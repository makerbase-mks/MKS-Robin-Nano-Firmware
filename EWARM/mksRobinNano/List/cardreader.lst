###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:02
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\cardreader.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\cardreader.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char const *strstr(char const *, char const *)
   \                     _Z6strstrPKcS0_: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
   \                     _Z6strstrPcPKc: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     23          #include "MarlinConfig.h"
     24          #include "fatfs.h"
     25          #include "mks_cfg.h"
     26          #include "mks_reprint.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 524 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

   \                                 In section .text, align 2
   \   __code __interwork __softfp SdBaseFile::SdBaseFile()
   \                     _ZN10SdBaseFileC1Ev: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x7001             STRB     R1,[R0, #+0]
   \   00000004   0x70C1             STRB     R1,[R0, #+3]
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \   00000000   0xF8D0 0x0200      LDR      R0,[R0, #+512]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??isFileOpen_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??isFileOpen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
     27          #include "usb_host.h"
     28          
     29          #include "draw_ui.h"

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_en.h",135  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_CN            "่งฃ้ค็ปๅฎ?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_s_cn.h",218  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 213)

    #define FILAMENT_CHANGE_TEXT_T_CN				"ๅพๆๅฐๆฉๆซๅๅ,\n่ซๆ<้ฒๆ>ๆ<้ๆ>"
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_t_cn.h",127  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_ru.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_ru.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 225)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_fr.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_fr.h",233  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 229)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_sp.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_it.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_it.h",229  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 224)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Multi_language.h",651  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 644)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Multi_language.h",859  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 853)

  #define Simple_Dec"ผ๕ษู"
                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",495  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "หูถศ"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",550  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          547)

  #define Complex_Speed "หูถศ"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",551  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          548)
     30          
     31          
     32          #if ENABLED(SDSUPPORT)
     33          
     34          
     35          #include "cardreader.h"
     36          #include "sdio_sdcard.h"

  #define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",152  Warning[Pe047]: 
          incompatible redefinition of macro "IS_NVIC_PRIORITY_GROUP"
          (declared at line 277 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SYSTICK_CLK_SOURCE" (declared
          at line 296 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define SDIO_INIT_CLK_DIV        0x166//0xB2 		//SDIOณ๕สผปฏฦตยสฃฌื๎ด๓400Kh  
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",36  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_INIT_CLK_DIV" (declared at
          line 479 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SDIO_TRANSFER_CLK_DIV    0x07//0x02//0x01		//SDIOดซสไฦตยสฃฌื๎ด๓24Mhz(4bit)กฃธรึตฬซะกฟษฤปแตผึยถมะดฮฤผณ๖ดํ 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",37  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_TRANSFER_CLK_DIV" (declared
          at line 482 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SD_CMD_GO_IDLE_STATE                       ((u8)0)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IDLE_STATE" (declared
          at line 304 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_OP_COND                        ((u8)1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",171  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_OP_COND" (declared
          at line 305 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ALL_SEND_CID                        ((u8)2)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",172  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ALL_SEND_CID" (declared
          at line 306 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_REL_ADDR                        ((u8)3) /*!< SDIO_SEND_REL_ADDR for SD Card */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_REL_ADDR" (declared
          at line 307 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_DSR                             ((u8)4)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_DSR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_SEN_OP_COND                    ((u8)5)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",175  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_SEN_OP_COND"
          (declared at line 309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SWITCH                           ((u8)6)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",176  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SWITCH" (declared at
          line 311 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEL_DESEL_CARD                      ((u8)7)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",177  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEL_DESEL_CARD" (declared
          at line 312 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SEND_EXT_CSD                     ((u8)8)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",178  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SEND_EXT_CSD"
          (declared at line 313 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CSD                            ((u8)9)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",179  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CSD" (declared at
          line 315 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CID                            ((u8)10)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",180  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CID" (declared at
          line 316 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_DAT_UNTIL_STOP                 ((u8)11) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",181  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_DAT_UNTIL_STOP"
          (declared at line 317 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_STOP_TRANSMISSION                   ((u8)12)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_STOP_TRANSMISSION"
          (declared at line 318 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_STATUS                         ((u8)13)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",183  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_STATUS" (declared at
          line 319 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_READ                     ((u8)14)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",184  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_READ"
          (declared at line 320 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_INACTIVE_STATE                   ((u8)15)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_INACTIVE_STATE"
          (declared at line 321 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCKLEN                        ((u8)16)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",186  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCKLEN" (declared
          at line 322 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_SINGLE_BLOCK                   ((u8)17)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",187  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_SINGLE_BLOCK"
          (declared at line 325 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_MULT_BLOCK                     ((u8)18)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",188  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_MULT_BLOCK"
          (declared at line 327 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_WRITE                    ((u8)19)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",189  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_WRITE"
          (declared at line 329 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_DAT_UNTIL_STOP                ((u8)20) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",190  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_DAT_UNTIL_STOP"
          (declared at line 330 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCK_COUNT                     ((u8)23) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",191  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCK_COUNT"
          (declared at line 331 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_SINGLE_BLOCK                  ((u8)24)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",192  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_SINGLE_BLOCK"
          (declared at line 332 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_MULT_BLOCK                    ((u8)25)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",193  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_MULT_BLOCK"
          (declared at line 334 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CID                            ((u8)26)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CID" (declared at
          line 335 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CSD                            ((u8)27)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",195  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CSD" (declared at
          line 336 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_WRITE_PROT                      ((u8)28)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",196  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_WRITE_PROT" (declared
          at line 337 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_CLR_WRITE_PROT                      ((u8)29)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_CLR_WRITE_PROT" (declared
          at line 338 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_WRITE_PROT                     ((u8)30)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",198  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_WRITE_PROT"
          (declared at line 339 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_START                  ((u8)32) /*!< To set the address of the first write
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",199  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_START"
          (declared at line 340 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_END                    ((u8)33) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",201  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_END"
          (declared at line 341 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_START                     ((u8)35) /*!< To set the address of the first write block to be erased.
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",203  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_START"
          (declared at line 342 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_END                       ((u8)36) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",206  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_END" (declared
          at line 344 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE                               ((u8)38)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE" (declared at line
          346 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_FAST_IO                             ((u8)39) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",210  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_FAST_IO" (declared at
          line 347 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_IRQ_STATE                        ((u8)40) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",211  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IRQ_STATE" (declared
          at line 348 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_LOCK_UNLOCK                         ((u8)42)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_LOCK_UNLOCK" (declared at
          line 349 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_CMD                             ((u8)55)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",213  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_CMD" (declared at
          line 351 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GEN_CMD                             ((u8)56)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",214  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GEN_CMD" (declared at
          line 353 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_NO_CMD                              ((u8)64)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",215  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_NO_CMD" (declared at line
          355 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_SD_SET_BUSWIDTH                 ((u8)6)  /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_SD_SET_BUSWIDTH"
          (declared at line 361 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_STAUS                        ((u8)13) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",222  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_STAUS" (declared
          at line 2841 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS        ((u8)22) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",223  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS" (declared at line 364 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_OP_COND                      ((u8)41) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",224  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_OP_COND" (declared
          at line 366 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CLR_CARD_DETECT          ((u8)42) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",225  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SET_CLR_CARD_DETECT" (declared at line 368 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SEND_SCR                     ((u8)51) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",226  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SEND_SCR"
          (declared at line 369 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_DIRECT                      ((u8)52) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",227  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_DIRECT" (declared
          at line 370 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_EXTENDED                    ((u8)53) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",228  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_EXTENDED"
          (declared at line 371 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MKB                      ((u8)43) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",234  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MKB" (declared
          at line 377 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MID                      ((u8)44) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",235  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MID" (declared
          at line 378 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RN1                  ((u8)45) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",236  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RN1"
          (declared at line 379 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RN2                  ((u8)46) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",237  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RN2"
          (declared at line 380 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RES2                 ((u8)47) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",238  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RES2"
          (declared at line 381 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RES1                 ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RES1"
          (declared at line 382 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK   ((u8)18) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",240  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK" (declared at line 383 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK  ((u8)25) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",241  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK" (declared at line 384 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_ERASE                 ((u8)38) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",242  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_ERASE"
          (declared at line 385 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_CHANGE_SECURE_AREA           ((u8)49) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",243  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_CHANGE_SECURE_AREA"
          (declared at line 386 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MKB             ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",244  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_WRITE_MKB"
          (declared at line 387 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define NULL 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "NULL" (declared at line 22 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench
          7.0\arm\inc\c\stdio.h")

  #define SD_OCR_CID_CSD_OVERWRIETE       ((u32)0x00010000)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",278  Warning[Pe047]: 
          incompatible redefinition of macro "SD_OCR_CID_CSD_OVERWRIETE"
          (declared at line 2840 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_DATATIMEOUT                  ((u32)0x000FFFFF)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",310  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DATATIMEOUT" (declared at
          line 78 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Inc\bsp_driver_sd.h")
     37          
     38          //#include "ultralcd.h"
     39          //#include "stepper.h"
     40          //#include "language.h"
     41          
     42          //#define LONGEST_FILENAME (longFilename[0] ? longFilename : filename)
     43          

   \                                 In section .text, align 2, keep-with-next
     44          CardReader::CardReader() {
   \                     _ZN10CardReaderC1Ev: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xF504 0x608E      ADD      R0,R4,#+1136
   \   00000008   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
     45              sdmode = 0;			
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xF884 0x046C      STRB     R0,[R4, #+1132]
     46          	sdprinting = false;
   \   00000012   0xF884 0x09B8      STRB     R0,[R4, #+2488]
     47          	cardOK = false;	
   \   00000016   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0x70C1             STRB     R1,[R0, #+3]
     48          	usbOK = false;
   \   0000001E   0x7101             STRB     R1,[R0, #+4]
     49              savetosd = false;
   \   00000020   0x4608             MOV      R0,R1
   \   00000022   0xF884 0x046D      STRB     R0,[R4, #+1133]
     50          }
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0xBD10             POP      {R4,PC}          ;; return
     51          

   \                                 In section .text, align 2, keep-with-next
     52          void CardReader::automount()	{}
   \                     _ZN10CardReader9automountEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
     53          void CardReader::checkautostart(bool force)
     54          {
     55          #if 0
     56            if(usbOK == false)        //U?จฌ??จฎD1จฐ??
     57            {
     58              if (SD_DET_IP != SD_DETECT_INVERTED)    
     59              {
     60                  if(cardOK || sdprinting)   // Card removed
     61                  {
     62          			SERIAL_ECHO_START();
     63          			SERIAL_ECHOLNPGM("SD card removed");
     64                      
     65                      FATFS_UnLinkDriver(SD_Path); 
     66                      unmount();
     67                  }
     68              }
     69              else
     70              {
     71                  if(!cardOK)
     72                  {
     73          			SERIAL_ECHO_START();
     74          			SERIAL_ECHOLNPGM("SD card inserted");
     75                      
     76                      FATFS_LinkDriver(&SD_Driver, SD_Path);
     77                      initsd();
     78                  }
     79              }
     80            }
     81            #endif
     82          #if unused //
     83            if (SD_DET_IP != SD_DETECT_INVERTED)  //?TSD?กง,?จฌ2aฆฬ?U?จฌก๊?1จฐ??
     84            {
     85              if((usbOK == false)&& (Appli_state == APPLICATION_READY))
     86              {
     87          		SERIAL_ECHO_START();
     88          		SERIAL_ECHOLNPGM("USB inserted");
     89                  
     90                  FATFS_LinkDriver(&USBH_Driver, USBH_Path);
     91                
     92                  f_mount(&fs, (TCHAR const*)USBH_Path, 0);
     93          		usbOK = true;
     94                  Appli_state = APPLICATION_IDLE;
     95                
     96              }
     97            } 
     98            
     99            if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?จฌ2aฆฬ?U?จฌ???aก๊?D???
    100            {
    101              //unmount();
    102              sdprinting = false;
    103          	usbOK = false;
    104          	SERIAL_ECHO_START();
    105          	SERIAL_ECHOLNPGM("USB removed");
    106              
    107              FATFS_UnLinkDriver(USBH_Path);
    108            }
    109          #endif
    110          }
   \                     _ZN10CardReader14checkautostartEb: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    111          #if 1
    112          

   \                                 In section .text, align 2, keep-with-next
    113          void CardReader::checkFilesys(unsigned char filesys)
    114          {
   \                     _ZN10CardReader12checkFilesysEh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    115          #if 1
    116          	switch(filesys)
   \   00000004   0x2901             CMP      R1,#+1
   \   00000006   0xD127             BNE.N    ??checkFilesys_0
    117          	{
    118          	case FILE_SYS_SD:
    119          	  //if(filesys == FILE_SYS_SD)        //U?จฌ??จฎD1จฐ??
    120          	  {
    121          	      if (SD_DET_IP != SD_DETECT_INVERTED)    
                 	                    ^
Warning[Pa118]: mixing boolean and non-boolean types in a comparison results
          in the boolean being promoted
   \   00000008   0xF604 0x15B8      ADDW     R5,R4,#+2488
   \   0000000C   0x78E8             LDRB     R0,[R5, #+3]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable38_3  ;; 0x42228130
   \   00000012   0x6809             LDR      R1,[R1, #+0]
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD010             BEQ.N    ??checkFilesys_1
    122          	      {
    123          	        if(cardOK || sdprinting)   // Card removed
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD103             BNE.N    ??checkFilesys_2
   \   0000001C   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD019             BEQ.N    ??checkFilesys_0
    124          	        {
    125          				SERIAL_ECHO_START();
   \                     ??checkFilesys_2: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable38_4
   \   00000028   0x.... 0x....      BL       _Z14serialprintPGMPKc
    126          				SERIAL_ECHOLNPGM("SD card removed");
   \   0000002C   0x.... 0x....      ADR.W    R0,`?<Constant "SD card removed\\n">`
   \   00000030   0x.... 0x....      BL       _Z14serialprintPGMPKc
    127          	            cardOK = false;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x70E8             STRB     R0,[R5, #+3]
   \   00000038   0xBD31             POP      {R0,R4,R5,PC}
    128          	            //FATFS_UnLinkDriver(SD_Path); 
    129          	            //unmount();
    130          	        }
    131          	      }
    132          	      else
    133          	      {
    134          	        if(!cardOK)
   \                     ??checkFilesys_1: (+1)
   \   0000003A   0x2800             CMP      R0,#+0
   \   0000003C   0xD10C             BNE.N    ??checkFilesys_0
    135          	        {
    136          				SERIAL_ECHO_START();
   \   0000003E   0x.... 0x....      LDR.W    R0,??DataTable38_4
   \   00000042   0x.... 0x....      BL       _Z14serialprintPGMPKc
    137          				SERIAL_ECHOLNPGM("Select SD file system");
   \   00000046   0x.... 0x....      ADR.W    R0,`?<Constant "Select SD file system\\n">`
   \   0000004A   0x.... 0x....      BL       _Z14serialprintPGMPKc
    138          	            //FATFS_LinkDriver_sd(&SD_Driver, SD_Path);
    139          	            //SD_Init();
    140          	            initsd();
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       _ZN10CardReader6initsdEv
    141          				usbOK = false;
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x7128             STRB     R0,[R5, #+4]
    142          	        }
    143          	      }
    144          	  }
    145          	 break;
    146          	 case FILE_SYS_USB:
    147          #if unused
    148          	  //if (SD_DET_IP != SD_DETECT_INVERTED)  //?TSD?กง,?จฌ2aฆฬ?U?จฌก๊?1จฐ??
    149          		  {
    150          		    if((usbOK == false)&& (Appli_state == APPLICATION_READY))
    151          		    {
    152          				SERIAL_ECHO_START();
    153          				SERIAL_ECHOLNPGM("Select USB file system");
    154          		        FATFS_LinkDriver_usb(&USBH_Driver, USBH_Path);
    155          		      
    156          		        f_mount(&fs, (TCHAR const*)USBH_Path, 0);
    157          				usbOK = true;
    158          				cardOK = false;
    159          		        Appli_state = APPLICATION_IDLE;
    160          		      
    161          		    }
    162          		  } 
    163          	  	  if((Appli_state == APPLICATION_DISCONNECT) &&(usbOK == true))     //?จฌ2aฆฬ?U?จฌ???aก๊?D???
    164          		  {
    165          		    //unmount();
    166          		    sdprinting = false;
    167          			usbOK = false;
    168          			SERIAL_ECHO_START();
    169          			SERIAL_ECHOLNPGM("USB removed");
    170          		    
    171          		    FATFS_UnLinkDriver(USBH_Path);
    172          		  }
    173          #endif
    174          	  break;
    175          	  default:break;
    176          	}
    177              #endif
    178          }
   \                     ??checkFilesys_0: (+1)
   \   00000058   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    179          #endif
    180          #if 0
    181          char *createFilename(char *buffer, const dir_t &p) { //buffer > 12characters
    182            char *pos = buffer;
    183            for (uint8_t i = 0; i < 11; i++) {
    184              if (p.name[i] == ' ') continue;
    185              if (i == 8) *pos++ = '.';
    186              *pos++ = p.name[i];
    187            }
    188            *pos++ = 0;
    189            return buffer;
    190          }
    191          
    192          /**
    193           * Dive into a folder and recurse depth-first to perform a pre-set operation lsAction:
    194           *   LS_Count       - Add +1 to nrFiles for every file within the parent
    195           *   LS_GetFilename - Get the filename of the file indexed by nrFile_index
    196           *   LS_SerialPrint - Print the full path and size of each file to serial output
    197           */
    198          
    199          uint16_t nrFile_index;
    200          
    201          void CardReader::lsDive(const char *prepend, SdFile parent, const char * const match/*=NULL*/) {
    202            dir_t p;
    203            uint8_t cnt = 0;
    204          
    205            // Read the next entry from a directory
    206            while (parent.readDir(p, longFilename) > 0) {
    207          
    208              // If the entry is a directory and the action is LS_SerialPrint
    209              if (DIR_IS_SUBDIR(&p) && lsAction != LS_Count && lsAction != LS_GetFilename) {
    210          
    211                // Get the short name for the item, which we know is a folder
    212                char lfilename[FILENAME_LENGTH];
    213                createFilename(lfilename, p);
    214          
    215                // Allocate enough stack space for the full path to a folder, trailing slash, and nul
    216                bool prepend_is_empty = (prepend[0] == '\0');
    217                int len = (prepend_is_empty ? 1 : strlen(prepend)) + strlen(lfilename) + 1 + 1;
    218                char path[len];
    219          
    220                // Append the FOLDERNAME12/ to the passed string.
    221                // It contains the full path to the "parent" argument.
    222                // We now have the full path to the item in this folder.
    223                strcpy(path, prepend_is_empty ? "/" : prepend); // root slash if prepend is empty
    224                strcat(path, lfilename); // FILENAME_LENGTH-1 characters maximum
    225                strcat(path, "/");       // 1 character
    226          
    227                // Serial.print(path);
    228          
    229                // Get a new directory object using the full path
    230                // and dive recursively into it.
    231                SdFile dir;
    232                if (!dir.open(parent, lfilename, O_READ)) {
    233                  if (lsAction == LS_SerialPrint) {
    234                    SERIAL_ECHO_START();
    235                    SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
    236                    SERIAL_ECHOLN(lfilename);
    237                  }
    238                }
    239                lsDive(path, dir);
    240                // close() is done automatically by destructor of SdFile
    241              }
    242              else {
    243                uint8_t pn0 = p.name[0];
    244                if (pn0 == DIR_NAME_FREE) break;
    245                if (pn0 == DIR_NAME_DELETED || pn0 == '.') continue;
    246                if (longFilename[0] == '.') continue;
    247          
    248                if (!DIR_IS_FILE_OR_SUBDIR(&p) || (p.attributes & DIR_ATT_HIDDEN)) continue;
    249          
    250                filenameIsDir = DIR_IS_SUBDIR(&p);
    251          
    252                if (!filenameIsDir && (p.name[8] != 'G' || p.name[9] == '~')) continue;
    253          
    254                switch (lsAction) {  // 1 based file count
    255                  case LS_Count:
    256                    nrFiles++;
    257                    break;
    258          
    259                  case LS_SerialPrint:
    260                    createFilename(filename, p);
    261                    SERIAL_PROTOCOL(prepend);
    262                    SERIAL_PROTOCOL(filename);
    263                    SERIAL_PROTOCOLCHAR(' ');
    264                    SERIAL_PROTOCOLLN(p.fileSize);
    265                    break;
    266          
    267                  case LS_GetFilename:
    268                    createFilename(filename, p);
    269                    if (match != NULL) {
    270                      if (strcasecmp(match, filename) == 0) return;
    271                    }
    272                    else if (cnt == nrFile_index) return;  // 0 based index
    273                    cnt++;
    274                    break;
    275                }
    276          
    277              }
    278            } // while readDir
    279          }
    280          
    281          void CardReader::ls() {
    282            lsAction = LS_SerialPrint;
    283            root.rewind();
    284            lsDive("", root);
    285          }
    286          
    287          #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
    288          
    289            /**
    290             * Get a long pretty path based on a DOS 8.3 path
    291             */
    292            void CardReader::printLongPath(char *path) {
    293              lsAction = LS_GetFilename;
    294          
    295              int i, pathLen = strlen(path);
    296          
    297              // SERIAL_ECHOPGM("Full Path: "); SERIAL_ECHOLN(path);
    298          
    299              // Zero out slashes to make segments
    300              for (i = 0; i < pathLen; i++) if (path[i] == '/') path[i] = '\0';
    301          
    302              SdFile diveDir = root; // start from the root for segment 1
    303              for (i = 0; i < pathLen;) {
    304          
    305                if (path[i] == '\0') i++; // move past a single nul
    306          
    307                char *segment = &path[i]; // The segment after most slashes
    308          
    309                // If a segment is empty (extra-slash) then exit
    310                if (!*segment) break;
    311          
    312                // Go to the next segment
    313                while (path[++i]) { }
    314          
    315                // SERIAL_ECHOPGM("Looking for segment: "); SERIAL_ECHOLN(segment);
    316          
    317                // Find the item, setting the long filename
    318                diveDir.rewind();
    319                lsDive("", diveDir, segment);
    320          
    321                // Print /LongNamePart to serial output
    322                SERIAL_PROTOCOLCHAR('/');
    323                SERIAL_PROTOCOL(longFilename[0] ? longFilename : "???");
    324          
    325                // If the filename was printed then that's it
    326                if (!filenameIsDir) break;
    327          
    328                // SERIAL_ECHOPGM("Opening dir: "); SERIAL_ECHOLN(segment);
    329          
    330                // Open the sub-item as the new dive parent
    331                SdFile dir;
    332                if (!dir.open(diveDir, segment, O_READ)) {
    333                  SERIAL_EOL();
    334                  SERIAL_ECHO_START();
    335                  SERIAL_ECHOPGM(MSG_SD_CANT_OPEN_SUBDIR);
    336                  SERIAL_ECHO(segment);
    337                  break;
    338                }
    339          
    340                diveDir.close();
    341                diveDir = dir;
    342          
    343              } // while i<pathLen
    344          
    345              SERIAL_EOL();
    346            }
    347          
    348          #endif // LONG_FILENAME_HOST_SUPPORT
    349          
    350          void CardReader::setroot() {
    351            /*if (!workDir.openRoot(&volume)) {
    352              SERIAL_ECHOLNPGM(MSG_SD_WORKDIR_FAIL);
    353            }*/
    354            workDir = root;
    355            curDir = &workDir;
    356            #if ENABLED(SDCARD_SORT_ALPHA)
    357              presort();
    358            #endif
    359          }
    360          
    361          #endif

   \                                 In section .text, align 2, keep-with-next
    362          void CardReader::initsd()
    363          {
   \                     _ZN10CardReader6initsdEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    364          	FRESULT mksMountState = FR_DISK_ERR;
    365          	cardOK = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x09BB      STRB     R0,[R4, #+2491]
    366          	
    367          	if( SD_DET_IP != SD_DETECT_INVERTED)
                 	              ^
Warning[Pa118]: mixing boolean and non-boolean types in a comparison results
          in the boolean being promoted

  	FRESULT mksMountState = FR_DISK_ERR;
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.cpp",364  Warning[Pe177]: 
          variable "mksMountState" was declared but never referenced
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable38_3  ;; 0x42228130
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD11C             BNE.N    ??initsd_0
    368          		return;
    369          
    370          	if(f_mount(&fs, (TCHAR const*)SD_Path, 0) != FR_OK)	
   \   00000014   0x.... 0x....      LDR.W    R5,??DataTable38_4
   \   00000018   0x2200             MOVS     R2,#+0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable38_5
   \   0000001E   0xF504 0x700B      ADD      R0,R4,#+556
   \   00000022   0x.... 0x....      BL       f_mount
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0xD007             BEQ.N    ??initsd_1
    371          	{
    372          		SERIAL_ECHO_START();
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    373          		SERIAL_ECHOLNPGM(MSG_SD_INIT_FAIL);
   \   00000030   0x.... 0x....      ADR.W    R0,`?<Constant "SD init fail\\n">`
   \   00000034   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000038   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    374          	}
    375          	else
    376          	{
    377          		SERIAL_ECHO_START();
   \                     ??initsd_1: (+1)
   \   0000003C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    378          		SERIAL_ECHOLNPGM(MSG_SD_CARD_OK);
   \   00000040   0x.... 0x....      ADR.W    R0,`?<Constant "SD card ok\\n">`
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
    379          		cardOK = true;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x09BB      STRB     R0,[R4, #+2491]
    380          	}
    381          }
   \                     ??initsd_0: (+1)
   \   0000004E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    382          #if 1
    383          

   \                                 In section .text, align 2, keep-with-next
    384          void CardReader::initusb()
    385          {
    386          #if unused
    387          	FRESULT mksMountState = FR_DISK_ERR;
    388          	usbOK = false;
    389          
    390          	if(f_mount(&fs, (TCHAR const*)USBH_Path, 0) != FR_OK)	
    391          	{
    392          		SERIAL_ECHO_START();
    393          		SERIAL_ECHOLNPGM("USB init fail");
    394          	}
    395          	else
    396          	{
    397          		SERIAL_ECHO_START();
    398          		SERIAL_ECHOLNPGM("USB OK");
    399          		usbOK = true;
    400          	}
    401          #endif
    402          }
   \                     _ZN10CardReader7initusbEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    403          #endif

   \                                 In section .text, align 2, keep-with-next
    404          void CardReader::mount()
    405          {
    406              sdmode = false;	sdprinting = false;
   \                     _ZN10CardReader5mountEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    407              initsd();
   \   0000000A   0x....             B.N      _ZN10CardReader6initsdEv
    408          }
    409          

   \                                 In section .text, align 2, keep-with-next
    410          void CardReader::unmount()
    411          {
    412              sdmode = false;		sdprinting = false;
   \                     _ZN10CardReader7unmountEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    413          	cardOK = false;
   \   0000000A   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    414              savetosd = false;	
   \   0000000E   0xF880 0x146D      STRB     R1,[R0, #+1133]
    415           #if 0   //lite mask   
    416          #if UI_DISPLAY_TYPE!=0 && SDSUPPORT
    417              uid.cwd[0]='/';
    418              uid.cwd[1]=0;
    419              uid.folderLevel=0;
    420          #endif
    421          #endif    //lite mask
    422          }
   \   00000012   0x4770             BX       LR               ;; return
    423          
    424          
    425          

   \                                 In section .text, align 2, keep-with-next
    426          void CardReader::release() {
    427              sdmode = false;		
   \                     _ZN10CardReader7releaseEv: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xF880 0x146C      STRB     R1,[R0, #+1132]
    428          	sdprinting = false;	
   \   00000006   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    429          	cardOK = false;
   \   0000000A   0xF880 0x19BB      STRB     R1,[R0, #+2491]
    430              savetosd = false;	
   \   0000000E   0xF880 0x146D      STRB     R1,[R0, #+1133]
    431          
    432          }
   \   00000012   0x4770             BX       LR               ;; return
    433          #if 0
    434          void CardReader::openAndPrintFile(const char *name) {
    435            char cmd[4 + strlen(name) + 1]; // Room for "M23 ", filename, and null
    436            sprintf_P(cmd, PSTR("M23 %s"), name);
    437            for (char *c = &cmd[4]; *c; c++) *c = tolower(*c);
    438            enqueue_and_echo_command(cmd);
    439            enqueue_and_echo_commands_P(PSTR("M24"));
    440          }
    441          #endif
    442          

   \                                 In section .text, align 2, keep-with-next
    443          void CardReader::startPrint()
    444          {
    445              if(!cardOK) return;
   \                     _ZN10CardReader10startPrintEv: (+1)
   \   00000000   0xF890 0x19BB      LDRB     R1,[R0, #+2491]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD004             BEQ.N    ??startPrint_0
    446              sdmode = true;	
   \   00000008   0x2101             MOVS     R1,#+1
   \   0000000A   0xF880 0x146C      STRB     R1,[R0, #+1132]
    447          	sdprinting = true;
   \   0000000E   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    448          }
   \                     ??startPrint_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return
    449          
    450          //volatile int textt;

   \                                 In section .text, align 2, keep-with-next
    451          void CardReader::startFileprint() {
    452            if (cardOK || usbOK) {
   \                     _ZN10CardReader14startFileprintEv: (+1)
   \   00000000   0xF600 0x11B8      ADDW     R1,R0,#+2488
   \   00000004   0x78CA             LDRB     R2,[R1, #+3]
   \   00000006   0x2A00             CMP      R2,#+0
   \   00000008   0xD102             BNE.N    ??startFileprint_0
   \   0000000A   0x7909             LDRB     R1,[R1, #+4]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD016             BEQ.N    ??startFileprint_1
    453              sdprinting = true; sdmode = true;
   \                     ??startFileprint_0: (+1)
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0xF880 0x19B8      STRB     R1,[R0, #+2488]
   \   00000016   0xF880 0x146C      STRB     R1,[R0, #+1132]
    454              #if ENABLED(SDCARD_SORT_ALPHA)
    455                flush_presort();
    456              #endif
    457          
    458          	mksReprint.mks_printer_state = MKS_WORKING;
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable38_6
   \   0000001E   0x21A7             MOVS     R1,#+167
   \   00000020   0xF880 0x10E0      STRB     R1,[R0, #+224]
    459              if(gCfgItems.pwroff_save_mode != 1)
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable38_7
   \   00000028   0xF891 0x119F      LDRB     R1,[R1, #+415]
   \   0000002C   0x2901             CMP      R1,#+1
   \   0000002E   0xD006             BEQ.N    ??startFileprint_1
    460          	    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0xF100 0x01E0      ADD      R1,R0,#+224
   \   00000036   0xF44F 0x6096      MOV      R0,#+1200
   \   0000003A   0x.... 0x....      B.W      epr_write_data
    461              //epr_read_data(EPR_SAV_FLAG, (uint8_t *)&textt,sizeof(mksReprint.mks_printer_state));
    462            }
    463          }
   \                     ??startFileprint_1: (+1)
   \   0000003E   0x4770             BX       LR               ;; return
    464          

   \                                 In section .text, align 2, keep-with-next
    465          void CardReader::pausePrint(bool intern)
    466          {
    467              if(!card.cardOK) return;
   \                     _ZN10CardReader10pausePrintEb: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_8
   \   00000004   0xF891 0x19BB      LDRB     R1,[R1, #+2491]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD002             BEQ.N    ??pausePrint_0
    468              sdmode = 2; // finish running line
   \   0000000C   0x2102             MOVS     R1,#+2
   \   0000000E   0xF880 0x146C      STRB     R1,[R0, #+1132]
    469          
    470          	/*...*/
    471          	
    472          }
   \                     ??pausePrint_0: (+1)
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    473          void CardReader::pauseSDPrint()
    474          {
    475            if(sdprinting)
   \                     _ZN10CardReader12pauseSDPrintEv: (+1)
   \   00000000   0xF890 0x19B8      LDRB     R1,[R0, #+2488]
   \   00000004   0x2900             CMP      R1,#+0
   \   00000006   0xD005             BEQ.N    ??pauseSDPrint_0
    476            {
    477              sdprinting = false;	sdmode = 2;
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF880 0x19B8      STRB     R1,[R0, #+2488]
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0xF880 0x146C      STRB     R1,[R0, #+1132]
    478            }
    479          }
   \                     ??pauseSDPrint_0: (+1)
   \   00000014   0x4770             BX       LR               ;; return
    480          
    481          

   \                                 In section .text, align 2, keep-with-next
    482          void CardReader::continuePrint(bool intern)
    483          {
    484              if(!card.cardOK) return;
    485          #if 0
    486              if(intern) {
    487                 // GCode::executeFString(PSTR(PAUSE_END_COMMANDS));
    488                  Printer::GoToMemoryPosition(true, true, false, false, Printer::maxFeedrate[X_AXIS]);
    489                  Printer::GoToMemoryPosition(false, false, true, false, Printer::maxFeedrate[Z_AXIS] / 2.0f);
    490                  Printer::GoToMemoryPosition(false, false, false, true, Printer::maxFeedrate[E_AXIS] / 2.0f);
    491              }
    492              //Printer::setMenuMode(MENU_MODE_SD_PAUSED, false);
    493              sdmode = 1;
    494              FALA_5V_CTRL = FALA_ON;    // กไจฐ?aกคกงจค-ฆฬ?จจY
    495          #endif    
    496          }
   \                     _ZN10CardReader13continuePrintEb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    497          void CardReader::stopSDPrint() {
   \                     _ZN10CardReader11stopSDPrintEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    498            sdprinting = false;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    499            if (isFileOpen()) closefile();
   \   0000000A   0x4620             MOV      R0,R4
   \   0000000C   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD004             BEQ.N    ??stopSDPrint_0
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001C   0x....             B.N      _ZN10CardReader9closefileEb
    500          }
   \                     ??stopSDPrint_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
    501          void CardReader::stopPrint()
    502          {
    503              if(!card.cardOK) return;
   \                     _ZN10CardReader9stopPrintEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_8
   \   00000004   0xF891 0x19BB      LDRB     R1,[R1, #+2491]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD004             BEQ.N    ??stopPrint_0
    504              sdmode = 0;	sdprinting = false;	
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   00000012   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    505          }
   \                     ??stopPrint_0: (+1)
   \   00000016   0x4770             BX       LR               ;; return
    506          

   \                                 In section .text, align 2, keep-with-next
    507          void CardReader::operatePrint()
    508          {
    509               
    510          }
   \                     _ZN10CardReader12operatePrintEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    511          char *CardReader::createFilename(char *buffer,const dir_t &p)
    512          {
   \                     _ZN10CardReader14createFilenameEPcRK14directoryEntry: (+1)
   \   00000000   0xB410             PUSH     {R4}
    513              char *pos = buffer,*src = (char*)p.name;
    514              for (uint8_t i = 0; i < 11; i++,src++)
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0xE00D             B.N      ??createFilename_0
    515              {
    516                  if (*src == ' ') continue;
   \                     ??createFilename_1: (+1)
   \   00000006   0xF992 0x4000      LDRSB    R4,[R2, #+0]
   \   0000000A   0x2C20             CMP      R4,#+32
   \   0000000C   0xD007             BEQ.N    ??createFilename_2
    517                  if (i == 8)
   \   0000000E   0x2B08             CMP      R3,#+8
   \   00000010   0xD102             BNE.N    ??createFilename_3
    518                      *pos++ = '.';
   \   00000012   0x232E             MOVS     R3,#+46
   \   00000014   0xF801 0x3B01      STRB     R3,[R1], #+1
    519                  *pos++ = *src;
   \                     ??createFilename_3: (+1)
   \   00000018   0x7813             LDRB     R3,[R2, #+0]
   \   0000001A   0xF801 0x3B01      STRB     R3,[R1], #+1
    520              }
   \                     ??createFilename_2: (+1)
   \   0000001E   0x1C40             ADDS     R0,R0,#+1
   \   00000020   0x1C52             ADDS     R2,R2,#+1
   \                     ??createFilename_0: (+1)
   \   00000022   0xB2C0             UXTB     R0,R0
   \   00000024   0x4603             MOV      R3,R0
   \   00000026   0x2B0B             CMP      R3,#+11
   \   00000028   0xDBED             BLT.N    ??createFilename_1
    521              *pos = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
    522              return pos;
   \   0000002E   0x4608             MOV      R0,R1
   \   00000030   0xBC10             POP      {R4}
   \   00000032   0x4770             BX       LR               ;; return
    523          }

   \                                 In section .text, align 2, keep-with-next
    524          bool CardReader::showFilename(const uint8_t *name)
    525          {
    526              if (*name == DIR_NAME_DELETED || *name == '.') return false;
   \                     _ZN10CardReader12showFilenameEPKh: (+1)
   \   00000000   0x7808             LDRB     R0,[R1, #+0]
   \   00000002   0x28E5             CMP      R0,#+229
   \   00000004   0xD001             BEQ.N    ??showFilename_0
   \   00000006   0x282E             CMP      R0,#+46
   \   00000008   0xD101             BNE.N    ??showFilename_1
   \                     ??showFilename_0: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    527              return true;
   \                     ??showFilename_1: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
    528          }
    529          

   \                                 In section .text, align 2, keep-with-next
    530          int8_t RFstricmp(const char* s1, const char* s2)
    531          {
   \                     _Z9RFstricmpPKcS0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0xE001             B.N      ??RFstricmp_0
    532              while(*s1 && (tolower(*s1) == tolower(*s2)))
    533                  s1++,s2++;
   \                     ??RFstricmp_1: (+1)
   \   00000008   0x1C64             ADDS     R4,R4,#+1
   \   0000000A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RFstricmp_0: (+1)
   \   0000000C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD008             BEQ.N    ??RFstricmp_2
   \   00000014   0x.... 0x....      BL       tolower
   \   00000018   0x4606             MOV      R6,R0
   \   0000001A   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000001E   0x.... 0x....      BL       tolower
   \   00000022   0x4286             CMP      R6,R0
   \   00000024   0xD0F0             BEQ.N    ??RFstricmp_1
    534              return (const uint8_t)tolower(*s1)-(const uint8_t)tolower(*s2);
                             ^
Warning[Pe191]: type qualifier is meaningless on cast type

      return (const uint8_t)tolower(*s1)-(const uint8_t)tolower(*s2);
                                          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.cpp",534  Warning[Pe191]: 
          type qualifier is meaningless on cast type
   \                     ??RFstricmp_2: (+1)
   \   00000026   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000002A   0x.... 0x....      BL       tolower
   \   0000002E   0x4604             MOV      R4,R0
   \   00000030   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000034   0x.... 0x....      BL       tolower
   \   00000038   0x1A20             SUBS     R0,R4,R0
   \   0000003A   0xB240             SXTB     R0,R0
   \   0000003C   0xBD70             POP      {R4-R6,PC}       ;; return
    535          }
    536          

   \                                 In section .text, align 2, keep-with-next
    537          int8_t RFstrnicmp(const char* s1, const char* s2, size_t n)
    538          {
   \                     _Z10RFstrnicmpPKcS0_j: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x4616             MOV      R6,R2
   \   00000008   0xE001             B.N      ??RFstrnicmp_0
    539              while(n--)
    540              {
    541                  if(tolower(*s1)!=tolower(*s2))
    542                      return (uint8_t)tolower(*s1) - (uint8_t)tolower(*s2);
    543                  s1++;
   \                     ??RFstrnicmp_1: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
    544                  s2++;
   \   0000000C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??RFstrnicmp_0: (+1)
   \   0000000E   0x4630             MOV      R0,R6
   \   00000010   0x1E46             SUBS     R6,R0,#+1
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD016             BEQ.N    ??RFstrnicmp_2
   \   00000016   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   0000001A   0x.... 0x....      BL       tolower
   \   0000001E   0x4607             MOV      R7,R0
   \   00000020   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   00000024   0x.... 0x....      BL       tolower
   \   00000028   0x4287             CMP      R7,R0
   \   0000002A   0xD0EE             BEQ.N    ??RFstrnicmp_1
   \   0000002C   0xF994 0x0000      LDRSB    R0,[R4, #+0]
   \   00000030   0x.... 0x....      BL       tolower
   \   00000034   0x4604             MOV      R4,R0
   \   00000036   0xF995 0x0000      LDRSB    R0,[R5, #+0]
   \   0000003A   0x.... 0x....      BL       tolower
   \   0000003E   0x1A20             SUBS     R0,R4,R0
   \   00000040   0xB240             SXTB     R0,R0
   \   00000042   0xBDF2             POP      {R1,R4-R7,PC}
    545              }
    546              return 0;
   \                     ??RFstrnicmp_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    547          }
    548          

   \                                 In section .text, align 2, keep-with-next
    549          void CardReader::ls()
    550          {
    551              if ((SD_DET_IP == SD_DETECT_INVERTED)&&(usbOK == false))
                                    ^
Warning[Pa118]: mixing boolean and non-boolean types in a comparison results
          in the boolean being promoted
   \                     _ZN10CardReader2lsEv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable38_3  ;; 0x42228130
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD106             BNE.N    ??ls_0
   \   0000000A   0xF890 0x19BC      LDRB     R1,[R0, #+2492]
   \   0000000E   0x2900             CMP      R1,#+0
   \   00000010   0xD102             BNE.N    ??ls_0
    552                get_file_list(SD_Path);
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable38_5
   \   00000016   0x....             B.N      _ZN10CardReader13get_file_listEPc
    553              else
    554              {
    555          #if unused
    556                get_file_list(USBH_Path);
    557          #endif
    558              }
    559          }
   \                     ??ls_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
    560          

   \                                 In section .text, align 2, keep-with-next
    561          bool CardReader::selectFile(char *filename, bool silent){}
                                                                          ^
Warning[Pe940]: missing return statement at end of non-void function
          "CardReader::selectFile"
   \                     _ZN10CardReader10selectFileEPcb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    562          bool CardReader::reopenfile(char* filename)
    563          {
   \                     _ZN10CardReader10reopenfileEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    564              f_close(&curFile);
   \   00000006   0x.... 0x....      BL       f_close
    565              if(f_open(&curFile, (const TCHAR *)filename, FA_OPEN_EXISTING | FA_READ) == FR_OK)	
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       f_open
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD105             BNE.N    ??reopenfile_0
    566              {
    567                  filesize = curFile.fsize;
   \   00000018   0xF8D4 0x020C      LDR      R0,[R4, #+524]
   \   0000001C   0xF8C4 0x045C      STR      R0,[R4, #+1116]
    568                  return true;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0xBD32             POP      {R1,R4,R5,PC}
    569              }
    570              else
    571              {
    572                  return false;
   \                     ??reopenfile_0: (+1)
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xBD32             POP      {R1,R4,R5,PC}    ;; return
    573              }
    574          }

   \                                 In section .text, align 2, keep-with-next
    575          bool CardReader::openFile(char* filename,bool silent, bool replace_current/*=true*/)
    576          {
   \                     _ZN10CardReader8openFileEPcbb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0B0             SUB      SP,SP,#+192
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    577              SdBaseFile parent;
   \   00000008   0xA826             ADD      R0,SP,#+152
   \   0000000A   0x.... 0x....      BL       _ZN10SdBaseFileC1Ev
    578              char *oldP;
                           ^
Warning[Pe177]: variable "oldP" was declared but never referenced
    579              boolean bFound;
                             ^
Warning[Pe177]: variable "bFound" was declared but never referenced
    580              
    581              char newname[150]={0};
   \   0000000E   0xA800             ADD      R0,SP,#+0
   \   00000010   0x2198             MOVS     R1,#+152
   \   00000012   0x.... 0x....      BL       __aeabi_memclr4
    582                
    583          	  if(sdprinting)			return false;
   \   00000016   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD001             BEQ.N    ??openFile_0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xE050             B.N      ??openFile_1
    584          	  f_close(&curFile);
   \                     ??openFile_0: (+1)
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       f_close
    585          
    586            if(filename[2] != '/')     //???t??2?กไ??จฌกค??กค??
   \   00000028   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000002C   0x282F             CMP      R0,#+47
   \   0000002E   0xD00A             BEQ.N    ??openFile_2
    587            {    
    588             if(card.cardOK)
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable38_8
   \   00000034   0xF890 0x09BB      LDRB     R0,[R0, #+2491]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD033             BEQ.N    ??openFile_3
    589          	   strcat(newname,SD_Path);
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable38_5
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       strcat
    590          #if unused
    591             else if(card.usbOK)
    592          	   strcat(newname,USBH_Path);
    593          #endif
    594             else
    595                    return false;
    596            }
    597          	strcat(newname,filename);
   \                     ??openFile_2: (+1)
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       strcat
    598          
    599             mks_saveFileName(newname);
   \   0000004E   0x.... 0x....      BL       mks_saveFileName
    600          
    601          	if(f_open(&curFile, (const TCHAR *)newname, FA_OPEN_EXISTING | FA_READ) == FR_OK)					
   \   00000052   0x.... 0x....      LDR.W    R6,??DataTable38_9
   \   00000056   0x2201             MOVS     R2,#+1
   \   00000058   0xA900             ADD      R1,SP,#+0
   \   0000005A   0x4620             MOV      R0,R4
   \   0000005C   0x.... 0x....      BL       f_open
   \   00000060   0x2800             CMP      R0,#+0
   \   00000062   0xD121             BNE.N    ??openFile_4
    602                {
    603          
    604                  if(!silent)
    605                  {
    606                  }
    607          		
    608                  sdpos = 0;
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF8C4 0x0460      STR      R0,[R4, #+1120]
    609                  filesize = curFile.fsize;
   \   0000006A   0xF8D4 0x020C      LDR      R0,[R4, #+524]
   \   0000006E   0xF8C4 0x045C      STR      R0,[R4, #+1116]
    610                  SERIAL_PROTOCOLPAIR(MSG_SD_FILE_OPENED, filename);
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0x.... 0x....      ADR.W    R0,`?<Constant "File opened: ">`
   \   00000078   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    611          		SERIAL_PROTOCOLPGM(MSG_SD_SIZE);
   \   0000007C   0x.... 0x....      ADR.W    R0,`?<Constant " Size: ">`
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
    612          		SERIAL_PROTOCOL(filesize);
   \   00000084   0x220A             MOVS     R2,#+10
   \   00000086   0xF8D4 0x145C      LDR      R1,[R4, #+1116]
   \   0000008A   0x4630             MOV      R0,R6
   \   0000008C   0x.... 0x....      BL       _ZN5Print5printEji
    613                  SERIAL_EOL();
   \   00000090   0x210A             MOVS     R1,#+10
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    614          		SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
   \   00000098   0x.... 0x....      ADR.W    R0,`?<Constant "File selected\\n">`
   \   0000009C   0x.... 0x....      BL       _Z14serialprintPGMPKc
    615                  return true;
   \   000000A0   0x2001             MOVS     R0,#+1
   \   000000A2   0xE00F             B.N      ??openFile_1
    616              }
   \                     ??openFile_3: (+1)
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0xE00D             B.N      ??openFile_1
    617              else
    618              {
    619          		SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, filename);
   \                     ??openFile_4: (+1)
   \   000000A8   0x4629             MOV      R1,R5
   \   000000AA   0x.... 0x....      ADR.W    R0,`?<Constant "open failed, File: ">`
   \   000000AE   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
    620          		SERIAL_PROTOCOLCHAR('.');
   \   000000B2   0x212E             MOVS     R1,#+46
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    621          		SERIAL_EOL();
   \   000000BA   0x210A             MOVS     R1,#+10
   \   000000BC   0x4630             MOV      R0,R6
   \   000000BE   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    622              
    623                  if(!silent){}
    624             //         Com::printFLN(Com::tFileOpenFailed);
    625                  return false;
   \   000000C2   0x2000             MOVS     R0,#+0
   \                     ??openFile_1: (+1)
   \   000000C4   0xB030             ADD      SP,SP,#+192
   \   000000C6   0xBD70             POP      {R4-R6,PC}       ;; return
    626              }
    627          }
    628          

   \                                 In section .text, align 2, keep-with-next
    629          void CardReader::printStatus()
    630          {
    631          #if 0
    632              if(sdactive)
    633              {
    634                  Com::printF(Com::tSDPrintingByte, sdpos);
    635                  Com::printFLN(Com::tSlash, filesize);
    636              }
    637              else
    638              {
    639                  Com::printFLN(Com::tNotSDPrinting);
    640              }
    641          #endif	
    642          
    643          }
   \                     _ZN10CardReader11printStatusEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    644          

   \                                 In section .text, align 2, keep-with-next
    645          void CardReader::getStatus()
    646          {
   \                     _ZN10CardReader9getStatusEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
    647            if(cardOK || usbOK){
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD103             BNE.N    ??getStatus_0
   \   0000000C   0xF894 0x09BC      LDRB     R0,[R4, #+2492]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD01A             BEQ.N    ??getStatus_1
    648              SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);
   \                     ??getStatus_0: (+1)
   \   00000014   0x.... 0x....      ADR.W    R0,`?<Constant "SD printing byte ">`
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
    649              SERIAL_PROTOCOL(sdpos);
   \   0000001C   0x.... 0x....      LDR.W    R5,??DataTable38_9
   \   00000020   0x220A             MOVS     R2,#+10
   \   00000022   0xF8D4 0x1460      LDR      R1,[R4, #+1120]
   \   00000026   0x4628             MOV      R0,R5
   \   00000028   0x.... 0x....      BL       _ZN5Print5printEji
    650              SERIAL_PROTOCOLPGM("/");
   \   0000002C   0x....             ADR.N    R0,??DataTable35  ;; "/"
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
    651              SERIAL_PROTOCOLLN(filesize);
   \   00000032   0x220A             MOVS     R2,#+10
   \   00000034   0xF8D4 0x145C      LDR      R1,[R4, #+1116]
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN5Print5printEji
   \   0000003E   0x210A             MOVS     R1,#+10
   \   00000040   0x4628             MOV      R0,R5
   \   00000042   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000046   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    652            }
    653            else{
    654              SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);
   \                     ??getStatus_1: (+1)
   \   0000004A   0x.... 0x....      ADR.W    R0,`?<Constant "Not SD printing\\n">`
   \   0000004E   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000052   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    655            }
    656          }
    657          
    658          

   \                                 In section .text, align 2, keep-with-next
    659          void CardReader::startWrite(char *filename)
    660          {
   \                     _ZN10CardReader10startWriteEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    661           //char sdFileName[100];
    662            //memset(sdFileName,0,sizeof(sdFileName));
    663            
    664              if(!cardOK && ! usbOK) return;
   \   00000006   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000000A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??startWrite_0
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD012             BEQ.N    ??startWrite_1
    665                f_close(&card.curFile);
   \                     ??startWrite_0: (+1)
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable38_8
   \   0000001A   0x.... 0x....      BL       f_close
    666              sdmode = false;    sdprinting = false;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF884 0x046C      STRB     R0,[R4, #+1132]
   \   00000024   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    667              
    668              //fat.chdir();
    669          	
    670              //if(!file.open(filename, O_CREAT | O_APPEND | O_WRITE | O_TRUNC))
    671                  //strcat(sdFileName,SD_Path);
    672                  //strcat(sdFileName,filename);
    673          	if(f_open(&curFile, (const TCHAR *)filename, FA_CREATE_ALWAYS | FA_WRITE | FA_READ)  != FR_OK)
   \   00000028   0x220B             MOVS     R2,#+11
   \   0000002A   0x4629             MOV      R1,R5
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       f_open
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD102             BNE.N    ??startWrite_1
    674              {
    675               ///   Com::printFLN(Com::tOpenFailedFile,filename);
    676              }
    677              else
    678              {
    679            ///      UI_STATUS(UI_TEXT_UPLOADING);
    680                  savetosd = true;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xF884 0x046D      STRB     R0,[R4, #+1133]
    681             ///     Com::printFLN(Com::tWritingToFile,filename);
    682              }
    683          }
   \                     ??startWrite_1: (+1)
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    684          

   \                                 In section .text, align 2, keep-with-next
    685          void CardReader::finishWrite()
    686          {
   \                     _ZN10CardReader11finishWriteEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
    687              if(!savetosd) return; // already closed or never opened
   \   00000004   0xF894 0x046D      LDRB     R0,[R4, #+1133]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD008             BEQ.N    ??finishWrite_0
    688              //file.sync();
    689              //file.close();
    690              f_sync(&curFile);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       f_sync
    691          	f_close(&curFile);
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       f_close
    692              savetosd = false;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0xF884 0x046D      STRB     R0,[R4, #+1133]
    693           ///   Com::printFLN(Com::tDoneSavingFile);
    694              //UI_CLEAR_STATUS;
    695          }
   \                     ??finishWrite_0: (+1)
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
    696          
    697          

   \                                 In section .text, align 2, keep-with-next
    698          void CardReader::deleteFile(char *filename)	{}
   \                     _ZN10CardReader10deleteFileEPc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    699          void CardReader::removeFile(char* filename) 
    700          {
   \                     _ZN10CardReader10removeFileEPc: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    701              if(!cardOK && !usbOK) return;
   \   00000006   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   0000000A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000000C   0x2900             CMP      R1,#+0
   \   0000000E   0xD102             BNE.N    ??removeFile_0
   \   00000010   0x7900             LDRB     R0,[R0, #+4]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD02B             BEQ.N    ??removeFile_1
    702              sdmode = false; sdprinting = false;
   \                     ??removeFile_0: (+1)
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0xF884 0x046C      STRB     R0,[R4, #+1132]
   \   0000001C   0xF884 0x09B8      STRB     R0,[R4, #+2488]
    703          	
    704              f_close(&curFile);
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       f_close
    705              /*if(fat.remove(filename))
    706              {
    707                  Com::printFLN(Com::tFileDeleted);
    708              }
    709              else
    710              {
    711                  if(fat.rmdir(filename))
    712                      Com::printFLN(Com::tFileDeleted);
    713                  else
    714                      Com::printFLN(Com::tDeletionFailed);
    715              }*/
    716              if(f_unlink((const TCHAR *)filename) == FR_OK)
   \   00000026   0x.... 0x....      LDR.W    R6,??DataTable38_9
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       f_unlink
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD10F             BNE.N    ??removeFile_2
    717          	{
    718            ///      Com::printFLN(Com::tFileDeleted);
    719            	SERIAL_PROTOCOLPGM("File deleted:");
   \   00000034   0x.... 0x....      ADR.W    R0,`?<Constant "File deleted:">`
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
    720            	SERIAL_PROTOCOLLN(filename);
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       _ZN10USARTClass5writeEh
    721            	sdpos = 0;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0xF8C4 0x0460      STR      R0,[R4, #+1120]
   \   00000052   0xBD70             POP      {R4-R6,PC}
    722            
    723              }
    724          	else
    725          	{
    726          ///		Com::printFLN(Com::tDeletionFailed);
    727          	SERIAL_PROTOCOLPGM("Deletion failed, File: ");
   \                     ??removeFile_2: (+1)
   \   00000054   0x.... 0x....      ADR.W    R0,`?<Constant "Deletion failed, File: ">`
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
    728          	SERIAL_PROTOCOL(filename);
   \   0000005C   0x4629             MOV      R1,R5
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _ZN5Print5printEPKc
    729          	SERIAL_PROTOCOLLNPGM(".");
   \   00000064   0x....             ADR.N    R0,??DataTable37  ;; 0x2E, 0x0A, 0x00, 0x00
   \   00000066   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
    730          
    731          	}
    732          }
   \                     ??removeFile_1: (+1)
   \   0000006E   0xBD70             POP      {R4-R6,PC}       ;; return
    733          

   \                                 In section .text, align 2, keep-with-next
    734          void CardReader::makeDirectory(char *filename)
    735          {
   \                     _ZN10CardReader13makeDirectoryEPc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x460C             MOV      R4,R1
    736              if(!cardOK && !usbOK) return;
   \   00000004   0xF600 0x11B8      ADDW     R1,R0,#+2488
   \   00000008   0x78CA             LDRB     R2,[R1, #+3]
   \   0000000A   0x2A00             CMP      R2,#+0
   \   0000000C   0xD102             BNE.N    ??makeDirectory_0
   \   0000000E   0x7909             LDRB     R1,[R1, #+4]
   \   00000010   0x2900             CMP      R1,#+0
   \   00000012   0xD023             BEQ.N    ??makeDirectory_1
    737              sdmode = false;	sdprinting = false;
   \                     ??makeDirectory_0: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0xF880 0x146C      STRB     R1,[R0, #+1132]
   \   0000001A   0xF880 0x19B8      STRB     R1,[R0, #+2488]
    738              //file.close();
    739              f_close(&curFile);
   \   0000001E   0x.... 0x....      BL       f_close
    740              //if(fat.mkdir(filename))
    741              if(f_mkdir((const TCHAR *)filename) == FR_OK)
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable38_9
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       f_mkdir
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD10A             BNE.N    ??makeDirectory_2
    742              {
    743           ///       Com::printFLN(Com::tDirectoryCreated);
    744           		SERIAL_PROTOCOLLN("Directory created");
   \   00000030   0x.... 0x....      ADR.W    R1,`?<Constant "Directory created">`
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000003A   0x210A             MOVS     R1,#+10
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000042   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    745              }
    746              else
    747              {
    748            ///      Com::printFLN(Com::tCreationFailed);
    749            SERIAL_PROTOCOLLN("Creation failed");
   \                     ??makeDirectory_2: (+1)
   \   00000046   0x.... 0x....      ADR.W    R1,`?<Constant "Creation failed">`
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000050   0x210A             MOVS     R1,#+10
   \   00000052   0x4628             MOV      R0,R5
   \   00000054   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000058   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
    750              }
    751          }
   \                     ??makeDirectory_1: (+1)
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
    752          void CardReader::get_file_list(char *path)
    753          {
    754          	if( path == 0)
   \                     _ZN10CardReader13get_file_listEPc: (+1)
   \   00000000   0x2900             CMP      R1,#+0
   \   00000002   0xD001             BEQ.N    ??get_file_list_0
    755          	{
    756          		return;
    757          	}
    758          
    759          	Explore_Disk(path, 0);
   \   00000004   0x2200             MOVS     R2,#+0
   \   00000006   0x....             B.N      _ZN10CardReader12Explore_DiskEPch
   \                     ??get_file_list_0: (+1)
   \   00000008   0x4770             BX       LR               ;; return
    760          	
    761          	
    762          }
    763          

   \                                 In section .text, align 2, keep-with-next
    764          uint8_t CardReader::Explore_Disk (char* path , uint8_t recu_level)
    765          {
   \                     _ZN10CardReader12Explore_DiskEPch: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x7D76      SUB      SP,SP,#+984
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4615             MOV      R5,R2
    766          
    767            FILINFO fno;
    768            DIR dir;
    769           // SD_CardInfo cardinfo;
    770            TCHAR *fn;
    771            char tmp[200];
    772            char Fstream[200];
    773          	int local_offset;
    774          	int file_offset = 0;
   \   0000000C   0x2700             MOVS     R7,#+0
    775          	FRESULT res;
    776          	
    777            #if _USE_LFN
    778              static TCHAR lfn[_MAX_LFN + 1];
    779              fno.lfname = lfn;
   \   0000000E   0x....             LDR.N    R1,??DataTable38_10
   \   00000010   0x9106             STR      R1,[SP, #+24]
    780              fno.lfsize = sizeof(lfn);
   \   00000012   0xF44F 0x7180      MOV      R1,#+256
   \   00000016   0x9107             STR      R1,[SP, #+28]
    781          #endif
    782          
    783          	if(path == 0)
   \   00000018   0x2C00             CMP      R4,#+0
   \   0000001A   0xD101             BNE.N    ??Explore_Disk_0
    784          		return 0;
   \   0000001C   0x4638             MOV      R0,R7
   \   0000001E   0xE018             B.N      ??Explore_Disk_1
    785          /*
    786          	if(path[0] == '0')               //skyblue 2016-12-13
    787          		f_mount(0, &fs);
    788          	else if(path[0] == '1')
    789          		f_mount(1, &fs);
    790          	else
    791          		return;
    792          */	
    793                  f_mount(&fs, (char *)path, 0);     //skyblue 2016-12-13
   \                     ??Explore_Disk_0: (+1)
   \   00000020   0x463A             MOV      R2,R7
   \   00000022   0x4621             MOV      R1,R4
   \   00000024   0xF500 0x700B      ADD      R0,R0,#+556
   \   00000028   0x.... 0x....      BL       f_mount
   \   0000002C   0xE007             B.N      ??Explore_Disk_2
    794                  
    795          	for(;;)
    796          	{
    797          		local_offset = 0;
    798          		
    799          		if (f_opendir(&dir, (const TCHAR *)path) == FR_OK) 
    800          	  	{
    801          
    802          		    while(1)
    803          		    {
    804          				res = f_readdir(&dir, &fno);
    805          				if (res != FR_OK || fno.fname[0] == 0) 
    806          				{
    807          					return;
                 					      ^
Warning[Pe117]: non-void function "CardReader::Explore_Disk" should return a
          value
    808          				}
    809          				if (fno.fname[0] == '.')
    810          				{
    811          					continue;
    812          				}
    813          
    814          				
    815          
    816          
    817          				if(local_offset >= file_offset)
    818          				{
    819          					file_offset++;
    820          					break;
    821          				}
    822          
    823          				local_offset++;
    824          		    }
    825          			
    826          		    if ((fno.lfname[0] == 0) || (fno.lfname == 0))
    827          				fn = fno.fname;
    828          			else
    829          				fn = fno.lfname;
    830          				
    831          		      	if((strstr((const char *)fn, ".gco")) || (strstr((const char *)fn, ".GCO")) || (fno.fattrib & AM_DIR))
    832          				{
    833          					  
    834          					  tmp[0] = '\0';
    835          					 // strcpy(tmp, path);
    836          					 // strcat(tmp, "/");
    837          					  strcat((char *)tmp, (char *)fn);
    838          
    839          					memset(Fstream, 0, sizeof(Fstream));
    840          					strcpy(Fstream, tmp);
    841          					  if((fno.fattrib & AM_DIR)&&(recu_level <= 10))
    842          				      {
    843          				      //  Explore_Disk(tmp, recu_level + 1);
    844          				      	
    845          						
    846          						strcat(Fstream, ".DIR\r\n");
   \                     ??Explore_Disk_3: (+1)
   \   0000002E   0x.... 0x....      ADR.W    R1,`?<Constant ".DIR\\r\\n">`
   \   00000032   0x.... 0x....      BL       strcat
    847          						//send_to_wifi(Fstream, strlen(Fstream));
    848          					//Com::print(Fstream);
    849                             	//Com::printF(Com::tSlash);
    850          					
    851          						SERIAL_PROTOCOL(Fstream);
   \   00000036   0xA908             ADD      R1,SP,#+32
   \   00000038   0x....             LDR.N    R0,??DataTable38_9
   \   0000003A   0x.... 0x....      BL       _ZN5Print5printEPKc
    852          						//SERIAL_PROTOCOLLNPGM("/");
    853          
    854          
    855          				      }
   \                     ??Explore_Disk_2: (+1)
   \   0000003E   0xF04F 0x0800      MOV      R8,#+0
   \   00000042   0x4621             MOV      R1,R4
   \   00000044   0xA86C             ADD      R0,SP,#+432
   \   00000046   0x.... 0x....      BL       f_opendir
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD007             BEQ.N    ??Explore_Disk_4
    856          					  else
    857          					  {					
    858          						strcat(Fstream, "\r\n");
    859          						//send_to_wifi(Fstream, strlen(Fstream));
    860          ///						Com::print(Fstream);
    861          ///                     	Com::printF(Com::tSlash);
    862          						SERIAL_PROTOCOL(Fstream);
    863          						//SERIAL_PROTOCOLLNPGM("/");
    864          
    865          					  }
    866          				}
    867          		  
    868          		      
    869          
    870          		     
    871          		    }
    872          				else
    873          					break;
    874          	
    875            	
    876          	}
    877           return res;
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0xB2C0             UXTB     R0,R0
   \                     ??Explore_Disk_1: (+1)
   \   00000052   0xF50D 0x7D76      ADD      SP,SP,#+984
   \   00000056   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
   \                     ??Explore_Disk_5: (+1)
   \   0000005A   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??Explore_Disk_4: (+1)
   \   0000005E   0xA900             ADD      R1,SP,#+0
   \   00000060   0xA86C             ADD      R0,SP,#+432
   \   00000062   0x.... 0x....      BL       f_readdir
   \   00000066   0x0006             MOVS     R6,R0
   \   00000068   0xD1F3             BNE.N    ??Explore_Disk_1
   \   0000006A   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD0EF             BEQ.N    ??Explore_Disk_1
   \   00000072   0x282E             CMP      R0,#+46
   \   00000074   0xD0F3             BEQ.N    ??Explore_Disk_4
   \   00000076   0x45B8             CMP      R8,R7
   \   00000078   0xDBEF             BLT.N    ??Explore_Disk_5
   \   0000007A   0x1C7F             ADDS     R7,R7,#+1
   \   0000007C   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   00000080   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD002             BEQ.N    ??Explore_Disk_6
   \   00000088   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000008C   0xD101             BNE.N    ??Explore_Disk_7
   \                     ??Explore_Disk_6: (+1)
   \   0000008E   0xF10D 0x0809      ADD      R8,SP,#+9
   \                     ??Explore_Disk_7: (+1)
   \   00000092   0x.... 0x....      ADR.W    R1,`?<Constant ".gco">`
   \   00000096   0x4640             MOV      R0,R8
   \   00000098   0x.... 0x....      BL       _Z6strstrPKcS0_
   \   0000009C   0x2800             CMP      R0,#+0
   \   0000009E   0xD10A             BNE.N    ??Explore_Disk_8
   \   000000A0   0x.... 0x....      ADR.W    R1,`?<Constant ".GCO">`
   \   000000A4   0x4640             MOV      R0,R8
   \   000000A6   0x.... 0x....      BL       _Z6strstrPKcS0_
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xD103             BNE.N    ??Explore_Disk_8
   \   000000AE   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000B2   0x06C0             LSLS     R0,R0,#+27
   \   000000B4   0xD5C3             BPL.N    ??Explore_Disk_2
   \                     ??Explore_Disk_8: (+1)
   \   000000B6   0x2000             MOVS     R0,#+0
   \   000000B8   0xF88D 0x00E8      STRB     R0,[SP, #+232]
   \   000000BC   0x4641             MOV      R1,R8
   \   000000BE   0xA83A             ADD      R0,SP,#+232
   \   000000C0   0x.... 0x....      BL       strcat
   \   000000C4   0x22C8             MOVS     R2,#+200
   \   000000C6   0x2100             MOVS     R1,#+0
   \   000000C8   0xA808             ADD      R0,SP,#+32
   \   000000CA   0x.... 0x....      BL       memset
   \   000000CE   0xA93A             ADD      R1,SP,#+232
   \   000000D0   0xA808             ADD      R0,SP,#+32
   \   000000D2   0x.... 0x....      BL       strcpy
   \   000000D6   0xF89D 0x1008      LDRB     R1,[SP, #+8]
   \   000000DA   0x06C9             LSLS     R1,R1,#+27
   \   000000DC   0xD501             BPL.N    ??Explore_Disk_9
   \   000000DE   0x2D0B             CMP      R5,#+11
   \   000000E0   0xDBA5             BLT.N    ??Explore_Disk_3
   \                     ??Explore_Disk_9: (+1)
   \   000000E2   0x....             ADR.N    R1,??DataTable38  ;; 0x0D, 0x0A, 0x00, 0x00
   \   000000E4   0xA808             ADD      R0,SP,#+32
   \   000000E6   0x.... 0x....      BL       strcat
   \   000000EA   0xA908             ADD      R1,SP,#+32
   \   000000EC   0x....             LDR.N    R0,??DataTable38_9
   \   000000EE   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000000F2   0xE7A4             B.N      ??Explore_Disk_2
    878          }

   \                                 In section .bss, align 4
   \                     ??lfn:
   \   00000000                      DS8 256
    879          

   \                                 In section .text, align 2, keep-with-next
    880          void CardReader::ShowSDFiles(void)
    881          	{
   \                     _ZN10CardReader11ShowSDFilesEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xF5AD 0x7D44      SUB      SP,SP,#+784
   \   00000008   0x4604             MOV      R4,R0
    882          	  FILINFO fno;
    883          	  DIR dir;
    884          	  TCHAR *fn;
    885                const TCHAR gFileName[5] = {'.', 'g', 'c', 'o', '\0'};
                                   ^
Warning[Pe177]: variable "gFileName" was declared but never referenced
    886                const TCHAR gFileNameCap[5] = {'.', 'G', 'C', 'O', '\0'};
                                   ^
Warning[Pe177]: variable "gFileNameCap" was declared but never referenced
    887          	  TCHAR tmp[200];
    888          	  int res;
    889          	
    890            #if _USE_LFN
    891          		static TCHAR lfn[_MAX_LFN + 1];
    892          		fno.lfname = lfn;
   \   0000000A   0x....             LDR.N    R0,??DataTable38_11
   \   0000000C   0x9006             STR      R0,[SP, #+24]
    893          		fno.lfsize = _MAX_LFN + 1;
   \   0000000E   0xF44F 0x7080      MOV      R0,#+256
   \   00000012   0x9007             STR      R0,[SP, #+28]
    894          #endif
    895          	 
    896          	
    897          	 //f_mount(1, &fs);
    898          	 #if 0//
    899                    if ((SD_DET_IP == SD_DETECT_INVERTED)&&(usbOK == false))                 
    900                      f_mount(&fs, (TCHAR const*)SD_Path, 0);     //skyblue 2016-12-13
    901                    else
    902                      f_mount(&fs, (TCHAR const*)USBH_Path, 0);
    903          	#endif
    904              
    905          #if defined(MKS_ROBIN2)    
    906          	if (gCfgItems.fileSysType == FILE_SYS_SD)                 
    907                   f_mount(&fs, (TCHAR const*)SD_Path, 0);     //skyblue 2016-12-13
    908              else
    909                   f_mount(&fs, (TCHAR const*)USBH_Path, 0);	
    910          #else//robin robin_mini robin_nanoึปำะSDฟจทฝสฝ
    911               f_mount(&fs, (TCHAR const*)SD_Path, 0);
   \   00000014   0x2200             MOVS     R2,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable38_5
   \   00000018   0xF504 0x700B      ADD      R0,R4,#+556
   \   0000001C   0x.... 0x....      BL       f_mount
    912          #endif
    913          
    914          	 if (f_opendir(&dir, gCurDir) == FR_OK) 
   \   00000020   0xF604 0x15B6      ADDW     R5,R4,#+2486
   \   00000024   0xF204 0x469C      ADDW     R6,R4,#+1180
   \   00000028   0x4631             MOV      R1,R6
   \   0000002A   0xA83A             ADD      R0,SP,#+232
   \   0000002C   0x.... 0x....      BL       f_opendir
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD166             BNE.N    ??ShowSDFiles_0
    915          	  {
    916          		Sd_file_cnt = 0;
   \   00000034   0xF204 0x4794      ADDW     R7,R4,#+1172
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x6078             STR      R0,[R7, #+4]
    917          			gcodeFileList.listVaild= 2;
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0x7068             STRB     R0,[R5, #+1]
   \   00000040   0xE001             B.N      ??ShowSDFiles_1
    918          		for (;;) 
    919          		{
    920          			res = f_readdir(&dir, &fno);
    921          			if (res != FR_OK || fno.fname[0] == 0) 
    922          			{
    923          				gcodeFileList.listVaild= 2;
    924          				break;
    925          			}
    926          			if ( fno.fname[0] == '.') 
    927          				continue;
    928          	
    929          			if ((fno.lfname[0] == 0) || (fno.lfname == 0))
    930          				fn = fno.fname;
    931          			else
    932          				fn = fno.lfname;
    933          	
    934          			/*	 if (fno.fattrib & AM_DIR) 
    935          			{
    936          			continue;
    937          			} 
    938          			else */
    939          			if(Sd_file_cnt == Sd_file_offset)
    940          			{
    941          				//Sd_file_offset++;
    942          				#if _LFN_UNICODE
    943          				if((wcsstr((const wchar_t *)fn, (const wchar_t *)gFileName)) || (wcsstr((const wchar_t *)fn, (const wchar_t *)gFileNameCap)) || (fno.fattrib & AM_DIR))
    944          				#else
    945          					if((strstr(fn, ".gco")) || (strstr(fn, ".GCO")) || (fno.fattrib & AM_DIR))
    946          				#endif
    947          				{
    948          					  //Sd_display_file_cnt++;
    949          					  
    950          					  tmp[0] = '\0';
    951          					  strcpy(tmp, (char const*)gCurDir);
    952          					  strcat(tmp, "/");
    953          					  #if _LFN_UNICODE
    954          					  wcscat((wchar_t *)tmp, (const wchar_t *)fn);
    955          					  #else
    956          					  strcat(tmp, fn);
    957          					  #endif
    958          	
    959          					  gcodeFileList.listVaild= 1;
    960          	
    961          					if(fno.fattrib & AM_DIR)
    962          					{
    963          						gcodeFileList.fileAttr[gcodeFileList.index] = 1;
    964          					}
    965          					else
    966          					{
    967          						gcodeFileList.fileAttr[gcodeFileList.index] = 0;
    968          					}
    969          	
    970          					#if _LFN_UNICODE
    971          					wcscpy((wchar_t *)gcodeFileList.fileName[gcodeFileList.index], (const wchar_t *)tmp);
    972          					#else
    973          					strcpy((char *)gcodeFileList.fileName[gcodeFileList.index], (const char *)tmp);
    974          					#endif
    975          					gcodeFileList.index++;
    976          					
    977          					
    978          				}
    979          				else
    980          				{
    981          					gcodeFileList.listVaild= 0;
    982          				}
    983          				break;
    984          			}
    985          			
    986          			Sd_file_cnt++;
   \                     ??ShowSDFiles_2: (+1)
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0x6078             STR      R0,[R7, #+4]
   \                     ??ShowSDFiles_1: (+1)
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0xA83A             ADD      R0,SP,#+232
   \   0000004A   0x.... 0x....      BL       f_readdir
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD157             BNE.N    ??ShowSDFiles_0
   \   00000052   0xF99D 0x0009      LDRSB    R0,[SP, #+9]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD053             BEQ.N    ??ShowSDFiles_0
   \   0000005A   0x282E             CMP      R0,#+46
   \   0000005C   0xD0F3             BEQ.N    ??ShowSDFiles_1
   \   0000005E   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   00000062   0xF998 0x0000      LDRSB    R0,[R8, #+0]
   \   00000066   0x2800             CMP      R0,#+0
   \   00000068   0xD002             BEQ.N    ??ShowSDFiles_3
   \   0000006A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006E   0xD101             BNE.N    ??ShowSDFiles_4
   \                     ??ShowSDFiles_3: (+1)
   \   00000070   0xF10D 0x0809      ADD      R8,SP,#+9
   \                     ??ShowSDFiles_4: (+1)
   \   00000074   0x6878             LDR      R0,[R7, #+4]
   \   00000076   0xF8D4 0x1494      LDR      R1,[R4, #+1172]
   \   0000007A   0x4288             CMP      R0,R1
   \   0000007C   0xD1E1             BNE.N    ??ShowSDFiles_2
   \   0000007E   0x.... 0x....      ADR.W    R1,`?<Constant ".gco">`
   \   00000082   0x4640             MOV      R0,R8
   \   00000084   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000088   0x2800             CMP      R0,#+0
   \   0000008A   0xD10A             BNE.N    ??ShowSDFiles_5
   \   0000008C   0x.... 0x....      ADR.W    R1,`?<Constant ".GCO">`
   \   00000090   0x4640             MOV      R0,R8
   \   00000092   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD103             BNE.N    ??ShowSDFiles_5
   \   0000009A   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   0000009E   0x06C0             LSLS     R0,R0,#+27
   \   000000A0   0xD52C             BPL.N    ??ShowSDFiles_6
   \                     ??ShowSDFiles_5: (+1)
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0xF88D 0x0020      STRB     R0,[SP, #+32]
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0xA808             ADD      R0,SP,#+32
   \   000000AC   0x.... 0x....      BL       strcpy
   \   000000B0   0x....             ADR.N    R1,??DataTable38_1  ;; "/"
   \   000000B2   0x.... 0x....      BL       strcat
   \   000000B6   0x4641             MOV      R1,R8
   \   000000B8   0xA808             ADD      R0,SP,#+32
   \   000000BA   0x.... 0x....      BL       strcat
   \   000000BE   0x2001             MOVS     R0,#+1
   \   000000C0   0x7068             STRB     R0,[R5, #+1]
   \   000000C2   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   000000C6   0xF000 0x0010      AND      R0,R0,#0x10
   \   000000CA   0x1E41             SUBS     R1,R0,#+1
   \   000000CC   0x4189             SBCS     R1,R1,R1
   \   000000CE   0x43C9             MVNS     R1,R1
   \   000000D0   0x0FC9             LSRS     R1,R1,#+31
   \   000000D2   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   000000D6   0x1900             ADDS     R0,R0,R4
   \   000000D8   0xF880 0x19B0      STRB     R1,[R0, #+2480]
   \   000000DC   0xA908             ADD      R1,SP,#+32
   \   000000DE   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   000000E2   0x22C8             MOVS     R2,#+200
   \   000000E4   0xFB02 0x4000      MLA      R0,R2,R0,R4
   \   000000E8   0xF500 0x60A0      ADD      R0,R0,#+1280
   \   000000EC   0x.... 0x....      BL       strcpy
   \   000000F0   0xF894 0x09B6      LDRB     R0,[R4, #+2486]
   \   000000F4   0x1C40             ADDS     R0,R0,#+1
   \   000000F6   0xF884 0x09B6      STRB     R0,[R4, #+2486]
   \   000000FA   0xE004             B.N      ??ShowSDFiles_7
   \                     ??ShowSDFiles_6: (+1)
   \   000000FC   0x2000             MOVS     R0,#+0
   \   000000FE   0x7068             STRB     R0,[R5, #+1]
   \   00000100   0xE001             B.N      ??ShowSDFiles_7
    987          			
    988          			 
    989          		}
    990          #if 0
    991          		while (f_readdir(&dirs, &finfo) == FR_OK)  
    992          		{
    993          		  if (finfo.fattrib & AM_ARC) 
    994          		  {
    995          			if(!finfo.fname[0]) 
    996          			  break;		 
    997          			  printf("\n\r file name is: %s\n",finfo.fname);
    998          			  printf("\n\r file size is: %d ", finfo.fsize); 
    999          	
   1000          			  if(File_type_Check( (u8 *)finfo.fname, "txt"))
   1001          			  { 
   1002          				BufferSet(buffer, 0, 100);
   1003          				res = f_open(&fsrc, finfo.fname, FA_OPEN_EXISTING | FA_READ);
   1004          				res = f_read(&fsrc, buffer, 100, &br);
   1005          				printf("\n\r file contex is: \n\r%s\n\r", buffer); 
   1006          				f_close(&fsrc); 							  
   1007          			  }
   1008          		  }
   1009          		  else
   1010          		  {
   1011          			printf("\n\r Path name is: %s", finfo.fname); 
   1012          			continue;//break;
   1013          		  }
   1014          		} 
   1015          		  res = f_open(&fsrc, "armjishu.txt", FA_CREATE_ALWAYS | FA_WRITE);
   1016          		  res = f_write(&fsrc, &armjishu, sizeof(armjishu), &bw);
   1017          		  f_close(&fsrc);
   1018          	#endif
   1019          	  
   1020          	 }
   1021          	 else
   1022          		 gcodeFileList.listVaild= 2;
   \                     ??ShowSDFiles_0: (+1)
   \   00000102   0x2002             MOVS     R0,#+2
   \   00000104   0x7068             STRB     R0,[R5, #+1]
   1023          	 
   1024          	}
   \                     ??ShowSDFiles_7: (+1)
   \   00000106   0xF50D 0x7D44      ADD      SP,SP,#+784
   \   0000010A   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .bss, align 4
   \                     ??lfn_1:
   \   00000000                      DS8 256
   1025          

   \                                 In section .text, align 2, keep-with-next
   1026          int CardReader::ascii2dec(char *ascii, char width)
   1027          {
   \                     _ZN10CardReader9ascii2decEPcc: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
   1028          	int i = 0;
   \   00000002   0x2300             MOVS     R3,#+0
   1029          	int result = 0;
   \   00000004   0x4618             MOV      R0,R3
   1030          
   1031          	if(ascii == 0)
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD105             BNE.N    ??ascii2dec_0
   1032          		return 0;
   1033          	
   1034          	while(i < width)
   1035          	{		
   1036          		result = result << 4;
   1037          		
   1038          		if(*(ascii + i) >= '0' && *(ascii + i) <= '9')
   1039          			result += *(ascii + i) - '0';
   1040          		else if(*(ascii + i) >= 'a' && *(ascii + i) <= 'f')
   1041          			result += *(ascii + i) - 'a' + 0x0a;
   1042          		else if(*(ascii + i) >= 'A' && *(ascii + i) <= 'F')
   1043          			result += *(ascii + i) - 'A' + 0x0a;
   1044          		else
   1045          			return 0;
   \                     ??ascii2dec_1: (+1)
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE01A             B.N      ??ascii2dec_2
   \                     ??ascii2dec_3: (+1)
   \   0000000E   0x3C30             SUBS     R4,R4,#+48
   \   00000010   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   1046          		
   1047          		i++;
   \                     ??ascii2dec_4: (+1)
   \   00000014   0x1C5B             ADDS     R3,R3,#+1
   \                     ??ascii2dec_0: (+1)
   \   00000016   0x4293             CMP      R3,R2
   \   00000018   0xDA14             BGE.N    ??ascii2dec_2
   \   0000001A   0x565C             LDRSB    R4,[R3, R1]
   \   0000001C   0x4625             MOV      R5,R4
   \   0000001E   0xF1A5 0x0630      SUB      R6,R5,#+48
   \   00000022   0x2E0A             CMP      R6,#+10
   \   00000024   0xD3F3             BCC.N    ??ascii2dec_3
   \   00000026   0xF1A5 0x0661      SUB      R6,R5,#+97
   \   0000002A   0x2E06             CMP      R6,#+6
   \   0000002C   0xD203             BCS.N    ??ascii2dec_5
   \   0000002E   0x3C57             SUBS     R4,R4,#+87
   \   00000030   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   00000034   0xE7EE             B.N      ??ascii2dec_4
   \                     ??ascii2dec_5: (+1)
   \   00000036   0x3D41             SUBS     R5,R5,#+65
   \   00000038   0x2D06             CMP      R5,#+6
   \   0000003A   0xD2E6             BCS.N    ??ascii2dec_1
   \   0000003C   0x3C37             SUBS     R4,R4,#+55
   \   0000003E   0xEB14 0x1000      ADDS     R0,R4,R0, LSL #+4
   \   00000042   0xE7E7             B.N      ??ascii2dec_4
   1048          	}
   1049          	return result;
   \                     ??ascii2dec_2: (+1)
   \   00000044   0xBC70             POP      {R4-R6}
   \   00000046   0x4770             BX       LR               ;; return
   1050          }
   1051          
   1052          /*---------------------------------mks add begin-------------------------------------*/

   \                                 In section .text, align 2, keep-with-next
   1053          uint32_t CardReader::getsdpos()
   1054          {
   1055          	//sdpos = file.curPosition();
   1056          	return sdpos;
   \                     _ZN10CardReader8getsdposEv: (+1)
   \   00000000   0xF8D0 0x0460      LDR      R0,[R0, #+1120]
   \   00000004   0x4770             BX       LR               ;; return
   1057          }

   \                                 In section .text, align 2, keep-with-next
   1058          void CardReader::printingHasFinished()
   1059          {
   \                     _ZN10CardReader19printingHasFinishedEv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1060              stepper.synchronize();
   \   00000004   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   1061          	f_close(&curFile);
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x.... 0x....      BL       f_close
   1062          
   1063              sdprinting = false;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   1064          	sdmode = 0;
   \   00000014   0xF884 0x046C      STRB     R0,[R4, #+1132]
   1065              if (SD_FINISHED_STEPPERRELEASE)
   1066                enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "M84 X Y Z E">`
   \   0000001C   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
   1067              print_job_timer.stop();
   \   00000020   0x....             LDR.N    R4,??DataTable38_12
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   1068              if (print_job_timer.duration() > 60)
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \   0000002E   0x283D             CMP      R0,#+61
   \   00000030   0xD304             BCC.N    ??printingHasFinished_0
   1069                enqueue_and_echo_commands_P(PSTR("M31"));
   \   00000032   0x....             ADR.N    R0,??DataTable38_2  ;; "M31"
   \   00000034   0xE8BD 0x4010      POP      {R4,LR}
   \   00000038   0x.... 0x....      B.W      _Z27enqueue_and_echo_commands_PPKc
   1070          }
   \                     ??printingHasFinished_0: (+1)
   \   0000003C   0xBD10             POP      {R4,PC}          ;; return
   1071          
   1072          
   1073          
   1074          
   1075          
   1076          

   \                                 In section .text, align 2, keep-with-next
   1077          void CardReader::closefile(bool store_location)
   1078          {
   \                     _ZN10CardReader9closefileEb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1079            f_close(&curFile);
   \   00000004   0x.... 0x....      BL       f_close
   1080            saving = false;  
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0xF884 0x09B9      STRB     R0,[R4, #+2489]
   1081            logging = false;
   \   0000000E   0xF884 0x09BA      STRB     R0,[R4, #+2490]
   1082            
   1083          }
   \   00000012   0xBD10             POP      {R4,PC}          ;; return
   1084          

   \                                 In section .text, align 2, keep-with-next
   1085          void CardReader::openLogFile(char* name)
   1086          {
   1087            logging = true;
   \                     _ZN10CardReader11openLogFileEPc: (+1)
   \   00000000   0x2201             MOVS     R2,#+1
   \   00000002   0xF880 0x29BA      STRB     R2,[R0, #+2490]
   1088            openFile(name, false);
   \   00000006   0x4613             MOV      R3,R2
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0x....             B.N      _ZN10CardReader8openFileEPcbb
   1089          }
   1090          

   \                                 In section .text, align 2, keep-with-next
   1091          void CardReader::write_command(char *buf)
   1092          {
   \                     _ZN10CardReader13write_commandEPc: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   1093            unsigned int lastBufferEntry = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x9001             STR      R0,[SP, #+4]
   1094            FRESULT writeStatus;
   1095            char* begin = buf;
   1096            char* npos = 0;
   1097            char* end = buf + strlen(buf) - 1;
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       strlen
   \   00000012   0x1940             ADDS     R0,R0,R5
   \   00000014   0x1E46             SUBS     R6,R0,#+1
   1098          	
   1099          	memset(&writeStatus, 0, sizeof(FRESULT));
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       memset
   1100          
   1101            if((npos = strchr(buf, 'N')) != NULL)
   \   00000020   0x214E             MOVS     R1,#+78
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0x.... 0x....      BL       _Z6strchrPci
   \   00000028   0x0007             MOVS     R7,R0
   \   0000002A   0xD008             BEQ.N    ??write_command_0
   1102            {
   1103              begin = strchr(npos, ' ') + 1;
   \   0000002C   0x2120             MOVS     R1,#+32
   \   0000002E   0x.... 0x....      BL       _Z6strchrPci
   \   00000032   0x1C45             ADDS     R5,R0,#+1
   1104              end = strchr(npos, '*') - 1;
   \   00000034   0x212A             MOVS     R1,#+42
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       _Z6strchrPci
   \   0000003C   0x1E46             SUBS     R6,R0,#+1
   1105            }
   1106            end[1] = '\r';
   \                     ??write_command_0: (+1)
   \   0000003E   0x200D             MOVS     R0,#+13
   \   00000040   0x7070             STRB     R0,[R6, #+1]
   1107            end[2] = '\n';
   \   00000042   0x200A             MOVS     R0,#+10
   \   00000044   0x70B0             STRB     R0,[R6, #+2]
   1108            
   1109            writeStatus = f_write(&curFile, begin, &(end[2]) - begin + 1, &lastBufferEntry);
   \   00000046   0x1CB0             ADDS     R0,R6,#+2
   \   00000048   0x1B40             SUBS     R0,R0,R5
   \   0000004A   0x1C46             ADDS     R6,R0,#+1
   \   0000004C   0xAB01             ADD      R3,SP,#+4
   \   0000004E   0x4632             MOV      R2,R6
   \   00000050   0x4629             MOV      R1,R5
   \   00000052   0x4620             MOV      R0,R4
   \   00000054   0x.... 0x....      BL       f_write
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
   1110            if( 	(writeStatus != FR_OK) ||
   1111          		(lastBufferEntry != (unsigned int)(&(end[2]) - begin + 1)))
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD102             BNE.N    ??write_command_1
   \   00000060   0x9801             LDR      R0,[SP, #+4]
   \   00000062   0x42B0             CMP      R0,R6
   \   00000064   0xD006             BEQ.N    ??write_command_2
   1112            {
   1113              SERIAL_ERROR_START();
   \                     ??write_command_1: (+1)
   \   00000066   0x....             LDR.N    R0,??DataTable38_13
   \   00000068   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1114              SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);
   \   0000006C   0x.... 0x....      ADR.W    R0,`?<Constant "error writing to file\\n">`
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1115            }
   1116          }
   \                     ??write_command_2: (+1)
   \   00000074   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "M31">`:
   \   00000000   0x4D 0x33          DC8 "M31"
   \              0x31 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000021   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000031   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000041   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000051   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000061   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000071   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000081   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant ".\\n">`:
   \   00000000   0x2E 0x0A          DC8 ".\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "\\r\\n">`:
   \   00000000   0x0D 0x0A          DC8 "\015\012"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .text, align 2, keep-with-next
   \   __code __interwork __softfp CardReader::subobject CardReader()
   \                     _ZN10CardReaderC2Ev: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002                      REQUIRE _ZN10CardReaderC1Ev
   \   00000002                      ;; // Fall through to label CardReader::CardReader()

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable35:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable37:
   \   00000000   0x2E 0x0A          DC8      0x2E, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38:
   \   00000000   0x0D 0x0A          DC8      0x0D, 0x0A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_1:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_2:
   \   00000000   0x4D 0x33          DC8      "M31"
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_3:
   \   00000000   0x42228130         DC32     0x42228130

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_4:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_5:
   \   00000000   0x........         DC32     SD_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_6:
   \   00000000   0x........         DC32     mksReprint

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_7:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_8:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_9:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_10:
   \   00000000   0x........         DC32     ??lfn

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_11:
   \   00000000   0x........         DC32     ??lfn_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_12:
   \   00000000   0x........         DC32     print_job_timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable38_13:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD init fail\\n">`:
   \   00000000   0x53 0x44          DC8 "SD init fail\012"
   \              0x20 0x69    
   \              0x6E 0x69    
   \              0x74 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x0A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD card ok\\n">`:
   \   00000000   0x53 0x44          DC8 "SD card ok\012"
   \              0x20 0x63    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x6F 0x6B    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M84 X Y Z E">`:
   \   00000000   0x4D 0x38          DC8 "M84 X Y Z E"
   \              0x34 0x20    
   \              0x58 0x20    
   \              0x59 0x20    
   \              0x5A 0x20    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD card removed\\n">`:
   \   00000000   0x53 0x44          DC8 "SD card removed\012"
   \              0x20 0x63    
   \              0x61 0x72    
   \              0x64 0x20    
   \              0x72 0x65    
   \              0x6D 0x6F    
   \              0x76 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Select SD file system\\n">`:
   \   00000000   0x53 0x65          DC8 "Select SD file system\012"
   \              0x6C 0x65    
   \              0x63 0x74    
   \              0x20 0x53    
   \              0x44 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x79 0x73    
   \              0x74 0x65    
   \              0x6D 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File opened: ">`:
   \   00000000   0x46 0x69          DC8 "File opened: "
   \              0x6C 0x65    
   \              0x20 0x6F    
   \              0x70 0x65    
   \              0x6E 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Size: ">`:
   \   00000000   0x20 0x53          DC8 " Size: "
   \              0x69 0x7A    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File selected\\n">`:
   \   00000000   0x46 0x69          DC8 "File selected\012"
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x65 0x6C    
   \              0x65 0x63    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "open failed, File: ">`:
   \   00000000   0x6F 0x70          DC8 "open failed, File: "
   \              0x65 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2C    
   \              0x20 0x46    
   \              0x69 0x6C    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SD printing byte ">`:
   \   00000000   0x53 0x44          DC8 "SD printing byte "
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x62 0x79    
   \              0x74 0x65    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Not SD printing\\n">`:
   \   00000000   0x4E 0x6F          DC8 "Not SD printing\012"
   \              0x74 0x20    
   \              0x53 0x44    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x69 0x6E    
   \              0x67 0x0A    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "File deleted:">`:
   \   00000000   0x46 0x69          DC8 "File deleted:"
   \              0x6C 0x65    
   \              0x20 0x64    
   \              0x65 0x6C    
   \              0x65 0x74    
   \              0x65 0x64    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Deletion failed, File: ">`:
   \   00000000   0x44 0x65          DC8 "Deletion failed, File: "
   \              0x6C 0x65    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x2C    
   \              0x20 0x46    
   \              0x69 0x6C    
   \              0x65 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "error writing to file\\n">`:
   \   00000000   0x65 0x72          DC8 "error writing to file\012"
   \              0x72 0x6F    
   \              0x72 0x20    
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x74 0x6F    
   \              0x20 0x66    
   \              0x69 0x6C    
   \              0x65 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Directory created">`:
   \   00000000   0x44 0x69          DC8 "Directory created"
   \              0x72 0x65    
   \              0x63 0x74    
   \              0x6F 0x72    
   \              0x79 0x20    
   \              0x63 0x72    
   \              0x65 0x61    
   \              0x74 0x65    
   \              0x64 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Creation failed">`:
   \   00000000   0x43 0x72          DC8 "Creation failed"
   \              0x65 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".gco">`:
   \   00000000   0x2E 0x67          DC8 ".gco"
   \              0x63 0x6F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".GCO">`:
   \   00000000   0x2E 0x47          DC8 ".GCO"
   \              0x43 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant ".DIR\\r\\n">`:
   \   00000000   0x2E 0x44          DC8 ".DIR\015\012"
   \              0x49 0x52    
   \              0x0D 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0
   1117          
   1118          #if 0
   1119          void CardReader::openLogFile(char* name) {
   1120            logging = true;
   1121            openFile(name, false);
   1122          }
   1123          
   1124          void appendAtom(SdFile &file, char *& dst, uint8_t &cnt) {
   1125            file.getFilename(dst);
   1126            while (*dst && cnt < MAXPATHNAMELENGTH) { dst++; cnt++; }
   1127            if (cnt < MAXPATHNAMELENGTH) { *dst = '/'; dst++; cnt++; }
   1128          }
   1129          
   1130          void CardReader::getAbsFilename(char *t) {
   1131            *t++ = '/';                                               // Root folder
   1132            uint8_t cnt = 1;
   1133          
   1134            for (uint8_t i = 0; i < workDirDepth; i++)                // Loop to current work dir
   1135              appendAtom(workDirParents[i], t, cnt);
   1136          
   1137            if (cnt < MAXPATHNAMELENGTH - (FILENAME_LENGTH)) {
   1138              appendAtom(file, t, cnt);
   1139              --t;
   1140            }
   1141            *t = '\0';
   1142          }
   1143          
   1144          void CardReader::openFile(char* name, const bool read, const bool subcall/*=false*/) {
   1145          
   1146            if (!cardOK) return;
   1147          
   1148            uint8_t doing = 0;
   1149            if (isFileOpen()) {                     // Replacing current file or doing a subroutine
   1150              if (subcall) {
   1151                if (file_subcall_ctr > SD_PROCEDURE_DEPTH - 1) {
   1152                  SERIAL_ERROR_START();
   1153                  SERIAL_ERRORPGM("trying to call sub-gcode files with too many levels. MAX level is:");
   1154                  SERIAL_ERRORLN(SD_PROCEDURE_DEPTH);
   1155                  kill(PSTR(MSG_KILLED));
   1156                  return;
   1157                }
   1158          
   1159                // Store current filename (based on workDirParents) and position
   1160                getAbsFilename(proc_filenames[file_subcall_ctr]);
   1161                filespos[file_subcall_ctr] = sdpos;
   1162          
   1163                SERIAL_ECHO_START();
   1164                SERIAL_ECHOPAIR("SUBROUTINE CALL target:\"", name);
   1165                SERIAL_ECHOPAIR("\" parent:\"", proc_filenames[file_subcall_ctr]);
   1166                SERIAL_ECHOLNPAIR("\" pos", sdpos);
   1167                file_subcall_ctr++;
   1168              }
   1169              else
   1170                doing = 1;
   1171            }
   1172            else if (subcall) {     // Returning from a subcall?
   1173              SERIAL_ECHO_START();
   1174              SERIAL_ECHOLNPGM("END SUBROUTINE");
   1175            }
   1176            else {                  // Opening fresh file
   1177              doing = 2;
   1178              file_subcall_ctr = 0; // Reset procedure depth in case user cancels print while in procedure
   1179            }
   1180          
   1181            if (doing) {
   1182              SERIAL_ECHO_START();
   1183              SERIAL_ECHOPGM("Now ");
   1184              serialprintPGM(doing == 1 ? PSTR("doing") : PSTR("fresh"));
   1185              SERIAL_ECHOLNPAIR(" file: ", name);
   1186            }
   1187          
   1188            stopSDPrint();
   1189          
   1190            SdFile myDir;
   1191            curDir = &root;
   1192            char *fname = name;
   1193            char *dirname_start, *dirname_end;
   1194          
   1195            if (name[0] == '/') {
   1196              dirname_start = &name[1];
   1197              while (dirname_start != NULL) {
   1198                dirname_end = strchr(dirname_start, '/');
   1199                //SERIAL_ECHOPGM("start:");SERIAL_ECHOLN((int)(dirname_start - name));
   1200                //SERIAL_ECHOPGM("end  :");SERIAL_ECHOLN((int)(dirname_end - name));
   1201                if (dirname_end != NULL && dirname_end > dirname_start) {
   1202                  char subdirname[FILENAME_LENGTH];
   1203                  strncpy(subdirname, dirname_start, dirname_end - dirname_start);
   1204                  subdirname[dirname_end - dirname_start] = '\0';
   1205                  if (!myDir.open(curDir, subdirname, O_READ)) {
   1206                    SERIAL_PROTOCOLPGM(MSG_SD_OPEN_FILE_FAIL);
   1207                    SERIAL_PROTOCOL(subdirname);
   1208                    SERIAL_PROTOCOLCHAR('.');
   1209                    return;
   1210                  }
   1211                  else {
   1212                    //SERIAL_ECHOLNPGM("dive ok");
   1213                  }
   1214          
   1215                  curDir = &myDir;
   1216                  dirname_start = dirname_end + 1;
   1217                }
   1218                else { // the remainder after all /fsa/fdsa/ is the filename
   1219                  fname = dirname_start;
   1220                  //SERIAL_ECHOLNPGM("remainder");
   1221                  //SERIAL_ECHOLN(fname);
   1222                  break;
   1223                }
   1224              }
   1225            }
   1226            else
   1227              curDir = &workDir; // Relative paths start in current directory
   1228          
   1229            if (read) {
   1230              if (file.open(curDir, fname, O_READ)) {
   1231                filesize = file.fileSize();
   1232                sdpos = 0;
   1233                SERIAL_PROTOCOLPAIR(MSG_SD_FILE_OPENED, fname);
   1234                SERIAL_PROTOCOLLNPAIR(MSG_SD_SIZE, filesize);
   1235                SERIAL_PROTOCOLLNPGM(MSG_SD_FILE_SELECTED);
   1236                getfilename(0, fname);
   1237                lcd_setstatus(longFilename[0] ? longFilename : fname);
   1238              }
   1239              else {
   1240                SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, fname);
   1241                SERIAL_PROTOCOLCHAR('.');
   1242                SERIAL_EOL();
   1243              }
   1244            }
   1245            else { //write
   1246              if (!file.open(curDir, fname, O_CREAT | O_APPEND | O_WRITE | O_TRUNC)) {
   1247                SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, fname);
   1248                SERIAL_PROTOCOLCHAR('.');
   1249                SERIAL_EOL();
   1250              }
   1251              else {
   1252                saving = true;
   1253                SERIAL_PROTOCOLLNPAIR(MSG_SD_WRITE_TO_FILE, name);
   1254                lcd_setstatus(fname);
   1255              }
   1256            }
   1257          }
   1258          
   1259          void CardReader::removeFile(const char * const name) {
   1260            if (!cardOK) return;
   1261          
   1262            stopSDPrint();
   1263          
   1264            SdFile myDir;
   1265            curDir = &root;
   1266            const char *fname = name;
   1267          
   1268            char *dirname_start, *dirname_end;
   1269            if (name[0] == '/') {
   1270              dirname_start = strchr(name, '/') + 1;
   1271              while (dirname_start != NULL) {
   1272                dirname_end = strchr(dirname_start, '/');
   1273                //SERIAL_ECHOPGM("start:");SERIAL_ECHOLN((int)(dirname_start - name));
   1274                //SERIAL_ECHOPGM("end  :");SERIAL_ECHOLN((int)(dirname_end - name));
   1275                if (dirname_end != NULL && dirname_end > dirname_start) {
   1276                  char subdirname[FILENAME_LENGTH];
   1277                  strncpy(subdirname, dirname_start, dirname_end - dirname_start);
   1278                  subdirname[dirname_end - dirname_start] = 0;
   1279                  SERIAL_ECHOLN(subdirname);
   1280                  if (!myDir.open(curDir, subdirname, O_READ)) {
   1281                    SERIAL_PROTOCOLPAIR(MSG_SD_OPEN_FILE_FAIL, subdirname);
   1282                    SERIAL_PROTOCOLCHAR('.');
   1283                    SERIAL_EOL();
   1284                    return;
   1285                  }
   1286          
   1287                  curDir = &myDir;
   1288                  dirname_start = dirname_end + 1;
   1289                }
   1290                else {
   1291                  fname = dirname_start;
   1292                  break;
   1293                }
   1294              }
   1295            }
   1296            else // Relative paths are rooted in the current directory
   1297              curDir = &workDir;
   1298          
   1299            if (file.remove(curDir, fname)) {
   1300              SERIAL_PROTOCOLPGM("File deleted:");
   1301              SERIAL_PROTOCOLLN(fname);
   1302              sdpos = 0;
   1303              #if ENABLED(SDCARD_SORT_ALPHA)
   1304                presort();
   1305              #endif
   1306            }
   1307            else {
   1308              SERIAL_PROTOCOLPGM("Deletion failed, File: ");
   1309              SERIAL_PROTOCOL(fname);
   1310              SERIAL_PROTOCOLCHAR('.');
   1311            }
   1312          }
   1313          
   1314          void CardReader::getStatus() {
   1315            if (cardOK) {
   1316              SERIAL_PROTOCOLPGM(MSG_SD_PRINTING_BYTE);
   1317              SERIAL_PROTOCOL(sdpos);
   1318              SERIAL_PROTOCOLCHAR('/');
   1319              SERIAL_PROTOCOLLN(filesize);
   1320            }
   1321            else
   1322              SERIAL_PROTOCOLLNPGM(MSG_SD_NOT_PRINTING);
   1323          }
   1324          
   1325          void CardReader::write_command(char *buf) {
   1326            char* begin = buf;
   1327            char* npos = NULL;
   1328            char* end = buf + strlen(buf) - 1;
   1329          
   1330            file.writeError = false;
   1331            if ((npos = strchr(buf, 'N')) != NULL) {
   1332              begin = strchr(npos, ' ') + 1;
   1333              end = strchr(npos, '*') - 1;
   1334            }
   1335            end[1] = '\r';
   1336            end[2] = '\n';
   1337            end[3] = '\0';
   1338            file.write(begin);
   1339            if (file.writeError) {
   1340              SERIAL_ERROR_START();
   1341              SERIAL_ERRORLNPGM(MSG_SD_ERR_WRITE_TO_FILE);
   1342            }
   1343          }
   1344          
   1345          void CardReader::checkautostart(bool force) {
   1346            if (!force && (!autostart_stilltocheck || PENDING(millis(), next_autostart_ms)))
   1347              return;
   1348          
   1349            autostart_stilltocheck = false;
   1350          
   1351            if (!cardOK) {
   1352              initsd();
   1353              if (!cardOK) return; // fail
   1354            }
   1355          
   1356            char autoname[10];
   1357            sprintf_P(autoname, PSTR("auto%i.g"), autostart_index);
   1358            for (int8_t i = 0; i < (int8_t)strlen(autoname); i++) autoname[i] = tolower(autoname[i]);
   1359          
   1360            dir_t p;
   1361          
   1362            root.rewind();
   1363          
   1364            bool found = false;
   1365            while (root.readDir(p, NULL) > 0) {
   1366              for (int8_t i = (int8_t)strlen((char*)p.name); i--;) p.name[i] = tolower(p.name[i]);
   1367              if (p.name[9] != '~' && strncmp((char*)p.name, autoname, 5) == 0) {
   1368                openAndPrintFile(autoname);
   1369                found = true;
   1370              }
   1371            }
   1372            if (!found)
   1373              autostart_index = -1;
   1374            else
   1375              autostart_index++;
   1376          }
   1377          
   1378          void CardReader::closefile(bool store_location) {
   1379            file.sync();
   1380            file.close();
   1381            saving = logging = false;
   1382          
   1383            if (store_location) {
   1384              //future: store printer state, filename and position for continuing a stopped print
   1385              // so one can unplug the printer and continue printing the next day.
   1386            }
   1387          }
   1388          
   1389          /**
   1390           * Get the name of a file in the current directory by index
   1391           */
   1392          void CardReader::getfilename(uint16_t nr, const char * const match/*=NULL*/) {
   1393            #if ENABLED(SDSORT_CACHE_NAMES)
   1394              if (match != NULL) {
   1395                while (nr < sort_count) {
   1396                  if (strcasecmp(match, sortshort[nr]) == 0) break;
   1397                  nr++;
   1398                }
   1399              }
   1400              if (nr < sort_count) {
   1401                strcpy(filename, sortshort[nr]);
   1402                strcpy(longFilename, sortnames[nr]);
   1403                filenameIsDir = TEST(isDir[nr>>3], nr & 0x07);
   1404                return;
   1405              }
   1406            #endif // SDSORT_CACHE_NAMES
   1407            curDir = &workDir;
   1408            lsAction = LS_GetFilename;
   1409            nrFile_index = nr;
   1410            curDir->rewind();
   1411            lsDive("", *curDir, match);
   1412          }
   1413          
   1414          uint16_t CardReader::getnrfilenames() {
   1415            curDir = &workDir;
   1416            lsAction = LS_Count;
   1417            nrFiles = 0;
   1418            curDir->rewind();
   1419            lsDive("", *curDir);
   1420            //SERIAL_ECHOLN(nrFiles);
   1421            return nrFiles;
   1422          }
   1423          
   1424          void CardReader::chdir(const char * relpath) {
   1425            SdFile newDir;
   1426            SdFile *parent = &root;
   1427          
   1428            if (workDir.isOpen()) parent = &workDir;
   1429          
   1430            if (!newDir.open(*parent, relpath, O_READ)) {
   1431              SERIAL_ECHO_START();
   1432              SERIAL_ECHOPGM(MSG_SD_CANT_ENTER_SUBDIR);
   1433              SERIAL_ECHOLN(relpath);
   1434            }
   1435            else {
   1436              workDir = newDir;
   1437              if (workDirDepth < MAX_DIR_DEPTH)
   1438                workDirParents[workDirDepth++] = workDir;
   1439              #if ENABLED(SDCARD_SORT_ALPHA)
   1440                presort();
   1441              #endif
   1442            }
   1443          }
   1444          
   1445          int8_t CardReader::updir() {
   1446            if (workDirDepth > 0) {                                               // At least 1 dir has been saved
   1447              workDir = --workDirDepth ? workDirParents[workDirDepth - 1] : root; // Use parent, or root if none
   1448              #if ENABLED(SDCARD_SORT_ALPHA)
   1449                presort();
   1450              #endif
   1451            }
   1452            return workDirDepth;
   1453          }
   1454          
   1455          
   1456          #if ENABLED(SDCARD_SORT_ALPHA)
   1457          
   1458            /**
   1459             * Get the name of a file in the current directory by sort-index
   1460             */
   1461            void CardReader::getfilename_sorted(const uint16_t nr) {
   1462              getfilename(
   1463                #if ENABLED(SDSORT_GCODE)
   1464                  sort_alpha &&
   1465                #endif
   1466                (nr < sort_count) ? sort_order[nr] : nr
   1467              );
   1468            }
   1469          
   1470            /**
   1471             * Read all the files and produce a sort key
   1472             *
   1473             * We can do this in 3 ways...
   1474             *  - Minimal RAM: Read two filenames at a time sorting along...
   1475             *  - Some RAM: Buffer the directory just for this sort
   1476             *  - Most RAM: Buffer the directory and return filenames from RAM
   1477             */
   1478            void CardReader::presort() {
   1479          
   1480              // Sorting may be turned off
   1481              #if ENABLED(SDSORT_GCODE)
   1482                if (!sort_alpha) return;
   1483              #endif
   1484          
   1485              // Throw away old sort index
   1486              flush_presort();
   1487          
   1488              // If there are files, sort up to the limit
   1489              uint16_t fileCnt = getnrfilenames();
   1490              if (fileCnt > 0) {
   1491          
   1492                // Never sort more than the max allowed
   1493                // If you use folders to organize, 20 may be enough
   1494                if (fileCnt > SDSORT_LIMIT) fileCnt = SDSORT_LIMIT;
   1495          
   1496                // Sort order is always needed. May be static or dynamic.
   1497                #if ENABLED(SDSORT_DYNAMIC_RAM)
   1498                  sort_order = new uint8_t[fileCnt];
   1499                #endif
   1500          
   1501                // Use RAM to store the entire directory during pre-sort.
   1502                // SDSORT_LIMIT should be set to prevent over-allocation.
   1503                #if ENABLED(SDSORT_USES_RAM)
   1504          
   1505                  // If using dynamic ram for names, allocate on the heap.
   1506                  #if ENABLED(SDSORT_CACHE_NAMES)
   1507                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1508                      sortshort = new char*[fileCnt];
   1509                      sortnames = new char*[fileCnt];
   1510                    #endif
   1511                  #elif ENABLED(SDSORT_USES_STACK)
   1512                    char sortnames[fileCnt][SORTED_LONGNAME_MAXLEN];
   1513                  #endif
   1514          
   1515                  // Folder sorting needs 1 bit per entry for flags.
   1516                  #if HAS_FOLDER_SORTING
   1517                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1518                      isDir = new uint8_t[(fileCnt + 7) >> 3];
   1519                    #elif ENABLED(SDSORT_USES_STACK)
   1520                      uint8_t isDir[(fileCnt + 7) >> 3];
   1521                    #endif
   1522                  #endif
   1523          
   1524                #else // !SDSORT_USES_RAM
   1525          
   1526                  // By default re-read the names from SD for every compare
   1527                  // retaining only two filenames at a time. This is very
   1528                  // slow but is safest and uses minimal RAM.
   1529                  char name1[LONG_FILENAME_LENGTH + 1];
   1530          
   1531                #endif
   1532          
   1533                if (fileCnt > 1) {
   1534          
   1535                  // Init sort order.
   1536                  for (uint16_t i = 0; i < fileCnt; i++) {
   1537                    sort_order[i] = i;
   1538                    // If using RAM then read all filenames now.
   1539                    #if ENABLED(SDSORT_USES_RAM)
   1540                      getfilename(i);
   1541                      #if ENABLED(SDSORT_DYNAMIC_RAM)
   1542                        // Use dynamic method to copy long filename
   1543                        sortnames[i] = strdup(LONGEST_FILENAME);
   1544                        #if ENABLED(SDSORT_CACHE_NAMES)
   1545                          // When caching also store the short name, since
   1546                          // we're replacing the getfilename() behavior.
   1547                          sortshort[i] = strdup(filename);
   1548                        #endif
   1549                      #else
   1550                        // Copy filenames into the static array
   1551                        #if SORTED_LONGNAME_MAXLEN != LONG_FILENAME_LENGTH
   1552                          strncpy(sortnames[i], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1553                          sortnames[i][SORTED_LONGNAME_MAXLEN - 1] = '\0';
   1554                        #else
   1555                          strncpy(sortnames[i], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1556                        #endif
   1557                        #if ENABLED(SDSORT_CACHE_NAMES)
   1558                          strcpy(sortshort[i], filename);
   1559                        #endif
   1560                      #endif
   1561                      // char out[30];
   1562                      // sprintf_P(out, PSTR("---- %i %s %s"), i, filenameIsDir ? "D" : " ", sortnames[i]);
   1563                      // SERIAL_ECHOLN(out);
   1564                      #if HAS_FOLDER_SORTING
   1565                        const uint16_t bit = i & 0x07, ind = i >> 3;
   1566                        if (bit == 0) isDir[ind] = 0x00;
   1567                        if (filenameIsDir) isDir[ind] |= _BV(bit);
   1568                      #endif
   1569                    #endif
   1570                  }
   1571          
   1572                  // Bubble Sort
   1573                  for (uint16_t i = fileCnt; --i;) {
   1574                    bool didSwap = false;
   1575                    for (uint16_t j = 0; j < i; ++j) {
   1576                      const uint16_t o1 = sort_order[j], o2 = sort_order[j + 1];
   1577          
   1578                      // Compare names from the array or just the two buffered names
   1579                      #if ENABLED(SDSORT_USES_RAM)
   1580                        #define _SORT_CMP_NODIR() (strcasecmp(sortnames[o1], sortnames[o2]) > 0)
   1581                      #else
   1582                        #define _SORT_CMP_NODIR() (strcasecmp(name1, name2) > 0)
   1583                      #endif
   1584          
   1585                      #if HAS_FOLDER_SORTING
   1586                        #if ENABLED(SDSORT_USES_RAM)
   1587                          // Folder sorting needs an index and bit to test for folder-ness.
   1588                          const uint8_t ind1 = o1 >> 3, bit1 = o1 & 0x07,
   1589                                        ind2 = o2 >> 3, bit2 = o2 & 0x07;
   1590                          #define _SORT_CMP_DIR(fs) \
   1591                            (((isDir[ind1] & _BV(bit1)) != 0) == ((isDir[ind2] & _BV(bit2)) != 0) \
   1592                              ? _SORT_CMP_NODIR() \
   1593                              : (isDir[fs > 0 ? ind1 : ind2] & (fs > 0 ? _BV(bit1) : _BV(bit2))) != 0)
   1594                        #else
   1595                          #define _SORT_CMP_DIR(fs) ((dir1 == filenameIsDir) ? _SORT_CMP_NODIR() : (fs > 0 ? dir1 : !dir1))
   1596                        #endif
   1597                      #endif
   1598          
   1599                      // The most economical method reads names as-needed
   1600                      // throughout the loop. Slow if there are many.
   1601                      #if DISABLED(SDSORT_USES_RAM)
   1602                        getfilename(o1);
   1603                        strcpy(name1, LONGEST_FILENAME); // save (or getfilename below will trounce it)
   1604                        #if HAS_FOLDER_SORTING
   1605                          bool dir1 = filenameIsDir;
   1606                        #endif
   1607                        getfilename(o2);
   1608                        char *name2 = LONGEST_FILENAME; // use the string in-place
   1609                      #endif // !SDSORT_USES_RAM
   1610          
   1611                      // Sort the current pair according to settings.
   1612                      if (
   1613                        #if HAS_FOLDER_SORTING
   1614                          #if ENABLED(SDSORT_GCODE)
   1615                            sort_folders ? _SORT_CMP_DIR(sort_folders) : _SORT_CMP_NODIR()
   1616                          #else
   1617                            _SORT_CMP_DIR(FOLDER_SORTING)
   1618                          #endif
   1619                        #else
   1620                          _SORT_CMP_NODIR()
   1621                        #endif
   1622                      ) {
   1623                        sort_order[j] = o2;
   1624                        sort_order[j + 1] = o1;
   1625                        didSwap = true;
   1626                      }
   1627                    }
   1628                    if (!didSwap) break;
   1629                  }
   1630                  // Using RAM but not keeping names around
   1631                  #if ENABLED(SDSORT_USES_RAM) && DISABLED(SDSORT_CACHE_NAMES)
   1632                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1633                      for (uint16_t i = 0; i < fileCnt; ++i) free(sortnames[i]);
   1634                      #if HAS_FOLDER_SORTING
   1635                        free(isDir);
   1636                      #endif
   1637                    #endif
   1638                  #endif
   1639                }
   1640                else {
   1641                  sort_order[0] = 0;
   1642                  #if ENABLED(SDSORT_USES_RAM) && ENABLED(SDSORT_CACHE_NAMES)
   1643                    getfilename(0);
   1644                    #if ENABLED(SDSORT_DYNAMIC_RAM)
   1645                      sortnames = new char*[1];
   1646                      sortnames[0] = strdup(LONGEST_FILENAME); // malloc
   1647                      #if ENABLED(SDSORT_CACHE_NAMES)
   1648                        sortshort = new char*[1];
   1649                        sortshort[0] = strdup(filename);       // malloc
   1650                      #endif
   1651                      isDir = new uint8_t[1];
   1652                    #else
   1653                      #if SORTED_LONGNAME_MAXLEN != LONG_FILENAME_LENGTH
   1654                        strncpy(sortnames[0], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1655                        sortnames[0][SORTED_LONGNAME_MAXLEN - 1] = '\0';
   1656                      #else
   1657                        strncpy(sortnames[0], LONGEST_FILENAME, SORTED_LONGNAME_MAXLEN);
   1658                      #endif
   1659                      #if ENABLED(SDSORT_CACHE_NAMES)
   1660                        strcpy(sortshort[0], filename);
   1661                      #endif
   1662                    #endif
   1663                    isDir[0] = filenameIsDir ? 0x01 : 0x00;
   1664                  #endif
   1665                }
   1666          
   1667                sort_count = fileCnt;
   1668              }
   1669            }
   1670          
   1671            void CardReader::flush_presort() {
   1672              if (sort_count > 0) {
   1673                #if ENABLED(SDSORT_DYNAMIC_RAM)
   1674                  delete sort_order;
   1675                  #if ENABLED(SDSORT_CACHE_NAMES)
   1676                    for (uint8_t i = 0; i < sort_count; ++i) {
   1677                      free(sortshort[i]); // strdup
   1678                      free(sortnames[i]); // strdup
   1679                    }
   1680                    delete sortshort;
   1681                    delete sortnames;
   1682                  #endif
   1683                #endif
   1684                sort_count = 0;
   1685              }
   1686            }
   1687          
   1688          #endif // SDCARD_SORT_ALPHA
   1689          
   1690          uint16_t CardReader::get_num_Files() {
   1691            return
   1692              #if ENABLED(SDCARD_SORT_ALPHA) && SDSORT_USES_RAM && SDSORT_CACHE_NAMES
   1693                nrFiles // no need to access the SD card for filenames
   1694              #else
   1695                getnrfilenames()
   1696              #endif
   1697            ;
   1698          }
   1699          
   1700          void CardReader::printingHasFinished() {
   1701            stepper.synchronize();
   1702            file.close();
   1703            if (file_subcall_ctr > 0) { // Heading up to a parent file that called current as a procedure.
   1704              file_subcall_ctr--;
   1705              openFile(proc_filenames[file_subcall_ctr], true, true);
   1706              setIndex(filespos[file_subcall_ctr]);
   1707              startFileprint();
   1708            }
   1709            else {
   1710              sdprinting = false;
   1711              #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
   1712                stepper.cleaning_buffer_counter = 1; // The command will fire from the Stepper ISR
   1713              #endif
   1714              print_job_timer.stop();
   1715              if (print_job_timer.duration() > 60)
   1716                enqueue_and_echo_commands_P(PSTR("M31"));
   1717              #if ENABLED(SDCARD_SORT_ALPHA)
   1718                presort();
   1719              #endif
   1720          
   1721              #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
   1722                lcd_reselect_last_file();
   1723              #endif
   1724            }
   1725          }
   1726          #endif
   1727          
   1728          #endif // SDSUPPORT

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CardReader::CardReader()
         8   -> SdBaseFile::SdBaseFile()
    1008   CardReader::Explore_Disk(char *, uint8_t)
      1008   -> Print::print(char const *)
      1008   -> f_mount
      1008   -> f_opendir
      1008   -> f_readdir
      1008   -> memset
      1008   -> strcat
      1008   -> strcpy
      1008   -> strstr(char const *, char const *)
     808   CardReader::ShowSDFiles()
       808   -> f_mount
       808   -> f_opendir
       808   -> f_readdir
       808   -> strcat
       808   -> strcpy
       808   -> strstr(char *, char const *)
      12   CardReader::ascii2dec(char *, char)
       0   CardReader::automount()
      16   CardReader::checkFilesys(unsigned char)
        16   -> CardReader::initsd()
        16   -> serialprintPGM(char const *)
       0   CardReader::checkautostart(bool)
       8   CardReader::closefile(bool)
         8   -> f_close
       0   CardReader::continuePrint(bool)
       4   CardReader::createFilename(char *, dir_t const &)
       0   CardReader::deleteFile(char *)
       8   CardReader::finishWrite()
         8   -> f_close
         8   -> f_sync
      16   CardReader::getStatus()
        16   -> Print::print(unsigned int, int)
         0   -> USARTClass::write(uint8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::get_file_list(char *)
         0   -> CardReader::Explore_Disk(char *, uint8_t)
       0   CardReader::getsdpos()
      16   CardReader::initsd()
        16   -> f_mount
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       0   CardReader::initusb()
       0   CardReader::isFileOpen()
       0   CardReader::ls()
         0   -> CardReader::get_file_list(char *)
      16   CardReader::makeDirectory(char *)
        16   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
        16   -> f_close
        16   -> f_mkdir
       0   CardReader::mount()
         0   -> CardReader::initsd()
     208   CardReader::openFile(char *, bool, bool)
       208   -> Print::print(unsigned int, int)
       208   -> SdBaseFile::SdBaseFile()
       208   -> USARTClass::write(uint8_t)
       208   -> __aeabi_memclr4
       208   -> f_close
       208   -> f_open
       208   -> mks_saveFileName
       208   -> serial_echopair_P(char const *, char const *)
       208   -> serialprintPGM(char const *)
       208   -> strcat
       0   CardReader::openLogFile(char *)
         0   -> CardReader::openFile(char *, bool, bool)
       0   CardReader::operatePrint()
       0   CardReader::pausePrint(bool)
       0   CardReader::pauseSDPrint()
       0   CardReader::printStatus()
       8   CardReader::printingHasFinished()
         8   -> Stepper::synchronize()
         8   -> Stopwatch::duration()
         8   -> Stopwatch::stop()
         0   -> enqueue_and_echo_commands_P(char const *)
         8   -> enqueue_and_echo_commands_P(char const *)
         8   -> f_close
       0   CardReader::release()
      16   CardReader::removeFile(char *)
        16   -> Print::print(char const *)
        16   -> USARTClass::write(uint8_t)
        16   -> f_close
        16   -> f_unlink
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      16   CardReader::reopenfile(char *)
        16   -> f_close
        16   -> f_open
       0   CardReader::selectFile(char *, bool)
       0   CardReader::showFilename(uint8_t const *)
       0   CardReader::startFileprint()
         0   -> epr_write_data
       0   CardReader::startPrint()
      16   CardReader::startWrite(char *)
        16   -> f_close
        16   -> f_open
       0   CardReader::stopPrint()
       8   CardReader::stopSDPrint()
         0   -> CardReader::closefile(bool)
         8   -> CardReader::isFileOpen()
       0   CardReader::subobject CardReader()
         0   -> CardReader::CardReader()
       0   CardReader::unmount()
      32   CardReader::write_command(char *)
        32   -> f_write
        32   -> memset
        32   -> serialprintPGM(char const *)
        32   -> strchr(char *, int)
        32   -> strlen
      16   RFstricmp(char const *, char const *)
        16   -> tolower
      24   RFstrnicmp(char const *, char const *, size_t)
        24   -> tolower
       0   SdBaseFile::SdBaseFile()
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   strchr(char *, int)
         0   -> __iar_Strchr
       0   strstr(char *, char const *)
         0   -> __iar_Strstr
       0   strstr(char const *, char const *)
         0   -> __iar_Strstr


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       8  ?<Constant " Size: ">
       8  ?<Constant ".DIR\r\n">
       8  ?<Constant ".GCO">
       4  ?<Constant ".\n">
       8  ?<Constant ".gco">
       2  ?<Constant "/">
      16  ?<Constant "Creation failed">
      24  ?<Constant "Deletion failed, File: ">
      20  ?<Constant "Directory created">
      16  ?<Constant "File deleted:">
      16  ?<Constant "File opened: ">
      16  ?<Constant "File selected\n">
       4  ?<Constant "M31">
      12  ?<Constant "M84 X Y Z E">
      20  ?<Constant "Not SD printing\n">
      12  ?<Constant "SD card ok\n">
      20  ?<Constant "SD card removed\n">
      16  ?<Constant "SD init fail\n">
      20  ?<Constant "SD printing byte ">
      24  ?<Constant "Select SD file system\n">
       4  ?<Constant "\r\n">
      24  ?<Constant "error writing to file\n">
      20  ?<Constant "open failed, File: ">
     152  ?<Constant {'\000'}>
       4  ??DataTable35
       4  ??DataTable37
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_10
       4  ??DataTable38_11
       4  ??DataTable38_12
       4  ??DataTable38_13
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable38_6
       4  ??DataTable38_7
       4  ??DataTable38_8
       4  ??DataTable38_9
      42  CardReader::CardReader()
     244  CardReader::Explore_Disk(char *, uint8_t)
     270  CardReader::ShowSDFiles()
      72  CardReader::ascii2dec(char *, char)
       2  CardReader::automount()
      90  CardReader::checkFilesys(unsigned char)
       2  CardReader::checkautostart(bool)
      20  CardReader::closefile(bool)
       2  CardReader::continuePrint(bool)
      52  CardReader::createFilename(char *, dir_t const &)
       2  CardReader::deleteFile(char *)
      32  CardReader::finishWrite()
      86  CardReader::getStatus()
      10  CardReader::get_file_list(char *)
       6  CardReader::getsdpos()
      80  CardReader::initsd()
       2  CardReader::initusb()
      16  CardReader::isFileOpen()
      26  CardReader::ls()
      94  CardReader::makeDirectory(char *)
      12  CardReader::mount()
     200  CardReader::openFile(char *, bool, bool)
      12  CardReader::openLogFile(char *)
       2  CardReader::operatePrint()
      20  CardReader::pausePrint(bool)
      22  CardReader::pauseSDPrint()
       2  CardReader::printStatus()
      62  CardReader::printingHasFinished()
      20  CardReader::release()
     112  CardReader::removeFile(char *)
      40  CardReader::reopenfile(char *)
       2  CardReader::selectFile(char *, bool)
      18  CardReader::showFilename(uint8_t const *)
      64  CardReader::startFileprint()
      20  CardReader::startPrint()
      62  CardReader::startWrite(char *)
      24  CardReader::stopPrint()
      32  CardReader::stopSDPrint()
       2  CardReader::subobject CardReader()
      20  CardReader::unmount()
     118  CardReader::write_command(char *)
      62  RFstricmp(char const *, char const *)
      72  RFstrnicmp(char const *, char const *, size_t)
       8  SdBaseFile::SdBaseFile()
     256  lfn
     256  lfn
      28  serialprintPGM(char const *)
       4  strchr(char *, int)
       4  strstr(char *, char const *)
       4  strstr(char const *, char const *)
       1  -- Other

 
   512 bytes in section .bss
   167 bytes in section .rodata
 2 570 bytes in section .text
 
 2 506 bytes of CODE  memory (+ 64 bytes shared)
   166 bytes of CONST memory (+  1 byte  shared)
   512 bytes of DATA  memory

Errors: none
Warnings: 110
