###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  09:25:18
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\stepper.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\stepper.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * stepper.cpp - A singleton object to execute motion plans using stepper motors
     25           * Marlin Firmware
     26           *
     27           * Derived from Grbl
     28           * Copyright (c) 2009-2011 Simen Svale Skogsrud
     29           *
     30           * Grbl is free software: you can redistribute it and/or modify
     31           * it under the terms of the GNU General Public License as published by
     32           * the Free Software Foundation, either version 3 of the License, or
     33           * (at your option) any later version.
     34           *
     35           * Grbl is distributed in the hope that it will be useful,
     36           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     37           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     38           * GNU General Public License for more details.
     39           *
     40           * You should have received a copy of the GNU General Public License
     41           * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
     42           */
     43          
     44          /* The timer calculations of this module informed by the 'RepRap cartesian firmware' by Zack Smith
     45             and Philipp Tiefenbacher. */
     46          
     47          #include "Marlin.h"

  #define UNUSED(x) ((void)(x))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Inc\mks_cfg.h",626  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

    }
    ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     48          #include "stepper.h"

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless

   \                                 In section .text, align 4
   \   __interwork __softfp unsigned short Stepper::calc_timer_interval(unsigned short)
   \                     _ZN7Stepper19calc_timer_intervalEt: (+1)
   \   00000000   0xF649 0x4241      MOVW     R2,#+40001
   \   00000004   0x4290             CMP      R0,R2
   \   00000006   0xBFAE             ITEE     GE 
   \   00000008   0xF649 0x4040      MOVWGE   R0,#+40000
   \   0000000C   0xF644 0x6221      MOVWLT   R2,#+20001
   \   00000010   0x4290             CMPLT    R0,R2
   \   00000012   0xDB02             BLT.N    ??calc_timer_interval_0
   \   00000014   0x0880             LSRS     R0,R0,#+2
   \   00000016   0x2104             MOVS     R1,#+4
   \   00000018   0xE006             B.N      ??calc_timer_interval_1
   \                     ??calc_timer_interval_0: (+1)
   \   0000001A   0xF242 0x7211      MOVW     R2,#+10001
   \   0000001E   0x4290             CMP      R0,R2
   \   00000020   0xBFA6             ITTE     GE 
   \   00000022   0x0840             LSRGE    R0,R0,#+1
   \   00000024   0x2102             MOVGE    R1,#+2
   \   00000026   0x2101             MOVLT    R1,#+1
   \                     ??calc_timer_interval_1: (+1)
   \   00000028   0x4A06             LDR.N    R2,??calc_timer_interval_2
   \   0000002A   0x7211             STRB     R1,[R2, #+8]
   \   0000002C   0xEB00 0x02C0      ADD      R2,R0,R0, LSL #+3
   \   00000030   0x4905             LDR.N    R1,??calc_timer_interval_2+0x4  ;; 0x44aa200
   \   00000032   0x0090             LSLS     R0,R2,#+2
   \   00000034   0xFB91 0xF0F0      SDIV     R0,R1,R0
   \   00000038   0xB280             UXTH     R0,R0
   \   0000003A   0x2864             CMP      R0,#+100
   \   0000003C   0xBFB8             IT       LT 
   \   0000003E   0x2064             MOVLT    R0,#+100
   \   00000040   0x4770             BX       LR               ;; return
   \   00000042   0xBF00             Nop      
   \                     ??calc_timer_interval_2:
   \   00000044   0x........         DC32     _ZN7Stepper15count_directionE
   \   00000048   0x044AA200         DC32     0x44aa200

   \                                 In section .data, align 1
   \   __absolute int8_t Stepper::trapezoid_generator_reset()::last_extruder
   \                     _ZZN7Stepper25trapezoid_generator_resetEvE13last_extruder:
   \   00000000   0xFF               DC8 -1
     49          #include "endstops.h"
     50          #include "planner.h"
     51          #include "temperature.h"

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer

          target_temperature_bed =
                                 ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
     52          #include "ultralcd.h"
     53          #include "language.h"
     54          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 524 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\Marlin_export.h")

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middleware
          s\Third_Party\Marlin\SdFatConfig.h")
     55          #include "mks_cfg.h"
     56          //#include "speed_lookuptable.h"
     57          #include "tim.h"
     58          
     59          #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)
     60            #include "ubl.h"
     61          #endif
     62          
     63          #if HAS_DIGIPOTSS
     64            #include <SPI.h>
     65          #endif
     66          

   \                                 In section .bss, align 4
     67          Stepper stepper; // Singleton
   \                     stepper:
   \   00000000                      DS8 4
     68          
     69          // public:
     70          
     71          block_t* Stepper::current_block = NULL;  // A pointer to the block currently being traced
     72          
     73          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
     74            bool Stepper::abort_on_endstop_hit = false;
     75          #endif
     76          
     77          #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
     78            bool Stepper::performing_homing = false;
     79          #endif
     80          
     81          #if HAS_MOTOR_CURRENT_PWM
     82            uint32_t Stepper::motor_current_setting[3]; // Initialized by settings.load()
     83          #endif
     84          
     85          // private:
     86          
     87          uint8_t Stepper::last_direction_bits = 0;        // The next stepping-bits to be output
     88          int16_t Stepper::cleaning_buffer_counter = 0;
     89          
     90          #if ENABLED(X_DUAL_ENDSTOPS)
     91            bool Stepper::locked_x_motor = false, Stepper::locked_x2_motor = false;
     92          #endif
     93          #if ENABLED(Y_DUAL_ENDSTOPS)
     94            bool Stepper::locked_y_motor = false, Stepper::locked_y2_motor = false;
     95          #endif
     96          #if 1//ENABLED(Z_DUAL_ENDSTOPS)
     97            bool Stepper::locked_z_motor = false, Stepper::locked_z2_motor = false;
     98          #endif
     99          
    100          long Stepper::counter_X = 0,
    101               Stepper::counter_Y = 0,
    102               Stepper::counter_Z = 0,
    103               Stepper::counter_E = 0;
    104          
    105          volatile uint32_t Stepper::step_events_completed = 0; // The number of step events executed in the current block
    106          
    107          #if ENABLED(LIN_ADVANCE)
    108          
    109            constexpr uint16_t ADV_NEVER = 65535;
    110          
    111            uint16_t Stepper::nextMainISR = 0,
    112                     Stepper::nextAdvanceISR = ADV_NEVER,
    113                     Stepper::eISR_Rate = ADV_NEVER;
    114          
    115            volatile int Stepper::e_steps[E_STEPPERS];
    116            int Stepper::final_estep_rate,
    117                Stepper::current_estep_rate[E_STEPPERS],
    118                Stepper::current_adv_steps[E_STEPPERS];
    119          
    120            /**
    121             * See https://github.com/MarlinFirmware/Marlin/issues/5699#issuecomment-309264382
    122             *
    123             * This fix isn't perfect and may lose steps - but better than locking up completely
    124             * in future the planner should slow down if advance stepping rate would be too high
    125             */
    126            FORCE_INLINE uint16_t adv_rate(const int steps, const uint16_t timer, const uint8_t loops) {
    127              if (steps) {
    128                const uint16_t rate = (timer * loops) / abs(steps);
    129                //return constrain(rate, 1, ADV_NEVER - 1)
    130                return rate ? rate : 1;
    131              }
    132              return ADV_NEVER;
    133            }
    134          
    135          #endif // LIN_ADVANCE
    136          
    137          long Stepper::acceleration_time, Stepper::deceleration_time;
    138          
    139          volatile long Stepper::count_position[NUM_AXIS] = { 0 };
    140          volatile signed char Stepper::count_direction[NUM_AXIS] = { 1, 1, 1, 1 };
    141          
    142          #if ENABLED(MIXING_EXTRUDER)
    143            long Stepper::counter_m[MIXING_STEPPERS];
    144          #endif
    145          
    146          uint8_t Stepper::step_loops, Stepper::step_loops_nominal;
    147          
    148          uint16_t Stepper::OCR1A_nominal,
    149                   Stepper::acc_step_rate; // needed for deceleration start point
    150          
    151          volatile long Stepper::endstops_trigsteps[XYZ];
    152          
    153          #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
    154            #define LOCKED_X_MOTOR  locked_x_motor
    155            #define LOCKED_Y_MOTOR  locked_y_motor
    156            #define LOCKED_Z_MOTOR  locked_z_motor
    157            #define LOCKED_X2_MOTOR locked_x2_motor
    158            #define LOCKED_Y2_MOTOR locked_y2_motor
    159            #define LOCKED_Z2_MOTOR locked_z2_motor
    160            #define DUAL_ENDSTOP_APPLY_STEP(AXIS,v)                                                                                                             \
    161              if (performing_homing) {                                                                                                                          \
    162                if (AXIS##_HOME_DIR < 0) {                                                                                                                      \
    163                  if (!(TEST(endstops.old_endstop_bits, AXIS##_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
    164                  if (!(TEST(endstops.old_endstop_bits, AXIS##2_MIN) && (count_direction[AXIS##_AXIS] < 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
    165                }                                                                                                                                               \
    166                else {                                                                                                                                          \
    167                  if (!(TEST(endstops.old_endstop_bits, AXIS##_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##_MOTOR) AXIS##_STEP_WRITE(v);     \
    168                  if (!(TEST(endstops.old_endstop_bits, AXIS##2_MAX) && (count_direction[AXIS##_AXIS] > 0)) && !LOCKED_##AXIS##2_MOTOR) AXIS##2_STEP_WRITE(v);  \
    169                }                                                                                                                                               \
    170              }                                                                                                                                                 \
    171              else {                                                                                                                                            \
    172                AXIS##_STEP_WRITE(v);                                                                                                                           \
    173                AXIS##2_STEP_WRITE(v);                                                                                                                          \
    174              }
    175          #endif
    176          
    177          #if ENABLED(X_DUAL_STEPPER_DRIVERS)
    178            #define X_APPLY_DIR(v,Q) do{ X_DIR_WRITE(v); X2_DIR_WRITE((v) != INVERT_X2_VS_X_DIR); }while(0)
    179            #if ENABLED(DUAL_X_CARRIAGE)
    180              #define X_APPLY_DIR(v,ALWAYS) \
    181                if (extruder_duplication_enabled || ALWAYS) { \
    182                  X_DIR_WRITE(v); \
    183                  X2_DIR_WRITE(v); \
    184                } \
    185                else { \
    186                  if (current_block->active_extruder) X2_DIR_WRITE(v); else X_DIR_WRITE(v); \
    187                }
    188              #define X_APPLY_STEP(v,ALWAYS) \
    189                if (extruder_duplication_enabled || ALWAYS) { \
    190                  X_STEP_WRITE(v); \
    191                  X2_STEP_WRITE(v); \
    192                } \
    193                else { \
    194                  if (current_block->active_extruder) X2_STEP_WRITE(v); else X_STEP_WRITE(v); \
    195                }
    196            #elif ENABLED(X_DUAL_ENDSTOPS)
    197              #define X_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(X,v)
    198            #else
    199              #define X_APPLY_STEP(v,Q) do{ X_STEP_WRITE(v); X2_STEP_WRITE(v); }while(0)
    200            #endif
    201          #else
    202            #define X_APPLY_DIR(v,Q) X_DIR_WRITE(v)
    203            #define X_APPLY_STEP(v,Q) X_STEP_WRITE(v)
    204          #endif
    205          
    206          #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
    207            #define Y_APPLY_DIR(v,Q) do{ Y_DIR_WRITE(v); Y2_DIR_WRITE((v) != INVERT_Y2_VS_Y_DIR); }while(0)
    208            #if ENABLED(Y_DUAL_ENDSTOPS)
    209              #define Y_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Y,v)
    210            #else
    211              #define Y_APPLY_STEP(v,Q) do{ Y_STEP_WRITE(v); Y2_STEP_WRITE(v); }while(0)
    212            #endif
    213          #else
    214            #define Y_APPLY_DIR(v,Q) Y_DIR_WRITE(v)
    215            #define Y_APPLY_STEP(v,Q) Y_STEP_WRITE(v)
    216          #endif
    217          /*
    218          #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
    219            #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); Z2_DIR_WRITE(v); }while(0)
    220            #if ENABLED(Z_DUAL_ENDSTOPS)
    221              #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
    222            #else
    223              #define Z_APPLY_STEP(v,Q) do{ Z_STEP_WRITE(v); Z2_STEP_WRITE(v); }while(0)
    224            #endif
    225          #else
    226            #define Z_APPLY_DIR(v,Q) Z_DIR_WRITE(v)
    227            #define Z_APPLY_STEP(v,Q) Z_STEP_WRITE(v)
    228          #endif
    229          */
    230          
    231          #define Z_APPLY_DIR(v,Q) do{ Z_DIR_WRITE(v); if(Z_DUAL_STEPPER_DRIVERS==1)Z2_DIR_WRITE(v); }while(0)
    232          #if 0//ENABLED(Z_DUAL_ENDSTOPS)
    233            #define Z_APPLY_STEP(v,Q) DUAL_ENDSTOP_APPLY_STEP(Z,v)
    234          #else
    235            #define Z_APPLY_STEP(v,Q) if(Z_DUAL_ENDSTOPS==1){DUAL_ENDSTOP_APPLY_STEP(Z,v)}else{do{ Z_STEP_WRITE(v); if(Z_DUAL_STEPPER_DRIVERS==1)Z2_STEP_WRITE(v); }while(0);}
    236          #endif
    237          
    238          
    239          #if DISABLED(MIXING_EXTRUDER)
    240            #define E_APPLY_STEP(v,Q) E_STEP_WRITE(v)
    241          #endif
    242          
    243          // intRes = longIn1 * longIn2 >> 24
    244          // uses:
    245          // r26 to store 0
    246          // r27 to store bits 16-23 of the 48bit result. The top bit is used to round the two byte result.
    247          // note that the lower two bytes and the upper byte of the 48bit result are not calculated.
    248          // this can cause the result to be out by one as the lower bytes may cause carries into the upper ones.
    249          // B0 A0 are bits 24-39 and are the returned value
    250          // C1 B1 A1 is longIn1
    251          // D2 C2 B2 A2 is longIn2
    252          //
    253          #define MultiU24X32toH16(intRes, longIn1, longIn2)  intRes = (uint16_t)((((uint64_t)longIn1 * (uint64_t)longIn2)>> 24)& 0XFFFF);
    254          /*
    255          #define MultiU24X32toH16(intRes, longIn1, longIn2) \
    256            asm volatile ( \
    257                           "clr r26 \n\t" \
    258                           "mul %A1, %B2 \n\t" \
    259                           "mov r27, r1 \n\t" \
    260                           "mul %B1, %C2 \n\t" \
    261                           "movw %A0, r0 \n\t" \
    262                           "mul %C1, %C2 \n\t" \
    263                           "add %B0, r0 \n\t" \
    264                           "mul %C1, %B2 \n\t" \
    265                           "add %A0, r0 \n\t" \
    266                           "adc %B0, r1 \n\t" \
    267                           "mul %A1, %C2 \n\t" \
    268                           "add r27, r0 \n\t" \
    269                           "adc %A0, r1 \n\t" \
    270                           "adc %B0, r26 \n\t" \
    271                           "mul %B1, %B2 \n\t" \
    272                           "add r27, r0 \n\t" \
    273                           "adc %A0, r1 \n\t" \
    274                           "adc %B0, r26 \n\t" \
    275                           "mul %C1, %A2 \n\t" \
    276                           "add r27, r0 \n\t" \
    277                           "adc %A0, r1 \n\t" \
    278                           "adc %B0, r26 \n\t" \
    279                           "mul %B1, %A2 \n\t" \
    280                           "add r27, r1 \n\t" \
    281                           "adc %A0, r26 \n\t" \
    282                           "adc %B0, r26 \n\t" \
    283                           "lsr r27 \n\t" \
    284                           "adc %A0, r26 \n\t" \
    285                           "adc %B0, r26 \n\t" \
    286                           "mul %D2, %A1 \n\t" \
    287                           "add %A0, r0 \n\t" \
    288                           "adc %B0, r1 \n\t" \
    289                           "mul %D2, %B1 \n\t" \
    290                           "add %B0, r0 \n\t" \
    291                           "clr r1 \n\t" \
    292                           : \
    293                           "=&r" (intRes) \
    294                           : \
    295                           "d" (longIn1), \
    296                           "d" (longIn2) \
    297                           : \
    298                           "r26" , "r27" \
    299                         )
    300          */
    301          // Some useful constants
    302          
    303          /**
    304           *         __________________________
    305           *        /|                        |\     _________________         ^
    306           *       / |                        | \   /|               |\        |
    307           *      /  |                        |  \ / |               | \       s
    308           *     /   |                        |   |  |               |  \      p
    309           *    /    |                        |   |  |               |   \     e
    310           *   +-----+------------------------+---+--+---------------+----+    e
    311           *   |               BLOCK 1            |      BLOCK 2          |    d
    312           *
    313           *                           time ----->
    314           *
    315           *  The trapezoid is the shape the speed curve over time. It starts at block->initial_rate, accelerates
    316           *  first block->accelerate_until step_events_completed, then keeps going at constant speed until
    317           *  step_events_completed reaches block->decelerate_after after which it decelerates until the trapezoid generator is reset.
    318           *  The slope of acceleration is calculated using v = u + at where t is the accumulated timer values of the steps so far.
    319           */

   \                                 In section .text, align 2, keep-with-next
    320          void Stepper::wake_up() {
    321            // TCNT1 = 0;
    322            ENABLE_STEPPER_DRIVER_INTERRUPT();
   \                     _ZN7Stepper7wake_upEv: (+1)
   \   00000000   0x....             B.N      ?Subroutine0
    323          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine0: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000004   0x.... 0x....      B.W      HAL_TIM_Base_Start_IT
    324          
    325          /**
    326           * Set the stepper direction of each axis
    327           *
    328           *   COREXY: X_AXIS=A_AXIS and Y_AXIS=B_AXIS
    329           *   COREXZ: X_AXIS=A_AXIS and Z_AXIS=C_AXIS
    330           *   COREYZ: Y_AXIS=B_AXIS and Z_AXIS=C_AXIS
    331           */

   \                                 In section .text, align 2, keep-with-next
    332          void Stepper::set_directions() {
   \                     _ZN7Stepper14set_directionsEv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    333          
    334            #define SET_STEP_DIR(AXIS) \
    335              if (motor_direction(AXIS ##_AXIS)) { \
    336                AXIS ##_APPLY_DIR(INVERT_## AXIS ##_DIR, false); \
    337                count_direction[AXIS ##_AXIS] = -1; \
    338              } \
    339              else { \
    340                AXIS ##_APPLY_DIR(!INVERT_## AXIS ##_DIR, false); \
    341                count_direction[AXIS ##_AXIS] = 1; \
    342              }
    343          
    344            #if HAS_X_DIR
    345              SET_STEP_DIR(X); // A
   \   00000002   0x.... 0x....      LDR.W    R7,??DataTable19
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable19_1
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable19_2
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable20
   \   00000012   0x797A             LDRB     R2,[R7, #+5]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x8829             LDRH     R1,[R5, #+0]
   \   00000018   0x7833             LDRB     R3,[R6, #+0]
   \   0000001A   0x07D2             LSLS     R2,R2,#+31
   \   0000001C   0xD407             BMI.N    ??set_directions_0
   \   0000001E   0x1E5A             SUBS     R2,R3,#+1
   \   00000020   0x4192             SBCS     R2,R2,R2
   \   00000022   0x0FD2             LSRS     R2,R2,#+31
   \   00000024   0xB252             SXTB     R2,R2
   \   00000026   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0xE004             B.N      ??set_directions_1
   \                     ??set_directions_0: (+1)
   \   0000002E   0xB25A             SXTB     R2,R3
   \   00000030   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000034   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??set_directions_1: (+1)
   \   00000038   0x7038             STRB     R0,[R7, #+0]
    346            #endif
    347            #if HAS_Y_DIR
    348              SET_STEP_DIR(Y); // B
   \   0000003A   0x797A             LDRB     R2,[R7, #+5]
   \   0000003C   0x6960             LDR      R0,[R4, #+20]
   \   0000003E   0x8969             LDRH     R1,[R5, #+10]
   \   00000040   0x7873             LDRB     R3,[R6, #+1]
   \   00000042   0x0792             LSLS     R2,R2,#+30
   \   00000044   0xD407             BMI.N    ??set_directions_2
   \   00000046   0x1E5A             SUBS     R2,R3,#+1
   \   00000048   0x4192             SBCS     R2,R2,R2
   \   0000004A   0x0FD2             LSRS     R2,R2,#+31
   \   0000004C   0xB252             SXTB     R2,R2
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0xE004             B.N      ??set_directions_3
   \                     ??set_directions_2: (+1)
   \   00000056   0xB25A             SXTB     R2,R3
   \   00000058   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000005C   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??set_directions_3: (+1)
   \   00000060   0x7078             STRB     R0,[R7, #+1]
    349            #endif
    350            #if HAS_Z_DIR
    351              SET_STEP_DIR(Z); // C
   \   00000062   0x7978             LDRB     R0,[R7, #+5]
   \   00000064   0x0740             LSLS     R0,R0,#+29
   \   00000066   0xD425             BMI.N    ??set_directions_4
   \   00000068   0x78B0             LDRB     R0,[R6, #+2]
   \   0000006A   0x8AA9             LDRH     R1,[R5, #+20]
   \   0000006C   0x1E42             SUBS     R2,R0,#+1
   \   0000006E   0x4192             SBCS     R2,R2,R2
   \   00000070   0x0FD2             LSRS     R2,R2,#+31
   \   00000072   0x6AA0             LDR      R0,[R4, #+40]
   \   00000074   0xB252             SXTB     R2,R2
   \   00000076   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007A   0xF896 0x0101      LDRB     R0,[R6, #+257]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD108             BNE.N    ??set_directions_5
   \   00000082   0x78B0             LDRB     R0,[R6, #+2]
   \   00000084   0x8CA9             LDRH     R1,[R5, #+36]
   \   00000086   0x1E42             SUBS     R2,R0,#+1
   \   00000088   0x4192             SBCS     R2,R2,R2
   \   0000008A   0x0FD2             LSRS     R2,R2,#+31
   \   0000008C   0x6CA0             LDR      R0,[R4, #+72]
   \   0000008E   0xB252             SXTB     R2,R2
   \   00000090   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??set_directions_5: (+1)
   \   00000094   0x2001             MOVS     R0,#+1
   \                     ??set_directions_6: (+1)
   \   00000096   0x70B8             STRB     R0,[R7, #+2]
   \   00000098   0x6A38             LDR      R0,[R7, #+32]
   \   0000009A   0x7979             LDRB     R1,[R7, #+5]
   \   0000009C   0x7840             LDRB     R0,[R0, #+1]
   \   0000009E   0x0709             LSLS     R1,R1,#+28
   \   000000A0   0xD41B             BMI.N    ??set_directions_7
    352            #endif
    353          
    354            #if DISABLED(LIN_ADVANCE)
    355              if (motor_direction(E_AXIS)) {
    356                REV_E_DIR();
    357                count_direction[E_AXIS] = -1;
    358              }
    359              else {
    360                NORM_E_DIR();
   \   000000A2   0xBB48             CBNZ.N   R0,??set_directions_8
   \   000000A4   0x78F0             LDRB     R0,[R6, #+3]
   \   000000A6   0x8BE9             LDRH     R1,[R5, #+30]
   \   000000A8   0x1E42             SUBS     R2,R0,#+1
   \   000000AA   0x4192             SBCS     R2,R2,R2
   \   000000AC   0x0FD2             LSRS     R2,R2,#+31
   \   000000AE   0x6BE0             LDR      R0,[R4, #+60]
   \   000000B0   0xB252             SXTB     R2,R2
   \   000000B2   0xE028             B.N      ??set_directions_9
   \                     ??set_directions_4: (+1)
   \   000000B4   0xF996 0x2002      LDRSB    R2,[R6, #+2]
   \   000000B8   0x8AA9             LDRH     R1,[R5, #+20]
   \   000000BA   0x6AA0             LDR      R0,[R4, #+40]
   \   000000BC   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000C0   0xF896 0x0101      LDRB     R0,[R6, #+257]
   \   000000C4   0x2801             CMP      R0,#+1
   \   000000C6   0xD105             BNE.N    ??set_directions_10
   \   000000C8   0xF996 0x2002      LDRSB    R2,[R6, #+2]
   \   000000CC   0x8CA9             LDRH     R1,[R5, #+36]
   \   000000CE   0x6CA0             LDR      R0,[R4, #+72]
   \   000000D0   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??set_directions_10: (+1)
   \   000000D4   0xF04F 0x30FF      MOV      R0,#-1
   \   000000D8   0xE7DD             B.N      ??set_directions_6
   \                     ??set_directions_7: (+1)
   \   000000DA   0xB920             CBNZ.N   R0,??set_directions_11
   \   000000DC   0xF996 0x2003      LDRSB    R2,[R6, #+3]
   \   000000E0   0x8BE9             LDRH     R1,[R5, #+30]
   \   000000E2   0x6BE0             LDR      R0,[R4, #+60]
   \   000000E4   0xE003             B.N      ??set_directions_12
   \                     ??set_directions_11: (+1)
   \   000000E6   0xF996 0x2004      LDRSB    R2,[R6, #+4]
   \   000000EA   0x8CA9             LDRH     R1,[R5, #+36]
   \   000000EC   0x6CA0             LDR      R0,[R4, #+72]
   \                     ??set_directions_12: (+1)
   \   000000EE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000F2   0xF04F 0x30FF      MOV      R0,#-1
   \   000000F6   0xE009             B.N      ??set_directions_13
   \                     ??set_directions_8: (+1)
   \   000000F8   0x7930             LDRB     R0,[R6, #+4]
   \   000000FA   0x8CA9             LDRH     R1,[R5, #+36]
   \   000000FC   0x1E42             SUBS     R2,R0,#+1
   \   000000FE   0x4192             SBCS     R2,R2,R2
   \   00000100   0x0FD2             LSRS     R2,R2,#+31
   \   00000102   0x6CA0             LDR      R0,[R4, #+72]
   \   00000104   0xB252             SXTB     R2,R2
   \                     ??set_directions_9: (+1)
   \   00000106   0x.... 0x....      BL       HAL_GPIO_WritePin
    361                count_direction[E_AXIS] = 1;
   \   0000010A   0x2001             MOVS     R0,#+1
   \                     ??set_directions_13: (+1)
   \   0000010C   0x70F8             STRB     R0,[R7, #+3]
    362              }
    363            #endif // !LIN_ADVANCE
    364              //HAL_Delay(2);
    365          }
   \   0000010E   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    366          
    367          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    368            extern volatile uint8_t e_hit;
    369          #endif
    370          
    371          /**
    372           * Stepper Driver Interrupt
    373           *
    374           * Directly pulses the stepper motors at high frequency.
    375           * Timer 1 runs at a base frequency of 2MHz, with this ISR using OCR1A compare mode.
    376           *
    377           * OCR1A   Frequency
    378           *     1     2 MHz
    379           *    50    40 KHz
    380           *   100    20 KHz - capped max rate
    381           *   200    10 KHz - nominal max rate
    382           *  2000     1 KHz - sleep rate
    383           *  4000   500  Hz - init rate
    384           */
    385           /*
    386          ISR(TIMER1_COMPA_vect) {
    387            #if ENABLED(LIN_ADVANCE)
    388              Stepper::advance_isr_scheduler();
    389            #else
    390              Stepper::isr();
    391            #endif
    392          }
    393          */
    394          
    395          //#define _ENABLE_ISRs() do { cli(); if (thermalManager.in_temp_isr) CBI(TIMSK0, OCIE0B); else SBI(TIMSK0, OCIE0B); ENABLE_STEPPER_DRIVER_INTERRUPT(); } while(0)
    396          #define _ENABLE_ISRs() do { sei(); if (thermalManager.in_temp_isr) HAL_TIM_Base_Stop_IT(&htim4); else HAL_TIM_Base_Start_IT(&htim4); ENABLE_STEPPER_DRIVER_INTERRUPT(); } while(0)
    397          

   \                                 In section .text, align 4, keep-with-next
    398          void IsrStepperHandler() { 
   \                     IsrStepperHandler: (+1)
   \   00000000   0xBF00             Nop      
   \   00000002   0xBF00             Nop      
    399          #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
    400          		Stepper::advance_isr_scheduler();
    401          #else
    402          		Stepper::StepperHandler(); 
   \   00000004                      REQUIRE _ZN7Stepper14StepperHandlerEv
   \   00000004                      ;; // Fall through to label Stepper::StepperHandler()
    403          #endif
    404            }
    405          

   \                                 In section .text, align 4, keep-with-next
    406          void Stepper::StepperHandler() {
   \                     _ZN7Stepper14StepperHandlerEv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
    407          
    408          
    409            uint16_t ocr_val;
    410          
    411            #define ENDSTOP_NOMINAL_OCR_VAL 3000 // Check endstops every 1.5ms to guarantee two stepper ISRs within 5ms for BLTouch
    412            #define OCR_VAL_TOLERANCE       1000 // First max delay is 2.0ms, last min delay is 0.5ms, all others 1.5ms
    413          
    414            #if DISABLED(LIN_ADVANCE)
    415              // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
    416              //CBI(TIMSK0, OCIE0B); // Temperature ISR
    417              HAL_TIM_Base_Stop_IT(&htim4);		//1?¡À?2a???D???
   \   00000004   0x.... 0x....      LDR.W    R10,??DataTable20_1
   \   00000008   0x4650             MOV      R0,R10
   \   0000000A   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable20_2
    418              DISABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000012   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
    419              sei();
    420            #endif
    421          
    422            #define _SPLIT(L) (ocr_val = (uint16_t)L)
    423            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    424          
    425              #define SPLIT(L) _SPLIT(L)
    426          
    427            #else // !ENDSTOP_INTERRUPTS_FEATURE : Sample endstops between stepping ISRs
    428          
    429              static uint32_t step_remaining = 0;
    430          
    431              #define SPLIT(L) do { \
    432                _SPLIT(L); \
    433                if (ENDSTOPS_ENABLED && L > ENDSTOP_NOMINAL_OCR_VAL) { \
    434                  const uint16_t remainder = (uint16_t)L % (ENDSTOP_NOMINAL_OCR_VAL); \
    435                  ocr_val = (remainder < OCR_VAL_TOLERANCE) ? ENDSTOP_NOMINAL_OCR_VAL + remainder : ENDSTOP_NOMINAL_OCR_VAL; \
    436                  step_remaining = (uint16_t)L - ocr_val; \
    437                } \
    438              }while(0)
    439          
    440              if (step_remaining && ENDSTOPS_ENABLED) {   // Just check endstops - not yet time for a step
   \   00000016   0x.... 0x....      LDR.W    R5,??DataTable19
   \   0000001A   0xB662             cpsie i
   \   0000001C   0x6CE8             LDR      R0,[R5, #+76]
   \   0000001E   0xB358             CBZ.N    R0,??StepperHandler_0
   \   00000020   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   00000024   0x7800             LDRB     R0,[R0, #+0]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xBF02             ITTT     EQ 
   \   0000002A   0x.... 0x....      LDREQ.W  R0,??DataTable20_4
   \   0000002E   0x7800             LDRBEQ   R0,[R0, #+0]
   \   00000030   0x2800             CMPEQ    R0,#+0
   \   00000032   0xD021             BEQ.N    ??StepperHandler_0
    441                endstops.update();
   \   00000034   0x.... 0x....      BL       _ZN8Endstops6updateEv
    442          
    443                // Next ISR either for endstops or stepping
    444                ocr_val = step_remaining <= ENDSTOP_NOMINAL_OCR_VAL ? step_remaining : ENDSTOP_NOMINAL_OCR_VAL;
   \   00000038   0x6CE8             LDR      R0,[R5, #+76]
   \   0000003A   0xF640 0x31B9      MOVW     R1,#+3001
   \   0000003E   0x4288             CMP      R0,R1
   \   00000040   0xBF34             ITE      CC 
   \   00000042   0x4601             MOVCC    R1,R0
   \   00000044   0xF640 0x31B8      MOVWCS   R1,#+3000
    445                step_remaining -= ocr_val;
   \   00000048   0xB289             UXTH     R1,R1
   \   0000004A   0x1A40             SUBS     R0,R0,R1
   \   0000004C   0x64E8             STR      R0,[R5, #+76]
    446                _NEXT_ISR(ocr_val);
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000052   0x6800             LDR      R0,[R0, #+0]
   \   00000054   0x62C1             STR      R1,[R0, #+44]
   \   00000056   0x6AC1             LDR      R1,[R0, #+44]
   \   00000058   0x6A42             LDR      R2,[R0, #+36]
   \   0000005A   0x4291             CMP      R1,R2
   \   0000005C   0xD202             BCS.N    ??StepperHandler_1
   \   0000005E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000060   0x1E49             SUBS     R1,R1,#+1
   \   00000062   0x6241             STR      R1,[R0, #+36]
    447                NOLESS(OCR1A, TCNT1 + 16);
   \                     ??StepperHandler_1: (+1)
   \   00000064   0x6AC1             LDR      R1,[R0, #+44]
   \   00000066   0x6A42             LDR      R2,[R0, #+36]
   \   00000068   0x3210             ADDS     R2,R2,#+16
   \   0000006A   0x4291             CMP      R1,R2
   \   0000006C   0xD202             BCS.N    ??StepperHandler_2
   \   0000006E   0x6A41             LDR      R1,[R0, #+36]
   \   00000070   0x3110             ADDS     R1,R1,#+16
   \   00000072   0x62C1             STR      R1,[R0, #+44]
    448                _ENABLE_ISRs(); // re-enable ISRs
   \                     ??StepperHandler_2: (+1)
   \   00000074   0xB662             cpsie i
   \   00000076   0xE315             B.N      ??StepperHandler_3
    449                return;
    450              }
    451          
    452            #endif // !ENDSTOP_INTERRUPTS_FEATURE
    453          
    454            //
    455            // When cleaning, discard the current block and run fast
    456            //
    457            if (cleaning_buffer_counter) {
   \                     ??StepperHandler_0: (+1)
   \   00000078   0xF9B5 0x200A      LDRSH    R2,[R5, #+10]
   \   0000007C   0x2A00             CMP      R2,#+0
   \   0000007E   0xD04B             BEQ.N    ??StepperHandler_4
    458              if (cleaning_buffer_counter < 0) {          // Count up for endstop hit
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable20_6
   \   00000088   0xD525             BPL.N    ??StepperHandler_5
    459                if (current_block) planner.discard_current_block(); // Discard the active block that led to the trigger
   \   0000008A   0x6A2A             LDR      R2,[R5, #+32]
   \   0000008C   0x2A00             CMP      R2,#+0
   \   0000008E   0xBF1E             ITTT     NE 
   \   00000090   0x780A             LDRBNE   R2,[R1, #+0]
   \   00000092   0x7803             LDRBNE   R3,[R0, #+0]
   \   00000094   0x429A             CMPNE    R2,R3
   \   00000096   0xD004             BEQ.N    ??StepperHandler_6
   \   00000098   0x7802             LDRB     R2,[R0, #+0]
   \   0000009A   0x1C52             ADDS     R2,R2,#+1
   \   0000009C   0xF002 0x020F      AND      R2,R2,#0xF
   \   000000A0   0x7002             STRB     R2,[R0, #+0]
    460                if (!planner.discard_continued_block())   // Discard next CONTINUED block
   \                     ??StepperHandler_6: (+1)
   \   000000A2   0x780A             LDRB     R2,[R1, #+0]
   \   000000A4   0x7803             LDRB     R3,[R0, #+0]
   \   000000A6   0x429A             CMP      R2,R3
   \   000000A8   0xD012             BEQ.N    ??StepperHandler_7
   \   000000AA   0x7802             LDRB     R2,[R0, #+0]
   \   000000AC   0x.... 0x....      LDR.W    R6,??DataTable20_7
   \   000000B0   0x2354             MOVS     R3,#+84
   \   000000B2   0xFB03 0x6202      MLA      R2,R3,R2,R6
   \   000000B6   0x7812             LDRB     R2,[R2, #+0]
   \   000000B8   0x06D2             LSLS     R2,R2,#+27
   \   000000BA   0xD509             BPL.N    ??StepperHandler_7
   \   000000BC   0x7809             LDRB     R1,[R1, #+0]
   \   000000BE   0x7802             LDRB     R2,[R0, #+0]
   \   000000C0   0x4291             CMP      R1,R2
   \   000000C2   0xD019             BEQ.N    ??StepperHandler_8
   \   000000C4   0x7801             LDRB     R1,[R0, #+0]
   \   000000C6   0x1C49             ADDS     R1,R1,#+1
   \   000000C8   0xF001 0x010F      AND      R1,R1,#0xF
   \   000000CC   0x7001             STRB     R1,[R0, #+0]
   \   000000CE   0xE013             B.N      ??StepperHandler_8
    461                  cleaning_buffer_counter = 0;            // Keep discarding until non-CONTINUED
   \                     ??StepperHandler_7: (+1)
   \   000000D0   0x2000             MOVS     R0,#+0
   \   000000D2   0x8168             STRH     R0,[R5, #+10]
   \   000000D4   0xE010             B.N      ??StepperHandler_8
    462              }
    463              else {
    464                planner.discard_current_block();
   \                     ??StepperHandler_5: (+1)
   \   000000D6   0x7809             LDRB     R1,[R1, #+0]
   \   000000D8   0x7803             LDRB     R3,[R0, #+0]
   \   000000DA   0x4299             CMP      R1,R3
   \   000000DC   0xD004             BEQ.N    ??StepperHandler_9
   \   000000DE   0x7801             LDRB     R1,[R0, #+0]
   \   000000E0   0x1C49             ADDS     R1,R1,#+1
   \   000000E2   0xF001 0x010F      AND      R1,R1,#0xF
   \   000000E6   0x7001             STRB     R1,[R0, #+0]
    465                --cleaning_buffer_counter;                // Count down for abort print
   \                     ??StepperHandler_9: (+1)
   \   000000E8   0x1E50             SUBS     R0,R2,#+1
   \   000000EA   0x8168             STRH     R0,[R5, #+10]
    466                #if ENABLED(SD_FINISHED_STEPPERRELEASE) && defined(SD_FINISHED_RELEASECOMMAND)
    467                  if (!cleaning_buffer_counter) enqueue_and_echo_commands_P(PSTR(SD_FINISHED_RELEASECOMMAND));
   \   000000EC   0xB200             SXTH     R0,R0
   \   000000EE   0xB918             CBNZ.N   R0,??StepperHandler_8
   \   000000F0   0x.... 0x....      ADR.W    R0,`?<Constant "M84 X Y Z E">`
   \   000000F4   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
    468                #endif
    469              }
    470              current_block = NULL;                       // Prep to get a new block after cleaning
   \                     ??StepperHandler_8: (+1)
   \   000000F8   0x2000             MOVS     R0,#+0
   \   000000FA   0x6228             STR      R0,[R5, #+32]
    471              _NEXT_ISR(200);                             // Run at max speed - 10 KHz
   \   000000FC   0x21C8             MOVS     R1,#+200
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000102   0x6800             LDR      R0,[R0, #+0]
   \   00000104   0x62C1             STR      R1,[R0, #+44]
   \   00000106   0x6AC1             LDR      R1,[R0, #+44]
   \   00000108   0x6A42             LDR      R2,[R0, #+36]
   \   0000010A   0x4291             CMP      R1,R2
   \   0000010C   0xD202             BCS.N    ??StepperHandler_10
   \   0000010E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000110   0x1E49             SUBS     R1,R1,#+1
   \   00000112   0x6241             STR      R1,[R0, #+36]
    472              _ENABLE_ISRs();
   \                     ??StepperHandler_10: (+1)
   \   00000114   0xB662             cpsie i
   \   00000116   0xE2C5             B.N      ??StepperHandler_3
    473              return;
    474            }
    475          
    476            // If there is no current block, attempt to pop one from the buffer
    477            if (!current_block) {
   \                     ??StepperHandler_4: (+1)
   \   00000118   0x6A28             LDR      R0,[R5, #+32]
   \   0000011A   0x2800             CMP      R0,#+0
   \   0000011C   0xD14D             BNE.N    ??StepperHandler_11
    478              // Anything in the buffer?
    479              if ((current_block = planner.get_current_block())) {
   \   0000011E   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   00000122   0x7801             LDRB     R1,[R0, #+0]
   \   00000124   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000128   0x7802             LDRB     R2,[R0, #+0]
   \   0000012A   0x4291             CMP      R1,R2
   \   0000012C   0xBF08             IT       EQ 
   \   0000012E   0x2000             MOVEQ    R0,#+0
   \   00000130   0xD009             BEQ.N    ??StepperHandler_12
   \   00000132   0x7800             LDRB     R0,[R0, #+0]
   \   00000134   0x.... 0x....      LDR.W    R2,??DataTable20_7
   \   00000138   0x2154             MOVS     R1,#+84
   \   0000013A   0xFB01 0x2000      MLA      R0,R1,R0,R2
   \   0000013E   0x7801             LDRB     R1,[R0, #+0]
   \   00000140   0xF041 0x0108      ORR      R1,R1,#0x8
   \   00000144   0x7001             STRB     R1,[R0, #+0]
   \                     ??StepperHandler_12: (+1)
   \   00000146   0x6228             STR      R0,[R5, #+32]
   \   00000148   0x2800             CMP      R0,#+0
   \   0000014A   0xD061             BEQ.N    ??StepperHandler_13
    480                trapezoid_generator_reset();
   \   0000014C   0xF890 0x1024      LDRB     R1,[R0, #+36]
   \   00000150   0x796B             LDRB     R3,[R5, #+5]
   \   00000152   0x.... 0x....      LDR.W    R2,??DataTable20_12
   \   00000156   0x4299             CMP      R1,R3
   \   00000158   0xBF02             ITTT     EQ 
   \   0000015A   0x7843             LDRBEQ   R3,[R0, #+1]
   \   0000015C   0xF992 0x6000      LDRSBEQ  R6,[R2, #+0]
   \   00000160   0x42B3             CMPEQ    R3,R6
   \   00000162   0xD005             BEQ.N    ??StepperHandler_14
   \   00000164   0x7169             STRB     R1,[R5, #+5]
   \   00000166   0xF990 0x0001      LDRSB    R0,[R0, #+1]
   \   0000016A   0x7010             STRB     R0,[R2, #+0]
   \   0000016C   0x.... 0x....      BL       _ZN7Stepper14set_directionsEv
   \                     ??StepperHandler_14: (+1)
   \   00000170   0x2000             MOVS     R0,#+0
   \   00000172   0x6A2E             LDR      R6,[R5, #+32]
   \   00000174   0x63E8             STR      R0,[R5, #+60]
   \   00000176   0x6BF0             LDR      R0,[R6, #+60]
   \   00000178   0xB280             UXTH     R0,R0
   \   0000017A   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
   \   0000017E   0x81A8             STRH     R0,[R5, #+12]
   \   00000180   0x7A28             LDRB     R0,[R5, #+8]
   \   00000182   0x7268             STRB     R0,[R5, #+9]
   \   00000184   0x6C30             LDR      R0,[R6, #+64]
   \   00000186   0x81E8             STRH     R0,[R5, #+14]
   \   00000188   0x89E8             LDRH     R0,[R5, #+14]
   \   0000018A   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
   \   0000018E   0x63A8             STR      R0,[R5, #+56]
   \   00000190   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000194   0x6800             LDR      R0,[R0, #+0]
   \   00000196   0x6BA9             LDR      R1,[R5, #+56]
   \   00000198   0x62C1             STR      R1,[R0, #+44]
   \   0000019A   0x6AC1             LDR      R1,[R0, #+44]
   \   0000019C   0x6A42             LDR      R2,[R0, #+36]
   \   0000019E   0x4291             CMP      R1,R2
   \   000001A0   0xD202             BCS.N    ??StepperHandler_15
   \   000001A2   0x6AC1             LDR      R1,[R0, #+44]
   \   000001A4   0x1E49             SUBS     R1,R1,#+1
   \   000001A6   0x6241             STR      R1,[R0, #+36]
    481          
    482                // Initialize Bresenham counters to 1/2 the ceiling
    483                counter_X = counter_Y = counter_Z = counter_E = -(current_block->step_event_count >> 1);
   \                     ??StepperHandler_15: (+1)
   \   000001A8   0x6970             LDR      R0,[R6, #+20]
   \   000001AA   0x0840             LSRS     R0,R0,#+1
   \   000001AC   0x4240             RSBS     R0,R0,#+0
   \   000001AE   0x6328             STR      R0,[R5, #+48]
   \   000001B0   0x62E8             STR      R0,[R5, #+44]
   \   000001B2   0x62A8             STR      R0,[R5, #+40]
   \   000001B4   0x6268             STR      R0,[R5, #+36]
    484          
    485                #if ENABLED(MIXING_EXTRUDER)
    486                  MIXING_STEPPERS_LOOP(i)
    487                    counter_m[i] = -(current_block->mix_event_count[i] >> 1);
    488                #endif
    489          
    490                step_events_completed = 0;
   \   000001B6   0x2000             MOVS     R0,#+0
   \   000001B8   0x6368             STR      R0,[R5, #+52]
   \                     ??StepperHandler_11: (+1)
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable20_3
   \   000001BE   0x7800             LDRB     R0,[R0, #+0]
   \   000001C0   0x2800             CMP      R0,#+0
   \   000001C2   0xBF03             ITTTE    EQ 
   \   000001C4   0x.... 0x....      LDREQ.W  R0,??DataTable20_4
   \   000001C8   0x7800             LDRBEQ   R0,[R0, #+0]
   \   000001CA   0x2800             CMPEQ    R0,#+0
    491          
    492                #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    493                  e_hit = 2; // Needed for the case an endstop is already triggered before the new move begins.
    494                             // No 'change' can be detected.
    495                #endif
    496          
    497                #if ENABLED(Z_LATE_ENABLE)
    498                  if (current_block->steps[Z_AXIS] > 0) {
    499                    enable_Z();
    500                    _NEXT_ISR(2000); // Run at slow speed - 1 KHz
    501                    _ENABLE_ISRs(); // re-enable ISRs
    502                    return;
    503                  }
    504                #endif
    505              }
    506              else {
    507                _NEXT_ISR(2000); // Run at slow speed - 1 KHz
    508                _ENABLE_ISRs(); // re-enable ISRs
    509                return;
    510              }
    511            }
    512          
    513            // Update endstops state, if enabled
    514            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    515              if (e_hit && ENDSTOPS_ENABLED) {
    516                endstops.update();
    517                e_hit--;
    518              }
    519            #else
    520              if (ENDSTOPS_ENABLED) endstops.update();
   \   000001CC   0x.... 0x....      BLNE     _ZN8Endstops6updateEv
    521            #endif
    522          
    523            // Take multiple steps per interrupt (For high speed moves)
    524            bool all_steps_done = false;
    525            for (uint8_t i = step_loops; i--;) {
   \   000001D0   0xF895 0xB008      LDRB     R11,[R5, #+8]
   \   000001D4   0x.... 0x....      LDR.W    R8,??DataTable20_13
   \   000001D8   0x.... 0x....      LDR.W    R9,??DataTable20_14
   \   000001DC   0x.... 0x....      LDR.W    R4,??DataTable19_1
   \   000001E0   0x.... 0x....      LDR.W    R7,??DataTable19_2
   \   000001E4   0x2600             MOVS     R6,#+0
   \                     ??StepperHandler_16: (+1)
   \   000001E6   0xFA5F 0xF08B      UXTB     R0,R11
   \   000001EA   0x2800             CMP      R0,#+0
   \   000001EC   0xF000 0x8184      BEQ.W    ??StepperHandler_17
    526              #if ENABLED(LIN_ADVANCE)
    527          
    528                counter_E += current_block->steps[E_AXIS];
    529                if (counter_E > 0) {
    530                  counter_E -= current_block->step_event_count;
    531                  #if DISABLED(MIXING_EXTRUDER)
    532                    // Don't step E here for mixing extruder
    533                    count_position[E_AXIS] += count_direction[E_AXIS];
    534                    motor_direction(E_AXIS) ? --e_steps[TOOL_E_INDEX] : ++e_steps[TOOL_E_INDEX];
    535                  #endif
    536                }
    537          
    538                #if ENABLED(MIXING_EXTRUDER)
    539                  // Step mixing steppers proportionally
    540                  const bool dir = motor_direction(E_AXIS);
    541                  MIXING_STEPPERS_LOOP(j) {
    542                    counter_m[j] += current_block->steps[E_AXIS];
    543                    if (counter_m[j] > 0) {
    544                      counter_m[j] -= current_block->mix_event_count[j];
    545                      dir ? --e_steps[j] : ++e_steps[j];
    546                    }
    547                  }
    548                #endif
    549          
    550              #endif // LIN_ADVANCE
    551          
    552              #define _COUNTER(AXIS) counter_## AXIS          
    553              #define _APPLY_STEP(AXIS) AXIS ##_APPLY_STEP    
    554              #define _INVERT_STEP_PIN(AXIS) INVERT_## AXIS ##_STEP_PIN 
    555          
    556              // Advance the Bresenham counter; start a pulse if the axis needs a step
    557              #define PULSE_START(AXIS) \
    558                _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
    559                if (_COUNTER(AXIS) > 0) { _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS),0); for(volatile int i_axis=0;i_axis<gCfgItems.pulseDelay;i_axis++);}
    560          
    561              // Stop an active pulse, reset the Bresenham counter, update the position
    562              #define PULSE_STOP(AXIS) \
    563                if (_COUNTER(AXIS) > 0) { \
    564                  _COUNTER(AXIS) -= current_block->step_event_count; \
    565                  count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
    566                  _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS),0); for(volatile int i_axis=0;i_axis<gCfgItems.pulseDelay;i_axis++);\
    567                }
    568          
    569              // Advance the Bresenham counter; start a pulse if the axis needs a step
    570              #define Z_PULSE_START(AXIS) \
    571                _COUNTER(AXIS) += current_block->steps[_AXIS(AXIS)]; \
    572                if (_COUNTER(AXIS) > 0) { Z_APPLY_STEP(!_INVERT_STEP_PIN(AXIS),0);for(volatile int iz_axis=0;iz_axis<gCfgItems.pulseDelay;iz_axis++);}
    573          
    574              // Stop an active pulse, reset the Bresenham counter, update the position
    575              #define Z_PULSE_STOP(AXIS) \
    576                if (_COUNTER(AXIS) > 0) { \
    577                  _COUNTER(AXIS) -= current_block->step_event_count; \
    578                  count_position[_AXIS(AXIS)] += count_direction[_AXIS(AXIS)]; \
    579                  Z_APPLY_STEP(_INVERT_STEP_PIN(AXIS),0); for(volatile int i_axis=0;i_axis<gCfgItems.pulseDelay;i_axis++);\
    580                }
    581          
    582              /**
    583               * Estimate the number of cycles that the stepper logic already takes
    584               * up between the start and stop of the X stepper pulse.
    585               *
    586               * Currently this uses very modest estimates of around 5 cycles.
    587               * True values may be derived by careful testing.
    588               *
    589               * Once any delay is added, the cost of the delay code itself
    590               * may be subtracted from this value to get a more accurate delay.
    591               * Delays under 20 cycles (1.25Âµs) will be very accurate, using NOPs.
    592               * Longer delays use a loop. The resolution is 8 cycles.
    593               */
    594          #if 0     
    595              #if HAS_X_STEP
    596                #define _CYCLE_APPROX_1 5
    597              #else
    598                #define _CYCLE_APPROX_1 0
    599              #endif
    600              #if ENABLED(X_DUAL_STEPPER_DRIVERS)
    601                #define _CYCLE_APPROX_2 _CYCLE_APPROX_1 + 4
    602              #else
    603                #define _CYCLE_APPROX_2 _CYCLE_APPROX_1
    604              #endif
    605              #if HAS_Y_STEP
    606                #define _CYCLE_APPROX_3 _CYCLE_APPROX_2 + 5
    607              #else
    608                #define _CYCLE_APPROX_3 _CYCLE_APPROX_2
    609              #endif
    610              #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
    611                #define _CYCLE_APPROX_4 _CYCLE_APPROX_3 + 4
    612              #else
    613                #define _CYCLE_APPROX_4 _CYCLE_APPROX_3
    614              #endif
    615              #if HAS_Z_STEP
    616                #define _CYCLE_APPROX_5 _CYCLE_APPROX_4 + 5
    617              #else
    618                #define _CYCLE_APPROX_5 _CYCLE_APPROX_4
    619              #endif
    620              #if ENABLED(Z_DUAL_STEPPER_DRIVERS)
    621                #define _CYCLE_APPROX_6 _CYCLE_APPROX_5 + 4
    622              #else
    623                #define _CYCLE_APPROX_6 _CYCLE_APPROX_5
    624              #endif
    625              #if DISABLED(LIN_ADVANCE)
    626                #if ENABLED(MIXING_EXTRUDER)
    627                  #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + (MIXING_STEPPERS) * 6
    628                #else
    629                  #define _CYCLE_APPROX_7 _CYCLE_APPROX_6 + 5
    630                #endif
    631              #else
    632                #define _CYCLE_APPROX_7 _CYCLE_APPROX_6
    633              #endif
    634          
    635              #define CYCLES_EATEN_XYZE _CYCLE_APPROX_7
    636              #define EXTRA_CYCLES_XYZE (STEP_PULSE_CYCLES - (CYCLES_EATEN_XYZE))
    637          #endif
    638          
    639              #define EXTRA_CYCLES_XYZE (0)
    640          
    641              /**
    642               * If a minimum pulse time was specified get the timer 0 value.
    643               *
    644               * TCNT0 has an 8x prescaler, so it increments every 8 cycles.
    645               * That's every 0.5Âµs on 16MHz and every 0.4Âµs on 20MHz.
    646               * 20 counts of TCNT0 -by itself- is a good pulse delay.
    647               * 10Âµs = 160 or 200 cycles.
    648               */
    649              #if EXTRA_CYCLES_XYZE > 20
    650                uint32_t pulse_start = TCNT0;
    651              #endif
    652          
    653              #if HAS_X_STEP
    654                PULSE_START(X);
   \   000001F0   0x6A29             LDR      R1,[R5, #+32]
   \   000001F2   0x6849             LDR      R1,[R1, #+4]
   \   000001F4   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \   000001F8   0x6A68             LDR      R0,[R5, #+36]
   \   000001FA   0x1808             ADDS     R0,R1,R0
   \   000001FC   0x6268             STR      R0,[R5, #+36]
   \   000001FE   0x2801             CMP      R0,#+1
   \   00000200   0xDB1D             BLT.N    ??StepperHandler_18
   \   00000202   0x8879             LDRH     R1,[R7, #+2]
   \   00000204   0x6860             LDR      R0,[R4, #+4]
   \   00000206   0x2201             MOVS     R2,#+1
   \   00000208   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000020C   0x9600             STR      R6,[SP, #+0]
   \   0000020E   0xE011             B.N      ??StepperHandler_19
   \                     ??StepperHandler_13: (+1)
   \   00000210   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000214   0x6800             LDR      R0,[R0, #+0]
   \   00000216   0xF44F 0x61FA      MOV      R1,#+2000
   \   0000021A   0x62C1             STR      R1,[R0, #+44]
   \   0000021C   0x6AC1             LDR      R1,[R0, #+44]
   \   0000021E   0x6A42             LDR      R2,[R0, #+36]
   \   00000220   0x4291             CMP      R1,R2
   \   00000222   0xD202             BCS.N    ??StepperHandler_20
   \   00000224   0x6AC1             LDR      R1,[R0, #+44]
   \   00000226   0x1E49             SUBS     R1,R1,#+1
   \   00000228   0x6241             STR      R1,[R0, #+36]
   \                     ??StepperHandler_20: (+1)
   \   0000022A   0xB662             cpsie i
   \   0000022C   0xE23A             B.N      ??StepperHandler_3
   \                     ??StepperHandler_21: (+1)
   \   0000022E   0x9800             LDR      R0,[SP, #+0]
   \   00000230   0x1C40             ADDS     R0,R0,#+1
   \   00000232   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_19: (+1)
   \   00000234   0x9800             LDR      R0,[SP, #+0]
   \   00000236   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   0000023A   0x4288             CMP      R0,R1
   \   0000023C   0xDBF7             BLT.N    ??StepperHandler_21
    655              #endif
    656              #if HAS_Y_STEP
    657                PULSE_START(Y);
   \                     ??StepperHandler_18: (+1)
   \   0000023E   0x6A29             LDR      R1,[R5, #+32]
   \   00000240   0x6AA8             LDR      R0,[R5, #+40]
   \   00000242   0x6889             LDR      R1,[R1, #+8]
   \   00000244   0x1808             ADDS     R0,R1,R0
   \   00000246   0x62A8             STR      R0,[R5, #+40]
   \   00000248   0x2801             CMP      R0,#+1
   \   0000024A   0xDB0E             BLT.N    ??StepperHandler_22
   \   0000024C   0x89B9             LDRH     R1,[R7, #+12]
   \   0000024E   0x69A0             LDR      R0,[R4, #+24]
   \   00000250   0x2201             MOVS     R2,#+1
   \   00000252   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000256   0x9600             STR      R6,[SP, #+0]
   \   00000258   0xE002             B.N      ??StepperHandler_23
   \                     ??StepperHandler_24: (+1)
   \   0000025A   0x9800             LDR      R0,[SP, #+0]
   \   0000025C   0x1C40             ADDS     R0,R0,#+1
   \   0000025E   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_23: (+1)
   \   00000260   0x9800             LDR      R0,[SP, #+0]
   \   00000262   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   00000266   0x4288             CMP      R0,R1
   \   00000268   0xDBF7             BLT.N    ??StepperHandler_24
    658              #endif
    659              #if HAS_Z_STEP
    660                Z_PULSE_START(Z);
   \                     ??StepperHandler_22: (+1)
   \   0000026A   0x6A29             LDR      R1,[R5, #+32]
   \   0000026C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000026E   0x68C9             LDR      R1,[R1, #+12]
   \   00000270   0x1808             ADDS     R0,R1,R0
   \   00000272   0x62E8             STR      R0,[R5, #+44]
   \   00000274   0x2801             CMP      R0,#+1
   \   00000276   0xDB5C             BLT.N    ??StepperHandler_25
   \   00000278   0x.... 0x....      LDR.W    R0,??DataTable20_15
   \   0000027C   0x7840             LDRB     R0,[R0, #+1]
   \   0000027E   0x2801             CMP      R0,#+1
   \   00000280   0xD13D             BNE.N    ??StepperHandler_26
   \   00000282   0x7928             LDRB     R0,[R5, #+4]
   \   00000284   0xB3A8             CBZ.N    R0,??StepperHandler_27
   \   00000286   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000028A   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   0000028E   0x2800             CMP      R0,#+0
   \   00000290   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000294   0xD515             BPL.N    ??StepperHandler_28
   \   00000296   0x0740             LSLS     R0,R0,#+29
   \   00000298   0xBF44             ITT      MI 
   \   0000029A   0xF995 0x0002      LDRSBMI  R0,[R5, #+2]
   \   0000029E   0x2800             CMPMI    R0,#+0
   \   000002A0   0xD406             BMI.N    ??StepperHandler_29
   \   000002A2   0x79A8             LDRB     R0,[R5, #+6]
   \   000002A4   0xB920             CBNZ.N   R0,??StepperHandler_29
   \   000002A6   0x8AF9             LDRH     R1,[R7, #+22]
   \   000002A8   0x6AE0             LDR      R0,[R4, #+44]
   \   000002AA   0x2201             MOVS     R2,#+1
   \   000002AC   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??StepperHandler_29: (+1)
   \   000002B0   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000002B4   0x0500             LSLS     R0,R0,#+20
   \   000002B6   0xD519             BPL.N    ??StepperHandler_30
   \   000002B8   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   000002BC   0x2800             CMP      R0,#+0
   \   000002BE   0xD42E             BMI.N    ??StepperHandler_31
   \   000002C0   0xE014             B.N      ??StepperHandler_30
   \                     ??StepperHandler_28: (+1)
   \   000002C2   0x0640             LSLS     R0,R0,#+25
   \   000002C4   0xD503             BPL.N    ??StepperHandler_32
   \   000002C6   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   000002CA   0x2801             CMP      R0,#+1
   \   000002CC   0xDA06             BGE.N    ??StepperHandler_33
   \                     ??StepperHandler_32: (+1)
   \   000002CE   0x79A8             LDRB     R0,[R5, #+6]
   \   000002D0   0xB920             CBNZ.N   R0,??StepperHandler_33
   \   000002D2   0x8AF9             LDRH     R1,[R7, #+22]
   \   000002D4   0x6AE0             LDR      R0,[R4, #+44]
   \   000002D6   0x2201             MOVS     R2,#+1
   \   000002D8   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??StepperHandler_33: (+1)
   \   000002DC   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   000002E0   0x04C0             LSLS     R0,R0,#+19
   \   000002E2   0xD503             BPL.N    ??StepperHandler_30
   \   000002E4   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   000002E8   0x2801             CMP      R0,#+1
   \   000002EA   0xDA18             BGE.N    ??StepperHandler_31
   \                     ??StepperHandler_30: (+1)
   \   000002EC   0x79E8             LDRB     R0,[R5, #+7]
   \   000002EE   0xB9B0             CBNZ.N   R0,??StepperHandler_31
   \   000002F0   0xE010             B.N      ??StepperHandler_34
   \                     ??StepperHandler_27: (+1)
   \   000002F2   0x8AF9             LDRH     R1,[R7, #+22]
   \   000002F4   0x6AE0             LDR      R0,[R4, #+44]
   \   000002F6   0x2201             MOVS     R2,#+1
   \   000002F8   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000002FC   0xE00A             B.N      ??StepperHandler_34
   \                     ??StepperHandler_26: (+1)
   \   000002FE   0x8AF9             LDRH     R1,[R7, #+22]
   \   00000300   0x6AE0             LDR      R0,[R4, #+44]
   \   00000302   0x2201             MOVS     R2,#+1
   \   00000304   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000308   0x.... 0x....      LDR.W    R0,??DataTable20
   \   0000030C   0xF890 0x0101      LDRB     R0,[R0, #+257]
   \   00000310   0x2801             CMP      R0,#+1
   \   00000312   0xD104             BNE.N    ??StepperHandler_31
   \                     ??StepperHandler_34: (+1)
   \   00000314   0x8CF9             LDRH     R1,[R7, #+38]
   \   00000316   0x6CE0             LDR      R0,[R4, #+76]
   \   00000318   0x2201             MOVS     R2,#+1
   \   0000031A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??StepperHandler_31: (+1)
   \   0000031E   0x9600             STR      R6,[SP, #+0]
   \   00000320   0xE002             B.N      ??StepperHandler_35
   \                     ??StepperHandler_36: (+1)
   \   00000322   0x9800             LDR      R0,[SP, #+0]
   \   00000324   0x1C40             ADDS     R0,R0,#+1
   \   00000326   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_35: (+1)
   \   00000328   0x9800             LDR      R0,[SP, #+0]
   \   0000032A   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   0000032E   0x4288             CMP      R0,R1
   \   00000330   0xDBF7             BLT.N    ??StepperHandler_36
    661              #endif
    662          
    663              // For non-advance use linear interpolation for E also
    664              #if DISABLED(LIN_ADVANCE)
    665                #if ENABLED(MIXING_EXTRUDER)
    666                  // Keep updating the single E axis
    667                  counter_E += current_block->steps[E_AXIS];
    668                  // Tick the counters used for this mix
    669                  MIXING_STEPPERS_LOOP(j) {
    670                    // Step mixing steppers (proportionally)
    671                    counter_m[j] += current_block->steps[E_AXIS];
    672                    // Step when the counter goes over zero
    673                    if (counter_m[j] > 0) En_STEP_WRITE(j, !INVERT_E_STEP_PIN);
    674                  }
    675                #else // !MIXING_EXTRUDER
    676                  PULSE_START(E);
   \                     ??StepperHandler_25: (+1)
   \   00000332   0x6A28             LDR      R0,[R5, #+32]
   \   00000334   0x6B29             LDR      R1,[R5, #+48]
   \   00000336   0x6902             LDR      R2,[R0, #+16]
   \   00000338   0x1851             ADDS     R1,R2,R1
   \   0000033A   0x6329             STR      R1,[R5, #+48]
   \   0000033C   0x2901             CMP      R1,#+1
   \   0000033E   0xDB14             BLT.N    ??StepperHandler_37
   \   00000340   0x7840             LDRB     R0,[R0, #+1]
   \   00000342   0xB918             CBNZ.N   R0,??StepperHandler_38
   \   00000344   0x8C39             LDRH     R1,[R7, #+32]
   \   00000346   0x6C20             LDR      R0,[R4, #+64]
   \   00000348   0x2201             MOVS     R2,#+1
   \   0000034A   0xE002             B.N      ??StepperHandler_39
   \                     ??StepperHandler_38: (+1)
   \   0000034C   0x8CF9             LDRH     R1,[R7, #+38]
   \   0000034E   0x6CE0             LDR      R0,[R4, #+76]
   \   00000350   0x2201             MOVS     R2,#+1
   \                     ??StepperHandler_39: (+1)
   \   00000352   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000356   0x9600             STR      R6,[SP, #+0]
   \   00000358   0xE002             B.N      ??StepperHandler_40
   \                     ??StepperHandler_41: (+1)
   \   0000035A   0x9800             LDR      R0,[SP, #+0]
   \   0000035C   0x1C40             ADDS     R0,R0,#+1
   \   0000035E   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_40: (+1)
   \   00000360   0x9800             LDR      R0,[SP, #+0]
   \   00000362   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   00000366   0x4288             CMP      R0,R1
   \   00000368   0xDBF7             BLT.N    ??StepperHandler_41
    677                #endif
    678              #endif // !LIN_ADVANCE
    679          
    680              // For minimum pulse time wait before stopping pulses
    681              #if EXTRA_CYCLES_XYZE > 20
    682                while (EXTRA_CYCLES_XYZE > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    683                pulse_start = TCNT0;
    684              #elif EXTRA_CYCLES_XYZE > 0
    685                DELAY_NOPS(EXTRA_CYCLES_XYZE);
    686              #endif
    687          
    688              #if HAS_X_STEP
    689                PULSE_STOP(X);
   \                     ??StepperHandler_37: (+1)
   \   0000036A   0x6A68             LDR      R0,[R5, #+36]
   \   0000036C   0x2801             CMP      R0,#+1
   \   0000036E   0xDB16             BLT.N    ??StepperHandler_42
   \   00000370   0x6A29             LDR      R1,[R5, #+32]
   \   00000372   0x6949             LDR      R1,[R1, #+20]
   \   00000374   0x1A40             SUBS     R0,R0,R1
   \   00000376   0x6268             STR      R0,[R5, #+36]
   \   00000378   0x2200             MOVS     R2,#+0
   \   0000037A   0x57A8             LDRSB    R0,[R5, R6]
   \   0000037C   0x6929             LDR      R1,[R5, #+16]
   \   0000037E   0x1840             ADDS     R0,R0,R1
   \   00000380   0x6128             STR      R0,[R5, #+16]
   \   00000382   0x8879             LDRH     R1,[R7, #+2]
   \   00000384   0x6860             LDR      R0,[R4, #+4]
   \   00000386   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000038A   0x9600             STR      R6,[SP, #+0]
   \   0000038C   0xE002             B.N      ??StepperHandler_43
   \                     ??StepperHandler_44: (+1)
   \   0000038E   0x9800             LDR      R0,[SP, #+0]
   \   00000390   0x1C40             ADDS     R0,R0,#+1
   \   00000392   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_43: (+1)
   \   00000394   0x9800             LDR      R0,[SP, #+0]
   \   00000396   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   0000039A   0x4288             CMP      R0,R1
   \   0000039C   0xDBF7             BLT.N    ??StepperHandler_44
    690              #endif
    691              #if HAS_Y_STEP
    692                PULSE_STOP(Y);
   \                     ??StepperHandler_42: (+1)
   \   0000039E   0x6AA8             LDR      R0,[R5, #+40]
   \   000003A0   0x2801             CMP      R0,#+1
   \   000003A2   0xDB17             BLT.N    ??StepperHandler_45
   \   000003A4   0x6A29             LDR      R1,[R5, #+32]
   \   000003A6   0x6949             LDR      R1,[R1, #+20]
   \   000003A8   0x1A40             SUBS     R0,R0,R1
   \   000003AA   0x62A8             STR      R0,[R5, #+40]
   \   000003AC   0x2200             MOVS     R2,#+0
   \   000003AE   0xF995 0x0001      LDRSB    R0,[R5, #+1]
   \   000003B2   0x6969             LDR      R1,[R5, #+20]
   \   000003B4   0x1840             ADDS     R0,R0,R1
   \   000003B6   0x6168             STR      R0,[R5, #+20]
   \   000003B8   0x89B9             LDRH     R1,[R7, #+12]
   \   000003BA   0x69A0             LDR      R0,[R4, #+24]
   \   000003BC   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000003C0   0x9600             STR      R6,[SP, #+0]
   \   000003C2   0xE002             B.N      ??StepperHandler_46
   \                     ??StepperHandler_47: (+1)
   \   000003C4   0x9800             LDR      R0,[SP, #+0]
   \   000003C6   0x1C40             ADDS     R0,R0,#+1
   \   000003C8   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_46: (+1)
   \   000003CA   0x9800             LDR      R0,[SP, #+0]
   \   000003CC   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   000003D0   0x4288             CMP      R0,R1
   \   000003D2   0xDBF7             BLT.N    ??StepperHandler_47
    693              #endif
    694              #if HAS_Z_STEP
    695                Z_PULSE_STOP(Z);
   \                     ??StepperHandler_45: (+1)
   \   000003D4   0x6AE8             LDR      R0,[R5, #+44]
   \   000003D6   0x2801             CMP      R0,#+1
   \   000003D8   0xDB65             BLT.N    ??StepperHandler_48
   \   000003DA   0x6A29             LDR      R1,[R5, #+32]
   \   000003DC   0x6949             LDR      R1,[R1, #+20]
   \   000003DE   0x1A40             SUBS     R0,R0,R1
   \   000003E0   0x62E8             STR      R0,[R5, #+44]
   \   000003E2   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   000003E6   0x69A9             LDR      R1,[R5, #+24]
   \   000003E8   0x1840             ADDS     R0,R0,R1
   \   000003EA   0x61A8             STR      R0,[R5, #+24]
   \   000003EC   0x.... 0x....      LDR.W    R0,??DataTable20_15
   \   000003F0   0x7840             LDRB     R0,[R0, #+1]
   \   000003F2   0x2801             CMP      R0,#+1
   \   000003F4   0xD13D             BNE.N    ??StepperHandler_49
   \   000003F6   0x7928             LDRB     R0,[R5, #+4]
   \   000003F8   0xB3A8             CBZ.N    R0,??StepperHandler_50
   \   000003FA   0x.... 0x....      LDR.W    R0,??DataTable20
   \   000003FE   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   00000402   0x2800             CMP      R0,#+0
   \   00000404   0xF898 0x0000      LDRB     R0,[R8, #+0]
   \   00000408   0xD515             BPL.N    ??StepperHandler_51
   \   0000040A   0x0740             LSLS     R0,R0,#+29
   \   0000040C   0xBF44             ITT      MI 
   \   0000040E   0xF995 0x0002      LDRSBMI  R0,[R5, #+2]
   \   00000412   0x2800             CMPMI    R0,#+0
   \   00000414   0xD406             BMI.N    ??StepperHandler_52
   \   00000416   0x79A8             LDRB     R0,[R5, #+6]
   \   00000418   0xB920             CBNZ.N   R0,??StepperHandler_52
   \   0000041A   0x8AF9             LDRH     R1,[R7, #+22]
   \   0000041C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000041E   0x2200             MOVS     R2,#+0
   \   00000420   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??StepperHandler_52: (+1)
   \   00000424   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000428   0x0500             LSLS     R0,R0,#+20
   \   0000042A   0xD519             BPL.N    ??StepperHandler_53
   \   0000042C   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   00000430   0x2800             CMP      R0,#+0
   \   00000432   0xD42E             BMI.N    ??StepperHandler_54
   \   00000434   0xE014             B.N      ??StepperHandler_53
   \                     ??StepperHandler_51: (+1)
   \   00000436   0x0640             LSLS     R0,R0,#+25
   \   00000438   0xD503             BPL.N    ??StepperHandler_55
   \   0000043A   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000043E   0x2801             CMP      R0,#+1
   \   00000440   0xDA06             BGE.N    ??StepperHandler_56
   \                     ??StepperHandler_55: (+1)
   \   00000442   0x79A8             LDRB     R0,[R5, #+6]
   \   00000444   0xB920             CBNZ.N   R0,??StepperHandler_56
   \   00000446   0x8AF9             LDRH     R1,[R7, #+22]
   \   00000448   0x6AE0             LDR      R0,[R4, #+44]
   \   0000044A   0x2200             MOVS     R2,#+0
   \   0000044C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??StepperHandler_56: (+1)
   \   00000450   0xF8B8 0x0000      LDRH     R0,[R8, #+0]
   \   00000454   0x04C0             LSLS     R0,R0,#+19
   \   00000456   0xD503             BPL.N    ??StepperHandler_53
   \   00000458   0xF995 0x0002      LDRSB    R0,[R5, #+2]
   \   0000045C   0x2801             CMP      R0,#+1
   \   0000045E   0xDA18             BGE.N    ??StepperHandler_54
   \                     ??StepperHandler_53: (+1)
   \   00000460   0x79E8             LDRB     R0,[R5, #+7]
   \   00000462   0xB9B0             CBNZ.N   R0,??StepperHandler_54
   \   00000464   0xE010             B.N      ??StepperHandler_57
   \                     ??StepperHandler_50: (+1)
   \   00000466   0x8AF9             LDRH     R1,[R7, #+22]
   \   00000468   0x6AE0             LDR      R0,[R4, #+44]
   \   0000046A   0x2200             MOVS     R2,#+0
   \   0000046C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000470   0xE00A             B.N      ??StepperHandler_57
   \                     ??StepperHandler_49: (+1)
   \   00000472   0x8AF9             LDRH     R1,[R7, #+22]
   \   00000474   0x6AE0             LDR      R0,[R4, #+44]
   \   00000476   0x2200             MOVS     R2,#+0
   \   00000478   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000047C   0x.... 0x....      LDR.W    R0,??DataTable20
   \   00000480   0xF890 0x0101      LDRB     R0,[R0, #+257]
   \   00000484   0x2801             CMP      R0,#+1
   \   00000486   0xD104             BNE.N    ??StepperHandler_54
   \                     ??StepperHandler_57: (+1)
   \   00000488   0x8CF9             LDRH     R1,[R7, #+38]
   \   0000048A   0x6CE0             LDR      R0,[R4, #+76]
   \   0000048C   0x2200             MOVS     R2,#+0
   \   0000048E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??StepperHandler_54: (+1)
   \   00000492   0x9600             STR      R6,[SP, #+0]
   \   00000494   0xE002             B.N      ??StepperHandler_58
   \                     ??StepperHandler_59: (+1)
   \   00000496   0x9800             LDR      R0,[SP, #+0]
   \   00000498   0x1C40             ADDS     R0,R0,#+1
   \   0000049A   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_58: (+1)
   \   0000049C   0x9800             LDR      R0,[SP, #+0]
   \   0000049E   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   000004A2   0x4288             CMP      R0,R1
   \   000004A4   0xDBF7             BLT.N    ??StepperHandler_59
    696              #endif
    697          
    698              #if DISABLED(LIN_ADVANCE)
    699                #if ENABLED(MIXING_EXTRUDER)
    700                  // Always step the single E axis
    701                  if (counter_E > 0) {
    702                    counter_E -= current_block->step_event_count;
    703                    count_position[E_AXIS] += count_direction[E_AXIS];
    704                  }
    705                  MIXING_STEPPERS_LOOP(j) {
    706                    if (counter_m[j] > 0) {
    707                      counter_m[j] -= current_block->mix_event_count[j];
    708                      En_STEP_WRITE(j, INVERT_E_STEP_PIN);
    709                    }
    710                  }
    711                #else // !MIXING_EXTRUDER
    712                  PULSE_STOP(E);
   \                     ??StepperHandler_48: (+1)
   \   000004A6   0x6B29             LDR      R1,[R5, #+48]
   \   000004A8   0x2901             CMP      R1,#+1
   \   000004AA   0xDB1C             BLT.N    ??StepperHandler_60
   \   000004AC   0x6A28             LDR      R0,[R5, #+32]
   \   000004AE   0x6942             LDR      R2,[R0, #+20]
   \   000004B0   0x1A89             SUBS     R1,R1,R2
   \   000004B2   0x6329             STR      R1,[R5, #+48]
   \   000004B4   0xF995 0x1003      LDRSB    R1,[R5, #+3]
   \   000004B8   0x69EA             LDR      R2,[R5, #+28]
   \   000004BA   0x1889             ADDS     R1,R1,R2
   \   000004BC   0x61E9             STR      R1,[R5, #+28]
   \   000004BE   0x4632             MOV      R2,R6
   \   000004C0   0x7840             LDRB     R0,[R0, #+1]
   \   000004C2   0x2800             CMP      R0,#+0
   \   000004C4   0xBF07             ITTEE    EQ 
   \   000004C6   0x8C39             LDRHEQ   R1,[R7, #+32]
   \   000004C8   0x6C20             LDREQ    R0,[R4, #+64]
   \   000004CA   0x8CF9             LDRHNE   R1,[R7, #+38]
   \   000004CC   0x6CE0             LDRNE    R0,[R4, #+76]
   \   000004CE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000004D2   0x9600             STR      R6,[SP, #+0]
   \   000004D4   0xE002             B.N      ??StepperHandler_61
   \                     ??StepperHandler_62: (+1)
   \   000004D6   0x9800             LDR      R0,[SP, #+0]
   \   000004D8   0x1C40             ADDS     R0,R0,#+1
   \   000004DA   0x9000             STR      R0,[SP, #+0]
   \                     ??StepperHandler_61: (+1)
   \   000004DC   0x9800             LDR      R0,[SP, #+0]
   \   000004DE   0xF8B9 0x12BC      LDRH     R1,[R9, #+700]
   \   000004E2   0x4288             CMP      R0,R1
   \   000004E4   0xDBF7             BLT.N    ??StepperHandler_62
    713                #endif
    714              #endif // !LIN_ADVANCE
    715          
    716              if (++step_events_completed >= current_block->step_event_count) {
   \                     ??StepperHandler_60: (+1)
   \   000004E6   0x6B68             LDR      R0,[R5, #+52]
   \   000004E8   0x1C40             ADDS     R0,R0,#+1
   \   000004EA   0x6368             STR      R0,[R5, #+52]
   \   000004EC   0x6A29             LDR      R1,[R5, #+32]
   \   000004EE   0x6949             LDR      R1,[R1, #+20]
   \   000004F0   0x4288             CMP      R0,R1
   \   000004F2   0xF4FF 0xAE78      BCC.W    ??StepperHandler_16
    717                all_steps_done = true;
   \   000004F6   0x2601             MOVS     R6,#+1
    718                break;
    719              }
    720          
    721              // For minimum pulse time wait after stopping pulses also
    722              #if EXTRA_CYCLES_XYZE > 20
    723                if (i) while (EXTRA_CYCLES_XYZE > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    724              #elif EXTRA_CYCLES_XYZE > 0
    725                if (i) DELAY_NOPS(EXTRA_CYCLES_XYZE);
    726              #endif
    727          
    728            } // steps_loop
    729          
    730            #if ENABLED(LIN_ADVANCE)
    731          
    732              if (current_block->use_advance_lead) {
    733                const int delta_adv_steps = current_estep_rate[TOOL_E_INDEX] - current_adv_steps[TOOL_E_INDEX];
    734                current_adv_steps[TOOL_E_INDEX] += delta_adv_steps;
    735                #if ENABLED(MIXING_EXTRUDER)
    736                  // Mixing extruders apply advance lead proportionally
    737                  MIXING_STEPPERS_LOOP(j)
    738                    e_steps[j] += delta_adv_steps * current_block->step_event_count / current_block->mix_event_count[j];
    739                #else
    740                  // For most extruders, advance the single E stepper
    741                  e_steps[TOOL_E_INDEX] += delta_adv_steps;
    742                #endif
    743              }
    744              // If we have esteps to execute, fire the next advance_isr "now"
    745              if (e_steps[TOOL_E_INDEX]) nextAdvanceISR = 0;
    746          
    747            #endif // LIN_ADVANCE
    748          
    749            // Calculate new timer value
    750            if (step_events_completed <= (uint32_t)current_block->accelerate_until) {
   \                     ??StepperHandler_17: (+1)
   \   000004F8   0x6A2A             LDR      R2,[R5, #+32]
   \   000004FA   0x6990             LDR      R0,[R2, #+24]
   \   000004FC   0x6B69             LDR      R1,[R5, #+52]
   \   000004FE   0x4288             CMP      R0,R1
   \   00000500   0xD33F             BCC.N    ??StepperHandler_63
    751          
    752              MultiU24X32toH16(acc_step_rate, acceleration_time, current_block->acceleration_rate);
    753              acc_step_rate += current_block->initial_rate;
   \   00000502   0xF8D5 0xB038      LDR      R11,[R5, #+56]
   \   00000506   0x6A10             LDR      R0,[R2, #+32]
   \   00000508   0xFB80 0x010B      SMULL    R0,R1,R0,R11
   \   0000050C   0x0E00             LSRS     R0,R0,#+24
   \   0000050E   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
   \   00000512   0x6C11             LDR      R1,[R2, #+64]
   \   00000514   0x1808             ADDS     R0,R1,R0
    754          
    755              // upper limit
    756              NOMORE(acc_step_rate, current_block->nominal_rate);
   \   00000516   0x6BD1             LDR      R1,[R2, #+60]
   \   00000518   0xB280             UXTH     R0,R0
   \   0000051A   0x4281             CMP      R1,R0
   \   0000051C   0xBF38             IT       CC 
   \   0000051E   0x4608             MOVCC    R0,R1
   \   00000520   0x81E8             STRH     R0,[R5, #+14]
    757          
    758              // step_rate to timer interval
    759              const uint16_t interval = calc_timer_interval(acc_step_rate);
   \   00000522   0x89E8             LDRH     R0,[R5, #+14]
   \   00000524   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
    760          
    761              SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
   \   00000528   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   0000052C   0x7812             LDRB     R2,[R2, #+0]
   \   0000052E   0x4601             MOV      R1,R0
   \   00000530   0x2A00             CMP      R2,#+0
   \   00000532   0xBF02             ITTT     EQ 
   \   00000534   0x.... 0x....      LDREQ.W  R2,??DataTable20_4
   \   00000538   0x7812             LDRBEQ   R2,[R2, #+0]
   \   0000053A   0x2A00             CMPEQ    R2,#+0
   \   0000053C   0xD013             BEQ.N    ??StepperHandler_64
   \   0000053E   0xF640 0x32B9      MOVW     R2,#+3001
   \   00000542   0x4290             CMP      R0,R2
   \   00000544   0xDB0F             BLT.N    ??StepperHandler_64
   \   00000546   0xF640 0x31B8      MOVW     R1,#+3000
   \   0000054A   0x460A             MOV      R2,R1
   \   0000054C   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   00000550   0xFB01 0x0212      MLS      R2,R1,R2,R0
   \   00000554   0xB292             UXTH     R2,R2
   \   00000556   0xF5B2 0x7F7A      CMP      R2,#+1000
   \   0000055A   0xBFB8             IT       LT 
   \   0000055C   0xF602 0x31B8      ADDWLT   R1,R2,#+3000
   \   00000560   0xB289             UXTH     R1,R1
   \   00000562   0x1A42             SUBS     R2,R0,R1
   \   00000564   0x64EA             STR      R2,[R5, #+76]
    762              _NEXT_ISR(ocr_val);
   \                     ??StepperHandler_64: (+1)
   \   00000566   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   0000056A   0x6812             LDR      R2,[R2, #+0]
   \   0000056C   0x62D1             STR      R1,[R2, #+44]
   \   0000056E   0x6AD1             LDR      R1,[R2, #+44]
   \   00000570   0x6A53             LDR      R3,[R2, #+36]
   \   00000572   0x4299             CMP      R1,R3
   \   00000574   0xD202             BCS.N    ??StepperHandler_65
   \   00000576   0x6AD1             LDR      R1,[R2, #+44]
   \   00000578   0x1E49             SUBS     R1,R1,#+1
   \   0000057A   0x6251             STR      R1,[R2, #+36]
    763          
    764              acceleration_time += interval;
   \                     ??StepperHandler_65: (+1)
   \   0000057C   0x4458             ADD      R0,R0,R11
   \   0000057E   0x63A8             STR      R0,[R5, #+56]
   \   00000580   0xE074             B.N      ??StepperHandler_66
    765          
    766              #if ENABLED(LIN_ADVANCE)
    767          
    768                if (current_block->use_advance_lead) {
    769                  #if ENABLED(MIXING_EXTRUDER)
    770                    MIXING_STEPPERS_LOOP(j)
    771                      current_estep_rate[j] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
    772                  #else
    773                    current_estep_rate[TOOL_E_INDEX] = ((uint32_t)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
    774                  #endif
    775                }
    776                eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
    777          
    778              #endif // LIN_ADVANCE
    779            }
    780            else if (step_events_completed > (uint32_t)current_block->decelerate_after) {
   \                     ??StepperHandler_63: (+1)
   \   00000582   0x69D0             LDR      R0,[R2, #+28]
   \   00000584   0x6B69             LDR      R1,[R5, #+52]
   \   00000586   0x4288             CMP      R0,R1
   \   00000588   0xD243             BCS.N    ??StepperHandler_67
    781              uint16_t step_rate;
    782              MultiU24X32toH16(step_rate, deceleration_time, current_block->acceleration_rate);
   \   0000058A   0xF8D5 0xB03C      LDR      R11,[R5, #+60]
   \   0000058E   0x6A10             LDR      R0,[R2, #+32]
   \   00000590   0xFB80 0x010B      SMULL    R0,R1,R0,R11
   \   00000594   0x0E00             LSRS     R0,R0,#+24
   \   00000596   0xEA40 0x2001      ORR      R0,R0,R1, LSL #+8
    783          
    784              if (step_rate < acc_step_rate) { // Still decelerating?
   \   0000059A   0x89E9             LDRH     R1,[R5, #+14]
   \   0000059C   0xB280             UXTH     R0,R0
   \   0000059E   0x4288             CMP      R0,R1
   \   000005A0   0xD206             BCS.N    ??StepperHandler_68
    785                step_rate = acc_step_rate - step_rate;
   \   000005A2   0x1A08             SUBS     R0,R1,R0
    786                NOLESS(step_rate, current_block->final_rate);
   \   000005A4   0x6C51             LDR      R1,[R2, #+68]
   \   000005A6   0xB280             UXTH     R0,R0
   \   000005A8   0x4288             CMP      R0,R1
   \   000005AA   0xD202             BCS.N    ??StepperHandler_69
   \   000005AC   0x4608             MOV      R0,R1
   \   000005AE   0xE000             B.N      ??StepperHandler_69
    787              }
    788              else
    789                step_rate = current_block->final_rate;
   \                     ??StepperHandler_68: (+1)
   \   000005B0   0x6C50             LDR      R0,[R2, #+68]
    790          
    791              // step_rate to timer interval
    792              const uint16_t interval = calc_timer_interval(step_rate);
   \                     ??StepperHandler_69: (+1)
   \   000005B2   0xB280             UXTH     R0,R0
   \   000005B4   0x.... 0x....      BL       _ZN7Stepper19calc_timer_intervalEt
    793          
    794              SPLIT(interval);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
   \   000005B8   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   000005BC   0x7812             LDRB     R2,[R2, #+0]
   \   000005BE   0x4601             MOV      R1,R0
   \   000005C0   0x2A00             CMP      R2,#+0
   \   000005C2   0xBF02             ITTT     EQ 
   \   000005C4   0x.... 0x....      LDREQ.W  R2,??DataTable20_4
   \   000005C8   0x7812             LDRBEQ   R2,[R2, #+0]
   \   000005CA   0x2A00             CMPEQ    R2,#+0
   \   000005CC   0xD013             BEQ.N    ??StepperHandler_70
   \   000005CE   0xF640 0x32B9      MOVW     R2,#+3001
   \   000005D2   0x4290             CMP      R0,R2
   \   000005D4   0xDB0F             BLT.N    ??StepperHandler_70
   \   000005D6   0xF640 0x31B8      MOVW     R1,#+3000
   \   000005DA   0x460A             MOV      R2,R1
   \   000005DC   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   000005E0   0xFB01 0x0212      MLS      R2,R1,R2,R0
   \   000005E4   0xB292             UXTH     R2,R2
   \   000005E6   0xF5B2 0x7F7A      CMP      R2,#+1000
   \   000005EA   0xBFB8             IT       LT 
   \   000005EC   0xF602 0x31B8      ADDWLT   R1,R2,#+3000
   \   000005F0   0xB289             UXTH     R1,R1
   \   000005F2   0x1A42             SUBS     R2,R0,R1
   \   000005F4   0x64EA             STR      R2,[R5, #+76]
    795              _NEXT_ISR(ocr_val);
   \                     ??StepperHandler_70: (+1)
   \   000005F6   0x.... 0x....      LDR.W    R2,??DataTable20_2
   \   000005FA   0x6812             LDR      R2,[R2, #+0]
   \   000005FC   0x62D1             STR      R1,[R2, #+44]
   \   000005FE   0x6AD1             LDR      R1,[R2, #+44]
   \   00000600   0x6A53             LDR      R3,[R2, #+36]
   \   00000602   0x4299             CMP      R1,R3
   \   00000604   0xD202             BCS.N    ??StepperHandler_71
   \   00000606   0x6AD1             LDR      R1,[R2, #+44]
   \   00000608   0x1E49             SUBS     R1,R1,#+1
   \   0000060A   0x6251             STR      R1,[R2, #+36]
    796          
    797              deceleration_time += interval;
   \                     ??StepperHandler_71: (+1)
   \   0000060C   0x4458             ADD      R0,R0,R11
   \   0000060E   0x63E8             STR      R0,[R5, #+60]
   \   00000610   0xE02C             B.N      ??StepperHandler_66
    798          
    799              #if ENABLED(LIN_ADVANCE)
    800          
    801                if (current_block->use_advance_lead) {
    802                  #if ENABLED(MIXING_EXTRUDER)
    803                    MIXING_STEPPERS_LOOP(j)
    804                      current_estep_rate[j] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8 * current_block->step_event_count / current_block->mix_event_count[j]) >> 17;
    805                  #else
    806                    current_estep_rate[TOOL_E_INDEX] = ((uint32_t)step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
    807                  #endif
    808                }
    809                eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], interval, step_loops);
    810          
    811              #endif // LIN_ADVANCE
    812            }
    813            else {
    814          
    815              #if ENABLED(LIN_ADVANCE)
    816          
    817                if (current_block->use_advance_lead)
    818                  current_estep_rate[TOOL_E_INDEX] = final_estep_rate;
    819          
    820                eISR_Rate = adv_rate(e_steps[TOOL_E_INDEX], OCR1A_nominal, step_loops_nominal);
    821          
    822              #endif
    823          
    824              SPLIT(OCR1A_nominal);  // split step into multiple ISRs if larger than ENDSTOP_NOMINAL_OCR_VAL
   \                     ??StepperHandler_67: (+1)
   \   00000612   0x.... 0x....      LDR.W    R2,??DataTable20_3
   \   00000616   0x89A8             LDRH     R0,[R5, #+12]
   \   00000618   0x7812             LDRB     R2,[R2, #+0]
   \   0000061A   0x4601             MOV      R1,R0
   \   0000061C   0x2A00             CMP      R2,#+0
   \   0000061E   0xBF02             ITTT     EQ 
   \   00000620   0x.... 0x....      LDREQ.W  R2,??DataTable20_4
   \   00000624   0x7812             LDRBEQ   R2,[R2, #+0]
   \   00000626   0x2A00             CMPEQ    R2,#+0
   \   00000628   0xD013             BEQ.N    ??StepperHandler_72
   \   0000062A   0xF640 0x32B9      MOVW     R2,#+3001
   \   0000062E   0x4290             CMP      R0,R2
   \   00000630   0xDB0F             BLT.N    ??StepperHandler_72
   \   00000632   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000636   0x460A             MOV      R2,R1
   \   00000638   0xFB90 0xF2F2      SDIV     R2,R0,R2
   \   0000063C   0xFB01 0x0212      MLS      R2,R1,R2,R0
   \   00000640   0xB292             UXTH     R2,R2
   \   00000642   0xF5B2 0x7F7A      CMP      R2,#+1000
   \   00000646   0xBFB8             IT       LT 
   \   00000648   0xF602 0x31B8      ADDWLT   R1,R2,#+3000
   \   0000064C   0xB289             UXTH     R1,R1
   \   0000064E   0x1A40             SUBS     R0,R0,R1
   \   00000650   0x64E8             STR      R0,[R5, #+76]
    825              _NEXT_ISR(ocr_val);
   \                     ??StepperHandler_72: (+1)
   \   00000652   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000656   0x6802             LDR      R2,[R0, #+0]
   \   00000658   0x62D1             STR      R1,[R2, #+44]
   \   0000065A   0x6AD0             LDR      R0,[R2, #+44]
   \   0000065C   0x6A51             LDR      R1,[R2, #+36]
   \   0000065E   0x4288             CMP      R0,R1
   \   00000660   0xD202             BCS.N    ??StepperHandler_73
   \   00000662   0x6AD0             LDR      R0,[R2, #+44]
   \   00000664   0x1E40             SUBS     R0,R0,#+1
   \   00000666   0x6250             STR      R0,[R2, #+36]
    826          
    827              // ensure we're running at the correct step rate, even if we just came off an acceleration
    828              step_loops = step_loops_nominal;
   \                     ??StepperHandler_73: (+1)
   \   00000668   0x7A68             LDRB     R0,[R5, #+9]
   \   0000066A   0x7228             STRB     R0,[R5, #+8]
    829            }
    830          
    831            #if DISABLED(LIN_ADVANCE)
    832              NOLESS(OCR1A, TCNT1 + 16);
   \                     ??StepperHandler_66: (+1)
   \   0000066C   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000670   0x6800             LDR      R0,[R0, #+0]
   \   00000672   0x6AC1             LDR      R1,[R0, #+44]
   \   00000674   0x6A42             LDR      R2,[R0, #+36]
   \   00000676   0x3210             ADDS     R2,R2,#+16
   \   00000678   0x4291             CMP      R1,R2
   \   0000067A   0xD202             BCS.N    ??StepperHandler_74
   \   0000067C   0x6A41             LDR      R1,[R0, #+36]
   \   0000067E   0x3110             ADDS     R1,R1,#+16
   \   00000680   0x62C1             STR      R1,[R0, #+44]
    833            #endif
    834          
    835            // If current block is finished, reset pointer
    836            if (all_steps_done) {
   \                     ??StepperHandler_74: (+1)
   \   00000682   0xB176             CBZ.N    R6,??StepperHandler_75
    837              current_block = NULL;
   \   00000684   0x2000             MOVS     R0,#+0
   \   00000686   0x6228             STR      R0,[R5, #+32]
    838              planner.discard_current_block();
   \   00000688   0x.... 0x....      LDR.W    R0,??DataTable20_6
   \   0000068C   0x7801             LDRB     R1,[R0, #+0]
   \   0000068E   0x.... 0x....      LDR.W    R0,??DataTable20_5
   \   00000692   0x7802             LDRB     R2,[R0, #+0]
   \   00000694   0x4291             CMP      R1,R2
   \   00000696   0xD004             BEQ.N    ??StepperHandler_75
   \   00000698   0x7801             LDRB     R1,[R0, #+0]
   \   0000069A   0x1C49             ADDS     R1,R1,#+1
   \   0000069C   0xF001 0x010F      AND      R1,R1,#0xF
   \   000006A0   0x7001             STRB     R1,[R0, #+0]
    839            }
    840            #if DISABLED(LIN_ADVANCE)
    841              _ENABLE_ISRs(); // re-enable ISRs
   \                     ??StepperHandler_75: (+1)
   \   000006A2   0xB662             cpsie i
   \                     ??StepperHandler_3: (+1)
   \   000006A4   0x.... 0x....      LDR.W    R0,??DataTable21
   \   000006A8   0x7800             LDRB     R0,[R0, #+0]
   \   000006AA   0x2800             CMP      R0,#+0
   \   000006AC   0x4650             MOV      R0,R10
   \   000006AE   0xD002             BEQ.N    ??StepperHandler_76
   \   000006B0   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   000006B4   0xE001             B.N      ??StepperHandler_77
   \                     ??StepperHandler_76: (+1)
   \   000006B6   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   \                     ??StepperHandler_77: (+1)
   \   000006BA   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   000006BE   0xBF00             Nop      
   \   000006C0                      REQUIRE ?Subroutine0
   \   000006C0                      ;; // Fall through to label ?Subroutine0
    842            #endif
    843          }

   \                                 In section .data, align 4
   \                     _ZN7Stepper15count_directionE:
   \   00000000   0x01 0x01          DC8 1, 1, 1, 1
   \              0x01 0x01    
   \                     _ZN7Stepper17performing_homingE:
   \   00000004   0x00               DC8 0
   \                     _ZN7Stepper19last_direction_bitsE:
   \   00000005   0x00               DC8 0
   \                     _ZN7Stepper14locked_z_motorE:
   \   00000006   0x00               DC8 0
   \                     _ZN7Stepper15locked_z2_motorE:
   \   00000007   0x00               DC8 0
   \                     _ZN7Stepper10step_loopsE:
   \   00000008   0x00               DC8 0
   \                     _ZN7Stepper18step_loops_nominalE:
   \   00000009   0x00               DC8 0
   \                     _ZN7Stepper23cleaning_buffer_counterE:
   \   0000000A   0x0000             DC16 0
   \                     _ZN7Stepper13OCR1A_nominalE:
   \   0000000C   0x00 0x00          DC8 0, 0
   \                     _ZN7Stepper13acc_step_rateE:
   \   0000000E   0x00 0x00          DC8 0, 0
   \                     _ZN7Stepper14count_positionE:
   \   00000010   0x00000000         DC32 0, 0, 0, 0
   \              0x00000000   
   \              0x00000000   
   \              0x00000000   
   \                     _ZN7Stepper13current_blockE:
   \   00000020   0x00000000         DC32 0H
   \                     _ZN7Stepper9counter_XE:
   \   00000024   0x00000000         DC32 0
   \                     _ZN7Stepper9counter_YE:
   \   00000028   0x00000000         DC32 0
   \                     _ZN7Stepper9counter_ZE:
   \   0000002C   0x00000000         DC32 0
   \                     _ZN7Stepper9counter_EE:
   \   00000030   0x00000000         DC32 0
   \                     _ZN7Stepper21step_events_completedE:
   \   00000034   0x00000000         DC32 0
   \                     _ZN7Stepper17acceleration_timeE:
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Stepper17deceleration_timeE:
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     _ZN7Stepper18endstops_trigstepsE:
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000004C   0x00000000         DC32 0
    844          
    845          #if ENABLED(LIN_ADVANCE)
    846          
    847            #define CYCLES_EATEN_E (E_STEPPERS * 5)
    848            #define EXTRA_CYCLES_E (STEP_PULSE_CYCLES - (CYCLES_EATEN_E))
    849          
    850            // Timer interrupt for E. e_steps is set in the main routine;
    851          
    852            void Stepper::advance_isr() {
    853          
    854              nextAdvanceISR = eISR_Rate;
    855          
    856              #if ENABLED(MK2_MULTIPLEXER)
    857                // Even-numbered steppers are reversed
    858                #define SET_E_STEP_DIR(INDEX) \
    859                  if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? !INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0) : INVERT_E## INDEX ##_DIR ^ TEST(INDEX, 0))
    860              #else
    861                #define SET_E_STEP_DIR(INDEX) \
    862                  if (e_steps[INDEX]) E## INDEX ##_DIR_WRITE(e_steps[INDEX] < 0 ? INVERT_E## INDEX ##_DIR : !INVERT_E## INDEX ##_DIR)
    863              #endif
    864          
    865              #define START_E_PULSE(INDEX) \
    866                if (e_steps[INDEX]) E## INDEX ##_STEP_WRITE(!INVERT_E_STEP_PIN)
    867          
    868              #define STOP_E_PULSE(INDEX) \
    869                if (e_steps[INDEX]) { \
    870                  e_steps[INDEX] < 0 ? ++e_steps[INDEX] : --e_steps[INDEX]; \
    871                  E## INDEX ##_STEP_WRITE(INVERT_E_STEP_PIN); \
    872                }
    873          
    874              SET_E_STEP_DIR(0);
    875              #if E_STEPPERS > 1
    876                SET_E_STEP_DIR(1);
    877                #if E_STEPPERS > 2
    878                  SET_E_STEP_DIR(2);
    879                  #if E_STEPPERS > 3
    880                    SET_E_STEP_DIR(3);
    881                    #if E_STEPPERS > 4
    882                      SET_E_STEP_DIR(4);
    883                    #endif
    884                  #endif
    885                #endif
    886              #endif
    887          
    888              // Step all E steppers that have steps
    889              for (uint8_t i = step_loops; i--;) {
    890          
    891                #if EXTRA_CYCLES_E > 20
    892                  uint32_t pulse_start = TCNT0;
    893                #endif
    894          
    895                START_E_PULSE(0);
    896                #if E_STEPPERS > 1
    897                  START_E_PULSE(1);
    898                  #if E_STEPPERS > 2
    899                    START_E_PULSE(2);
    900                    #if E_STEPPERS > 3
    901                      START_E_PULSE(3);
    902                      #if E_STEPPERS > 4
    903                        START_E_PULSE(4);
    904                      #endif
    905                    #endif
    906                  #endif
    907                #endif
    908          
    909                // For minimum pulse time wait before stopping pulses
    910                #if EXTRA_CYCLES_E > 20
    911                  while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    912                  pulse_start = TCNT0;
    913                #elif EXTRA_CYCLES_E > 0
    914                  DELAY_NOPS(EXTRA_CYCLES_E);
    915                #endif
    916          
    917                STOP_E_PULSE(0);
    918                #if E_STEPPERS > 1
    919                  STOP_E_PULSE(1);
    920                  #if E_STEPPERS > 2
    921                    STOP_E_PULSE(2);
    922                    #if E_STEPPERS > 3
    923                      STOP_E_PULSE(3);
    924                      #if E_STEPPERS > 4
    925                        STOP_E_PULSE(4);
    926                      #endif
    927                    #endif
    928                  #endif
    929                #endif
    930          
    931                // For minimum pulse time wait before looping
    932                #if EXTRA_CYCLES_E > 20
    933                  if (i) while (EXTRA_CYCLES_E > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
    934                #elif EXTRA_CYCLES_E > 0
    935                  if (i) DELAY_NOPS(EXTRA_CYCLES_E);
    936                #endif
    937          
    938              } // steps_loop
    939            }
    940          
    941            void Stepper::advance_isr_scheduler() {
    942              // Disable Timer0 ISRs and enable global ISR again to capture UART events (incoming chars)
    943              CBI(TIMSK0, OCIE0B); // Temperature ISR
    944              DISABLE_STEPPER_DRIVER_INTERRUPT();
    945              sei();
    946          
    947              // Run main stepping ISR if flagged
    948              if (!nextMainISR) isr();
    949          
    950              // Run Advance stepping ISR if flagged
    951              if (!nextAdvanceISR) advance_isr();
    952          
    953              // Is the next advance ISR scheduled before the next main ISR?
    954              if (nextAdvanceISR <= nextMainISR) {
    955                // Set up the next interrupt
    956                OCR1A = nextAdvanceISR;
    957                // New interval for the next main ISR
    958                if (nextMainISR) nextMainISR -= nextAdvanceISR;
    959                // Will call Stepper::advance_isr on the next interrupt
    960                nextAdvanceISR = 0;
    961              }
    962              else {
    963                // The next main ISR comes first
    964                OCR1A = nextMainISR;
    965                // New interval for the next advance ISR, if any
    966                if (nextAdvanceISR && nextAdvanceISR != ADV_NEVER)
    967                  nextAdvanceISR -= nextMainISR;
    968                // Will call Stepper::isr on the next interrupt
    969                nextMainISR = 0;
    970              }
    971          
    972              // Don't run the ISR faster than possible
    973              NOLESS(OCR1A, TCNT1 + 16);
    974          
    975              // Restore original ISR settings
    976              _ENABLE_ISRs();
    977            }
    978          
    979          #endif // LIN_ADVANCE
    980          

   \                                 In section .text, align 4, keep-with-next
    981          void Stepper::init() {
   \                     _ZN7Stepper4initEv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    982          
    983            // Init Digipot Motor Current
    984            #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
    985              digipot_init();
    986            #endif
    987          
    988            // Init Microstepping Pins
    989            #if HAS_MICROSTEPS
    990              microstep_init();
    991            #endif
    992          
    993            // Init TMC Steppers
    994            #if ENABLED(HAVE_TMCDRIVER)
    995              tmc_init();
    996            #endif
    997          
    998            // Init TMC2130 Steppers
    999            #if ENABLED(HAVE_TMC2130)
   1000              tmc2130_init();
   1001            #endif
   1002          
   1003            // Init TMC2208 Steppers
   1004            #if ENABLED(HAVE_TMC2208)
   1005              tmc2208_init();
   1006            #endif
   1007          
   1008            // TRAMS, TMC2130 and TMC2208 advanced settings
   1009            #if HAS_TRINAMIC
   1010              TMC_ADV()
   1011            #endif
   1012          
   1013            // Init L6470 Steppers
   1014            #if ENABLED(HAVE_L6470DRIVER)
   1015              L6470_init();
   1016            #endif
   1017          
   1018            // Init Dir Pins
   1019            #if HAS_X_DIR
   1020              X_DIR_INIT;
   1021            #endif
   1022            #if HAS_X2_DIR
   1023              X2_DIR_INIT;
   1024            #endif
   1025            #if HAS_Y_DIR
   1026              Y_DIR_INIT;
   1027              #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_DIR
   1028                Y2_DIR_INIT;
   1029              #endif
   1030            #endif
   1031            #if HAS_Z_DIR
   1032              Z_DIR_INIT;
   1033              //#if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_DIR
   1034              if(Z_DUAL_STEPPER_DRIVERS==1)
   1035              {
   1036                Z2_DIR_INIT;
   1037              }
   1038              //#endif
   1039            #endif
   1040            #if HAS_E0_DIR
   1041              E0_DIR_INIT;
   1042            #endif
   1043            #if HAS_E1_DIR
   1044              E1_DIR_INIT;
   1045            #endif
   1046            #if HAS_E2_DIR
   1047              E2_DIR_INIT;
   1048            #endif
   1049            #if HAS_E3_DIR
   1050              E3_DIR_INIT;
   1051            #endif
   1052            #if HAS_E4_DIR
   1053              E4_DIR_INIT;
   1054            #endif
   1055          
   1056            // Init Enable Pins - steppers default to disabled.
   1057            #if HAS_X_ENABLE
   1058              X_ENABLE_INIT;
   1059              if (!X_ENABLE_ON) X_ENABLE_WRITE(HIGH);
   \   00000004   0x.... 0x....      LDR.W    R8,??DataTable20
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable19_1
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable19_2
   \   00000010   0xF208 0x1601      ADDW     R6,R8,#+257
   \   00000014   0x78F0             LDRB     R0,[R6, #+3]
   \   00000016   0xB920             CBNZ.N   R0,??init_0
   \   00000018   0x88A9             LDRH     R1,[R5, #+4]
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_WritePin
   1060              #if ENABLED(DUAL_X_CARRIAGE) && HAS_X2_ENABLE
   1061                X2_ENABLE_INIT;
   1062                if (!X_ENABLE_ON) X2_ENABLE_WRITE(HIGH);
   1063              #endif
   1064            #endif
   1065            #if HAS_Y_ENABLE
   1066              Y_ENABLE_INIT;
   1067              if (!Y_ENABLE_ON) Y_ENABLE_WRITE(HIGH);
   \                     ??init_0: (+1)
   \   00000022   0x7930             LDRB     R0,[R6, #+4]
   \   00000024   0xB920             CBNZ.N   R0,??init_1
   \   00000026   0x89E9             LDRH     R1,[R5, #+14]
   \   00000028   0x69E0             LDR      R0,[R4, #+28]
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0x.... 0x....      BL       HAL_GPIO_WritePin
   1068              #if ENABLED(Y_DUAL_STEPPER_DRIVERS) && HAS_Y2_ENABLE
   1069                Y2_ENABLE_INIT;
   1070                if (!Y_ENABLE_ON) Y2_ENABLE_WRITE(HIGH);
   1071              #endif
   1072            #endif
   1073            #if HAS_Z_ENABLE
   1074              Z_ENABLE_INIT;
   1075              if (!Z_ENABLE_ON) Z_ENABLE_WRITE(HIGH);
   \                     ??init_1: (+1)
   \   00000030   0x7970             LDRB     R0,[R6, #+5]
   \   00000032   0xB920             CBNZ.N   R0,??init_2
   \   00000034   0x8B29             LDRH     R1,[R5, #+24]
   \   00000036   0x6B20             LDR      R0,[R4, #+48]
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_WritePin
   1076              //#if ENABLED(Z_DUAL_STEPPER_DRIVERS) && HAS_Z2_ENABLE
   1077              if(Z_DUAL_STEPPER_DRIVERS==1)
   1078              {
   1079                Z2_ENABLE_INIT;
   1080              }
   1081                if (!Z_ENABLE_ON) Z2_ENABLE_WRITE(HIGH);
   \                     ??init_2: (+1)
   \   0000003E   0x7970             LDRB     R0,[R6, #+5]
   \   00000040   0xB920             CBNZ.N   R0,??init_3
   \   00000042   0x8D29             LDRH     R1,[R5, #+40]
   \   00000044   0x6D20             LDR      R0,[R4, #+80]
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x.... 0x....      BL       HAL_GPIO_WritePin
   1082              //#endif
   1083            #endif
   1084            #if HAS_E0_ENABLE
   1085              E0_ENABLE_INIT;
   1086              if (!E_ENABLE_ON) E0_ENABLE_WRITE(HIGH);
   \                     ??init_3: (+1)
   \   0000004C   0x79B0             LDRB     R0,[R6, #+6]
   \   0000004E   0xB920             CBNZ.N   R0,??init_4
   \   00000050   0x8C69             LDRH     R1,[R5, #+34]
   \   00000052   0x6C60             LDR      R0,[R4, #+68]
   \   00000054   0x2201             MOVS     R2,#+1
   \   00000056   0x.... 0x....      BL       HAL_GPIO_WritePin
   1087            #endif
   1088            #if HAS_E1_ENABLE
   1089              E1_ENABLE_INIT;
   1090              if (!E_ENABLE_ON) E1_ENABLE_WRITE(HIGH);
   \                     ??init_4: (+1)
   \   0000005A   0x79B0             LDRB     R0,[R6, #+6]
   \   0000005C   0xB920             CBNZ.N   R0,??init_5
   \   0000005E   0x8D29             LDRH     R1,[R5, #+40]
   \   00000060   0x6D20             LDR      R0,[R4, #+80]
   \   00000062   0x2201             MOVS     R2,#+1
   \   00000064   0x.... 0x....      BL       HAL_GPIO_WritePin
   1091            #endif
   1092            #if HAS_E2_ENABLE
   1093              E2_ENABLE_INIT;
   1094              if (!E_ENABLE_ON) E2_ENABLE_WRITE(HIGH);
   1095            #endif
   1096            #if HAS_E3_ENABLE
   1097              E3_ENABLE_INIT;
   1098              if (!E_ENABLE_ON) E3_ENABLE_WRITE(HIGH);
   1099            #endif
   1100            #if HAS_E4_ENABLE
   1101              E4_ENABLE_INIT;
   1102              if (!E_ENABLE_ON) E4_ENABLE_WRITE(HIGH);
   1103            #endif
   1104          
   1105            // Init endstops and pullups
   1106            endstops.init();
   \                     ??init_5: (+1)
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable21_1
   \   0000006C   0x.... 0x....      BL       _ZN8Endstops4initEv
   1107          
   1108            #define _STEP_INIT(AXIS) AXIS ##_STEP_INIT
   1109            #define _WRITE_STEP(AXIS, HIGHLOW) AXIS ##_STEP_WRITE(HIGHLOW)
   1110            #define _DISABLE(AXIS) disable_## AXIS()
   1111          
   1112            #define AXIS_INIT(AXIS, PIN) \
   1113              _STEP_INIT(AXIS); \
   1114              _WRITE_STEP(AXIS, _INVERT_STEP_PIN(PIN)); \
   1115              _DISABLE(AXIS)
   1116          
   1117            #define E_AXIS_INIT(NUM) AXIS_INIT(E## NUM, E)
   1118          
   1119            // Init Step Pins
   1120            #if HAS_X_STEP
   1121              #if ENABLED(X_DUAL_STEPPER_DRIVERS) || ENABLED(DUAL_X_CARRIAGE)
   1122                X2_STEP_INIT;
   1123                X2_STEP_WRITE(INVERT_X_STEP_PIN);
   1124              #endif
   1125              AXIS_INIT(X, X);
   \   00000070   0x8869             LDRH     R1,[R5, #+2]
   \   00000072   0x6860             LDR      R0,[R4, #+4]
   \   00000074   0x2200             MOVS     R2,#+0
   \   00000076   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000007C   0x88A9             LDRH     R1,[R5, #+4]
   \   0000007E   0x1E42             SUBS     R2,R0,#+1
   \   00000080   0x4192             SBCS     R2,R2,R2
   \   00000082   0x0FD2             LSRS     R2,R2,#+31
   \   00000084   0x68A0             LDR      R0,[R4, #+8]
   \   00000086   0xB252             SXTB     R2,R2
   \   00000088   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000008C   0x.... 0x....      LDR.W    R7,??DataTable21_2
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x7038             STRB     R0,[R7, #+0]
   1126            #endif
   1127          
   1128            #if HAS_Y_STEP
   1129              #if ENABLED(Y_DUAL_STEPPER_DRIVERS)
   1130                Y2_STEP_INIT;
   1131                Y2_STEP_WRITE(INVERT_Y_STEP_PIN);
   1132              #endif
   1133              AXIS_INIT(Y, Y);
   \   00000094   0x2200             MOVS     R2,#+0
   \   00000096   0x89A9             LDRH     R1,[R5, #+12]
   \   00000098   0x69A0             LDR      R0,[R4, #+24]
   \   0000009A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000009E   0x7930             LDRB     R0,[R6, #+4]
   \   000000A0   0x89E9             LDRH     R1,[R5, #+14]
   \   000000A2   0x1E42             SUBS     R2,R0,#+1
   \   000000A4   0x4192             SBCS     R2,R2,R2
   \   000000A6   0x0FD2             LSRS     R2,R2,#+31
   \   000000A8   0x69E0             LDR      R0,[R4, #+28]
   \   000000AA   0xB252             SXTB     R2,R2
   \   000000AC   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000B0   0x2000             MOVS     R0,#+0
   \   000000B2   0x7078             STRB     R0,[R7, #+1]
   1134            #endif
   1135          
   1136            #if HAS_Z_STEP
   1137              //#if ENABLED(Z_DUAL_STEPPER_DRIVERS)
   1138              if(Z_DUAL_STEPPER_DRIVERS==1)
   \   000000B4   0xF898 0x0101      LDRB     R0,[R8, #+257]
   \   000000B8   0x2801             CMP      R0,#+1
   \   000000BA   0xD104             BNE.N    ??init_6
   1139              {
   1140                Z2_STEP_INIT;
   1141                Z2_STEP_WRITE(INVERT_Z_STEP_PIN);
   \   000000BC   0x8CE9             LDRH     R1,[R5, #+38]
   \   000000BE   0x6CE0             LDR      R0,[R4, #+76]
   \   000000C0   0x2200             MOVS     R2,#+0
   \   000000C2   0x.... 0x....      BL       HAL_GPIO_WritePin
   1142              }
   1143              //#endif
   1144              AXIS_INIT(Z, Z);
   \                     ??init_6: (+1)
   \   000000C6   0x8AE9             LDRH     R1,[R5, #+22]
   \   000000C8   0x6AE0             LDR      R0,[R4, #+44]
   \   000000CA   0x2200             MOVS     R2,#+0
   \   000000CC   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000D0   0x7970             LDRB     R0,[R6, #+5]
   \   000000D2   0x8B29             LDRH     R1,[R5, #+24]
   \   000000D4   0x1E42             SUBS     R2,R0,#+1
   \   000000D6   0x4192             SBCS     R2,R2,R2
   \   000000D8   0x0FD2             LSRS     R2,R2,#+31
   \   000000DA   0x6B20             LDR      R0,[R4, #+48]
   \   000000DC   0xB252             SXTB     R2,R2
   \   000000DE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000E2   0x7970             LDRB     R0,[R6, #+5]
   \   000000E4   0x8D29             LDRH     R1,[R5, #+40]
   \   000000E6   0x1E42             SUBS     R2,R0,#+1
   \   000000E8   0x4192             SBCS     R2,R2,R2
   \   000000EA   0x0FD2             LSRS     R2,R2,#+31
   \   000000EC   0x6D20             LDR      R0,[R4, #+80]
   \   000000EE   0xB252             SXTB     R2,R2
   \   000000F0   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000F4   0x2000             MOVS     R0,#+0
   \   000000F6   0x70B8             STRB     R0,[R7, #+2]
   1145            #endif
   1146          
   1147            #if HAS_E0_STEP
   1148              E_AXIS_INIT(0);
   \   000000F8   0x2200             MOVS     R2,#+0
   \   000000FA   0x8C29             LDRH     R1,[R5, #+32]
   \   000000FC   0x6C20             LDR      R0,[R4, #+64]
   \   000000FE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000102   0x79B0             LDRB     R0,[R6, #+6]
   \   00000104   0x8C69             LDRH     R1,[R5, #+34]
   \   00000106   0x1E42             SUBS     R2,R0,#+1
   \   00000108   0x4192             SBCS     R2,R2,R2
   \   0000010A   0x0FD2             LSRS     R2,R2,#+31
   \   0000010C   0x6C60             LDR      R0,[R4, #+68]
   \   0000010E   0xB252             SXTB     R2,R2
   \   00000110   0x.... 0x....      BL       HAL_GPIO_WritePin
   1149            #endif
   1150            #if HAS_E1_STEP
   1151              E_AXIS_INIT(1);
   \   00000114   0x8CE9             LDRH     R1,[R5, #+38]
   \   00000116   0x6CE0             LDR      R0,[R4, #+76]
   \   00000118   0x2200             MOVS     R2,#+0
   \   0000011A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000011E   0x79B0             LDRB     R0,[R6, #+6]
   \   00000120   0x8D29             LDRH     R1,[R5, #+40]
   \   00000122   0x1E42             SUBS     R2,R0,#+1
   \   00000124   0x4192             SBCS     R2,R2,R2
   \   00000126   0x0FD2             LSRS     R2,R2,#+31
   \   00000128   0x6D20             LDR      R0,[R4, #+80]
   \   0000012A   0xB252             SXTB     R2,R2
   \   0000012C   0x.... 0x....      BL       HAL_GPIO_WritePin
   1152            #endif
   1153            #if HAS_E2_STEP
   1154              E_AXIS_INIT(2);
   1155            #endif
   1156            #if HAS_E3_STEP
   1157              E_AXIS_INIT(3);
   1158            #endif
   1159            #if HAS_E4_STEP
   1160              E_AXIS_INIT(4);
   1161            #endif
   1162          #if 0
   1163            // waveform generation = 0100 = CTC
   1164            SET_WGM(1, CTC_OCRnA);
   1165          
   1166            // output mode = 00 (disconnected)
   1167            SET_COMA(1, NORMAL);
   1168          
   1169            // Set the timer pre-scaler
   1170            // Generally we use a divider of 8, resulting in a 2MHz timer
   1171            // frequency on a 16MHz MCU. If you are going to change this, be
   1172            // sure to regenerate speed_lookuptable.h with
   1173            // create_speed_lookuptable.py
   1174            SET_CS(1, PRESCALER_8);  //  CS 2 = 1/8 prescaler
   1175          
   1176            // Init Stepper ISR to 122 Hz for quick starting
   1177            OCR1A = 0x4000;
   1178            TCNT1 = 0;
   1179          #endif
   1180            ENABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000130   0x.... 0x....      LDR.W    R0,??DataTable20_2
   \   00000134   0x.... 0x....      BL       HAL_TIM_Base_Start_IT
   1181          
   1182            #if ENABLED(LIN_ADVANCE)
   1183              for (uint8_t i = 0; i < COUNT(e_steps); i++) e_steps[i] = 0;
   1184              ZERO(current_adv_steps);
   1185            #endif
   1186          
   1187            endstops.enable(true); // Start with endstops active. After homing they can be disabled
   \   00000138   0x.... 0x....      LDR.W    R1,??DataTable20_3
   \   0000013C   0x2001             MOVS     R0,#+1
   \   0000013E   0x7008             STRB     R0,[R1, #+0]
   1188            sei();
   \   00000140   0xB662             cpsie i
   1189          
   1190            set_directions(); // Init directions to last_direction_bits = 0
   \   00000142   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000146   0x.... 0x....      B.W      _ZN7Stepper14set_directionsEv
   1191          }
   1192          
   1193          
   1194          /**
   1195           * Block until all buffered steps are executed / cleaned
   1196           */

   \                                 In section .text, align 2, keep-with-next
   1197          void Stepper::synchronize() { while (planner.blocks_queued() || cleaning_buffer_counter) idle(); }
   \                     _ZN7Stepper11synchronizeEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable20_5
   \   00000004   0x....             LDR.N    R5,??DataTable20_6
   \   00000006   0xE001             B.N      ??synchronize_0
   \                     ??synchronize_1: (+1)
   \   00000008   0x.... 0x....      BL       _Z4idlev
   \                     ??synchronize_0: (+1)
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x7821             LDRB     R1,[R4, #+0]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x.... 0x....      LDREQ.W  R0,??DataTable21_3
   \   00000018   0xF9B0 0x000A      LDRSHEQ  R0,[R0, #+10]
   \   0000001C   0x2800             CMPEQ    R0,#+0
   \   0000001E   0xD1F3             BNE.N    ??synchronize_1
   \   00000020   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   1198          void Stepper::waitUntilEndOfAllBuffers() { while (planner.blocks_queued()) ;}
   \                     _ZN7Stepper24waitUntilEndOfAllBuffersEv: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable20_5
   \   00000002   0x....             LDR.N    R1,??DataTable20_6
   \                     ??waitUntilEndOfAllBuffers_0: (+1)
   \   00000004   0x780A             LDRB     R2,[R1, #+0]
   \   00000006   0x7803             LDRB     R3,[R0, #+0]
   \   00000008   0x429A             CMP      R2,R3
   \   0000000A   0xD1FB             BNE.N    ??waitUntilEndOfAllBuffers_0
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   1199          void Stepper:: waitUntilEndOfAllMoves()	{ }
   \                     _ZN7Stepper22waitUntilEndOfAllMovesEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1200          
   1201          /**
   1202           * Set the stepper positions directly in steps
   1203           *
   1204           * The input is based on the typical per-axis XYZ steps.
   1205           * For CORE machines XYZ needs to be translated to ABC.
   1206           *
   1207           * This allows get_axis_position_mm to correctly
   1208           * derive the current XYZ position later on.
   1209           */

   \                                 In section .text, align 4, keep-with-next
   1210          void Stepper::set_position(const long &a, const long &b, const long &c, const long &e) {
   \                     _ZN7Stepper12set_positionERKlS1_S1_S1_: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x461F             MOV      R7,R3
   1211          
   1212            synchronize(); // Bad to set stepper counts in the middle of a move
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable20_5
   \   00000010   0x.... 0x....      LDR.W    R9,??DataTable20_6
   \   00000014   0xE001             B.N      ??set_position_0
   \                     ??set_position_1: (+1)
   \   00000016   0x.... 0x....      BL       _Z4idlev
   \                     ??set_position_0: (+1)
   \   0000001A   0xF899 0x0000      LDRB     R0,[R9, #+0]
   \   0000001E   0xF898 0x1000      LDRB     R1,[R8, #+0]
   \   00000022   0x4288             CMP      R0,R1
   \   00000024   0xBF02             ITTT     EQ 
   \   00000026   0x....             LDREQ.N  R0,??DataTable19
   \   00000028   0xF9B0 0x100A      LDRSHEQ  R1,[R0, #+10]
   \   0000002C   0x2900             CMPEQ    R1,#+0
   \   0000002E   0xD1F2             BNE.N    ??set_position_1
   1213          
   1214            CRITICAL_SECTION_START;
   \   00000030   0x.... 0x....      LDR.W    R1,??DataTable21_4
   \   00000034   0xB672             cpsid i
   \   00000036   0xF9B1 0x2058      LDRSH    R2,[R1, #+88]
   \   0000003A   0x6823             LDR      R3,[R4, #+0]
   \   0000003C   0x210C             MOVS     R1,#+12
   \   0000003E   0x420A             TST      R2,R1
   \   00000040   0xD00A             BEQ.N    ??set_position_2
   1215          #if 0
   1216            #if CORE_IS_XY
   1217              // corexy positioning
   1218              // these equations follow the form of the dA and dB equations on http://www.corexy.com/theory.html
   1219              count_position[A_AXIS] = a + b;
   1220              count_position[B_AXIS] = CORESIGN(a - b);
   1221              count_position[Z_AXIS] = c;
   1222            #elif CORE_IS_XZ
   1223              // corexz planning
   1224              count_position[A_AXIS] = a + c;
   1225              count_position[Y_AXIS] = b;
   1226              count_position[C_AXIS] = CORESIGN(a - c);
   1227            #elif CORE_IS_YZ
   1228              // coreyz planning
   1229              count_position[X_AXIS] = a;
   1230              count_position[B_AXIS] = b + c;
   1231              count_position[C_AXIS] = CORESIGN(b - c);
   1232            #else
   1233              // default non-h-bot planning
   1234              count_position[X_AXIS] = a;
   1235              count_position[Y_AXIS] = b;
   1236              count_position[Z_AXIS] = c;
   1237            #endif
   1238          #endif
   1239            if(MACHINETPYE & CORE_IS_XY)
   1240            	{
   1241          	  count_position[A_AXIS] = a + b;
   \   00000042   0x6829             LDR      R1,[R5, #+0]
   \   00000044   0x18C9             ADDS     R1,R1,R3
   \   00000046   0x6101             STR      R1,[R0, #+16]
   1242          	  count_position[B_AXIS] = CORESIGN(a - b);
   \   00000048   0x682B             LDR      R3,[R5, #+0]
   \   0000004A   0x6821             LDR      R1,[R4, #+0]
   \   0000004C   0x1AC9             SUBS     R1,R1,R3
   \   0000004E   0x23A8             MOVS     R3,#+168
   \   00000050   0x421A             TST      R2,R3
   \   00000052   0xD021             BEQ.N    ??set_position_3
   \   00000054   0x4249             RSBS     R1,R1,#+0
   1243          	  count_position[Z_AXIS] = c;
   1244            	}
   \   00000056   0xE01F             B.N      ??set_position_3
   1245            else if(MACHINETPYE & CORE_IS_XZ)
   \                     ??set_position_2: (+1)
   \   00000058   0x2130             MOVS     R1,#+48
   \   0000005A   0x420A             TST      R2,R1
   \   0000005C   0xD00C             BEQ.N    ??set_position_4
   1246            	{
   1247          	  count_position[A_AXIS] = a + c;
   \   0000005E   0x6831             LDR      R1,[R6, #+0]
   \   00000060   0x18C9             ADDS     R1,R1,R3
   \   00000062   0x6101             STR      R1,[R0, #+16]
   1248          	  count_position[Y_AXIS] = b;
   \   00000064   0x6829             LDR      R1,[R5, #+0]
   \   00000066   0x6141             STR      R1,[R0, #+20]
   1249          	  count_position[C_AXIS] = CORESIGN(a - c);
   \   00000068   0x6833             LDR      R3,[R6, #+0]
   \   0000006A   0x6821             LDR      R1,[R4, #+0]
   \   0000006C   0x1AC9             SUBS     R1,R1,R3
   \   0000006E   0x23A8             MOVS     R3,#+168
   \   00000070   0x421A             TST      R2,R3
   \   00000072   0xD013             BEQ.N    ??set_position_5
   \   00000074   0x4249             RSBS     R1,R1,#+0
   1250            	}
   \   00000076   0xE011             B.N      ??set_position_5
   1251            else if(MACHINETPYE & CORE_IS_YZ)
   \                     ??set_position_4: (+1)
   \   00000078   0x21C0             MOVS     R1,#+192
   \   0000007A   0x420A             TST      R2,R1
   \   0000007C   0x6103             STR      R3,[R0, #+16]
   \   0000007E   0x6829             LDR      R1,[R5, #+0]
   \   00000080   0xD00A             BEQ.N    ??set_position_3
   1252            	{
   1253          	  count_position[X_AXIS] = a;
   1254          	  count_position[B_AXIS] = b + c;
   \   00000082   0x6833             LDR      R3,[R6, #+0]
   \   00000084   0x1859             ADDS     R1,R3,R1
   \   00000086   0x6141             STR      R1,[R0, #+20]
   1255          	  count_position[C_AXIS] = CORESIGN(b - c);
   \   00000088   0x6833             LDR      R3,[R6, #+0]
   \   0000008A   0x6829             LDR      R1,[R5, #+0]
   \   0000008C   0x1AC9             SUBS     R1,R1,R3
   \   0000008E   0x23A8             MOVS     R3,#+168
   \   00000090   0x421A             TST      R2,R3
   \   00000092   0xD003             BEQ.N    ??set_position_5
   \   00000094   0x4249             RSBS     R1,R1,#+0
   1256            	}
   \   00000096   0xE001             B.N      ??set_position_5
   1257            else
   1258            	{
   1259          	  count_position[X_AXIS] = a;
   1260          	  count_position[Y_AXIS] = b;
   \                     ??set_position_3: (+1)
   \   00000098   0x6141             STR      R1,[R0, #+20]
   1261          	  count_position[Z_AXIS] = c;
   \   0000009A   0x6831             LDR      R1,[R6, #+0]
   \                     ??set_position_5: (+1)
   \   0000009C   0x6181             STR      R1,[R0, #+24]
   1262            	}
   1263          
   1264            count_position[E_AXIS] = e;
   \   0000009E   0x6839             LDR      R1,[R7, #+0]
   \   000000A0   0x61C1             STR      R1,[R0, #+28]
   1265            CRITICAL_SECTION_END;
   \   000000A2   0xB662             cpsie i
   1266          }
   \   000000A4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1267          

   \                                 In section .text, align 4, keep-with-next
   1268          void Stepper::set_position(const AxisEnum &axis, const long &v) {
   1269            CRITICAL_SECTION_START;
   \                     _ZN7Stepper12set_positionERK8AxisEnumRKl: (+1)
   \   00000000   0xB672             cpsid i
   1270            count_position[axis] = v;
   \   00000002   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R2,??DataTable21_3
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   00000010   0x6101             STR      R1,[R0, #+16]
   1271            CRITICAL_SECTION_END;
   \   00000012   0xB662             cpsie i
   1272          }
   \   00000014   0x4770             BX       LR               ;; return
   1273          

   \                                 In section .text, align 4, keep-with-next
   1274          void Stepper::set_e_position(const long &e) {
   1275            CRITICAL_SECTION_START;
   \                     _ZN7Stepper14set_e_positionERKl: (+1)
   \   00000000   0xB672             cpsid i
   1276            count_position[E_AXIS] = e;
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   00000008   0x61C8             STR      R0,[R1, #+28]
   1277            CRITICAL_SECTION_END;
   \   0000000A   0xB662             cpsie i
   1278          }
   \   0000000C   0x4770             BX       LR               ;; return
   1279          
   1280          /**
   1281           * Get a stepper's position in steps.
   1282           */

   \                                 In section .text, align 4, keep-with-next
   1283          long Stepper::position(const AxisEnum axis) {
   1284            CRITICAL_SECTION_START;
   1285            const long count_pos = count_position[axis];
   \                     _ZN7Stepper8positionE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable21_3
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0xB672             cpsid i
   \   0000000A   0x6900             LDR      R0,[R0, #+16]
   1286            CRITICAL_SECTION_END;
   \   0000000C   0xB662             cpsie i
   1287            return count_pos;
   \   0000000E   0x4770             BX       LR               ;; return
   1288          }
   1289          
   1290          /**
   1291           * Get an axis position according to stepper position(s)
   1292           * For CORE machines apply translation from ABC to XYZ.
   1293           */

   \                                 In section .text, align 4, keep-with-next
   1294          float Stepper::get_axis_position_mm(const AxisEnum axis) {
   \                     _ZN7Stepper20get_axis_position_mmE8AxisEnum: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   1295            float axis_steps;
   1296            //#if IS_CORE
   1297            if(MACHINETPYE & IS_CORE) {
   \   00000002   0x....             LDR.N    R1,??DataTable20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0xF891 0x0058      LDRB     R0,[R1, #+88]
   \   0000000A   0x22FC             MOVS     R2,#+252
   \   0000000C   0x4210             TST      R0,R2
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xD025             BEQ.N    ??get_axis_position_mm_0
   1298              // Requesting one of the "core" axes?
   1299              if (axis == CORE_AXIS_1 || axis == CORE_AXIS_2) {
   \   00000012   0x.... 0x....      LDR.W    R2,??DataTable21_5
   \   00000016   0x7C13             LDRB     R3,[R2, #+16]
   \   00000018   0x4298             CMP      R0,R3
   \   0000001A   0xBF1C             ITT      NE 
   \   0000001C   0x7C53             LDRBNE   R3,[R2, #+17]
   \   0000001E   0x4298             CMPNE    R0,R3
   \   00000020   0xD11D             BNE.N    ??get_axis_position_mm_0
   1300                CRITICAL_SECTION_START;
   \   00000022   0xB672             cpsid i
   1301                // ((a1+a2)+(a1-a2))/2 -> (a1+a2+a1-a2)/2 -> (a1+a1)/2 -> a1
   1302                // ((a1+a2)-(a1-a2))/2 -> (a1+a2-a1+a2)/2 -> (a2+a2)/2 -> a2
   1303                axis_steps = 0.5f * (
   1304                  axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
   1305                                      : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
   1306                );
   \   00000024   0x7C53             LDRB     R3,[R2, #+17]
   \   00000026   0x7C12             LDRB     R2,[R2, #+16]
   \   00000028   0x....             LDR.N    R5,??DataTable19
   \   0000002A   0xEB05 0x0282      ADD      R2,R5,R2, LSL #+2
   \   0000002E   0x4298             CMP      R0,R3
   \   00000030   0x6910             LDR      R0,[R2, #+16]
   \   00000032   0xEB05 0x0683      ADD      R6,R5,R3, LSL #+2
   \   00000036   0xD108             BNE.N    ??get_axis_position_mm_1
   \   00000038   0x6932             LDR      R2,[R6, #+16]
   \   0000003A   0xF891 0x1058      LDRB     R1,[R1, #+88]
   \   0000003E   0x1A80             SUBS     R0,R0,R2
   \   00000040   0x22A8             MOVS     R2,#+168
   \   00000042   0x4211             TST      R1,R2
   \   00000044   0xD003             BEQ.N    ??get_axis_position_mm_2
   \   00000046   0x4240             RSBS     R0,R0,#+0
   \   00000048   0xE001             B.N      ??get_axis_position_mm_2
   \                     ??get_axis_position_mm_1: (+1)
   \   0000004A   0x6931             LDR      R1,[R6, #+16]
   \   0000004C   0x1808             ADDS     R0,R1,R0
   \                     ??get_axis_position_mm_2: (+1)
   \   0000004E   0x.... 0x....      BL       __aeabi_i2f
   \   00000052   0xF04F 0x517C      MOV      R1,#+1056964608
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   1307                CRITICAL_SECTION_END;
   \   0000005A   0xB662             cpsie i
   \   0000005C   0xE003             B.N      ??get_axis_position_mm_3
   1308              }
   1309              else
   1310                axis_steps = position(axis);
   1311            	}
   1312            //#else
   1313            else
   1314            {
   1315              axis_steps = position(axis);
   \                     ??get_axis_position_mm_0: (+1)
   \   0000005E   0x.... 0x....      BL       _ZN7Stepper8positionE8AxisEnum
   \   00000062   0x.... 0x....      BL       __aeabi_i2f
   1316            }
   1317            //#endif
   1318            return axis_steps * planner.steps_to_mm[axis];
   \                     ??get_axis_position_mm_3: (+1)
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable21_6
   \   0000006A   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   0000006E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000072   0x.... 0x....      B.W      __aeabi_fmul
   1319          }
   1320          

   \                                 In section .text, align 2, keep-with-next
   1321          void Stepper::finish_and_disable() {
   \                     _ZN7Stepper18finish_and_disableEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1322            synchronize();
   \   00000002   0x....             LDR.N    R4,??DataTable20_5
   \   00000004   0x....             LDR.N    R5,??DataTable20_6
   \   00000006   0xE001             B.N      ??finish_and_disable_0
   \                     ??finish_and_disable_1: (+1)
   \   00000008   0x.... 0x....      BL       _Z4idlev
   \                     ??finish_and_disable_0: (+1)
   \   0000000C   0x7828             LDRB     R0,[R5, #+0]
   \   0000000E   0x7821             LDRB     R1,[R4, #+0]
   \   00000010   0x4288             CMP      R0,R1
   \   00000012   0xBF02             ITTT     EQ 
   \   00000014   0x.... 0x....      LDREQ.W  R0,??DataTable21_3
   \   00000018   0xF9B0 0x000A      LDRSHEQ  R0,[R0, #+10]
   \   0000001C   0x2800             CMPEQ    R0,#+0
   \   0000001E   0xD1F3             BNE.N    ??finish_and_disable_1
   1323            disable_all_steppers();
   \   00000020   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000024   0x.... 0x....      B.W      _Z20disable_all_steppersv
   1324          }
   1325          

   \                                 In section .text, align 2, keep-with-next
   1326          void Stepper::quick_stop() {
   \                     _ZN7Stepper10quick_stopEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   1327            cleaning_buffer_counter = 5000;
   \   00000002   0x....             LDR.N    R4,??DataTable19
   1328            DISABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000004   0x....             LDR.N    R5,??DataTable20_2
   \   00000006   0xF241 0x3088      MOVW     R0,#+5000
   \   0000000A   0x8160             STRH     R0,[R4, #+10]
   \   0000000C   0x4628             MOV      R0,R5
   \   0000000E   0x.... 0x....      BL       HAL_TIM_Base_Stop_IT
   \   00000012   0x....             LDR.N    R0,??DataTable20_5
   \   00000014   0x....             LDR.N    R1,??DataTable20_6
   \   00000016   0xE008             B.N      ??quick_stop_0
   1329            while (planner.blocks_queued()) planner.discard_current_block();
   \                     ??quick_stop_1: (+1)
   \   00000018   0x780A             LDRB     R2,[R1, #+0]
   \   0000001A   0x7803             LDRB     R3,[R0, #+0]
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD004             BEQ.N    ??quick_stop_0
   \   00000020   0x7802             LDRB     R2,[R0, #+0]
   \   00000022   0x1C52             ADDS     R2,R2,#+1
   \   00000024   0xF002 0x020F      AND      R2,R2,#0xF
   \   00000028   0x7002             STRB     R2,[R0, #+0]
   \                     ??quick_stop_0: (+1)
   \   0000002A   0x780A             LDRB     R2,[R1, #+0]
   \   0000002C   0x7803             LDRB     R3,[R0, #+0]
   \   0000002E   0x429A             CMP      R2,R3
   \   00000030   0xD1F2             BNE.N    ??quick_stop_1
   1330            current_block = NULL;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6220             STR      R0,[R4, #+32]
   1331            ENABLE_STEPPER_DRIVER_INTERRUPT();
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000003C   0x.... 0x....      B.W      HAL_TIM_Base_Start_IT
   1332            #if ENABLED(ULTRA_LCD)
   1333              planner.clear_block_buffer_runtime();
   1334            #endif
   1335          }
   1336          

   \                                 In section .text, align 2, keep-with-next
   1337          void Stepper::endstop_triggered(AxisEnum axis) {
   \                     _ZN7Stepper17endstop_triggeredE8AxisEnum: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R0,??DataTable20
   \   00000006   0x....             LDR.N    R5,??DataTable19
   \   00000008   0xF9B0 0x1058      LDRSH    R1,[R0, #+88]
   \   0000000C   0x20FC             MOVS     R0,#+252
   \   0000000E   0x4201             TST      R1,R0
   \   00000010   0xD01F             BEQ.N    ??endstop_triggered_0
   1338          
   1339            //#if IS_CORE
   1340            if(MACHINETPYE & IS_CORE) {
   1341          
   1342              endstops_trigsteps[axis] = 0.5f * (
                                              ^
Warning[Pa093]: implicit conversion from floating point to integer

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\planner.h",549  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        _NEXT_ISR(acceleration_time);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.h",383  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        _NEXT_ISR(ocr_val);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",446  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        NOLESS(OCR1A, TCNT1 + 16);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",447  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      _NEXT_ISR(200);                             // Run at max speed - 10 KHz
      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",471  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        _NEXT_ISR(2000); // Run at slow speed - 1 KHz
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",507  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        PULSE_START(X);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",654  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        PULSE_START(Y);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",657  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        Z_PULSE_START(Z);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",660  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

          PULSE_START(E);
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",676  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        PULSE_STOP(X);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",689  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        PULSE_STOP(X);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",689  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        PULSE_STOP(Y);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",692  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        PULSE_STOP(Y);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",692  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        Z_PULSE_STOP(Z);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",695  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        Z_PULSE_STOP(Z);
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",695  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

          PULSE_STOP(E);
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",712  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

          PULSE_STOP(E);
          ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",712  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      _NEXT_ISR(ocr_val);
      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",762  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      _NEXT_ISR(ocr_val);
      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",795  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      _NEXT_ISR(ocr_val);
      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",825  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      NOLESS(OCR1A, TCNT1 + 16);
      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",832  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

        axis_steps = 0.5f * (
        ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",1303  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

      endstops_trigsteps[axis] = 0.5f * (
      ^
"D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\stepper.cpp",1342  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   1343                axis == CORE_AXIS_2 ? CORESIGN(count_position[CORE_AXIS_1] - count_position[CORE_AXIS_2])
   1344                                    : count_position[CORE_AXIS_1] + count_position[CORE_AXIS_2]
   1345              );
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable21_5
   \   00000016   0x7C42             LDRB     R2,[R0, #+17]
   \   00000018   0x7C00             LDRB     R0,[R0, #+16]
   \   0000001A   0xEB05 0x0080      ADD      R0,R5,R0, LSL #+2
   \   0000001E   0xEB05 0x0382      ADD      R3,R5,R2, LSL #+2
   \   00000022   0x6900             LDR      R0,[R0, #+16]
   \   00000024   0x4294             CMP      R4,R2
   \   00000026   0xD106             BNE.N    ??endstop_triggered_1
   \   00000028   0x691A             LDR      R2,[R3, #+16]
   \   0000002A   0x1A80             SUBS     R0,R0,R2
   \   0000002C   0x22A8             MOVS     R2,#+168
   \   0000002E   0x4211             TST      R1,R2
   \   00000030   0xD003             BEQ.N    ??endstop_triggered_2
   \   00000032   0x4240             RSBS     R0,R0,#+0
   \   00000034   0xE001             B.N      ??endstop_triggered_2
   \                     ??endstop_triggered_1: (+1)
   \   00000036   0x6919             LDR      R1,[R3, #+16]
   \   00000038   0x1808             ADDS     R0,R1,R0
   \                     ??endstop_triggered_2: (+1)
   \   0000003A   0x.... 0x....      BL       __aeabi_i2f
   \   0000003E   0xF04F 0x517C      MOV      R1,#+1056964608
   \   00000042   0x.... 0x....      BL       __aeabi_fmul
   \   00000046   0x.... 0x....      BL       __aeabi_f2iz
   \   0000004A   0xEB05 0x0184      ADD      R1,R5,R4, LSL #+2
   \   0000004E   0x6408             STR      R0,[R1, #+64]
   \   00000050   0xE003             B.N      ??endstop_triggered_3
   1346            }
   \                     ??endstop_triggered_0: (+1)
   \   00000052   0xEB05 0x0084      ADD      R0,R5,R4, LSL #+2
   \   00000056   0x6901             LDR      R1,[R0, #+16]
   \   00000058   0x6401             STR      R1,[R0, #+64]
   1347            else
   1348            //#else // !COREXY && !COREXZ && !COREYZ
   1349            {
   1350              endstops_trigsteps[axis] = count_position[axis];
   1351            }
   1352            //#endif // !COREXY && !COREXZ && !COREYZ
   1353          
   1354            kill_current_block();
   \                     ??endstop_triggered_3: (+1)
   \   0000005A   0x6A28             LDR      R0,[R5, #+32]
   \   0000005C   0x6940             LDR      R0,[R0, #+20]
   \   0000005E   0x6368             STR      R0,[R5, #+52]
   1355            cleaning_buffer_counter = -1; // Discard the rest of the move
   \   00000060   0xF04F 0x30FF      MOV      R0,#-1
   \   00000064   0x8168             STRH     R0,[R5, #+10]
   1356          }
   \   00000066   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1357          

   \                                 In section .text, align 4, keep-with-next
   1358          void Stepper::report_positions() {
   \                     _ZN7Stepper16report_positionsEv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   1359            CRITICAL_SECTION_START;
   1360            const long xpos = count_position[X_AXIS],
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable21_3
   \   00000008   0x.... 0x....      LDR.W    R8,??DataTable20
   \   0000000C   0xB672             cpsid i
   \   0000000E   0x6907             LDR      R7,[R0, #+16]
   1361                       ypos = count_position[Y_AXIS],
   \   00000010   0x6946             LDR      R6,[R0, #+20]
   1362                       zpos = count_position[Z_AXIS];
   \   00000012   0x6984             LDR      R4,[R0, #+24]
   1363            CRITICAL_SECTION_END;
   \   00000014   0xB662             cpsie i
   1364          
   1365            //#if CORE_IS_XY || CORE_IS_XZ || IS_SCARA
   1366            if(MACHINETPYE&IS_SCARA || MACHINETPYE&CORE_IS_XZ || MACHINETPYE&IS_SCARA)
   \   00000016   0xF9B8 0x0058      LDRSH    R0,[R8, #+88]
   \   0000001A   0xF44F 0x714C      MOV      R1,#+816
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xBF04             ITT      EQ 
   \   00000022   0xF44F 0x7140      MOVEQ    R1,#+768
   \   00000026   0x4208             TSTEQ    R0,R1
   \   00000028   0xD00C             BEQ.N    ??report_positions_0
   1367              {SERIAL_PROTOCOLPGM(MSG_COUNT_A);}
   \   0000002A   0x.... 0x....      ADR.W    R9,`?<Constant " Count A:">`
   \   0000002E   0x.... 0x....      LDR.W    R5,??DataTable21_7
   \                     ??report_positions_1: (+1)
   \   00000032   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   00000036   0x0008             MOVS     R0,R1
   \   00000038   0xD011             BEQ.N    ??report_positions_2
   \   0000003A   0xB2C9             UXTB     R1,R1
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000042   0xE7F6             B.N      ??report_positions_1
   1368            //#else
   1369            else
   1370              {SERIAL_PROTOCOLPGM(MSG_COUNT_X);}
   \                     ??report_positions_0: (+1)
   \   00000044   0x.... 0x....      ADR.W    R9,`?<Constant " Count X:">`
   \   00000048   0x.... 0x....      LDR.W    R5,??DataTable21_7
   \   0000004C   0xE003             B.N      ??report_positions_3
   \                     ??report_positions_4: (+1)
   \   0000004E   0xB2C9             UXTB     R1,R1
   \   00000050   0x4628             MOV      R0,R5
   \   00000052   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??report_positions_3: (+1)
   \   00000056   0xF919 0x1B01      LDRSB    R1,[R9], #+1
   \   0000005A   0x0008             MOVS     R0,R1
   \   0000005C   0xD1F7             BNE.N    ??report_positions_4
   1371            //#endif
   1372            SERIAL_PROTOCOL(xpos);
   \                     ??report_positions_2: (+1)
   \   0000005E   0x220A             MOVS     R2,#+10
   \   00000060   0x4639             MOV      R1,R7
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       _ZN5Print5printEli
   1373          
   1374            //#if CORE_IS_XY || CORE_IS_YZ || IS_SCARA
   1375            if(MACHINETPYE&CORE_IS_XY || MACHINETPYE&CORE_IS_YZ || MACHINETPYE&IS_SCARA)
   \   00000068   0xF8B8 0x0058      LDRH     R0,[R8, #+88]
   \   0000006C   0xF44F 0x7173      MOV      R1,#+972
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xD009             BEQ.N    ??report_positions_5
   1376              {SERIAL_PROTOCOLPGM(" B:");}
   \   00000074   0x....             ADR.N    R7,??DataTable20_8  ;; " B:"
   \                     ??report_positions_6: (+1)
   \   00000076   0xF917 0x1B01      LDRSB    R1,[R7], #+1
   \   0000007A   0x0008             MOVS     R0,R1
   \   0000007C   0xD00E             BEQ.N    ??report_positions_7
   \   0000007E   0xB2C9             UXTB     R1,R1
   \   00000080   0x4628             MOV      R0,R5
   \   00000082   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000086   0xE7F6             B.N      ??report_positions_6
   1377            //#else
   1378            else
   1379              {SERIAL_PROTOCOLPGM(" Y:");}
   \                     ??report_positions_5: (+1)
   \   00000088   0x....             ADR.N    R7,??DataTable20_9  ;; " Y:"
   \   0000008A   0xE003             B.N      ??report_positions_8
   \                     ??report_positions_9: (+1)
   \   0000008C   0xB2C9             UXTB     R1,R1
   \   0000008E   0x4628             MOV      R0,R5
   \   00000090   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??report_positions_8: (+1)
   \   00000094   0xF917 0x1B01      LDRSB    R1,[R7], #+1
   \   00000098   0x0008             MOVS     R0,R1
   \   0000009A   0xD1F7             BNE.N    ??report_positions_9
   1380            //#endif
   1381            SERIAL_PROTOCOL(ypos);
   \                     ??report_positions_7: (+1)
   \   0000009C   0x220A             MOVS     R2,#+10
   \   0000009E   0x4631             MOV      R1,R6
   \   000000A0   0x4628             MOV      R0,R5
   \   000000A2   0x.... 0x....      BL       _ZN5Print5printEli
   1382          
   1383            //#if CORE_IS_XZ || CORE_IS_YZ
   1384            if(MACHINETPYE&CORE_IS_XZ || MACHINETPYE&CORE_IS_YZ)
   \   000000A6   0xF898 0x0058      LDRB     R0,[R8, #+88]
   \   000000AA   0x21F0             MOVS     R1,#+240
   \   000000AC   0x4208             TST      R0,R1
   \   000000AE   0xD009             BEQ.N    ??report_positions_10
   1385              {SERIAL_PROTOCOLPGM(" C:");}
   \   000000B0   0x....             ADR.N    R6,??DataTable20_10  ;; " C:"
   \                     ??report_positions_11: (+1)
   \   000000B2   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   000000B6   0x0008             MOVS     R0,R1
   \   000000B8   0xD00E             BEQ.N    ??report_positions_12
   \   000000BA   0xB2C9             UXTB     R1,R1
   \   000000BC   0x4628             MOV      R0,R5
   \   000000BE   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000C2   0xE7F6             B.N      ??report_positions_11
   1386            //#else
   1387            else
   1388              {SERIAL_PROTOCOLPGM(" Z:");}
   \                     ??report_positions_10: (+1)
   \   000000C4   0x....             ADR.N    R6,??DataTable20_11  ;; " Z:"
   \   000000C6   0xE003             B.N      ??report_positions_13
   \                     ??report_positions_14: (+1)
   \   000000C8   0xB2C9             UXTB     R1,R1
   \   000000CA   0x4628             MOV      R0,R5
   \   000000CC   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??report_positions_13: (+1)
   \   000000D0   0xF916 0x1B01      LDRSB    R1,[R6], #+1
   \   000000D4   0x0008             MOVS     R0,R1
   \   000000D6   0xD1F7             BNE.N    ??report_positions_14
   1389            //#endif
   1390            SERIAL_PROTOCOL(zpos);
   \                     ??report_positions_12: (+1)
   \   000000D8   0x220A             MOVS     R2,#+10
   \   000000DA   0x4621             MOV      R1,R4
   \   000000DC   0x4628             MOV      R0,R5
   \   000000DE   0x.... 0x....      BL       _ZN5Print5printEli
   1391          
   1392            SERIAL_EOL();
   \   000000E2   0x4628             MOV      R0,R5
   \   000000E4   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000E8   0x210A             MOVS     R1,#+10
   \   000000EA   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   1393          }
   1394          
   1395          #if ENABLED(BABYSTEPPING)
   1396          
   1397            #if ENABLED(DELTA)
   1398              #define CYCLES_EATEN_BABYSTEP (2 * 15)
   1399            #else
   1400              #define CYCLES_EATEN_BABYSTEP 0
   1401            #endif
   1402            #define EXTRA_CYCLES_BABYSTEP (STEP_PULSE_CYCLES - (CYCLES_EATEN_BABYSTEP))
   1403          
   1404            #define _ENABLE(AXIS) enable_## AXIS()
   1405            #define _READ_DIR(AXIS) AXIS ##_DIR_READ
   1406            #define _INVERT_DIR(AXIS) INVERT_## AXIS ##_DIR
   1407            #define _APPLY_DIR(AXIS, INVERT) AXIS ##_APPLY_DIR(INVERT, true)
   1408          
   1409            #if EXTRA_CYCLES_BABYSTEP > 20
   1410              #define _SAVE_START const uint32_t pulse_start = TCNT0
   1411              #define _PULSE_WAIT while (EXTRA_CYCLES_BABYSTEP > (uint32_t)(TCNT0 - pulse_start) * (INT0_PRESCALER)) { /* nada */ }
   1412            #else
   1413              #define _SAVE_START NOOP
   1414              #if EXTRA_CYCLES_BABYSTEP > 0
   1415                #define _PULSE_WAIT DELAY_NOPS(EXTRA_CYCLES_BABYSTEP)
   1416              #elif STEP_PULSE_CYCLES > 0
   1417                #define _PULSE_WAIT NOOP
   1418              #elif ENABLED(DELTA)
   1419                #define _PULSE_WAIT NOOP//for(uint8_t i=0;i<=255;i++)//HAL_Delay(2);//delayMicroseconds(2);
   1420              #else
   1421                #define _PULSE_WAIT NOOP//for(uint8_t i=0;i<=255;i++)//HAL_Delay(4);//delayMicroseconds(4);
   1422              #endif
   1423            #endif
   1424          
   1425            #define BABYSTEP_AXIS(AXIS, INVERT) {                     \
   1426                const uint8_t old_dir = _READ_DIR(AXIS);              \
   1427                _ENABLE(AXIS);                                        \
   1428                _SAVE_START;                                          \
   1429                _APPLY_DIR(AXIS, (GPIO_PinState)(_INVERT_DIR(AXIS)^direction^INVERT)); \
   1430                _APPLY_STEP(AXIS)(!_INVERT_STEP_PIN(AXIS), true);     \
   1431                _PULSE_WAIT;                                          \
   1432                _APPLY_STEP(AXIS)(_INVERT_STEP_PIN(AXIS), true);      \
   1433                _APPLY_DIR(AXIS, (GPIO_PinState)old_dir);                            \
   1434              }
   1435          
   1436            // MUST ONLY BE CALLED BY AN ISR,
   1437            // No other ISR should ever interrupt this!

   \                                 In section .text, align 4, keep-with-next
   1438            void Stepper::babystep(const AxisEnum axis, const bool direction) {
   \                     _ZN7Stepper8babystepE8AxisEnumb: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x460C             MOV      R4,R1
   1439              cli();
   \   00000006   0xB672             cpsid i
   1440          
   1441              switch (axis) {
   \   00000008   0xB118             CBZ.N    R0,??babystep_0
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD04D             BEQ.N    ??babystep_1
   \   0000000E   0xD326             BCC.N    ??babystep_2
   \   00000010   0xE194             B.N      ??babystep_3
   1442          
   1443                #if ENABLED(BABYSTEP_XY)
   1444          
   1445                  case X_AXIS:
   1446                    BABYSTEP_AXIS(X, false);
   \                     ??babystep_0: (+1)
   \   00000012   0x....             LDR.N    R5,??DataTable21_8
   \   00000014   0x....             LDR.N    R6,??DataTable21_9
   \   00000016   0x6828             LDR      R0,[R5, #+0]
   \   00000018   0x8831             LDRH     R1,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000001E   0x.... 0x....      LDR.W    R9,??DataTable21_4
   \   00000022   0x88B1             LDRH     R1,[R6, #+4]
   \   00000024   0xF999 0x2104      LDRSB    R2,[R9, #+260]
   \   00000028   0x4607             MOV      R7,R0
   \   0000002A   0x68A8             LDR      R0,[R5, #+8]
   \   0000002C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000030   0xF999 0x0000      LDRSB    R0,[R9, #+0]
   \   00000034   0x8831             LDRH     R1,[R6, #+0]
   \   00000036   0xEA84 0x0200      EOR      R2,R4,R0
   \   0000003A   0x6828             LDR      R0,[R5, #+0]
   \   0000003C   0xB252             SXTB     R2,R2
   \   0000003E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000042   0x8871             LDRH     R1,[R6, #+2]
   \   00000044   0x6868             LDR      R0,[R5, #+4]
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000004C   0x8871             LDRH     R1,[R6, #+2]
   \   0000004E   0x6868             LDR      R0,[R5, #+4]
   \   00000050   0x2200             MOVS     R2,#+0
   \   00000052   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000056   0x8831             LDRH     R1,[R6, #+0]
   \   00000058   0x6828             LDR      R0,[R5, #+0]
   \   0000005A   0x463A             MOV      R2,R7
   \   0000005C   0xE16C             B.N      ??babystep_4
   1447                    break;
   1448          
   1449                  case Y_AXIS:
   1450                    BABYSTEP_AXIS(Y, false);
   \                     ??babystep_2: (+1)
   \   0000005E   0x....             LDR.N    R5,??DataTable21_8
   \   00000060   0x....             LDR.N    R6,??DataTable21_9
   \   00000062   0x6968             LDR      R0,[R5, #+20]
   \   00000064   0x8971             LDRH     R1,[R6, #+10]
   \   00000066   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000006A   0x.... 0x....      LDR.W    R9,??DataTable21_4
   \   0000006E   0x89F1             LDRH     R1,[R6, #+14]
   \   00000070   0xF999 0x2105      LDRSB    R2,[R9, #+261]
   \   00000074   0x4607             MOV      R7,R0
   \   00000076   0x69E8             LDR      R0,[R5, #+28]
   \   00000078   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007C   0xF999 0x0001      LDRSB    R0,[R9, #+1]
   \   00000080   0x8971             LDRH     R1,[R6, #+10]
   \   00000082   0xEA84 0x0200      EOR      R2,R4,R0
   \   00000086   0x6968             LDR      R0,[R5, #+20]
   \   00000088   0xB252             SXTB     R2,R2
   \   0000008A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000008E   0x89B1             LDRH     R1,[R6, #+12]
   \   00000090   0x69A8             LDR      R0,[R5, #+24]
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000098   0x89B1             LDRH     R1,[R6, #+12]
   \   0000009A   0x69A8             LDR      R0,[R5, #+24]
   \   0000009C   0x2200             MOVS     R2,#+0
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000A2   0x8971             LDRH     R1,[R6, #+10]
   \   000000A4   0x6968             LDR      R0,[R5, #+20]
   \   000000A6   0x463A             MOV      R2,R7
   \   000000A8   0xE146             B.N      ??babystep_4
   1451                    break;
   1452          
   1453                #endif
   1454          
   1455                case Z_AXIS: {
   1456          
   1457                  //#if DISABLED(DELTA)
   1458          	if(MACHINETPYE != DELTA)
   \                     ??babystep_1: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R9,??DataTable21_4
   \   000000AE   0x....             LDR.N    R5,??DataTable21_8
   \   000000B0   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   000000B4   0x....             LDR.N    R6,??DataTable21_9
   \   000000B6   0x2802             CMP      R0,#+2
   \   000000B8   0xF000 0x80D1      BEQ.W    ??babystep_5
   1459          	{
   1460          
   1461                    BABYSTEP_AXIS(Z, BABYSTEP_INVERT_Z);
   \   000000BC   0x8AB1             LDRH     R1,[R6, #+20]
   \   000000BE   0x6AA8             LDR      R0,[R5, #+40]
   \   000000C0   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000C4   0xF999 0x2106      LDRSB    R2,[R9, #+262]
   \   000000C8   0x8B31             LDRH     R1,[R6, #+24]
   \   000000CA   0xFA5F 0xF880      UXTB     R8,R0
   \   000000CE   0x6B28             LDR      R0,[R5, #+48]
   \   000000D0   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000D4   0xF999 0x2106      LDRSB    R2,[R9, #+262]
   \   000000D8   0x8D31             LDRH     R1,[R6, #+40]
   \   000000DA   0x6D28             LDR      R0,[R5, #+80]
   \   000000DC   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000E0   0xF999 0x0002      LDRSB    R0,[R9, #+2]
   \   000000E4   0x8AB1             LDRH     R1,[R6, #+20]
   \   000000E6   0xEA84 0x0200      EOR      R2,R4,R0
   \   000000EA   0x6AA8             LDR      R0,[R5, #+40]
   \   000000EC   0xB252             SXTB     R2,R2
   \   000000EE   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000F2   0xF899 0x0101      LDRB     R0,[R9, #+257]
   \   000000F6   0x2801             CMP      R0,#+1
   \   000000F8   0xD108             BNE.N    ??babystep_6
   \   000000FA   0xF999 0x0002      LDRSB    R0,[R9, #+2]
   \   000000FE   0x8CB1             LDRH     R1,[R6, #+36]
   \   00000100   0xEA84 0x0200      EOR      R2,R4,R0
   \   00000104   0x6CA8             LDR      R0,[R5, #+72]
   \   00000106   0xB252             SXTB     R2,R2
   \   00000108   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_6: (+1)
   \   0000010C   0xF899 0x0102      LDRB     R0,[R9, #+258]
   \   00000110   0x2801             CMP      R0,#+1
   \   00000112   0xD13A             BNE.N    ??babystep_7
   \   00000114   0x....             LDR.N    R4,??DataTable21_3
   \   00000116   0x7920             LDRB     R0,[R4, #+4]
   \   00000118   0xB388             CBZ.N    R0,??babystep_8
   \   0000011A   0x....             LDR.N    R7,??DataTable21_10
   \   0000011C   0xF999 0x1007      LDRSB    R1,[R9, #+7]
   \   00000120   0x8838             LDRH     R0,[R7, #+0]
   \   00000122   0x2900             CMP      R1,#+0
   \   00000124   0xD514             BPL.N    ??babystep_9
   \   00000126   0x0740             LSLS     R0,R0,#+29
   \   00000128   0xBF44             ITT      MI 
   \   0000012A   0xF994 0x0002      LDRSBMI  R0,[R4, #+2]
   \   0000012E   0x2800             CMPMI    R0,#+0
   \   00000130   0xD406             BMI.N    ??babystep_10
   \   00000132   0x79A0             LDRB     R0,[R4, #+6]
   \   00000134   0xB920             CBNZ.N   R0,??babystep_10
   \   00000136   0x8AF1             LDRH     R1,[R6, #+22]
   \   00000138   0x6AE8             LDR      R0,[R5, #+44]
   \   0000013A   0x2201             MOVS     R2,#+1
   \   0000013C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_10: (+1)
   \   00000140   0x8838             LDRH     R0,[R7, #+0]
   \   00000142   0x0500             LSLS     R0,R0,#+20
   \   00000144   0xD518             BPL.N    ??babystep_11
   \   00000146   0xF994 0x0002      LDRSB    R0,[R4, #+2]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD42B             BMI.N    ??babystep_12
   \   0000014E   0xE013             B.N      ??babystep_11
   \                     ??babystep_9: (+1)
   \   00000150   0x0640             LSLS     R0,R0,#+25
   \   00000152   0xD503             BPL.N    ??babystep_13
   \   00000154   0xF994 0x0002      LDRSB    R0,[R4, #+2]
   \   00000158   0x2801             CMP      R0,#+1
   \   0000015A   0xDA06             BGE.N    ??babystep_14
   \                     ??babystep_13: (+1)
   \   0000015C   0x79A0             LDRB     R0,[R4, #+6]
   \   0000015E   0xB920             CBNZ.N   R0,??babystep_14
   \   00000160   0x8AF1             LDRH     R1,[R6, #+22]
   \   00000162   0x6AE8             LDR      R0,[R5, #+44]
   \   00000164   0x2201             MOVS     R2,#+1
   \   00000166   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_14: (+1)
   \   0000016A   0x8838             LDRH     R0,[R7, #+0]
   \   0000016C   0x04C0             LSLS     R0,R0,#+19
   \   0000016E   0xD503             BPL.N    ??babystep_11
   \   00000170   0xF994 0x0002      LDRSB    R0,[R4, #+2]
   \   00000174   0x2801             CMP      R0,#+1
   \   00000176   0xDA16             BGE.N    ??babystep_12
   \                     ??babystep_11: (+1)
   \   00000178   0x79E0             LDRB     R0,[R4, #+7]
   \   0000017A   0xB9A0             CBNZ.N   R0,??babystep_12
   \   0000017C   0xE00E             B.N      ??babystep_15
   \                     ??babystep_8: (+1)
   \   0000017E   0x8AF1             LDRH     R1,[R6, #+22]
   \   00000180   0x6AE8             LDR      R0,[R5, #+44]
   \   00000182   0x2201             MOVS     R2,#+1
   \   00000184   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000188   0xE008             B.N      ??babystep_15
   \                     ??babystep_7: (+1)
   \   0000018A   0x8AF1             LDRH     R1,[R6, #+22]
   \   0000018C   0x6AE8             LDR      R0,[R5, #+44]
   \   0000018E   0x2201             MOVS     R2,#+1
   \   00000190   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000194   0xF899 0x0101      LDRB     R0,[R9, #+257]
   \   00000198   0x2801             CMP      R0,#+1
   \   0000019A   0xD104             BNE.N    ??babystep_12
   \                     ??babystep_15: (+1)
   \   0000019C   0x8CF1             LDRH     R1,[R6, #+38]
   \   0000019E   0x6CE8             LDR      R0,[R5, #+76]
   \   000001A0   0x2201             MOVS     R2,#+1
   \   000001A2   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_12: (+1)
   \   000001A6   0xF899 0x0102      LDRB     R0,[R9, #+258]
   \   000001AA   0x2801             CMP      R0,#+1
   \   000001AC   0xD13A             BNE.N    ??babystep_16
   \   000001AE   0x....             LDR.N    R4,??DataTable21_3
   \   000001B0   0x7920             LDRB     R0,[R4, #+4]
   \   000001B2   0xB388             CBZ.N    R0,??babystep_17
   \   000001B4   0x....             LDR.N    R7,??DataTable21_10
   \   000001B6   0xF999 0x1007      LDRSB    R1,[R9, #+7]
   \   000001BA   0x8838             LDRH     R0,[R7, #+0]
   \   000001BC   0x2900             CMP      R1,#+0
   \   000001BE   0xD514             BPL.N    ??babystep_18
   \   000001C0   0x0740             LSLS     R0,R0,#+29
   \   000001C2   0xBF44             ITT      MI 
   \   000001C4   0xF994 0x0002      LDRSBMI  R0,[R4, #+2]
   \   000001C8   0x2800             CMPMI    R0,#+0
   \   000001CA   0xD406             BMI.N    ??babystep_19
   \   000001CC   0x79A0             LDRB     R0,[R4, #+6]
   \   000001CE   0xB920             CBNZ.N   R0,??babystep_19
   \   000001D0   0x8AF1             LDRH     R1,[R6, #+22]
   \   000001D2   0x6AE8             LDR      R0,[R5, #+44]
   \   000001D4   0x2200             MOVS     R2,#+0
   \   000001D6   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_19: (+1)
   \   000001DA   0x8838             LDRH     R0,[R7, #+0]
   \   000001DC   0x0500             LSLS     R0,R0,#+20
   \   000001DE   0xD518             BPL.N    ??babystep_20
   \   000001E0   0xF994 0x0002      LDRSB    R0,[R4, #+2]
   \   000001E4   0x2800             CMP      R0,#+0
   \   000001E6   0xD42B             BMI.N    ??babystep_21
   \   000001E8   0xE013             B.N      ??babystep_20
   \                     ??babystep_18: (+1)
   \   000001EA   0x0640             LSLS     R0,R0,#+25
   \   000001EC   0xD503             BPL.N    ??babystep_22
   \   000001EE   0xF994 0x0002      LDRSB    R0,[R4, #+2]
   \   000001F2   0x2801             CMP      R0,#+1
   \   000001F4   0xDA06             BGE.N    ??babystep_23
   \                     ??babystep_22: (+1)
   \   000001F6   0x79A0             LDRB     R0,[R4, #+6]
   \   000001F8   0xB920             CBNZ.N   R0,??babystep_23
   \   000001FA   0x8AF1             LDRH     R1,[R6, #+22]
   \   000001FC   0x6AE8             LDR      R0,[R5, #+44]
   \   000001FE   0x2200             MOVS     R2,#+0
   \   00000200   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_23: (+1)
   \   00000204   0x8838             LDRH     R0,[R7, #+0]
   \   00000206   0x04C0             LSLS     R0,R0,#+19
   \   00000208   0xD503             BPL.N    ??babystep_20
   \   0000020A   0xF994 0x0002      LDRSB    R0,[R4, #+2]
   \   0000020E   0x2801             CMP      R0,#+1
   \   00000210   0xDA16             BGE.N    ??babystep_21
   \                     ??babystep_20: (+1)
   \   00000212   0x79E0             LDRB     R0,[R4, #+7]
   \   00000214   0xB9A0             CBNZ.N   R0,??babystep_21
   \   00000216   0xE00E             B.N      ??babystep_24
   \                     ??babystep_17: (+1)
   \   00000218   0x8AF1             LDRH     R1,[R6, #+22]
   \   0000021A   0x6AE8             LDR      R0,[R5, #+44]
   \   0000021C   0x2200             MOVS     R2,#+0
   \   0000021E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000222   0xE008             B.N      ??babystep_24
   \                     ??babystep_16: (+1)
   \   00000224   0x8AF1             LDRH     R1,[R6, #+22]
   \   00000226   0x6AE8             LDR      R0,[R5, #+44]
   \   00000228   0x2200             MOVS     R2,#+0
   \   0000022A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000022E   0xF899 0x0101      LDRB     R0,[R9, #+257]
   \   00000232   0x2801             CMP      R0,#+1
   \   00000234   0xD104             BNE.N    ??babystep_21
   \                     ??babystep_24: (+1)
   \   00000236   0x8CF1             LDRH     R1,[R6, #+38]
   \   00000238   0x6CE8             LDR      R0,[R5, #+76]
   \   0000023A   0x2200             MOVS     R2,#+0
   \   0000023C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \                     ??babystep_21: (+1)
   \   00000240   0x8AB1             LDRH     R1,[R6, #+20]
   \   00000242   0x6AA8             LDR      R0,[R5, #+40]
   \   00000244   0xFA4F 0xF288      SXTB     R2,R8
   \   00000248   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000024C   0xF899 0x0101      LDRB     R0,[R9, #+257]
   \   00000250   0x2801             CMP      R0,#+1
   \   00000252   0xD173             BNE.N    ??babystep_3
   \   00000254   0x8CB1             LDRH     R1,[R6, #+36]
   \   00000256   0x6CA8             LDR      R0,[R5, #+72]
   \   00000258   0xFA4F 0xF288      SXTB     R2,R8
   \   0000025C   0xE06C             B.N      ??babystep_4
   1462          	}
   1463                  //#else // DELTA
   1464          	else
   1465          	{
   1466                    const bool z_direction = direction ^ BABYSTEP_INVERT_Z;
   1467          
   1468                    enable_X();
   \                     ??babystep_5: (+1)
   \   0000025E   0xF999 0x2104      LDRSB    R2,[R9, #+260]
   \   00000262   0x88B1             LDRH     R1,[R6, #+4]
   \   00000264   0x68A8             LDR      R0,[R5, #+8]
   \   00000266   0x.... 0x....      BL       HAL_GPIO_WritePin
   1469                    enable_Y();
   \   0000026A   0xF999 0x2105      LDRSB    R2,[R9, #+261]
   \   0000026E   0x89F1             LDRH     R1,[R6, #+14]
   \   00000270   0x69E8             LDR      R0,[R5, #+28]
   \   00000272   0x.... 0x....      BL       HAL_GPIO_WritePin
   1470                    enable_Z();
   \   00000276   0xF999 0x2106      LDRSB    R2,[R9, #+262]
   \   0000027A   0x8B31             LDRH     R1,[R6, #+24]
   \   0000027C   0x6B28             LDR      R0,[R5, #+48]
   \   0000027E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000282   0xF999 0x2106      LDRSB    R2,[R9, #+262]
   \   00000286   0x8D31             LDRH     R1,[R6, #+40]
   \   00000288   0x6D28             LDR      R0,[R5, #+80]
   \   0000028A   0x.... 0x....      BL       HAL_GPIO_WritePin
   1471          
   1472                    const uint8_t old_x_dir_pin = X_DIR_READ,
   \   0000028E   0x8831             LDRH     R1,[R6, #+0]
   \   00000290   0x6828             LDR      R0,[R5, #+0]
   \   00000292   0x.... 0x....      BL       HAL_GPIO_ReadPin
   1473                                  old_y_dir_pin = Y_DIR_READ,
   \   00000296   0x8971             LDRH     R1,[R6, #+10]
   \   00000298   0x4680             MOV      R8,R0
   \   0000029A   0x6968             LDR      R0,[R5, #+20]
   \   0000029C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   1474                                  old_z_dir_pin = Z_DIR_READ;
   \   000002A0   0x8AB1             LDRH     R1,[R6, #+20]
   \   000002A2   0x4607             MOV      R7,R0
   \   000002A4   0x6AA8             LDR      R0,[R5, #+40]
   \   000002A6   0x.... 0x....      BL       HAL_GPIO_ReadPin
   1475          
   1476                    X_DIR_WRITE((GPIO_PinState)(INVERT_X_DIR ^ z_direction));
   \   000002AA   0x8831             LDRH     R1,[R6, #+0]
   \   000002AC   0x4682             MOV      R10,R0
   \   000002AE   0xF999 0x0000      LDRSB    R0,[R9, #+0]
   \   000002B2   0xEA84 0x0200      EOR      R2,R4,R0
   \   000002B6   0x6828             LDR      R0,[R5, #+0]
   \   000002B8   0xB252             SXTB     R2,R2
   \   000002BA   0x.... 0x....      BL       HAL_GPIO_WritePin
   1477                    Y_DIR_WRITE((GPIO_PinState)(INVERT_Y_DIR ^ z_direction));
   \   000002BE   0xF999 0x0001      LDRSB    R0,[R9, #+1]
   \   000002C2   0x8971             LDRH     R1,[R6, #+10]
   \   000002C4   0xEA84 0x0200      EOR      R2,R4,R0
   \   000002C8   0x6968             LDR      R0,[R5, #+20]
   \   000002CA   0xB252             SXTB     R2,R2
   \   000002CC   0x.... 0x....      BL       HAL_GPIO_WritePin
   1478                    Z_DIR_WRITE((GPIO_PinState)(INVERT_Z_DIR ^ z_direction));
   \   000002D0   0xF999 0x0002      LDRSB    R0,[R9, #+2]
   \   000002D4   0x8AB1             LDRH     R1,[R6, #+20]
   \   000002D6   0xEA84 0x0200      EOR      R2,R4,R0
   \   000002DA   0x6AA8             LDR      R0,[R5, #+40]
   \   000002DC   0xB252             SXTB     R2,R2
   \   000002DE   0x.... 0x....      BL       HAL_GPIO_WritePin
   1479          
   1480                    _SAVE_START;
   1481          
   1482                    X_STEP_WRITE(!INVERT_X_STEP_PIN);
   \   000002E2   0x8871             LDRH     R1,[R6, #+2]
   \   000002E4   0x6868             LDR      R0,[R5, #+4]
   \   000002E6   0x2201             MOVS     R2,#+1
   \   000002E8   0x.... 0x....      BL       HAL_GPIO_WritePin
   1483                    Y_STEP_WRITE(!INVERT_Y_STEP_PIN);
   \   000002EC   0x89B1             LDRH     R1,[R6, #+12]
   \   000002EE   0x69A8             LDR      R0,[R5, #+24]
   \   000002F0   0x2201             MOVS     R2,#+1
   \   000002F2   0x.... 0x....      BL       HAL_GPIO_WritePin
   1484                    Z_STEP_WRITE(!INVERT_Z_STEP_PIN);
   \   000002F6   0x8AF1             LDRH     R1,[R6, #+22]
   \   000002F8   0x6AE8             LDR      R0,[R5, #+44]
   \   000002FA   0x2201             MOVS     R2,#+1
   \   000002FC   0x.... 0x....      BL       HAL_GPIO_WritePin
   1485          
   1486                    _PULSE_WAIT;
   1487          
   1488                    X_STEP_WRITE(INVERT_X_STEP_PIN);
   \   00000300   0x8871             LDRH     R1,[R6, #+2]
   \   00000302   0x6868             LDR      R0,[R5, #+4]
   \   00000304   0x2200             MOVS     R2,#+0
   \   00000306   0x.... 0x....      BL       HAL_GPIO_WritePin
   1489                    Y_STEP_WRITE(INVERT_Y_STEP_PIN);
   \   0000030A   0x89B1             LDRH     R1,[R6, #+12]
   \   0000030C   0x69A8             LDR      R0,[R5, #+24]
   \   0000030E   0x2200             MOVS     R2,#+0
   \   00000310   0x.... 0x....      BL       HAL_GPIO_WritePin
   1490                    Z_STEP_WRITE(INVERT_Z_STEP_PIN);
   \   00000314   0x8AF1             LDRH     R1,[R6, #+22]
   \   00000316   0x6AE8             LDR      R0,[R5, #+44]
   \   00000318   0x2200             MOVS     R2,#+0
   \   0000031A   0x.... 0x....      BL       HAL_GPIO_WritePin
   1491          
   1492                    // Restore direction bits
   1493                    X_DIR_WRITE(old_x_dir_pin);
   \   0000031E   0x8831             LDRH     R1,[R6, #+0]
   \   00000320   0x6828             LDR      R0,[R5, #+0]
   \   00000322   0x4642             MOV      R2,R8
   \   00000324   0x.... 0x....      BL       HAL_GPIO_WritePin
   1494                    Y_DIR_WRITE(old_y_dir_pin);
   \   00000328   0x8971             LDRH     R1,[R6, #+10]
   \   0000032A   0x6968             LDR      R0,[R5, #+20]
   \   0000032C   0x463A             MOV      R2,R7
   \   0000032E   0x.... 0x....      BL       HAL_GPIO_WritePin
   1495                    Z_DIR_WRITE(old_z_dir_pin);
   \   00000332   0x8AB1             LDRH     R1,[R6, #+20]
   \   00000334   0x6AA8             LDR      R0,[R5, #+40]
   \   00000336   0x4652             MOV      R2,R10
   \                     ??babystep_4: (+1)
   \   00000338   0x.... 0x....      BL       HAL_GPIO_WritePin
   1496          
   1497                  //#endif
   1498          	}
   1499          
   1500                } break;
   1501          
   1502                default: break;
   1503              }
   1504              sei();
   \                     ??babystep_3: (+1)
   \   0000033C   0xB662             cpsie i
   1505            }
   \   0000033E   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M84 X Y Z E">`:
   \   00000000   0x4D 0x38          DC8 "M84 X Y Z E"
   \              0x34 0x20    
   \              0x58 0x20    
   \              0x59 0x20    
   \              0x5A 0x20    
   \              0x45 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x........         DC32     _ZN7Stepper15count_directionE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_1:
   \   00000000   0x........         DC32     htim4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_2:
   \   00000000   0x........         DC32     htim2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_3:
   \   00000000   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_4:
   \   00000000   0x........         DC32     _ZN8Endstops15z_probe_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_5:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_tailE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_6:
   \   00000000   0x........         DC32     _ZN7Planner17block_buffer_headE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_7:
   \   00000000   0x........         DC32     _ZN7Planner12block_bufferE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_8:
   \   00000000   0x20 0x42          DC8      " B:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_9:
   \   00000000   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_10:
   \   00000000   0x20 0x43          DC8      " C:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_11:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_12:
   \   00000000   0x........         DC32     _ZZN7Stepper25trapezoid_generator_resetEvE13last_extruder

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_13:
   \   00000000   0x........         DC32     _ZN8Endstops16old_endstop_bitsE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_14:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable20_15:
   \   00000000   0x........         DC32     mksCfg+0x101

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   0x........         DC32     _ZN11Temperature11in_temp_isrE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_1:
   \   00000000   0x........         DC32     endstops

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_2:
   \   00000000   0x........         DC32     axis_known_position

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_3:
   \   00000000   0x........         DC32     _ZN7Stepper15count_directionE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_4:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_5:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_6:
   \   00000000   0x........         DC32     _ZN7Planner11steps_to_mmE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_7:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_8:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_9:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable21_10:
   \   00000000   0x........         DC32     _ZN8Endstops16old_endstop_bitsE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Count A:">`:
   \   00000000   0x20 0x43          DC8 " Count A:"
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x20 0x41    
   \              0x3A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Count X:">`:
   \   00000000   0x20 0x43          DC8 " Count X:"
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x20 0x58    
   \              0x3A 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " B:">`:
   \   00000000   0x20 0x42          DC8 " B:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y:">`:
   \   00000000   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " C:">`:
   \   00000000   0x20 0x43          DC8 " C:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    
   1506          
   1507          #endif // BABYSTEPPING
   1508          
   1509          /**
   1510           * Software-controlled Stepper Motor Current
   1511           */
   1512          
   1513          #if HAS_DIGIPOTSS
   1514          
   1515            // From Arduino DigitalPotControl example
   1516            void Stepper::digitalPotWrite(const int16_t address, const int16_t value) {
   1517              WRITE(DIGIPOTSS_PIN, LOW);  // Take the SS pin low to select the chip
   1518              SPI.transfer(address);      // Send the address and value via SPI
   1519              SPI.transfer(value);
   1520              WRITE(DIGIPOTSS_PIN, HIGH); // Take the SS pin high to de-select the chip
   1521              //delay(10);
   1522            }
   1523          
   1524          #endif // HAS_DIGIPOTSS
   1525          
   1526          #if HAS_MOTOR_CURRENT_PWM
   1527          
   1528            void Stepper::refresh_motor_power() {
   1529              for (uint8_t i = 0; i < COUNT(motor_current_setting); ++i) {
   1530                switch (i) {
   1531                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
   1532                    case 0:
   1533                  #endif
   1534                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
   1535                    case 1:
   1536                  #endif
   1537                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
   1538                    case 2:
   1539                  #endif
   1540                      digipot_current(i, motor_current_setting[i]);
   1541                  default: break;
   1542                }
   1543              }
   1544            }
   1545          
   1546          #endif // HAS_MOTOR_CURRENT_PWM
   1547          
   1548          #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
   1549          
   1550            void Stepper::digipot_current(const uint8_t driver, const int current) {
   1551          
   1552              #if HAS_DIGIPOTSS
   1553          
   1554                const uint8_t digipot_ch[] = DIGIPOT_CHANNELS;
   1555                digitalPotWrite(digipot_ch[driver], current);
   1556          
   1557              #elif HAS_MOTOR_CURRENT_PWM
   1558          
   1559                if (WITHIN(driver, 0, 2))
   1560                  motor_current_setting[driver] = current; // update motor_current_setting
   1561          
   1562                #define _WRITE_CURRENT_PWM(P) analogWrite(MOTOR_CURRENT_PWM_## P ##_PIN, 255L * current / (MOTOR_CURRENT_PWM_RANGE))
   1563                switch (driver) {
   1564                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
   1565                    case 0: _WRITE_CURRENT_PWM(XY); break;
   1566                  #endif
   1567                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
   1568                    case 1: _WRITE_CURRENT_PWM(Z); break;
   1569                  #endif
   1570                  #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
   1571                    case 2: _WRITE_CURRENT_PWM(E); break;
   1572                  #endif
   1573                }
   1574              #endif
   1575            }
   1576          
   1577            void Stepper::digipot_init() {
   1578          
   1579              #if HAS_DIGIPOTSS
   1580          
   1581                static const uint8_t digipot_motor_current[] = DIGIPOT_MOTOR_CURRENT;
   1582          
   1583                SPI.begin();
   1584                SET_OUTPUT(DIGIPOTSS_PIN);
   1585          
   1586                for (uint8_t i = 0; i < COUNT(digipot_motor_current); i++) {
   1587                  //digitalPotWrite(digipot_ch[i], digipot_motor_current[i]);
   1588                  digipot_current(i, digipot_motor_current[i]);
   1589                }
   1590          
   1591              #elif HAS_MOTOR_CURRENT_PWM
   1592          
   1593                #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
   1594                  SET_OUTPUT(MOTOR_CURRENT_PWM_XY_PIN);
   1595                #endif
   1596                #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
   1597                  SET_OUTPUT(MOTOR_CURRENT_PWM_Z_PIN);
   1598                #endif
   1599                #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
   1600                  SET_OUTPUT(MOTOR_CURRENT_PWM_E_PIN);
   1601                #endif
   1602          
   1603                refresh_motor_power();
   1604          
   1605                // Set Timer5 to 31khz so the PWM of the motor power is as constant as possible. (removes a buzzing noise)
   1606                SET_CS5(PRESCALER_1);
   1607          
   1608              #endif
   1609            }
   1610          
   1611          #endif
   1612          
   1613          #if HAS_MICROSTEPS
   1614          
   1615            /**
   1616             * Software-controlled Microstepping
   1617             */
   1618          
   1619            void Stepper::microstep_init() {
   1620              SET_OUTPUT(X_MS1_PIN);
   1621              SET_OUTPUT(X_MS2_PIN);
   1622              #if HAS_Y_MICROSTEPS
   1623                SET_OUTPUT(Y_MS1_PIN);
   1624                SET_OUTPUT(Y_MS2_PIN);
   1625              #endif
   1626              #if HAS_Z_MICROSTEPS
   1627                SET_OUTPUT(Z_MS1_PIN);
   1628                SET_OUTPUT(Z_MS2_PIN);
   1629              #endif
   1630              #if HAS_E0_MICROSTEPS
   1631                SET_OUTPUT(E0_MS1_PIN);
   1632                SET_OUTPUT(E0_MS2_PIN);
   1633              #endif
   1634              #if HAS_E1_MICROSTEPS
   1635                SET_OUTPUT(E1_MS1_PIN);
   1636                SET_OUTPUT(E1_MS2_PIN);
   1637              #endif
   1638              #if HAS_E2_MICROSTEPS
   1639                SET_OUTPUT(E2_MS1_PIN);
   1640                SET_OUTPUT(E2_MS2_PIN);
   1641              #endif
   1642              #if HAS_E3_MICROSTEPS
   1643                SET_OUTPUT(E3_MS1_PIN);
   1644                SET_OUTPUT(E3_MS2_PIN);
   1645              #endif
   1646              #if HAS_E4_MICROSTEPS
   1647                SET_OUTPUT(E4_MS1_PIN);
   1648                SET_OUTPUT(E4_MS2_PIN);
   1649              #endif
   1650              static const uint8_t microstep_modes[] = MICROSTEP_MODES;
   1651              for (uint16_t i = 0; i < COUNT(microstep_modes); i++)
   1652                microstep_mode(i, microstep_modes[i]);
   1653            }
   1654          
   1655            void Stepper::microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2) {
   1656              if (ms1 >= 0) switch (driver) {
   1657                case 0: WRITE(X_MS1_PIN, ms1); break;
   1658                #if HAS_Y_MICROSTEPS
   1659                  case 1: WRITE(Y_MS1_PIN, ms1); break;
   1660                #endif
   1661                #if HAS_Z_MICROSTEPS
   1662                  case 2: WRITE(Z_MS1_PIN, ms1); break;
   1663                #endif
   1664                #if HAS_E0_MICROSTEPS
   1665                  case 3: WRITE(E0_MS1_PIN, ms1); break;
   1666                #endif
   1667                #if HAS_E1_MICROSTEPS
   1668                  case 4: WRITE(E1_MS1_PIN, ms1); break;
   1669                #endif
   1670                #if HAS_E2_MICROSTEPS
   1671                  case 5: WRITE(E2_MS1_PIN, ms1); break;
   1672                #endif
   1673                #if HAS_E3_MICROSTEPS
   1674                  case 6: WRITE(E3_MS1_PIN, ms1); break;
   1675                #endif
   1676                #if HAS_E4_MICROSTEPS
   1677                  case 7: WRITE(E4_MS1_PIN, ms1); break;
   1678                #endif
   1679              }
   1680              if (ms2 >= 0) switch (driver) {
   1681                case 0: WRITE(X_MS2_PIN, ms2); break;
   1682                #if HAS_Y_MICROSTEPS
   1683                  case 1: WRITE(Y_MS2_PIN, ms2); break;
   1684                #endif
   1685                #if HAS_Z_MICROSTEPS
   1686                  case 2: WRITE(Z_MS2_PIN, ms2); break;
   1687                #endif
   1688                #if HAS_E0_MICROSTEPS
   1689                  case 3: WRITE(E0_MS2_PIN, ms2); break;
   1690                #endif
   1691                #if HAS_E1_MICROSTEPS
   1692                  case 4: WRITE(E1_MS2_PIN, ms2); break;
   1693                #endif
   1694                #if HAS_E2_MICROSTEPS
   1695                  case 5: WRITE(E2_MS2_PIN, ms2); break;
   1696                #endif
   1697                #if HAS_E3_MICROSTEPS
   1698                  case 6: WRITE(E3_MS2_PIN, ms2); break;
   1699                #endif
   1700                #if HAS_E4_MICROSTEPS
   1701                  case 7: WRITE(E4_MS2_PIN, ms2); break;
   1702                #endif
   1703              }
   1704            }
   1705          
   1706            void Stepper::microstep_mode(const uint8_t driver, const uint8_t stepping_mode) {
   1707              switch (stepping_mode) {
   1708                case 1: microstep_ms(driver, MICROSTEP1); break;
   1709                case 2: microstep_ms(driver, MICROSTEP2); break;
   1710                case 4: microstep_ms(driver, MICROSTEP4); break;
   1711                case 8: microstep_ms(driver, MICROSTEP8); break;
   1712                case 16: microstep_ms(driver, MICROSTEP16); break;
   1713              }
   1714            }
   1715          
   1716            void Stepper::microstep_readings() {
   1717              SERIAL_PROTOCOLLNPGM("MS1,MS2 Pins");
   1718              SERIAL_PROTOCOLPGM("X: ");
   1719              SERIAL_PROTOCOL(READ(X_MS1_PIN));
   1720              SERIAL_PROTOCOLLN(READ(X_MS2_PIN));
   1721              #if HAS_Y_MICROSTEPS
   1722                SERIAL_PROTOCOLPGM("Y: ");
   1723                SERIAL_PROTOCOL(READ(Y_MS1_PIN));
   1724                SERIAL_PROTOCOLLN(READ(Y_MS2_PIN));
   1725              #endif
   1726              #if HAS_Z_MICROSTEPS
   1727                SERIAL_PROTOCOLPGM("Z: ");
   1728                SERIAL_PROTOCOL(READ(Z_MS1_PIN));
   1729                SERIAL_PROTOCOLLN(READ(Z_MS2_PIN));
   1730              #endif
   1731              #if HAS_E0_MICROSTEPS
   1732                SERIAL_PROTOCOLPGM("E0: ");
   1733                SERIAL_PROTOCOL(READ(E0_MS1_PIN));
   1734                SERIAL_PROTOCOLLN(READ(E0_MS2_PIN));
   1735              #endif
   1736              #if HAS_E1_MICROSTEPS
   1737                SERIAL_PROTOCOLPGM("E1: ");
   1738                SERIAL_PROTOCOL(READ(E1_MS1_PIN));
   1739                SERIAL_PROTOCOLLN(READ(E1_MS2_PIN));
   1740              #endif
   1741              #if HAS_E2_MICROSTEPS
   1742                SERIAL_PROTOCOLPGM("E2: ");
   1743                SERIAL_PROTOCOL(READ(E2_MS1_PIN));
   1744                SERIAL_PROTOCOLLN(READ(E2_MS2_PIN));
   1745              #endif
   1746              #if HAS_E3_MICROSTEPS
   1747                SERIAL_PROTOCOLPGM("E3: ");
   1748                SERIAL_PROTOCOL(READ(E3_MS1_PIN));
   1749                SERIAL_PROTOCOLLN(READ(E3_MS2_PIN));
   1750              #endif
   1751              #if HAS_E4_MICROSTEPS
   1752                SERIAL_PROTOCOLPGM("E4: ");
   1753                SERIAL_PROTOCOL(READ(E4_MS1_PIN));
   1754                SERIAL_PROTOCOLLN(READ(E4_MS2_PIN));
   1755              #endif
   1756            }
   1757          
   1758          #endif // HAS_MICROSTEPS

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   IsrStepperHandler
         0   -> Stepper::StepperHandler()
      40   Stepper::StepperHandler()
        40   -> Endstops::update()
        40   -> HAL_GPIO_WritePin
         0   -> HAL_TIM_Base_Start_IT
        40   -> HAL_TIM_Base_Start_IT
        40   -> HAL_TIM_Base_Stop_IT
        40   -> Stepper::calc_timer_interval(unsigned short)
        40   -> Stepper::set_directions()
        40   -> enqueue_and_echo_commands_P(char const *)
      32   Stepper::babystep(AxisEnum, bool)
        32   -> HAL_GPIO_ReadPin
        32   -> HAL_GPIO_WritePin
       0   Stepper::calc_timer_interval(unsigned short)
      16   Stepper::endstop_triggered(AxisEnum)
        16   -> __aeabi_f2iz
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
      16   Stepper::finish_and_disable()
         0   -> disable_all_steppers()
        16   -> idle()
      16   Stepper::get_axis_position_mm(AxisEnum)
        16   -> Stepper::position(AxisEnum)
         0   -> __aeabi_fmul
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
      24   Stepper::init()
        24   -> Endstops::init()
        24   -> HAL_GPIO_WritePin
        24   -> HAL_TIM_Base_Start_IT
         0   -> Stepper::set_directions()
       0   Stepper::position(AxisEnum)
      16   Stepper::quick_stop()
         0   -> HAL_TIM_Base_Start_IT
        16   -> HAL_TIM_Base_Stop_IT
      32   Stepper::report_positions()
        32   -> Print::print(long, int)
         0   -> USARTClass::write(uint8_t)
        32   -> USARTClass::write(uint8_t)
      24   Stepper::set_directions()
        24   -> HAL_GPIO_WritePin
       0   Stepper::set_e_position(long const &)
       0   Stepper::set_position(AxisEnum const &, long const &)
      32   Stepper::set_position(long const &, long const &, long const &, long const &)
        32   -> idle()
      16   Stepper::synchronize()
        16   -> idle()
       0   Stepper::waitUntilEndOfAllBuffers()
       0   Stepper::waitUntilEndOfAllMoves()
       0   Stepper::wake_up()
         0   -> HAL_TIM_Base_Start_IT


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant " B:">
       4  ?<Constant " C:">
      12  ?<Constant " Count A:">
      12  ?<Constant " Count X:">
       4  ?<Constant " Y:">
       4  ?<Constant " Z:">
      12  ?<Constant "M84 X Y Z E">
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_10
       4  ??DataTable20_11
       4  ??DataTable20_12
       4  ??DataTable20_13
       4  ??DataTable20_14
       4  ??DataTable20_15
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable20_8
       4  ??DataTable20_9
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_10
       4  ??DataTable21_2
       4  ??DataTable21_3
       4  ??DataTable21_4
       4  ??DataTable21_5
       4  ??DataTable21_6
       4  ??DataTable21_7
       4  ??DataTable21_8
       4  ??DataTable21_9
       8  ?Subroutine0
       4  IsrStepperHandler
    1728  Stepper::StepperHandler()
     834  Stepper::babystep(AxisEnum, bool)
      76  Stepper::calc_timer_interval(unsigned short)
      80  Stepper::count_direction
          Stepper::performing_homing
          Stepper::last_direction_bits
          Stepper::locked_z_motor
          Stepper::locked_z2_motor
          Stepper::step_loops
          Stepper::step_loops_nominal
          Stepper::cleaning_buffer_counter
          Stepper::OCR1A_nominal
          Stepper::acc_step_rate
          Stepper::count_position
          Stepper::current_block
          Stepper::counter_X
          Stepper::counter_Y
          Stepper::counter_Z
          Stepper::counter_E
          Stepper::step_events_completed
          Stepper::acceleration_time
          Stepper::deceleration_time
          Stepper::endstops_trigsteps
          step_remaining
     104  Stepper::endstop_triggered(AxisEnum)
      40  Stepper::finish_and_disable()
     118  Stepper::get_axis_position_mm(AxisEnum)
     330  Stepper::init()
      16  Stepper::position(AxisEnum)
      64  Stepper::quick_stop()
     238  Stepper::report_positions()
     272  Stepper::set_directions()
      14  Stepper::set_e_position(long const &)
      22  Stepper::set_position(AxisEnum const &, long const &)
     168  Stepper::set_position(long const &, long const &, long const &, long const &)
      34  Stepper::synchronize()
      14  Stepper::waitUntilEndOfAllBuffers()
       2  Stepper::waitUntilEndOfAllMoves()
       2  Stepper::wake_up()
       1  last_extruder
       4  stepper
       1  -- Other

 
     4 bytes in section .bss
    81 bytes in section .data
    17 bytes in section .rodata
 4 244 bytes in section .text
 
 4 168 bytes of CODE  memory (+ 76 bytes shared)
    16 bytes of CONST memory (+  1 byte  shared)
    84 bytes of DATA  memory (+  1 byte  shared)

Errors: none
Warnings: 42
