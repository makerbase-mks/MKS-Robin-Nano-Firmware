###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:42
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\mks_test.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\mks_test.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\mks_test.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\mks_test.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\mks_test.cpp
      1          /* Includes ------------------------------------------------------------------*/
      2          #include "main.h"
      3          #include "stm32f1xx_hal.h"
      4          #include "adc.h"
      5          #include "dma.h"
      6          #include "fatfs.h"
      7          #include "i2c.h"
      8          #include "rtc.h"
      9          #include "sdio.h"
     10          #include "spi.h"
     11          #include "tim.h"
     12          #include "usart.h"
     13          #include "usb_host.h"
     14          #include "gpio.h"
     15          #include "fsmc.h"
     16          //#include "iwdg.h"
     17          
     18          /* USER CODE BEGIN Includes */
     19          #include "Marlin.h"

  #define UNUSED(x) (void) (x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\macros.h",101  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 87 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
     20          #include "Marlin_export.h"
     21          #include "mks_test.h"

  #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION_MODE" (declared
          at line 466 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",146  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          459 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",158  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 488 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          496 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          504 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          512 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 521 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 535 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",408  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",409  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",425  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 558 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #else defined(MKS_ROBIN_NANO)
        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.h",40  Warning[Pe014]: 
          extra text after expected end of preprocessing directive
     22          #include "mks_reprint.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 524 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\EWARM\..\Middlewares\Third_Party\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")
     23              
     24          #include "spi_flash.h"
     25          #include "cardreader.h"
     26          #ifdef USE_MKS_WIFI
     27          #include "wifi_module.h"
     28          #endif    
     29          #include "serial.h"  
     30          #include "gui.h"
     31          
     32          #include "draw_ui.h"

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_en.h",135  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_CN            "่งฃ้ค็ปๅฎ?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_s_cn.h",218  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 213)

    #define FILAMENT_CHANGE_TEXT_T_CN				"ๅพๆๅฐๆฉๆซๅๅ,\n่ซๆ<้ฒๆ>ๆ<้ๆ>"
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_t_cn.h",127  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_ru.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_ru.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 225)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_fr.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_fr.h",233  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 229)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_sp.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_it.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_it.h",229  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 224)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Multi_language.h",651  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 644)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\Multi_language\Multi_language.h",859  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 853)

  #define Simple_Dec"ผ๕ษู"
                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",495  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "หูถศ"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",550  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          547)

  #define Complex_Speed "หูถศ"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",551  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          548)
     33          #include "draw_ready_print.h"
     34          /*----------------------------------------------------------------*/
     35          struct HARDWARE_TEST_STATE
     36          {
     37          	uint8_t pw_det_sta;
     38          	uint8_t pw_off_sta;
     39          	uint8_t mt_det_sta;
     40              uint8_t mt_det2_sta;
     41          	uint8_t xs1_5_sta;
     42          	uint8_t xs1_6_sta;
     43          	uint8_t xs2_5_sta;
     44          	uint8_t t1_cs_sta;
     45          	uint8_t t2_cs_sta;
     46          	uint8_t endstopx1_sta;
     47          	uint8_t endstopx2_sta;
     48          	uint8_t endstopy1_sta;
     49          	uint8_t endstopy2_sta;
     50          	uint8_t endstopz1_sta;
     51          	uint8_t endstopz2_sta;
     52          };
     53          

   \                                 In section .bss, align 4
     54          HARDWARE_TEST_STATE GPIO_TEST_STATE;
   \                     GPIO_TEST_STATE:
   \   00000000                      DS8 16
     55          

   \                                 In section .text, align 2, keep-with-next
     56          void test_gpio_readlevel_L()
     57          {
   \                     _Z21test_gpio_readlevel_Lv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
     58          	volatile uint32_t itest;
     59          
     60              HAL_GPIO_WritePin(WIFI_IO2_GPIO_Port, WIFI_IO2_Pin, GPIO_PIN_SET);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable19  ;; 0x40010800
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xF44F 0x7180      MOV      R1,#+256
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       HAL_GPIO_WritePin
     61          	itest = 10000;
   \   00000014   0xF242 0x7010      MOVW     R0,#+10000
   \   00000018   0x9000             STR      R0,[SP, #+0]
     62          	while(itest--);
   \                     ??test_gpio_readlevel_L_0: (+1)
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x1E41             SUBS     R1,R0,#+1
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1FA             BNE.N    ??test_gpio_readlevel_L_0
     63              /*
     64          	if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3)==Bit_RESET)
     65          	{
     66          		GPIO_TEST_STATE.xs1_5_sta = 1;
     67          	}
     68          	else
     69          	{
     70          		GPIO_TEST_STATE.xs1_5_sta = 0;
     71          	}
     72          	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)==Bit_RESET)
     73          	{
     74          		GPIO_TEST_STATE.xs1_6_sta = 1;
     75          	}
     76          	else
     77          	{
     78          		GPIO_TEST_STATE.xs1_6_sta = 0;
     79          	}
     80          	
     81          	if(GPIO_ReadInputDataBit(GPIOF, GPIO_Pin_9)==Bit_RESET)
     82          	{
     83          		GPIO_TEST_STATE.xs2_5_sta = 1;
     84          	}
     85          	else
     86          	{
     87          		GPIO_TEST_STATE.xs2_5_sta = 0;
     88          	}
     89          	*/
     90          	if(HAL_GPIO_ReadPin(PW_DET_GPIO_Port, PW_DET_Pin)==GPIO_PIN_RESET)
   \   00000024   0x.... 0x....      LDR.W    R5,??DataTable19_1
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x4180             SBCS     R0,R0,R0
   \   00000034   0x0FC0             LSRS     R0,R0,#+31
   \   00000036   0x7028             STRB     R0,[R5, #+0]
     91          	{
     92          		GPIO_TEST_STATE.pw_det_sta = 1;
     93          	}
     94          	else
     95          	{
     96          		GPIO_TEST_STATE.pw_det_sta = 0;
     97          	}
     98          	/*
     99          	if(HAL_GPIO_ReadPin(BOOT1_GPIO_Port, BOOT1_Pin)==GPIO_PIN_RESET)
    100          	{
    101          		GPIO_TEST_STATE.pw_off_sta = 1;
    102          	}
    103          	else
    104          	{
    105          		GPIO_TEST_STATE.pw_off_sta = 0;
    106          	}
    107          */
    108          	if(HAL_GPIO_ReadPin(MT_DET_GPIO_Port, MT_DET_Pin)==GPIO_PIN_RESET)
   \   00000038   0x2110             MOVS     R1,#+16
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000040   0x1E40             SUBS     R0,R0,#+1
   \   00000042   0x4180             SBCS     R0,R0,R0
   \   00000044   0x0FC0             LSRS     R0,R0,#+31
   \   00000046   0x70A8             STRB     R0,[R5, #+2]
    109          	{
    110          		GPIO_TEST_STATE.mt_det_sta = 1;
    111          	}
    112          	else
    113          	{
    114          		GPIO_TEST_STATE.mt_det_sta = 0;
    115          	}
    116          	if(HAL_GPIO_ReadPin(MT_DET2_GPIO_Port, MT_DET2_Pin)==GPIO_PIN_RESET)
   \   00000048   0x.... 0x....      LDR.W    R6,??DataTable19_2  ;; 0x40011800
   \   0000004C   0x2140             MOVS     R1,#+64
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000054   0x1E40             SUBS     R0,R0,#+1
   \   00000056   0x4180             SBCS     R0,R0,R0
   \   00000058   0x0FC0             LSRS     R0,R0,#+31
   \   0000005A   0x70E8             STRB     R0,[R5, #+3]
    117          	{
    118          		GPIO_TEST_STATE.mt_det2_sta = 1;
    119          	}
    120          	else
    121          	{
    122          		GPIO_TEST_STATE.mt_det2_sta = 0;
    123          	}	
    124          	if(HAL_GPIO_ReadPin(XMIN_GPIO_Port, XMIN_Pin)==GPIO_PIN_RESET)
   \   0000005C   0xF44F 0x4100      MOV      R1,#+32768
   \   00000060   0x4620             MOV      R0,R4
   \   00000062   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000066   0x1E40             SUBS     R0,R0,#+1
   \   00000068   0x4180             SBCS     R0,R0,R0
   \   0000006A   0x0FC0             LSRS     R0,R0,#+31
   \   0000006C   0x7268             STRB     R0,[R5, #+9]
    125          	{
    126          		GPIO_TEST_STATE.endstopx1_sta = 1;
    127          	}
    128          	else
    129          	{
    130          		GPIO_TEST_STATE.endstopx1_sta = 0;
    131          	}
    132              /*
    133          	if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0)==Bit_RESET)
    134          	{
    135          		GPIO_TEST_STATE.endstopx2_sta = 1;
    136          	}
    137          	else
    138          	{
    139          		GPIO_TEST_STATE.endstopx2_sta = 0;
    140          	}
    141          	*/
    142          	if(HAL_GPIO_ReadPin(YMIN_GPIO_Port, YMIN_Pin)==GPIO_PIN_RESET)
   \   0000006E   0xF44F 0x5180      MOV      R1,#+4096
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x4180             SBCS     R0,R0,R0
   \   0000007C   0x0FC0             LSRS     R0,R0,#+31
   \   0000007E   0x72E8             STRB     R0,[R5, #+11]
    143          	{
    144          		GPIO_TEST_STATE.endstopy1_sta = 1;
    145          	}
    146          	else
    147          	{
    148          		GPIO_TEST_STATE.endstopy1_sta = 0;
    149          	}
    150              /*
    151          	if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4)==Bit_RESET)
    152          	{
    153          		GPIO_TEST_STATE.endstopy2_sta = 1;
    154          	}
    155          	else
    156          	{
    157          		GPIO_TEST_STATE.endstopy2_sta = 0;
    158          	}
    159          	*/
    160          	if(HAL_GPIO_ReadPin(ZMIN_GPIO_Port, ZMIN_Pin)==GPIO_PIN_RESET)
   \   00000080   0xF44F 0x6100      MOV      R1,#+2048
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000008A   0x1E40             SUBS     R0,R0,#+1
   \   0000008C   0x4180             SBCS     R0,R0,R0
   \   0000008E   0x0FC0             LSRS     R0,R0,#+31
   \   00000090   0x7368             STRB     R0,[R5, #+13]
    161          	{
    162          		GPIO_TEST_STATE.endstopz1_sta = 1;
    163          	}
    164          	else
    165          	{
    166          		GPIO_TEST_STATE.endstopz1_sta = 0;
    167          	}
    168          	if(HAL_GPIO_ReadPin(ZMAX_GPIO_Port, ZMAX_Pin)==GPIO_PIN_RESET)
   \   00000092   0x2110             MOVS     R1,#+16
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40011000
   \   00000098   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000009C   0x1E40             SUBS     R0,R0,#+1
   \   0000009E   0x4180             SBCS     R0,R0,R0
   \   000000A0   0x0FC0             LSRS     R0,R0,#+31
   \   000000A2   0x73A8             STRB     R0,[R5, #+14]
    169          	{
    170          		GPIO_TEST_STATE.endstopz2_sta = 1;
    171          	}
    172          	else
    173          	{
    174          		GPIO_TEST_STATE.endstopz2_sta = 0;
    175          	}
    176          	if(HAL_GPIO_ReadPin(TC1_CS_GPIO_Port, TC1_CS_Pin)==GPIO_PIN_RESET)
   \   000000A4   0x2120             MOVS     R1,#+32
   \   000000A6   0x4630             MOV      R0,R6
   \   000000A8   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000AC   0x1E40             SUBS     R0,R0,#+1
   \   000000AE   0x4180             SBCS     R0,R0,R0
   \   000000B0   0x0FC0             LSRS     R0,R0,#+31
   \   000000B2   0x71E8             STRB     R0,[R5, #+7]
    177          	{
    178          		GPIO_TEST_STATE.t1_cs_sta= 1;
    179          	}
    180          	else
    181          	{
    182          		GPIO_TEST_STATE.t1_cs_sta= 0;
    183          	}
    184              /*
    185          	if(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_6)==Bit_RESET)
    186          	{
    187          		GPIO_TEST_STATE.t2_cs_sta= 1;
    188          	}
    189          	else
    190          	{
    191          		GPIO_TEST_STATE.t2_cs_sta= 0;
    192          	}
    193          	*/
    194          }
   \   000000B4   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
    195          

   \                                 In section .text, align 2, keep-with-next
    196          void test_gpio_readlevel_H()
    197          {
   \                     _Z21test_gpio_readlevel_Hv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
    198          	volatile uint32_t itesth;
    199          	HAL_GPIO_WritePin(WIFI_IO2_GPIO_Port, WIFI_IO2_Pin, GPIO_PIN_RESET);
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable19  ;; 0x40010800
   \   00000008   0x2200             MOVS     R2,#+0
   \   0000000A   0xF44F 0x7180      MOV      R1,#+256
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       HAL_GPIO_WritePin
    200          	itesth= 10000;
   \   00000014   0xF242 0x7010      MOVW     R0,#+10000
   \   00000018   0x9000             STR      R0,[SP, #+0]
    201          	while(itesth--);	
   \                     ??test_gpio_readlevel_H_0: (+1)
   \   0000001A   0x9800             LDR      R0,[SP, #+0]
   \   0000001C   0x1E41             SUBS     R1,R0,#+1
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD1FA             BNE.N    ??test_gpio_readlevel_H_0
    202              /*
    203          	if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_3)!=Bit_RESET)
    204          	{
    205          		GPIO_TEST_STATE.xs1_5_sta = 1;
    206          	}
    207          	else
    208          	{
    209          		GPIO_TEST_STATE.xs1_5_sta = 0;
    210          	}
    211          	if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_1)!=Bit_RESET)
    212          	{
    213          		GPIO_TEST_STATE.xs1_6_sta = 1;
    214          	}
    215          	else
    216          	{
    217          		GPIO_TEST_STATE.xs1_6_sta = 0;
    218          	}
    219          	
    220          	if(GPIO_ReadInputDataBit(GPIOF, GPIO_Pin_9)!=Bit_RESET)
    221          	{
    222          		GPIO_TEST_STATE.xs2_5_sta = 1;
    223          	}
    224          	else
    225          	{
    226          		GPIO_TEST_STATE.xs2_5_sta = 0;
    227          	}
    228          	*/
    229          	if(HAL_GPIO_ReadPin(PW_DET_GPIO_Port, PW_DET_Pin)!=GPIO_PIN_RESET)
   \   00000024   0x.... 0x....      LDR.W    R5,??DataTable19_1
   \   00000028   0x2104             MOVS     R1,#+4
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000030   0x1E40             SUBS     R0,R0,#+1
   \   00000032   0x4180             SBCS     R0,R0,R0
   \   00000034   0x43C0             MVNS     R0,R0
   \   00000036   0x0FC0             LSRS     R0,R0,#+31
   \   00000038   0x7028             STRB     R0,[R5, #+0]
    230          	{
    231          		GPIO_TEST_STATE.pw_det_sta = 1;
    232          	}
    233          	else
    234          	{
    235          		GPIO_TEST_STATE.pw_det_sta = 0;
    236          	}
    237          	/*
    238          	if(HAL_GPIO_ReadPin(BOOT1_GPIO_Port, BOOT1_Pin)!=GPIO_PIN_RESET)
    239          	{
    240          		GPIO_TEST_STATE.pw_off_sta = 1;
    241          	}
    242          	else
    243          	{
    244          		GPIO_TEST_STATE.pw_off_sta = 0;
    245          	}
    246          */
    247          	if(HAL_GPIO_ReadPin(MT_DET_GPIO_Port, MT_DET_Pin)!=GPIO_PIN_RESET)
   \   0000003A   0x2110             MOVS     R1,#+16
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000042   0x1E40             SUBS     R0,R0,#+1
   \   00000044   0x4180             SBCS     R0,R0,R0
   \   00000046   0x43C0             MVNS     R0,R0
   \   00000048   0x0FC0             LSRS     R0,R0,#+31
   \   0000004A   0x70A8             STRB     R0,[R5, #+2]
    248          	{
    249          		GPIO_TEST_STATE.mt_det_sta = 1;
    250          	}
    251          	else
    252          	{
    253          		GPIO_TEST_STATE.mt_det_sta = 0;
    254          	}
    255          	if(HAL_GPIO_ReadPin(MT_DET2_GPIO_Port, MT_DET2_Pin)!=GPIO_PIN_RESET)
   \   0000004C   0x.... 0x....      LDR.W    R6,??DataTable19_2  ;; 0x40011800
   \   00000050   0x2140             MOVS     R1,#+64
   \   00000052   0x4630             MOV      R0,R6
   \   00000054   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x4180             SBCS     R0,R0,R0
   \   0000005C   0x43C0             MVNS     R0,R0
   \   0000005E   0x0FC0             LSRS     R0,R0,#+31
   \   00000060   0x70E8             STRB     R0,[R5, #+3]
    256          	{
    257          		GPIO_TEST_STATE.mt_det2_sta = 1;
    258          	}
    259          	else
    260          	{
    261          		GPIO_TEST_STATE.mt_det2_sta = 0;
    262          	}	
    263          	if(HAL_GPIO_ReadPin(XMIN_GPIO_Port, XMIN_Pin)!=GPIO_PIN_RESET)
   \   00000062   0xF44F 0x4100      MOV      R1,#+32768
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000006C   0x1E40             SUBS     R0,R0,#+1
   \   0000006E   0x4180             SBCS     R0,R0,R0
   \   00000070   0x43C0             MVNS     R0,R0
   \   00000072   0x0FC0             LSRS     R0,R0,#+31
   \   00000074   0x7268             STRB     R0,[R5, #+9]
    264          	{
    265          		GPIO_TEST_STATE.endstopx1_sta = 1;
    266          	}
    267          	else
    268          	{
    269          		GPIO_TEST_STATE.endstopx1_sta = 0;
    270          	}
    271              /*
    272          	if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_0)!=Bit_RESET)
    273          	{
    274          		GPIO_TEST_STATE.endstopx2_sta = 1;
    275          	}
    276          	else
    277          	{
    278          		GPIO_TEST_STATE.endstopx2_sta = 0;
    279          	}
    280          	*/
    281          	if(HAL_GPIO_ReadPin(YMIN_GPIO_Port, YMIN_Pin)!=GPIO_PIN_RESET)
   \   00000076   0xF44F 0x5180      MOV      R1,#+4096
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000080   0x1E40             SUBS     R0,R0,#+1
   \   00000082   0x4180             SBCS     R0,R0,R0
   \   00000084   0x43C0             MVNS     R0,R0
   \   00000086   0x0FC0             LSRS     R0,R0,#+31
   \   00000088   0x72E8             STRB     R0,[R5, #+11]
    282          	{
    283          		GPIO_TEST_STATE.endstopy1_sta = 1;
    284          	}
    285          	else
    286          	{
    287          		GPIO_TEST_STATE.endstopy1_sta = 0;
    288          	}
    289          /*
    290          	if(GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_4)!=Bit_RESET)
    291          	{
    292          		GPIO_TEST_STATE.endstopy2_sta = 1;
    293          	}
    294          	else
    295          	{
    296          		GPIO_TEST_STATE.endstopy2_sta = 0;
    297          	}
    298          	*/
    299          	if(HAL_GPIO_ReadPin(ZMIN_GPIO_Port, ZMIN_Pin)!=GPIO_PIN_RESET)
   \   0000008A   0xF44F 0x6100      MOV      R1,#+2048
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000094   0x1E40             SUBS     R0,R0,#+1
   \   00000096   0x4180             SBCS     R0,R0,R0
   \   00000098   0x43C0             MVNS     R0,R0
   \   0000009A   0x0FC0             LSRS     R0,R0,#+31
   \   0000009C   0x7368             STRB     R0,[R5, #+13]
    300          	{
    301          		GPIO_TEST_STATE.endstopz1_sta = 1;
    302          	}
    303          	else
    304          	{
    305          		GPIO_TEST_STATE.endstopz1_sta = 0;
    306          	}
    307          	if(HAL_GPIO_ReadPin(ZMAX_GPIO_Port, ZMAX_Pin)!=GPIO_PIN_RESET)
   \   0000009E   0x2110             MOVS     R1,#+16
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40011000
   \   000000A4   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000A8   0x1E40             SUBS     R0,R0,#+1
   \   000000AA   0x4180             SBCS     R0,R0,R0
   \   000000AC   0x43C0             MVNS     R0,R0
   \   000000AE   0x0FC0             LSRS     R0,R0,#+31
   \   000000B0   0x73A8             STRB     R0,[R5, #+14]
    308          	{
    309          		GPIO_TEST_STATE.endstopz2_sta = 1;
    310          	}
    311          	else
    312          	{
    313          		GPIO_TEST_STATE.endstopz2_sta = 0;
    314          	}
    315          	if(HAL_GPIO_ReadPin(TC1_CS_GPIO_Port, TC1_CS_Pin)!=GPIO_PIN_RESET)
   \   000000B2   0x2120             MOVS     R1,#+32
   \   000000B4   0x4630             MOV      R0,R6
   \   000000B6   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   000000BA   0x1E40             SUBS     R0,R0,#+1
   \   000000BC   0x4180             SBCS     R0,R0,R0
   \   000000BE   0x43C0             MVNS     R0,R0
   \   000000C0   0x0FC0             LSRS     R0,R0,#+31
   \   000000C2   0x71E8             STRB     R0,[R5, #+7]
    316          	{
    317          		GPIO_TEST_STATE.t1_cs_sta= 1;
    318          	}
    319          	else
    320          	{
    321          		GPIO_TEST_STATE.t1_cs_sta= 0;
    322          	}
    323              /*
    324          	if(GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_6)!=Bit_RESET)
    325          	{
    326          		GPIO_TEST_STATE.t2_cs_sta= 1;
    327          	}
    328          	else
    329          	{
    330          		GPIO_TEST_STATE.t2_cs_sta= 0;
    331          	}
    332          	*/
    333          }
   \   000000C4   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
    334          void Test_GPIO_Init()
    335          {
   \                     _Z14Test_GPIO_Initv: (+1)
   \   00000000   0xB51F             PUSH     {R0-R4,LR}
    336           	GPIO_InitTypeDef GPIO_InitStructure;
    337          	
    338          	//RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOC|RCC_APB2Periph_GPIOE, ENABLE );
    339          	//ฟุึฦฝลPW_OFF(PB2)
    340          	GPIO_InitStructure.Pin = WIFI_IO2_Pin;
   \   00000002   0xF44F 0x7080      MOV      R0,#+256
   \   00000006   0x9000             STR      R0,[SP, #+0]
    341          	GPIO_InitStructure.Mode =GPIO_MODE_OUTPUT_PP ;
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x9001             STR      R0,[SP, #+4]
    342          	GPIO_InitStructure.Speed = GPIO_SPEED_FREQ_HIGH;	
   \   0000000C   0x2003             MOVS     R0,#+3
   \   0000000E   0x9003             STR      R0,[SP, #+12]
    343          	HAL_GPIO_Init(WIFI_IO2_GPIO_Port, &GPIO_InitStructure);
   \   00000010   0x.... 0x....      LDR.W    R4,??DataTable19  ;; 0x40010800
   \   00000014   0xA900             ADD      R1,SP,#+0
   \   00000016   0x4620             MOV      R0,R4
   \   00000018   0x.... 0x....      BL       HAL_GPIO_Init
    344          	HAL_GPIO_WritePin(WIFI_IO2_GPIO_Port, WIFI_IO2_Pin, GPIO_PIN_SET);    
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF44F 0x7180      MOV      R1,#+256
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       HAL_GPIO_WritePin
    345          
    346          	//PW_DET(PA2)/MT_DET1(PA4)/MT_DET2(PE6)
    347          	GPIO_InitStructure.Pin =  PW_DET_Pin;
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0x9000             STR      R0,[SP, #+0]
    348          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0x9001             STR      R0,[SP, #+4]
    349          	HAL_GPIO_Init(PW_DET_GPIO_Port, &GPIO_InitStructure);
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x4620             MOV      R0,R4
   \   00000034   0x.... 0x....      BL       HAL_GPIO_Init
    350          	GPIO_InitStructure.Pin = MT_DET_Pin;
   \   00000038   0x2010             MOVS     R0,#+16
   \   0000003A   0x9000             STR      R0,[SP, #+0]
    351          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x9001             STR      R0,[SP, #+4]
    352          	HAL_GPIO_Init(MT_DET_GPIO_Port, &GPIO_InitStructure);
   \   00000040   0xA900             ADD      R1,SP,#+0
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       HAL_GPIO_Init
    353          	GPIO_InitStructure.Pin = MT_DET2_Pin;
   \   00000048   0x2040             MOVS     R0,#+64
   \   0000004A   0x9000             STR      R0,[SP, #+0]
    354          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   0000004C   0x2000             MOVS     R0,#+0
   \   0000004E   0x9001             STR      R0,[SP, #+4]
    355          	HAL_GPIO_Init(MT_DET2_GPIO_Port, &GPIO_InitStructure); 
   \   00000050   0xA900             ADD      R1,SP,#+0
   \   00000052   0x.... 0x....      LDR.W    R0,??DataTable19_2  ;; 0x40011800
   \   00000056   0x.... 0x....      BL       HAL_GPIO_Init
    356            
    357          	//X-(PA15)
    358          	GPIO_InitStructure.Pin = XMIN_Pin;
   \   0000005A   0xF44F 0x4000      MOV      R0,#+32768
   \   0000005E   0x9000             STR      R0,[SP, #+0]
    359          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   00000060   0x2000             MOVS     R0,#+0
   \   00000062   0x9001             STR      R0,[SP, #+4]
    360          	HAL_GPIO_Init(XMIN_GPIO_Port, &GPIO_InitStructure);
   \   00000064   0xA900             ADD      R1,SP,#+0
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       HAL_GPIO_Init
    361          	//Y-(PA12)
    362          	GPIO_InitStructure.Pin = YMIN_Pin;
   \   0000006C   0xF44F 0x5080      MOV      R0,#+4096
   \   00000070   0x9000             STR      R0,[SP, #+0]
    363          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x9001             STR      R0,[SP, #+4]
    364          	HAL_GPIO_Init(YMIN_GPIO_Port, &GPIO_InitStructure);
   \   00000076   0xA900             ADD      R1,SP,#+0
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       HAL_GPIO_Init
    365          	//Z-(PA11)/Z+(PC4)
    366          	GPIO_InitStructure.Pin = ZMIN_Pin;
   \   0000007E   0xF44F 0x6000      MOV      R0,#+2048
   \   00000082   0x9000             STR      R0,[SP, #+0]
    367          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x9001             STR      R0,[SP, #+4]
    368          	HAL_GPIO_Init(ZMIN_GPIO_Port, &GPIO_InitStructure);
   \   00000088   0xA900             ADD      R1,SP,#+0
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       HAL_GPIO_Init
    369          	GPIO_InitStructure.Pin = ZMAX_Pin;
   \   00000090   0x2010             MOVS     R0,#+16
   \   00000092   0x9000             STR      R0,[SP, #+0]
    370          	GPIO_InitStructure.Mode =GPIO_MODE_INPUT ;
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x9001             STR      R0,[SP, #+4]
    371          	HAL_GPIO_Init(ZMAX_GPIO_Port, &GPIO_InitStructure);
   \   00000098   0xA900             ADD      R1,SP,#+0
   \   0000009A   0x.... 0x....      LDR.W    R0,??DataTable19_3  ;; 0x40011000
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_Init
    372          	//T1_CS(PE5)
    373           	//GPIO_InitStructure.Pin = TC1_CS_Pin;
    374          	//GPIO_InitStructure.Mode =GPIO_MODE_OUTPUT_PP ;
    375          	//HAL_GPIO_Init(TC1_CS_GPIO_Port, &GPIO_InitStructure);	   
    376          
    377          }
   \   000000A2   0xBD1F             POP      {R0-R4,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
    378          void Test_GPIO()
    379          {
   \                     Test_GPIO: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    380              Test_GPIO_Init();
   \   00000002   0x.... 0x....      BL       _Z14Test_GPIO_Initv
    381          
    382          	test_gpio_readlevel_L();
   \   00000006   0x.... 0x....      BL       _Z21test_gpio_readlevel_Lv
    383          	test_gpio_readlevel_H();
   \   0000000A   0x.... 0x....      BL       _Z21test_gpio_readlevel_Hv
    384          	test_gpio_readlevel_L();
   \   0000000E   0x.... 0x....      BL       _Z21test_gpio_readlevel_Lv
    385          
    386              if((GPIO_TEST_STATE.pw_det_sta == 1)&&(GPIO_TEST_STATE.mt_det_sta == 1)&&(GPIO_TEST_STATE.mt_det2_sta == 1))
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable19_1
   \   00000016   0x7820             LDRB     R0,[R4, #+0]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD10C             BNE.N    ??Test_GPIO_0
   \   0000001C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000001E   0x2801             CMP      R0,#+1
   \   00000020   0xD109             BNE.N    ??Test_GPIO_0
   \   00000022   0x78E0             LDRB     R0,[R4, #+3]
   \   00000024   0x2801             CMP      R0,#+1
   \   00000026   0xD106             BNE.N    ??Test_GPIO_0
    387          	{
    388          		GUI_DispStringAt("ถฯต็ถฯมฯฝำฟฺีณฃ", 10, 60);
   \   00000028   0x223C             MOVS     R2,#+60
   \   0000002A   0x210A             MOVS     R1,#+10
   \   0000002C   0x.... 0x....      ADR.W    R0,`?<Constant "\\266\\317\\265\\347\\266\\317\\301\\317\\2`
   \   00000030   0x.... 0x....      BL       GUI_DispStringAt
   \   00000034   0xE013             B.N      ??Test_GPIO_1
    389          	}
    390          	else
    391          	{
    392          		GUI_SetBkColor(gCfgItems.background_color);
   \                     ??Test_GPIO_0: (+1)
   \   00000036   0x.... 0x....      LDR.W    R5,??DataTable19_4
   \   0000003A   0x6868             LDR      R0,[R5, #+4]
   \   0000003C   0x.... 0x....      BL       GUI_SetBkColor
    393          		GUI_SetColor(0X0000ff);//	บ์ษซืึฬๅ
   \   00000040   0x20FF             MOVS     R0,#+255
   \   00000042   0x.... 0x....      BL       GUI_SetColor
    394          		GUI_DispStringAt("ถฯต็ถฯมฯฝำฟฺา์ณฃ", 10, 60);
   \   00000046   0x223C             MOVS     R2,#+60
   \   00000048   0x210A             MOVS     R1,#+10
   \   0000004A   0x.... 0x....      ADR.W    R0,`?<Constant "\\266\\317\\265\\347\\266\\317\\301\\317\\2_1`
   \   0000004E   0x.... 0x....      BL       GUI_DispStringAt
    395          		GUI_SetBkColor(gCfgItems.background_color);
   \   00000052   0x6868             LDR      R0,[R5, #+4]
   \   00000054   0x.... 0x....      BL       GUI_SetBkColor
    396          		GUI_SetColor(gCfgItems.title_color);		
   \   00000058   0x68A8             LDR      R0,[R5, #+8]
   \   0000005A   0x.... 0x....      BL       GUI_SetColor
    397          	}
    398              /*
    399          	if((GPIO_TEST_STATE.t1_cs_sta== 1))
    400          	{
    401          		GUI_DispStringAt("ศศต็ลผฝำฟฺีณฃ", 0, 150);
    402          	}
    403          	else
    404          	{
    405          		GUI_SetBkColor(gCfgItems.background_color);
    406          		GUI_SetColor(0X0000ff);//	บ์ษซืึฬๅ
    407          		GUI_DispStringAt("ศศต็ลผฝำฟฺา์ณฃ", 0, 150);
    408          		GUI_SetBkColor(gCfgItems.background_color);
    409          		GUI_SetColor(gCfgItems.title_color);		
    410          	}
    411          	*/
    412          	if((GPIO_TEST_STATE.endstopx1_sta== 1)
    413          		&&(GPIO_TEST_STATE.endstopy1_sta== 1)
    414          		&&(GPIO_TEST_STATE.endstopz1_sta== 1)
    415          		&&(GPIO_TEST_STATE.endstopz2_sta== 1))
   \                     ??Test_GPIO_1: (+1)
   \   0000005E   0x7A60             LDRB     R0,[R4, #+9]
   \   00000060   0x2801             CMP      R0,#+1
   \   00000062   0xD110             BNE.N    ??Test_GPIO_2
   \   00000064   0x7AE0             LDRB     R0,[R4, #+11]
   \   00000066   0x2801             CMP      R0,#+1
   \   00000068   0xD10D             BNE.N    ??Test_GPIO_2
   \   0000006A   0x7B60             LDRB     R0,[R4, #+13]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD10A             BNE.N    ??Test_GPIO_2
   \   00000070   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000072   0x2801             CMP      R0,#+1
   \   00000074   0xD107             BNE.N    ??Test_GPIO_2
    416          	{
    417          		GUI_DispStringAt("ฯฮปฝำฟฺีณฃ", 10, 90);
   \   00000076   0x225A             MOVS     R2,#+90
   \   00000078   0x210A             MOVS     R1,#+10
   \   0000007A   0x.... 0x....      ADR.W    R0,`?<Constant "\\317\\336\\316\\273\\275\\323\\277\\332\\3`
   \   0000007E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000082   0x.... 0x....      B.W      GUI_DispStringAt
    418          	}
    419          	else
    420          	{
    421          		GUI_SetBkColor(gCfgItems.background_color);
   \                     ??Test_GPIO_2: (+1)
   \   00000086   0x.... 0x....      LDR.W    R5,??DataTable19_4
   \   0000008A   0x6868             LDR      R0,[R5, #+4]
   \   0000008C   0x.... 0x....      BL       GUI_SetBkColor
    422          		GUI_SetColor(0X0000ff);//	บ์ษซืึฬๅ
   \   00000090   0x20FF             MOVS     R0,#+255
   \   00000092   0x.... 0x....      BL       GUI_SetColor
    423          		GUI_DispStringAt("ฯฮปฝำฟฺา์ณฃ", 10, 90);
   \   00000096   0x225A             MOVS     R2,#+90
   \   00000098   0x210A             MOVS     R1,#+10
   \   0000009A   0x.... 0x....      ADR.W    R0,`?<Constant "\\317\\336\\316\\273\\275\\323\\277\\332\\3_1`
   \   0000009E   0x.... 0x....      BL       GUI_DispStringAt
    424          		GUI_SetBkColor(gCfgItems.background_color);
   \   000000A2   0x6868             LDR      R0,[R5, #+4]
   \   000000A4   0x.... 0x....      BL       GUI_SetBkColor
    425          		GUI_SetColor(gCfgItems.title_color);
   \   000000A8   0x68A8             LDR      R0,[R5, #+8]
   \   000000AA   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   000000AE   0x.... 0x....      B.W      GUI_SetColor
    426          	}
    427          		
    428          }
    429          
    430          /*----------------------------------------------------------------*/
    431          /*---------------------AT24C16 TEST BEGIN--------------------------*/
    432          #define EEP_LEN 256
    433          #define OFFSET 256
    434          

   \                                 In section .text, align 2, keep-with-next
    435          bool mksEeprom_test()
    436          {
   \                     mksEeprom_test: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    437          		int i;
    438          		int eppr_add[4] = {0,1536,1537,2047};
   \   00000004   0xA802             ADD      R0,SP,#+8
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant {0, 1536, 1537, 2047}>`
   \   0000000A   0x2210             MOVS     R2,#+16
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
    439          		volatile uint8_t eppr_w[4]={0xa1,0xb2,0xc3,0xd4};
   \   00000010   0xA801             ADD      R0,SP,#+4
   \   00000012   0x.... 0x....      ADR.W    R1,`?<Constant {(unsigned char)'\\241', (unsigned c`
   \   00000016   0x680A             LDR      R2,[R1, #0]
   \   00000018   0x6002             STR      R2,[R0, #+0]
    440                  volatile uint8_t eppr_r[4];
    441          
    442          	for(i=0;i<4;i++)
   \   0000001A   0x2400             MOVS     R4,#+0
   \   0000001C   0xE000             B.N      ??mksEeprom_test_0
   \                     ??mksEeprom_test_1: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??mksEeprom_test_0: (+1)
   \   00000020   0x2C04             CMP      R4,#+4
   \   00000022   0xDA18             BGE.N    ??mksEeprom_test_2
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0xF850 0x5024      LDR      R5,[R0, R4, LSL #+2]
   \   0000002A   0x2201             MOVS     R2,#+1
   \   0000002C   0xA801             ADD      R0,SP,#+4
   \   0000002E   0x1821             ADDS     R1,R4,R0
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xB280             UXTH     R0,R0
    443          		{
    444          		AT24CXX_Write(eppr_add[i], (uint8_t *)&eppr_w[i],1); 
   \   00000034   0x.... 0x....      BL       AT24CXX_Write
    445          		AT24CXX_Read(eppr_add[i],(u8 *)&eppr_r[i],1);
   \   00000038   0x2201             MOVS     R2,#+1
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0x1821             ADDS     R1,R4,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0xB280             UXTH     R0,R0
   \   00000042   0x.... 0x....      BL       AT24CXX_Read
    446          		if(eppr_r[i] != eppr_w[i])
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x5C20             LDRB     R0,[R4, R0]
   \   0000004A   0xA901             ADD      R1,SP,#+4
   \   0000004C   0x5C61             LDRB     R1,[R4, R1]
   \   0000004E   0x4288             CMP      R0,R1
   \   00000050   0xD0E5             BEQ.N    ??mksEeprom_test_1
    447          			{
    448          			return false;
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0xE000             B.N      ??mksEeprom_test_3
    449          			}
    450          		}
    451          	  
    452          	return true;	
   \                     ??mksEeprom_test_2: (+1)
   \   00000056   0x2001             MOVS     R0,#+1
   \                     ??mksEeprom_test_3: (+1)
   \   00000058   0xB007             ADD      SP,SP,#+28
   \   0000005A   0xBD30             POP      {R4,R5,PC}       ;; return
    453          }  
    454          /*---------------------AT24C16 TEST END--------------------------*/
    455          
    456          
    457          /*---------------------W25Q64 TEST BEGIN--------------------------*/
    458          
    459          
    460          #define  sFLASH_ID              0xEF3015
    461          #define  W25Q64_FLASH_ID        0xEF4017
    462          #define  FLASH_WriteAddress     0x000000
    463          #define  FLASH_ReadAddress      FLASH_WriteAddress
    464          #define  FLASH_SectorToErase    FLASH_WriteAddress
    465          
    466          #define countof(a) (sizeof(a) / sizeof(*(a)))
    467          #define  BufferSize (countof(Tx_Buffer)-1)
    468          

   \                                 In section .data, align 4
    469          uint8_t Tx_Buffer[] = "\r\n www.makerbase.com STM32F407ZET6 SPI1 Flash DMA Mode Test Example:\r\n communication with an Winbond W25X64 W25Q64 SPI FLASH.";
   \                     Tx_Buffer:
   \   00000000   0x0D 0x0A          DC8 0DH, 0AH, 20H, 77H, 77H, 77H, 2EH, 6DH
   \              0x20 0x77    
   \              0x77 0x77    
   \              0x2E 0x6D    
   \   00000008   0x61 0x6B          DC8 61H, 6BH, 65H, 72H, 62H, 61H, 73H, 65H
   \              0x65 0x72    
   \              0x62 0x61    
   \              0x73 0x65    
   \   00000010   0x2E 0x63          DC8 2EH, 63H, 6FH, 6DH, 20H, 53H, 54H, 4DH
   \              0x6F 0x6D    
   \              0x20 0x53    
   \              0x54 0x4D    
   \   00000018   0x33 0x32          DC8 33H, 32H, 46H, 34H, 30H, 37H, 5AH, 45H
   \              0x46 0x34    
   \              0x30 0x37    
   \              0x5A 0x45    
   \   00000020   0x54 0x36          DC8 54H, 36H, 20H, 53H, 50H, 49H, 31H, 20H
   \              0x20 0x53    
   \              0x50 0x49    
   \              0x31 0x20    
   \   00000028   0x46 0x6C          DC8 46H, 6CH, 61H, 73H, 68H, 20H, 44H, 4DH
   \              0x61 0x73    
   \              0x68 0x20    
   \              0x44 0x4D    
   \   00000030   0x41 0x20          DC8 41H, 20H, 4DH, 6FH, 64H, 65H, 20H, 54H
   \              0x4D 0x6F    
   \              0x64 0x65    
   \              0x20 0x54    
   \   00000038   0x65 0x73          DC8 65H, 73H, 74H, 20H, 45H, 78H, 61H, 6DH
   \              0x74 0x20    
   \              0x45 0x78    
   \              0x61 0x6D    
   \   00000040   0x70 0x6C          DC8 70H, 6CH, 65H, 3AH, 0DH, 0AH, 20H, 63H
   \              0x65 0x3A    
   \              0x0D 0x0A    
   \              0x20 0x63    
   \   00000048   0x6F 0x6D          DC8 6FH, 6DH, 6DH, 75H, 6EH, 69H, 63H, 61H
   \              0x6D 0x75    
   \              0x6E 0x69    
   \              0x63 0x61    
   \   00000050   0x74 0x69          DC8 74H, 69H, 6FH, 6EH, 20H, 77H, 69H, 74H
   \              0x6F 0x6E    
   \              0x20 0x77    
   \              0x69 0x74    
   \   00000058   0x68 0x20          DC8 68H, 20H, 61H, 6EH, 20H, 57H, 69H, 6EH
   \              0x61 0x6E    
   \              0x20 0x57    
   \              0x69 0x6E    
   \   00000060   0x62 0x6F          DC8 62H, 6FH, 6EH, 64H, 20H, 57H, 32H, 35H
   \              0x6E 0x64    
   \              0x20 0x57    
   \              0x32 0x35    
   \   00000068   0x58 0x36          DC8 58H, 36H, 34H, 20H, 57H, 32H, 35H, 51H
   \              0x34 0x20    
   \              0x57 0x32    
   \              0x35 0x51    
   \   00000070   0x36 0x34          DC8 36H, 34H, 20H, 53H, 50H, 49H, 20H, 46H
   \              0x20 0x53    
   \              0x50 0x49    
   \              0x20 0x46    
   \   00000078   0x4C 0x41          DC8 4CH, 41H, 53H, 48H, 2EH, 0
   \              0x53 0x48    
   \              0x2E 0x00    
   \   0000007E   0x00 0x00          DC8 0, 0

   \                                 In section .bss, align 4
    470          uint8_t Rx_Buffer[BufferSize];
   \                     Rx_Buffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 2
    471          uint16_t Index;
   \                     Index:
   \   00000000                      DS8 2

   \                                 In section .bss, align 1
    472          volatile TestStatus TransferStatus1 = FAILED, TransferStatus2 = PASSED;
   \                     TransferStatus1:
   \   00000000                      DS8 1

   \                                 In section .data, align 1
   \                     TransferStatus2:
   \   00000000   0x01               DC8 1
    473          void SPI_FLASH_TEST(void);
    474          TestStatus Buffercmp(u8* pBuffer1, u8* pBuffer2, u16 BufferLength);
    475          

   \                                 In section .text, align 2, keep-with-next
    476          bool mksW25Q64Test(void)
    477          {
    478          #if 0
    479             __IO uint32_t FlashID = 0;
    480             __IO uint32_t DeviceID = 0;
    481             __IO uint16_t W25QXX_TYPE = 0;
    482          
    483            	bool testStatus = false;
    484            W25QXX_TYPE = W25QXX_ReadID();	//0xEF16
    485            /* Get SPI Flash Device ID */
    486            DeviceID = SPI_FLASH_ReadDeviceID(); //0x16
    487            /* Get SPI FlashID */
    488            FlashID = SPI_FLASH_ReadID();	//0xEF4017
    489          
    490            /* Check the SPI Flash ID */
    491            if ((FlashID == sFLASH_ID) || (FlashID == W25Q64_FLASH_ID)) 
    492            {
    493              /* Perform a write in the Flash followed by a read of the written data */
    494              /* Erase SPI FLASH Sector to write on */
    495              SPI_FLASH_SectorErase(FLASH_SectorToErase);
    496          
    497              //delay_ms(10);//printf("\r\n SPI FLASH Write:\n\r%s\r\n ", Tx_Buffer);
    498              
    499              /* Write Tx_Buffer data to SPI FLASH memory */
    500              
    501              SPI_FLASH_BufferWrite(Tx_Buffer, FLASH_WriteAddress, BufferSize);
    502               
    503          
    504               
    505              //delay_ms(10);
    506              /* Read data from SPI FLASH memory */
    507              SPI_FLASH_BufferRead(Rx_Buffer, FLASH_ReadAddress, BufferSize);
    508              for (Index = 0; Index < BufferSize; Index++) Rx_Buffer[Index]=0;
    509              SPI1_SetSpeed(SPI_BAUDRATEPRESCALER_128);
    510              SPI_FLASH_BufferRead(Rx_Buffer, FLASH_ReadAddress, BufferSize);
    511              for (Index = 0; Index < BufferSize; Index++) Rx_Buffer[Index]=0;
    512              SPI1_SetSpeed(SPI_BAUDRATEPRESCALER_4);
    513              SPI_FLASH_BufferRead(Rx_Buffer, FLASH_ReadAddress, BufferSize);
    514              for (Index = 0; Index < BufferSize; Index++) Rx_Buffer[Index]=0;
    515              
    516              SPI_FLASH_BufferRead(Rx_Buffer, FLASH_ReadAddress, BufferSize);
    517              
    518              /* Check the corectness of written dada */
    519              TransferStatus1 = Buffercmp(Tx_Buffer, Rx_Buffer, BufferSize);
    520              /* TransferStatus1 = PASSED, if the transmitted and received data by SPI1
    521                 are the same */
    522              /* TransferStatus1 = FAILED, if the transmitted and received data by SPI1
    523                 are different */
    524          
    525              /* Perform an erase in the Flash followed by a read of the written data */
    526              /* Erase SPI FLASH Sector to write on */
    527              SPI_FLASH_SectorErase(FLASH_SectorToErase);
    528          
    529              /* Read data from SPI FLASH memory */
    530              SPI_FLASH_BufferRead(Rx_Buffer, FLASH_ReadAddress, BufferSize);
    531          
    532              /* Check the corectness of erasing operation dada */
    533              for (Index = 0; Index < BufferSize; Index++)
    534              {
    535                if (Rx_Buffer[Index] != 0xFF)
    536                {
    537                  TransferStatus2 = FAILED;
    538                }
    539                //delay_ms(10);//printf(".");
    540              }
    541              
    542              /* TransferStatus2 = PASSED, if the specified sector part is erased */
    543              /* TransferStatus2 = FAILED, if the specified sector part is not well erased */
    544          
    545              if((PASSED == TransferStatus1) && (PASSED == TransferStatus2))
    546              {
    547                //HAL_Delay(10);    //ok
    548                testStatus = true;
    549              }
    550              else
    551              {
    552                //HAL_Delay(10);    //err
    553                testStatus = false;
    554              }
    555            }
    556            else
    557            {
    558              //HAL_Delay(10);    //err
    559              testStatus = false;
    560            }
    561            SPI_Flash_PowerDown();  
    562          	return testStatus;
    563          #endif
    564          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "mksW25Q64Test"
   \                     mksW25Q64Test: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    565          /*******************************************************************************
    566          * Function Name  : Buffercmp
    567          * Description    : Compares two buffers.
    568          * Input          : - pBuffer1, pBuffer2: buffers to be compared.
    569          *                : - BufferLength: buffer's length
    570          * Output         : None
    571          * Return         : PASSED: pBuffer1 identical to pBuffer2
    572          *                  FAILED: pBuffer1 differs from pBuffer2
    573          *******************************************************************************/

   \                                 In section .text, align 2, keep-with-next
    574          TestStatus Buffercmp(u8* pBuffer1, u8* pBuffer2, u16 BufferLength)
    575          {
   \                     _Z9BuffercmpPhS_t: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0xE001             B.N      ??Buffercmp_0
    576            while(BufferLength--)
    577            {
    578              if(*pBuffer1 != *pBuffer2)
    579              {
    580                return FAILED;
    581              }
    582          
    583              pBuffer1++;
   \                     ??Buffercmp_1: (+1)
   \   00000004   0x1C40             ADDS     R0,R0,#+1
    584              pBuffer2++;
   \   00000006   0x1C49             ADDS     R1,R1,#+1
   \                     ??Buffercmp_0: (+1)
   \   00000008   0x4613             MOV      R3,R2
   \   0000000A   0x1E5A             SUBS     R2,R3,#+1
   \   0000000C   0xB29B             UXTH     R3,R3
   \   0000000E   0x2B00             CMP      R3,#+0
   \   00000010   0xD005             BEQ.N    ??Buffercmp_2
   \   00000012   0x7803             LDRB     R3,[R0, #+0]
   \   00000014   0x780C             LDRB     R4,[R1, #+0]
   \   00000016   0x42A3             CMP      R3,R4
   \   00000018   0xD0F4             BEQ.N    ??Buffercmp_1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xE000             B.N      ??Buffercmp_3
    585            }
    586          
    587            return PASSED;
   \                     ??Buffercmp_2: (+1)
   \   0000001E   0x2001             MOVS     R0,#+1
   \                     ??Buffercmp_3: (+1)
   \   00000020   0xBC10             POP      {R4}
   \   00000022   0x4770             BX       LR               ;; return
    588          }
    589          
    590          
    591          /*---------------------W25Q64 TEST END--------------------------*/
    592          
    593          /*---------------------SDIO+FATFS TEST BEGIN--------------------------*/

   \                                 In section .data, align 4
    594            FATFS SDFatFs;  /* File system object for SD card logical drive */
    595            FIL MyFile;     /* File object */
    596          //#define countof(a) (sizeof(a) / sizeof(*(a)))
    597          #define sdBufferSize (countof(wtext)-1)
    598            uint8_t wtext[] = "www.makerbase.com STM32F407ZET6 SDIO+FATFS DMA Mode Test Example:\r\nThis is mksRobinPro STM32F407ZET6 working with FatFs\r\n"; /* File write buffer */
    599            uint8_t rtext[sdBufferSize];                                   /* File read buffer */
    600            volatile TestStatus TransferStatusSD = FAILED;
   \                     TransferStatusSD:
   \   00000000   0x00               DC8 0
   \   00000001   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \                     SDFatFs:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000014   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000034   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000094   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000A4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000B4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000C4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000D4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000E4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000000F4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000104   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000114   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000124   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000134   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000144   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000154   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000164   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000174   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000184   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000194   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001A4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001B4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001C4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001D4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001E4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000001F4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000204   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000214   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000224   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     MyFile:
   \   00000234   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000244   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000254   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000264   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000274   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000284   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000294   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002A4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002B4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002C4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002D4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002E4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000002F4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000304   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000314   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000324   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000334   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000344   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000354   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000364   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000374   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000384   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000394   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000003A4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000003B4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000003C4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000003D4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000003E4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000003F4   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000404   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000414   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000424   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000434   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000444   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000454   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     wtext:
   \   00000460   0x77 0x77          DC8 77H, 77H, 77H, 2EH, 6DH, 61H, 6BH, 65H
   \              0x77 0x2E    
   \              0x6D 0x61    
   \              0x6B 0x65    
   \   00000468   0x72 0x62          DC8 72H, 62H, 61H, 73H, 65H, 2EH, 63H, 6FH
   \              0x61 0x73    
   \              0x65 0x2E    
   \              0x63 0x6F    
   \   00000470   0x6D 0x20          DC8 6DH, 20H, 53H, 54H, 4DH, 33H, 32H, 46H
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x46    
   \   00000478   0x34 0x30          DC8 34H, 30H, 37H, 5AH, 45H, 54H, 36H, 20H
   \              0x37 0x5A    
   \              0x45 0x54    
   \              0x36 0x20    
   \   00000480   0x53 0x44          DC8 53H, 44H, 49H, 4FH, 2BH, 46H, 41H, 54H
   \              0x49 0x4F    
   \              0x2B 0x46    
   \              0x41 0x54    
   \   00000488   0x46 0x53          DC8 46H, 53H, 20H, 44H, 4DH, 41H, 20H, 4DH
   \              0x20 0x44    
   \              0x4D 0x41    
   \              0x20 0x4D    
   \   00000490   0x6F 0x64          DC8 6FH, 64H, 65H, 20H, 54H, 65H, 73H, 74H
   \              0x65 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \   00000498   0x20 0x45          DC8 20H, 45H, 78H, 61H, 6DH, 70H, 6CH, 65H
   \              0x78 0x61    
   \              0x6D 0x70    
   \              0x6C 0x65    
   \   000004A0   0x3A 0x0D          DC8 3AH, 0DH, 0AH, 54H, 68H, 69H, 73H, 20H
   \              0x0A 0x54    
   \              0x68 0x69    
   \              0x73 0x20    
   \   000004A8   0x69 0x73          DC8 69H, 73H, 20H, 6DH, 6BH, 73H, 52H, 6FH
   \              0x20 0x6D    
   \              0x6B 0x73    
   \              0x52 0x6F    
   \   000004B0   0x62 0x69          DC8 62H, 69H, 6EH, 50H, 72H, 6FH, 20H, 53H
   \              0x6E 0x50    
   \              0x72 0x6F    
   \              0x20 0x53    
   \   000004B8   0x54 0x4D          DC8 54H, 4DH, 33H, 32H, 46H, 34H, 30H, 37H
   \              0x33 0x32    
   \              0x46 0x34    
   \              0x30 0x37    
   \   000004C0   0x5A 0x45          DC8 5AH, 45H, 54H, 36H, 20H, 77H, 6FH, 72H
   \              0x54 0x36    
   \              0x20 0x77    
   \              0x6F 0x72    
   \   000004C8   0x6B 0x69          DC8 6BH, 69H, 6EH, 67H, 20H, 77H, 69H, 74H
   \              0x6E 0x67    
   \              0x20 0x77    
   \              0x69 0x74    
   \   000004D0   0x68 0x20          DC8 68H, 20H, 46H, 61H, 74H, 46H, 73H, 0DH
   \              0x46 0x61    
   \              0x74 0x46    
   \              0x73 0x0D    
   \   000004D8   0x0A 0x00          DC8 0AH, 0
   \   000004DA   0x00 0x00          DC8 0, 0
   \                     rtext:
   \   000004DC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000004EC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   000004FC   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000050C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000051C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000052C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000053C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000054C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .text, align 2, keep-with-next
    601          bool mksSdCardTest()
    602          {
   \                     mksSdCardTest: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
    603          	bool testStatus = false;
    604          
    605            FRESULT res;                                          /* FatFs function common result code */
    606            uint32_t byteswritten, bytesread;                     /* File write/read counts */
    607          
    608            /*##-1- Link the micro SD disk I/O driver ##################################*/
    609            //มดฝำ SD ตืฒใวถฏบฏสตฝ FATFS ฮฤผฯตอณฃฌีโธ๖ิฺ MX_FATFS_Init()บฏสึะาัพญอ๊ณษ
    610            //if(FATFS_LinkDriver(&SD_Driver, SD_Path) == 0)
    611            {
    612              /*##-2- Register the file system object to the FatFs module ##############*/
    613              if(f_mount(&SDFatFs, (TCHAR const*)SD_Path, 0) != FR_OK)
   \   00000004   0x....             LDR.N    R4,??DataTable19_5
   \   00000006   0x2200             MOVS     R2,#+0
   \   00000008   0x....             LDR.N    R1,??DataTable19_6
   \   0000000A   0x1D20             ADDS     R0,R4,#+4
   \   0000000C   0x.... 0x....      BL       f_mount
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD12E             BNE.N    ??mksSdCardTest_0
    614              {
    615                /* FatFs Initialization Error */
    616                Error_Handler();
    617              }
    618              else
    619              {
    620                /*##-3- Create a FAT file system (format) on the logical drive #########*/
    621                /* WARNING: Formatting the uSD card will delete all content on the device */
    622                //ถิ SD ฟจฝ๘ะะธ๑สฝปฏ
    623          #if 0
    624                if(f_mkfs((TCHAR const*)SD_Path, 0, 0) != FR_OK)
    625                {
    626                  /* FatFs Format Error */
    627                  Error_Handler();
    628                }
    629                else
    630          #endif        
    631                {       
    632                  /*##-4- Create and Open a new text file object with write access #####*/
    633                  if(f_open(&MyFile, "1:\STM32.TXT", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
                                               ^
Warning[Pe192]: unrecognized character escape sequence
   \   00000014   0xF504 0x750D      ADD      R5,R4,#+564
   \   00000018   0x.... 0x....      ADR.W    R6,`?<Constant "1:STM32.TXT">`
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x4631             MOV      R1,R6
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       f_open
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD123             BNE.N    ??mksSdCardTest_0
    634                  {
    635                    /* 'STM32.TXT' file Open for write Error */
    636                    Error_Handler();
    637                  }
    638                  else
    639                  {
    640                    /*##-5- Write data to the text file ################################*/
    641                    res = f_write(&MyFile, wtext, sizeof(wtext), (uint32_t *)&byteswritten);
   \   0000002A   0xF204 0x4760      ADDW     R7,R4,#+1120
   \   0000002E   0xAB01             ADD      R3,SP,#+4
   \   00000030   0x227A             MOVS     R2,#+122
   \   00000032   0x4639             MOV      R1,R7
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       f_write
    642                    
    643                    if((byteswritten == 0) || (res != FR_OK))
   \   0000003A   0x9901             LDR      R1,[SP, #+4]
   \   0000003C   0x2900             CMP      R1,#+0
   \   0000003E   0xD018             BEQ.N    ??mksSdCardTest_0
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD116             BNE.N    ??mksSdCardTest_0
    644                    {
    645                      /* 'STM32.TXT' file Write or EOF Error */
    646                      Error_Handler();
    647                    }
    648                    else
    649                    {
    650                      /*##-6- Close the open text file #################################*/
    651                      f_close(&MyFile);
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       f_close
    652                      
    653                      /*##-7- Open the text file object with read access ###############*/
    654                      if(f_open(&MyFile, "1:\STM32.TXT", FA_READ) != FR_OK)
                                                   ^
Warning[Pe192]: unrecognized character escape sequence
   \   0000004A   0x2201             MOVS     R2,#+1
   \   0000004C   0x4631             MOV      R1,R6
   \   0000004E   0x4628             MOV      R0,R5
   \   00000050   0x.... 0x....      BL       f_open
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD10C             BNE.N    ??mksSdCardTest_0
    655                      {
    656                        /* 'STM32.TXT' file Open for read Error */
    657                        Error_Handler();
    658                      }
    659                      else
    660                      {
    661                        /*##-8- Read data from the text file ###########################*/
    662                        res = f_read(&MyFile, rtext, sizeof(rtext), (UINT*)&bytesread);
   \   00000058   0xF204 0x46DC      ADDW     R6,R4,#+1244
   \   0000005C   0xAB00             ADD      R3,SP,#+0
   \   0000005E   0x2279             MOVS     R2,#+121
   \   00000060   0x4631             MOV      R1,R6
   \   00000062   0x4628             MOV      R0,R5
   \   00000064   0x.... 0x....      BL       f_read
    663                        
    664                        if((bytesread == 0) || (res != FR_OK))
   \   00000068   0x9900             LDR      R1,[SP, #+0]
   \   0000006A   0x2900             CMP      R1,#+0
   \   0000006C   0xD001             BEQ.N    ??mksSdCardTest_0
   \   0000006E   0x2800             CMP      R0,#+0
   \   00000070   0xD002             BEQ.N    ??mksSdCardTest_1
    665                        {
    666                          /* 'STM32.TXT' file Read or EOF Error */
    667                          Error_Handler();
   \                     ??mksSdCardTest_0: (+1)
   \   00000072   0x.... 0x....      BL       Error_Handler
   \   00000076   0xBDFE             POP      {R1-R7,PC}
    668                        }
    669                        else
    670                        {
    671                          /*##-9- Close the open text file #############################*/
    672                          f_close(&MyFile);
   \                     ??mksSdCardTest_1: (+1)
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       f_close
    673                          
    674                          /*##-10- Compare read data with the expected data ############*/
    675                          TransferStatusSD = Buffercmp(wtext, rtext, sdBufferSize);
   \   0000007E   0x2279             MOVS     R2,#+121
   \   00000080   0x4631             MOV      R1,R6
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x.... 0x....      BL       _Z9BuffercmpPhS_t
   \   00000088   0x7020             STRB     R0,[R4, #+0]
    676                          if(PASSED == TransferStatusSD)
   \   0000008A   0xF994 0x0000      LDRSB    R0,[R4, #+0]
    677                          {                
    678                            /* Success of the demo: no error occurrence */
    679                            //HAL_Delay(10);    //ok
    680                            testStatus = true;
    681                          }
    682                          else
    683                          {
    684                          testStatus = false;
    685                            //Error_Handler();
    686                          }
    687                        }
    688                      }
    689                    }
    690                  }
    691                }
    692              }
    693            }
    694          
    695          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "mksSdCardTest"

  	bool testStatus = false;
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\mks_test.cpp",603  Warning[Pe550]: 
          variable "testStatus" was set but never used
   \   0000008E   0xBDFE             POP      {R1-R7,PC}       ;; return
    696          /*---------------------SDIO+FATFS TEST END--------------------------*/
    697          
    698          #if 0
    699          /*---------------------USB+FATFS TEST BEGIN------------------------*/
    700          extern ApplicationTypeDef Appli_state;
    701          FATFS USBDISKFatFs;           /* File system object for USB disk logical drive */
    702          FIL usbFile;                   /* File object */
    703          //char USBDISKPath[4];          /* USB Host logical drive path */
    704          USBH_HandleTypeDef hUSB_Host; /* USB Host handle */
    705          volatile TestStatus TransferStatusUSB = FAILED;
    706          char usbStatus = 0;
    707          
    708          void usbFileReadTest(void);
    709          void MSC_Application();
    710          void mksUSBTest()
    711          {
    712            static ApplicationTypeDef pre_state = APPLICATION_IDLE;
    713            volatile FRESULT fr;
    714            FATFS fs;
    715            FIL fil;
    716            UINT off = 0;
    717            uint8_t buff[20];
    718            long counter = 0;  
    719            usbStatus = 0;
    720            while (1)
    721            {
    722          	counter++;
    723              MX_USB_HOST_Process();
    724          
    725                switch(Appli_state)
    726                {
    727                //case APPLICATION_START:
    728                case APPLICATION_READY:
    729                  MSC_Application();
    730                  usbFileReadTest();
    731                  Appli_state = APPLICATION_IDLE;
    732                  break;
    733                  
    734                case APPLICATION_IDLE:
    735                default:
    736                  break;      
    737                } 
    738          
    739          	if(usbStatus) break;
    740          	if(counter > 100000)	break;
    741            }
    742          
    743          
    744            if(usbStatus == 1)
    745            {
    746              SERIAL_PROTOCOLLNPGM("U-Disk OK.");
    747              GUI_DispStringAt("U-Disk OK.", 10, 120);
    748            }
    749            else if(usbStatus == 2) 
    750            {
    751              SERIAL_PROTOCOLLNPGM("U-Disk ERR!");
    752              GUI_DispStringAt("U-Disk ERR!", 10, 120);
    753            }
    754            else
    755            {
    756              SERIAL_PROTOCOLLNPGM("U-Disk was not detected!");
    757              GUI_DispStringAt("U-Disk was not detected!", 10, 120);
    758            }
    759          }
    760          
    761          static void MSC_Application(void)
    762          {
    763          #if unused
    764            #define usbBufferSize (countof(usbwtext)-1)
    765            FRESULT res;                                          /* FatFs function common result code */
    766            uint32_t byteswritten, bytesread;                     /* File write/read counts */
    767            //uint8_t usbwtext[] = "This is mksRobinPro working with USB-FatFs."; /* File write buffer */
    768            uint8_t usbwtext[] = "This is mksRobinPro working with USB-FatFs Start. 1. Redistribution of source code must retain the above copyright notice,2. Redistributions in binary form must reproduce the above copyright notice,and/or other materials provided with the distribution.3. Neither the name of STMicroelectronics nor the names of other contributors to this software may be used to endorse or promote products derived from this software without specific written permission. 4. This software, including modifications and/or derivative works of this software, must execute solely and exclusively on microcontroller or microprocessor devices manufactured by or for STMicroelectronics. 5. Redistribution and use of this software other than as permitted under this license is void and will automatically terminate your rights under  this license. 6.Redistribution and use in source and binary forms, with or without modification, are permitted, provided that the following conditions are met. This is mksRobinPro working with USB-FatFs End.";
    769            uint8_t usbrtext[usbBufferSize];                                   /* File read buffer */
    770            
    771            /* Register the file system object to the FatFs module */
    772            if(f_mount(&USBDISKFatFs, (TCHAR const*)USBH_Path, 0) != FR_OK)
    773            {
    774              /* FatFs Initialization Error */
    775              Error_Handler();
    776            }
    777            else
    778            {
    779              HAL_Delay(10);
    780              /* Create and Open a new text file object with write access */
    781              //if(f_open(&usbFile, "STM32.TXT", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK) 
    782              if(f_open(&usbFile, "0:/STM32_USB.TXT", FA_READ | FA_WRITE | FA_CREATE_ALWAYS) != FR_OK) 
    783              {   
    784                /* 'STM32.TXT' file Open for write Error */
    785                Error_Handler();
    786              }
    787              else
    788              {
    789                /* Write data to the text file */
    790                res = f_write(&usbFile, usbwtext, sizeof(usbwtext), &byteswritten);
    791                
    792                if((byteswritten == 0) || (res != FR_OK))
    793                {
    794                  /* 'STM32.TXT' file Write or EOF Error */
    795                  Error_Handler();
    796                }
    797                else
    798                {
    799                  /* Close the open text file */
    800                  f_close(&usbFile);
    801                  
    802                  /* Open the text file object with read access */
    803                  if(f_open(&usbFile, "0:/STM32_USB.TXT", FA_READ) != FR_OK)
    804                  {
    805                    /* 'STM32.TXT' file Open for read Error */
    806                    Error_Handler();
    807                  }
    808                  else
    809                  {
    810                    /* Read data from the text file */
    811                    res = f_read(&usbFile, usbrtext, sizeof(usbrtext), &bytesread);
    812                    
    813                    if((bytesread == 0) || (res != FR_OK))
    814                    {
    815                      /* 'STM32.TXT' file Read or EOF Error */
    816                      Error_Handler();
    817                    }
    818                    else
    819                    {
    820                      /* Close the open text file */
    821                      f_close(&usbFile);
    822                      
    823                      /* Compare read data with the expected data */
    824                          TransferStatusUSB = Buffercmp(usbwtext, usbrtext, usbBufferSize);
    825                          if(PASSED == TransferStatusUSB)
    826                          {                
    827                            /* Success of the demo: no error occurrence */
    828                            //HAL_Delay(10);    //ok
    829                            usbStatus = 1;
    830                          }
    831                          else
    832                          {
    833                            //Error_Handler();
    834                            usbStatus = 2;
    835                          }
    836          
    837                    }
    838                  }
    839                }
    840              }
    841            }
    842          /*-------------  usbFileReadTest --------------*/
    843          /*  
    844              volatile long usbReadCnt=0;
    845              while(usbReadCnt++ < 10000)
    846              {
    847                if(f_open(&usbFile, "0:/STM32_USB.TXT", FA_READ) != FR_OK) Error_Handler();
    848                res = f_read(&usbFile, usbrtext, sizeof(usbrtext), &bytesread);
    849                if((bytesread == 0) || (res != FR_OK))   Error_Handler();
    850                f_close(&usbFile);
    851                TransferStatusUSB = Buffercmp(usbwtext, usbrtext, usbBufferSize);
    852                if(PASSED != TransferStatusUSB)  Error_Handler();
    853                memcpy(&usbrtext,0,usbBufferSize); 
    854              }
    855              HAL_Delay(10);
    856          */  
    857          /*-------------  usbFileReadTest --------------*/  
    858            /* Unlink the USB disk I/O driver */
    859            //FATFS_UnLinkDriver(USBH_Path);
    860          
    861          #endif
    862          }
    863          
    864          static void usbFileReadTest(void)
    865          {
    866          }
    867          #endif
    868          /*---------------------USB+FATFS TEST END--------------------------*/
    869          
    870          /*---------------------TFT-LCD TEST BEGIN--------------------------*/

   \                                 In section .text, align 2, keep-with-next
    871          void mksTFTLCDTest()
    872          {
    873            
    874          }
   \                     _Z13mksTFTLCDTestv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    875          /*---------------------TFT-LCD TEST END--------------------------*/
    876          
    877          /*---------------------mksHardwareTest BEGIN--------------------------*/
    878          volatile char mksStepperState=0;
    879          volatile uint32_t testCnt=0;
    880          
    881          

   \                                 In section .text, align 2, keep-with-next
    882          void mksStepperTest()
    883          {
   \                     mksStepperTest: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
    884          	if(mksStepperState == 0)
   \   00000002   0x....             LDR.N    R1,??DataTable19_7  ;; 0x42210198
   \   00000004   0x....             LDR.N    R2,??DataTable19_8  ;; 0x42228198
   \   00000006   0x....             LDR.N    R3,??DataTable19_9  ;; 0x42218194
   \   00000008   0x....             LDR.N    R4,??DataTable19_10  ;; 0x42230180
   \   0000000A   0x....             LDR.N    R0,??DataTable19_11
   \   0000000C   0xF990 0x5000      LDRSB    R5,[R0, #+0]
   \   00000010   0x2D00             CMP      R5,#+0
   \   00000012   0xD10B             BNE.N    ??mksStepperTest_0
    885          	{
    886          		XSTEP_OP =0;YSTEP_OP =0;ZSTEP_OP =0;E0STEP_OP =0;E1STEP_OP =0;
   \   00000014   0x2500             MOVS     R5,#+0
   \   00000016   0x60E5             STR      R5,[R4, #+12]
   \   00000018   0x6025             STR      R5,[R4, #+0]
   \   0000001A   0x462C             MOV      R4,R5
   \   0000001C   0x601C             STR      R4,[R3, #+0]
   \   0000001E   0x4623             MOV      R3,R4
   \   00000020   0x6013             STR      R3,[R2, #+0]
   \   00000022   0x461A             MOV      R2,R3
   \   00000024   0x600A             STR      R2,[R1, #+0]
    887          		mksStepperState = 1;
   \   00000026   0x2101             MOVS     R1,#+1
   \   00000028   0x7001             STRB     R1,[R0, #+0]
   \   0000002A   0xE00A             B.N      ??mksStepperTest_1
    888          	}
    889          	else
    890          	{
    891          		XSTEP_OP =1;YSTEP_OP =1;ZSTEP_OP =1;E0STEP_OP =1;E1STEP_OP =1;
   \                     ??mksStepperTest_0: (+1)
   \   0000002C   0x2501             MOVS     R5,#+1
   \   0000002E   0x60E5             STR      R5,[R4, #+12]
   \   00000030   0x6025             STR      R5,[R4, #+0]
   \   00000032   0x462C             MOV      R4,R5
   \   00000034   0x601C             STR      R4,[R3, #+0]
   \   00000036   0x4623             MOV      R3,R4
   \   00000038   0x6013             STR      R3,[R2, #+0]
   \   0000003A   0x461A             MOV      R2,R3
   \   0000003C   0x600A             STR      R2,[R1, #+0]
    892          		mksStepperState = 0;
   \   0000003E   0x2100             MOVS     R1,#+0
   \   00000040   0x7001             STRB     R1,[R0, #+0]
    893          	}
    894          	testCnt++;
   \                     ??mksStepperTest_1: (+1)
   \   00000042   0x6841             LDR      R1,[R0, #+4]
   \   00000044   0x1C49             ADDS     R1,R1,#+1
   \   00000046   0x6041             STR      R1,[R0, #+4]
    895          }	
   \   00000048   0xBC30             POP      {R4,R5}
   \   0000004A   0x4770             BX       LR               ;; return
    896          

   \                                 In section .text, align 2, keep-with-next
    897          void mksGpioTest()
    898          {
    899          #if 0
    900          			if(testCnt % 100 ==75)
    901          				{
    902          				mksEndStopsCnt = 0;
    903          				memset(mksEndStopsBuf,0,sizeof(mksEndStopsBuf));
    904          				
    905          				if(!XMIN_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"X ");}				//PC13
    906          				if(!YMIN_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"Y ");}				//PC0
    907          				if(!ZMIN_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"Z- ");}				//PC12
    908          				if(!ZMAX_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"Z+ ");}				//PB9
    909          	
    910          				if(!FIL_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"FIL ");}				//PB8
    911          				if(!PWM_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"PWM ");}				//PA11
    912          				if(!BT_ENC_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"ENC ");}			//PB3
    913          				if(!BT_EN1_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"EN1 ");}			//PB5
    914          				if(!BT_EN2_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"EN2 ");}			//PB4
    915          	
    916          	
    917          				if(!WIFI_IO1) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"IO1 ");} 		//PC7
    918          				if(!WIFI_IO2) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"IO2 ");} 		//PC11
    919          				if(!WIFI_CTL) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"CTL ");} 		//PA12
    920          				if(!WIFI_RX) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"RX ");}			//PA3
    921          				if(!WIFI_TX) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"TX ");}			//PA2
    922          	
    923          				}
    924          			if(testCnt % 100 ==25)
    925          				{
    926          				mksEndStopsCnt = 0;
    927          				memset(mksEndStopsBuf,0,sizeof(mksEndStopsBuf));
    928          				
    929          				if(XMIN_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"X ");} 				//PC13
    930          				if(YMIN_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"Y ");} 				//PC0
    931          				if(ZMIN_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"Z- ");}				//PC12
    932          				if(ZMAX_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"Z+ ");}				//PB9
    933          	
    934          				if(FIL_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"FIL ");}				//PB8
    935          				if(PWM_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"PWM ");}				//PA11
    936          				if(BT_ENC_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"ENC ");} 			//PB3
    937          				if(BT_EN1_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"EN1 ");} 			//PB5
    938          				if(BT_EN2_OP) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"EN2 ");} 			//PB4
    939          	
    940          				if(WIFI_IO1) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"IO1 ");}			//PC7
    941          				if(WIFI_IO2) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"IO2 ");}			//PC11
    942          				if(WIFI_CTL) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"CTL ");}			//PA12
    943          				if(WIFI_RX) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"RX ");}			//PA3
    944          				if(WIFI_TX) {mksEndStopsCnt++;strcat(mksEndStopsBuf,"TX ");}			//PA2
    945          				
    946          				}
    947          #endif		
    948          
    949          }
   \                     _Z11mksGpioTestv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    950          
    951          static int cnt_test=0;
    952          

   \                                 In section .text, align 2, keep-with-next
    953          void mksHardwareTest()
    954          {
   \                     mksHardwareTest: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    955          
    956          
    957              static char buf_test[50];
    958              static uint32_t ix;
                                     ^
Warning[Pe177]: variable "ix" was declared but never referenced

  static int cnt_test=0;
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\mks_test.cpp",951  Warning[Pe177]: 
          variable "cnt_test" was declared but never referenced

  		if(eppr_r[i] != eppr_w[i])
  		^
"E:\code\Robin_Nano_SVN\branches\robin_nano35ิดย๋\robin_nano35_v1.0.4_source\Src\mks_test.cpp",446  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
    959          	/*------------------------------------------------------------*/
    960          #if 0
    961          
    962          		
    963                  if(mksEeprom_test())
    964                  {   
    965                      SERIAL_PROTOCOLLNPGM("EEPROM OK.");
    966                      GUI_DispStringAt("EEPROM OK.", 10, 30);
    967                  }
    968          		else
    969                  {      
    970                      SERIAL_PROTOCOLLNPGM("EEPROM ERR!");
    971                      GUI_DispStringAt("EEPROM ERR.", 10, 30);
    972                  }
    973          
    974          		if(mksW25Q64Test())
    975                  {      
    976                      SERIAL_PROTOCOLLNPGM("W25Q64 OK.");
    977                      GUI_DispStringAt("W25Q64 OK.", 10, 60);
    978                  }
    979          		else 
    980                  {    
    981                      SERIAL_PROTOCOLLNPGM("W25Q64 ERR!");
    982                      GUI_DispStringAt("W25Q64 ERR.", 10, 60);
    983                  }
    984          
    985          		if(SD_DET_IP == 0)
    986          		{
    987          			if(mksSdCardTest())
    988                      {         
    989                          SERIAL_PROTOCOLLNPGM("SD card OK.");
    990                          GUI_DispStringAt("SD card OK.", 10, 90);
    991                       }
    992          			else
    993                      {         
    994                          SERIAL_PROTOCOLLNPGM("SD card ERR!");
    995                          GUI_DispStringAt("SD card ERR!", 10, 90);
    996                       }
    997          		}
    998          		else
    999                  {  
   1000          				SERIAL_PROTOCOLLNPGM("SD card was not detected!");
   1001                          GUI_DispStringAt("SD card was not detected!", 10, 90);
   1002                   }
   1003          #endif        
   1004          #if unused
   1005          		mksUSBTest();			
   1006          #endif
   1007          	/*------------------------------------------------------------*/
   1008          
   1009          
   1010          		XENA_OP = 0;YENA_OP = 0;ZENA_OP = 0;E0ENA_OP = 0;E1ENA_OP = 0;
   \   00000004   0x....             LDR.N    R7,??DataTable19_12  ;; 0x42230184
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0x60F8             STR      R0,[R7, #+12]
   \   0000000A   0x6038             STR      R0,[R7, #+0]
   \   0000000C   0x....             LDR.N    R5,??DataTable19_13  ;; 0x42218180
   \   0000000E   0x6228             STR      R0,[R5, #+32]
   \   00000010   0x60E8             STR      R0,[R5, #+12]
   \   00000012   0x....             LDR.N    R6,??DataTable19_14  ;; 0x42210180
   \   00000014   0x60F0             STR      R0,[R6, #+12]
   1011          		
   1012                  thermalManager.init();
   \   00000016   0x....             LDR.N    R0,??DataTable19_15
   \   00000018   0x.... 0x....      BL       _ZN11Temperature4initEv
   1013          
   1014          		
   1015          		//while(cnt_test<3)
   1016          		{
   1017          		  //cnt_test++;
   1018                    
   1019          		  if(testCnt % 2000 > 1000)	//ต็ป๚ทฝฯ๒ฟุึฦ
   \   0000001C   0x....             LDR.N    R4,??DataTable19_11
   \   0000001E   0x6863             LDR      R3,[R4, #+4]
   \   00000020   0x....             LDR.N    R2,??DataTable19_16  ;; 0x4222818c
   \   00000022   0xF240 0x30E9      MOVW     R0,#+1001
   \   00000026   0xF44F 0x61FA      MOV      R1,#+2000
   \   0000002A   0x468C             MOV      R12,R1
   \   0000002C   0xFBB3 0xFCFC      UDIV     R12,R3,R12
   \   00000030   0xFB01 0x331C      MLS      R3,R1,R12,R3
   \   00000034   0x4283             CMP      R3,R0
   \   00000036   0xD307             BCC.N    ??mksHardwareTest_0
   1020          			{XDIR_OP = 0;YDIR_OP = 0;ZDIR_OP = 0;E0DIR_OP = 0;E1DIR_OP = 0;}
   \   00000038   0x2300             MOVS     R3,#+0
   \   0000003A   0x607B             STR      R3,[R7, #+4]
   \   0000003C   0x626B             STR      R3,[R5, #+36]
   \   0000003E   0x612B             STR      R3,[R5, #+16]
   \   00000040   0x6013             STR      R3,[R2, #+0]
   \   00000042   0x461A             MOV      R2,R3
   \   00000044   0x6072             STR      R2,[R6, #+4]
   \   00000046   0xE006             B.N      ??mksHardwareTest_1
   1021          		  else
   1022          			  {XDIR_OP = 1;YDIR_OP = 1;ZDIR_OP = 1;E0DIR_OP = 1;E1DIR_OP = 1;}
   \                     ??mksHardwareTest_0: (+1)
   \   00000048   0x2301             MOVS     R3,#+1
   \   0000004A   0x607B             STR      R3,[R7, #+4]
   \   0000004C   0x626B             STR      R3,[R5, #+36]
   \   0000004E   0x612B             STR      R3,[R5, #+16]
   \   00000050   0x6013             STR      R3,[R2, #+0]
   \   00000052   0x461A             MOV      R2,R3
   \   00000054   0x6072             STR      R2,[R6, #+4]
   1023          		  //า๒ฮชผทณ๖อท2ฟุฮยนฝลำ๋ท็ษศถจสฑฦ๗ธดำรฃฌ
   1024          		  //ห๙าิล็อท2ฟุฮยึธสพตฦปแษมหธ
   1025          		  if(testCnt % 2000 > 1000)   //MOSฟุึฦ
   \                     ??mksHardwareTest_1: (+1)
   \   00000056   0x6867             LDR      R7,[R4, #+4]
   \   00000058   0x....             LDR.N    R2,??DataTable19_17  ;; 0x40000440
   \   0000005A   0x....             LDR.N    R3,??DataTable19_18  ;; 0x4222018c
   \   0000005C   0x468C             MOV      R12,R1
   \   0000005E   0xFBB7 0xFCFC      UDIV     R12,R7,R12
   \   00000062   0xFB01 0x711C      MLS      R1,R1,R12,R7
   \   00000066   0x4281             CMP      R1,R0
   \   00000068   0xD307             BCC.N    ??mksHardwareTest_2
   1026          			{BED_OP=1;HEATER1_OP=1;HEATER2_OP=1;MKS_FAN_TIM = 10000;}
   \   0000006A   0x2001             MOVS     R0,#+1
   \   0000006C   0x6030             STR      R0,[R6, #+0]
   \   0000006E   0x6018             STR      R0,[R3, #+0]
   \   00000070   0x6028             STR      R0,[R5, #+0]
   \   00000072   0xF242 0x7010      MOVW     R0,#+10000
   \   00000076   0x6010             STR      R0,[R2, #+0]
   \   00000078   0xE004             B.N      ??mksHardwareTest_3
   1027          		  else
   1028          			{BED_OP=0;HEATER1_OP=0;HEATER2_OP=0;MKS_FAN_TIM = 0;}
   \                     ??mksHardwareTest_2: (+1)
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x6030             STR      R0,[R6, #+0]
   \   0000007E   0x6018             STR      R0,[R3, #+0]
   \   00000080   0x6028             STR      R0,[R5, #+0]
   \   00000082   0x6010             STR      R0,[R2, #+0]
   1029          
   1030          		  //mksGpioTest();
   1031                    Test_GPIO();
   \                     ??mksHardwareTest_3: (+1)
   \   00000084   0x.... 0x....      BL       Test_GPIO
   1032          
   1033          		  thermalManager.manage_heater();
   \   00000088   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   1034                    //ix=1000;
   1035                    //while(ix--)
   1036                    //{;}
   1037                    sprintf(buf_test, "T0:%0.3f T1:%0.3f B:%0.3f",thermalManager.current_temperature[0],thermalManager.current_temperature[1],thermalManager.current_temperature_bed);
   \   0000008C   0x....             LDR.N    R5,??DataTable19_19
   \   0000008E   0x....             LDR.N    R0,??DataTable19_20
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x.... 0x....      BL       __aeabi_f2d
   \   00000096   0xE9CD 0x0102      STRD     R0,R1,[SP, #+8]
   \   0000009A   0x6868             LDR      R0,[R5, #+4]
   \   0000009C   0x.... 0x....      BL       __aeabi_f2d
   \   000000A0   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   000000A4   0x6828             LDR      R0,[R5, #+0]
   \   000000A6   0x.... 0x....      BL       __aeabi_f2d
   \   000000AA   0x4602             MOV      R2,R0
   \   000000AC   0x460B             MOV      R3,R1
   \   000000AE   0x.... 0x....      ADR.W    R1,`?<Constant "T0:%0.3f T1:%0.3f B:%...">`
   \   000000B2   0xF104 0x0008      ADD      R0,R4,#+8
   \   000000B6   0x.... 0x....      BL       sprintf
   1038                    
   1039                    GUI_DispStringAt(buf_test, 10, 30);
   \   000000BA   0x221E             MOVS     R2,#+30
   \   000000BC   0x210A             MOVS     R1,#+10
   \   000000BE   0xF104 0x0008      ADD      R0,R4,#+8
   \   000000C2   0xB005             ADD      SP,SP,#+20
   \   000000C4   0xE8BD 0x40F0      POP      {R4-R7,LR}
   \   000000C8   0x.... 0x....      B.W      GUI_DispStringAt
   1040          	      //test_screen();
   1041          
   1042          		}
   1043          
   1044          
   1045          }

   \                                 In section .bss, align 4
   \                     mksStepperState:
   \   00000000                      DS8 1
   \   00000001                      DS8 3
   \                     testCnt:
   \   00000004                      DS8 4
   \   00000008                      DS8 52
   1046          
   1047          /*---------------------mksHardwareTest END--------------------------*/

   \                                 In section .bss, align 4
   1048          static GUI_HWIN hHardwaretestWnd;
   \                     hHardwaretestWnd:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 24
   1049          static BUTTON_STRUCT buttonRet;
   1050          void Clear_Hardwaretest();
   1051          

   \                                 In section .text, align 2, keep-with-next
   1052          static void cbHardwaretestWin(WM_MESSAGE * pMsg) {
   1053          
   1054          	switch (pMsg->MsgId)
   \                     _Z17cbHardwaretestWinP10WM_MESSAGE: (+1)
   \   00000000   0x6801             LDR      R1,[R0, #+0]
   \   00000002   0x290C             CMP      R1,#+12
   \   00000004   0xD100             BNE.N    ??cbHardwaretestWin_0
   \   00000006   0x4770             BX       LR
   \                     ??cbHardwaretestWin_0: (+1)
   \   00000008   0xB580             PUSH     {R7,LR}
   \   0000000A   0x290D             CMP      R1,#+13
   \   0000000C   0xD033             BEQ.N    ??cbHardwaretestWin_1
   \   0000000E   0x290F             CMP      R1,#+15
   \   00000010   0xD031             BEQ.N    ??cbHardwaretestWin_1
   \   00000012   0x2926             CMP      R1,#+38
   \   00000014   0xD12B             BNE.N    ??cbHardwaretestWin_2
   1055          	{
   1056          		case WM_PAINT:
   1057          
   1058          			break;
   1059          		case WM_TOUCH:
   1060          		 	
   1061          			break;
   1062          		case WM_TOUCH_CHILD:
   1063          			
   1064          			break;
   1065          			
   1066          		case WM_NOTIFY_PARENT:
   1067          			if(pMsg->Data.v == WM_NOTIFICATION_RELEASED)
   \   00000016   0x6881             LDR      R1,[R0, #+8]
   \   00000018   0x2902             CMP      R1,#+2
   \   0000001A   0xD12C             BNE.N    ??cbHardwaretestWin_1
   1068          			{
   1069          				if(pMsg->hWinSrc == buttonRet.btnHandle)
   \   0000001C   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000020   0x....             LDR.N    R1,??DataTable19_21
   \   00000022   0xF9B1 0x1004      LDRSH    R1,[R1, #+4]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD125             BNE.N    ??cbHardwaretestWin_1
   1070          				{
   1071          				    //cnt_test=0;
   1072          				    XENA_OP = 0;YENA_OP = 0;ZENA_OP = 0;E0ENA_OP = 0;E1ENA_OP = 0;
   \   0000002A   0x....             LDR.N    R0,??DataTable19_12  ;; 0x42230184
   \   0000002C   0x2100             MOVS     R1,#+0
   \   0000002E   0x60C1             STR      R1,[R0, #+12]
   \   00000030   0x6001             STR      R1,[R0, #+0]
   \   00000032   0x....             LDR.N    R0,??DataTable19_13  ;; 0x42218180
   \   00000034   0x6201             STR      R1,[R0, #+32]
   \   00000036   0x60C1             STR      R1,[R0, #+12]
   \   00000038   0x....             LDR.N    R1,??DataTable19_14  ;; 0x42210180
   \   0000003A   0x2200             MOVS     R2,#+0
   \   0000003C   0x60CA             STR      R2,[R1, #+12]
   1073                              BED_OP=0;HEATER1_OP=0;HEATER2_OP=0;MKS_FAN_TIM = 0;
   \   0000003E   0x600A             STR      R2,[R1, #+0]
   \   00000040   0x4611             MOV      R1,R2
   \   00000042   0x....             LDR.N    R2,??DataTable19_18  ;; 0x4222018c
   \   00000044   0x6011             STR      R1,[R2, #+0]
   \   00000046   0x6001             STR      R1,[R0, #+0]
   \   00000048   0x4608             MOV      R0,R1
   \   0000004A   0x....             LDR.N    R1,??DataTable19_17  ;; 0x40000440
   \   0000004C   0x6008             STR      R0,[R1, #+0]
   1074          				    mksTmp.cfg_hardware_test_enable=0;
   \   0000004E   0x....             LDR.N    R1,??DataTable19_22
   \   00000050   0x74C8             STRB     R0,[R1, #+19]
   1075                              last_disp_state = HARDWARE_TEST_UI;
   \   00000052   0x2021             MOVS     R0,#+33
   \   00000054   0x....             LDR.N    R1,??DataTable19_23
   \   00000056   0x7008             STRB     R0,[R1, #+0]
   1076          					GUI_UC_SetEncodeUTF8();
   \   00000058   0x.... 0x....      BL       GUI_UC_SetEncodeUTF8
   1077          					GUI_SetFont(&FONT_TITLE);
   \   0000005C   0x....             LDR.N    R0,??DataTable19_24
   \   0000005E   0x.... 0x....      BL       GUI_SetFont
   1078          					Clear_Hardwaretest();
   \   00000062   0x.... 0x....      BL       Clear_Hardwaretest
   1079          					draw_ready_print();
   \   00000066   0xE8BD 0x4001      POP      {R0,LR}
   \   0000006A   0x.... 0x....      B.W      draw_ready_print
   1080          				}
   1081          				
   1082          			}
   1083          			break;
   1084          			
   1085          		default:
   1086          			WM_DefaultProc(pMsg);
   \                     ??cbHardwaretestWin_2: (+1)
   \   0000006E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000072   0x.... 0x....      B.W      WM_DefaultProc
   1087          		}
   1088          	}
   \                     ??cbHardwaretestWin_1: (+1)
   \   00000076   0xBD01             POP      {R0,PC}          ;; return
   1089          

   \                                 In section .text, align 2, keep-with-next
   1090          void draw_Hardwaretest()
   1091          {
   \                     draw_Hardwaretest: (+1)
   \   00000000   0xB57F             PUSH     {R0-R6,LR}
   1092          	if(disp_state_stack._disp_state[disp_state_stack._disp_index] != HARDWARE_TEST_UI)
   \   00000002   0x....             LDR.N    R0,??DataTable19_25
   \   00000004   0xF990 0x1064      LDRSB    R1,[R0, #+100]
   \   00000008   0x560A             LDRSB    R2,[R1, R0]
   \   0000000A   0x2A21             CMP      R2,#+33
   \   0000000C   0xD005             BEQ.N    ??draw_Hardwaretest_0
   1093          	{
   1094          		disp_state_stack._disp_index++;
   \   0000000E   0x1C49             ADDS     R1,R1,#+1
   \   00000010   0xF880 0x1064      STRB     R1,[R0, #+100]
   1095          		disp_state_stack._disp_state[disp_state_stack._disp_index] = HARDWARE_TEST_UI;
   \   00000014   0x2221             MOVS     R2,#+33
   \   00000016   0xB249             SXTB     R1,R1
   \   00000018   0x540A             STRB     R2,[R1, R0]
   1096          	}
   1097          	disp_state = HARDWARE_TEST_UI;
   \                     ??draw_Hardwaretest_0: (+1)
   \   0000001A   0x2021             MOVS     R0,#+33
   \   0000001C   0x....             LDR.N    R1,??DataTable19_26
   \   0000001E   0x7008             STRB     R0,[R1, #+0]
   1098          
   1099              GUI_SetBkColor(gCfgItems.background_color);
   \   00000020   0x....             LDR.N    R4,??DataTable19_4
   \   00000022   0x6860             LDR      R0,[R4, #+4]
   \   00000024   0x.... 0x....      BL       GUI_SetBkColor
   1100          	GUI_SetColor(gCfgItems.title_color);
   \   00000028   0x1D25             ADDS     R5,R4,#+4
   \   0000002A   0x6868             LDR      R0,[R5, #+4]
   \   0000002C   0x.... 0x....      BL       GUI_SetColor
   1101          	GUI_Clear();
   \   00000030   0x.... 0x....      BL       GUI_Clear
   1102          
   1103          	GUI_UC_SetEncodeNone();
   \   00000034   0x.... 0x....      BL       GUI_UC_SetEncodeNone
   1104          	GUI_SetFont(&GUI_FontHZ16);
   \   00000038   0x....             LDR.N    R0,??DataTable19_27
   \   0000003A   0x.... 0x....      BL       GUI_SetFont
   1105          
   1106          /*---------------------------------------------------------------------------*/
   1107          //นฝลฒโสิ
   1108          	Test_GPIO();
   \   0000003E   0x.... 0x....      BL       Test_GPIO
   1109          	
   1110          /*---------------------------------------------------------------------------*/
   1111          	hHardwaretestWnd = WM_CreateWindow(LCD_WIDTH * 3 / 4 , titleHeight + imgHeight / 2, LCD_WIDTH / 4 - 1, imgHeight / 2 - 1, WM_CF_SHOW, cbHardwaretestWin, 0);
   \   00000042   0x....             LDR.N    R6,??DataTable19_21
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x9002             STR      R0,[SP, #+8]
   \   00000048   0x....             LDR.N    R0,??DataTable19_28
   \   0000004A   0x9001             STR      R0,[SP, #+4]
   \   0000004C   0x2002             MOVS     R0,#+2
   \   0000004E   0x9000             STR      R0,[SP, #+0]
   \   00000050   0x238D             MOVS     R3,#+141
   \   00000052   0x2277             MOVS     R2,#+119
   \   00000054   0x21B2             MOVS     R1,#+178
   \   00000056   0xF44F 0x70B4      MOV      R0,#+360
   \   0000005A   0x.... 0x....      BL       WM_CreateWindow
   \   0000005E   0x8030             STRH     R0,[R6, #+0]
   1112          	
   1113          	buttonRet.btnHandle = BUTTON_CreateEx(0 , 0, LCD_WIDTH / 4 - 2, imgHeight / 2 - 1, hHardwaretestWnd, BUTTON_CF_SHOW, 0, alloc_win_id());
   \   00000060   0x.... 0x....      BL       alloc_win_id
   \   00000064   0x9003             STR      R0,[SP, #+12]
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x9002             STR      R0,[SP, #+8]
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x9001             STR      R0,[SP, #+4]
   \   0000006E   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000072   0x9000             STR      R0,[SP, #+0]
   \   00000074   0x238D             MOVS     R3,#+141
   \   00000076   0x2276             MOVS     R2,#+118
   \   00000078   0x2100             MOVS     R1,#+0
   \   0000007A   0x4608             MOV      R0,R1
   \   0000007C   0x.... 0x....      BL       BUTTON_CreateEx
   \   00000080   0x80B0             STRH     R0,[R6, #+4]
   1114          
   1115          	BUTTON_SetBmpFileName(buttonRet.btnHandle, "bmp_return.bin",1);	
   \   00000082   0x2201             MOVS     R2,#+1
   \   00000084   0x.... 0x....      ADR.W    R1,`?<Constant "bmp_return.bin">`
   \   00000088   0x.... 0x....      BL       BUTTON_SetBmpFileName
   1116          	BUTTON_SetBitmapEx(buttonRet.btnHandle, 0, &bmp_struct,BMP_PIC_X, BMP_PIC_Y); 
   \   0000008C   0x....             LDR.N    R0,??DataTable19_29
   \   0000008E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000092   0x9000             STR      R0,[SP, #+0]
   \   00000094   0x....             LDR.N    R0,??DataTable19_30
   \   00000096   0xF990 0x3000      LDRSB    R3,[R0, #+0]
   \   0000009A   0x....             LDR.N    R2,??DataTable19_31
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000A2   0x.... 0x....      BL       BUTTON_SetBitmapEx
   1117              
   1118          	BUTTON_SetBkColor(buttonRet.btnHandle, BUTTON_CI_PRESSED, gCfgItems.back_btn_color);
   \   000000A6   0x6BAA             LDR      R2,[R5, #+56]
   \   000000A8   0x2101             MOVS     R1,#+1
   \   000000AA   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000AE   0x.... 0x....      BL       BUTTON_SetBkColor
   1119          	BUTTON_SetBkColor(buttonRet.btnHandle, BUTTON_CI_UNPRESSED, gCfgItems.back_btn_color);
   \   000000B2   0x6BAA             LDR      R2,[R5, #+56]
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000BA   0x.... 0x....      BL       BUTTON_SetBkColor
   1120          	BUTTON_SetTextColor(buttonRet.btnHandle, BUTTON_CI_PRESSED, gCfgItems.back_btn_textcolor);
   \   000000BE   0x6BEA             LDR      R2,[R5, #+60]
   \   000000C0   0x2101             MOVS     R1,#+1
   \   000000C2   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000C6   0x.... 0x....      BL       BUTTON_SetTextColor
   1121          	BUTTON_SetTextColor(buttonRet.btnHandle, BUTTON_CI_UNPRESSED, gCfgItems.back_btn_textcolor);  
   \   000000CA   0x6BEA             LDR      R2,[R5, #+60]
   \   000000CC   0x2100             MOVS     R1,#+0
   \   000000CE   0xF9B6 0x0004      LDRSH    R0,[R6, #+4]
   \   000000D2   0x.... 0x....      BL       BUTTON_SetTextColor
   1122              
   1123              if(gCfgItems.multiple_language != 0)
   \   000000D6   0xF894 0x01BF      LDRB     R0,[R4, #+447]
   1124              {
   1125                  //BUTTON_SetText(buttonRet.btnHandle, common_menu.text_back);
   1126              }
   1127              GUI_DispStringAt("ำฒผฒโสิ-(ศํผฤฺฒฟฐๆฑพV1.0.1_001)", 20, 0);
   \   000000DA   0x2200             MOVS     R2,#+0
   \   000000DC   0x2114             MOVS     R1,#+20
   \   000000DE   0x.... 0x....      ADR.W    R0,`?<Constant "\\323\\262\\274\\376\\262\\342\\312\\324-(`
   \   000000E2   0x.... 0x....      BL       GUI_DispStringAt
   1128              mksHardwareTest();
   \   000000E6   0xE8BD 0x407F      POP      {R0-R6,LR}
   \   000000EA   0x....             B.N      mksHardwareTest
   1129          
   1130          }
   1131          

   \                                 In section .text, align 2, keep-with-next
   1132          void Clear_Hardwaretest()
   1133          {
   \                     Clear_Hardwaretest: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   1134          	GUI_SetBkColor(gCfgItems.background_color);
   \   00000002   0x....             LDR.N    R0,??DataTable19_4
   \   00000004   0x6840             LDR      R0,[R0, #+4]
   \   00000006   0x.... 0x....      BL       GUI_SetBkColor
   1135          	if(WM_IsWindow(hHardwaretestWnd))
   \   0000000A   0x....             LDR.N    R4,??DataTable19_21
   \   0000000C   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   00000010   0x.... 0x....      BL       WM_IsWindow
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD005             BEQ.N    ??Clear_Hardwaretest_0
   1136          	{
   1137          		WM_DeleteWindow(hHardwaretestWnd);
   \   00000018   0xF9B4 0x0000      LDRSH    R0,[R4, #+0]
   \   0000001C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000020   0x.... 0x....      B.W      WM_DeleteWindow
   1138          		//GUI_Exec();
   1139          	}
   1140          	//GUI_Clear();
   1141          }
   \                     ??Clear_Hardwaretest_0: (+1)
   \   00000024   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19:
   \   00000000   0x40010800         DC32     0x40010800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_1:
   \   00000000   0x........         DC32     GPIO_TEST_STATE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_2:
   \   00000000   0x40011800         DC32     0x40011800

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_3:
   \   00000000   0x40011000         DC32     0x40011000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_4:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_5:
   \   00000000   0x........         DC32     TransferStatusSD

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_6:
   \   00000000   0x........         DC32     SD_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_7:
   \   00000000   0x42210198         DC32     0x42210198

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_8:
   \   00000000   0x42228198         DC32     0x42228198

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_9:
   \   00000000   0x42218194         DC32     0x42218194

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_10:
   \   00000000   0x42230180         DC32     0x42230180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_11:
   \   00000000   0x........         DC32     mksStepperState

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_12:
   \   00000000   0x42230184         DC32     0x42230184

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_13:
   \   00000000   0x42218180         DC32     0x42218180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_14:
   \   00000000   0x42210180         DC32     0x42210180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_15:
   \   00000000   0x........         DC32     thermalManager

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_16:
   \   00000000   0x4222818C         DC32     0x4222818c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_17:
   \   00000000   0x40000440         DC32     0x40000440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_18:
   \   00000000   0x4222018C         DC32     0x4222018c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_19:
   \   00000000   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_20:
   \   00000000   0x........         DC32     _ZN11Temperature23current_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_21:
   \   00000000   0x........         DC32     hHardwaretestWnd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_22:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_23:
   \   00000000   0x........         DC32     last_disp_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_24:
   \   00000000   0x........         DC32     GUI_FontHZ_fontHz14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_25:
   \   00000000   0x........         DC32     disp_state_stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_26:
   \   00000000   0x........         DC32     disp_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_27:
   \   00000000   0x........         DC32     GUI_FontHZ16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_28:
   \   00000000   0x........         DC32     _Z17cbHardwaretestWinP10WM_MESSAGE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_29:
   \   00000000   0x........         DC32     BMP_PIC_Y

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_30:
   \   00000000   0x........         DC32     BMP_PIC_X

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable19_31:
   \   00000000   0x........         DC32     bmp_struct

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\266\\317\\265\\347\\266\\317\\301\\317\\2`:
   \   00000000   0xB6 0xCF          DC8 "\266\317\265\347\266\317\301\317\275\323\277\332\325\375\263\243"
   \              0xB5 0xE7    
   \              0xB6 0xCF    
   \              0xC1 0xCF    
   \              0xBD 0xD3    
   \              0xBF 0xDA    
   \              0xD5 0xFD    
   \              0xB3 0xA3    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\266\\317\\265\\347\\266\\317\\301\\317\\2_1`:
   \   00000000   0xB6 0xCF          DC8 "\266\317\265\347\266\317\301\317\275\323\277\332\322\354\263\243"
   \              0xB5 0xE7    
   \              0xB6 0xCF    
   \              0xC1 0xCF    
   \              0xBD 0xD3    
   \              0xBF 0xDA    
   \              0xD2 0xEC    
   \              0xB3 0xA3    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\317\\336\\316\\273\\275\\323\\277\\332\\3`:
   \   00000000   0xCF 0xDE          DC8 "\317\336\316\273\275\323\277\332\325\375\263\243"
   \              0xCE 0xBB    
   \              0xBD 0xD3    
   \              0xBF 0xDA    
   \              0xD5 0xFD    
   \              0xB3 0xA3    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\317\\336\\316\\273\\275\\323\\277\\332\\3_1`:
   \   00000000   0xCF 0xDE          DC8 "\317\336\316\273\275\323\277\332\322\354\263\243"
   \              0xCE 0xBB    
   \              0xBD 0xD3    
   \              0xBF 0xDA    
   \              0xD2 0xEC    
   \              0xB3 0xA3    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {0, 1536, 1537, 2047}>`:
   \   00000000   0x00000000         DC32 0, 1536, 1537, 2047
   \              0x00000600   
   \              0x00000601   
   \              0x000007FF   

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(unsigned char)'\\241', (unsigned c`:
   \   00000000   0xA1 0xB2          DC8 161, 178, 195, 212
   \              0xC3 0xD4    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "1:STM32.TXT">`:
   \   00000000   0x31 0x3A          DC8 "1:STM32.TXT"
   \              0x53 0x54    
   \              0x4D 0x33    
   \              0x32 0x2E    
   \              0x54 0x58    
   \              0x54 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "T0:%0.3f T1:%0.3f B:%...">`:
   \   00000000   0x54 0x30          DC8 "T0:%0.3f T1:%0.3f B:%0.3f"
   \              0x3A 0x25    
   \              0x30 0x2E    
   \              0x33 0x66    
   \              0x20 0x54    
   \              0x31 0x3A    
   \              0x25 0x30    
   \              0x2E 0x33    
   \              0x66 0x20    
   \              0x42 0x3A    
   \              0x25 0x30    
   \              0x2E 0x33    
   \              0x66 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "bmp_return.bin">`:
   \   00000000   0x62 0x6D          DC8 "bmp_return.bin"
   \              0x70 0x5F    
   \              0x72 0x65    
   \              0x74 0x75    
   \              0x72 0x6E    
   \              0x2E 0x62    
   \              0x69 0x6E    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\323\\262\\274\\376\\262\\342\\312\\324-(`:
   \   00000000   0xD3 0xB2          DC8 "\323\262\274\376\262\342\312\324-(\310\355\274\376\304\332\262\277\260\346\261\276V1.0.1_001)"
   \              0xBC 0xFE    
   \              0xB2 0xE2    
   \              0xCA 0xD4    
   \              0x2D 0x28    
   \              0xC8 0xED    
   \              0xBC 0xFE    
   \              0xC4 0xDA    
   \              0xB2 0xBF    
   \              0xB0 0xE6    
   \              0xB1 0xBE    
   \              0x56 0x31    
   \              0x2E 0x30    
   \              0x2E 0x31    
   \              0x5F 0x30    
   \              0x30 0x31    
   \              0x29 0x00    
   \   00000022   0x00 0x00          DC8 0, 0
   1142          
   1143          /* USER CODE END 0 */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       4   Buffercmp(u8 *, u8 *, u16)
       8   Clear_Hardwaretest
         8   -> GUI_SetBkColor
         0   -> WM_DeleteWindow
         8   -> WM_IsWindow
      16   Test_GPIO
         0   -> GUI_DispStringAt
        16   -> GUI_DispStringAt
        16   -> GUI_SetBkColor
         0   -> GUI_SetColor
        16   -> GUI_SetColor
        16   -> Test_GPIO_Init()
        16   -> test_gpio_readlevel_H()
        16   -> test_gpio_readlevel_L()
      24   Test_GPIO_Init()
        24   -> HAL_GPIO_Init
        24   -> HAL_GPIO_WritePin
       8   cbHardwaretestWin(WM_MESSAGE *)
         8   -> Clear_Hardwaretest
         8   -> GUI_SetFont
         8   -> GUI_UC_SetEncodeUTF8
         0   -> WM_DefaultProc
         0   -> draw_ready_print
      32   draw_Hardwaretest
        32   -> BUTTON_CreateEx
        32   -> BUTTON_SetBitmapEx
        32   -> BUTTON_SetBkColor
        32   -> BUTTON_SetBmpFileName
        32   -> BUTTON_SetTextColor
        32   -> GUI_Clear
        32   -> GUI_DispStringAt
        32   -> GUI_SetBkColor
        32   -> GUI_SetColor
        32   -> GUI_SetFont
        32   -> GUI_UC_SetEncodeNone
        32   -> Test_GPIO
        32   -> WM_CreateWindow
        32   -> alloc_win_id
         0   -> mksHardwareTest
      40   mksEeprom_test
        40   -> AT24CXX_Read
        40   -> AT24CXX_Write
        40   -> __aeabi_memcpy4
       0   mksGpioTest()
      40   mksHardwareTest
         0   -> GUI_DispStringAt
        40   -> Temperature::init()
        40   -> Temperature::manage_heater()
        40   -> Test_GPIO
        40   -> __aeabi_f2d
        40   -> sprintf
      32   mksSdCardTest
        32   -> Buffercmp(u8 *, u8 *, u16)
        32   -> Error_Handler
        32   -> f_close
        32   -> f_mount
        32   -> f_open
        32   -> f_read
        32   -> f_write
       8   mksStepperTest
       0   mksTFTLCDTest()
       0   mksW25Q64Test
      24   test_gpio_readlevel_H()
        24   -> HAL_GPIO_ReadPin
        24   -> HAL_GPIO_WritePin
      24   test_gpio_readlevel_L()
        24   -> HAL_GPIO_ReadPin
        24   -> HAL_GPIO_WritePin


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?<Constant "1:STM32.TXT">
      28  ?<Constant "T0:%0.3f T1:%0.3f B:%...">
      20  ?<Constant "\266\317\265\347\266\317\301\317\2
      20  ?<Constant "\266\317\265\347\266\317\301\317\2_1
      16  ?<Constant "\317\336\316\273\275\323\277\332\3
      16  ?<Constant "\317\336\316\273\275\323\277\332\3_1
      36  ?<Constant "\323\262\274\376\262\342\312\324-(
      16  ?<Constant "bmp_return.bin">
       4  ?<Constant {(unsigned char)'\241', (unsigned c
      16  ?<Constant {0, 1536, 1537, 2047}>
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_20
       4  ??DataTable19_21
       4  ??DataTable19_22
       4  ??DataTable19_23
       4  ??DataTable19_24
       4  ??DataTable19_25
       4  ??DataTable19_26
       4  ??DataTable19_27
       4  ??DataTable19_28
       4  ??DataTable19_29
       4  ??DataTable19_3
       4  ??DataTable19_30
       4  ??DataTable19_31
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
      36  Buffercmp(u8 *, u8 *, u16)
      38  Clear_Hardwaretest
      16  GPIO_TEST_STATE
       2  Index
     128  Rx_Buffer
     178  Test_GPIO
     164  Test_GPIO_Init()
       1  TransferStatus1
       1  TransferStatus2
    1368  TransferStatusSD
          SDFatFs
          MyFile
          wtext
          rtext
     128  Tx_Buffer
     120  cbHardwaretestWin(WM_MESSAGE *)
     236  draw_Hardwaretest
      28  hHardwaretestWnd
          buttonRet
      92  mksEeprom_test
       2  mksGpioTest()
     204  mksHardwareTest
     144  mksSdCardTest
      60  mksStepperState
          testCnt
          buf_test
      76  mksStepperTest
       2  mksTFTLCDTest()
       2  mksW25Q64Test
     198  test_gpio_readlevel_H()
     182  test_gpio_readlevel_L()
       1  -- Other

 
   235 bytes in section .bss
 1 497 bytes in section .data
     1 byte  in section .rodata
 1 986 bytes in section .text
 
 1 986 bytes of CODE  memory
     0 bytes of CONST memory (+ 1 byte shared)
 1 732 bytes of DATA  memory

Errors: none
Warnings: 52
