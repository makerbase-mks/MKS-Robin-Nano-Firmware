###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:38
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\Marlin_main.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\Marlin_main.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp
      1          /**
      2           * Marlin 3D Printer Firmware
      3           * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
      4           *
      5           * Based on Sprinter and grbl.
      6           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      7           *
      8           * This program is free software: you can redistribute it and/or modify
      9           * it under the terms of the GNU General Public License as published by
     10           * the Free Software Foundation, either version 3 of the License, or
     11           * (at your option) any later version.
     12           *
     13           * This program is distributed in the hope that it will be useful,
     14           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     15           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     16           * GNU General Public License for more details.
     17           *
     18           * You should have received a copy of the GNU General Public License
     19           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     20           *
     21           */
     22          
     23          /**
     24           * About Marlin
     25           *
     26           * This firmware is a mashup between Sprinter and grbl.
     27           *  - https://github.com/kliment/Sprinter
     28           *  - https://github.com/simen/grbl/tree
     29           */
     30          
     31          /**
     32           * -----------------
     33           * G-Codes in Marlin
     34           * -----------------
     35           *
     36           * Helpful G-code references:
     37           *  - http://linuxcnc.org/handbook/gcode/g-code.html
     38           *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
     39           *
     40           * Help to document Marlin's G-codes online:
     41           *  - http://reprap.org/wiki/G-code
     42           *  - https://github.com/MarlinFirmware/MarlinDocumentation
     43           *
     44           * -----------------
     45           *
     46           * "G" Codes
     47           *
     48           * G0   -> G1
     49           * G1   - Coordinated Movement X Y Z E
     50           * G2   - CW ARC
     51           * G3   - CCW ARC
     52           * G4   - Dwell S<seconds> or P<milliseconds>
     53           * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
     54           * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
     55           * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
     56           * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
     57           * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
     58           * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
     59           * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
     60           * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
     61           * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
     62           * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
     63           * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
     64           * G28  - Home one or more axes
     65           * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
     66           * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
     67           * G31  - Dock sled (Z_PROBE_SLED only)
     68           * G32  - Undock sled (Z_PROBE_SLED only)
     69           * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
     70           * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
     71           * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
     72           * G90  - Use Absolute Coordinates
     73           * G91  - Use Relative Coordinates
     74           * G92  - Set current position to coordinates given
     75           *
     76           * "M" Codes
     77           *
     78           * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
     79           * M1   -> M0
     80           * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
     81           * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
     82           * M5   - Turn laser/spindle off
     83           * M17  - Enable/Power all stepper motors
     84           * M18  - Disable all stepper motors; same as M84
     85           * M20  - List SD card. (Requires SDSUPPORT)
     86           * M21  - Init SD card. (Requires SDSUPPORT)
     87           * M22  - Release SD card. (Requires SDSUPPORT)
     88           * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
     89           * M24  - Start/resume SD print. (Requires SDSUPPORT)
     90           * M25  - Pause SD print. (Requires SDSUPPORT)
     91           * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
     92           * M27  - Report SD print status. (Requires SDSUPPORT)
     93           * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
     94           * M29  - Stop SD write. (Requires SDSUPPORT)
     95           * M30  - Delete file from SD: "M30 /path/file.gco"
     96           * M31  - Report time since last M109 or SD card start to serial.
     97           * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
     98           *        Use P to run other files as sub-programs: "M32 P !filename#"
     99           *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
    100           * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
    101           * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
    102           * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
    103           * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
    104           * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
    105           * M75  - Start the print job timer.
    106           * M76  - Pause the print job timer.
    107           * M77  - Stop the print job timer.
    108           * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
    109           * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
    110           * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
    111           * M82  - Set E codes absolute (default).
    112           * M83  - Set E codes relative while in Absolute (G90) mode.
    113           * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
    114           *        duration after which steppers should turn off. S0 disables the timeout.
    115           * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
    116           * M92  - Set planner.axis_steps_per_mm for one or more axes.
    117           * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
    118           * M104 - Set extruder target temp.
    119           * M105 - Report current temperatures.
    120           * M106 - Set print fan speed.
    121           * M107 - Print fan off.
    122           * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
    123           * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
    124           *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
    125           *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
    126           * M110 - Set the current line number. (Used by host printing)
    127           * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
    128           * M112 - Emergency stop.
    129           * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
    130           * M114 - Report current position.
    131           * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
    132           * M117 - Display a message on the controller screen. (Requires an LCD)
    133           * M118 - Display a message in the host console.
    134           * M119 - Report endstops status.
    135           * M120 - Enable endstops detection.
    136           * M121 - Disable endstops detection.
    137           * M122 - Debug stepper (Requires HAVE_TMC2130)
    138           * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
    139           * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
    140           * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
    141           * M128 - EtoP Open. (Requires BARICUDA)
    142           * M129 - EtoP Closed. (Requires BARICUDA)
    143           * M140 - Set bed target temp. S<temp>
    144           * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
    145           * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
    146           * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
    147           * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
    148           * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
    149           * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
    150           * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
    151           * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
    152           *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
    153           * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
    154           * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
    155           * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
    156           * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
    157           * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
    158           * M205 - Set advanced settings. Current units apply:
    159                      S<print> T<travel> minimum speeds
    160                      B<minimum segment time>
    161                      X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
    162           * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    163           * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
    164           * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
    165           * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
    166                    Every normal extrude-only move will be classified as retract depending on the direction.
    167           * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
    168           * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
    169           * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
    170           * M221 - Set Flow Percentage: "M221 S<percent>"
    171           * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
    172           * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
    173           * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
    174           * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
    175           * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
    176           * M280 - Set servo position absolute: "M280 P<index> S<angle|碌s>". (Requires servos)
    177           * M290 - Babystepping (Requires BABYSTEPPING)
    178           * M300 - Play beep sound S<frequency Hz> P<duration ms>
    179           * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
    180           * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
    181           * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
    182           * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
    183           * M350 - Set microstepping mode. (Requires digital microstepping pins.)
    184           * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
    185           * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
    186           * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
    187           * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
    188           * M400 - Finish all moves.
    189           * M401 - Lower Z probe. (Requires a probe)
    190           * M402 - Raise Z probe. (Requires a probe)
    191           * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
    192           * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
    193           * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
    194           * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
    195           * M410 - Quickstop. Abort all planned moves.
    196           * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
    197           * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
    198           * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
    199           * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
    200           * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
    201           * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
    202           * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
    203           * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
    204           * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
    205           * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
    206           * M666 - Set delta endstop adjustment. (Requires DELTA)
    207           * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
    208           * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
    209           * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
    210           * M860 - Report the position of position encoder modules.
    211           * M861 - Report the status of position encoder modules.
    212           * M862 - Perform an axis continuity test for position encoder modules.
    213           * M863 - Perform steps-per-mm calibration for position encoder modules.
    214           * M864 - Change position encoder module I2C address.
    215           * M865 - Check position encoder module firmware version.
    216           * M866 - Report or reset position encoder module error count.
    217           * M867 - Enable/disable or toggle error correction for position encoder modules.
    218           * M868 - Report or set position encoder module error correction threshold.
    219           * M869 - Report position encoder module error.
    220           * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
    221           * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    222           * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
    223           * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
    224           * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
    225           * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
    226           * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    227           * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
    228           * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
    229           * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
    230           *
    231           * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
    232           * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
    233           * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
    234           * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
    235           * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
    236           *
    237           * ************ Custom codes - This can change to suit future G-code regulations
    238           * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
    239           * M998	- Stop SD print. (Requires SDSUPPORT)
    240           * M999 - Restart after being stopped by error
    241           *
    242           * "T" Codes
    243           *
    244           * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
    245           *
    246           */
    247          
    248          #include "Marlin.h"

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
   \                     _Z6strchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
   \                     _Z7strrchrPci: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strrchr

   \                                 In section .text, align 2
   \   __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
   \                     _Z6strstrPcPKc: (+1)
   \   00000000   0x.... 0x....      B.W      __iar_Strstr

  #define UNUSED(x) ((void)(x))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_def.h",87  Warning[Pe047]: 
          incompatible redefinition of macro "UNUSED" (declared at line 101 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\macros.h")

  		volatile volatile float desireBedTempBak;
  		         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Inc\mks_cfg.h",613  Warning[Pe083]: 
          type qualifier specified more than once

  #define strcpy_P(dest, src) strcpy((dest), (src))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",23  Warning[Pe047]: 
          incompatible redefinition of macro "strcpy_P" (declared at line 93
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define strstr_P(a, b) strstr((a), (b))
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",26  Warning[Pe047]: 
          incompatible redefinition of macro "strstr_P" (declared at line 94
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define sprintf_P(s, f, ...) sprintf((s), (f), __VA_ARGS__)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",28  Warning[Pe047]: 
          incompatible redefinition of macro "sprintf_P" (declared at line 95
          of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define pgm_read_word_near(addr) pgm_read_word(addr)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\arduino\stm32\cores\arduino\avr\pgmspace.h",38  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_word_near" (declared at
          line 65 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

   \                                 In section .text, align 2
   \   __interwork __softfp void serial_echopair_P(char const *, bool)
   \                     _Z17serial_echopair_PPKcb: (+1)
   \   00000000   0x.... 0x....      B.W      _Z17serial_echopair_PPKci

   \                                 In section .text, align 4
   \   __interwork __softfp void serialprintPGM(char const *)
   \                     _Z14serialprintPGMPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xE003             B.N      ??serialprintPGM_0
   \                     ??serialprintPGM_1: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x4803             LDR.N    R0,??serialprintPGM_2
   \   0000000A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??serialprintPGM_0: (+1)
   \   0000000E   0xF914 0x1B01      LDRSB    R1,[R4], #+1
   \   00000012   0x0008             MOVS     R0,R1
   \   00000014   0xD1F7             BNE.N    ??serialprintPGM_1
   \   00000016   0xBD10             POP      {R4,PC}          ;; return
   \                     ??serialprintPGM_2:
   \   00000018   0x........         DC32     Serial3

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsRunning()
   \                     _Z9IsRunningv: (+1)
   \   00000000   0x4801             LDR.N    R0,??IsRunning_0
   \   00000002   0x7900             LDRB     R0,[R0, #+4]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??IsRunning_0:
   \   00000008   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp bool IsStopped()
   \                     _Z9IsStoppedv: (+1)
   \   00000000   0x4802             LDR.N    R0,??IsStopped_0
   \   00000002   0x7900             LDRB     R0,[R0, #+4]
   \   00000004   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??IsStopped_0:
   \   0000000C   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4
   \   __interwork __softfp void refresh_cmd_timeout()
   \                     _Z19refresh_cmd_timeoutv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   \   00000006   0x4901             LDR.N    R1,??refresh_cmd_timeout_0
   \   00000008   0x65C8             STR      R0,[R1, #+92]
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
   \                     ??refresh_cmd_timeout_0:
   \   0000000C   0x........         DC32     axis_homed

   \                                 In section .text, align 4
   \   __interwork __softfp void set_current_from_destination()
   \                     _Z28set_current_from_destinationv: (+1)
   \   00000000   0x4803             LDR.N    R0,??set_current_from_destination_0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF100 0x0118      ADD      R1,R0,#+24
   \   00000008   0x3008             ADDS     R0,R0,#+8
   \   0000000A   0x.... 0x....      B.W      memcpy
   \   0000000E   0xBF00             Nop      
   \                     ??set_current_from_destination_0:
   \   00000010   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp void set_destination_from_current()
   \                     _Z28set_destination_from_currentv: (+1)
   \   00000000   0x4803             LDR.N    R0,??set_destination_from_current_0
   \   00000002   0x2210             MOVS     R2,#+16
   \   00000004   0xF100 0x0108      ADD      R1,R0,#+8
   \   00000008   0x3018             ADDS     R0,R0,#+24
   \   0000000A   0x.... 0x....      B.W      memcpy
   \   0000000E   0xBF00             Nop      
   \                     ??set_destination_from_current_0:
   \   00000010   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_IS_KINEMATIC(float const &, float const &)
   \                     _Z34position_is_reachable_IS_KINEMATICRKfS0_: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4857             LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0
   \   0000000A   0xF9B0 0x1058      LDRSH    R1,[R0, #+88]
   \   0000000E   0x078A             LSLS     R2,R1,#+30
   \   00000010   0xD54E             BPL.N    ??position_is_reachable_IS_KINEMATIC_1
   \   00000012   0xF8D0 0x8054      LDR      R8,[R0, #+84]
   \   00000016   0xF04F 0x0902      MOV      R9,#+2
   \   0000001A   0xF04F 0x567E      MOV      R6,#+1065353216
   \   0000001E   0x4637             MOV      R7,R6
   \   00000020   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_2
   \                     ??position_is_reachable_IS_KINEMATIC_3: (+1)
   \   00000022   0x4640             MOV      R0,R8
   \   00000024   0x4641             MOV      R1,R8
   \   00000026   0x.... 0x....      BL       __aeabi_fmul
   \   0000002A   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_2: (+1)
   \   0000002C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000030   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_4
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x4641             MOV      R1,R8
   \   00000036   0x.... 0x....      BL       __aeabi_fmul
   \   0000003A   0x4607             MOV      R7,R0
   \                     ??position_is_reachable_IS_KINEMATIC_4: (+1)
   \   0000003C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000040   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_3
   \   00000042   0xF8D5 0x8000      LDR      R8,[R5, #+0]
   \   00000046   0xF04F 0x0902      MOV      R9,#+2
   \   0000004A   0x4635             MOV      R5,R6
   \   0000004C   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_5
   \                     ??position_is_reachable_IS_KINEMATIC_6: (+1)
   \   0000004E   0x4640             MOV      R0,R8
   \   00000050   0x4641             MOV      R1,R8
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_5: (+1)
   \   00000058   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000005C   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_7
   \   0000005E   0x4628             MOV      R0,R5
   \   00000060   0x4641             MOV      R1,R8
   \   00000062   0x.... 0x....      BL       __aeabi_fmul
   \   00000066   0x4605             MOV      R5,R0
   \                     ??position_is_reachable_IS_KINEMATIC_7: (+1)
   \   00000068   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000006C   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_6
   \   0000006E   0x6824             LDR      R4,[R4, #+0]
   \   00000070   0xF04F 0x0802      MOV      R8,#+2
   \   00000074   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_8
   \                     ??position_is_reachable_IS_KINEMATIC_9: (+1)
   \   00000076   0x4620             MOV      R0,R4
   \   00000078   0x4621             MOV      R1,R4
   \   0000007A   0x.... 0x....      BL       __aeabi_fmul
   \   0000007E   0x4604             MOV      R4,R0
   \                     ??position_is_reachable_IS_KINEMATIC_8: (+1)
   \   00000080   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000084   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_10
   \   00000086   0x4630             MOV      R0,R6
   \   00000088   0x4621             MOV      R1,R4
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4606             MOV      R6,R0
   \                     ??position_is_reachable_IS_KINEMATIC_10: (+1)
   \   00000090   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000094   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_9
   \   00000096   0x4628             MOV      R0,R5
   \   00000098   0x4631             MOV      R1,R6
   \   0000009A   0x.... 0x....      BL       __aeabi_fadd
   \   0000009E   0x4601             MOV      R1,R0
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000A6   0xD801             BHI.N    ??position_is_reachable_IS_KINEMATIC_11
   \   000000A8   0x2001             MOVS     R0,#+1
   \   000000AA   0xE05A             B.N      ??position_is_reachable_IS_KINEMATIC_12
   \                     ??position_is_reachable_IS_KINEMATIC_11: (+1)
   \   000000AC   0x2000             MOVS     R0,#+0
   \   000000AE   0xE058             B.N      ??position_is_reachable_IS_KINEMATIC_12
   \                     ??position_is_reachable_IS_KINEMATIC_1: (+1)
   \   000000B0   0xF44F 0x7040      MOV      R0,#+768
   \   000000B4   0x4201             TST      R1,R0
   \   000000B6   0xD054             BEQ.N    ??position_is_reachable_IS_KINEMATIC_12
   \   000000B8   0xF8DF 0x80B0      LDR.W    R8,??position_is_reachable_IS_KINEMATIC_0+0x4  ;; 0x43960000
   \   000000BC   0xF04F 0x0902      MOV      R9,#+2
   \   000000C0   0xF04F 0x567E      MOV      R6,#+1065353216
   \   000000C4   0x4637             MOV      R7,R6
   \   000000C6   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_13
   \                     ??position_is_reachable_IS_KINEMATIC_14: (+1)
   \   000000C8   0x4640             MOV      R0,R8
   \   000000CA   0x4641             MOV      R1,R8
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_13: (+1)
   \   000000D2   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000D6   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_15
   \   000000D8   0x4638             MOV      R0,R7
   \   000000DA   0x4641             MOV      R1,R8
   \   000000DC   0x.... 0x....      BL       __aeabi_fmul
   \   000000E0   0x4607             MOV      R7,R0
   \                     ??position_is_reachable_IS_KINEMATIC_15: (+1)
   \   000000E2   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000E6   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_14
   \   000000E8   0x6829             LDR      R1,[R5, #+0]
   \   000000EA   0x4821             LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0x8  ;; 0xc2c80000
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x4680             MOV      R8,R0
   \   000000F2   0xF04F 0x0902      MOV      R9,#+2
   \   000000F6   0x4635             MOV      R5,R6
   \   000000F8   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_16
   \                     ??position_is_reachable_IS_KINEMATIC_17: (+1)
   \   000000FA   0x4640             MOV      R0,R8
   \   000000FC   0x4641             MOV      R1,R8
   \   000000FE   0x.... 0x....      BL       __aeabi_fmul
   \   00000102   0x4680             MOV      R8,R0
   \                     ??position_is_reachable_IS_KINEMATIC_16: (+1)
   \   00000104   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000108   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_18
   \   0000010A   0x4628             MOV      R0,R5
   \   0000010C   0x4641             MOV      R1,R8
   \   0000010E   0x.... 0x....      BL       __aeabi_fmul
   \   00000112   0x4605             MOV      R5,R0
   \                     ??position_is_reachable_IS_KINEMATIC_18: (+1)
   \   00000114   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000118   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_17
   \   0000011A   0x6821             LDR      R1,[R4, #+0]
   \   0000011C   0x4815             LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0xC  ;; 0x42600000
   \   0000011E   0x.... 0x....      BL       __aeabi_fadd
   \   00000122   0x4604             MOV      R4,R0
   \   00000124   0xF04F 0x0802      MOV      R8,#+2
   \   00000128   0xE004             B.N      ??position_is_reachable_IS_KINEMATIC_19
   \                     ??position_is_reachable_IS_KINEMATIC_20: (+1)
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x4621             MOV      R1,R4
   \   0000012E   0x.... 0x....      BL       __aeabi_fmul
   \   00000132   0x4604             MOV      R4,R0
   \                     ??position_is_reachable_IS_KINEMATIC_19: (+1)
   \   00000134   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000138   0xD504             BPL.N    ??position_is_reachable_IS_KINEMATIC_21
   \   0000013A   0x4630             MOV      R0,R6
   \   0000013C   0x4621             MOV      R1,R4
   \   0000013E   0x.... 0x....      BL       __aeabi_fmul
   \   00000142   0x4606             MOV      R6,R0
   \                     ??position_is_reachable_IS_KINEMATIC_21: (+1)
   \   00000144   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000148   0xD1EF             BNE.N    ??position_is_reachable_IS_KINEMATIC_20
   \   0000014A   0x4628             MOV      R0,R5
   \   0000014C   0x4631             MOV      R1,R6
   \   0000014E   0x.... 0x....      BL       __aeabi_fadd
   \   00000152   0x4601             MOV      R1,R0
   \   00000154   0x4638             MOV      R0,R7
   \   00000156   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000015A   0xD801             BHI.N    ??position_is_reachable_IS_KINEMATIC_22
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0xE000             B.N      ??position_is_reachable_IS_KINEMATIC_12
   \                     ??position_is_reachable_IS_KINEMATIC_22: (+1)
   \   00000160   0x2000             MOVS     R0,#+0

    }
    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin.h",537  Warning[Pe940]: 
          missing return statement at end of non-void function
          "position_is_reachable_IS_KINEMATIC"
   \                     ??position_is_reachable_IS_KINEMATIC_12: (+1)
   \   00000162   0xE8BD 0x83F2      POP      {R1,R4-R9,PC}    ;; return
   \   00000166   0xBF00             Nop      
   \                     ??position_is_reachable_IS_KINEMATIC_0:
   \   00000168   0x........         DC32     mksCfg
   \   0000016C   0x43960000         DC32     0x43960000
   \   00000170   0xC2C80000         DC32     0xc2c80000
   \   00000174   0x42600000         DC32     0x42600000

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
   \                     _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_: (+1)
   \   00000000   0xB57C             PUSH     {R2-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD00F             BEQ.N    ??position_is_reachable_by_probe_IS_KINEMATIC_0
   \   0000000E   0x4E09             LDR.N    R6,??position_is_reachable_by_probe_IS_KINEMATIC_1
   \   00000010   0x6820             LDR      R0,[R4, #+0]
   \   00000012   0x6EF1             LDR      R1,[R6, #+108]
   \   00000014   0x.... 0x....      BL       __aeabi_fsub
   \   00000018   0x9000             STR      R0,[SP, #+0]
   \   0000001A   0x6828             LDR      R0,[R5, #+0]
   \   0000001C   0x6F31             LDR      R1,[R6, #+112]
   \   0000001E   0x.... 0x....      BL       __aeabi_fsub
   \   00000022   0x9001             STR      R0,[SP, #+4]
   \   00000024   0xA901             ADD      R1,SP,#+4
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   0000002C   0xBD76             POP      {R1,R2,R4-R6,PC}
   \                     ??position_is_reachable_by_probe_IS_KINEMATIC_0: (+1)
   \   0000002E   0x2000             MOVS     R0,#+0
   \   00000030   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \   00000032   0xBF00             Nop      
   \                     ??position_is_reachable_by_probe_IS_KINEMATIC_1:
   \   00000034   0x........         DC32     mksCfg

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_IS_CARTESIAN(float const &, float const &)
   \                     _Z34position_is_reachable_IS_CARTESIANRKfS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x468B             MOV      R11,R1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_f2d
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0xF8DF 0x8094      LDR.W    R8,??position_is_reachable_IS_CARTESIAN_0  ;; 0xd2f1a9fc
   \   00000014   0xF8DF 0x9094      LDR.W    R9,??position_is_reachable_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
   \   00000018   0xF8DF 0xA094      LDR.W    R10,??position_is_reachable_IS_CARTESIAN_0+0x8
   \   0000001C   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4642             MOV      R2,R8
   \   00000026   0x464B             MOV      R3,R9
   \   00000028   0x.... 0x....      BL       __aeabi_dadd
   \   0000002C   0x4602             MOV      R2,R0
   \   0000002E   0x460B             MOV      R3,R1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000038   0xD832             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   0000003A   0x4646             MOV      R6,R8
   \   0000003C   0x4F1D             LDR.N    R7,??position_is_reachable_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
   \   0000003E   0xF8DA 0x0014      LDR      R0,[R10, #+20]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0x463B             MOV      R3,R7
   \   0000004A   0x.... 0x....      BL       __aeabi_dadd
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0x462B             MOV      R3,R5
   \   00000052   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000056   0xD823             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   00000058   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4604             MOV      R4,R0
   \   00000062   0x460D             MOV      R5,R1
   \   00000064   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000068   0x.... 0x....      BL       __aeabi_f2d
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x464B             MOV      R3,R9
   \   00000070   0x.... 0x....      BL       __aeabi_dadd
   \   00000074   0x4602             MOV      R2,R0
   \   00000076   0x460B             MOV      R3,R1
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000080   0xD80E             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   00000082   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x4632             MOV      R2,R6
   \   0000008C   0x463B             MOV      R3,R7
   \   0000008E   0x.... 0x....      BL       __aeabi_dadd
   \   00000092   0x4622             MOV      R2,R4
   \   00000094   0x462B             MOV      R3,R5
   \   00000096   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000009A   0xD801             BHI.N    ??position_is_reachable_IS_CARTESIAN_1
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE000             B.N      ??position_is_reachable_IS_CARTESIAN_2
   \                     ??position_is_reachable_IS_CARTESIAN_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??position_is_reachable_IS_CARTESIAN_2: (+1)
   \   000000A2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   000000A6   0xBF00             Nop      
   \                     ??position_is_reachable_IS_CARTESIAN_0:
   \   000000A8   0xD2F1A9FC         DC32     0xd2f1a9fc
   \   000000AC   0xBF50624D         DC32     0xbf50624d
   \   000000B0   0x........         DC32     mksCfg
   \   000000B4   0x3F50624D         DC32     0x3f50624d

   \                                 In section .text, align 4
   \   __interwork __softfp bool position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
   \                     _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x468B             MOV      R11,R1
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_f2d
   \   0000000C   0x4604             MOV      R4,R0
   \   0000000E   0x460D             MOV      R5,R1
   \   00000010   0xF8DF 0x8094      LDR.W    R8,??position_is_reachable_by_probe_IS_CARTESIAN_0  ;; 0xd2f1a9fc
   \   00000014   0xF8DF 0x9094      LDR.W    R9,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
   \   00000018   0xF8DF 0xA094      LDR.W    R10,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x8
   \   0000001C   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4642             MOV      R2,R8
   \   00000026   0x464B             MOV      R3,R9
   \   00000028   0x.... 0x....      BL       __aeabi_dadd
   \   0000002C   0x4602             MOV      R2,R0
   \   0000002E   0x460B             MOV      R3,R1
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x4629             MOV      R1,R5
   \   00000034   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000038   0xD832             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   0000003A   0x4646             MOV      R6,R8
   \   0000003C   0x4F1D             LDR.N    R7,??position_is_reachable_by_probe_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
   \   0000003E   0xF8DA 0x0004      LDR      R0,[R10, #+4]
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4632             MOV      R2,R6
   \   00000048   0x463B             MOV      R3,R7
   \   0000004A   0x.... 0x....      BL       __aeabi_dadd
   \   0000004E   0x4622             MOV      R2,R4
   \   00000050   0x462B             MOV      R3,R5
   \   00000052   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000056   0xD823             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   00000058   0xF8DB 0x0000      LDR      R0,[R11, #+0]
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4604             MOV      R4,R0
   \   00000062   0x460D             MOV      R5,R1
   \   00000064   0xF8DA 0x0008      LDR      R0,[R10, #+8]
   \   00000068   0x.... 0x....      BL       __aeabi_f2d
   \   0000006C   0x4642             MOV      R2,R8
   \   0000006E   0x464B             MOV      R3,R9
   \   00000070   0x.... 0x....      BL       __aeabi_dadd
   \   00000074   0x4602             MOV      R2,R0
   \   00000076   0x460B             MOV      R3,R1
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x4629             MOV      R1,R5
   \   0000007C   0x.... 0x....      BL       __aeabi_cdrcmple
   \   00000080   0xD80E             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   00000082   0xF8DA 0x000C      LDR      R0,[R10, #+12]
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x4632             MOV      R2,R6
   \   0000008C   0x463B             MOV      R3,R7
   \   0000008E   0x.... 0x....      BL       __aeabi_dadd
   \   00000092   0x4622             MOV      R2,R4
   \   00000094   0x462B             MOV      R3,R5
   \   00000096   0x.... 0x....      BL       __aeabi_cdrcmple
   \   0000009A   0xD801             BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
   \   0000009C   0x2001             MOVS     R0,#+1
   \   0000009E   0xE000             B.N      ??position_is_reachable_by_probe_IS_CARTESIAN_2
   \                     ??position_is_reachable_by_probe_IS_CARTESIAN_1: (+1)
   \   000000A0   0x2000             MOVS     R0,#+0
   \                     ??position_is_reachable_by_probe_IS_CARTESIAN_2: (+1)
   \   000000A2   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   000000A6   0xBF00             Nop      
   \                     ??position_is_reachable_by_probe_IS_CARTESIAN_0:
   \   000000A8   0xD2F1A9FC         DC32     0xd2f1a9fc
   \   000000AC   0xBF50624D         DC32     0xbf50624d
   \   000000B0   0x........         DC32     mksTmp
   \   000000B4   0x3F50624D         DC32     0x3f50624d
    249          
    250          #include "ultralcd.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_update()
   \                     _Z10lcd_updatev: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_init()
   \                     _Z8lcd_initv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool lcd_hasstatus()
   \                     _Z13lcd_hasstatusv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setstatus(char const *, bool)
   \                     _Z13lcd_setstatusPKcb: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
   \                     _Z16lcd_setstatusPGMPKca: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_setalertstatusPGM(char const *)
   \                     _Z21lcd_setalertstatusPGMPKc: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_reset_alert_level()
   \                     _Z21lcd_reset_alert_levelv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void lcd_refresh()
   \                     _Z11lcd_refreshv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    251          #include "planner.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::refresh_e_factor(uint8_t)
   \                     _ZN7Planner16refresh_e_factorEh: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4606             MOV      R6,R0
   \   00000004   0x480C             LDR.N    R0,??refresh_e_factor_0
   \   00000006   0xF930 0x0016      LDRSH    R0,[R0, R6, LSL #+1]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2d
   \   0000000E   0x4A0B             LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
   \   00000010   0x4B0B             LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
   \   00000012   0x.... 0x....      BL       __aeabi_dmul
   \   00000016   0x4604             MOV      R4,R0
   \   00000018   0x460D             MOV      R5,R1
   \   0000001A   0x480A             LDR.N    R0,??refresh_e_factor_0+0xC
   \   0000001C   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000020   0x.... 0x....      BL       __aeabi_f2d
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x462B             MOV      R3,R5
   \   00000028   0x.... 0x....      BL       __aeabi_dmul
   \   0000002C   0x.... 0x....      BL       __aeabi_d2f
   \   00000030   0x4905             LDR.N    R1,??refresh_e_factor_0+0x10
   \   00000032   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   00000036   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??refresh_e_factor_0:
   \   00000038   0x........         DC32     _ZN7Planner15flow_percentageE
   \   0000003C   0x47AE147B         DC32     0x47ae147b
   \   00000040   0x3F847AE1         DC32     0x3f847ae1
   \   00000044   0x........         DC32     _ZN7Planner21volumetric_multiplierE
   \   00000048   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
   \                     _ZN7Planner17set_filament_sizeEhRKf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4A09             LDR.N    R2,??set_filament_size_0
   \   00000004   0x6809             LDR      R1,[R1, #+0]
   \   00000006   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   0000000A   0x2300             MOVS     R3,#+0
   \   0000000C   0x4619             MOV      R1,R3
   \   0000000E   0xE008             B.N      ??set_filament_size_1
   \                     ??set_filament_size_2: (+1)
   \   00000010   0xF852 0x0023      LDR      R0,[R2, R3, LSL #+2]
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000018   0xD102             BNE.N    ??set_filament_size_3
   \   0000001A   0x4804             LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
   \   0000001C   0xF842 0x0023      STR      R0,[R2, R3, LSL #+2]
   \                     ??set_filament_size_3: (+1)
   \   00000020   0x1C5B             ADDS     R3,R3,#+1
   \                     ??set_filament_size_1: (+1)
   \   00000022   0x2B02             CMP      R3,#+2
   \   00000024   0xD3F4             BCC.N    ??set_filament_size_2
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
   \                     ??set_filament_size_0:
   \   00000028   0x........         DC32     _ZN7Planner13filament_sizeE
   \   0000002C   0x40400000         DC32     0x40400000

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::force_fade_recalc()
   \                     _ZN7Planner17force_fade_recalcEv: (+1)
   \   00000000   0x4801             LDR.N    R0,??force_fade_recalc_0  ;; 0xc479fff0
   \   00000002   0x4902             LDR.N    R1,??force_fade_recalc_0+0x4
   \   00000004   0x6008             STR      R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??force_fade_recalc_0:
   \   00000008   0xC479FFF0         DC32     0xc479fff0
   \   0000000C   0x........         DC32     _ZN7Planner11last_fade_zE

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_z_fade_height(float const &)
   \                     _ZN7Planner17set_z_fade_heightERKf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4A10             LDR.N    R2,??set_z_fade_height_6
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000000C   0xD201             BCS.N    ??set_z_fade_height_7
   \   0000000E   0x6010             STR      R0,[R2, #+0]
   \   00000010   0xE001             B.N      ??set_z_fade_height_8
   \                     ??set_z_fade_height_7: (+1)
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x6010             STR      R0,[R2, #+0]
   \                     ??set_z_fade_height_8: (+1)
   \   00000016   0x6812             LDR      R2,[R2, #+0]
   \   00000018   0x4610             MOV      R0,R2
   \   0000001A   0x490C             LDR.N    R1,??set_z_fade_height_6+0x4  ;; 0xb58637bd
   \   0000001C   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000020   0xD807             BHI.N    ??set_z_fade_height_9
   \   00000022   0x490B             LDR.N    R1,??set_z_fade_height_6+0x8  ;; 0x358637be
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000028   0xD203             BCS.N    ??set_z_fade_height_9
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4909             LDR.N    R1,??set_z_fade_height_6+0xC
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xE006             B.N      ??set_z_fade_height_10
   \                     ??set_z_fade_height_9: (+1)
   \   00000032   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000036   0x4611             MOV      R1,R2
   \   00000038   0x.... 0x....      BL       __aeabi_fdiv
   \   0000003C   0x4905             LDR.N    R1,??set_z_fade_height_6+0xC
   \   0000003E   0x6008             STR      R0,[R1, #+0]
   \                     ??set_z_fade_height_10: (+1)
   \   00000040   0xE8BD 0x4001      POP      {R0,LR}
   \   00000044   0x.... 0x....      B.W      _ZN7Planner17force_fade_recalcEv
   \                     ??set_z_fade_height_6:
   \   00000048   0x........         DC32     _ZN7Planner13z_fade_heightE
   \   0000004C   0xB58637BD         DC32     0xb58637bd
   \   00000050   0x358637BE         DC32     0x358637be
   \   00000054   0x........         DC32     _ZN7Planner21inverse_z_fade_heightE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::leveling_active_at_z(float const &)
   \                     _ZN7Planner20leveling_active_at_zERKf: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4602             MOV      R2,R0
   \   00000004   0x4807             LDR.N    R0,??leveling_active_at_z_0
   \   00000006   0x6803             LDR      R3,[R0, #+0]
   \   00000008   0x4618             MOV      R0,R3
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000010   0xD004             BEQ.N    ??leveling_active_at_z_1
   \   00000012   0x6810             LDR      R0,[R2, #+0]
   \   00000014   0x4619             MOV      R1,R3
   \   00000016   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000001A   0xD201             BCS.N    ??leveling_active_at_z_2
   \                     ??leveling_active_at_z_1: (+1)
   \   0000001C   0x2001             MOVS     R0,#+1
   \   0000001E   0xBD02             POP      {R1,PC}
   \                     ??leveling_active_at_z_2: (+1)
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xBD02             POP      {R1,PC}          ;; return
   \                     ??leveling_active_at_z_0:
   \   00000024   0x........         DC32     _ZN7Planner13z_fade_heightE

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::apply_leveling(float (&)[3])
   \                     _ZN7Planner14apply_levelingERA3_f: (+1)
   \   00000000   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000004   0x1D01             ADDS     R1,R0,#+4
   \   00000006   0x.... 0x....      B.W      _ZN7Planner14apply_levelingERfS0_S0_

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
   \                     _ZN7Planner11buffer_lineEfffRKfS1_h: (+1)
   \   00000000   0xB537             PUSH     {R0-R2,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0x9D08             LDR      R5,[SP, #+32]
   \   00000008   0x480C             LDR.N    R0,??buffer_line_0
   \   0000000A   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   0000000E   0x222E             MOVS     R2,#+46
   \   00000010   0x4211             TST      R1,R2
   \   00000012   0xD008             BEQ.N    ??buffer_line_1
   \   00000014   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD104             BNE.N    ??buffer_line_1
   \   0000001C   0xAA04             ADD      R2,SP,#+16
   \   0000001E   0xA903             ADD      R1,SP,#+12
   \   00000020   0xA802             ADD      R0,SP,#+8
   \   00000022   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \                     ??buffer_line_1: (+1)
   \   00000026   0x9809             LDR      R0,[SP, #+36]
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0x9500             STR      R5,[SP, #+0]
   \   0000002C   0x4623             MOV      R3,R4
   \   0000002E   0xAA04             ADD      R2,SP,#+16
   \   00000030   0xA903             ADD      R1,SP,#+12
   \   00000032   0xA802             ADD      R0,SP,#+8
   \   00000034   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \   00000038   0xB005             ADD      SP,SP,#+20
   \   0000003A   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??buffer_line_0:
   \   0000003C   0x........         DC32     mksCfg

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
   \                     _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x6820             LDR      R0,[R4, #+0]
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0xA802             ADD      R0,SP,#+8
   \   00000010   0x6861             LDR      R1,[R4, #+4]
   \   00000012   0x6041             STR      R1,[R0, #+4]
   \   00000014   0x68A1             LDR      R1,[R4, #+8]
   \   00000016   0x6081             STR      R1,[R0, #+8]
   \   00000018   0x4F24             LDR.N    R7,??buffer_line_kinematic_0
   \   0000001A   0xF897 0x0040      LDRB     R0,[R7, #+64]
   \   0000001E   0x212E             MOVS     R1,#+46
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD002             BEQ.N    ??buffer_line_kinematic_1
   \   00000024   0xA802             ADD      R0,SP,#+8
   \   00000026   0x.... 0x....      BL       _ZN7Planner14apply_levelingERA3_f
   \                     ??buffer_line_kinematic_1: (+1)
   \   0000002A   0xF107 0x0040      ADD      R0,R7,#+64
   \   0000002E   0xF9B0 0x0018      LDRSH    R0,[R0, #+24]
   \   00000032   0xF240 0x3102      MOVW     R1,#+770
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD02C             BEQ.N    ??buffer_line_kinematic_2
   \   0000003A   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0xD102             BNE.N    ??buffer_line_kinematic_3
   \   00000042   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   00000046   0xE001             B.N      ??buffer_line_kinematic_4
   \                     ??buffer_line_kinematic_3: (+1)
   \   00000048   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   \                     ??buffer_line_kinematic_4: (+1)
   \   0000004C   0x4918             LDR.N    R1,??buffer_line_kinematic_0+0x4
   \   0000004E   0xF891 0x0148      LDRB     R0,[R1, #+328]
   \   00000052   0x2801             CMP      R0,#+1
   \   00000054   0xD111             BNE.N    ??buffer_line_kinematic_5
   \   00000056   0x68A0             LDR      R0,[R4, #+8]
   \   00000058   0xF8D1 0x1298      LDR      R1,[R1, #+664]
   \   0000005C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000060   0xD20B             BCS.N    ??buffer_line_kinematic_5
   \   00000062   0x68E1             LDR      R1,[R4, #+12]
   \   00000064   0x4813             LDR.N    R0,??buffer_line_kinematic_0+0x8
   \   00000066   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000006A   0x68C0             LDR      R0,[R0, #+12]
   \   0000006C   0x.... 0x....      BL       __aeabi_fmul
   \   00000070   0x.... 0x....      BL       lroundf
   \   00000074   0x4910             LDR.N    R1,??buffer_line_kinematic_0+0xC
   \   00000076   0x60C8             STR      R0,[R1, #+12]
   \   00000078   0xE015             B.N      ??buffer_line_kinematic_6
   \                     ??buffer_line_kinematic_5: (+1)
   \   0000007A   0x4810             LDR.N    R0,??buffer_line_kinematic_0+0x10
   \   0000007C   0x9601             STR      R6,[SP, #+4]
   \   0000007E   0x9500             STR      R5,[SP, #+0]
   \   00000080   0xF104 0x030C      ADD      R3,R4,#+12
   \   00000084   0xF100 0x0258      ADD      R2,R0,#+88
   \   00000088   0xF100 0x0154      ADD      R1,R0,#+84
   \   0000008C   0x3050             ADDS     R0,R0,#+80
   \   0000008E   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \   00000092   0xE008             B.N      ??buffer_line_kinematic_6
   \                     ??buffer_line_kinematic_2: (+1)
   \   00000094   0x9601             STR      R6,[SP, #+4]
   \   00000096   0x9500             STR      R5,[SP, #+0]
   \   00000098   0xF104 0x030C      ADD      R3,R4,#+12
   \   0000009C   0xAA04             ADD      R2,SP,#+16
   \   0000009E   0xA903             ADD      R1,SP,#+12
   \   000000A0   0xA802             ADD      R0,SP,#+8
   \   000000A2   0x.... 0x....      BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
   \                     ??buffer_line_kinematic_6: (+1)
   \   000000A6   0xB005             ADD      SP,SP,#+20
   \   000000A8   0xBDF0             POP      {R4-R7,PC}       ;; return
   \   000000AA   0xBF00             Nop      
   \                     ??buffer_line_kinematic_0:
   \   000000AC   0x........         DC32     mksCfg
   \   000000B0   0x........         DC32     gCfgItems
   \   000000B4   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
   \   000000B8   0x........         DC32     _ZN7Planner8positionE
   \   000000BC   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4
   \   __interwork __softfp void Planner::set_position_mm(float, float, float, float const &)
   \                     _ZN7Planner15set_position_mmEfffRKf: (+1)
   \   00000000   0xB517             PUSH     {R0-R2,R4,LR}
   \   00000002   0xB081             SUB      SP,SP,#+4
   \   00000004   0x461C             MOV      R4,R3
   \   00000006   0x480B             LDR.N    R0,??set_position_mm_0
   \   00000008   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   0000000C   0x222E             MOVS     R2,#+46
   \   0000000E   0x4211             TST      R1,R2
   \   00000010   0xD008             BEQ.N    ??set_position_mm_1
   \   00000012   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000016   0x2801             CMP      R0,#+1
   \   00000018   0xD104             BNE.N    ??set_position_mm_1
   \   0000001A   0xAA03             ADD      R2,SP,#+12
   \   0000001C   0xA902             ADD      R1,SP,#+8
   \   0000001E   0xA801             ADD      R0,SP,#+4
   \   00000020   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   \                     ??set_position_mm_1: (+1)
   \   00000024   0x4623             MOV      R3,R4
   \   00000026   0xAA03             ADD      R2,SP,#+12
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0xA801             ADD      R0,SP,#+4
   \   0000002C   0x.... 0x....      BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
   \   00000030   0xBD1F             POP      {R0-R4,PC}       ;; return
   \   00000032   0xBF00             Nop      
   \                     ??set_position_mm_0:
   \   00000034   0x........         DC32     mksCfg

   \                                 In section .text, align 2
   \   __interwork __softfp void Planner::set_e_position_mm(float const &)
   \                     _ZN7Planner17set_e_position_mmERKf: (+1)
   \   00000000   0x4601             MOV      R1,R0
   \   00000002   0x2003             MOVS     R0,#+3
   \   00000004   0x.... 0x....      B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf

   \                                 In section .text, align 4
   \   __interwork __softfp bool Planner::blocks_queued()
   \                     _ZN7Planner13blocks_queuedEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??blocks_queued_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4904             LDR.N    R1,??blocks_queued_0+0x4
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x4288             CMP      R0,R1
   \   0000000A   0xD001             BEQ.N    ??blocks_queued_1
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x4770             BX       LR
   \                     ??blocks_queued_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??blocks_queued_0:
   \   00000014   0x........         DC32     _ZN7Planner17block_buffer_headE
   \   00000018   0x........         DC32     _ZN7Planner17block_buffer_tailE

      static constexpr int8_t next_block_index(const int8_t block_index) { return BLOCK_MOD(block_index + 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",627  Warning[Pe815]: 
          type qualifier on return type is meaningless

      static constexpr int8_t prev_block_index(const int8_t block_index) { return BLOCK_MOD(block_index - 1); }
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",628  Warning[Pe815]: 
          type qualifier on return type is meaningless
    252          #include "stepper.h"

   \                                 In section .text, align 2
   \   __interwork __softfp float Stepper::get_axis_position_degrees(AxisEnum)
   \                     _ZN7Stepper25get_axis_position_degreesE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN7Stepper20get_axis_position_mmE8AxisEnum

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::set_homing_flag_z(bool)
   \                     _ZN7Stepper17set_homing_flag_zEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??set_homing_flag_z_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??set_homing_flag_z_0:
   \   00000008   0x........         DC32     _ZN7Stepper17performing_homingE

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::set_z_lock(bool)
   \                     _ZN7Stepper10set_z_lockEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??set_z_lock_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??set_z_lock_0:
   \   00000008   0x........         DC32     _ZN7Stepper14locked_z_motorE

   \                                 In section .text, align 4
   \   __interwork __softfp void Stepper::set_z2_lock(bool)
   \                     _ZN7Stepper11set_z2_lockEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??set_z2_lock_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??set_z2_lock_0:
   \   00000008   0x........         DC32     _ZN7Stepper15locked_z2_motorE
    253          #include "endstops.h"

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_globally(bool)
   \                     _ZN8Endstops15enable_globallyEb: (+1)
   \   00000000   0x4902             LDR.N    R1,??enable_globally_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4902             LDR.N    R1,??enable_globally_0+0x4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??enable_globally_0:
   \   0000000C   0x........         DC32     _ZN8Endstops7enabledE
   \   00000010   0x........         DC32     _ZN8Endstops16enabled_globallyE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable(bool)
   \                     _ZN8Endstops6enableEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??enable_0:
   \   00000008   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::not_homing()
   \                     _ZN8Endstops10not_homingEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??not_homing_0
   \   00000002   0x7800             LDRB     R0,[R0, #+0]
   \   00000004   0x4902             LDR.N    R1,??not_homing_0+0x4
   \   00000006   0x7008             STRB     R0,[R1, #+0]
   \   00000008   0x4770             BX       LR               ;; return
   \   0000000A   0xBF00             Nop      
   \                     ??not_homing_0:
   \   0000000C   0x........         DC32     _ZN8Endstops16enabled_globallyE
   \   00000010   0x........         DC32     _ZN8Endstops7enabledE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::hit_on_purpose()
   \                     _ZN8Endstops14hit_on_purposeEv: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??hit_on_purpose_0
   \   00000004   0x7008             STRB     R0,[R1, #+0]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??hit_on_purpose_0:
   \   00000008   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4
   \   __interwork __softfp void Endstops::enable_z_probe(bool)
   \                     _ZN8Endstops14enable_z_probeEb: (+1)
   \   00000000   0x4901             LDR.N    R1,??enable_z_probe_0
   \   00000002   0x7008             STRB     R0,[R1, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??enable_z_probe_0:
   \   00000008   0x........         DC32     _ZN8Endstops15z_probe_enabledE
    254          #include "temperature.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
   \                     _ZN11Temperature16tooColdToExtrudeEh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x480B             LDR.N    R0,??tooColdToExtrude_0
   \   00000006   0x7800             LDRB     R0,[R0, #+0]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??tooColdToExtrude_1
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??tooColdToExtrude_1: (+1)
   \   00000010   0x4809             LDR.N    R0,??tooColdToExtrude_0+0x4
   \   00000012   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       __aeabi_i2f
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x460D             MOV      R5,R1
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000024   0x4629             MOV      R1,R5
   \   00000026   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002A   0xD201             BCS.N    ??tooColdToExtrude_2
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??tooColdToExtrude_2: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \                     ??tooColdToExtrude_0:
   \   00000034   0x........         DC32     _ZN11Temperature18allow_cold_extrudeE
   \   00000038   0x........         DC32     _ZN11Temperature16extrude_min_tempE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degHotend(uint8_t)
   \                     _ZN11Temperature9degHotendEh: (+1)
   \   00000000   0x4901             LDR.N    R1,??degHotend_0
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??degHotend_0:
   \   00000008   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degBed()
   \                     _ZN11Temperature6degBedEv: (+1)
   \   00000000   0x4801             LDR.N    R0,??degBed_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return
   \   00000006   0xBF00             Nop      
   \                     ??degBed_0:
   \   00000008   0x........         DC32     _ZN11Temperature23current_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetHotend(uint8_t)
   \                     _ZN11Temperature15degTargetHotendEh: (+1)
   \   00000000   0x4902             LDR.N    R1,??degTargetHotend_0
   \   00000002   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000006   0x.... 0x....      B.W      __aeabi_i2f
   \   0000000A   0xBF00             Nop      
   \                     ??degTargetHotend_0:
   \   0000000C   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp float Temperature::degTargetBed()
   \                     _ZN11Temperature12degTargetBedEv: (+1)
   \   00000000   0x4802             LDR.N    R0,??degTargetBed_0
   \   00000002   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000006   0x.... 0x....      B.W      __aeabi_i2f
   \   0000000A   0xBF00             Nop      
   \                     ??degTargetBed_0:
   \   0000000C   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
   \                     _ZN11Temperature15setTargetHotendEfh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1

        target_temperature[HOTEND_INDEX] = celsius;
                                         ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",406  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000004   0x.... 0x....      BL       __aeabi_f2iz
   \   00000008   0x4903             LDR.N    R1,??setTargetHotend_0
   \   0000000A   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0xE8BD 0x4010      POP      {R4,LR}
   \   00000014   0x.... 0x....      B.W      _ZN11Temperature21start_watching_heaterEh
   \                     ??setTargetHotend_0:
   \   00000018   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::setTargetBed(float)
   \                     _ZN11Temperature12setTargetBedEf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4809             LDR.N    R0,??setTargetBed_0
   \   00000006   0xF9B0 0x5032      LDRSH    R5,[R0, #+50]
   \   0000000A   0x4628             MOV      R0,R5
   \   0000000C   0x.... 0x....      BL       __aeabi_i2f
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD202             BCS.N    ??setTargetBed_1
   \   0000001A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000001E   0x4605             MOV      R5,R0
   \                     ??setTargetBed_1: (+1)
   \   00000020   0x4803             LDR.N    R0,??setTargetBed_0+0x4
   \   00000022   0x8005             STRH     R5,[R0, #+0]

          target_temperature_bed =
                                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\temperature.h",414  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000024   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000028   0x.... 0x....      B.W      _ZN11Temperature18start_watching_bedEv
   \                     ??setTargetBed_0:
   \   0000002C   0x........         DC32     mksCfg
   \   00000030   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
   \                     _ZN11Temperature15isCoolingHotendEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x4807             LDR.N    R0,??isCoolingHotend_0
   \   00000006   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000000A   0x.... 0x....      BL       __aeabi_i2f
   \   0000000E   0x4906             LDR.N    R1,??isCoolingHotend_0+0x4
   \   00000010   0xF851 0x1024      LDR      R1,[R1, R4, LSL #+2]
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD201             BCS.N    ??isCoolingHotend_1
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C   0xBD10             POP      {R4,PC}
   \                     ??isCoolingHotend_1: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xBD10             POP      {R4,PC}          ;; return
   \   00000022   0xBF00             Nop      
   \                     ??isCoolingHotend_0:
   \   00000024   0x........         DC32     _ZN11Temperature18target_temperatureE
   \   00000028   0x........         DC32     _ZN11Temperature19current_temperatureE

   \                                 In section .text, align 4
   \   __interwork __softfp bool Temperature::isCoolingBed()
   \                     _ZN11Temperature12isCoolingBedEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x4807             LDR.N    R0,??isCoolingBed_0
   \   00000004   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000008   0x.... 0x....      BL       __aeabi_i2f
   \   0000000C   0x4905             LDR.N    R1,??isCoolingBed_0+0x4
   \   0000000E   0x6809             LDR      R1,[R1, #+0]
   \   00000010   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000014   0xD201             BCS.N    ??isCoolingBed_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0xBD02             POP      {R1,PC}
   \                     ??isCoolingBed_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0xBD02             POP      {R1,PC}          ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??isCoolingBed_0:
   \   00000020   0x........         DC32     _ZN11Temperature22target_temperature_bedE
   \   00000024   0x........         DC32     _ZN11Temperature23current_temperature_bedE

   \                                 In section .text, align 2
   \   __interwork __softfp void Temperature::updatePID()
   \                     _ZN11Temperature9updatePIDEv: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void Temperature::set_auto_report_interval(uint8_t)
   \                     _ZN11Temperature24set_auto_report_intervalEh: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x2C3D             CMP      R4,#+61
   \   00000006   0xDB00             BLT.N    ??set_auto_report_interval_0
   \   00000008   0x243C             MOVS     R4,#+60
   \                     ??set_auto_report_interval_0: (+1)
   \   0000000A   0x4805             LDR.N    R0,??set_auto_report_interval_1
   \   0000000C   0x7004             STRB     R4,[R0, #+0]
   \   0000000E   0x.... 0x....      BL       HAL_GetTick
   \   00000012   0xF44F 0x717A      MOV      R1,#+1000
   \   00000016   0xFB01 0x0004      MLA      R0,R1,R4,R0
   \   0000001A   0x4902             LDR.N    R1,??set_auto_report_interval_1+0x4
   \   0000001C   0x6008             STR      R0,[R1, #+0]
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   \                     ??set_auto_report_interval_1:
   \   00000020   0x........         DC32     _ZN11Temperature25auto_report_temp_intervalE
   \   00000024   0x........         DC32     _ZN11Temperature19next_temp_report_msE
    255          #include "cardreader.h"

  #define SD_DETECT_INVERTED false
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",27  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DETECT_INVERTED" (declared at
          line 524 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Configuration_adv.h")

  #define PSTR(s) s
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",31  Warning[Pe047]: 
          incompatible redefinition of macro "PSTR" (declared at line 63 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin.h")

  #define pgm_read_byte(x) (*(char*)x)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",32  Warning[Pe047]: 
          incompatible redefinition of macro "pgm_read_byte" (declared at line
          64 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\Marlin_export.h")

  #define LONG_FILENAME_LENGTH (13*MAX_VFAT_ENTRIES+1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\cardreader.h",61  Warning[Pe047]: 
          incompatible redefinition of macro "LONG_FILENAME_LENGTH" (declared
          at line 119 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define ALLOW_DEPRECATED_FUNCTIONS 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",635  Warning[Pe047]: 
          incompatible redefinition of macro "ALLOW_DEPRECATED_FUNCTIONS"
          (declared at line 67 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

  #define SPI_SD_INIT_RATE 11
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\SdFat.h",647  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_SD_INIT_RATE" (declared at
          line 79 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\SdFatConfig.h")

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::isFileOpen()
   \                     _ZN10CardReader10isFileOpenEv: (+1)
   \   00000000   0xF8D0 0x0200      LDR      R0,[R0, #+512]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??isFileOpen_0
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??isFileOpen_0: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool CardReader::eof()
   \                     _ZN10CardReader3eofEv: (+1)
   \   00000000   0xF8D0 0x1460      LDR      R1,[R0, #+1120]
   \   00000004   0xF8D0 0x045C      LDR      R0,[R0, #+1116]
   \   00000008   0x4281             CMP      R1,R0
   \   0000000A   0x4180             SBCS     R0,R0,R0
   \   0000000C   0x43C0             MVNS     R0,R0
   \   0000000E   0x0FC0             LSRS     R0,R0,#+31
   \   00000010   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t CardReader::get()
   \                     _ZN10CardReader3getEv: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0xAB01             ADD      R3,SP,#+4
   \   00000006   0x2201             MOVS     R2,#+1
   \   00000008   0xA900             ADD      R1,SP,#+0
   \   0000000A   0x.... 0x....      BL       f_read
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD004             BEQ.N    ??get_0
   \   00000012   0xF04F 0x30FF      MOV      R0,#-1
   \   00000016   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000001A   0xE005             B.N      ??get_1
   \                     ??get_0: (+1)
   \   0000001C   0xF8D4 0x0460      LDR      R0,[R4, #+1120]
   \   00000020   0x9901             LDR      R1,[SP, #+4]
   \   00000022   0x1808             ADDS     R0,R1,R0
   \   00000024   0xF8C4 0x0460      STR      R0,[R4, #+1120]
   \                     ??get_1: (+1)
   \   00000028   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000002C   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp void CardReader::setIndex(long)
   \                     _ZN10CardReader8setIndexEl: (+1)
   \   00000000   0xF8C0 0x1460      STR      R1,[R0, #+1120]
   \   00000004   0x.... 0x....      B.W      f_lseek
    256          #include "configuration_store.h"
    257          #include "language.h"
    258          //#include "pins_arduino.h"
    259          #include "math.h"
    260          #include "nozzle.h"
    261          #include "duration_t.h"

   \                                 In section .text, align 2
   \   __code __interwork __softfp duration_t::duration_t(uint32_t const &)
   \                     _ZN10duration_tC1ERKj: (+1)
   \   00000000   0x6809             LDR      R1,[R1, #+0]
   \   00000002   0x6001             STR      R1,[R0, #+0]
   \   00000004   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t duration_t::year() const
   \                     _ZNK10duration_t4yearEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \   00000006   0xF240 0x116D      MOVW     R1,#+365
   \   0000000A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t duration_t::day() const
   \                     _ZNK10duration_t3dayEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \   00000006   0x2118             MOVS     R1,#+24
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xB280             UXTH     R0,R0
   \   0000000E   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::hour() const
   \                     _ZNK10duration_t4hourEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \   00000006   0x213C             MOVS     R1,#+60
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::minute() const
   \                     _ZNK10duration_t6minuteEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \   00000006   0x213C             MOVS     R1,#+60
   \   00000008   0xFBB0 0xF0F1      UDIV     R0,R0,R1
   \   0000000C   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint32_t duration_t::second() const
   \                     _ZNK10duration_t6secondEv: (+1)
   \   00000000   0x6800             LDR      R0,[R0, #+0]
   \   00000002   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp void duration_t::toString(char *) const
   \                     _ZNK10duration_t8toStringEPc: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4607             MOV      R7,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x.... 0x....      BL       _ZNK10duration_t4yearEv
   \   0000000E   0x4605             MOV      R5,R0
   \   00000010   0x4638             MOV      R0,R7
   \   00000012   0x.... 0x....      BL       _ZNK10duration_t3dayEv
   \   00000016   0xF240 0x116D      MOVW     R1,#+365
   \   0000001A   0xFB90 0xF1F1      SDIV     R1,R0,R1
   \   0000001E   0xF240 0x126D      MOVW     R2,#+365
   \   00000022   0xFB02 0x0611      MLS      R6,R2,R1,R0
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       _ZNK10duration_t4hourEv
   \   0000002C   0x2118             MOVS     R1,#+24
   \   0000002E   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000032   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000036   0xEBA0 0x08C2      SUB      R8,R0,R2, LSL #+3
   \   0000003A   0x4638             MOV      R0,R7
   \   0000003C   0x.... 0x....      BL       _ZNK10duration_t6minuteEv
   \   00000040   0xF04F 0x093C      MOV      R9,#+60
   \   00000044   0x4649             MOV      R1,R9
   \   00000046   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000004A   0xFB09 0x0A11      MLS      R10,R9,R1,R0
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       _ZNK10duration_t6secondEv
   \   00000054   0x4649             MOV      R1,R9
   \   00000056   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000005A   0xFB09 0x0211      MLS      R2,R9,R1,R0
   \   0000005E   0x2D00             CMP      R5,#+0
   \   00000060   0xD00B             BEQ.N    ??toString_0
   \   00000062   0x9202             STR      R2,[SP, #+8]
   \   00000064   0xF8CD 0xA004      STR      R10,[SP, #+4]
   \   00000068   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   0000006C   0x4633             MOV      R3,R6
   \   0000006E   0x462A             MOV      R2,R5
   \   00000070   0x4918             LDR.N    R1,??toString_1
   \   00000072   0x4620             MOV      R0,R4
   \   00000074   0x.... 0x....      BL       sprintf
   \   00000078   0xE029             B.N      ??toString_2
   \                     ??toString_0: (+1)
   \   0000007A   0x2E00             CMP      R6,#+0
   \   0000007C   0xD009             BEQ.N    ??toString_3
   \   0000007E   0x9201             STR      R2,[SP, #+4]
   \   00000080   0xF8CD 0xA000      STR      R10,[SP, #+0]
   \   00000084   0x4643             MOV      R3,R8
   \   00000086   0x4632             MOV      R2,R6
   \   00000088   0x4913             LDR.N    R1,??toString_1+0x4
   \   0000008A   0x4620             MOV      R0,R4
   \   0000008C   0x.... 0x....      BL       sprintf
   \   00000090   0xE01D             B.N      ??toString_2
   \                     ??toString_3: (+1)
   \   00000092   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000096   0xD007             BEQ.N    ??toString_4
   \   00000098   0x9200             STR      R2,[SP, #+0]
   \   0000009A   0x4653             MOV      R3,R10
   \   0000009C   0x4642             MOV      R2,R8
   \   0000009E   0x490F             LDR.N    R1,??toString_1+0x8
   \   000000A0   0x4620             MOV      R0,R4
   \   000000A2   0x.... 0x....      BL       sprintf
   \   000000A6   0xE012             B.N      ??toString_2
   \                     ??toString_4: (+1)
   \   000000A8   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000AC   0xD008             BEQ.N    ??toString_5
   \   000000AE   0x4613             MOV      R3,R2
   \   000000B0   0x4652             MOV      R2,R10
   \   000000B2   0x490B             LDR.N    R1,??toString_1+0xC
   \   000000B4   0x4620             MOV      R0,R4
   \   000000B6   0xB004             ADD      SP,SP,#+16
   \   000000B8   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000BC   0x.... 0x....      B.W      sprintf
   \                     ??toString_5: (+1)
   \   000000C0   0x4908             LDR.N    R1,??toString_1+0x10
   \   000000C2   0x4620             MOV      R0,R4
   \   000000C4   0xB004             ADD      SP,SP,#+16
   \   000000C6   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000CA   0x.... 0x....      B.W      sprintf
   \                     ??toString_2: (+1)
   \   000000CE   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \   000000D2   0xBF00             Nop      
   \                     ??toString_1:
   \   000000D4   0x........         DC32     _ZZNK10duration_t8toStringEPcEs
   \   000000D8   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_0
   \   000000DC   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_1
   \   000000E0   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_2
   \   000000E4   0x........         DC32     _ZZNK10duration_t8toStringEPcEs_3
    262          //#include "types.h"
    263          #include "tim.h"
    264          #include "gcode.h"

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::seen(char)
   \                     _ZN11GCodeParser4seenEc: (+1)
   \   00000000   0xF1A0 0x0141      SUB      R1,R0,#+65
   \   00000004   0xB2C9             UXTB     R1,R1
   \   00000006   0x291A             CMP      R1,#+26
   \   00000008   0xD301             BCC.N    ??seen_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
   \                     ??seen_0: (+1)
   \   0000000E   0x10C8             ASRS     R0,R1,#+3
   \   00000010   0x4A0A             LDR.N    R2,??seen_1
   \   00000012   0x5C80             LDRB     R0,[R0, R2]
   \   00000014   0xF001 0x0207      AND      R2,R1,#0x7
   \   00000018   0x40D0             LSRS     R0,R0,R2
   \   0000001A   0xF010 0x0001      ANDS     R0,R0,#0x1
   \   0000001E   0xD00B             BEQ.N    ??seen_2
   \   00000020   0x4A07             LDR.N    R2,??seen_1+0x4
   \   00000022   0x5C89             LDRB     R1,[R1, R2]
   \   00000024   0x4A07             LDR.N    R2,??seen_1+0x8
   \   00000026   0x2900             CMP      R1,#+0
   \   00000028   0xD004             BEQ.N    ??seen_3
   \   0000002A   0x4B07             LDR.N    R3,??seen_1+0xC
   \   0000002C   0x681B             LDR      R3,[R3, #+0]
   \   0000002E   0x18C9             ADDS     R1,R1,R3
   \   00000030   0x6011             STR      R1,[R2, #+0]
   \   00000032   0x4770             BX       LR
   \                     ??seen_3: (+1)
   \   00000034   0x2100             MOVS     R1,#+0
   \   00000036   0x6011             STR      R1,[R2, #+0]
   \                     ??seen_2: (+1)
   \   00000038   0x4770             BX       LR               ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??seen_1:
   \   0000003C   0x........         DC32     _ZN11GCodeParser8codebitsE
   \   00000040   0x........         DC32     _ZN11GCodeParser5paramE
   \   00000044   0x........         DC32     _ZN11GCodeParser9value_ptrE
   \   00000048   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp bool GCodeParser::has_value()
   \                     _ZN11GCodeParser9has_valueEv: (+1)
   \   00000000   0x4803             LDR.N    R0,??has_value_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD001             BEQ.N    ??has_value_1
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x4770             BX       LR
   \                     ??has_value_1: (+1)
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x4770             BX       LR               ;; return
   \                     ??has_value_0:
   \   00000010   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::seenval(char)
   \                     _ZN11GCodeParser7seenvalEc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD003             BEQ.N    ??seenval_0
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      _ZN11GCodeParser9has_valueEv
   \                     ??seenval_0: (+1)
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp float GCodeParser::value_float()
   \                     _ZN11GCodeParser11value_floatEv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4A12             LDR.N    R2,??value_float_0
   \   00000004   0x6810             LDR      R0,[R2, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD01D             BEQ.N    ??value_float_1
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0xE000             B.N      ??value_float_2
   \                     ??value_float_3: (+1)
   \   0000000E   0x1C64             ADDS     R4,R4,#+1
   \                     ??value_float_2: (+1)
   \   00000010   0xF994 0x5000      LDRSB    R5,[R4, #+0]
   \   00000014   0x2D00             CMP      R5,#+0
   \   00000016   0xD001             BEQ.N    ??value_float_4
   \   00000018   0x2D20             CMP      R5,#+32
   \   0000001A   0xD106             BNE.N    ??value_float_5
   \                     ??value_float_4: (+1)
   \   0000001C   0x2100             MOVS     R1,#+0
   \   0000001E   0x.... 0x....      BL       strtod
   \   00000022   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000026   0x.... 0x....      B.W      __aeabi_d2f
   \                     ??value_float_5: (+1)
   \   0000002A   0x2D45             CMP      R5,#+69
   \   0000002C   0xD001             BEQ.N    ??value_float_6
   \   0000002E   0x2D65             CMP      R5,#+101
   \   00000030   0xD1ED             BNE.N    ??value_float_3
   \                     ??value_float_6: (+1)
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x7020             STRB     R0,[R4, #+0]
   \   00000036   0x4601             MOV      R1,R0
   \   00000038   0x6810             LDR      R0,[R2, #+0]
   \   0000003A   0x.... 0x....      BL       strtod
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x7025             STRB     R5,[R4, #+0]
   \   00000044   0xBD32             POP      {R1,R4,R5,PC}
   \                     ??value_float_1: (+1)
   \   00000046   0x2000             MOVS     R0,#+0
   \   00000048   0xBD32             POP      {R1,R4,R5,PC}    ;; return
   \   0000004A   0xBF00             Nop      
   \                     ??value_float_0:
   \   0000004C   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp int32_t GCodeParser::value_long()
   \                     _ZN11GCodeParser10value_longEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??value_long_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??value_long_1
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      strtol
   \                     ??value_long_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??value_long_0:
   \   00000014   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 4
   \   __interwork __softfp uint32_t GCodeParser::value_ulong()
   \                     _ZN11GCodeParser11value_ulongEv: (+1)
   \   00000000   0x4804             LDR.N    R0,??value_ulong_0
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x2800             CMP      R0,#+0
   \   00000006   0xD003             BEQ.N    ??value_ulong_1
   \   00000008   0x220A             MOVS     R2,#+10
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      B.W      strtoul
   \                     ??value_ulong_1: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x4770             BX       LR               ;; return
   \                     ??value_ulong_0:
   \   00000014   0x........         DC32     _ZN11GCodeParser9value_ptrE

   \                                 In section .text, align 2
   \   __interwork __softfp millis_t GCodeParser::value_millis()
   \                     _ZN11GCodeParser12value_millisEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_ulongEv

   \                                 In section .text, align 4

    FORCE_INLINE static millis_t value_millis_from_seconds() { return value_float() * 1000UL; }
                                                                      ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\gcode.h",207  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
   \                     _ZN11GCodeParser25value_millis_from_secondsEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000006   0x4903             LDR.N    R1,??value_millis_from_seconds_0  ;; 0x447a0000
   \   00000008   0x.... 0x....      BL       __aeabi_fmul
   \   0000000C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000010   0x.... 0x....      B.W      __aeabi_f2uiz
   \                     ??value_millis_from_seconds_0:
   \   00000014   0x447A0000         DC32     0x447a0000

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t GCodeParser::value_int()
   \                     _ZN11GCodeParser9value_intEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0xB200             SXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t GCodeParser::value_ushort()
   \                     _ZN11GCodeParser12value_ushortEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0xB280             UXTH     R0,R0
   \   00000008   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t GCodeParser::value_byte()
   \                     _ZN11GCodeParser10value_byteEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD501             BPL.N    ??value_byte_0
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE007             B.N      ??value_byte_1
   \                     ??value_byte_0: (+1)
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000012   0x28FF             CMP      R0,#+255
   \   00000014   0xDD01             BLE.N    ??value_byte_2
   \   00000016   0x20FF             MOVS     R0,#+255
   \   00000018   0xE001             B.N      ??value_byte_1
   \                     ??value_byte_2: (+1)
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \                     ??value_byte_1: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::value_bool()
   \                     _ZN11GCodeParser10value_boolEv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x.... 0x....      BL       _ZN11GCodeParser9has_valueEv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD006             BEQ.N    ??value_bool_0
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   0000000E   0x1E40             SUBS     R0,R0,#+1
   \   00000010   0x4180             SBCS     R0,R0,R0
   \   00000012   0x43C0             MVNS     R0,R0
   \   00000014   0x0FC0             LSRS     R0,R0,#+31
   \   00000016   0xBD02             POP      {R1,PC}
   \                     ??value_bool_0: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0xBD02             POP      {R1,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_linear_units()
   \                     _ZN11GCodeParser18value_linear_unitsEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_axis_units(AxisEnum)
   \                     _ZN11GCodeParser16value_axis_unitsE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_per_axis_unit(AxisEnum)
   \                     _ZN11GCodeParser19value_per_axis_unitE8AxisEnum: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_celsius()
   \                     _ZN11GCodeParser13value_celsiusEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser11value_floatEv

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::value_feedrate()
   \                     _ZN11GCodeParser14value_feedrateEv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN11GCodeParser18value_linear_unitsEv

   \                                 In section .text, align 2
   \   __interwork __softfp bool GCodeParser::boolval(char)
   \                     _ZN11GCodeParser7boolvalEc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??boolval_0
   \   0000000C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000010   0x.... 0x....      B.W      _ZN11GCodeParser10value_boolEv
   \                     ??boolval_0: (+1)
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _ZN11GCodeParser4seenEc

   \                                 In section .text, align 2
   \   __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
   \                     _ZN11GCodeParser7bytevalEch: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??byteval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??byteval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
   \                     _ZN11GCodeParser6intvalEcs: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??intval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??intval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
   \                     _ZN11GCodeParser9ushortvalEct: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??ushortval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser12value_ushortEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??ushortval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::linearval(char, float)
   \                     _ZN11GCodeParser9linearvalEcf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??linearval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??linearval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2
   \   __interwork __softfp float GCodeParser::celsiusval(char, float)
   \                     _ZN11GCodeParser10celsiusvalEcf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??celsiusval_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000010   0x4604             MOV      R4,R0
   \                     ??celsiusval_0: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xBD10             POP      {R4,PC}          ;; return
    265          
    266          #include "least_squares_fit.h"

   \                                 In section .text, align 2
   \   __interwork __softfp void incremental_LSF_reset(linear_fit_data *)
   \                     _Z21incremental_LSF_resetP15linear_fit_data: (+1)
   \   00000000   0x223C             MOVS     R2,#+60
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      B.W      memset

   \                                 In section .text, align 2
   \   __interwork __softfp void incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
   \                     _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460F             MOV      R7,R1
   \   00000008   0x4616             MOV      R6,R2
   \   0000000A   0x4698             MOV      R8,R3
   \   0000000C   0x6829             LDR      R1,[R5, #+0]
   \   0000000E   0x6838             LDR      R0,[R7, #+0]
   \   00000010   0x.... 0x....      BL       __aeabi_fadd
   \   00000014   0x6028             STR      R0,[R5, #+0]
   \   00000016   0x6869             LDR      R1,[R5, #+4]
   \   00000018   0x6830             LDR      R0,[R6, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_fadd
   \   0000001E   0x6068             STR      R0,[R5, #+4]
   \   00000020   0x68A9             LDR      R1,[R5, #+8]
   \   00000022   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000026   0x.... 0x....      BL       __aeabi_fadd
   \   0000002A   0x60A8             STR      R0,[R5, #+8]
   \   0000002C   0xF8D7 0xB000      LDR      R11,[R7, #+0]
   \   00000030   0xF04F 0x0902      MOV      R9,#+2
   \   00000034   0xF04F 0x547E      MOV      R4,#+1065353216
   \   00000038   0x46A2             MOV      R10,R4
   \   0000003A   0xE004             B.N      ??incremental_LSF_0
   \                     ??incremental_LSF_1: (+1)
   \   0000003C   0x4658             MOV      R0,R11
   \   0000003E   0x4659             MOV      R1,R11
   \   00000040   0x.... 0x....      BL       __aeabi_fmul
   \   00000044   0x4683             MOV      R11,R0
   \                     ??incremental_LSF_0: (+1)
   \   00000046   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000004A   0xD504             BPL.N    ??incremental_LSF_2
   \   0000004C   0x4650             MOV      R0,R10
   \   0000004E   0x4659             MOV      R1,R11
   \   00000050   0x.... 0x....      BL       __aeabi_fmul
   \   00000054   0x4682             MOV      R10,R0
   \                     ??incremental_LSF_2: (+1)
   \   00000056   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000005A   0xD1EF             BNE.N    ??incremental_LSF_1
   \   0000005C   0x68E8             LDR      R0,[R5, #+12]
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      BL       __aeabi_fadd
   \   00000064   0x60E8             STR      R0,[R5, #+12]
   \   00000066   0xF8D6 0xB000      LDR      R11,[R6, #+0]
   \   0000006A   0xF04F 0x0902      MOV      R9,#+2
   \   0000006E   0x46A2             MOV      R10,R4
   \   00000070   0xE004             B.N      ??incremental_LSF_3
   \                     ??incremental_LSF_4: (+1)
   \   00000072   0x4658             MOV      R0,R11
   \   00000074   0x4659             MOV      R1,R11
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0x4683             MOV      R11,R0
   \                     ??incremental_LSF_3: (+1)
   \   0000007C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000080   0xD504             BPL.N    ??incremental_LSF_5
   \   00000082   0x4650             MOV      R0,R10
   \   00000084   0x4659             MOV      R1,R11
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4682             MOV      R10,R0
   \                     ??incremental_LSF_5: (+1)
   \   0000008C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000090   0xD1EF             BNE.N    ??incremental_LSF_4
   \   00000092   0x6928             LDR      R0,[R5, #+16]
   \   00000094   0x4651             MOV      R1,R10
   \   00000096   0x.... 0x....      BL       __aeabi_fadd
   \   0000009A   0x6128             STR      R0,[R5, #+16]
   \   0000009C   0xF8D8 0xA000      LDR      R10,[R8, #+0]
   \   000000A0   0xF04F 0x0902      MOV      R9,#+2
   \   000000A4   0xE004             B.N      ??incremental_LSF_6
   \                     ??incremental_LSF_7: (+1)
   \   000000A6   0x4650             MOV      R0,R10
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fmul
   \   000000AE   0x4682             MOV      R10,R0
   \                     ??incremental_LSF_6: (+1)
   \   000000B0   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000B4   0xD504             BPL.N    ??incremental_LSF_8
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x4651             MOV      R1,R10
   \   000000BA   0x.... 0x....      BL       __aeabi_fmul
   \   000000BE   0x4604             MOV      R4,R0
   \                     ??incremental_LSF_8: (+1)
   \   000000C0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000C4   0xD1EF             BNE.N    ??incremental_LSF_7
   \   000000C6   0x6968             LDR      R0,[R5, #+20]
   \   000000C8   0x4621             MOV      R1,R4
   \   000000CA   0x.... 0x....      BL       __aeabi_fadd
   \   000000CE   0x6168             STR      R0,[R5, #+20]
   \   000000D0   0x6839             LDR      R1,[R7, #+0]
   \   000000D2   0x6830             LDR      R0,[R6, #+0]
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x69A9             LDR      R1,[R5, #+24]
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x61A8             STR      R0,[R5, #+24]
   \   000000E0   0x6839             LDR      R1,[R7, #+0]
   \   000000E2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x69E9             LDR      R1,[R5, #+28]
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x61E8             STR      R0,[R5, #+28]
   \   000000F2   0x6831             LDR      R1,[R6, #+0]
   \   000000F4   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000F8   0x.... 0x....      BL       __aeabi_fmul
   \   000000FC   0x6A29             LDR      R1,[R5, #+32]
   \   000000FE   0x.... 0x....      BL       __aeabi_fadd
   \   00000102   0x6228             STR      R0,[R5, #+32]
   \   00000104   0x6A68             LDR      R0,[R5, #+36]
   \   00000106   0x6839             LDR      R1,[R7, #+0]
   \   00000108   0xF021 0x4100      BIC      R1,R1,#0x80000000
   \   0000010C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000110   0xD202             BCS.N    ??incremental_LSF_9
   \   00000112   0x6838             LDR      R0,[R7, #+0]
   \   00000114   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \                     ??incremental_LSF_9: (+1)
   \   00000118   0x6268             STR      R0,[R5, #+36]
   \   0000011A   0x6AA8             LDR      R0,[R5, #+40]
   \   0000011C   0x6831             LDR      R1,[R6, #+0]
   \   0000011E   0xF021 0x4100      BIC      R1,R1,#0x80000000
   \   00000122   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000126   0xD202             BCS.N    ??incremental_LSF_10
   \   00000128   0x6830             LDR      R0,[R6, #+0]
   \   0000012A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \                     ??incremental_LSF_10: (+1)
   \   0000012E   0x62A8             STR      R0,[R5, #+40]
   \   00000130   0x6BA9             LDR      R1,[R5, #+56]
   \   00000132   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000136   0x.... 0x....      BL       __aeabi_fadd
   \   0000013A   0x63A8             STR      R0,[R5, #+56]
   \   0000013C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
    267          #include "ubl.h"

          	cx = (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
          	   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",182  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					cx = (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",184  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					cy = (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",195  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					cy = (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",197  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					px= (x - (MESH_MIN_X_IS_KINEMATIC) + (MESH_X_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  					  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",208  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					px= (x - (MESH_MIN_X_IS_Cartesian) + (MESH_X_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  					  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",210  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_KINEMATIC) + (MESH_Y_DIST_IS_KINEMATIC) * 0.5) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",219  Warning[Pa093]: 
          implicit conversion from floating point to integer

  					py = (y - (MESH_MIN_Y_IS_Cartesian) + (MESH_Y_DIST_IS_Cartesian) * 0.5) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  					   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\ubl.h",221  Warning[Pa093]: 
          implicit conversion from floating point to integer

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_xposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4F4A             LDR.N    R7,??mesh_index_to_xpos_0
   \   00000008   0xF897 0x6060      LDRB     R6,[R7, #+96]
   \   0000000C   0xF107 0x0008      ADD      R0,R7,#+8
   \   00000010   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   00000014   0xF240 0x3202      MOVW     R2,#+770
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD02B             BEQ.N    ??mesh_index_to_xpos_1
   \   0000001C   0x42B5             CMP      R5,R6
   \   0000001E   0xD203             BCS.N    ??mesh_index_to_xpos_2
   \   00000020   0x4844             LDR.N    R0,??mesh_index_to_xpos_0+0x4
   \   00000022   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000026   0xE081             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_2: (+1)
   \   00000028   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000030   0x4682             MOV      R10,R0
   \   00000032   0x4C41             LDR.N    R4,??mesh_index_to_xpos_0+0x8
   \   00000034   0x6820             LDR      R0,[R4, #+0]
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fadd
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_ui2f
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x6860             LDR      R0,[R4, #+4]
   \   00000048   0x4651             MOV      R1,R10
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4604             MOV      R4,R0
   \   00000056   0x1E70             SUBS     R0,R6,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000070   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_1: (+1)
   \   00000074   0x42B5             CMP      R5,R6
   \   00000076   0xD203             BCS.N    ??mesh_index_to_xpos_4
   \   00000078   0x482E             LDR.N    R0,??mesh_index_to_xpos_0+0x4
   \   0000007A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000007E   0xE055             B.N      ??mesh_index_to_xpos_3
   \                     ??mesh_index_to_xpos_4: (+1)
   \   00000080   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   00000084   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   00000094   0x.... 0x....      BL       __aeabi_ui2f
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fadd
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF107 0x0060      ADD      R0,R7,#+96
   \   000000AE   0xF8D0 0xB00C      LDR      R11,[R0, #+12]
   \   000000B2   0x68B8             LDR      R0,[R7, #+8]
   \   000000B4   0x4659             MOV      R1,R11
   \   000000B6   0x.... 0x....      BL       __aeabi_fadd
   \   000000BA   0x4607             MOV      R7,R0
   \   000000BC   0x4621             MOV      R1,R4
   \   000000BE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C2   0xD201             BCS.N    ??mesh_index_to_xpos_5
   \   000000C4   0x9400             STR      R4,[SP, #+0]
   \   000000C6   0xE000             B.N      ??mesh_index_to_xpos_6
   \                     ??mesh_index_to_xpos_5: (+1)
   \   000000C8   0x9700             STR      R7,[SP, #+0]
   \                     ??mesh_index_to_xpos_6: (+1)
   \   000000CA   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CE   0x4649             MOV      R1,R9
   \   000000D0   0x.... 0x....      BL       __aeabi_fmul
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fsub
   \   000000DA   0x4681             MOV      R9,R0
   \   000000DC   0x4640             MOV      R0,R8
   \   000000DE   0x4659             MOV      R1,R11
   \   000000E0   0x.... 0x....      BL       __aeabi_fadd
   \   000000E4   0x4601             MOV      R1,R0
   \   000000E6   0x4648             MOV      R0,R9
   \   000000E8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EC   0xD300             BCC.N    ??mesh_index_to_xpos_7
   \   000000EE   0x4689             MOV      R9,R1
   \                     ??mesh_index_to_xpos_7: (+1)
   \   000000F0   0x4638             MOV      R0,R7
   \   000000F2   0x4621             MOV      R1,R4
   \   000000F4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F8   0xD300             BCC.N    ??mesh_index_to_xpos_8
   \   000000FA   0x463C             MOV      R4,R7
   \                     ??mesh_index_to_xpos_8: (+1)
   \   000000FC   0x4628             MOV      R0,R5
   \   000000FE   0x.... 0x....      BL       __aeabi_ui2f
   \   00000102   0x4605             MOV      R5,R0
   \   00000104   0x4648             MOV      R0,R9
   \   00000106   0x4621             MOV      R1,R4
   \   00000108   0x.... 0x....      BL       __aeabi_fsub
   \   0000010C   0x4604             MOV      R4,R0
   \   0000010E   0x1E70             SUBS     R0,R6,#+1
   \   00000110   0x.... 0x....      BL       __aeabi_i2f
   \   00000114   0x4601             MOV      R1,R0
   \   00000116   0x4620             MOV      R0,R4
   \   00000118   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x.... 0x....      BL       __aeabi_fmul
   \   00000122   0x9900             LDR      R1,[SP, #+0]
   \   00000124   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000128   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_xpos_3: (+1)
   \   0000012C   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??mesh_index_to_xpos_0:
   \   00000130   0x........         DC32     mksCfg
   \   00000134   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE
   \   00000138   0x........         DC32     mksTmp

   \                                 In section .text, align 4
   \   __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
   \                     _ZN20unified_bed_leveling18mesh_index_to_yposEh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x4F49             LDR.N    R7,??mesh_index_to_ypos_0
   \   00000008   0xF897 0x6061      LDRB     R6,[R7, #+97]
   \   0000000C   0xF107 0x000C      ADD      R0,R7,#+12
   \   00000010   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   00000014   0xF240 0x3202      MOVW     R2,#+770
   \   00000018   0x4211             TST      R1,R2
   \   0000001A   0xD02B             BEQ.N    ??mesh_index_to_ypos_1
   \   0000001C   0x42B5             CMP      R5,R6
   \   0000001E   0xD203             BCS.N    ??mesh_index_to_ypos_2
   \   00000020   0x4843             LDR.N    R0,??mesh_index_to_ypos_0+0x4
   \   00000022   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   00000026   0xE07F             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_2: (+1)
   \   00000028   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   0000002C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000030   0x4682             MOV      R10,R0
   \   00000032   0x4C40             LDR.N    R4,??mesh_index_to_ypos_0+0x8
   \   00000034   0x68A0             LDR      R0,[R4, #+8]
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fadd
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x4628             MOV      R0,R5
   \   00000040   0x.... 0x....      BL       __aeabi_ui2f
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x68E0             LDR      R0,[R4, #+12]
   \   00000048   0x4651             MOV      R1,R10
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x4639             MOV      R1,R7
   \   00000050   0x.... 0x....      BL       __aeabi_fsub
   \   00000054   0x4604             MOV      R4,R0
   \   00000056   0x1E70             SUBS     R0,R6,#+1
   \   00000058   0x.... 0x....      BL       __aeabi_i2f
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_fdiv
   \   00000064   0x4629             MOV      R1,R5
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4639             MOV      R1,R7
   \   0000006C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000070   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_1: (+1)
   \   00000074   0x42B5             CMP      R5,R6
   \   00000076   0xD203             BCS.N    ??mesh_index_to_ypos_4
   \   00000078   0x482D             LDR.N    R0,??mesh_index_to_ypos_0+0x4
   \   0000007A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000007E   0xE053             B.N      ??mesh_index_to_ypos_3
   \                     ??mesh_index_to_ypos_4: (+1)
   \   00000080   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   00000084   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000088   0x4641             MOV      R1,R8
   \   0000008A   0x.... 0x....      BL       __aeabi_fmul
   \   0000008E   0x4681             MOV      R9,R0
   \   00000090   0xF897 0x0098      LDRB     R0,[R7, #+152]
   \   00000094   0x.... 0x....      BL       __aeabi_ui2f
   \   00000098   0x4682             MOV      R10,R0
   \   0000009A   0x4648             MOV      R0,R9
   \   0000009C   0x4649             MOV      R1,R9
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4651             MOV      R1,R10
   \   000000A4   0x.... 0x....      BL       __aeabi_fadd
   \   000000A8   0x4604             MOV      R4,R0
   \   000000AA   0xF8D7 0xB070      LDR      R11,[R7, #+112]
   \   000000AE   0x68F8             LDR      R0,[R7, #+12]
   \   000000B0   0x4659             MOV      R1,R11
   \   000000B2   0x.... 0x....      BL       __aeabi_fadd
   \   000000B6   0x4607             MOV      R7,R0
   \   000000B8   0x4621             MOV      R1,R4
   \   000000BA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BE   0xD201             BCS.N    ??mesh_index_to_ypos_5
   \   000000C0   0x9400             STR      R4,[SP, #+0]
   \   000000C2   0xE000             B.N      ??mesh_index_to_ypos_6
   \                     ??mesh_index_to_ypos_5: (+1)
   \   000000C4   0x9700             STR      R7,[SP, #+0]
   \                     ??mesh_index_to_ypos_6: (+1)
   \   000000C6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000CA   0x4649             MOV      R1,R9
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4651             MOV      R1,R10
   \   000000D2   0x.... 0x....      BL       __aeabi_fsub
   \   000000D6   0x4681             MOV      R9,R0
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x4659             MOV      R1,R11
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x4601             MOV      R1,R0
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E8   0xD300             BCC.N    ??mesh_index_to_ypos_7
   \   000000EA   0x4689             MOV      R9,R1
   \                     ??mesh_index_to_ypos_7: (+1)
   \   000000EC   0x4638             MOV      R0,R7
   \   000000EE   0x4621             MOV      R1,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F4   0xD300             BCC.N    ??mesh_index_to_ypos_8
   \   000000F6   0x463C             MOV      R4,R7
   \                     ??mesh_index_to_ypos_8: (+1)
   \   000000F8   0x4628             MOV      R0,R5
   \   000000FA   0x.... 0x....      BL       __aeabi_ui2f
   \   000000FE   0x4605             MOV      R5,R0
   \   00000100   0x4648             MOV      R0,R9
   \   00000102   0x4621             MOV      R1,R4
   \   00000104   0x.... 0x....      BL       __aeabi_fsub
   \   00000108   0x4604             MOV      R4,R0
   \   0000010A   0x1E70             SUBS     R0,R6,#+1
   \   0000010C   0x.... 0x....      BL       __aeabi_i2f
   \   00000110   0x4601             MOV      R1,R0
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0x.... 0x....      BL       __aeabi_fdiv
   \   00000118   0x4629             MOV      R1,R5
   \   0000011A   0x.... 0x....      BL       __aeabi_fmul
   \   0000011E   0x9900             LDR      R1,[SP, #+0]
   \   00000120   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000124   0x.... 0x....      B.W      __aeabi_fadd
   \                     ??mesh_index_to_ypos_3: (+1)
   \   00000128   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \                     ??mesh_index_to_ypos_0:
   \   0000012C   0x........         DC32     mksCfg
   \   00000130   0x........         DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
   \   00000134   0x........         DC32     mksTmp

   \                                 In section .text, align 4
   \   __interwork __softfp bool unified_bed_leveling::mesh_is_valid()
   \                     _ZN20unified_bed_leveling13mesh_is_validEv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4A1D             LDR.N    R2,??mesh_is_valid_0
   \   00000004   0x6853             LDR      R3,[R2, #+4]
   \   00000006   0x6814             LDR      R4,[R2, #+0]
   \   00000008   0x4620             MOV      R0,R4
   \   0000000A   0x4619             MOV      R1,R3
   \   0000000C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000010   0xD129             BNE.N    ??mesh_is_valid_1
   \   00000012   0x4618             MOV      R0,R3
   \   00000014   0x6891             LDR      R1,[R2, #+8]
   \   00000016   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000001A   0xD124             BNE.N    ??mesh_is_valid_1
   \   0000001C   0x6B53             LDR      R3,[R2, #+52]
   \   0000001E   0x6B15             LDR      R5,[R2, #+48]
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x4619             MOV      R1,R3
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000028   0xD11D             BNE.N    ??mesh_is_valid_1
   \   0000002A   0x4618             MOV      R0,R3
   \   0000002C   0x6B91             LDR      R1,[R2, #+56]
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000032   0xD118             BNE.N    ??mesh_is_valid_1
   \   00000034   0x6E53             LDR      R3,[R2, #+100]
   \   00000036   0x6E16             LDR      R6,[R2, #+96]
   \   00000038   0x4630             MOV      R0,R6
   \   0000003A   0x4619             MOV      R1,R3
   \   0000003C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000040   0xD111             BNE.N    ??mesh_is_valid_1
   \   00000042   0x4618             MOV      R0,R3
   \   00000044   0x6E91             LDR      R1,[R2, #+104]
   \   00000046   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000004A   0xD10C             BNE.N    ??mesh_is_valid_1
   \   0000004C   0x4620             MOV      R0,R4
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000054   0xD107             BNE.N    ??mesh_is_valid_1
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000005C   0xD103             BNE.N    ??mesh_is_valid_1
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000064   0xD006             BEQ.N    ??mesh_is_valid_2
   \                     ??mesh_is_valid_1: (+1)
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       __iar_FDtest
   \   0000006C   0x2802             CMP      R0,#+2
   \   0000006E   0xD001             BEQ.N    ??mesh_is_valid_2
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xBD70             POP      {R4-R6,PC}
   \                     ??mesh_is_valid_2: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??mesh_is_valid_0:
   \   00000078   0x........         DC32     _ZN20unified_bed_leveling8z_valuesE

   \                                 In section .text, align 2
   \   __interwork __softfp void gcode_G29_UBL()
   \                     _Z13gcode_G29_UBLv: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN20unified_bed_leveling13gcode_G29_UBLEv
    268          
    269          #include "mks_cfg.h"
    270          #include "mks_reprint.h"
    271          
    272          #if 1
    273          
    274          #include "wifi_module.h"
    275          
    276          #include "gui.h"
    277          
    278          #include "draw_ready_print.h"
    279          
    280          #include "draw_ui.h"

    #define FILAMENT_CHANGE_TEXT_EN				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_en.h",135  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_EN"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_CN            "瑙ｉょ瀹?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_s_cn.h",218  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_CN"
          (declared at line 213)

    #define FILAMENT_CHANGE_TEXT_T_CN				"寰版,\n璜<叉><>"
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_t_cn.h",127  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_T_CN"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_RU				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_ru.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_RU"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_RU            "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_ru.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_RU"
          (declared at line 225)

    #define FILAMENT_CHANGE_TEXT_FR				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_fr.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_FR"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_FR        "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_fr.h",233  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_FR"
          (declared at line 229)

    #define FILAMENT_CHANGE_TEXT_SP				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_sp.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_SP"
          (declared at line 113)

    #define FILAMENT_CHANGE_TEXT_IT				"Please click <Load> \nor <unload>,After \npinter pause."
            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_it.h",133  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_IT"
          (declared at line 113)

  #define DIALOG_UNBIND_PRINTER_IT                "Unbind the printer?"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Language_it.h",229  Warning[Pe047]: 
          incompatible redefinition of macro "DIALOG_UNBIND_PRINTER_IT"
          (declared at line 224)

  #define FILAMENT_CHANGE_TEXT_JP				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Multi_language.h",651  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_JP"
          (declared at line 644)

  #define FILAMENT_CHANGE_TEXT_GN				"Please click <Load> \nor <unload>,After \npinter pause."
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\Multi_language\Multi_language.h",859  Warning[Pe047]: 
          incompatible redefinition of macro "FILAMENT_CHANGE_TEXT_GN"
          (declared at line 853)

  #define Simple_Dec"减少"
                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",495  Warning[Pe1649]: 
          white space is required between the macro name "Simple_Dec" and its
          replacement text

  #define Simple_Speed "速度"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",550  Warning[Pe047]: 
          incompatible redefinition of macro "Simple_Speed" (declared at line
          547)

  #define Complex_Speed "速度"
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\User\ui\draw_ui.h",551  Warning[Pe047]: 
          incompatible redefinition of macro "Complex_Speed" (declared at line
          548)
    281          #include "wifi_module.h"
    282          #include "draw_printing.h"
    283          #include "draw_pause_ui.h"
    284          #include "sdio_sdcard.h"

  #define IS_NVIC_PRIORITY_GROUP(GROUP) (((GROUP) == NVIC_PriorityGroup_0) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",152  Warning[Pe047]: 
          incompatible redefinition of macro "IS_NVIC_PRIORITY_GROUP"
          (declared at line 277 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define IS_SYSTICK_CLK_SOURCE(SOURCE) (((SOURCE) == SysTick_CLKSource_HCLK) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\misc.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SYSTICK_CLK_SOURCE" (declared
          at line 296 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_cortex.h")

  #define SDIO_INIT_CLK_DIV        0x166//0xB2 		//SDIO初始化频率，最大400Kh  
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",36  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_INIT_CLK_DIV" (declared at
          line 479 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SDIO_TRANSFER_CLK_DIV    0x07//0x02//0x01		//SDIO传输频率，最大24Mhz(4bit)。该值太小可能会导致读写文件出错 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",37  Warning[Pe047]: 
          incompatible redefinition of macro "SDIO_TRANSFER_CLK_DIV" (declared
          at line 482 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_ll_sdmmc.h")

  #define SD_CMD_GO_IDLE_STATE                       ((u8)0)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IDLE_STATE" (declared
          at line 304 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_OP_COND                        ((u8)1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",171  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_OP_COND" (declared
          at line 305 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ALL_SEND_CID                        ((u8)2)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",172  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ALL_SEND_CID" (declared
          at line 306 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_REL_ADDR                        ((u8)3) /*!< SDIO_SEND_REL_ADDR for SD Card */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",173  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_REL_ADDR" (declared
          at line 307 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_DSR                             ((u8)4)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",174  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_DSR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_SEN_OP_COND                    ((u8)5)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",175  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_SEN_OP_COND"
          (declared at line 309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SWITCH                           ((u8)6)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",176  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SWITCH" (declared at
          line 311 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEL_DESEL_CARD                      ((u8)7)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",177  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEL_DESEL_CARD" (declared
          at line 312 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_SEND_EXT_CSD                     ((u8)8)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",178  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_SEND_EXT_CSD"
          (declared at line 313 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CSD                            ((u8)9)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",179  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CSD" (declared at
          line 315 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_CID                            ((u8)10)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",180  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_CID" (declared at
          line 316 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_DAT_UNTIL_STOP                 ((u8)11) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",181  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_DAT_UNTIL_STOP"
          (declared at line 317 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_STOP_TRANSMISSION                   ((u8)12)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_STOP_TRANSMISSION"
          (declared at line 318 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_STATUS                         ((u8)13)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",183  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_STATUS" (declared at
          line 319 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_READ                     ((u8)14)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",184  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_READ"
          (declared at line 320 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_INACTIVE_STATE                   ((u8)15)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",185  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_INACTIVE_STATE"
          (declared at line 321 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCKLEN                        ((u8)16)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",186  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCKLEN" (declared
          at line 322 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_SINGLE_BLOCK                   ((u8)17)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",187  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_SINGLE_BLOCK"
          (declared at line 325 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_READ_MULT_BLOCK                     ((u8)18)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",188  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_READ_MULT_BLOCK"
          (declared at line 327 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_HS_BUSTEST_WRITE                    ((u8)19)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",189  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_HS_BUSTEST_WRITE"
          (declared at line 329 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_DAT_UNTIL_STOP                ((u8)20) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",190  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_DAT_UNTIL_STOP"
          (declared at line 330 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_BLOCK_COUNT                     ((u8)23) 
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",191  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_BLOCK_COUNT"
          (declared at line 331 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_SINGLE_BLOCK                  ((u8)24)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",192  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_SINGLE_BLOCK"
          (declared at line 332 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_WRITE_MULT_BLOCK                    ((u8)25)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",193  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_WRITE_MULT_BLOCK"
          (declared at line 334 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CID                            ((u8)26)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CID" (declared at
          line 335 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_PROG_CSD                            ((u8)27)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",195  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_PROG_CSD" (declared at
          line 336 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SET_WRITE_PROT                      ((u8)28)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",196  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SET_WRITE_PROT" (declared
          at line 337 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_CLR_WRITE_PROT                      ((u8)29)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",197  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_CLR_WRITE_PROT" (declared
          at line 338 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SEND_WRITE_PROT                     ((u8)30)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",198  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SEND_WRITE_PROT"
          (declared at line 339 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_START                  ((u8)32) /*!< To set the address of the first write
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",199  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_START"
          (declared at line 340 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_ERASE_GRP_END                    ((u8)33) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",201  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_ERASE_GRP_END"
          (declared at line 341 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_START                     ((u8)35) /*!< To set the address of the first write block to be erased.
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",203  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_START"
          (declared at line 342 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE_GRP_END                       ((u8)36) /*!< To set the address of the last write block of the
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",206  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE_GRP_END" (declared
          at line 344 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_ERASE                               ((u8)38)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",209  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_ERASE" (declared at line
          346 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_FAST_IO                             ((u8)39) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",210  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_FAST_IO" (declared at
          line 347 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GO_IRQ_STATE                        ((u8)40) /*!< SD Card doesn't support it */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",211  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GO_IRQ_STATE" (declared
          at line 348 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_LOCK_UNLOCK                         ((u8)42)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_LOCK_UNLOCK" (declared at
          line 349 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_CMD                             ((u8)55)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",213  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_CMD" (declared at
          line 351 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_GEN_CMD                             ((u8)56)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",214  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_GEN_CMD" (declared at
          line 353 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_NO_CMD                              ((u8)64)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",215  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_NO_CMD" (declared at line
          355 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_APP_SD_SET_BUSWIDTH                 ((u8)6)  /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",221  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_APP_SD_SET_BUSWIDTH"
          (declared at line 361 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_STAUS                        ((u8)13) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",222  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_STAUS" (declared
          at line 2841 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS        ((u8)22) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",223  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SEND_NUM_WRITE_BLOCKS" (declared at line 364 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_OP_COND                      ((u8)41) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",224  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_OP_COND" (declared
          at line 366 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CLR_CARD_DETECT          ((u8)42) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",225  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SET_CLR_CARD_DETECT" (declared at line 368 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SEND_SCR                     ((u8)51) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",226  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SEND_SCR"
          (declared at line 369 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_DIRECT                      ((u8)52) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",227  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_DIRECT" (declared
          at line 370 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SDIO_RW_EXTENDED                    ((u8)53) /*!< For SD I/O Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",228  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SDIO_RW_EXTENDED"
          (declared at line 371 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MKB                      ((u8)43) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",234  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MKB" (declared
          at line 377 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_MID                      ((u8)44) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",235  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_MID" (declared
          at line 378 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RN1                  ((u8)45) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",236  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RN1"
          (declared at line 379 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RN2                  ((u8)46) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",237  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RN2"
          (declared at line 380 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SET_CER_RES2                 ((u8)47) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",238  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SET_CER_RES2"
          (declared at line 381 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_GET_CER_RES1                 ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",239  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_GET_CER_RES1"
          (declared at line 382 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK   ((u8)18) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",240  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_READ_MULTIPLE_BLOCK" (declared at line 383 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK  ((u8)25) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",241  Warning[Pe047]: 
          incompatible redefinition of macro
          "SD_CMD_SD_APP_SECURE_WRITE_MULTIPLE_BLOCK" (declared at line 384 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_ERASE                 ((u8)38) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",242  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_ERASE"
          (declared at line 385 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_CHANGE_SECURE_AREA           ((u8)49) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",243  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_CHANGE_SECURE_AREA"
          (declared at line 386 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define SD_CMD_SD_APP_SECURE_WRITE_MKB             ((u8)48) /*!< For SD Card only */
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",244  Warning[Pe047]: 
          incompatible redefinition of macro "SD_CMD_SD_APP_SECURE_WRITE_MKB"
          (declared at line 387 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_sd.h")

  #define NULL 0
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",257  Warning[Pe047]: 
          incompatible redefinition of macro "NULL" (declared at line 22 of
          "C:\Program Files (x86)\IAR Systems\Embedded Workbench
          7.0\arm\inc\c\stdio.h")

  #define SD_OCR_CID_CSD_OVERWRIETE       ((u32)0x00010000)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",278  Warning[Pe047]: 
          incompatible redefinition of macro "SD_OCR_CID_CSD_OVERWRIETE"
          (declared at line 2840 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\Legacy/stm32_hal_legacy.h")

  #define SD_DATATIMEOUT                  ((u32)0x000FFFFF)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\sdio_sdcard.h",310  Warning[Pe047]: 
          incompatible redefinition of macro "SD_DATATIMEOUT" (declared at
          line 78 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Inc\bsp_driver_sd.h")
    285          #include "draw_keyboard.h"
    286          #include "draw_Tips.h"
    287          #include "ili9320.h"
    288          

   \                                 In section .bss, align 1
    289          volatile uint8_t temper_error_flg = 0;
   \                     temper_error_flg:
   \   00000000                      DS8 1
    290          volatile uint8_t temper_error_type = 0;
   \                     temper_error_type:
   \   00000001                      DS8 1
    291          
    292          volatile uint8_t mks_heating_busy = 0;
    293          
    294          extern void PowerOff_Filament_Check();
    295          extern void display_temper_error();
    296          extern void Close_machine_display();
    297          
    298          extern uint8_t IsChooseAutoShutdown;
    299          
    300          extern uint8_t temperature_change_frequency;
    301          
    302          static uint32_t temperature_change_frequency_cnt = 0;
    303          static uint32_t After_finish_print_time = 0;
    304          
    305          uint8_t filament_loading_time_flg;
    306          uint32_t filament_loading_time_cnt;
    307          uint8_t filament_loading_completed;
    308          uint8_t filament_unloading_time_flg;
    309          uint32_t filament_unloading_time_cnt;
    310          uint8_t filament_unloading_completed;
    311          
    312          uint8_t filament_heat_completed_load;
    313          uint8_t filament_heat_completed_unload;
    314          
    315          extern uint32_t filament_rate;
    316          
    317          
    318          volatile uint32_t TimeIncrease;
    319          uint8_t volatile printing_rate_update_flag;
    320          uint8_t preview_no_display;
    321          extern PRINT_TIME  print_time;
    322          
    323          extern uint8_t from_flash_pic;
    324          volatile uint8_t loop_start=0;
    325          #endif
    326          
    327          
    328          #if 0
    329          #if HAS_ABL
    330            #include "vector_3.h"
    331            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
    332              #include "least_squares_fit.h"
    333            #endif
    334          #elif ENABLED(MESH_BED_LEVELING)
    335            #include "mesh_bed_leveling.h"
    336          #endif
    337          #endif
    338          #include "vector_3.h"
    339          //#include "qr_solve.h"
    340          #include "mesh_bed_leveling.h"

  	#define MESH_X_DIST_IS_KINEMATIC ((MESH_MAX_X_IS_KINEMATIC - (MESH_MIN_X_IS_KINEMATIC)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",41  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_KINEMATIC"
          (declared at line 74 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_KINEMATIC ((MESH_MAX_Y_IS_KINEMATIC - (MESH_MIN_Y_IS_KINEMATIC)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",42  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_KINEMATIC"
          (declared at line 75 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_X_DIST_IS_Cartesian ((MESH_MAX_X_IS_Cartesian - (MESH_MIN_X_IS_Cartesian)) / (GRID_MAX_POINTS_X - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",43  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_X_DIST_IS_Cartesian"
          (declared at line 76 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

  	#define MESH_Y_DIST_IS_Cartesian ((MESH_MAX_Y_IS_Cartesian - (MESH_MIN_Y_IS_Cartesian)) / (GRID_MAX_POINTS_Y - 1))
  	        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",44  Warning[Pe047]: 
          incompatible redefinition of macro "MESH_Y_DIST_IS_Cartesian"
          (declared at line 77 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Middlewares\Third_Party\Marlin\ubl.h")

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
   \                     _ZN17mesh_bed_leveling5set_zEaaRKf: (+1)
   \   00000000   0xEB00 0x0340      ADD      R3,R0,R0, LSL #+1
   \   00000004   0x4803             LDR.N    R0,??set_z_0
   \   00000006   0xEB00 0x1003      ADD      R0,R0,R3, LSL #+4
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0xF840 0x2021      STR      R2,[R0, R1, LSL #+2]
   \   00000010   0x4770             BX       LR               ;; return
   \   00000012   0xBF00             Nop      
   \                     ??set_z_0:
   \   00000014   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE

   \                                 In section .text, align 4
   \   __interwork __softfp void mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
   \                     _ZN17mesh_bed_leveling6zigzagEaRaS0_: (+1)
   \   00000000   0xB430             PUSH     {R4,R5}
   \   00000002   0x4B0C             LDR.N    R3,??zigzag_0
   \   00000004   0xF893 0x4060      LDRB     R4,[R3, #+96]
   \   00000008   0xFB90 0xF5F4      SDIV     R5,R0,R4
   \   0000000C   0xFB04 0x0415      MLS      R4,R4,R5,R0
   \   00000010   0x700C             STRB     R4,[R1, #+0]
   \   00000012   0xF893 0x4060      LDRB     R4,[R3, #+96]
   \   00000016   0xFB90 0xF0F4      SDIV     R0,R0,R4
   \   0000001A   0x7010             STRB     R0,[R2, #+0]
   \   0000001C   0x7810             LDRB     R0,[R2, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD505             BPL.N    ??zigzag_1
   \   00000022   0xF993 0x0060      LDRSB    R0,[R3, #+96]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x780A             LDRB     R2,[R1, #+0]
   \   0000002A   0x1A80             SUBS     R0,R0,R2
   \   0000002C   0x7008             STRB     R0,[R1, #+0]
   \                     ??zigzag_1: (+1)
   \   0000002E   0xBC30             POP      {R4,R5}
   \   00000030   0x4770             BX       LR               ;; return
   \   00000032   0xBF00             Nop      
   \                     ??zigzag_0:
   \   00000034   0x........         DC32     mksCfg

   \                                 In section .text, align 2
   \   __interwork __softfp void mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
   \                     _ZN17mesh_bed_leveling12set_zigzag_zEaRKf: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460C             MOV      R4,R1
   \   00000006   0xAA00             ADD      R2,SP,#+0
   \   00000008   0xF10D 0x0101      ADD      R1,SP,#+1
   \   0000000C   0x.... 0x....      BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
   \   00000010   0x4622             MOV      R2,R4
   \   00000012   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   00000016   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \   0000001A   0x.... 0x....      BL       _ZN17mesh_bed_leveling5set_zEaaRKf
   \   0000001E   0xBD13             POP      {R0,R1,R4,PC}    ;; return

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_xERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E55             LDR.N    R6,??cell_index_x_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??cell_index_x_1

  				cx= (x - (MESH_MIN_X_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",83  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x813C      LDR.W    R8,??cell_index_x_0+0x4
   \   00000026   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x0004      LDR      R0,[R8, #+4]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493C             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05C             B.N      ??cell_index_x_2

  				cx= (x - (MESH_MIN_X_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",87  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_x_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF106 0x0060      ADD      R0,R6,#+96
   \   000000A6   0xF8D0 0xA00C      LDR      R10,[R0, #+12]
   \   000000AA   0x68B0             LDR      R0,[R6, #+8]
   \   000000AC   0x4651             MOV      R1,R10
   \   000000AE   0x.... 0x....      BL       __aeabi_fadd
   \   000000B2   0x4605             MOV      R5,R0
   \   000000B4   0x4641             MOV      R1,R8
   \   000000B6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000BA   0xD202             BCS.N    ??cell_index_x_3
   \   000000BC   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000C0   0xE000             B.N      ??cell_index_x_4
   \                     ??cell_index_x_3: (+1)
   \   000000C2   0x9500             STR      R5,[SP, #+0]
   \                     ??cell_index_x_4: (+1)
   \   000000C4   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C8   0x4659             MOV      R1,R11
   \   000000CA   0x.... 0x....      BL       __aeabi_fmul
   \   000000CE   0x4639             MOV      R1,R7
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0x4607             MOV      R7,R0
   \   000000D6   0x4648             MOV      R0,R9
   \   000000D8   0x4651             MOV      R1,R10
   \   000000DA   0x.... 0x....      BL       __aeabi_fadd
   \   000000DE   0x4601             MOV      R1,R0
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E6   0xD300             BCC.N    ??cell_index_x_5
   \   000000E8   0x460F             MOV      R7,R1
   \                     ??cell_index_x_5: (+1)
   \   000000EA   0x4628             MOV      R0,R5
   \   000000EC   0x4641             MOV      R1,R8
   \   000000EE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F2   0xD300             BCC.N    ??cell_index_x_6
   \   000000F4   0x46A8             MOV      R8,R5
   \                     ??cell_index_x_6: (+1)
   \   000000F6   0x6820             LDR      R0,[R4, #+0]
   \   000000F8   0x9900             LDR      R1,[SP, #+0]
   \   000000FA   0x.... 0x....      BL       __aeabi_fsub
   \   000000FE   0x.... 0x....      BL       __aeabi_f2d
   \   00000102   0x4604             MOV      R4,R0
   \   00000104   0x460D             MOV      R5,R1
   \   00000106   0x4638             MOV      R0,R7
   \   00000108   0x4641             MOV      R1,R8
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x4607             MOV      R7,R0
   \   00000110   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000114   0x1E40             SUBS     R0,R0,#+1
   \   00000116   0x.... 0x....      BL       __aeabi_i2f
   \   0000011A   0x4601             MOV      R1,R0
   \   0000011C   0x4638             MOV      R0,R7
   \   0000011E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000122   0x.... 0x....      BL       __aeabi_f2d
   \   00000126   0x4602             MOV      R2,R0
   \   00000128   0x460B             MOV      R3,R1
   \   0000012A   0x2000             MOVS     R0,#+0
   \   0000012C   0x490D             LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
   \   0000012E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000132   0x4622             MOV      R2,R4
   \   00000134   0x462B             MOV      R3,R5
   \   00000136   0x.... 0x....      BL       __aeabi_dmul
   \   0000013A   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??cell_index_x_2: (+1)
   \   0000013E   0xB240             SXTB     R0,R0
   \   00000140   0x0001             MOVS     R1,R0
   \   00000142   0xD501             BPL.N    ??cell_index_x_7
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0xE005             B.N      ??cell_index_x_8
   \                     ??cell_index_x_7: (+1)
   \   00000148   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   0000014C   0x1E93             SUBS     R3,R2,#+2
   \   0000014E   0x428B             CMP      R3,R1
   \   00000150   0xDA00             BGE.N    ??cell_index_x_8
   \   00000152   0x1E90             SUBS     R0,R2,#+2
   \                     ??cell_index_x_8: (+1)
   \   00000154   0xB240             SXTB     R0,R0
   \   00000156   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   0000015A   0xBF00             Nop      
   \                     ??cell_index_x_0:
   \   0000015C   0x........         DC32     mksCfg
   \   00000160   0x........         DC32     mksTmp
   \   00000164   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
   \                     _ZN17mesh_bed_leveling12cell_index_yERKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x4E54             LDR.N    R6,??cell_index_y_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4607             MOV      R7,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF8B0 0x104C      LDRH     R1,[R0, #+76]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD030             BEQ.N    ??cell_index_y_1

  				cy= (y - (MESH_MIN_Y_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",95  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF8DF 0x8138      LDR.W    R8,??cell_index_y_0+0x4
   \   00000026   0xF8D8 0x0008      LDR      R0,[R8, #+8]
   \   0000002A   0x4639             MOV      R1,R7
   \   0000002C   0x.... 0x....      BL       __aeabi_fadd
   \   00000030   0x4681             MOV      R9,R0
   \   00000032   0x6820             LDR      R0,[R4, #+0]
   \   00000034   0x4649             MOV      R1,R9
   \   00000036   0x.... 0x....      BL       __aeabi_fsub
   \   0000003A   0x.... 0x....      BL       __aeabi_f2d
   \   0000003E   0x4604             MOV      R4,R0
   \   00000040   0x460D             MOV      R5,R1
   \   00000042   0xF8D8 0x000C      LDR      R0,[R8, #+12]
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_fsub
   \   0000004C   0x4649             MOV      R1,R9
   \   0000004E   0x.... 0x....      BL       __aeabi_fsub
   \   00000052   0x4607             MOV      R7,R0
   \   00000054   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000058   0x1E40             SUBS     R0,R0,#+1
   \   0000005A   0x.... 0x....      BL       __aeabi_i2f
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x4638             MOV      R0,R7
   \   00000062   0x.... 0x....      BL       __aeabi_fdiv
   \   00000066   0x.... 0x....      BL       __aeabi_f2d
   \   0000006A   0x4602             MOV      R2,R0
   \   0000006C   0x460B             MOV      R3,R1
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x493B             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   00000072   0x.... 0x....      BL       __aeabi_ddiv
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x.... 0x....      BL       __aeabi_d2iz
   \   00000082   0xE05A             B.N      ??cell_index_y_2

  				cy= (y - (MESH_MIN_Y_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",97  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??cell_index_y_1: (+1)
   \   00000084   0xF8D0 0x900C      LDR      R9,[R0, #+12]
   \   00000088   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000008C   0x4649             MOV      R1,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_fmul
   \   00000092   0x4683             MOV      R11,R0
   \   00000094   0x4659             MOV      R1,R11
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4680             MOV      R8,R0
   \   000000A2   0xF8D6 0xA070      LDR      R10,[R6, #+112]
   \   000000A6   0x68F0             LDR      R0,[R6, #+12]
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fadd
   \   000000AE   0x4605             MOV      R5,R0
   \   000000B0   0x4641             MOV      R1,R8
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B6   0xD202             BCS.N    ??cell_index_y_3
   \   000000B8   0xF8CD 0x8000      STR      R8,[SP, #+0]
   \   000000BC   0xE000             B.N      ??cell_index_y_4
   \                     ??cell_index_y_3: (+1)
   \   000000BE   0x9500             STR      R5,[SP, #+0]
   \                     ??cell_index_y_4: (+1)
   \   000000C0   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000C4   0x4659             MOV      R1,R11
   \   000000C6   0x.... 0x....      BL       __aeabi_fmul
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      BL       __aeabi_fsub
   \   000000D0   0x4607             MOV      R7,R0
   \   000000D2   0x4648             MOV      R0,R9
   \   000000D4   0x4651             MOV      R1,R10
   \   000000D6   0x.... 0x....      BL       __aeabi_fadd
   \   000000DA   0x4601             MOV      R1,R0
   \   000000DC   0x4638             MOV      R0,R7
   \   000000DE   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E2   0xD300             BCC.N    ??cell_index_y_5
   \   000000E4   0x460F             MOV      R7,R1
   \                     ??cell_index_y_5: (+1)
   \   000000E6   0x4628             MOV      R0,R5
   \   000000E8   0x4641             MOV      R1,R8
   \   000000EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000EE   0xD300             BCC.N    ??cell_index_y_6
   \   000000F0   0x46A8             MOV      R8,R5
   \                     ??cell_index_y_6: (+1)
   \   000000F2   0x6820             LDR      R0,[R4, #+0]
   \   000000F4   0x9900             LDR      R1,[SP, #+0]
   \   000000F6   0x.... 0x....      BL       __aeabi_fsub
   \   000000FA   0x.... 0x....      BL       __aeabi_f2d
   \   000000FE   0x4604             MOV      R4,R0
   \   00000100   0x460D             MOV      R5,R1
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x4641             MOV      R1,R8
   \   00000106   0x.... 0x....      BL       __aeabi_fsub
   \   0000010A   0x4607             MOV      R7,R0
   \   0000010C   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000110   0x1E40             SUBS     R0,R0,#+1
   \   00000112   0x.... 0x....      BL       __aeabi_i2f
   \   00000116   0x4601             MOV      R1,R0
   \   00000118   0x4638             MOV      R0,R7
   \   0000011A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000011E   0x.... 0x....      BL       __aeabi_f2d
   \   00000122   0x4602             MOV      R2,R0
   \   00000124   0x460B             MOV      R3,R1
   \   00000126   0x2000             MOVS     R0,#+0
   \   00000128   0x490D             LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
   \   0000012A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000012E   0x4622             MOV      R2,R4
   \   00000130   0x462B             MOV      R3,R5
   \   00000132   0x.... 0x....      BL       __aeabi_dmul
   \   00000136   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??cell_index_y_2: (+1)
   \   0000013A   0xB240             SXTB     R0,R0
   \   0000013C   0x0001             MOVS     R1,R0
   \   0000013E   0xD501             BPL.N    ??cell_index_y_7
   \   00000140   0x2000             MOVS     R0,#+0
   \   00000142   0xE005             B.N      ??cell_index_y_8
   \                     ??cell_index_y_7: (+1)
   \   00000144   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   00000148   0x1E93             SUBS     R3,R2,#+2
   \   0000014A   0x428B             CMP      R3,R1
   \   0000014C   0xDA00             BGE.N    ??cell_index_y_8
   \   0000014E   0x1E90             SUBS     R0,R2,#+2
   \                     ??cell_index_y_8: (+1)
   \   00000150   0xB240             SXTB     R0,R0
   \   00000152   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
   \   00000156   0xBF00             Nop      
   \                     ??cell_index_y_0:
   \   00000158   0x........         DC32     mksCfg
   \   0000015C   0x........         DC32     mksTmp
   \   00000160   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
   \                     _ZN17mesh_bed_leveling13probe_index_xERKf: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4E6A             LDR.N    R6,??probe_index_x_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000016   0xF8B0 0x1050      LDRH     R1,[R0, #+80]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD03A             BEQ.N    ??probe_index_x_1

  				px = (x - (MESH_MIN_X_IS_KINEMATIC) + 0.5 * (MESH_X_DIST_IS_KINEMATIC)) * (1.0 / (MESH_X_DIST_IS_KINEMATIC));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",105  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      BL       __aeabi_i2f
   \   0000002C   0x4605             MOV      R5,R0
   \   0000002E   0x4C61             LDR.N    R4,??probe_index_x_0+0x4
   \   00000030   0x6820             LDR      R0,[R4, #+0]
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0x6860             LDR      R0,[R4, #+4]
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x.... 0x....      BL       __aeabi_fsub
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4604             MOV      R4,R0
   \   00000054   0x460D             MOV      R5,R1
   \   00000056   0x6838             LDR      R0,[R7, #+0]
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x4680             MOV      R8,R0
   \   00000064   0x4689             MOV      R9,R1
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4953             LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3fe00000
   \   0000006A   0x4622             MOV      R2,R4
   \   0000006C   0x462B             MOV      R3,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x4642             MOV      R2,R8
   \   00000074   0x464B             MOV      R3,R9
   \   00000076   0x.... 0x....      BL       __aeabi_dadd
   \   0000007A   0x4680             MOV      R8,R0
   \   0000007C   0x4689             MOV      R9,R1
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x494E             LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
   \   00000082   0x4622             MOV      R2,R4
   \   00000084   0x462B             MOV      R3,R5
   \   00000086   0x.... 0x....      BL       __aeabi_ddiv
   \   0000008A   0x4642             MOV      R2,R8
   \   0000008C   0x464B             MOV      R3,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
   \   00000092   0x.... 0x....      BL       __aeabi_d2iz
   \   00000096   0xE07E             B.N      ??probe_index_x_2

  				px = (x - (MESH_MIN_X_IS_Cartesian) + 0.5 * (MESH_X_DIST_IS_Cartesian)) * (1.0 / (MESH_X_DIST_IS_Cartesian));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",107  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??probe_index_x_1: (+1)
   \   00000098   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   0000009C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   000000A0   0x4641             MOV      R1,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x4682             MOV      R10,R0
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x4649             MOV      R1,R9
   \   000000B0   0x.... 0x....      BL       __aeabi_fadd
   \   000000B4   0x4604             MOV      R4,R0
   \   000000B6   0xF106 0x0060      ADD      R0,R6,#+96
   \   000000BA   0xF8D0 0xB00C      LDR      R11,[R0, #+12]
   \   000000BE   0x68B0             LDR      R0,[R6, #+8]
   \   000000C0   0x4659             MOV      R1,R11
   \   000000C2   0x.... 0x....      BL       __aeabi_fadd
   \   000000C6   0x4605             MOV      R5,R0
   \   000000C8   0x4621             MOV      R1,R4
   \   000000CA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CE   0xD201             BCS.N    ??probe_index_x_3
   \   000000D0   0x9402             STR      R4,[SP, #+8]
   \   000000D2   0xE000             B.N      ??probe_index_x_4
   \                     ??probe_index_x_3: (+1)
   \   000000D4   0x9502             STR      R5,[SP, #+8]
   \                     ??probe_index_x_4: (+1)
   \   000000D6   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000DA   0x4651             MOV      R1,R10
   \   000000DC   0x.... 0x....      BL       __aeabi_fmul
   \   000000E0   0x4649             MOV      R1,R9
   \   000000E2   0x.... 0x....      BL       __aeabi_fsub
   \   000000E6   0x4682             MOV      R10,R0
   \   000000E8   0x4640             MOV      R0,R8
   \   000000EA   0x4659             MOV      R1,R11
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x4602             MOV      R2,R0
   \   000000F2   0x4650             MOV      R0,R10
   \   000000F4   0x4611             MOV      R1,R2
   \   000000F6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000FA   0xD201             BCS.N    ??probe_index_x_5
   \   000000FC   0x46D0             MOV      R8,R10
   \   000000FE   0xE000             B.N      ??probe_index_x_6
   \                     ??probe_index_x_5: (+1)
   \   00000100   0x4690             MOV      R8,R2
   \                     ??probe_index_x_6: (+1)
   \   00000102   0x4628             MOV      R0,R5
   \   00000104   0x4621             MOV      R1,R4
   \   00000106   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010A   0xD201             BCS.N    ??probe_index_x_7
   \   0000010C   0x46A1             MOV      R9,R4
   \   0000010E   0xE000             B.N      ??probe_index_x_8
   \                     ??probe_index_x_7: (+1)
   \   00000110   0x46A9             MOV      R9,R5
   \                     ??probe_index_x_8: (+1)
   \   00000112   0x4650             MOV      R0,R10
   \   00000114   0x4611             MOV      R1,R2
   \   00000116   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011A   0xD300             BCC.N    ??probe_index_x_9
   \   0000011C   0x4692             MOV      R10,R2
   \                     ??probe_index_x_9: (+1)
   \   0000011E   0x4628             MOV      R0,R5
   \   00000120   0x4621             MOV      R1,R4
   \   00000122   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000126   0xD300             BCC.N    ??probe_index_x_10
   \   00000128   0x462C             MOV      R4,R5
   \                     ??probe_index_x_10: (+1)
   \   0000012A   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   0000012E   0x1E40             SUBS     R0,R0,#+1
   \   00000130   0x.... 0x....      BL       __aeabi_i2f
   \   00000134   0x4605             MOV      R5,R0
   \   00000136   0x6838             LDR      R0,[R7, #+0]
   \   00000138   0x9902             LDR      R1,[SP, #+8]
   \   0000013A   0x.... 0x....      BL       __aeabi_fsub
   \   0000013E   0x.... 0x....      BL       __aeabi_f2d
   \   00000142   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000146   0x4640             MOV      R0,R8
   \   00000148   0x4649             MOV      R1,R9
   \   0000014A   0x.... 0x....      BL       __aeabi_fsub
   \   0000014E   0x4629             MOV      R1,R5
   \   00000150   0x.... 0x....      BL       __aeabi_fdiv
   \   00000154   0x.... 0x....      BL       __aeabi_f2d
   \   00000158   0x2200             MOVS     R2,#+0
   \   0000015A   0x4B17             LDR.N    R3,??probe_index_x_0+0x8  ;; 0x3fe00000
   \   0000015C   0x.... 0x....      BL       __aeabi_dmul
   \   00000160   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000164   0x.... 0x....      BL       __aeabi_dadd
   \   00000168   0x4680             MOV      R8,R0
   \   0000016A   0x4689             MOV      R9,R1
   \   0000016C   0x4650             MOV      R0,R10
   \   0000016E   0x4621             MOV      R1,R4
   \   00000170   0x.... 0x....      BL       __aeabi_fsub
   \   00000174   0x4629             MOV      R1,R5
   \   00000176   0x.... 0x....      BL       __aeabi_fdiv
   \   0000017A   0x.... 0x....      BL       __aeabi_f2d
   \   0000017E   0x4602             MOV      R2,R0
   \   00000180   0x460B             MOV      R3,R1
   \   00000182   0x2000             MOVS     R0,#+0
   \   00000184   0x490D             LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
   \   00000186   0x.... 0x....      BL       __aeabi_ddiv
   \   0000018A   0x4642             MOV      R2,R8
   \   0000018C   0x464B             MOV      R3,R9
   \   0000018E   0x.... 0x....      BL       __aeabi_dmul
   \   00000192   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??probe_index_x_2: (+1)
   \   00000196   0xB240             SXTB     R0,R0
   \   00000198   0x0001             MOVS     R1,R0
   \   0000019A   0xD404             BMI.N    ??probe_index_x_11
   \   0000019C   0xF896 0x2060      LDRB     R2,[R6, #+96]
   \   000001A0   0x1E52             SUBS     R2,R2,#+1
   \   000001A2   0x428A             CMP      R2,R1
   \   000001A4   0xDA01             BGE.N    ??probe_index_x_12
   \                     ??probe_index_x_11: (+1)
   \   000001A6   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??probe_index_x_12: (+1)
   \   000001AA   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \   000001AE   0xBF00             Nop      
   \                     ??probe_index_x_0:
   \   000001B0   0x........         DC32     mksCfg
   \   000001B4   0x........         DC32     mksTmp
   \   000001B8   0x3FE00000         DC32     0x3fe00000
   \   000001BC   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4
   \   __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
   \                     _ZN17mesh_bed_leveling13probe_index_yERKf: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4E69             LDR.N    R6,??probe_index_y_0
   \   00000008   0xF896 0x0098      LDRB     R0,[R6, #+152]
   \   0000000C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000010   0x4681             MOV      R9,R0
   \   00000012   0xF106 0x000C      ADD      R0,R6,#+12
   \   00000016   0xF9B0 0x104C      LDRSH    R1,[R0, #+76]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4291             CMP      R1,R2
   \   00000020   0xD13A             BNE.N    ??probe_index_y_1

        	py = (y - (MESH_MIN_Y_IS_KINEMATIC) + 0.5 * (MESH_Y_DIST_IS_KINEMATIC)) * (1.0 / (MESH_Y_DIST_IS_KINEMATIC));
        	   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",115  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \   00000022   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   00000026   0x1E40             SUBS     R0,R0,#+1
   \   00000028   0x.... 0x....      BL       __aeabi_i2f
   \   0000002C   0x4605             MOV      R5,R0
   \   0000002E   0x4C60             LDR.N    R4,??probe_index_y_0+0x4
   \   00000030   0x68A0             LDR      R0,[R4, #+8]
   \   00000032   0x4649             MOV      R1,R9
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x4680             MOV      R8,R0
   \   0000003A   0x68E0             LDR      R0,[R4, #+12]
   \   0000003C   0x4649             MOV      R1,R9
   \   0000003E   0x.... 0x....      BL       __aeabi_fsub
   \   00000042   0x4641             MOV      R1,R8
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4604             MOV      R4,R0
   \   00000054   0x460D             MOV      R5,R1
   \   00000056   0x6838             LDR      R0,[R7, #+0]
   \   00000058   0x4641             MOV      R1,R8
   \   0000005A   0x.... 0x....      BL       __aeabi_fsub
   \   0000005E   0x.... 0x....      BL       __aeabi_f2d
   \   00000062   0x4680             MOV      R8,R0
   \   00000064   0x4689             MOV      R9,R1
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x4952             LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3fe00000
   \   0000006A   0x4622             MOV      R2,R4
   \   0000006C   0x462B             MOV      R3,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_dmul
   \   00000072   0x4642             MOV      R2,R8
   \   00000074   0x464B             MOV      R3,R9
   \   00000076   0x.... 0x....      BL       __aeabi_dadd
   \   0000007A   0x4680             MOV      R8,R0
   \   0000007C   0x4689             MOV      R9,R1
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x494D             LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
   \   00000082   0x4622             MOV      R2,R4
   \   00000084   0x462B             MOV      R3,R5
   \   00000086   0x.... 0x....      BL       __aeabi_ddiv
   \   0000008A   0x4642             MOV      R2,R8
   \   0000008C   0x464B             MOV      R3,R9
   \   0000008E   0x.... 0x....      BL       __aeabi_dmul
   \   00000092   0x.... 0x....      BL       __aeabi_d2iz
   \   00000096   0xE07C             B.N      ??probe_index_y_2

  				py = (y - (MESH_MIN_Y_IS_Cartesian) + 0.5 * (MESH_Y_DIST_IS_Cartesian)) * (1.0 / (MESH_Y_DIST_IS_Cartesian));
  				   ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\mesh_bed_leveling.h",117  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??probe_index_y_1: (+1)
   \   00000098   0xF8D0 0x800C      LDR      R8,[R0, #+12]
   \   0000009C   0xF04F 0x507C      MOV      R0,#+1056964608
   \   000000A0   0x4641             MOV      R1,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_fmul
   \   000000A6   0x4682             MOV      R10,R0
   \   000000A8   0x4651             MOV      R1,R10
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x4649             MOV      R1,R9
   \   000000B0   0x.... 0x....      BL       __aeabi_fadd
   \   000000B4   0x4604             MOV      R4,R0
   \   000000B6   0xF8D6 0xB070      LDR      R11,[R6, #+112]
   \   000000BA   0x68F0             LDR      R0,[R6, #+12]
   \   000000BC   0x4659             MOV      R1,R11
   \   000000BE   0x.... 0x....      BL       __aeabi_fadd
   \   000000C2   0x4605             MOV      R5,R0
   \   000000C4   0x4621             MOV      R1,R4
   \   000000C6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CA   0xD201             BCS.N    ??probe_index_y_3
   \   000000CC   0x9402             STR      R4,[SP, #+8]
   \   000000CE   0xE000             B.N      ??probe_index_y_4
   \                     ??probe_index_y_3: (+1)
   \   000000D0   0x9502             STR      R5,[SP, #+8]
   \                     ??probe_index_y_4: (+1)
   \   000000D2   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000000D6   0x4651             MOV      R1,R10
   \   000000D8   0x.... 0x....      BL       __aeabi_fmul
   \   000000DC   0x4649             MOV      R1,R9
   \   000000DE   0x.... 0x....      BL       __aeabi_fsub
   \   000000E2   0x4682             MOV      R10,R0
   \   000000E4   0x4640             MOV      R0,R8
   \   000000E6   0x4659             MOV      R1,R11
   \   000000E8   0x.... 0x....      BL       __aeabi_fadd
   \   000000EC   0x4602             MOV      R2,R0
   \   000000EE   0x4650             MOV      R0,R10
   \   000000F0   0x4611             MOV      R1,R2
   \   000000F2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F6   0xD201             BCS.N    ??probe_index_y_5
   \   000000F8   0x46D0             MOV      R8,R10
   \   000000FA   0xE000             B.N      ??probe_index_y_6
   \                     ??probe_index_y_5: (+1)
   \   000000FC   0x4690             MOV      R8,R2
   \                     ??probe_index_y_6: (+1)
   \   000000FE   0x4628             MOV      R0,R5
   \   00000100   0x4621             MOV      R1,R4
   \   00000102   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000106   0xD201             BCS.N    ??probe_index_y_7
   \   00000108   0x46A1             MOV      R9,R4
   \   0000010A   0xE000             B.N      ??probe_index_y_8
   \                     ??probe_index_y_7: (+1)
   \   0000010C   0x46A9             MOV      R9,R5
   \                     ??probe_index_y_8: (+1)
   \   0000010E   0x4650             MOV      R0,R10
   \   00000110   0x4611             MOV      R1,R2
   \   00000112   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000116   0xD300             BCC.N    ??probe_index_y_9
   \   00000118   0x4692             MOV      R10,R2
   \                     ??probe_index_y_9: (+1)
   \   0000011A   0x4628             MOV      R0,R5
   \   0000011C   0x4621             MOV      R1,R4
   \   0000011E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000122   0xD300             BCC.N    ??probe_index_y_10
   \   00000124   0x462C             MOV      R4,R5
   \                     ??probe_index_y_10: (+1)
   \   00000126   0xF896 0x0061      LDRB     R0,[R6, #+97]
   \   0000012A   0x1E40             SUBS     R0,R0,#+1
   \   0000012C   0x.... 0x....      BL       __aeabi_i2f
   \   00000130   0x4605             MOV      R5,R0
   \   00000132   0x6838             LDR      R0,[R7, #+0]
   \   00000134   0x9902             LDR      R1,[SP, #+8]
   \   00000136   0x.... 0x....      BL       __aeabi_fsub
   \   0000013A   0x.... 0x....      BL       __aeabi_f2d
   \   0000013E   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000142   0x4640             MOV      R0,R8
   \   00000144   0x4649             MOV      R1,R9
   \   00000146   0x.... 0x....      BL       __aeabi_fsub
   \   0000014A   0x4629             MOV      R1,R5
   \   0000014C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000150   0x.... 0x....      BL       __aeabi_f2d
   \   00000154   0x2200             MOVS     R2,#+0
   \   00000156   0x4B17             LDR.N    R3,??probe_index_y_0+0x8  ;; 0x3fe00000
   \   00000158   0x.... 0x....      BL       __aeabi_dmul
   \   0000015C   0xE9DD 0x2300      LDRD     R2,R3,[SP, #+0]
   \   00000160   0x.... 0x....      BL       __aeabi_dadd
   \   00000164   0x4680             MOV      R8,R0
   \   00000166   0x4689             MOV      R9,R1
   \   00000168   0x4650             MOV      R0,R10
   \   0000016A   0x4621             MOV      R1,R4
   \   0000016C   0x.... 0x....      BL       __aeabi_fsub
   \   00000170   0x4629             MOV      R1,R5
   \   00000172   0x.... 0x....      BL       __aeabi_fdiv
   \   00000176   0x.... 0x....      BL       __aeabi_f2d
   \   0000017A   0x4602             MOV      R2,R0
   \   0000017C   0x460B             MOV      R3,R1
   \   0000017E   0x2000             MOVS     R0,#+0
   \   00000180   0x490D             LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
   \   00000182   0x.... 0x....      BL       __aeabi_ddiv
   \   00000186   0x4642             MOV      R2,R8
   \   00000188   0x464B             MOV      R3,R9
   \   0000018A   0x.... 0x....      BL       __aeabi_dmul
   \   0000018E   0x.... 0x....      BL       __aeabi_d2iz
   \                     ??probe_index_y_2: (+1)
   \   00000192   0xB240             SXTB     R0,R0
   \   00000194   0x0001             MOVS     R1,R0
   \   00000196   0xD404             BMI.N    ??probe_index_y_11
   \   00000198   0xF896 0x2061      LDRB     R2,[R6, #+97]
   \   0000019C   0x1E52             SUBS     R2,R2,#+1
   \   0000019E   0x428A             CMP      R2,R1
   \   000001A0   0xDA01             BGE.N    ??probe_index_y_12
   \                     ??probe_index_y_11: (+1)
   \   000001A2   0xF04F 0x30FF      MOV      R0,#-1
   \                     ??probe_index_y_12: (+1)
   \   000001A6   0xE8BD 0x8FFE      POP      {R1-R11,PC}      ;; return
   \   000001AA   0xBF00             Nop      
   \                     ??probe_index_y_0:
   \   000001AC   0x........         DC32     mksCfg
   \   000001B0   0x........         DC32     mksTmp
   \   000001B4   0x3FE00000         DC32     0x3fe00000
   \   000001B8   0x3FF00000         DC32     0x3ff00000
    341          
    342          #if ENABLED(BEZIER_CURVE_SUPPORT)
    343            #include "planner_bezier.h"
    344          #endif
    345          
    346          #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
    347            #include "buzzer.h"
    348          #endif
    349          
    350          #if ENABLED(USE_WATCHDOG)
    351            #include "watchdog.h"
    352          #endif
    353          
    354          #if ENABLED(MAX7219_DEBUG)
    355            #include "Max7219_Debug_LEDs.h"
    356          #endif
    357          
    358          #if HAS_COLOR_LEDS
    359            #include "leds.h"
    360          #endif
    361          
    362          #if HAS_SERVOS
    363            #include "servo.h"
    364          #endif
    365          
    366          #if HAS_DIGIPOTSS
    367            #include <SPI.h>
    368          #endif
    369          
    370          #if ENABLED(DAC_STEPPER_CURRENT)
    371            #include "stepper_dac.h"
    372          #endif
    373          
    374          #if ENABLED(EXPERIMENTAL_I2CBUS)
    375            #include "twibus.h"
    376          #endif
    377          
    378          #if ENABLED(I2C_POSITION_ENCODERS)
    379            #include "I2CPositionEncoder.h"
    380          #endif
    381          
    382          #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    383            #include "endstop_interrupts.h"
    384          #endif
    385          
    386          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    387            void gcode_M100();
    388            void M100_dump_routine(const char * const title, const char *start, const char *end);
    389          #endif
    390          
    391          #if ENABLED(G26_MESH_VALIDATION)
    392            bool g26_debug_flag; // =false
    393            void gcode_G26();
    394          #endif
    395          
    396          #if ENABLED(SDSUPPORT)

   \                                 In section .text, align 2, keep-with-next
   \   static __intrinsic __interwork __softfp void __sti__routine()
   \                     __sti__routine: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
    397            CardReader card;
   \   00000004   0x.... 0x....      LDR.W    R5,??DataTable134_3
   \   00000008   0x4628             MOV      R0,R5
   \   0000000A   0x.... 0x....      BL       _ZN10CardReaderC1Ev
    398          #endif
    399          
    400          #if ENABLED(EXPERIMENTAL_I2CBUS)
    401            TWIBus i2c;
    402          #endif
    403          
    404          #if ENABLED(G38_PROBE_TARGET)
    405            bool G38_move = false,
    406                 G38_endstop_hit = false;
    407          #endif
    408          
    409          #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
    410            #include "ubl.h"
    411            extern bool defer_return_to_status;
    412            unified_bed_leveling ubl;
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable134_4
   \   00000012   0xF104 0x0084      ADD      R0,R4,#+132
   \   00000016   0x.... 0x....      BL       _ZN20unified_bed_levelingC1Ev
   \   0000001A   0xF605 0x506C      ADDW     R0,R5,#+3436
   \   0000001E   0x.... 0x....      BL       _ZN9StopwatchC1Ev
   \   00000022   0x.... 0x....      LDR.W    R5,??DataTable134_5
   \   00000026   0x6F68             LDR      R0,[R5, #+116]
   \   00000028   0x.... 0x....      LDR.W    R1,??DataTable134_6  ;; 0x42700000
   \   0000002C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000030   0x6760             STR      R0,[R4, #+116]
   \   00000032   0x69E8             LDR      R0,[R5, #+28]
   \   00000034   0x67E0             STR      R0,[R4, #+124]
   \   00000036   0x.... 0x....      LDR.W    R7,??DataTable134_7  ;; 0x43160000
   \   0000003A   0x46B9             MOV      R9,R7
   \   0000003C   0xF04F 0x0A02      MOV      R10,#+2
   \   00000040   0xF04F 0x567E      MOV      R6,#+1065353216
   \   00000044   0x46B0             MOV      R8,R6
   \   00000046   0xE004             B.N      ??__sti__routine_0
   \                     ??__sti__routine_1: (+1)
   \   00000048   0x4648             MOV      R0,R9
   \   0000004A   0x4649             MOV      R1,R9
   \   0000004C   0x.... 0x....      BL       __aeabi_fmul
   \   00000050   0x4681             MOV      R9,R0
   \                     ??__sti__routine_0: (+1)
   \   00000052   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000056   0xD504             BPL.N    ??__sti__routine_2
   \   00000058   0x4640             MOV      R0,R8
   \   0000005A   0x4649             MOV      R1,R9
   \   0000005C   0x.... 0x....      BL       __aeabi_fmul
   \   00000060   0x4680             MOV      R8,R0
   \                     ??__sti__routine_2: (+1)
   \   00000062   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000066   0xD1EF             BNE.N    ??__sti__routine_1
   \   00000068   0x.... 0x....      LDR.W    R9,??DataTable134_8
   \   0000006C   0xF8C9 0x8034      STR      R8,[R9, #+52]
   \   00000070   0x4641             MOV      R1,R8
   \   00000072   0xF04F 0x4080      MOV      R0,#+1073741824
   \   00000076   0x.... 0x....      BL       __aeabi_fmul
   \   0000007A   0xF8C4 0x0080      STR      R0,[R4, #+128]
   \   0000007E   0x2402             MOVS     R4,#+2
   \   00000080   0xE004             B.N      ??__sti__routine_3
   \                     ??__sti__routine_4: (+1)
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x4639             MOV      R1,R7
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x4607             MOV      R7,R0
   \                     ??__sti__routine_3: (+1)
   \   0000008C   0x07E0             LSLS     R0,R4,#+31
   \   0000008E   0xD504             BPL.N    ??__sti__routine_5
   \   00000090   0x4630             MOV      R0,R6
   \   00000092   0x4639             MOV      R1,R7
   \   00000094   0x.... 0x....      BL       __aeabi_fmul
   \   00000098   0x4606             MOV      R6,R0
   \                     ??__sti__routine_5: (+1)
   \   0000009A   0x0864             LSRS     R4,R4,#+1
   \   0000009C   0xD1F1             BNE.N    ??__sti__routine_4
   \   0000009E   0xF8C9 0x6038      STR      R6,[R9, #+56]
   \   000000A2   0x68A8             LDR      R0,[R5, #+8]
   \   000000A4   0xF8C9 0x0004      STR      R0,[R9, #+4]
   \   000000A8   0x68E8             LDR      R0,[R5, #+12]
   \   000000AA   0xF8C9 0x0008      STR      R0,[R9, #+8]
   \   000000AE   0x6928             LDR      R0,[R5, #+16]
   \   000000B0   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   000000B4   0x6968             LDR      R0,[R5, #+20]
   \   000000B6   0xF8C9 0x0010      STR      R0,[R9, #+16]
   \   000000BA   0x69A8             LDR      R0,[R5, #+24]
   \   000000BC   0xF8C9 0x0014      STR      R0,[R9, #+20]
   \   000000C0   0x69E8             LDR      R0,[R5, #+28]
   \   000000C2   0xF8C9 0x0018      STR      R0,[R9, #+24]
   \   000000C6   0x6D28             LDR      R0,[R5, #+80]
   \   000000C8   0xF8C9 0x0024      STR      R0,[R9, #+36]
   \   000000CC   0x6968             LDR      R0,[R5, #+20]
   \   000000CE   0x68A9             LDR      R1,[R5, #+8]
   \   000000D0   0x.... 0x....      BL       __aeabi_fsub
   \   000000D4   0xF8C9 0x0028      STR      R0,[R9, #+40]
   \   000000D8   0x69A8             LDR      R0,[R5, #+24]
   \   000000DA   0x68E9             LDR      R1,[R5, #+12]
   \   000000DC   0x.... 0x....      BL       __aeabi_fsub
   \   000000E0   0xF8C9 0x002C      STR      R0,[R9, #+44]
   \   000000E4   0x69E8             LDR      R0,[R5, #+28]
   \   000000E6   0x6929             LDR      R1,[R5, #+16]
   \   000000E8   0x.... 0x....      BL       __aeabi_fsub
   \   000000EC   0xF8C9 0x0030      STR      R0,[R9, #+48]
   \   000000F0   0x7968             LDRB     R0,[R5, #+5]
   \   000000F2   0xF889 0x0000      STRB     R0,[R9, #+0]
   \   000000F6   0x79A8             LDRB     R0,[R5, #+6]
   \   000000F8   0xF889 0x0001      STRB     R0,[R9, #+1]
   \   000000FC   0x79E8             LDRB     R0,[R5, #+7]
   \   000000FE   0xF889 0x0002      STRB     R0,[R9, #+2]
   \   00000102   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    413          #endif
    414          
    415          #if ENABLED(CNC_COORDINATE_SYSTEMS)
    416            int8_t active_coordinate_system = -1; // machine space
    417            float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
    418          #endif
    419          
    420          bool Running = true;
    421          
    422          uint8_t marlin_debug_flags = DEBUG_NONE;
    423          
    424          /**
    425           * Cartesian Current Position
    426           *   Used to track the native machine position as moves are queued.
    427           *   Used by 'buffer_line_to_current_position' to do a move after changing it.
    428           *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
    429           */
    430          float current_position[XYZE] = { 0.0 };
    431          
    432          /**
    433           * Cartesian Destination
    434           *   The destination for a move, filled in by G-code movement commands,
    435           *   and expected by functions like 'prepare_move_to_destination'.
    436           *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
    437           */
    438          float destination[XYZE] = { 0.0 };
    439          
    440          /**
    441           * axis_homed
    442           *   Flags that each linear axis was homed.
    443           *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
    444           *
    445           * axis_known_position
    446           *   Flags that the position is known in each linear axis. Set when homed.
    447           *   Cleared whenever a stepper powers off, potentially losing its position.
    448           */
    449          bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
    450          
    451          /**
    452           * GCode line number handling. Hosts may opt to include line numbers when
    453           * sending commands to Marlin, and lines will be checked for sequentiality.
    454           * M110 N<int> sets the current line number.
    455           */
    456          static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
    457          
    458          /**
    459           * GCode Command Queue
    460           * A simple ring buffer of BUFSIZE command strings.
    461           *
    462           * Commands are copied into this buffer by the command injectors
    463           * (immediate, serial, sd card) and they are processed sequentially by
    464           * the main loop. The process_next_command function parses the next
    465           * command and hands off execution to individual handler functions.
    466           */
    467          uint8_t commands_in_queue = 0; // Count of commands in the queue
    468          static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
    469                         cmd_queue_index_w = 0; // Ring buffer write position
    470          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    471            char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
    472          #else                                         // This can be collapsed back to the way it was soon.
    473          static char command_queue[BUFSIZE][MAX_CMD_SIZE];
    474          #endif
    475          
    476          /**
    477           * Next Injected Command pointer. NULL if no commands are being injected.
    478           * Used by Marlin internally to ensure that commands initiated from within
    479           * are enqueued ahead of any pending serial or sd card commands.
    480           */
    481          static const char *injected_commands_P = NULL;
    482          
    483          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
    484            TempUnit input_temp_units = TEMPUNIT_C;
    485          #endif
    486          
    487          /**
    488           * Feed rates are often configured with mm/m
    489           * but the planner and stepper like mm/s units.
    490           */
    491           /*
    492          static const float homing_feedrate_mm_s[] PROGMEM = {
    493            #if ENABLED(DELTA)
    494              MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
    495            #else
    496              MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
    497            #endif
    498            MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
    499          };
    500          
    501          FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
    502          */
    503          
    504          float  homing_feedrate_mm_s[4];
    505          
    506          float feedrate_mm_s = MMM_TO_MMS(1500.0);
    507          static float saved_feedrate_mm_s;
    508          int16_t feedrate_percentage = 100, saved_feedrate_percentage;
    509          
    510          // Initialized by settings.load()
    511          bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
    512          
    513          #if HAS_WORKSPACE_OFFSET
    514            #if HAS_POSITION_SHIFT
    515              // The distance that XYZ has been offset by G92. Reset by G28.
    516              float position_shift[XYZ] = { 0 };
    517            #endif
    518            #if HAS_HOME_OFFSET
    519              // This offset is added to the configured home position.
    520              // Set by M206, M428, or menu item. Saved to EEPROM.
    521              float home_offset[XYZ] = { 0 };
    522            #endif
    523            #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
    524              // The above two are combined to save on computes
    525              float workspace_offset[XYZ] = { 0 };
    526            #endif
    527          #endif
    528          
    529          // Software Endstops are based on the configured limits.
    530          /*
    531          float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
    532                soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
    533          */
    534          float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

   \                                 In section .text, align 2, keep-with-next
    535          void soft_endstop_min_init()
    536          {
   \                     _Z21soft_endstop_min_initv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
    537              if(MACHINETPYE & IS_KINEMATIC)
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable134_5
   \   00000008   0x6960             LDR      R0,[R4, #+20]
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable134_9
   \   0000000E   0xF04F 0x567C      MOV      R6,#+1056964608
   \   00000012   0x.... 0x....      LDR.W    R7,??DataTable134_4
   \   00000016   0xF8B4 0x1058      LDRH     R1,[R4, #+88]
   \   0000001A   0xF240 0x3202      MOVW     R2,#+770
   \   0000001E   0x4211             TST      R1,R2
   \   00000020   0xD019             BEQ.N    ??soft_endstop_min_init_0
    538              {
    539                  soft_endstop_min[0]= X_MIN_BED_IS_KINEMATIC;
   \   00000022   0xF04F 0x483F      MOV      R8,#-1090519040
   \   00000026   0x4641             MOV      R1,R8
   \   00000028   0x.... 0x....      BL       __aeabi_fmul
   \   0000002C   0x6478             STR      R0,[R7, #+68]
    540                  soft_endstop_min[1]= Y_MIN_BED_IS_KINEMATIC;
   \   0000002E   0x69A0             LDR      R0,[R4, #+24]
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x.... 0x....      BL       __aeabi_fmul
   \   00000036   0x64B8             STR      R0,[R7, #+72]
    541                  soft_endstop_min[2]= Z_MIN_POS;
   \   00000038   0x6920             LDR      R0,[R4, #+16]
   \   0000003A   0x64F8             STR      R0,[R7, #+76]
    542          
    543                  soft_endstop_max[0] = X_MAX_BED_IS_KINEMATIC;
   \   0000003C   0x6960             LDR      R0,[R4, #+20]
   \   0000003E   0x4631             MOV      R1,R6
   \   00000040   0x.... 0x....      BL       __aeabi_fmul
   \   00000044   0x6268             STR      R0,[R5, #+36]
    544                  soft_endstop_max[1] = Y_MAX_BED_IS_KINEMATIC;
   \   00000046   0x69A0             LDR      R0,[R4, #+24]
   \   00000048   0x4631             MOV      R1,R6
   \   0000004A   0x.... 0x....      BL       __aeabi_fmul
   \   0000004E   0x62A8             STR      R0,[R5, #+40]
    545                  soft_endstop_max[2] = Z_MAX_POS;
   \   00000050   0x69E0             LDR      R0,[R4, #+28]
   \   00000052   0x62E8             STR      R0,[R5, #+44]
   \   00000054   0xE024             B.N      ??soft_endstop_min_init_1
    546              }
    547              else
    548              {
    549                  soft_endstop_min[0]= X_MIN_BED_IS_CARTESIAN;
   \                     ??soft_endstop_min_init_0: (+1)
   \   00000056   0x4631             MOV      R1,R6
   \   00000058   0x.... 0x....      BL       __aeabi_fmul
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x.... 0x....      BL       __aeabi_fsub
   \   00000062   0x6478             STR      R0,[R7, #+68]
    550                  soft_endstop_min[1]= Y_MIN_BED_IS_CARTESIAN;
   \   00000064   0x69A0             LDR      R0,[R4, #+24]
   \   00000066   0x4631             MOV      R1,R6
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0x4601             MOV      R1,R0
   \   0000006E   0x.... 0x....      BL       __aeabi_fsub
   \   00000072   0x64B8             STR      R0,[R7, #+72]
    551                  soft_endstop_min[2]= Z_MIN_POS;
   \   00000074   0x6920             LDR      R0,[R4, #+16]
   \   00000076   0x64F8             STR      R0,[R7, #+76]
    552          
    553                  soft_endstop_max[0] = X_MAX_BED_IS_CARTESIAN;
   \   00000078   0xF04F 0x4780      MOV      R7,#+1073741824
   \   0000007C   0x6960             LDR      R0,[R4, #+20]
   \   0000007E   0x4631             MOV      R1,R6
   \   00000080   0x.... 0x....      BL       __aeabi_fmul
   \   00000084   0x4639             MOV      R1,R7
   \   00000086   0x.... 0x....      BL       __aeabi_fmul
   \   0000008A   0x6268             STR      R0,[R5, #+36]
    554                  soft_endstop_max[1] = Y_MAX_BED_IS_CARTESIAN;
   \   0000008C   0x69A0             LDR      R0,[R4, #+24]
   \   0000008E   0x4631             MOV      R1,R6
   \   00000090   0x.... 0x....      BL       __aeabi_fmul
   \   00000094   0x4639             MOV      R1,R7
   \   00000096   0x.... 0x....      BL       __aeabi_fmul
   \   0000009A   0x62A8             STR      R0,[R5, #+40]
    555                  soft_endstop_max[2] = Z_MAX_POS;
   \   0000009C   0x69E0             LDR      R0,[R4, #+28]
   \   0000009E   0x62E8             STR      R0,[R5, #+44]
    556              }        
    557          }
   \                     ??soft_endstop_min_init_1: (+1)
   \   000000A0   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return
    558          
    559          #if HAS_SOFTWARE_ENDSTOPS
    560            bool soft_endstops_enabled = true;
    561            #if 1// IS_KINEMATIC
    562              float soft_endstop_radius, soft_endstop_radius_2;
    563            #endif
    564          #endif
    565          
    566          #if FAN_COUNT > 0
    567            int fanSpeeds[FAN_COUNT] = { 0 };
    568            #if ENABLED(EXTRA_FAN_SPEED)
    569              int16_t old_fanSpeeds[FAN_COUNT],
    570                      new_fanSpeeds[FAN_COUNT];
    571            #endif
    572            #if ENABLED(PROBING_FANS_OFF)
    573              bool fans_paused = false;
    574              int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
    575            #endif
    576          #endif
    577          
    578          // The active extruder (tool). Set with T<extruder> command.
    579          uint8_t active_extruder = 0;
    580          
    581          // Relative Mode. Enable with G91, disable with G90.
    582          static bool relative_mode = false;
    583          
    584          // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
    585          volatile bool wait_for_heatup = true;
    586          
    587          // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
    588          #if HAS_RESUME_CONTINUE
    589            volatile bool wait_for_user = false;
    590          #endif
    591          

   \                                 In section .text, align 4, keep-with-next
    592          const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
   \                     axis_codes:
   \   00000000   0x58 0x59          DC8 88, 89, 90, 69
   \              0x5A 0x45    
    593          
    594          // Number of characters read in the current line of serial input
    595          static int serial_count = 0;
    596          static int wifi_read_count = 0;
    597          
    598          // Inactivity shutdown
    599          millis_t previous_cmd_ms = 0;
    600          static millis_t max_inactive_time = 0;
    601          static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
    602          
    603          // Print Job Timer
    604          #if ENABLED(PRINTCOUNTER)
    605            PrintCounter print_job_timer = PrintCounter();
    606          #else
    607            Stopwatch print_job_timer = Stopwatch();
    608          #endif
    609          
    610          // Buzzer - I2C on the LCD or a BEEPER_PIN
    611          #if ENABLED(LCD_USE_I2C_BUZZER)
    612            #define BUZZ(d,f) lcd_buzz(d, f)
    613          #elif PIN_EXISTS(BEEPER)
    614            Buzzer buzzer;
    615            #define BUZZ(d,f) buzzer.tone(d, f)
    616          #else
    617            #define BUZZ(d,f) NOOP
    618          #endif
    619          
    620          uint8_t target_extruder;
    621          
    622          #if HAS_BED_PROBE
    623            float zprobe_zoffset; // Initialized by settings.load()
    624          #endif
    625          
    626          #if 1//HAS_ABL
    627            float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
    628            #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
    629          #elif defined(XY_PROBE_SPEED)
    630            #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
    631          #else
    632            #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
    633          #endif
    634          
    635          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
    636          /*
    637            #if ENABLED(DELTA)
    638              #define ADJUST_DELTA(V) \
    639                if (planner.leveling_active) { \
    640                  const float zadj = bilinear_z_offset(V); \
    641                  delta[A_AXIS] += zadj; \
    642                  delta[B_AXIS] += zadj; \
    643                  delta[C_AXIS] += zadj; \
    644                }
    645            #else
    646              #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
    647            #endif
    648            */

   \                                 In section .text, align 2, keep-with-next
    649          void  ADJUST_DELTA(const float logical[XYZ])
    650          {
   \                     _Z12ADJUST_DELTAPKf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    651          	float zadj;
    652          
    653          	if(MACHINETPYE == DELTA)
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable135
   \   00000006   0x7809             LDRB     R1,[R1, #+0]
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable134_5
   \   0000000C   0xF9B2 0x2058      LDRSH    R2,[R2, #+88]
   \   00000010   0x2A02             CMP      R2,#+2
   \   00000012   0xD116             BNE.N    ??ADJUST_DELTA_0
    654          		{
    655                	if (planner.leveling_active) { 
   \   00000014   0x2900             CMP      R1,#+0
   \   00000016   0xD01E             BEQ.N    ??ADJUST_DELTA_1
    656                 	 	zadj = bilinear_z_offset(logical); 
   \   00000018   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   0000001C   0x4604             MOV      R4,R0
    657                  	delta[A_AXIS] += zadj; 
   \   0000001E   0x.... 0x....      LDR.W    R5,??DataTable134_4
   \   00000022   0x6D28             LDR      R0,[R5, #+80]
   \   00000024   0x4621             MOV      R1,R4
   \   00000026   0x.... 0x....      BL       __aeabi_fadd
   \   0000002A   0x6528             STR      R0,[R5, #+80]
    658                 		delta[B_AXIS] += zadj; 
   \   0000002C   0x6D68             LDR      R0,[R5, #+84]
   \   0000002E   0x4621             MOV      R1,R4
   \   00000030   0x.... 0x....      BL       __aeabi_fadd
   \   00000034   0x6568             STR      R0,[R5, #+84]
    659                  	delta[C_AXIS] += zadj; 
   \   00000036   0x6DA8             LDR      R0,[R5, #+88]
   \   00000038   0x4621             MOV      R1,R4
   \   0000003A   0x.... 0x....      BL       __aeabi_fadd
   \   0000003E   0x65A8             STR      R0,[R5, #+88]
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}
    660                		}
    661          		}
    662          		else
    663          			{
    664          			if (planner.leveling_active) 
   \                     ??ADJUST_DELTA_0: (+1)
   \   00000042   0x2900             CMP      R1,#+0
   \   00000044   0xD007             BEQ.N    ??ADJUST_DELTA_1
    665          				 delta[Z_AXIS] += bilinear_z_offset(logical); 
   \   00000046   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   0000004A   0x.... 0x....      LDR.W    R5,??DataTable134_4
   \   0000004E   0x6DA9             LDR      R1,[R5, #+88]
   \   00000050   0x.... 0x....      BL       __aeabi_fadd
   \   00000054   0x65A8             STR      R0,[R5, #+88]
    666          			}
    667          }  
   \                     ??ADJUST_DELTA_1: (+1)
   \   00000056   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    668          //#elif IS_KINEMATIC
    669          //  #define ADJUST_DELTA(V) NOOP
    670          #endif
    671          
    672          #if ENABLED(X_DUAL_ENDSTOPS)
    673            float x_endstop_adj;                // Initialized by settings.load()
    674          #endif
    675          #if ENABLED(Y_DUAL_ENDSTOPS)
    676            float y_endstop_adj;                // Initialized by settings.load()
    677          #endif
    678          #if 1//ENABLED(Z_DUAL_ENDSTOPS)
    679            float z_endstop_adj;                // Initialized by settings.load()
    680          #endif
    681          
    682          // Extruder offsets
    683          #if HOTENDS > 1
    684            float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
    685          #endif
    686          
    687          #if HAS_Z_SERVO_ENDSTOP
    688            const int z_servo_angle[2] = Z_SERVO_ANGLES;
    689          #endif
    690          
    691          #if ENABLED(BARICUDA)
    692            uint8_t baricuda_valve_pressure = 0,
    693                    baricuda_e_to_p_pressure = 0;
    694          #endif
    695          
    696          #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
    697            bool autoretract_enabled,                 // M209 S - Autoretract switch
    698                 retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
    699            float retract_length,                     // M207 S - G10 Retract length
    700                  retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
    701                  retract_zlift,                      // M207 Z - G10 Retract hop size
    702                  retract_recover_length,             // M208 S - G11 Recover length
    703                  retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
    704                  swap_retract_length,                // M207 W - G10 Swap Retract length
    705                  swap_retract_recover_length,        // M208 W - G11 Swap Recover length
    706                  swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
    707            #if EXTRUDERS > 1
    708              bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
    709            #else
    710              constexpr bool retracted_swap[1] = { false };
    711            #endif
    712          #endif // FWRETRACT
    713          
    714          #if HAS_POWER_SWITCH
    715            bool powersupply_on =
    716              #if ENABLED(PS_DEFAULT_OFF)
    717                false
    718              #else
    719                true
    720              #endif
    721            ;
    722          #endif
    723          
    724          #if 1//ENABLED(DELTA)
    725          
    726            float delta[ABC];
    727          
    728            // Initialized by settings.load()
    729            float delta_height,
    730                  delta_endstop_adj[ABC] = { 0 },
    731                  delta_radius,
    732                  delta_tower_angle_trim[ABC],
    733                  delta_tower[ABC][2],
    734                  delta_diagonal_rod,
    735                  delta_calibration_radius,
    736                  delta_diagonal_rod_2_tower[ABC],
    737                  delta_segments_per_second,
    738                  delta_clip_start_height = Z_MAX_POS;
    739          
    740            float delta_safe_distance_from_top();
    741          
    742          #endif
    743          
    744          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
    745            int bilinear_grid_spacing[2], bilinear_start[2];
    746            float bilinear_grid_factor[2],
    747                  //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
    748                  z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
    749          #endif
    750          
    751          #if 1//IS_SCARA
    752            // Float constants for SCARA calculations

   \                                 In section .rodata, align 4, keep-with-next
    753            const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
   \                     L1:
   \   00000000   0x43160000         DC32 43160000H

   \                                 In section .rodata, align 4, keep-with-next
   \                     L2:
   \   00000000   0x43160000         DC32 43160000H

   \                                 In section .data, align 4
   \                     mks_heating_busy:
   \   00000000   0x00               DC8 0
   \                     marlin_debug_flags:
   \   00000001   0x00               DC8 0
   \                     commands_in_queue:
   \   00000002   0x00               DC8 0
   \                     active_extruder:
   \   00000003   0x00               DC8 0
   \                     wait_for_heatup:
   \   00000004   0x01               DC8 1
   \                     target_extruder:
   \   00000005   0x00               DC8 0
   \                     feedrate_percentage:
   \   00000006   0x0064             DC16 100
   \                     current_position:
   \   00000008   0x00000000         DC32 0H
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     destination:
   \   00000018   0x00000000         DC32 0H
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     homing_feedrate_mm_s:
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     workspace_offset:
   \   00000038   0x00000000         DC32 0H
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_min:
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta:
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     feedrate_mm_s:
   \   0000005C   0x41C80000         DC32 41C80000H
   \                     position_shift:
   \   00000060   0x00000000         DC32 0H
   \   00000064   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     fanSpeeds:
   \   0000006C   0x00000000         DC32 0
   \                     zprobe_zoffset:
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     xy_probe_feedrate_mm_s:
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_height:
   \   00000078   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_clip_start_height:
   \   0000007C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000080   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     ubl:
   \   00000084   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
    754                        L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
    755                        L2_2 = sq(float(L2));
    756          
    757            //float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
    758            //      delta[ABC];
    759          #endif
    760          
    761          float cartes[XYZ] = { 0 };
    762          
    763          #if ENABLED(FILAMENT_WIDTH_SENSOR)
    764            bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
    765            float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
    766                  filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
    767            uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
    768            int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
    769                   filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
    770          #endif
    771          
    772          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    773            static bool filament_ran_out = false;
    774          #endif
    775          
    776          #if ENABLED(ADVANCED_PAUSE_FEATURE)
    777            AdvancedPauseMenuResponse advanced_pause_menu_response;
    778          #endif
    779          
    780          #if ENABLED(MIXING_EXTRUDER)
    781            float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
    782            #if MIXING_VIRTUAL_TOOLS > 1
    783              float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
    784            #endif
    785          #endif
    786          
    787          static bool send_ok[BUFSIZE];
    788          
    789          #if HAS_SERVOS
    790            Servo servo[NUM_SERVOS];
    791            #define MOVE_SERVO(I, P) servo[I].move(P)
    792            #if HAS_Z_SERVO_ENDSTOP
    793              #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
    794              #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
    795            #endif
    796          #endif
    797          
    798          #ifdef CHDK
    799            millis_t chdkHigh = 0;
    800            bool chdkActive = false;
    801          #endif
    802          
    803          #if ENABLED(PID_EXTRUSION_SCALING)
    804            int lpq_len = 20;
    805          #endif
    806          
    807          #if ENABLED(HOST_KEEPALIVE_FEATURE)
    808            MarlinBusyState busy_state = NOT_BUSY;
    809            static millis_t next_busy_signal_ms = 0;
    810            uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
    811          #else
    812            #define host_keepalive() NOOP
    813          #endif
    814          
    815          #if ENABLED(I2C_POSITION_ENCODERS)
    816            I2CPositionEncodersMgr I2CPEM;
    817            uint8_t blockBufferIndexRef = 0;
    818            millis_t lastUpdateMillis;
    819          #endif
    820          
    821          #if ENABLED(CNC_WORKSPACE_PLANES)
    822            static WorkspacePlane workspace_plane = PLANE_XY;
    823          #endif
    824          
    825          //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
    826          //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
    827          static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
    828          static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
    829          /*P
    830          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    831            static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    832            static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
    833            typedef void __void_##CONFIG##__
    834          */
    835          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
    836          	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
    837          	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
    838          

   \                                 In section .text, align 2, keep-with-next
    839          XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
   \                     _Z12base_min_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable134_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6840             LDR      R0,[R0, #+4]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    840          XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
   \                     _Z12base_max_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable134_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    841          XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
   \                     _Z13base_home_pos8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable134_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x69C0             LDR      R0,[R0, #+28]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    842          XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
   \                     _Z10max_length8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable134_8
   \   00000004   0xEB01 0x0080      ADD      R0,R1,R0, LSL #+2
   \   00000008   0x6A80             LDR      R0,[R0, #+40]
   \   0000000A   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    843          XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
   \                     _Z12home_bump_mm8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable137
   \   00000004   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000008   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
    844          XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
   \                     _Z8home_dir8AxisEnum: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable134_8
   \   00000004   0x5640             LDRSB    R0,[R0, R1]
   \   00000006   0x4770             BX       LR               ;; return
    845          
    846          /**
    847           * ***************************************************************************
    848           * ******************************** FUNCTIONS ********************************
    849           * ***************************************************************************
    850           */
    851          
    852          void stop();
    853          
    854          void get_available_commands();
    855          void process_next_command();
    856          void process_parsed_command();
    857          
    858          void get_cartesian_from_steppers();
    859          void set_current_from_steppers_for_axis(const AxisEnum axis);
    860          
    861          #if ENABLED(ARC_SUPPORT)
    862            void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
    863          #endif
    864          
    865          #if ENABLED(BEZIER_CURVE_SUPPORT)
    866            void plan_cubic_move(const float (&offset)[4]);
    867          #endif
    868          
    869          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
    870          void report_current_position();
    871          void report_current_position_detail();
    872          
    873          #if ENABLED(DEBUG_LEVELING_FEATURE)
    874            void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
    875              serialprintPGM(prefix);
    876              SERIAL_CHAR('(');
    877              SERIAL_ECHO(x);
    878              SERIAL_ECHOPAIR(", ", y);
    879              SERIAL_ECHOPAIR(", ", z);
    880              SERIAL_CHAR(')');
    881              if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
    882            }
    883          
    884            void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
    885              print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
    886            }
    887          
    888            #if 1//HAS_ABL
    889              void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
    890                print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
    891              }
    892            #endif
    893          
    894            #define DEBUG_POS(SUFFIX,VAR) do { \
    895              print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
    896          #endif
    897          
    898          /**
    899           * sync_plan_position
    900           *
    901           * Set the planner/stepper positions directly from current_position with
    902           * no kinematic translation. Used for homing axes and cartesian/core syncing.
    903           */

   \                                 In section .text, align 2, keep-with-next
    904          void sync_plan_position() {
    905            #if ENABLED(DEBUG_LEVELING_FEATURE)
    906              if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
    907            #endif
    908            planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
   \                     _Z18sync_plan_positionv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable134_4
   \   00000004   0xF100 0x0314      ADD      R3,R0,#+20
   \   00000008   0x6902             LDR      R2,[R0, #+16]
   \   0000000A   0x68C1             LDR      R1,[R0, #+12]
   \   0000000C   0x6880             LDR      R0,[R0, #+8]
   \   0000000E   0x.... 0x....      B.W      _ZN7Planner15set_position_mmEfffRKf
    909          }

   \                                 In section .text, align 4
    910          inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
   \                     _Z20sync_plan_position_ev: (+1)
   \   00000000   0x4801             LDR.N    R0,??sync_plan_position_e_0
   \   00000002   0x.... 0x....      B.W      _ZN7Planner17set_e_position_mmERKf
   \   00000006   0xBF00             Nop      
   \                     ??sync_plan_position_e_0:
   \   00000008   0x........         DC32     mks_heating_busy+0x14
    911          
    912          //#if IS_KINEMATIC
    913          

   \                                 In section .text, align 4
    914            inline void sync_plan_position_kinematic() {
    915              #if ENABLED(DEBUG_LEVELING_FEATURE)
    916                if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
    917              #endif
    918              planner.set_position_mm_kinematic(current_position);
   \                     _Z28sync_plan_position_kinematicv: (+1)
   \   00000000   0x4801             LDR.N    R0,??sync_plan_position_kinematic_0
   \   00000002   0x.... 0x....      B.W      _ZN7Planner25set_position_mm_kinematicERA4_Kf
   \   00000006   0xBF00             Nop      
   \                     ??sync_plan_position_kinematic_0:
   \   00000008   0x........         DC32     mks_heating_busy+0x8
    919            }
    920          //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
    921          
    922          //#else
    923          
    924          //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
    925          
    926          //#endif
    927          

   \                                 In section .text, align 2, keep-with-next
    928          void SYNC_PLAN_POSITION_KINEMATIC()
    929          {
    930          	if(MACHINETPYE & IS_KINEMATIC)
   \                     _Z28SYNC_PLAN_POSITION_KINEMATICv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable134_5
   \   00000004   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000008   0xF240 0x3102      MOVW     R1,#+770
   \   0000000C   0x4208             TST      R0,R1
   \   0000000E   0xD001             BEQ.N    ??SYNC_PLAN_POSITION_KINEMATIC_0
    931          		sync_plan_position_kinematic();
   \   00000010   0x.... 0x....      B.W      _Z28sync_plan_position_kinematicv
    932          	else
    933          		sync_plan_position();
   \                     ??SYNC_PLAN_POSITION_KINEMATIC_0: (+1)
   \   00000014   0x....             B.N      _Z18sync_plan_positionv
    934          }
    935          
    936          #if 0//ENABLED(SDSUPPORT)
    937            #include "SdFatUtil.h"
    938            int freeMemory() { return SdFatUtil::FreeRam(); }
    939          #else
    940          /*
    941          extern "C" {
    942            extern char __bss_end;
    943            extern char __heap_start;
    944            extern void* __brkval;
    945          
    946            int freeMemory() {
    947              int free_memory;
    948              if ((int)__brkval == 0)
    949                free_memory = ((int)&free_memory) - ((int)&__bss_end);
    950              else
    951                free_memory = ((int)&free_memory) - ((int)__brkval);
    952              return free_memory;
    953            }
    954          }
    955          */

   \                                 In section .text, align 2, keep-with-next
    956          	int freeMemory() { return 4396; }	//No free ram management
   \                     _Z10freeMemoryv: (+1)
   \   00000000   0xF241 0x102C      MOVW     R0,#+4396
   \   00000004   0x4770             BX       LR               ;; return
    957          
    958          #endif // !SDSUPPORT
    959          
    960          #if ENABLED(DIGIPOT_I2C)
    961            extern void digipot_i2c_set_current(uint8_t channel, float current);
    962            extern void digipot_i2c_init();
    963          #endif
    964          
    965          /**
    966           * Inject the next "immediate" command, when possible, onto the front of the queue.
    967           * Return true if any immediate commands remain to inject.
    968           */

   \                                 In section .text, align 2, keep-with-next
    969          static bool drain_injected_commands_P() {
   \                     _Z25drain_injected_commands_Pv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
    970            if (injected_commands_P != NULL) {
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable137_1
   \   00000008   0x6821             LDR      R1,[R4, #+0]
   \   0000000A   0x2900             CMP      R1,#+0
   \   0000000C   0xD01C             BEQ.N    ??drain_injected_commands_P_0
    971              size_t i = 0;
   \   0000000E   0x2500             MOVS     R5,#+0
    972              char c, cmd[30];
    973              //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
    974              strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
   \   00000010   0x221D             MOVS     R2,#+29
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       strncpy
    975              cmd[sizeof(cmd) - 1] = '\0';
   \   00000018   0xA800             ADD      R0,SP,#+0
   \   0000001A   0x4629             MOV      R1,R5
   \   0000001C   0x7741             STRB     R1,[R0, #+29]
   \   0000001E   0xE000             B.N      ??drain_injected_commands_P_1
    976              while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
   \                     ??drain_injected_commands_P_2: (+1)
   \   00000020   0x1C6D             ADDS     R5,R5,#+1
   \                     ??drain_injected_commands_P_1: (+1)
   \   00000022   0x562E             LDRSB    R6,[R5, R0]
   \   00000024   0x2E00             CMP      R6,#+0
   \   00000026   0xD001             BEQ.N    ??drain_injected_commands_P_3
   \   00000028   0x2E0A             CMP      R6,#+10
   \   0000002A   0xD1F9             BNE.N    ??drain_injected_commands_P_2
    977              cmd[i] = '\0';
   \                     ??drain_injected_commands_P_3: (+1)
   \   0000002C   0x5429             STRB     R1,[R5, R0]
    978              if (enqueue_and_echo_command(cmd))     // success?
   \   0000002E   0x.... 0x....      BL       _Z24enqueue_and_echo_commandPKcb
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD008             BEQ.N    ??drain_injected_commands_P_0
    979                injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD004             BEQ.N    ??drain_injected_commands_P_4
   \   0000003A   0x6820             LDR      R0,[R4, #+0]
   \   0000003C   0x1828             ADDS     R0,R5,R0
   \   0000003E   0x1C40             ADDS     R0,R0,#+1
   \   00000040   0x6020             STR      R0,[R4, #+0]
   \   00000042   0xE001             B.N      ??drain_injected_commands_P_0
   \                     ??drain_injected_commands_P_4: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x6020             STR      R0,[R4, #+0]
    980            }
    981            return (injected_commands_P != NULL);    // return whether any more remain
   \                     ??drain_injected_commands_P_0: (+1)
   \   00000048   0x6820             LDR      R0,[R4, #+0]
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD001             BEQ.N    ??drain_injected_commands_P_5
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0xE000             B.N      ??drain_injected_commands_P_6
   \                     ??drain_injected_commands_P_5: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \                     ??drain_injected_commands_P_6: (+1)
   \   00000054   0xB008             ADD      SP,SP,#+32
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
    982          }
    983          
    984          /**
    985           * Record one or many commands to run from program memory.
    986           * Aborts the current queue, if any.
    987           * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
    988           */

   \                                 In section .text, align 2, keep-with-next
    989          void enqueue_and_echo_commands_P(const char * const pgcode) {
    990            injected_commands_P = pgcode;
   \                     _Z27enqueue_and_echo_commands_PPKc: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable137_1
   \   00000004   0x6008             STR      R0,[R1, #+0]
    991            drain_injected_commands_P(); // first command executed asap (when possible)
   \   00000006   0x....             B.N      _Z25drain_injected_commands_Pv
    992          }
    993          
    994          /**
    995           * Clear the Marlin command queue
    996           */

   \                                 In section .text, align 2, keep-with-next
    997          void clear_command_queue() {
    998            cmd_queue_index_r = cmd_queue_index_w;
   \                     _Z19clear_command_queuev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable137_2
   \   00000004   0x7A01             LDRB     R1,[R0, #+8]
   \   00000006   0x71C1             STRB     R1,[R0, #+7]
    999            commands_in_queue = 0;
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x.... 0x....      LDR.W    R1,??DataTable134_4
   \   0000000E   0x7088             STRB     R0,[R1, #+2]
   1000          }
   \   00000010   0x4770             BX       LR               ;; return
   1001          
   1002          /**
   1003           * Once a new command is in the ring buffer, call this to commit it
   1004           */

   \                                 In section .text, align 4
   1005          inline void _commit_command(bool say_ok) {
   1006            send_ok[cmd_queue_index_w] = say_ok;
   \                     _Z15_commit_commandb: (+1)
   \   00000000   0x4907             LDR.N    R1,??_commit_command_0
   \   00000002   0x7A0A             LDRB     R2,[R1, #+8]
   \   00000004   0x1853             ADDS     R3,R2,R1
   \   00000006   0x7618             STRB     R0,[R3, #+24]
   1007            if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
   \   00000008   0x1C50             ADDS     R0,R2,#+1
   \   0000000A   0x7208             STRB     R0,[R1, #+8]
   \   0000000C   0xB2C0             UXTB     R0,R0
   \   0000000E   0x2804             CMP      R0,#+4
   \   00000010   0xDB01             BLT.N    ??_commit_command_1
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x7208             STRB     R0,[R1, #+8]
   1008            commands_in_queue++;
   \                     ??_commit_command_1: (+1)
   \   00000016   0x4803             LDR.N    R0,??_commit_command_0+0x4
   \   00000018   0x7881             LDRB     R1,[R0, #+2]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0x7081             STRB     R1,[R0, #+2]
   1009          }
   \   0000001E   0x4770             BX       LR               ;; return
   \                     ??_commit_command_0:
   \   00000020   0x........         DC32     filament_loading_time_flg
   \   00000024   0x........         DC32     mks_heating_busy
   1010          
   1011          /**
   1012           * Copy a command from RAM into the main command buffer.
   1013           * Return true if the command was successfully added.
   1014           * Return false for a full buffer, or if the 'command' is a comment.
   1015           */

   \                                 In section .text, align 4
   1016          inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
   \                     _Z15_enqueuecommandPKcb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x460C             MOV      R4,R1
   1017            if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
   \   00000004   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   00000008   0x293B             CMP      R1,#+59
   \   0000000A   0xD003             BEQ.N    ??_enqueuecommand_0
   \   0000000C   0x490A             LDR.N    R1,??_enqueuecommand_1
   \   0000000E   0x7889             LDRB     R1,[R1, #+2]
   \   00000010   0x2904             CMP      R1,#+4
   \   00000012   0xDB01             BLT.N    ??_enqueuecommand_2
   \                     ??_enqueuecommand_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xBD10             POP      {R4,PC}
   1018            strcpy(command_queue[cmd_queue_index_w], cmd);
   \                     ??_enqueuecommand_2: (+1)
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4808             LDR.N    R0,??_enqueuecommand_1+0x4
   \   0000001C   0x7A00             LDRB     R0,[R0, #+8]
   \   0000001E   0xEB00 0x0240      ADD      R2,R0,R0, LSL #+1
   \   00000022   0x4807             LDR.N    R0,??_enqueuecommand_1+0x8
   \   00000024   0xEB00 0x1042      ADD      R0,R0,R2, LSL #+5
   \   00000028   0x.... 0x....      BL       strcpy
   1019            _commit_command(say_ok);
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _Z15_commit_commandb
   1020            return true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}          ;; return
   \   00000036   0xBF00             Nop      
   \                     ??_enqueuecommand_1:
   \   00000038   0x........         DC32     mks_heating_busy
   \   0000003C   0x........         DC32     filament_loading_time_flg
   \   00000040   0x........         DC32     command_queue
   1021          }
   1022          
   1023          /**
   1024           * Enqueue with Serial Echo
   1025           */

   \                                 In section .text, align 2, keep-with-next
   1026          bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
   \                     _Z24enqueue_and_echo_commandPKcb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   1027            if (_enqueuecommand(cmd, say_ok)) {
   \   00000004   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD014             BEQ.N    ??enqueue_and_echo_command_0
   1028              SERIAL_ECHO_START();
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable137_3
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1029              SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
   \   00000014   0x4621             MOV      R1,R4
   \   00000016   0x.... 0x....      ADR.W    R0,`?<Constant "enqueueing \\"">`
   \   0000001A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   1030              SERIAL_CHAR('"');
   \   0000001E   0x.... 0x....      LDR.W    R4,??DataTable137_4
   \   00000022   0x2122             MOVS     R1,#+34
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1031              SERIAL_EOL();
   \   0000002A   0x210A             MOVS     R1,#+10
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1032              return true;
   \   00000032   0x2001             MOVS     R0,#+1
   \   00000034   0xBD10             POP      {R4,PC}
   1033            }
   1034            return false;
   \                     ??enqueue_and_echo_command_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   1035          }
   1036          

   \                                 In section .text, align 2, keep-with-next
   1037          void setup_killpin() {
   1038            #if HAS_KILL
   1039              SET_INPUT_PULLUP(KILL_PIN);
   1040            #endif
   1041          }
   \                     _Z13setup_killpinv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1042          
   1043          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   1044          
   1045            void setup_filrunoutpin() {
   1046              #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
   1047                SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
   1048              #else
   1049                SET_INPUT(FIL_RUNOUT_PIN);
   1050              #endif
   1051            }
   1052          
   1053          #endif
   1054          

   \                                 In section .text, align 2, keep-with-next
   1055          void setup_powerhold() {
   1056            #if HAS_SUICIDE
   1057              OUT_WRITE(SUICIDE_PIN, HIGH);
   1058            #endif
   1059            #if HAS_POWER_SWITCH
   1060              #if ENABLED(PS_DEFAULT_OFF)
   1061                OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   1062              #else
   1063                OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
   1064              #endif
   1065            #endif
   1066          }
   \                     _Z15setup_powerholdv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1067          

   \                                 In section .text, align 2, keep-with-next
   1068          void suicide() {
   1069            #if HAS_SUICIDE
   1070              OUT_WRITE(SUICIDE_PIN, LOW);
   1071            #endif
   1072          }
   \                     _Z7suicidev: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1073          

   \                                 In section .text, align 2, keep-with-next
   1074          void servo_init() {
   1075            #if NUM_SERVOS >= 1 && HAS_SERVO_0
   1076              servo[0].attach(SERVO0_PIN);
   1077              servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
   1078            #endif
   1079            #if NUM_SERVOS >= 2 && HAS_SERVO_1
   1080              servo[1].attach(SERVO1_PIN);
   1081              servo[1].detach();
   1082            #endif
   1083            #if NUM_SERVOS >= 3 && HAS_SERVO_2
   1084              servo[2].attach(SERVO2_PIN);
   1085              servo[2].detach();
   1086            #endif
   1087            #if NUM_SERVOS >= 4 && HAS_SERVO_3
   1088              servo[3].attach(SERVO3_PIN);
   1089              servo[3].detach();
   1090            #endif
   1091          
   1092            #if HAS_Z_SERVO_ENDSTOP
   1093              /**
   1094               * Set position of Z Servo Endstop
   1095               *
   1096               * The servo might be deployed and positioned too low to stow
   1097               * when starting up the machine or rebooting the board.
   1098               * There's no way to know where the nozzle is positioned until
   1099               * homing has been done - no homing with z-probe without init!
   1100               *
   1101               */
   1102              STOW_Z_SERVO();
   1103            #endif
   1104          }
   \                     _Z10servo_initv: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   1105          
   1106          /**
   1107           * Stepper Reset (RigidBoard, et.al.)
   1108           */
   1109          #if HAS_STEPPER_RESET
   1110            void disableStepperDrivers() {
   1111              OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
   1112            }
   1113            void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
   1114          #endif
   1115          
   1116          #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
   1117          
   1118            void i2c_on_receive(int bytes) { // just echo all bytes received to serial
   1119              i2c.receive(bytes);
   1120            }
   1121          
   1122            void i2c_on_request() {          // just send dummy data for now
   1123              i2c.reply("Hello World!\n");
   1124            }
   1125          
   1126          #endif
   1127          

   \                                 In section .text, align 2, keep-with-next
   1128          void gcode_line_error(const char* err, bool doFlush = true) {
   \                     _Z16gcode_line_errorPKcb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   1129            SERIAL_ERROR_START();
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable137_5
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1130            serialprintPGM(err);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1131            SERIAL_ERRORLN(gcode_LastN);
   \   00000014   0x.... 0x....      LDR.W    R4,??DataTable137_4
   \   00000018   0x.... 0x....      LDR.W    R6,??DataTable139
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x6AF1             LDR      R1,[R6, #+44]
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1132            //Serial.println(gcode_N);
   1133            if (doFlush) FlushSerialRequestResend();
   \   0000002E   0x2D00             CMP      R5,#+0
   \   00000030   0xD001             BEQ.N    ??gcode_line_error_0
   \   00000032   0x.... 0x....      BL       _Z24FlushSerialRequestResendv
   1134            serial_count = 0;
   \                     ??gcode_line_error_0: (+1)
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x6370             STR      R0,[R6, #+52]
   1135          }
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
   1136          
   1137          uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
   1138          
   1139          uint8_t from_wifi_flag = 0; // whether data comes from wifi model
   1140          
   1141          /**
   1142           * Get all commands waiting on the serial port and queue them.
   1143           * Exit when the buffer is full or when no more characters are
   1144           * left on the serial port.
   1145           */

   \                                 In section .text, align 4
   1146          inline void get_serial_commands() {
   \                     _Z19get_serial_commandsv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   1147            static char serial_line_buffer[MAX_CMD_SIZE];
   1148            static bool serial_comment_mode = false;
   1149            static millis_t last_wait_time = 0;
   1150            const millis_t wait_ms = millis();
   \   00000004   0x.... 0x....      BL       HAL_GetTick
   \   00000008   0x4606             MOV      R6,R0
   1151          
   1152            // If the command buffer is empty for too long,
   1153            // send "wait" to indicate Marlin is still waiting.
   1154            #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1155              static millis_t last_command_time = 0;
   1156              const millis_t ms = millis();
   1157              if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
   1158                SERIAL_ECHOLNPGM(MSG_WAIT);
   1159                last_command_time = ms;
   1160              }
   1161            #endif
   1162          #if 1
   1163            
   1164          	  /*5s?¨?2a2?|ì?????¨2¨oy?Y?¨°¨¨??a??¨?D¨￠a?¨2?????ê??¨|¨o1¨??wifi*/
   1165          	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
   \   0000000A   0x4C77             LDR.N    R4,??get_serial_commands_0
   \   0000000C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xF040 0x80A4      BNE.W    ??get_serial_commands_1
   \   00000014   0x4875             LDR.N    R0,??get_serial_commands_0+0x4
   \   00000016   0x.... 0x....      BL       _ZN10USARTClass9availableEv
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xF040 0x809E      BNE.W    ??get_serial_commands_1
   \   00000020   0x4873             LDR.N    R0,??get_serial_commands_0+0x8
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0x1A71             SUBS     R1,R6,R1
   \   00000026   0xF5B1 0x717A      SUBS     R1,R1,#+1000
   \   0000002A   0xF100 0x8097      BMI.W    ??get_serial_commands_1
   1166          		if(serial_wait_tick <= 5)
   \   0000002E   0x4D71             LDR.N    R5,??get_serial_commands_0+0xC
   \   00000030   0x7A29             LDRB     R1,[R5, #+8]
   \   00000032   0x2906             CMP      R1,#+6
   \   00000034   0xDA01             BGE.N    ??get_serial_commands_2
   1167          	  {
   1168          		  serial_wait_tick ++;
   \   00000036   0x1C49             ADDS     R1,R1,#+1
   \   00000038   0x7229             STRB     R1,[R5, #+8]
   1169          	  }
   1170          		last_wait_time = wait_ms;
   \                     ??get_serial_commands_2: (+1)
   \   0000003A   0x6006             STR      R6,[R0, #+0]
   \   0000003C   0xE08E             B.N      ??get_serial_commands_1
   1171          	  }
   1172          #endif
   1173          
   1174            /**
   1175             * Loop while serial characters are incoming and the queue is not full
   1176             */
   1177            int c;
   1178            while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
   1179          
   1180              char serial_char = c;
   1181          	
   1182          	serial_wait_tick = 0;
   1183          	from_wifi_flag = 0;
   1184          
   1185              /**
   1186               * If the character ends the line
   1187               */
   1188              if (serial_char == '\n' || serial_char == '\r') {
   1189          
   1190                serial_comment_mode = false;                      // end of line == end of comment
   1191          
   1192                if (!serial_count) continue;                      // Skip empty lines
   1193          
   1194                serial_line_buffer[serial_count] = 0;             // Terminate string
   1195                serial_count = 0;                                 // Reset buffer
   1196          
   1197                char* command = serial_line_buffer;
   1198          
   1199                while (*command == ' ') command++;                // Skip leading spaces
   \                     ??get_serial_commands_3: (+1)
   \   0000003E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??get_serial_commands_4: (+1)
   \   00000040   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000044   0x2820             CMP      R0,#+32
   \   00000046   0xD0FA             BEQ.N    ??get_serial_commands_3
   1200                char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
   \   00000048   0x284E             CMP      R0,#+78
   \   0000004A   0xD101             BNE.N    ??get_serial_commands_5
   \   0000004C   0x46B9             MOV      R9,R7
   \   0000004E   0xE001             B.N      ??get_serial_commands_6
   \                     ??get_serial_commands_5: (+1)
   \   00000050   0xF04F 0x0900      MOV      R9,#+0
   1201          
   1202                if (npos) {
   \                     ??get_serial_commands_6: (+1)
   \   00000054   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000058   0xD04B             BEQ.N    ??get_serial_commands_7
   1203          
   1204                  bool M110 = strstr_P(command, PSTR("M110")) != NULL;
   \   0000005A   0x4967             LDR.N    R1,??get_serial_commands_0+0x10
   \   0000005C   0x4638             MOV      R0,R7
   \   0000005E   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD002             BEQ.N    ??get_serial_commands_8
   \   00000066   0xF04F 0x0801      MOV      R8,#+1
   \   0000006A   0xE001             B.N      ??get_serial_commands_9
   \                     ??get_serial_commands_8: (+1)
   \   0000006C   0xF04F 0x0800      MOV      R8,#+0
   1205          
   1206                  if (M110) {
   \                     ??get_serial_commands_9: (+1)
   \   00000070   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000074   0xD006             BEQ.N    ??get_serial_commands_10
   1207                    char* n2pos = strchr(command + 4, 'N');
   \   00000076   0x214E             MOVS     R1,#+78
   \   00000078   0x1D38             ADDS     R0,R7,#+4
   \   0000007A   0x.... 0x....      BL       _Z6strchrPci
   1208                    if (n2pos) npos = n2pos;
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD000             BEQ.N    ??get_serial_commands_10
   \   00000082   0x4681             MOV      R9,R0
   1209                  }
   1210          
   1211                  gcode_N = strtol(npos + 1, NULL, 10);
   \                     ??get_serial_commands_10: (+1)
   \   00000084   0x220A             MOVS     R2,#+10
   \   00000086   0x2100             MOVS     R1,#+0
   \   00000088   0xF109 0x0001      ADD      R0,R9,#+1
   \   0000008C   0x.... 0x....      BL       strtol
   \   00000090   0x62A8             STR      R0,[R5, #+40]
   1212          
   1213                  if (gcode_N != gcode_LastN + 1 && !M110) {
   \   00000092   0x6AE9             LDR      R1,[R5, #+44]
   \   00000094   0x1C49             ADDS     R1,R1,#+1
   \   00000096   0x4288             CMP      R0,R1
   \   00000098   0xD008             BEQ.N    ??get_serial_commands_11
   \   0000009A   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000009E   0xD105             BNE.N    ??get_serial_commands_11
   1214                    gcode_line_error(PSTR(MSG_ERR_LINE_NO));
   \   000000A0   0x2101             MOVS     R1,#+1
   \   000000A2   0x4856             LDR.N    R0,??get_serial_commands_0+0x14
   \   000000A4   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000A8   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1215                    return;
   1216                  }
   1217          
   1218                  char *apos = strrchr(command, '*');
   \                     ??get_serial_commands_11: (+1)
   \   000000AC   0x212A             MOVS     R1,#+42
   \   000000AE   0x4638             MOV      R0,R7
   \   000000B0   0x.... 0x....      BL       _Z7strrchrPci
   1219                  if (apos) {
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD06D             BEQ.N    ??get_serial_commands_12
   1220                    uint8_t checksum = 0, count = uint8_t(apos - command);
   \   000000B8   0xF04F 0x0800      MOV      R8,#+0
   \   000000BC   0x1BC1             SUBS     R1,R0,R7
   \   000000BE   0xE004             B.N      ??get_serial_commands_13
   1221                    while (count) checksum ^= command[--count];
   \                     ??get_serial_commands_14: (+1)
   \   000000C0   0x1E49             SUBS     R1,R1,#+1
   \   000000C2   0xB2C9             UXTB     R1,R1
   \   000000C4   0x57CA             LDRSB    R2,[R1, R7]
   \   000000C6   0xEA82 0x0808      EOR      R8,R2,R8
   \                     ??get_serial_commands_13: (+1)
   \   000000CA   0xB2C9             UXTB     R1,R1
   \   000000CC   0x2900             CMP      R1,#+0
   \   000000CE   0xD1F7             BNE.N    ??get_serial_commands_14
   1222                    if (strtol(apos + 1, NULL, 10) != checksum) {
   \   000000D0   0x220A             MOVS     R2,#+10
   \   000000D2   0x2100             MOVS     R1,#+0
   \   000000D4   0x1C40             ADDS     R0,R0,#+1
   \   000000D6   0x.... 0x....      BL       strtol
   \   000000DA   0xFA5F 0xF888      UXTB     R8,R8
   \   000000DE   0x4540             CMP      R0,R8
   \   000000E0   0xD005             BEQ.N    ??get_serial_commands_15
   1223                      gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
   \   000000E2   0x2101             MOVS     R1,#+1
   \   000000E4   0x4846             LDR.N    R0,??get_serial_commands_0+0x18
   \   000000E6   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000000EA   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1224                      return;
   1225                    }
   1226                  }
   1227                  else {
   1228                    gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
   1229                    return;
   1230                  }
   1231          
   1232                  gcode_LastN = gcode_N;
   \                     ??get_serial_commands_15: (+1)
   \   000000EE   0x6AA8             LDR      R0,[R5, #+40]
   \   000000F0   0x62E8             STR      R0,[R5, #+44]
   1233                }
   1234          
   1235                // Movement commands alert when stopped
   1236                if (IsStopped()) {
   \                     ??get_serial_commands_7: (+1)
   \   000000F2   0x.... 0x....      BL       _Z9IsStoppedv
   \   000000F6   0x2800             CMP      R0,#+0
   \   000000F8   0xD013             BEQ.N    ??get_serial_commands_16
   1237                  char* gpos = strchr(command, 'G');
   \   000000FA   0x2147             MOVS     R1,#+71
   \   000000FC   0x4638             MOV      R0,R7
   \   000000FE   0x.... 0x....      BL       _Z6strchrPci
   1238                  if (gpos) {
   \   00000102   0x2800             CMP      R0,#+0
   \   00000104   0xD00D             BEQ.N    ??get_serial_commands_16
   1239                    const int codenum = strtol(gpos + 1, NULL, 10);
   1240                    switch (codenum) {
   \   00000106   0x220A             MOVS     R2,#+10
   \   00000108   0x2100             MOVS     R1,#+0
   \   0000010A   0x1C40             ADDS     R0,R0,#+1
   \   0000010C   0x.... 0x....      BL       strtol
   \   00000110   0x2803             CMP      R0,#+3
   \   00000112   0xD806             BHI.N    ??get_serial_commands_16
   1241                      case 0:
   1242                      case 1:
   1243                      case 2:
   1244                      case 3:
   1245                        SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   00000114   0x483B             LDR.N    R0,??get_serial_commands_0+0x1C
   \   00000116   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1246                        LCD_MESSAGEPGM(MSG_STOPPED);
   \   0000011A   0x2100             MOVS     R1,#+0
   \   0000011C   0x483A             LDR.N    R0,??get_serial_commands_0+0x20
   \   0000011E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   1247                        break;
   1248                    }
   1249                  }
   1250                }
   1251          
   1252                #if DISABLED(EMERGENCY_PARSER)
   1253                  // If command was e-stop process now
   1254                  if (strcmp(command, "M108") == 0) {
   \                     ??get_serial_commands_16: (+1)
   \   00000122   0x493A             LDR.N    R1,??get_serial_commands_0+0x24
   \   00000124   0x4638             MOV      R0,R7
   \   00000126   0x.... 0x....      BL       strcmp
   \   0000012A   0x2800             CMP      R0,#+0
   \   0000012C   0xD101             BNE.N    ??get_serial_commands_17
   1255                    wait_for_heatup = false;
   \   0000012E   0x2000             MOVS     R0,#+0
   \   00000130   0x7120             STRB     R0,[R4, #+4]
   1256                    #if ENABLED(ULTIPANEL)
   1257                      wait_for_user = false;
   1258                    #endif
   1259                  }
   1260                  if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_serial_commands_17: (+1)
   \   00000132   0x4937             LDR.N    R1,??get_serial_commands_0+0x28
   \   00000134   0x4638             MOV      R0,R7
   \   00000136   0x.... 0x....      BL       strcmp
   \   0000013A   0x2800             CMP      R0,#+0
   \   0000013C   0xD102             BNE.N    ??get_serial_commands_18
   \   0000013E   0x4835             LDR.N    R0,??get_serial_commands_0+0x2C
   \   00000140   0x.... 0x....      BL       _Z4killPKc
   1261                  if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_serial_commands_18: (+1)
   \   00000144   0x4934             LDR.N    R1,??get_serial_commands_0+0x30
   \   00000146   0x4638             MOV      R0,R7
   \   00000148   0x.... 0x....      BL       strcmp
   \   0000014C   0x2800             CMP      R0,#+0
   \   0000014E   0xD101             BNE.N    ??get_serial_commands_19
   \   00000150   0x.... 0x....      BL       _Z17quickstop_stepperv
   1262                #endif
   1263          
   1264                #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1265                  last_command_time = ms;
   1266                #endif
   1267          
   1268                // Add the command to the queue
   1269                _enqueuecommand(serial_line_buffer, true);
   \                     ??get_serial_commands_19: (+1)
   \   00000154   0x2101             MOVS     R1,#+1
   \   00000156   0x4630             MOV      R0,R6
   \   00000158   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_serial_commands_1: (+1)
   \   0000015C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000015E   0x2804             CMP      R0,#+4
   \   00000160   0xDA3F             BGE.N    ??get_serial_commands_20
   \   00000162   0x4E22             LDR.N    R6,??get_serial_commands_0+0x4
   \   00000164   0x4630             MOV      R0,R6
   \   00000166   0x.... 0x....      BL       _ZN10USARTClass4readEv
   \   0000016A   0x2800             CMP      R0,#+0
   \   0000016C   0xD439             BMI.N    ??get_serial_commands_20
   \   0000016E   0xB240             SXTB     R0,R0
   \   00000170   0x4D20             LDR.N    R5,??get_serial_commands_0+0xC
   \   00000172   0x2100             MOVS     R1,#+0
   \   00000174   0x8129             STRH     R1,[R5, #+8]
   \   00000176   0x280A             CMP      R0,#+10
   \   00000178   0xD001             BEQ.N    ??get_serial_commands_21
   \   0000017A   0x280D             CMP      R0,#+13
   \   0000017C   0xD110             BNE.N    ??get_serial_commands_22
   \                     ??get_serial_commands_21: (+1)
   \   0000017E   0x4608             MOV      R0,R1
   \   00000180   0x4926             LDR.N    R1,??get_serial_commands_0+0x34
   \   00000182   0x7008             STRB     R0,[R1, #+0]
   \   00000184   0x6B69             LDR      R1,[R5, #+52]
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD0E8             BEQ.N    ??get_serial_commands_1
   \   0000018A   0x4E25             LDR.N    R6,??get_serial_commands_0+0x38
   \   0000018C   0x5588             STRB     R0,[R1, R6]
   \   0000018E   0x6368             STR      R0,[R5, #+52]
   \   00000190   0x4637             MOV      R7,R6
   \   00000192   0xE755             B.N      ??get_serial_commands_4
   \                     ??get_serial_commands_12: (+1)
   \   00000194   0x2101             MOVS     R1,#+1
   \   00000196   0x4823             LDR.N    R0,??get_serial_commands_0+0x3C
   \   00000198   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   0000019C   0x.... 0x....      B.W      _Z16gcode_line_errorPKcb
   1270              }
   1271              else if (serial_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_serial_commands_22: (+1)
   \   000001A0   0x6B69             LDR      R1,[R5, #+52]
   \   000001A2   0x295F             CMP      R1,#+95
   \   000001A4   0xDADA             BGE.N    ??get_serial_commands_1
   1272                // Keep fetching, but ignore normal characters beyond the max length
   1273                // The command will be injected when EOL is reached
   1274              }
   1275              else if (serial_char == '\\') {  // Handle escapes
   \   000001A6   0x285C             CMP      R0,#+92
   \   000001A8   0xD10E             BNE.N    ??get_serial_commands_23
   1276                if ((c = MYSERIAL.read()) >= 0) {
   \   000001AA   0x4630             MOV      R0,R6
   \   000001AC   0x.... 0x....      BL       _ZN10USARTClass4readEv
   \   000001B0   0x2800             CMP      R0,#+0
   \   000001B2   0xD4D3             BMI.N    ??get_serial_commands_1
   1277                  // if we have one more character, copy it over
   1278                  serial_char = c;
   1279                  if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \   000001B4   0x4919             LDR.N    R1,??get_serial_commands_0+0x34
   \   000001B6   0x7809             LDRB     R1,[R1, #+0]
   \   000001B8   0x2900             CMP      R1,#+0
   \   000001BA   0xD1CF             BNE.N    ??get_serial_commands_1
   \   000001BC   0x6B69             LDR      R1,[R5, #+52]
   \   000001BE   0x4A18             LDR.N    R2,??get_serial_commands_0+0x38
   \   000001C0   0x5488             STRB     R0,[R1, R2]
   \   000001C2   0x1C48             ADDS     R0,R1,#+1
   \   000001C4   0x6368             STR      R0,[R5, #+52]
   \   000001C6   0xE7C9             B.N      ??get_serial_commands_1
   1280                }
   1281                // otherwise do nothing
   1282              }
   1283              else { // it's not a newline, carriage return or escape char
   1284                if (serial_char == ';') serial_comment_mode = true;
   \                     ??get_serial_commands_23: (+1)
   \   000001C8   0x4A14             LDR.N    R2,??get_serial_commands_0+0x34
   \   000001CA   0x283B             CMP      R0,#+59
   \   000001CC   0xD101             BNE.N    ??get_serial_commands_24
   \   000001CE   0x2301             MOVS     R3,#+1
   \   000001D0   0x7013             STRB     R3,[R2, #+0]
   1285                if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   \                     ??get_serial_commands_24: (+1)
   \   000001D2   0x7812             LDRB     R2,[R2, #+0]
   \   000001D4   0x2A00             CMP      R2,#+0
   \   000001D6   0xD1C1             BNE.N    ??get_serial_commands_1
   \   000001D8   0x4A11             LDR.N    R2,??get_serial_commands_0+0x38
   \   000001DA   0x5488             STRB     R0,[R1, R2]
   \   000001DC   0x1C48             ADDS     R0,R1,#+1
   \   000001DE   0x6368             STR      R0,[R5, #+52]
   \   000001E0   0xE7BC             B.N      ??get_serial_commands_1
   1286              }
   1287          
   1288            } // queue has space, serial has data
   1289          }
   \                     ??get_serial_commands_20: (+1)
   \   000001E2   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \   000001E6   0xBF00             Nop      
   \                     ??get_serial_commands_0:
   \   000001E8   0x........         DC32     mks_heating_busy
   \   000001EC   0x........         DC32     Serial3
   \   000001F0   0x........         DC32     _ZZ19get_serial_commandsvE14last_wait_time
   \   000001F4   0x........         DC32     axis_relative_modes
   \   000001F8   0x........         DC32     _ZZ19get_serial_commandsvEs
   \   000001FC   0x........         DC32     _ZZ19get_serial_commandsvEs_0
   \   00000200   0x........         DC32     _ZZ19get_serial_commandsvEs_1
   \   00000204   0x........         DC32     _ZZ19get_serial_commandsvEs_3
   \   00000208   0x........         DC32     _ZZ19get_serial_commandsvEs_4
   \   0000020C   0x........         DC32     _ZZ19get_serial_commandsvEs_5
   \   00000210   0x........         DC32     _ZZ19get_serial_commandsvEs_6
   \   00000214   0x........         DC32     _ZZ19get_serial_commandsvEs_7
   \   00000218   0x........         DC32     _ZZ19get_serial_commandsvEs_8
   \   0000021C   0x........         DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
   \   00000220   0x........         DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
   \   00000224   0x........         DC32     _ZZ19get_serial_commandsvEs_2
   1290          
   1291          #if ENABLED(SDSUPPORT)
   1292          
   1293          uint8_t sd_read_error_flg=0;
   1294          uint8_t sd_read_cnt=0;
   1295          

   \                                 In section .text, align 2, keep-with-next
   1296          void display_sd_error()
   1297          {
   \                     _Z16display_sd_errorv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   1298            char buf_sd_err[30]={0};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
   1299            
   1300            if(sd_read_error_flg == 1)
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable137_2
   \   00000010   0x7A60             LDRB     R0,[R4, #+9]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD119             BNE.N    ??display_sd_error_0
   1301            {
   1302                GUI_SetBkColor(gCfgItems.background_color);
   \   00000016   0x.... 0x....      LDR.W    R5,??DataTable139_1
   \   0000001A   0x6868             LDR      R0,[R5, #+4]
   \   0000001C   0x.... 0x....      BL       GUI_SetBkColor
   1303                GUI_SetColor(0X0000ff);//   oìé?×?ì?
   \   00000020   0x20FF             MOVS     R0,#+255
   \   00000022   0x.... 0x....      BL       GUI_SetColor
   1304                //memset(buf_sd_err,' ',sizeof(buf_sd_err)-1);
   1305                //GUI_DispStringAt(buf_sd_err,250, TITLE_YPOS);
   1306                sprintf(buf_sd_err,"sd:%d",sd_read_cnt);
   \   00000026   0x7AA2             LDRB     R2,[R4, #+10]
   \   00000028   0x.... 0x....      ADR.W    R1,`?<Constant "sd:%d">`
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       sprintf
   1307                GUI_DispStringAt(buf_sd_err,400, TITLE_YPOS);
   \   00000032   0x2205             MOVS     R2,#+5
   \   00000034   0xF44F 0x71C8      MOV      R1,#+400
   \   00000038   0xA800             ADD      R0,SP,#+0
   \   0000003A   0x.... 0x....      BL       GUI_DispStringAt
   1308                GUI_SetBkColor(gCfgItems.background_color);
   \   0000003E   0x6868             LDR      R0,[R5, #+4]
   \   00000040   0x.... 0x....      BL       GUI_SetBkColor
   1309                GUI_SetColor(gCfgItems.title_color);            
   \   00000044   0x68A8             LDR      R0,[R5, #+8]
   \   00000046   0x.... 0x....      BL       GUI_SetColor
   1310            }
   1311          }
   \                     ??display_sd_error_0: (+1)
   \   0000004A   0xB009             ADD      SP,SP,#+36
   \   0000004C   0xBD30             POP      {R4,R5,PC}       ;; return
   1312          
   1313          
   1314            /**
   1315             * Get commands from the SD Card until the command buffer is full
   1316             * or until the end of the file is reached. The special character '#'
   1317             * can also interrupt buffering.
   1318             */

   \                                 In section .text, align 4
   1319            inline void get_sdcard_commands() {
   \                     _Z19get_sdcard_commandsv: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   1320              static bool stop_buffering = false,
   1321                          sd_comment_mode = false;
   1322          
   1323              if (!card.sdprinting) return;
   \   00000004   0x4C72             LDR.N    R4,??get_sdcard_commands_0
   \   00000006   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xF000 0x80DD      BEQ.W    ??get_sdcard_commands_1
   1324          
   1325              /**
   1326               * '#' stops reading from SD to the buffer prematurely, so procedural
   1327               * macro calls are possible. If it occurs, stop_buffering is triggered
   1328               * and the buffer is run dry; this character _can_ occur in serial com
   1329               * due to checksums, however, no checksums are used in SD printing.
   1330               */
   1331          
   1332              if (commands_in_queue == 0) stop_buffering = false;
   \   00000010   0x4D70             LDR.N    R5,??get_sdcard_commands_0+0x4
   \   00000012   0x78A8             LDRB     R0,[R5, #+2]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD102             BNE.N    ??get_sdcard_commands_2
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x496F             LDR.N    R1,??get_sdcard_commands_0+0x8
   \   0000001C   0x7008             STRB     R0,[R1, #+0]
   1333          
   1334              uint16_t sd_count = 0;
   \                     ??get_sdcard_commands_2: (+1)
   \   0000001E   0x2600             MOVS     R6,#+0
   1335              bool card_eof = card.eof();
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   00000026   0x4681             MOV      R9,R0
   \   00000028   0x4F6B             LDR.N    R7,??get_sdcard_commands_0+0x8
   \   0000002A   0xE05C             B.N      ??get_sdcard_commands_3
   1336              while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
   1337                const int16_t n = card.get();
   1338                char sd_char = (char)n;
   1339                card_eof = card.eof();
   1340                if (card_eof || n == -1
   1341                    || sd_char == '\n' || sd_char == '\r'
   1342                    || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
   1343                ) {
   1344                  if (card_eof) {
   1345                    gCfgItems.breakpoint_reprint_flg = 0;
   1346                    gCfgItems.breakpoint_z_pos = 0;
   1347                    gCfgItems.breakpoint_flg=0;
   1348          
   1349                    card.printingHasFinished();
   1350          
   1351                    if (card.sdprinting)
   1352                      sd_count = 0; // If a sub-file was printing, continue from call point
   1353                    else {
   1354                      SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
   1355                      #if ENABLED(PRINTER_EVENT_LEDS)
   1356                        LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
   1357                        leds.set_green();
   1358                        #if HAS_RESUME_CONTINUE
   1359                          enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
   1360                        #else
   1361                          safe_delay(1000);
   1362                        #endif
   1363                        leds.set_off();
   1364                      #endif
   1365                      card.checkautostart(true);
   1366          			
   1367          			#if 1
   1368          			
   1369          			
   1370          			//′òíê1??ú?￡
   1371          			//if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
   1372          			//    Close_machine_display();
   1373          
   1374                      #endif 				
   1375                    }
   1376                  }
   1377                  else if (n == -1) {
   \                     ??get_sdcard_commands_4: (+1)
   \   0000002C   0xF11A 0x0F01      CMN      R10,#+1
   \   00000030   0xD141             BNE.N    ??get_sdcard_commands_5
   1378                    SERIAL_ERROR_START();
   \   00000032   0x486A             LDR.N    R0,??get_sdcard_commands_0+0xC
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1379                    SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
   \   00000038   0x4869             LDR.N    R0,??get_sdcard_commands_0+0x10
   \   0000003A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1380                    //sd_count++;
   1381                    //card.cardOK=false;
   1382                    //commands_in_queue+=1;
   1383                    //sdpos_bak=card.sdpos;
   1384                    //card.sdprinting=false;
   1385                    SD_Init();
   \   0000003E   0x.... 0x....      BL       SD_Init
   1386                    card.initsd();
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader6initsdEv
   1387                    if(card.reopenfile(curFileName))
   \   00000048   0x4966             LDR.N    R1,??get_sdcard_commands_0+0x14
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _ZN10CardReader10reopenfileEPc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD004             BEQ.N    ??get_sdcard_commands_6
   1388                    {
   1389                      card.setIndex(card.sdpos);
   \   00000054   0xF8D4 0x1460      LDR      R1,[R4, #+1120]
   \   00000058   0x4620             MOV      R0,R4
   \   0000005A   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   1390                    }
   1391                    memset(command_queue[cmd_queue_index_w],0,sizeof(command_queue[cmd_queue_index_w]));
   \                     ??get_sdcard_commands_6: (+1)
   \   0000005E   0xF8DF 0xA188      LDR.W    R10,??get_sdcard_commands_0+0x18
   \   00000062   0x2260             MOVS     R2,#+96
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xF89A 0x0008      LDRB     R0,[R10, #+8]
   \   0000006A   0xEB00 0x0340      ADD      R3,R0,R0, LSL #+1
   \   0000006E   0x485F             LDR.N    R0,??get_sdcard_commands_0+0x1C
   \   00000070   0xEB00 0x1043      ADD      R0,R0,R3, LSL #+5
   \   00000074   0x.... 0x....      BL       memset
   1392                    //GUI_TOUCH_Exec(); 	  
   1393                    //GUI_Exec();
   1394                   #if 1
   1395          	  thermalManager.manage_heater();
   \   00000078   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   1396          	  
   1397          	  display_temper_error();
   \   0000007C   0x.... 0x....      BL       _Z20display_temper_errorv
   1398          	  
   1399          	  //wifi_looping();
   1400          	  
   1401          	  if(wifi_link_state != WIFI_TRANS_FILE)
   \   00000080   0x485B             LDR.N    R0,??get_sdcard_commands_0+0x20
   \   00000082   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000086   0x2810             CMP      R0,#+16
   \   00000088   0xD001             BEQ.N    ??get_sdcard_commands_7
   1402          	  {
   1403          		  GUI_RefreshPage();
   \   0000008A   0x.... 0x....      BL       GUI_RefreshPage
   1404          	  }
   1405          	  #if defined(TFT70)
   1406          	  disp_pre_gcode(3,40);
   1407          	  #elif defined(TFT35)
   1408          	  //#if defined(MKS_ROBIN2)
   1409          	  if(preview_no_display != 1)
   \                     ??get_sdcard_commands_7: (+1)
   \   0000008E   0xF89A 0x0005      LDRB     R0,[R10, #+5]
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD003             BEQ.N    ??get_sdcard_commands_8
   1410          	  {
   1411          		  disp_pre_gcode(2,36);
   \   00000096   0x2124             MOVS     R1,#+36
   \   00000098   0x2002             MOVS     R0,#+2
   \   0000009A   0x.... 0x....      BL       disp_pre_gcode
   1412          	  }
   1413          	  //#endif
   1414          	  #endif
   1415          	  
   1416          	  GUI_TOUCH_Exec(); 	  
   \                     ??get_sdcard_commands_8: (+1)
   \   0000009E   0x.... 0x....      BL       GUI_TOUCH_Exec
   1417          	  GUI_Exec(); 
   \   000000A2   0x.... 0x....      BL       GUI_Exec
   1418          
   1419          	#endif
   1420          
   1421                    sd_read_error_flg=1;
   \   000000A6   0x2001             MOVS     R0,#+1
   \   000000A8   0xF88A 0x0009      STRB     R0,[R10, #+9]
   1422                    sd_read_cnt++;
   \   000000AC   0xF89A 0x000A      LDRB     R0,[R10, #+10]
   \   000000B0   0x1C40             ADDS     R0,R0,#+1
   \   000000B2   0xF88A 0x000A      STRB     R0,[R10, #+10]
   1423                  }
   1424                  if (sd_char == '#') stop_buffering = true;
   \                     ??get_sdcard_commands_5: (+1)
   \   000000B6   0xF1B8 0x0F23      CMP      R8,#+35
   \   000000BA   0xD101             BNE.N    ??get_sdcard_commands_9
   \   000000BC   0x2001             MOVS     R0,#+1
   \   000000BE   0x7038             STRB     R0,[R7, #+0]
   1425          
   1426                  sd_comment_mode = false; // for new command
   \                     ??get_sdcard_commands_9: (+1)
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x494C             LDR.N    R1,??get_sdcard_commands_0+0x24
   \   000000C4   0x7008             STRB     R0,[R1, #+0]
   1427          
   1428                  if (!sd_count) continue; // skip empty lines (and comment lines)
   \   000000C6   0xB2B6             UXTH     R6,R6
   \   000000C8   0x2E00             CMP      R6,#+0
   \   000000CA   0xD00C             BEQ.N    ??get_sdcard_commands_3
   1429          
   1430                  command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
   \   000000CC   0x4846             LDR.N    R0,??get_sdcard_commands_0+0x18
   \   000000CE   0x7A00             LDRB     R0,[R0, #+8]
   \   000000D0   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   000000D4   0x4845             LDR.N    R0,??get_sdcard_commands_0+0x1C
   \   000000D6   0xEB00 0x1041      ADD      R0,R0,R1, LSL #+5
   \   000000DA   0x2100             MOVS     R1,#+0
   \   000000DC   0x5431             STRB     R1,[R6, R0]
   1431                  sd_count = 0; // clear sd line buffer
   \   000000DE   0x460E             MOV      R6,R1
   1432          
   1433                  _commit_command(false);
   \   000000E0   0x4608             MOV      R0,R1
   \   000000E2   0x.... 0x....      BL       _Z15_commit_commandb
   \                     ??get_sdcard_commands_3: (+1)
   \   000000E6   0x78A8             LDRB     R0,[R5, #+2]
   \   000000E8   0x2804             CMP      R0,#+4
   \   000000EA   0xDA6E             BGE.N    ??get_sdcard_commands_1
   \   000000EC   0x7838             LDRB     R0,[R7, #+0]
   \   000000EE   0xEA50 0x0009      ORRS     R0,R0,R9
   \   000000F2   0xD16A             BNE.N    ??get_sdcard_commands_1
   \   000000F4   0x4620             MOV      R0,R4
   \   000000F6   0x.... 0x....      BL       _ZN10CardReader3getEv
   \   000000FA   0x4682             MOV      R10,R0
   \   000000FC   0x46D0             MOV      R8,R10
   \   000000FE   0xFA4F 0xF888      SXTB     R8,R8
   \   00000102   0x4620             MOV      R0,R4
   \   00000104   0x.... 0x....      BL       _ZN10CardReader3eofEv
   \   00000108   0x4681             MOV      R9,R0
   \   0000010A   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000010E   0xD112             BNE.N    ??get_sdcard_commands_10
   \   00000110   0xF11A 0x0F01      CMN      R10,#+1
   \   00000114   0xD00F             BEQ.N    ??get_sdcard_commands_10
   \   00000116   0xF1B8 0x0F0A      CMP      R8,#+10
   \   0000011A   0xD00C             BEQ.N    ??get_sdcard_commands_10
   \   0000011C   0xF1B8 0x0F0D      CMP      R8,#+13
   \   00000120   0xD009             BEQ.N    ??get_sdcard_commands_10
   \   00000122   0xF1B8 0x0F23      CMP      R8,#+35
   \   00000126   0xD002             BEQ.N    ??get_sdcard_commands_11
   \   00000128   0xF1B8 0x0F3A      CMP      R8,#+58
   \   0000012C   0xD120             BNE.N    ??get_sdcard_commands_12
   \                     ??get_sdcard_commands_11: (+1)
   \   0000012E   0x4831             LDR.N    R0,??get_sdcard_commands_0+0x24
   \   00000130   0x7800             LDRB     R0,[R0, #+0]
   \   00000132   0x2800             CMP      R0,#+0
   \   00000134   0xD11C             BNE.N    ??get_sdcard_commands_12
   \                     ??get_sdcard_commands_10: (+1)
   \   00000136   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000013A   0xF43F 0xAF77      BEQ.W    ??get_sdcard_commands_4
   \   0000013E   0x482E             LDR.N    R0,??get_sdcard_commands_0+0x28
   \   00000140   0x2100             MOVS     R1,#+0
   \   00000142   0xF880 0x1148      STRB     R1,[R0, #+328]
   \   00000146   0xF8C0 0x1298      STR      R1,[R0, #+664]
   \   0000014A   0xF880 0x1155      STRB     R1,[R0, #+341]
   \   0000014E   0x4620             MOV      R0,R4
   \   00000150   0x.... 0x....      BL       _ZN10CardReader19printingHasFinishedEv
   \   00000154   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD001             BEQ.N    ??get_sdcard_commands_13
   \   0000015C   0x2600             MOVS     R6,#+0
   \   0000015E   0xE7AA             B.N      ??get_sdcard_commands_5
   \                     ??get_sdcard_commands_13: (+1)
   \   00000160   0x4826             LDR.N    R0,??get_sdcard_commands_0+0x2C
   \   00000162   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000166   0x2101             MOVS     R1,#+1
   \   00000168   0x4620             MOV      R0,R4
   \   0000016A   0x.... 0x....      BL       _ZN10CardReader14checkautostartEb
   \   0000016E   0xE7A2             B.N      ??get_sdcard_commands_5
   1434                }
   1435                else if (sd_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_sdcard_commands_12: (+1)
   \   00000170   0xB2B6             UXTH     R6,R6
   \   00000172   0x4630             MOV      R0,R6
   \   00000174   0x285F             CMP      R0,#+95
   \   00000176   0xDAB6             BGE.N    ??get_sdcard_commands_3
   1436                  /**
   1437                   * Keep fetching, but ignore normal characters beyond the max length
   1438                   * The command will be injected when EOL is reached
   1439                   */
   1440                }
   1441                else {
   1442                  if (sd_char == ';') sd_comment_mode = true;
   \   00000178   0x491E             LDR.N    R1,??get_sdcard_commands_0+0x24
   \   0000017A   0xF1B8 0x0F3B      CMP      R8,#+59
   \   0000017E   0xD101             BNE.N    ??get_sdcard_commands_14
   \   00000180   0x2201             MOVS     R2,#+1
   \   00000182   0x700A             STRB     R2,[R1, #+0]
   1443                  //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   1444                  if (!sd_comment_mode) 
   \                     ??get_sdcard_commands_14: (+1)
   \   00000184   0x7809             LDRB     R1,[R1, #+0]
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD1AD             BNE.N    ??get_sdcard_commands_3
   1445                  {
   1446          			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
   \   0000018A   0x4917             LDR.N    R1,??get_sdcard_commands_0+0x18
   \   0000018C   0x7A09             LDRB     R1,[R1, #+8]
   \   0000018E   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000192   0x4916             LDR.N    R1,??get_sdcard_commands_0+0x1C
   \   00000194   0xEB01 0x1142      ADD      R1,R1,R2, LSL #+5
   \   00000198   0xF800 0x8001      STRB     R8,[R0, R1]
   \   0000019C   0x1C76             ADDS     R6,R6,#+1
   1447          			if(sd_char == 0x5a ) //"Z"
   \   0000019E   0xF1B8 0x0F5A      CMP      R8,#+90
   \   000001A2   0xD1A0             BNE.N    ??get_sdcard_commands_3
   1448          			{
   1449          				mksReprint.sdpos = card.getsdpos()-3;	//"・?2?????"
   \   000001A4   0x4620             MOV      R0,R4
   \   000001A6   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   000001AA   0x1EC0             SUBS     R0,R0,#+3
   \   000001AC   0xF8C4 0x0AA4      STR      R0,[R4, #+2724]
   1450          				#if 1
   1451          				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bakμ?èY??μ?￡????′ê1ó?
   \   000001B0   0xF604 0x20A4      ADDW     R0,R4,#+2724
   \   000001B4   0xF8D4 0x1AA4      LDR      R1,[R4, #+2724]
   \   000001B8   0x6041             STR      R1,[R0, #+4]
   1452          				if(gCfgItems.pwroff_save_mode != 1)//sd?¨±￡′???μ?êy?Y
   \   000001BA   0x490F             LDR.N    R1,??get_sdcard_commands_0+0x28
   \   000001BC   0xF891 0x119F      LDRB     R1,[R1, #+415]
   \   000001C0   0x2901             CMP      R1,#+1
   \   000001C2   0xD090             BEQ.N    ??get_sdcard_commands_3
   1453                          #endif
   1454          					mksReprint.refresh = true;
   \   000001C4   0x2101             MOVS     R1,#+1
   \   000001C6   0x7401             STRB     R1,[R0, #+16]
   \   000001C8   0xE78D             B.N      ??get_sdcard_commands_3
   1455          			}
   1456                  }        
   1457                }
   1458              }
   1459            }
   \                     ??get_sdcard_commands_1: (+1)
   \   000001CA   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
   \   000001CE   0xBF00             Nop      
   \                     ??get_sdcard_commands_0:
   \   000001D0   0x........         DC32     card
   \   000001D4   0x........         DC32     mks_heating_busy
   \   000001D8   0x........         DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
   \   000001DC   0x........         DC32     errormagic
   \   000001E0   0x........         DC32     _ZZ19get_sdcard_commandsvEs_0
   \   000001E4   0x........         DC32     curFileName
   \   000001E8   0x........         DC32     filament_loading_time_flg
   \   000001EC   0x........         DC32     command_queue
   \   000001F0   0x........         DC32     wifi_link_state
   \   000001F4   0x........         DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
   \   000001F8   0x........         DC32     gCfgItems
   \   000001FC   0x........         DC32     _ZZ19get_sdcard_commandsvEs
   1460          
   1461          #endif // SDSUPPORT
   1462          #if 1

   \                                 In section .text, align 4
   1463          inline void get_wifi_commands() {
   \                     _Z17get_wifi_commandsv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   1464            static char wifi_line_buffer[MAX_CMD_SIZE];
   1465            static bool wifi_comment_mode = false;
   1466          
   1467            if(serial_wait_tick > 5)
   \   00000002   0x4C3B             LDR.N    R4,??get_wifi_commands_0
   \   00000004   0x7A20             LDRB     R0,[R4, #+8]
   \   00000006   0x2806             CMP      R0,#+6
   \   00000008   0xDB6E             BLT.N    ??get_wifi_commands_1
   1468            {
   1469            	from_wifi_flag = 1;
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7260             STRB     R0,[R4, #+9]
   \   0000000E   0x4D39             LDR.N    R5,??get_wifi_commands_0+0x4
   \   00000010   0xE039             B.N      ??get_wifi_commands_2
   1470          
   1471          /**
   1472          	   * Loop while serial characters are incoming and the queue is not full
   1473          	   */
   1474          	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
   1475          
   1476          	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
   1477          
   1478          	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
   1479          
   1480          	    /**
   1481          	     * If the character ends the line
   1482          	     */
   1483          	    if (wifi_char == '\n' || wifi_char == '\r') {
   1484          
   1485          	      wifi_comment_mode = false; // end of line == end of comment
   1486          
   1487          	      if (!wifi_read_count) continue; // skip empty lines
   1488          
   1489          	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
   1490          	      wifi_read_count = 0; //reset buffer
   1491          
   1492          	      char* command = wifi_line_buffer;
   1493          
   1494          	      while (*command == ' ') command++; // skip any leading spaces	    
   \                     ??get_wifi_commands_3: (+1)
   \   00000012   0x1C7F             ADDS     R7,R7,#+1
   \                     ??get_wifi_commands_4: (+1)
   \   00000014   0xF997 0x0000      LDRSB    R0,[R7, #+0]
   \   00000018   0x2820             CMP      R0,#+32
   \   0000001A   0xD0FA             BEQ.N    ??get_wifi_commands_3
   1495          
   1496          	      // Movement commands alert when stopped
   1497          	      if (IsStopped()) {
   \   0000001C   0x.... 0x....      BL       _Z9IsStoppedv
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD013             BEQ.N    ??get_wifi_commands_5
   1498          	        char* gpos = strchr(command, 'G');
   \   00000024   0x2147             MOVS     R1,#+71
   \   00000026   0x4638             MOV      R0,R7
   \   00000028   0x.... 0x....      BL       _Z6strchrPci
   1499          	        if (gpos) {
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00D             BEQ.N    ??get_wifi_commands_5
   1500          	          const int codenum = strtol(gpos + 1, NULL, 10);
   1501          	          switch (codenum) {
   \   00000030   0x220A             MOVS     R2,#+10
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x.... 0x....      BL       strtol
   \   0000003A   0x2803             CMP      R0,#+3
   \   0000003C   0xD806             BHI.N    ??get_wifi_commands_5
   1502          	            case 0:
   1503          	            case 1:
   1504          	            case 2:
   1505          	            case 3:
   1506          	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   0000003E   0x482E             LDR.N    R0,??get_wifi_commands_0+0x8
   \   00000040   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1507          	              LCD_MESSAGEPGM(MSG_STOPPED);
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x482D             LDR.N    R0,??get_wifi_commands_0+0xC
   \   00000048   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   1508          	              break;
   1509          	          }
   1510          	        }
   1511          	      }
   1512          
   1513          	      #if DISABLED(EMERGENCY_PARSER)
   1514          	        // If command was e-stop process now
   1515          	        if (strcmp(command, "M108") == 0) {
   \                     ??get_wifi_commands_5: (+1)
   \   0000004C   0x492C             LDR.N    R1,??get_wifi_commands_0+0x10
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       strcmp
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD101             BNE.N    ??get_wifi_commands_6
   1516          	          wait_for_heatup = false;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7128             STRB     R0,[R5, #+4]
   1517          	          #if ENABLED(ULTIPANEL)
   1518          	            wait_for_user = false;
   1519          	          #endif
   1520          	        }
   1521          	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
   \                     ??get_wifi_commands_6: (+1)
   \   0000005C   0x4929             LDR.N    R1,??get_wifi_commands_0+0x14
   \   0000005E   0x4638             MOV      R0,R7
   \   00000060   0x.... 0x....      BL       strcmp
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD102             BNE.N    ??get_wifi_commands_7
   \   00000068   0x4827             LDR.N    R0,??get_wifi_commands_0+0x18
   \   0000006A   0x.... 0x....      BL       _Z4killPKc
   1522          	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
   \                     ??get_wifi_commands_7: (+1)
   \   0000006E   0x4927             LDR.N    R1,??get_wifi_commands_0+0x1C
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x.... 0x....      BL       strcmp
   \   00000076   0x2800             CMP      R0,#+0
   \   00000078   0xD101             BNE.N    ??get_wifi_commands_8
   \   0000007A   0x.... 0x....      BL       _Z17quickstop_stepperv
   1523          	      #endif
   1524          
   1525          	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
   1526          	        last_command_time = ms;
   1527          	      #endif
   1528          
   1529          	      // Add the command to the queue
   1530          	      _enqueuecommand(wifi_line_buffer, true);
   \                     ??get_wifi_commands_8: (+1)
   \   0000007E   0x2101             MOVS     R1,#+1
   \   00000080   0x4630             MOV      R0,R6
   \   00000082   0x.... 0x....      BL       _Z15_enqueuecommandPKcb
   \                     ??get_wifi_commands_2: (+1)
   \   00000086   0x78A8             LDRB     R0,[R5, #+2]
   \   00000088   0x2804             CMP      R0,#+4
   \   0000008A   0xDA2F             BGE.N    ??get_wifi_commands_9
   \   0000008C   0x4920             LDR.N    R1,??get_wifi_commands_0+0x20
   \   0000008E   0x6E0A             LDR      R2,[R1, #+96]
   \   00000090   0x6E48             LDR      R0,[R1, #+100]
   \   00000092   0x4282             CMP      R2,R0
   \   00000094   0xD02A             BEQ.N    ??get_wifi_commands_9
   \   00000096   0x5650             LDRSB    R0,[R2, R1]
   \   00000098   0x1C52             ADDS     R2,R2,#+1
   \   0000009A   0x2360             MOVS     R3,#+96
   \   0000009C   0xFBB2 0xF3F3      UDIV     R3,R2,R3
   \   000000A0   0xEB03 0x0643      ADD      R6,R3,R3, LSL #+1
   \   000000A4   0xEBA2 0x1246      SUB      R2,R2,R6, LSL #+5
   \   000000A8   0x660A             STR      R2,[R1, #+96]
   \   000000AA   0x280A             CMP      R0,#+10
   \   000000AC   0xD001             BEQ.N    ??get_wifi_commands_10
   \   000000AE   0x280D             CMP      R0,#+13
   \   000000B0   0xD10A             BNE.N    ??get_wifi_commands_11
   \                     ??get_wifi_commands_10: (+1)
   \   000000B2   0x2000             MOVS     R0,#+0
   \   000000B4   0x4917             LDR.N    R1,??get_wifi_commands_0+0x24
   \   000000B6   0x7008             STRB     R0,[R1, #+0]
   \   000000B8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000BA   0x2900             CMP      R1,#+0
   \   000000BC   0xD0E3             BEQ.N    ??get_wifi_commands_2
   \   000000BE   0x4E16             LDR.N    R6,??get_wifi_commands_0+0x28
   \   000000C0   0x5588             STRB     R0,[R1, R6]
   \   000000C2   0x63A0             STR      R0,[R4, #+56]
   \   000000C4   0x4637             MOV      R7,R6
   \   000000C6   0xE7A5             B.N      ??get_wifi_commands_4
   1531          	    }
   1532          	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
   \                     ??get_wifi_commands_11: (+1)
   \   000000C8   0x6BA1             LDR      R1,[R4, #+56]
   \   000000CA   0x295F             CMP      R1,#+95
   \   000000CC   0xDADB             BGE.N    ??get_wifi_commands_2
   1533          	      // Keep fetching, but ignore normal characters beyond the max length
   1534          	      // The command will be injected when EOL is reached
   1535          	    }
   1536          		/*
   1537          	    else if (wifi_char == '\\') {  // Handle escapes
   1538          	      if (MYSERIAL.available() > 0) {
   1539          	        // if we have one more character, copy it over
   1540          	        wifi_char = MYSERIAL.read();
   1541          	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
   1542          	      }
   1543          	      // otherwise do nothing
   1544          	    }*/
   1545          	    else { // it's not a newline, carriage return or escape char
   1546          	      if (wifi_char == ';') wifi_comment_mode = true;
   \   000000CE   0x4A11             LDR.N    R2,??get_wifi_commands_0+0x24
   \   000000D0   0x283B             CMP      R0,#+59
   \   000000D2   0xD101             BNE.N    ??get_wifi_commands_12
   \   000000D4   0x2301             MOVS     R3,#+1
   \   000000D6   0x7013             STRB     R3,[R2, #+0]
   1547          	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
   \                     ??get_wifi_commands_12: (+1)
   \   000000D8   0x7812             LDRB     R2,[R2, #+0]
   \   000000DA   0x2A00             CMP      R2,#+0
   \   000000DC   0xD1D3             BNE.N    ??get_wifi_commands_2
   \   000000DE   0x4A0E             LDR.N    R2,??get_wifi_commands_0+0x28
   \   000000E0   0x5488             STRB     R0,[R1, R2]
   \   000000E2   0x1C48             ADDS     R0,R1,#+1
   \   000000E4   0x63A0             STR      R0,[R4, #+56]
   \   000000E6   0xE7CE             B.N      ??get_wifi_commands_2
   1548          	    }
   1549          
   1550          	  }
   1551              }// queue has space, serial has data
   1552              else
   1553              {
   1554              	from_wifi_flag = 0;
   \                     ??get_wifi_commands_1: (+1)
   \   000000E8   0x2000             MOVS     R0,#+0
   \   000000EA   0x7260             STRB     R0,[R4, #+9]
   1555              }
   1556          }
   \                     ??get_wifi_commands_9: (+1)
   \   000000EC   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
   \   000000EE   0xBF00             Nop      
   \                     ??get_wifi_commands_0:
   \   000000F0   0x........         DC32     axis_relative_modes
   \   000000F4   0x........         DC32     mks_heating_busy
   \   000000F8   0x........         DC32     _ZZ17get_wifi_commandsvEs
   \   000000FC   0x........         DC32     _ZZ17get_wifi_commandsvEs_0
   \   00000100   0x........         DC32     _ZZ17get_wifi_commandsvEs_1
   \   00000104   0x........         DC32     _ZZ17get_wifi_commandsvEs_2
   \   00000108   0x........         DC32     _ZZ17get_wifi_commandsvEs_3
   \   0000010C   0x........         DC32     _ZZ17get_wifi_commandsvEs_4
   \   00000110   0x........         DC32     espGcodeFifo
   \   00000114   0x........         DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
   \   00000118   0x........         DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
   1557          #endif
   1558          
   1559          /**
   1560           * Add to the circular command queue the next command from:
   1561           *  - The command-injection queue (injected_commands_P)
   1562           *  - The active serial input (usually USB)
   1563           *  - The SD card file being actively printed
   1564           */

   \                                 In section .text, align 2, keep-with-next
   1565          void get_available_commands() {
   \                     _Z22get_available_commandsv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1566          
   1567            // if any immediate commands remain, don't get other commands yet
   1568            if (drain_injected_commands_P()) return;
   \   00000002   0x.... 0x....      BL       _Z25drain_injected_commands_Pv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD107             BNE.N    ??get_available_commands_0
   1569          
   1570            get_serial_commands();
   \   0000000A   0x.... 0x....      BL       _Z19get_serial_commandsv
   1571            
   1572          #if 1
   1573          	get_wifi_commands();
   \   0000000E   0x.... 0x....      BL       _Z17get_wifi_commandsv
   1574          #endif
   1575          
   1576            #if ENABLED(SDSUPPORT)
   1577              get_sdcard_commands();
   \   00000012   0xE8BD 0x4001      POP      {R0,LR}
   \   00000016   0x.... 0x....      B.W      _Z19get_sdcard_commandsv
   \                     ??get_available_commands_0: (+1)
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
   1578            #endif
   1579          }
   1580          
   1581          /**
   1582           * Set target_extruder from the T parameter or the active_extruder
   1583           *
   1584           * Returns TRUE if the target is invalid
   1585           */

   \                                 In section .text, align 2, keep-with-next
   1586          bool get_target_extruder_from_command(const uint16_t code) {
   \                     _Z32get_target_extruder_from_commandt: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   1587            if (parser.seenval('T')) {
   \   00000004   0x2054             MOVS     R0,#+84
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD023             BEQ.N    ??get_target_extruder_from_command_0
   1588              const int8_t e = parser.value_byte();
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xB26D             SXTB     R5,R5
   1589              if (e >= EXTRUDERS) {
   \   00000016   0x2D02             CMP      R5,#+2
   \   00000018   0xDB19             BLT.N    ??get_target_extruder_from_command_1
   1590                SERIAL_ECHO_START();
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable137_3
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1591                SERIAL_CHAR('M');
   \   00000022   0x.... 0x....      LDR.W    R6,??DataTable137_4
   \   00000026   0x214D             MOVS     R1,#+77
   \   00000028   0x4630             MOV      R0,R6
   \   0000002A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1592                SERIAL_ECHO(code);
   \   0000002E   0x220A             MOVS     R2,#+10
   \   00000030   0x4621             MOV      R1,R4
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       _ZN5Print5printEii
   1593                SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
   \   00000038   0x4629             MOV      R1,R5
   \   0000003A   0x.... 0x....      ADR.W    R0,`?<Constant " Invalid extruder ">`
   \   0000003E   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0x4630             MOV      R0,R6
   \   00000046   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   1594                return true;
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0xBD70             POP      {R4-R6,PC}
   1595              }
   1596              target_extruder = e;
   \                     ??get_target_extruder_from_command_1: (+1)
   \   0000004E   0x.... 0x....      LDR.W    R0,??DataTable134_4
   \   00000052   0x7145             STRB     R5,[R0, #+5]
   \   00000054   0xE003             B.N      ??get_target_extruder_from_command_2
   1597            }
   1598            else
   1599              target_extruder = active_extruder;
   \                     ??get_target_extruder_from_command_0: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable134_4
   \   0000005A   0x78C1             LDRB     R1,[R0, #+3]
   \   0000005C   0x7141             STRB     R1,[R0, #+5]
   1600          
   1601            return false;
   \                     ??get_target_extruder_from_command_2: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return
   1602          }
   1603          
   1604          #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   1605            bool extruder_duplication_enabled = false; // Used in Dual X mode 2
   1606          #endif
   1607          
   1608          #if ENABLED(DUAL_X_CARRIAGE)
   1609          
   1610            static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
   1611          
   1612            static float x_home_pos(const int extruder) {
   1613              if (extruder == 0)
   1614                return base_home_pos(X_AXIS);
   1615              else
   1616                /**
   1617                 * In dual carriage mode the extruder offset provides an override of the
   1618                 * second X-carriage position when homed - otherwise X2_HOME_POS is used.
   1619                 * This allows soft recalibration of the second extruder home position
   1620                 * without firmware reflash (through the M218 command).
   1621                 */
   1622                return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
   1623            }
   1624          
   1625            static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
   1626          
   1627            static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
   1628            static bool active_extruder_parked = false;        // used in mode 1 & 2
   1629            static float raised_parked_position[XYZE];         // used in mode 1
   1630            static millis_t delayed_move_time = 0;             // used in mode 1
   1631            static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
   1632            static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
   1633          
   1634          #endif // DUAL_X_CARRIAGE
   1635          
   1636          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
   1637          
   1638            /**
   1639             * Software endstops can be used to monitor the open end of
   1640             * an axis that has a hardware endstop on the other end. Or
   1641             * they can prevent axes from moving past endstops and grinding.
   1642             *
   1643             * To keep doing their job as the coordinate system changes,
   1644             * the software endstop positions must be refreshed to remain
   1645             * at the same positions relative to the machine.
   1646             */

   \                                 In section .text, align 2, keep-with-next
   1647            void update_software_endstops(const AxisEnum axis) {
   \                     _Z24update_software_endstops8AxisEnum: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4606             MOV      R6,R0
   1648              #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
   1649                workspace_offset[axis] = home_offset[axis] + position_shift[axis];
   \   00000006   0x4637             MOV      R7,R6
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable134_4
   \   0000000C   0xEB04 0x0887      ADD      R8,R4,R7, LSL #+2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable137_2
   \   00000014   0xEB00 0x0087      ADD      R0,R0,R7, LSL #+2
   \   00000018   0x6B01             LDR      R1,[R0, #+48]
   \   0000001A   0xF8D8 0x0060      LDR      R0,[R8, #+96]
   \   0000001E   0x.... 0x....      BL       __aeabi_fadd
   \   00000022   0xF8C8 0x0038      STR      R0,[R8, #+56]
   1650              #endif
   1651          
   1652              #if ENABLED(DUAL_X_CARRIAGE)
   1653                if (axis == X_AXIS) {
   1654          
   1655                  // In Dual X mode hotend_offset[X] is T1's home position
   1656                  float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
   1657          
   1658                  if (active_extruder != 0) {
   1659                    // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
   1660                    soft_endstop_min[X_AXIS] = X2_MIN_POS;
   1661                    soft_endstop_max[X_AXIS] = dual_max_x;
   1662                  }
   1663                  else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
   1664                    // In Duplication Mode, T0 can move as far left as X_MIN_POS
   1665                    // but not so far to the right that T1 would move past the end
   1666                    soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
   1667                    soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
   1668                  }
   1669                  else {
   1670                    // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
   1671                    soft_endstop_min[axis] = base_min_pos(axis);
   1672                    soft_endstop_max[axis] = base_max_pos(axis);
   1673                  }
   1674                }
   1675          	#else
   1676              if (MACHINETPYE == DELTA)//ENABLED(DELTA)
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable134_9
   \   0000002A   0x.... 0x....      LDR.W    R9,??DataTable134_5
   \   0000002E   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   00000032   0x2802             CMP      R0,#+2
   \   00000034   0x4630             MOV      R0,R6
   \   00000036   0xD10E             BNE.N    ??update_software_endstops_0
   1677              {
   1678                soft_endstop_min[axis] = base_min_pos(axis);
   \   00000038   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   0000003C   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1679                soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
   \   00000040   0x2F02             CMP      R7,#+2
   \   00000042   0xD101             BNE.N    ??update_software_endstops_1
   \   00000044   0x6FA0             LDR      R0,[R4, #+120]
   \   00000046   0xE002             B.N      ??update_software_endstops_2
   \                     ??update_software_endstops_1: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \                     ??update_software_endstops_2: (+1)
   \   0000004E   0xEB05 0x0187      ADD      R1,R5,R7, LSL #+2
   \   00000052   0x6248             STR      R0,[R1, #+36]
   \   00000054   0xE009             B.N      ??update_software_endstops_3
   1680              }
   1681              else
   1682              {
   1683                soft_endstop_min[axis] = base_min_pos(axis);
   \                     ??update_software_endstops_0: (+1)
   \   00000056   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   0000005A   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1684                soft_endstop_max[axis] = base_max_pos(axis);
   \   0000005E   0x4630             MOV      R0,R6
   \   00000060   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \   00000064   0xEB05 0x0187      ADD      R1,R5,R7, LSL #+2
   \   00000068   0x6248             STR      R0,[R1, #+36]
   1685              }
   1686              #endif
   1687          
   1688              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1689                if (DEBUGGING(LEVELING)) {
   1690                  SERIAL_ECHOPAIR("For ", axis_codes[axis]);
   1691                  #if HAS_HOME_OFFSET
   1692                    SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
   1693                  #endif
   1694                  #if HAS_POSITION_SHIFT
   1695                    SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
   1696                  #endif
   1697                  SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
   1698                  SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
   1699                }
   1700              #endif
   1701          
   1702              //#if ENABLED(DELTA)
   1703              if(MACHINETPYE == DELTA)
   \                     ??update_software_endstops_3: (+1)
   \   0000006A   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD153             BNE.N    ??update_software_endstops_4
   1704              {
   1705                switch(axis) {
   \   00000072   0x2E00             CMP      R6,#+0
   \   00000074   0xD002             BEQ.N    ??update_software_endstops_5
   \   00000076   0x2E02             CMP      R6,#+2
   \   00000078   0xD048             BEQ.N    ??update_software_endstops_6
   \   0000007A   0xD24E             BCS.N    ??update_software_endstops_4
   1706                  case X_AXIS:
   1707                  case Y_AXIS:
   1708                    // Get a minimum radius for clamping
   1709                    soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
   \                     ??update_software_endstops_5: (+1)
   \   0000007C   0x6C61             LDR      R1,[R4, #+68]
   \   0000007E   0x6CA0             LDR      R0,[R4, #+72]
   \   00000080   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000084   0xD300             BCC.N    ??update_software_endstops_7
   \   00000086   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_7: (+1)
   \   00000088   0xF021 0x4000      BIC      R0,R1,#0x80000000
   \   0000008C   0x6A6A             LDR      R2,[R5, #+36]
   \   0000008E   0x4611             MOV      R1,R2
   \   00000090   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000094   0xD207             BCS.N    ??update_software_endstops_8
   \   00000096   0x6C61             LDR      R1,[R4, #+68]
   \   00000098   0x6CA0             LDR      R0,[R4, #+72]
   \   0000009A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000009E   0xD300             BCC.N    ??update_software_endstops_9
   \   000000A0   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_9: (+1)
   \   000000A2   0xF021 0x4200      BIC      R2,R1,#0x80000000
   \                     ??update_software_endstops_8: (+1)
   \   000000A6   0x6AA9             LDR      R1,[R5, #+40]
   \   000000A8   0x4610             MOV      R0,R2
   \   000000AA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000AE   0xD217             BCS.N    ??update_software_endstops_10
   \   000000B0   0x6C61             LDR      R1,[R4, #+68]
   \   000000B2   0x6CA0             LDR      R0,[R4, #+72]
   \   000000B4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B8   0xD300             BCC.N    ??update_software_endstops_11
   \   000000BA   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_11: (+1)
   \   000000BC   0xF021 0x4000      BIC      R0,R1,#0x80000000
   \   000000C0   0x6A69             LDR      R1,[R5, #+36]
   \   000000C2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000C6   0xD209             BCS.N    ??update_software_endstops_12
   \   000000C8   0x6C61             LDR      R1,[R4, #+68]
   \   000000CA   0x6CA0             LDR      R0,[R4, #+72]
   \   000000CC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D0   0xD300             BCC.N    ??update_software_endstops_13
   \   000000D2   0x4601             MOV      R1,R0
   \                     ??update_software_endstops_13: (+1)
   \   000000D4   0xF021 0x4000      BIC      R0,R1,#0x80000000
   \   000000D8   0x6568             STR      R0,[R5, #+84]
   \   000000DA   0xE002             B.N      ??update_software_endstops_14
   \                     ??update_software_endstops_12: (+1)
   \   000000DC   0x6569             STR      R1,[R5, #+84]
   \   000000DE   0xE000             B.N      ??update_software_endstops_14
   \                     ??update_software_endstops_10: (+1)
   \   000000E0   0x6569             STR      R1,[R5, #+84]
   1710                    soft_endstop_radius_2 = sq(soft_endstop_radius);
   \                     ??update_software_endstops_14: (+1)
   \   000000E2   0x6D6C             LDR      R4,[R5, #+84]
   \   000000E4   0x2602             MOVS     R6,#+2
   \   000000E6   0xF04F 0x577E      MOV      R7,#+1065353216
   \   000000EA   0xE004             B.N      ??update_software_endstops_15
   \                     ??update_software_endstops_16: (+1)
   \   000000EC   0x4620             MOV      R0,R4
   \   000000EE   0x4621             MOV      R1,R4
   \   000000F0   0x.... 0x....      BL       __aeabi_fmul
   \   000000F4   0x4604             MOV      R4,R0
   \                     ??update_software_endstops_15: (+1)
   \   000000F6   0x07F0             LSLS     R0,R6,#+31
   \   000000F8   0xD504             BPL.N    ??update_software_endstops_17
   \   000000FA   0x4638             MOV      R0,R7
   \   000000FC   0x4621             MOV      R1,R4
   \   000000FE   0x.... 0x....      BL       __aeabi_fmul
   \   00000102   0x4607             MOV      R7,R0
   \                     ??update_software_endstops_17: (+1)
   \   00000104   0x0876             LSRS     R6,R6,#+1
   \   00000106   0xD1F1             BNE.N    ??update_software_endstops_16
   \   00000108   0x65AF             STR      R7,[R5, #+88]
   1711                    break;
   \   0000010A   0xE006             B.N      ??update_software_endstops_4
   1712                  case Z_AXIS:
   1713                    delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
   \                     ??update_software_endstops_6: (+1)
   \   0000010C   0x.... 0x....      BL       _Z28delta_safe_distance_from_topv
   \   00000110   0x4601             MOV      R1,R0
   \   00000112   0x6AE8             LDR      R0,[R5, #+44]
   \   00000114   0x.... 0x....      BL       __aeabi_fsub
   \   00000118   0x67E0             STR      R0,[R4, #+124]
   1714                  default: break;
   1715                }
   1716              }
   1717              //#endif
   1718            }
   \                     ??update_software_endstops_4: (+1)
   \   0000011A   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   1719          
   1720          #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
   1721          
   1722          #if 1//HAS_M206_COMMAND
   1723            /**
   1724             * Change the home offset for an axis, update the current
   1725             * position and the software endstops to retain the same
   1726             * relative distance to the new home.
   1727             *
   1728             * Since this changes the current_position, code should
   1729             * call sync_plan_position soon after this.
   1730             */

   \                                 In section .text, align 2, keep-with-next
   1731            static void set_home_offset(const AxisEnum axis, const float v) {
   1732          
   1733            	if(MACHINETPYE == DELTA)	return;
   \                     _Z15set_home_offset8AxisEnumf: (+1)
   \   00000000   0x.... 0x....      LDR.W    R2,??DataTable134_5
   \   00000004   0xF9B2 0x2058      LDRSH    R2,[R2, #+88]
   \   00000008   0x2A02             CMP      R2,#+2
   \   0000000A   0xD005             BEQ.N    ??set_home_offset_0
   1734          	
   1735              home_offset[axis] = v;
   \   0000000C   0x.... 0x....      LDR.W    R2,??DataTable137_2
   \   00000010   0xEB02 0x0280      ADD      R2,R2,R0, LSL #+2
   \   00000014   0x6311             STR      R1,[R2, #+48]
   1736              update_software_endstops(axis);
   \   00000016   0x....             B.N      _Z24update_software_endstops8AxisEnum
   \                     ??set_home_offset_0: (+1)
   \   00000018   0x4770             BX       LR               ;; return
   1737            }
   1738          #endif // HAS_M206_COMMAND
   1739          
   1740          /**
   1741           * Set an axis' current position to its home position (after homing).
   1742           *
   1743           * For Core and Cartesian robots this applies one-to-one when an
   1744           * individual axis has been homed.
   1745           *
   1746           * DELTA should wait until all homing is done before setting the XYZ
   1747           * current_position to home, because homing is a single operation.
   1748           * In the case where the axis positions are already known and previously
   1749           * homed, DELTA could home to X or Y individually by moving either one
   1750           * to the center. However, homing Z always homes XY and Z.
   1751           *
   1752           * SCARA should wait until all XY homing is done before setting the XY
   1753           * current_position to home, because neither X nor Y is at home until
   1754           * both are at home. Z can however be homed individually.
   1755           *
   1756           * Callers must sync the planner position after calling this!
   1757           */

   \                                 In section .text, align 2, keep-with-next
   1758          static void set_axis_is_at_home(const AxisEnum axis) {
   \                     _Z19set_axis_is_at_home8AxisEnum: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4604             MOV      R4,R0
   1759            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1760              if (DEBUGGING(LEVELING)) {
   1761                SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
   1762                SERIAL_CHAR(')');
   1763                SERIAL_EOL();
   1764              }
   1765            #endif
   1766          
   1767            axis_known_position[axis] = axis_homed[axis] = true;
   \   00000008   0x4625             MOV      R5,R4
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable134_9
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x55A8             STRB     R0,[R5, R6]
   \   00000012   0x19A9             ADDS     R1,R5,R6
   \   00000014   0x7108             STRB     R0,[R1, #+4]
   1768          
   1769            #if HAS_POSITION_SHIFT
   1770              position_shift[axis] = 0;
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable134_4
   \   0000001A   0xEB07 0x0885      ADD      R8,R7,R5, LSL #+2
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0xF8C8 0x0060      STR      R0,[R8, #+96]
   1771              update_software_endstops(axis);
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   1772            #endif
   1773          
   1774            #if ENABLED(DUAL_X_CARRIAGE)
   1775              if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
   1776                current_position[X_AXIS] = x_home_pos(active_extruder);
   1777                return;
   1778              }
   1779            #endif
   1780          
   1781            //#if ENABLED(MORGAN_SCARA)
   1782            if(MACHINETPYE&MORGAN_SCARA)
   \   0000002A   0x.... 0x....      LDR.W    R9,??DataTable134_5
   \   0000002E   0xF9B9 0x0058      LDRSH    R0,[R9, #+88]
   \   00000032   0x05C1             LSLS     R1,R0,#+23
   \   00000034   0xD531             BPL.N    ??set_axis_is_at_home_0
   1783            	{
   1784              /**
   1785               * Morgan SCARA homes XY at the same time
   1786               */
   1787              if (axis == X_AXIS || axis == Y_AXIS) {
   \   00000036   0x2C00             CMP      R4,#+0
   \   00000038   0xD001             BEQ.N    ??set_axis_is_at_home_1
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD127             BNE.N    ??set_axis_is_at_home_2
   1788          
   1789                float homeposition[XYZ] = {
   \                     ??set_axis_is_at_home_1: (+1)
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0xF10D 0x0A00      ADD      R10,SP,#+0
   \   0000004A   0x2001             MOVS     R0,#+1
   \   0000004C   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000050   0xF8CA 0x0004      STR      R0,[R10, #+4]
   \   00000054   0x2002             MOVS     R0,#+2
   \   00000056   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   0000005A   0xF8CA 0x0008      STR      R0,[R10, #+8]
   1790                  base_home_pos(X_AXIS),
   1791                  base_home_pos(Y_AXIS),
   1792                  base_home_pos(Z_AXIS)
   1793                };
   1794          
   1795                // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
   1796                // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
   1797          
   1798                /**
   1799                 * Get Home position SCARA arm angles using inverse kinematics,
   1800                 * and calculate homing offset using forward kinematics
   1801                 */
   1802                inverse_kinematics_MORGAN_SCARA(homeposition);
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   1803                forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
   \   00000064   0xF107 0x0154      ADD      R1,R7,#+84
   \   00000068   0xF107 0x0050      ADD      R0,R7,#+80
   \   0000006C   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
   1804          
   1805                // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
   1806                // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
   1807          
   1808                current_position[axis] = cartes[axis];
   \   00000070   0xEB06 0x0685      ADD      R6,R6,R5, LSL #+2
   \   00000074   0x6CB0             LDR      R0,[R6, #+72]
   \   00000076   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1809          
   1810                /**
   1811                 * SCARA home positions are based on configuration since the actual
   1812                 * limits are determined by the inverse kinematic transform.
   1813                 */
   1814                soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   \   0000007A   0x4620             MOV      R0,R4
   \   0000007C   0x.... 0x....      BL       _Z12base_min_pos8AxisEnum
   \   00000080   0xF8C8 0x0044      STR      R0,[R8, #+68]
   1815                soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       _Z12base_max_pos8AxisEnum
   \   0000008A   0x6270             STR      R0,[R6, #+36]
   \   0000008C   0xE018             B.N      ??set_axis_is_at_home_3
   1816              }
   1817              else
   1818          	{
   1819          	    current_position[axis] = base_home_pos(axis);
   \                     ??set_axis_is_at_home_2: (+1)
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   00000094   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   00000098   0xE012             B.N      ??set_axis_is_at_home_3
   1820          	}		
   1821            	}
   1822            //#elif ENABLED(DELTA)
   1823            else if(MACHINETPYE&DELTA)
   \                     ??set_axis_is_at_home_0: (+1)
   \   0000009A   0x0780             LSLS     R0,R0,#+30
   \   0000009C   0xD50B             BPL.N    ??set_axis_is_at_home_4
   1824            {
   1825              if (axis == Z_AXIS)
   \   0000009E   0x2D02             CMP      R5,#+2
   \   000000A0   0xD103             BNE.N    ??set_axis_is_at_home_5
   1826                current_position[axis] = delta_height;
   \   000000A2   0x6FB8             LDR      R0,[R7, #+120]
   \   000000A4   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   000000A8   0xE00A             B.N      ??set_axis_is_at_home_3
   1827              else
   1828            //#endif
   1829            	{
   1830              	current_position[axis] = base_home_pos(axis);
   \                     ??set_axis_is_at_home_5: (+1)
   \   000000AA   0x4620             MOV      R0,R4
   \   000000AC   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   000000B0   0xF8C8 0x0008      STR      R0,[R8, #+8]
   \   000000B4   0xE004             B.N      ??set_axis_is_at_home_3
   1831            	}
   1832            }
   1833            else
   1834            {
   1835              	current_position[axis] = base_home_pos(axis);
   \                     ??set_axis_is_at_home_4: (+1)
   \   000000B6   0x4620             MOV      R0,R4
   \   000000B8   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   000000BC   0xF8C8 0x0008      STR      R0,[R8, #+8]
   1836            }    
   1837            /**
   1838             * Z Probe Z Homing? Account for the probe's Z offset.
   1839             */
   1840            #if HAS_BED_PROBE //&& Z_HOME_DIR < 0
   1841            if(Z_HOME_DIR < 0)
   \                     ??set_axis_is_at_home_3: (+1)
   \   000000C0   0xF999 0x0007      LDRSB    R0,[R9, #+7]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD512             BPL.N    ??set_axis_is_at_home_6
   1842            {
   1843              if (axis == Z_AXIS) {
   \   000000C8   0x2D02             CMP      R5,#+2
   \   000000CA   0xD110             BNE.N    ??set_axis_is_at_home_6
   1844                #if HOMING_Z_WITH_PROBE
   1845          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   \   000000CC   0xF899 0x0099      LDRB     R0,[R9, #+153]
   \   000000D0   0x2801             CMP      R0,#+1
   \   000000D2   0xD105             BNE.N    ??set_axis_is_at_home_7
   1846          	  {
   1847                  current_position[Z_AXIS] -= zprobe_zoffset;
   \   000000D4   0x6938             LDR      R0,[R7, #+16]
   \   000000D6   0x6F39             LDR      R1,[R7, #+112]
   \   000000D8   0x.... 0x....      BL       __aeabi_fsub
   \   000000DC   0x6138             STR      R0,[R7, #+16]
   \   000000DE   0xE006             B.N      ??set_axis_is_at_home_6
   1848          
   1849                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1850                    if (DEBUGGING(LEVELING)) {
   1851                      SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
   1852                      SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
   1853                    }
   1854                  #endif
   1855          	  }
   1856          	  else
   1857          	  {
   1858          		  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");	  
   \                     ??set_axis_is_at_home_7: (+1)
   \   000000E0   0x7878             LDRB     R0,[R7, #+1]
   \   000000E2   0x0680             LSLS     R0,R0,#+26
   \   000000E4   0xD503             BPL.N    ??set_axis_is_at_home_6
   \   000000E6   0x.... 0x....      ADR.W    R0,`?<Constant "*** Z HOMED TO ENDSTO...">`
   \   000000EA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1859          	  }
   1860                #elif ENABLED(DEBUG_LEVELING_FEATURE)
   1861          
   1862                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
   1863          
   1864                #endif
   1865              }
   1866            }
   1867            #endif
   1868          
   1869            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1870              if (DEBUGGING(LEVELING)) {
   1871                #if HAS_HOME_OFFSET
   1872                  SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
   1873                  SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
   1874                #endif
   1875                DEBUG_POS("", current_position);
   1876                SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
   1877                SERIAL_CHAR(')');
   1878                SERIAL_EOL();
   1879              }
   1880            #endif
   1881          
   1882            #if ENABLED(I2C_POSITION_ENCODERS)
   1883              I2CPEM.homed(axis);
   1884            #endif
   1885          }
   \                     ??set_axis_is_at_home_6: (+1)
   \   000000EE   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   1886          
   1887          /**
   1888           * Some planner shorthand inline functions
   1889           */

   \                                 In section .text, align 4
   1890          inline float get_homing_bump_feedrate(const AxisEnum axis) {
   \                     _Z24get_homing_bump_feedrate8AxisEnum: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   1891            //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   1892          	int  homing_bump_divisor[4];
   1893          	if(MACHINETPYE == DELTA)
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x4912             LDR.N    R1,??get_homing_bump_feedrate_0
   \   0000000A   0xF9B1 0x1058      LDRSH    R1,[R1, #+88]
   \   0000000E   0x2902             CMP      R1,#+2
   \   00000010   0xD104             BNE.N    ??get_homing_bump_feedrate_1
   1894          	{
   1895          		homing_bump_divisor[0] = 10;
   \   00000012   0x210A             MOVS     R1,#+10
   \   00000014   0x9100             STR      R1,[SP, #+0]
   1896          		homing_bump_divisor[1] = 10;
   \   00000016   0x6041             STR      R1,[R0, #+4]
   1897          		homing_bump_divisor[2] = 10;
   \   00000018   0x6081             STR      R1,[R0, #+8]
   \   0000001A   0xE004             B.N      ??get_homing_bump_feedrate_2
   1898          	}
   1899          	else
   1900          	{
   1901          		homing_bump_divisor[0] = 2;
   \                     ??get_homing_bump_feedrate_1: (+1)
   \   0000001C   0x2102             MOVS     R1,#+2
   \   0000001E   0x9100             STR      R1,[SP, #+0]
   1902          		homing_bump_divisor[1] = 2;
   \   00000020   0x6041             STR      R1,[R0, #+4]
   1903          		homing_bump_divisor[2] = 4;
   \   00000022   0x2104             MOVS     R1,#+4
   \   00000024   0x6081             STR      R1,[R0, #+8]
   1904          	}  
   1905            uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   \                     ??get_homing_bump_feedrate_2: (+1)
   \   00000026   0xF810 0x5024      LDRB     R5,[R0, R4, LSL #+2]
   1906            if (hbd < 1) {
   \   0000002A   0x2D00             CMP      R5,#+0
   \   0000002C   0xD106             BNE.N    ??get_homing_bump_feedrate_3
   1907              hbd = 10;
   \   0000002E   0x250A             MOVS     R5,#+10
   1908              SERIAL_ECHO_START();
   \   00000030   0x4809             LDR.N    R0,??get_homing_bump_feedrate_0+0x4
   \   00000032   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1909              SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   \   00000036   0x4809             LDR.N    R0,??get_homing_bump_feedrate_0+0x8
   \   00000038   0x.... 0x....      BL       _Z14serialprintPGMPKc
   1910            }
   1911            //return homing_feedrate(axis) / hbd;
   1912            return homing_feedrate_mm_s[axis] / hbd;
   \                     ??get_homing_bump_feedrate_3: (+1)
   \   0000003C   0x4628             MOV      R0,R5
   \   0000003E   0x.... 0x....      BL       __aeabi_ui2f
   \   00000042   0x4601             MOV      R1,R0
   \   00000044   0x4806             LDR.N    R0,??get_homing_bump_feedrate_0+0xC
   \   00000046   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   0000004A   0x6A80             LDR      R0,[R0, #+40]
   \   0000004C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000050   0xB005             ADD      SP,SP,#+20
   \   00000052   0xBD30             POP      {R4,R5,PC}       ;; return
   \                     ??get_homing_bump_feedrate_0:
   \   00000054   0x........         DC32     mksCfg
   \   00000058   0x........         DC32     echomagic
   \   0000005C   0x........         DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
   \   00000060   0x........         DC32     mks_heating_busy
   1913          }
   1914          
   1915          /**
   1916           * Move the planner to the current position from wherever it last moved
   1917           * (or from wherever it has been told it is located).
   1918           */

   \                                 In section .text, align 4
   1919          inline void buffer_line_to_current_position() {
   \                     _Z31buffer_line_to_current_positionv: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   1920            planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
   \   00000004   0x4806             LDR.N    R0,??buffer_line_to_current_position_0
   \   00000006   0x78C1             LDRB     R1,[R0, #+3]
   \   00000008   0x9101             STR      R1,[SP, #+4]
   \   0000000A   0xF100 0x015C      ADD      R1,R0,#+92
   \   0000000E   0x9100             STR      R1,[SP, #+0]
   \   00000010   0xF100 0x0314      ADD      R3,R0,#+20
   \   00000014   0x6902             LDR      R2,[R0, #+16]
   \   00000016   0x68C1             LDR      R1,[R0, #+12]
   \   00000018   0x6880             LDR      R0,[R0, #+8]
   \   0000001A   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1921          }
   \   0000001E   0xBD07             POP      {R0-R2,PC}       ;; return
   \                     ??buffer_line_to_current_position_0:
   \   00000020   0x........         DC32     mks_heating_busy
   1922          
   1923          /**
   1924           * Move the planner to the position stored in the destination array, which is
   1925           * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
   1926           */

   \                                 In section .text, align 4
   1927          inline void buffer_line_to_destination(const float fr_mm_s) {
   \                     _Z26buffer_line_to_destinationf: (+1)
   \   00000000   0xB501             PUSH     {R0,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   1928            planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
   \   00000004   0x4806             LDR.N    R0,??buffer_line_to_destination_0
   \   00000006   0x78C1             LDRB     R1,[R0, #+3]
   \   00000008   0x9101             STR      R1,[SP, #+4]
   \   0000000A   0xA902             ADD      R1,SP,#+8
   \   0000000C   0x9100             STR      R1,[SP, #+0]
   \   0000000E   0xF100 0x0324      ADD      R3,R0,#+36
   \   00000012   0x6A02             LDR      R2,[R0, #+32]
   \   00000014   0x69C1             LDR      R1,[R0, #+28]
   \   00000016   0x6980             LDR      R0,[R0, #+24]
   \   00000018   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   1929          }
   \   0000001C   0xBD07             POP      {R0-R2,PC}       ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??buffer_line_to_destination_0:
   \   00000020   0x........         DC32     mks_heating_busy
   1930          
   1931          #if 1//IS_KINEMATIC
   1932            /**
   1933             * Calculate delta, start a line, and set current_position to destination
   1934             */

   \                                 In section .text, align 2, keep-with-next
   1935            void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
   \                     _Z42prepare_uninterpolated_move_to_destinationf: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   1936              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1937                if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
   1938              #endif
   1939          
   1940              refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   1941          
   1942              #if UBL_SEGMENTED
   1943                // ubl segmented line will do z-only moves in single segment
   1944                ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
   1945              #else
   1946                if ( current_position[X_AXIS] == destination[X_AXIS]
   1947                  && current_position[Y_AXIS] == destination[Y_AXIS]
   1948                  && current_position[Z_AXIS] == destination[Z_AXIS]
   1949                  && current_position[E_AXIS] == destination[E_AXIS]
   1950                ) return;
   \   00000008   0x.... 0x....      LDR.W    R5,??DataTable134_4
   \   0000000C   0x68A8             LDR      R0,[R5, #+8]
   \   0000000E   0x69A9             LDR      R1,[R5, #+24]
   \   00000010   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000014   0xD10E             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \   00000016   0x68E8             LDR      R0,[R5, #+12]
   \   00000018   0x69E9             LDR      R1,[R5, #+28]
   \   0000001A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000001E   0xD109             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \   00000020   0x6928             LDR      R0,[R5, #+16]
   \   00000022   0x6A29             LDR      R1,[R5, #+32]
   \   00000024   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000028   0xD104             BNE.N    ??prepare_uninterpolated_move_to_destination_0
   \   0000002A   0x6968             LDR      R0,[R5, #+20]
   \   0000002C   0x6A69             LDR      R1,[R5, #+36]
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000032   0xD01F             BEQ.N    ??prepare_uninterpolated_move_to_destination_1
   1951          
   1952                planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
   \                     ??prepare_uninterpolated_move_to_destination_0: (+1)
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0x2100             MOVS     R1,#+0
   \   00000038   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000003C   0xD100             BNE.N    ??prepare_uninterpolated_move_to_destination_2
   \   0000003E   0x6DEC             LDR      R4,[R5, #+92]
   \                     ??prepare_uninterpolated_move_to_destination_2: (+1)
   \   00000040   0xF9B5 0x0006      LDRSH    R0,[R5, #+6]
   \   00000044   0x.... 0x....      BL       __aeabi_i2f
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0x.... 0x....      BL       __aeabi_fmul
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x.... 0x....      LDR.W    R2,??DataTable143  ;; 0x47ae147b
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable144  ;; 0x3f847ae1
   \   0000005A   0x.... 0x....      BL       __aeabi_dmul
   \   0000005E   0x.... 0x....      BL       __aeabi_d2f
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0x78EA             LDRB     R2,[R5, #+3]
   \   00000066   0xA900             ADD      R1,SP,#+0
   \   00000068   0xF105 0x0018      ADD      R0,R5,#+24
   \   0000006C   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
   1953              #endif
   1954          
   1955              set_current_from_destination();
   \   00000070   0x.... 0x....      BL       _Z28set_current_from_destinationv
   1956            }
   \                     ??prepare_uninterpolated_move_to_destination_1: (+1)
   \   00000074   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   1957          #endif // IS_KINEMATIC
   1958          
   1959          /**
   1960           *  Plan a move to (X, Y, Z) and set the current_position
   1961           *  The final current_position may not be the one that was requested
   1962           */

   \                                 In section .text, align 2, keep-with-next
   1963          void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z19do_blocking_move_toRKfS0_S0_S0_: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x4607             MOV      R7,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x4699             MOV      R9,R3
   1964            const float old_feedrate_mm_s = feedrate_mm_s;
   \   0000000C   0x.... 0x....      LDR.W    R5,??DataTable134_4
   \   00000010   0x6DEE             LDR      R6,[R5, #+92]
   1965          
   1966            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1967              if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
   1968            #endif
   1969          
   1970            const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
   \   00000012   0xF8D9 0xA000      LDR      R10,[R9, #+0]
   \   00000016   0x4650             MOV      R0,R10
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000001E   0xD101             BNE.N    ??do_blocking_move_to_0
   \   00000020   0xF8D5 0xA030      LDR      R10,[R5, #+48]
   \                     ??do_blocking_move_to_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable134_5
   \   00000028   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000002C   0x2802             CMP      R0,#+2
   \   0000002E   0xD141             BNE.N    ??do_blocking_move_to_1
   1971          
   1972            //#if ENABLED(DELTA)
   1973            if(MACHINETPYE == DELTA)
   1974            {
   1975              if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
   \   00000030   0x4641             MOV      R1,R8
   \   00000032   0x4638             MOV      R0,R7
   \   00000034   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xF000 0x8096      BEQ.W    ??do_blocking_move_to_2
   1976          
   1977              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \   0000003E   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   00000042   0x4610             MOV      R0,R2
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000004A   0xD001             BEQ.N    ??do_blocking_move_to_3
   \   0000004C   0x65EA             STR      R2,[R5, #+92]
   \   0000004E   0xE001             B.N      ??do_blocking_move_to_4
   \                     ??do_blocking_move_to_3: (+1)
   \   00000050   0x6F68             LDR      R0,[R5, #+116]
   \   00000052   0x65E8             STR      R0,[R5, #+92]
   1978          
   1979              set_destination_from_current();          // sync destination at the start
   \                     ??do_blocking_move_to_4: (+1)
   \   00000054   0x.... 0x....      BL       _Z28set_destination_from_currentv
   1980          
   1981              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1982                if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
   1983              #endif
   1984          
   1985              // when in the danger zone
   1986              if (current_position[Z_AXIS] > delta_clip_start_height) {
   \   00000058   0x6FE8             LDR      R0,[R5, #+124]
   \   0000005A   0x6929             LDR      R1,[R5, #+16]
   \   0000005C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000060   0xD212             BCS.N    ??do_blocking_move_to_5
   1987                if (rz > delta_clip_start_height) {   // staying in the danger zone
   \   00000062   0x6821             LDR      R1,[R4, #+0]
   \   00000064   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000068   0xD20A             BCS.N    ??do_blocking_move_to_6
   1988                  destination[X_AXIS] = rx;           // move directly (uninterpolated)
   \   0000006A   0x6838             LDR      R0,[R7, #+0]
   \   0000006C   0x61A8             STR      R0,[R5, #+24]
   1989                  destination[Y_AXIS] = ry;
   \   0000006E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000072   0x61E8             STR      R0,[R5, #+28]
   1990                  destination[Z_AXIS] = rz;
   \   00000074   0x6820             LDR      R0,[R4, #+0]
   \   00000076   0x6228             STR      R0,[R5, #+32]
   1991                  prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   \   00000078   0x2000             MOVS     R0,#+0
   \   0000007A   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   0000007E   0x....             B.N      _Z42prepare_uninterpolated_move_to_destinationf
   1992                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1993                    if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
   1994                  #endif
   1995                  return;
   1996                }
   1997                destination[Z_AXIS] = delta_clip_start_height;
   \                     ??do_blocking_move_to_6: (+1)
   \   00000080   0x6228             STR      R0,[R5, #+32]
   1998                prepare_uninterpolated_move_to_destination(); // set_current_from_destination
   \   00000082   0x2000             MOVS     R0,#+0
   \   00000084   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   1999                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2000                  if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
   2001                #endif
   2002              }
   2003          
   2004              if (rz > current_position[Z_AXIS]) {    // raising?
   \                     ??do_blocking_move_to_5: (+1)
   \   00000088   0x6821             LDR      R1,[R4, #+0]
   \   0000008A   0x6928             LDR      R0,[R5, #+16]
   \   0000008C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000090   0xD203             BCS.N    ??do_blocking_move_to_7
   2005                destination[Z_AXIS] = rz;
   \   00000092   0x6229             STR      R1,[R5, #+32]
   2006                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   \   00000094   0x4650             MOV      R0,R10
   \   00000096   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2007                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2008                  if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
   2009                #endif
   2010              }
   2011          
   2012              destination[X_AXIS] = rx;
   \                     ??do_blocking_move_to_7: (+1)
   \   0000009A   0x6838             LDR      R0,[R7, #+0]
   \   0000009C   0x61A8             STR      R0,[R5, #+24]
   2013              destination[Y_AXIS] = ry;
   \   0000009E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000A2   0x61E8             STR      R0,[R5, #+28]
   2014              prepare_move_to_destination();         // set_current_from_destination
   \   000000A4   0x.... 0x....      BL       _Z27prepare_move_to_destinationv
   2015              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2016                if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
   2017              #endif
   2018          
   2019              if (rz < current_position[Z_AXIS]) {    // lowering?
   \   000000A8   0x6820             LDR      R0,[R4, #+0]
   \   000000AA   0x6929             LDR      R1,[R5, #+16]
   \   000000AC   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000B0   0xD258             BCS.N    ??do_blocking_move_to_8
   \   000000B2   0xE029             B.N      ??do_blocking_move_to_9
   2020                destination[Z_AXIS] = rz;
   2021                prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
   2022                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2023                  if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
   2024                #endif
   2025              }
   2026            }
   2027            //#elif IS_SCARA
   2028            else if(MACHINETPYE&IS_SCARA) {
   \                     ??do_blocking_move_to_1: (+1)
   \   000000B4   0xF44F 0x7140      MOV      R1,#+768
   \   000000B8   0x4208             TST      R0,R1
   \   000000BA   0xD02B             BEQ.N    ??do_blocking_move_to_10
   2029          
   2030              if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
   \   000000BC   0x4641             MOV      R1,R8
   \   000000BE   0x4638             MOV      R0,R7
   \   000000C0   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD050             BEQ.N    ??do_blocking_move_to_2
   2031          
   2032              set_destination_from_current();
   \   000000C8   0x.... 0x....      BL       _Z28set_destination_from_currentv
   2033          
   2034              // If Z needs to raise, do it before moving XY
   2035              if (destination[Z_AXIS] < rz) {
   \   000000CC   0x6821             LDR      R1,[R4, #+0]
   \   000000CE   0x6A28             LDR      R0,[R5, #+32]
   \   000000D0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D4   0xD203             BCS.N    ??do_blocking_move_to_11
   2036                destination[Z_AXIS] = rz;
   \   000000D6   0x6229             STR      R1,[R5, #+32]
   2037                prepare_uninterpolated_move_to_destination(z_feedrate);
   \   000000D8   0x4650             MOV      R0,R10
   \   000000DA   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2038              }
   2039          
   2040              destination[X_AXIS] = rx;
   \                     ??do_blocking_move_to_11: (+1)
   \   000000DE   0x6838             LDR      R0,[R7, #+0]
   \   000000E0   0x61A8             STR      R0,[R5, #+24]
   2041              destination[Y_AXIS] = ry;
   \   000000E2   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   000000E6   0x61E8             STR      R0,[R5, #+28]
   2042              prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
   \   000000E8   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   000000EC   0x4610             MOV      R0,R2
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000F4   0xD100             BNE.N    ??do_blocking_move_to_12
   \   000000F6   0x6F6A             LDR      R2,[R5, #+116]
   \                     ??do_blocking_move_to_12: (+1)
   \   000000F8   0x4610             MOV      R0,R2
   \   000000FA   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   2043          
   2044              // If Z needs to lower, do it after moving XY
   2045              if (destination[Z_AXIS] > rz) {
   \   000000FE   0x6820             LDR      R0,[R4, #+0]
   \   00000100   0x6A29             LDR      R1,[R5, #+32]
   \   00000102   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000106   0xD22D             BCS.N    ??do_blocking_move_to_8
   2046                destination[Z_AXIS] = rz;
   \                     ??do_blocking_move_to_9: (+1)
   \   00000108   0x6820             LDR      R0,[R4, #+0]
   \   0000010A   0x6228             STR      R0,[R5, #+32]
   2047                prepare_uninterpolated_move_to_destination(z_feedrate);
   \   0000010C   0x4650             MOV      R0,R10
   \   0000010E   0x.... 0x....      BL       _Z42prepare_uninterpolated_move_to_destinationf
   \   00000112   0xE027             B.N      ??do_blocking_move_to_8
   2048              }
   2049            }
   2050            //#else
   2051            else
   2052            {
   2053              // If Z needs to raise, do it before moving XY
   2054              if (current_position[Z_AXIS] < rz) {
   \                     ??do_blocking_move_to_10: (+1)
   \   00000114   0x6928             LDR      R0,[R5, #+16]
   \   00000116   0x6821             LDR      R1,[R4, #+0]
   \   00000118   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011C   0xD205             BCS.N    ??do_blocking_move_to_13
   2055                feedrate_mm_s = z_feedrate;
   \   0000011E   0xF8C5 0xA05C      STR      R10,[R5, #+92]
   2056                current_position[Z_AXIS] = rz;
   \   00000122   0x6820             LDR      R0,[R4, #+0]
   \   00000124   0x6128             STR      R0,[R5, #+16]
   2057                buffer_line_to_current_position();
   \   00000126   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2058              }
   2059          
   2060              feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??do_blocking_move_to_13: (+1)
   \   0000012A   0xF8D9 0x2000      LDR      R2,[R9, #+0]
   \   0000012E   0x4610             MOV      R0,R2
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000136   0xD001             BEQ.N    ??do_blocking_move_to_14
   \   00000138   0x65EA             STR      R2,[R5, #+92]
   \   0000013A   0xE001             B.N      ??do_blocking_move_to_15
   \                     ??do_blocking_move_to_14: (+1)
   \   0000013C   0x6F68             LDR      R0,[R5, #+116]
   \   0000013E   0x65E8             STR      R0,[R5, #+92]
   2061              current_position[X_AXIS] = rx;
   \                     ??do_blocking_move_to_15: (+1)
   \   00000140   0x6838             LDR      R0,[R7, #+0]
   \   00000142   0x60A8             STR      R0,[R5, #+8]
   2062              current_position[Y_AXIS] = ry;
   \   00000144   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000148   0x60E8             STR      R0,[R5, #+12]
   2063              buffer_line_to_current_position();
   \   0000014A   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2064          
   2065              // If Z needs to lower, do it after moving XY
   2066              if (current_position[Z_AXIS] > rz) {
   \   0000014E   0x6820             LDR      R0,[R4, #+0]
   \   00000150   0x6929             LDR      R1,[R5, #+16]
   \   00000152   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000156   0xD205             BCS.N    ??do_blocking_move_to_8
   2067                feedrate_mm_s = z_feedrate;
   \   00000158   0xF8C5 0xA05C      STR      R10,[R5, #+92]
   2068                current_position[Z_AXIS] = rz;
   \   0000015C   0x6820             LDR      R0,[R4, #+0]
   \   0000015E   0x6128             STR      R0,[R5, #+16]
   2069                buffer_line_to_current_position();
   \   00000160   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   2070              }
   2071            }
   2072            //#endif
   2073          
   2074            stepper.synchronize();
   \                     ??do_blocking_move_to_8: (+1)
   \   00000164   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   2075          
   2076            feedrate_mm_s = old_feedrate_mm_s;
   \   00000168   0x65EE             STR      R6,[R5, #+92]
   2077          
   2078            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2079              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
   2080            #endif
   2081          }
   \                     ??do_blocking_move_to_2: (+1)
   \   0000016A   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   2082          void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_xRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2083            do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
   \   00000002   0x....             LDR.N    R4,??DataTable134_4
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0xF104 0x0210      ADD      R2,R4,#+16
   \   0000000A   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000000E   0xB001             ADD      SP,SP,#+4
   \   00000010   0xBC10             POP      {R4}
   \   00000012   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2084          }

   \                                 In section .text, align 2, keep-with-next
   2085          void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
   \                     _Z21do_blocking_move_to_zRKfS0_: (+1)
   \   00000000   0xB418             PUSH     {R3,R4}
   2086            do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
   \   00000002   0x....             LDR.N    R4,??DataTable134_4
   \   00000004   0x460B             MOV      R3,R1
   \   00000006   0x4602             MOV      R2,R0
   \   00000008   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000000C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000010   0xB001             ADD      SP,SP,#+4
   \   00000012   0xBC10             POP      {R4}
   \   00000014   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2087          }

   \                                 In section .text, align 2, keep-with-next
   2088          void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
   2089            do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
   \                     _Z22do_blocking_move_to_xyRKfS0_S0_: (+1)
   \   00000000   0x4613             MOV      R3,R2
   \   00000002   0x.... 0x....      LDR.W    R2,??DataTable145
   \   00000006   0x....             B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
   2090          }
   2091          
   2092          //
   2093          // Prepare to do endstop or probe moves
   2094          // with custom feedrates.
   2095          //
   2096          //  - Save current feedrates
   2097          //  - Reset the rate multiplier
   2098          //  - Reset the command timeout
   2099          //  - Enable the endstops (for endstop moves)
   2100          //

   \                                 In section .text, align 2, keep-with-next
   2101          static void setup_for_endstop_or_probe_move() {
   2102            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2103              if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
   2104            #endif
   2105            saved_feedrate_mm_s = feedrate_mm_s;
   \                     _Z31setup_for_endstop_or_probe_movev: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable145_1
   \   00000004   0x....             LDR.N    R1,??DataTable134_4
   \   00000006   0x6DCA             LDR      R2,[R1, #+92]
   \   00000008   0x6042             STR      R2,[R0, #+4]
   2106            saved_feedrate_percentage = feedrate_percentage;
   \   0000000A   0x88CA             LDRH     R2,[R1, #+6]
   \   0000000C   0x8002             STRH     R2,[R0, #+0]
   2107            feedrate_percentage = 100;
   \   0000000E   0x2064             MOVS     R0,#+100
   \   00000010   0x80C8             STRH     R0,[R1, #+6]
   2108            refresh_cmd_timeout();
   \   00000012   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2109          }
   2110          

   \                                 In section .text, align 2, keep-with-next
   2111          static void clean_up_after_endstop_or_probe_move() {
   2112            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2113              if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   2114            #endif
   2115            feedrate_mm_s = saved_feedrate_mm_s;
   \                     _Z36clean_up_after_endstop_or_probe_movev: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable134_4
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable145_1
   \   00000006   0x684A             LDR      R2,[R1, #+4]
   \   00000008   0x65C2             STR      R2,[R0, #+92]
   2116            feedrate_percentage = saved_feedrate_percentage;
   \   0000000A   0x8809             LDRH     R1,[R1, #+0]
   \   0000000C   0x80C1             STRH     R1,[R0, #+6]
   2117            refresh_cmd_timeout();
   \   0000000E   0x.... 0x....      B.W      _Z19refresh_cmd_timeoutv
   2118          }
   2119          
   2120          #if HAS_BED_PROBE
   2121            /**
   2122             * Raise Z to a minimum height to make room for a probe to move
   2123             */

   \                                 In section .text, align 4
   2124            inline void do_probe_raise(const float z_raise) {
   \                     _Z14do_probe_raisef: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   2125              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2126                if (DEBUGGING(LEVELING)) {
   2127                  SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
   2128                  SERIAL_CHAR(')');
   2129                  SERIAL_EOL();
   2130                }
   2131              #endif
   2132          
   2133              float z_dest = z_raise;
   \   00000002   0x9000             STR      R0,[SP, #+0]
   2134              if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
   \   00000004   0x4C0B             LDR.N    R4,??do_probe_raise_0
   \   00000006   0x6F22             LDR      R2,[R4, #+112]
   \   00000008   0x4610             MOV      R0,R2
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000010   0xD204             BCS.N    ??do_probe_raise_1
   \   00000012   0x9800             LDR      R0,[SP, #+0]
   \   00000014   0x4611             MOV      R1,R2
   \   00000016   0x.... 0x....      BL       __aeabi_fsub
   \   0000001A   0x9000             STR      R0,[SP, #+0]
   2135          
   2136              if (z_dest > current_position[Z_AXIS])
   \                     ??do_probe_raise_1: (+1)
   \   0000001C   0x6920             LDR      R0,[R4, #+16]
   \   0000001E   0x9900             LDR      R1,[SP, #+0]
   \   00000020   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000024   0xD205             BCS.N    ??do_probe_raise_2
   2137                do_blocking_move_to_z(z_dest);
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x9001             STR      R0,[SP, #+4]
   \   0000002A   0xA901             ADD      R1,SP,#+4
   \   0000002C   0xA800             ADD      R0,SP,#+0
   \   0000002E   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2138            }
   \                     ??do_probe_raise_2: (+1)
   \   00000032   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \                     ??do_probe_raise_0:
   \   00000034   0x........         DC32     mks_heating_busy
   2139          
   2140          #endif // HAS_BED_PROBE
   2141          
   2142          #if HAS_AXIS_UNHOMED_ERR
   2143          

   \                                 In section .text, align 2, keep-with-next
   2144            bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
   \                     _Z18axis_unhomed_errorbbb: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   2145              #if ENABLED(HOME_AFTER_DEACTIVATE)
   2146                const bool xx = x && !axis_known_position[X_AXIS],
   2147                           yy = y && !axis_known_position[Y_AXIS],
   2148                           zz = z && !axis_known_position[Z_AXIS];
   2149              #else
   2150                const bool xx = x && !axis_homed[X_AXIS],
   \   00000002   0x2800             CMP      R0,#+0
   \   00000004   0xD004             BEQ.N    ??axis_unhomed_error_0
   \   00000006   0x....             LDR.N    R0,??DataTable134_9
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0xF080 0x0401      EOR      R4,R0,#0x1
   \   0000000E   0xE000             B.N      ??axis_unhomed_error_1
   \                     ??axis_unhomed_error_0: (+1)
   \   00000010   0x2400             MOVS     R4,#+0
   2151                           yy = y && !axis_homed[Y_AXIS],
   \                     ??axis_unhomed_error_1: (+1)
   \   00000012   0x2900             CMP      R1,#+0
   \   00000014   0xD004             BEQ.N    ??axis_unhomed_error_2
   \   00000016   0x....             LDR.N    R0,??DataTable134_9
   \   00000018   0x7840             LDRB     R0,[R0, #+1]
   \   0000001A   0xF080 0x0501      EOR      R5,R0,#0x1
   \   0000001E   0xE000             B.N      ??axis_unhomed_error_3
   \                     ??axis_unhomed_error_2: (+1)
   \   00000020   0x2500             MOVS     R5,#+0
   2152                           zz = z && !axis_homed[Z_AXIS];
   \                     ??axis_unhomed_error_3: (+1)
   \   00000022   0x2A00             CMP      R2,#+0
   \   00000024   0xD004             BEQ.N    ??axis_unhomed_error_4
   \   00000026   0x....             LDR.N    R0,??DataTable134_9
   \   00000028   0x7880             LDRB     R0,[R0, #+2]
   \   0000002A   0xF080 0x0601      EOR      R6,R0,#0x1
   \   0000002E   0xE000             B.N      ??axis_unhomed_error_5
   \                     ??axis_unhomed_error_4: (+1)
   \   00000030   0x2600             MOVS     R6,#+0
   2153              #endif
   2154              if (xx || yy || zz) {
   \                     ??axis_unhomed_error_5: (+1)
   \   00000032   0xEA45 0x0004      ORR      R0,R5,R4
   \   00000036   0x4330             ORRS     R0,R6,R0
   \   00000038   0xD01C             BEQ.N    ??axis_unhomed_error_6
   2155                SERIAL_ECHO_START();
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable137_3
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2156                SERIAL_ECHOPGM(MSG_HOME " ");
   \   00000042   0x.... 0x....      ADR.W    R0,`?<Constant "Home ">`
   \   00000046   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2157                if (xx) SERIAL_ECHOPGM(MSG_X);
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD002             BEQ.N    ??axis_unhomed_error_7
   \   0000004E   0x....             ADR.N    R0,??DataTable134  ;; "X"
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2158                if (yy) SERIAL_ECHOPGM(MSG_Y);
   \                     ??axis_unhomed_error_7: (+1)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ.N    ??axis_unhomed_error_8
   \   00000058   0x....             ADR.N    R0,??DataTable134_1  ;; "Y"
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2159                if (zz) SERIAL_ECHOPGM(MSG_Z);
   \                     ??axis_unhomed_error_8: (+1)
   \   0000005E   0x2E00             CMP      R6,#+0
   \   00000060   0xD002             BEQ.N    ??axis_unhomed_error_9
   \   00000062   0x....             ADR.N    R0,??DataTable134_2  ;; "Z"
   \   00000064   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2160                SERIAL_ECHOLNPGM(" " MSG_FIRST);
   \                     ??axis_unhomed_error_9: (+1)
   \   00000068   0x.... 0x....      ADR.W    R0,`?<Constant " first\\n">`
   \   0000006C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2161          
   2162                #if ENABLED(ULTRA_LCD)
   2163                  lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
   2164                #endif
   2165                return true;
   \   00000070   0x2001             MOVS     R0,#+1
   \   00000072   0xBD70             POP      {R4-R6,PC}
   2166              }
   2167              return false;
   \                     ??axis_unhomed_error_6: (+1)
   \   00000074   0x2000             MOVS     R0,#+0
   \   00000076   0xBD70             POP      {R4-R6,PC}       ;; return
   2168            }
   2169          
   2170          #endif // HAS_AXIS_UNHOMED_ERR
   2171          
   2172          #if ENABLED(Z_PROBE_SLED)
   2173          
   2174            #ifndef SLED_DOCKING_OFFSET
   2175              #define SLED_DOCKING_OFFSET 0
   2176            #endif
   2177          
   2178            /**
   2179             * Method to dock/undock a sled designed by Charles Bell.
   2180             *
   2181             * stow[in]     If false, move to MAX_X and engage the solenoid
   2182             *              If true, move to MAX_X and release the solenoid
   2183             */
   2184            static void dock_sled(bool stow) {
   2185              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2186                if (DEBUGGING(LEVELING)) {
   2187                  SERIAL_ECHOPAIR("dock_sled(", stow);
   2188                  SERIAL_CHAR(')');
   2189                  SERIAL_EOL();
   2190                }
   2191              #endif
   2192          
   2193              // Dock sled a bit closer to ensure proper capturing
   2194              do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
   2195          
   2196              #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
   2197                WRITE(SOL1_PIN, !stow); // switch solenoid
   2198              #endif
   2199            }
   2200          
   2201          #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2202          
   2203            FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
   2204              do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
   2205            }
   2206          
   2207            void run_deploy_moves_script() {
   2208              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
   2209                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
   2210                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
   2211                #endif
   2212                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
   2213                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
   2214                #endif
   2215                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
   2216                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
   2217                #endif
   2218                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
   2219                  #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
   2220                #endif
   2221                const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
   2222                do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
   2223              #endif
   2224              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
   2225                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
   2226                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
   2227                #endif
   2228                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
   2229                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
   2230                #endif
   2231                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
   2232                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
   2233                #endif
   2234                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
   2235                  #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
   2236                #endif
   2237                const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
   2238                do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
   2239              #endif
   2240              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
   2241                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
   2242                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
   2243                #endif
   2244                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
   2245                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
   2246                #endif
   2247                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
   2248                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
   2249                #endif
   2250                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
   2251                  #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
   2252                #endif
   2253                const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
   2254                do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
   2255              #endif
   2256              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
   2257                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
   2258                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
   2259                #endif
   2260                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
   2261                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
   2262                #endif
   2263                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
   2264                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
   2265                #endif
   2266                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
   2267                  #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
   2268                #endif
   2269                const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
   2270                do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
   2271              #endif
   2272              #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
   2273                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
   2274                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
   2275                #endif
   2276                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
   2277                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
   2278                #endif
   2279                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
   2280                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
   2281                #endif
   2282                #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
   2283                  #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
   2284                #endif
   2285                const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
   2286                do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
   2287              #endif
   2288            }
   2289          
   2290            void run_stow_moves_script() {
   2291              #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
   2292                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
   2293                  #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
   2294                #endif
   2295                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
   2296                  #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
   2297                #endif
   2298                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
   2299                  #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
   2300                #endif
   2301                #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
   2302                  #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
   2303                #endif
   2304                const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
   2305                do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
   2306              #endif
   2307              #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
   2308                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
   2309                  #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
   2310                #endif
   2311                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
   2312                  #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
   2313                #endif
   2314                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
   2315                  #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
   2316                #endif
   2317                #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
   2318                  #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
   2319                #endif
   2320                const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
   2321                do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
   2322              #endif
   2323              #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
   2324                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
   2325                  #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
   2326                #endif
   2327                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
   2328                  #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
   2329                #endif
   2330                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
   2331                  #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
   2332                #endif
   2333                #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
   2334                  #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
   2335                #endif
   2336                const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
   2337                do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
   2338              #endif
   2339              #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
   2340                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
   2341                  #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
   2342                #endif
   2343                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
   2344                  #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
   2345                #endif
   2346                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
   2347                  #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
   2348                #endif
   2349                #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
   2350                  #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
   2351                #endif
   2352                const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
   2353                do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
   2354              #endif
   2355              #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
   2356                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
   2357                  #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
   2358                #endif
   2359                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
   2360                  #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
   2361                #endif
   2362                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
   2363                  #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
   2364                #endif
   2365                #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
   2366                  #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
   2367                #endif
   2368                const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
   2369                do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
   2370              #endif
   2371            }
   2372          
   2373          #endif // Z_PROBE_ALLEN_KEY
   2374          
   2375          #if ENABLED(PROBING_FANS_OFF)
   2376          
   2377            void fans_pause(const bool p) {
   2378              if (p != fans_paused) {
   2379                fans_paused = p;
   2380                if (p)
   2381                  for (uint8_t x = 0; x < FAN_COUNT; x++) {
   2382                    paused_fanSpeeds[x] = fanSpeeds[x];
   2383                    fanSpeeds[x] = 0;
   2384                  }
   2385                else
   2386                  for (uint8_t x = 0; x < FAN_COUNT; x++)
   2387                    fanSpeeds[x] = paused_fanSpeeds[x];
   2388              }
   2389            }
   2390          
   2391          #endif // PROBING_FANS_OFF
   2392          
   2393          #if HAS_BED_PROBE
   2394          
   2395            // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
   2396            #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
   2397              #if 1 //ENABLED(Z_MIN_PROBE_ENDSTOP)
   2398                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
   2399              #else
   2400                #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
   2401              #endif
   2402            #endif
   2403          
   2404            #if QUIET_PROBING
   2405              void probing_pause(const bool p) {
   2406                #if ENABLED(PROBING_HEATERS_OFF)
   2407                  thermalManager.pause(p);
   2408                #endif
   2409                #if ENABLED(PROBING_FANS_OFF)
   2410                  fans_pause(p);
   2411                #endif
   2412                if (p) safe_delay(
   2413                  #if DELAY_BEFORE_PROBING > 25
   2414                    DELAY_BEFORE_PROBING
   2415                  #else
   2416                    25
   2417                  #endif
   2418                );
   2419              }
   2420            #endif // QUIET_PROBING
   2421          
   2422            //#if ENABLED(BLTOUCH)
   2423          

   \                                 In section .text, align 2, keep-with-next
   2424              void bltouch_command(int angle) {
   2425              #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
   2426                //MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
   2427                int mksAngle;
   2428           	  switch(angle)
   \                     _Z15bltouch_commandi: (+1)
   \   00000000   0x280A             CMP      R0,#+10
   \   00000002   0xD006             BEQ.N    ??bltouch_command_0
   \   00000004   0x283C             CMP      R0,#+60
   \   00000006   0xD00D             BEQ.N    ??bltouch_command_1
   \   00000008   0x285A             CMP      R0,#+90
   \   0000000A   0xD005             BEQ.N    ??bltouch_command_2
   \   0000000C   0x2878             CMP      R0,#+120
   \   0000000E   0xD006             BEQ.N    ??bltouch_command_3
   \   00000010   0xE00B             B.N      ??bltouch_command_4
   2429          	  {
   2430          		 case 10:
   2431          			 mksAngle = 700/2;
   \                     ??bltouch_command_0: (+1)
   \   00000012   0xF44F 0x70AF      MOV      R0,#+350
   2432          			 break;
   \   00000016   0xE00A             B.N      ??bltouch_command_5
   2433          		 case 90:
   2434          			 mksAngle = 1500/2;
   \                     ??bltouch_command_2: (+1)
   \   00000018   0xF240 0x20EE      MOVW     R0,#+750
   2435          			 break;
   \   0000001C   0xE007             B.N      ??bltouch_command_5
   2436          		 case 120:
   2437          			 mksAngle = 1800/2;
   \                     ??bltouch_command_3: (+1)
   \   0000001E   0xF44F 0x7061      MOV      R0,#+900
   2438          			 break;
   \   00000022   0xE004             B.N      ??bltouch_command_5
   2439          		 case 160:
   2440          			 mksAngle = 2200/2;
   2441          			 break;
   2442          		 case 60:
   2443          			 mksAngle = 1200/2;
   \                     ??bltouch_command_1: (+1)
   \   00000024   0xF44F 0x7016      MOV      R0,#+600
   2444          			 break;
   \   00000028   0xE001             B.N      ??bltouch_command_5
   2445          		 default:
   2446          			 mksAngle = 2200/2;
   \                     ??bltouch_command_4: (+1)
   \   0000002A   0xF240 0x404C      MOVW     R0,#+1100
   2447          			 break;
   2448          	  }
   2449                MKS_TOUCH_TIM = mksAngle;	  
   \                     ??bltouch_command_5: (+1)
   \   0000002E   0x.... 0x....      LDR.W    R1,??DataTable145_2  ;; 0x40012c34
   \   00000032   0x6008             STR      R0,[R1, #+0]
   2450                safe_delay(BLTOUCH_DELAY);
   \   00000034   0xF240 0x1077      MOVW     R0,#+375
   \   00000038   0x.... 0x....      B.W      _Z10safe_delaym
   2451                #endif
   2452              }
   2453          

   \                                 In section .text, align 2, keep-with-next
   2454              bool set_bltouch_deployed(const bool deploy) {
   \                     _Z20set_bltouch_deployedb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   2455                if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   \   00000004   0x....             LDR.N    R5,??DataTable134_5
   \   00000006   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   0000000A   0x2801             CMP      R0,#+1
   \   0000000C   0xD123             BNE.N    ??set_bltouch_deployed_0
   2456          		{
   2457          		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
   \   0000000E   0x2C00             CMP      R4,#+0
   \   00000010   0xD050             BEQ.N    ??set_bltouch_deployed_1
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable145_3
   \   00000016   0x.... 0x....      LDR.W    R7,??DataTable145_4
   \   0000001A   0x8B79             LDRH     R1,[R7, #+26]
   \   0000001C   0x6B70             LDR      R0,[R6, #+52]
   \   0000001E   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   00000022   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   00000026   0x4288             CMP      R0,R1
   \   00000028   0xD044             BEQ.N    ??set_bltouch_deployed_1
   2458          		  { 	 // If BL-Touch says it's triggered
   2459          		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
   \   0000002A   0x20A0             MOVS     R0,#+160
   \   0000002C   0x.... 0x....      BL       _Z15bltouch_commandi
   2460          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   \   00000030   0x200A             MOVS     R0,#+10
   \   00000032   0x.... 0x....      BL       _Z15bltouch_commandi
   2461          		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
   \   00000036   0x205A             MOVS     R0,#+90
   \   00000038   0x.... 0x....      BL       _Z15bltouch_commandi
   2462          		  safe_delay(1500); 				 // Wait for internal self-test to complete.
   \   0000003C   0xF240 0x50DC      MOVW     R0,#+1500
   \   00000040   0x.... 0x....      BL       _Z10safe_delaym
   2463          											 //  (Measured completion time was 0.65 seconds
   2464          											 //   after reset, deploy, and stow sequence)
   2465          		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   \   00000044   0x8B79             LDRH     R1,[R7, #+26]
   \   00000046   0x6B70             LDR      R0,[R6, #+52]
   \   00000048   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000004C   0xF895 0x1039      LDRB     R1,[R5, #+57]
   \   00000050   0x4288             CMP      R0,R1
   \   00000052   0xD02F             BEQ.N    ??set_bltouch_deployed_1
   \   00000054   0xE024             B.N      ??set_bltouch_deployed_2
   2466          			SERIAL_ERROR_START();
   2467          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   2468          			stop(); 						 // punt!
   2469          		  	}
   2470          			}
   2471          		
   2472          		}
   2473          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \                     ??set_bltouch_deployed_0: (+1)
   \   00000056   0x2802             CMP      R0,#+2
   \   00000058   0xD12C             BNE.N    ??set_bltouch_deployed_1
   2474          		{
   2475          		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
   \   0000005A   0x2C00             CMP      R4,#+0
   \   0000005C   0xD02A             BEQ.N    ??set_bltouch_deployed_1
   \   0000005E   0x.... 0x....      LDR.W    R6,??DataTable145_3
   \   00000062   0x.... 0x....      LDR.W    R7,??DataTable145_4
   \   00000066   0x8BB9             LDRH     R1,[R7, #+28]
   \   00000068   0x6BB0             LDR      R0,[R6, #+56]
   \   0000006A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000006E   0xF205 0x0539      ADDW     R5,R5,#+57
   \   00000072   0x7929             LDRB     R1,[R5, #+4]
   \   00000074   0x4288             CMP      R0,R1
   \   00000076   0xD01D             BEQ.N    ??set_bltouch_deployed_1
   2476          		  { 	 // If BL-Touch says it's triggered
   2477          		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
   \   00000078   0x20A0             MOVS     R0,#+160
   \   0000007A   0x.... 0x....      BL       _Z15bltouch_commandi
   2478          		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
   \   0000007E   0x200A             MOVS     R0,#+10
   \   00000080   0x.... 0x....      BL       _Z15bltouch_commandi
   2479          		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
   \   00000084   0x205A             MOVS     R0,#+90
   \   00000086   0x.... 0x....      BL       _Z15bltouch_commandi
   2480          		  safe_delay(1500); 				 // Wait for internal self-test to complete.
   \   0000008A   0xF240 0x50DC      MOVW     R0,#+1500
   \   0000008E   0x.... 0x....      BL       _Z10safe_delaym
   2481          											 //  (Measured completion time was 0.65 seconds
   2482          											 //   after reset, deploy, and stow sequence)
   2483          		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
   \   00000092   0x8BB9             LDRH     R1,[R7, #+28]
   \   00000094   0x6BB0             LDR      R0,[R6, #+56]
   \   00000096   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000009A   0x7929             LDRB     R1,[R5, #+4]
   \   0000009C   0x4288             CMP      R0,R1
   \   0000009E   0xD009             BEQ.N    ??set_bltouch_deployed_1
   2484          			SERIAL_ERROR_START();
   \                     ??set_bltouch_deployed_2: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable137_5
   \   000000A4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2485          			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
   \   000000A8   0x.... 0x....      ADR.W    R0,`?<Constant "STOP called because o...">`
   \   000000AC   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2486          			stop(); 						 // punt!
   \   000000B0   0x.... 0x....      BL       _Z4stopv
   2487          		  }
   2488          		}
   2489          		}
   2490                //}
   2491          
   2492                bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
   \                     ??set_bltouch_deployed_1: (+1)
   \   000000B4   0x2C00             CMP      R4,#+0
   \   000000B6   0xD001             BEQ.N    ??set_bltouch_deployed_3
   \   000000B8   0x200A             MOVS     R0,#+10
   \   000000BA   0xE000             B.N      ??set_bltouch_deployed_4
   \                     ??set_bltouch_deployed_3: (+1)
   \   000000BC   0x205A             MOVS     R0,#+90
   \                     ??set_bltouch_deployed_4: (+1)
   \   000000BE   0x.... 0x....      BL       _Z15bltouch_commandi
   2493          
   2494                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2495                  if (DEBUGGING(LEVELING)) {
   2496                    SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
   2497                    SERIAL_CHAR(')');
   2498                    SERIAL_EOL();
   2499                  }
   2500                #endif
   2501          
   2502                return false;
   \   000000C2   0x2000             MOVS     R0,#+0
   \   000000C4   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
   2503              }
   2504          
   2505            //#endif // BLTOUCH
   2506          
   2507            // returns false for ok and true for failure

   \                                 In section .text, align 2, keep-with-next
   2508            bool set_probe_deployed(bool deploy) {
   \                     _Z18set_probe_deployedb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   2509          
   2510              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2511                if (DEBUGGING(LEVELING)) {
   2512                  DEBUG_POS("set_probe_deployed", current_position);
   2513                  SERIAL_ECHOLNPAIR("deploy: ", deploy);
   2514                }
   2515              #endif
   2516          
   2517              if (endstops.z_probe_enabled == deploy) return false;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable146
   \   0000000A   0x7800             LDRB     R0,[R0, #+0]
   \   0000000C   0x42A0             CMP      R0,R4
   \   0000000E   0xD101             BNE.N    ??set_probe_deployed_0
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0xE01B             B.N      ??set_probe_deployed_1
   2518          
   2519              // Make room for probe
   2520              //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
   2521              do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
   \                     ??set_probe_deployed_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable134_5
   \   00000016   0x6E41             LDR      R1,[R0, #+100]
   \   00000018   0x6E80             LDR      R0,[R0, #+104]
   \   0000001A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000001E   0xD300             BCC.N    ??set_probe_deployed_2
   \   00000020   0x4601             MOV      R1,R0
   \                     ??set_probe_deployed_2: (+1)
   \   00000022   0x4608             MOV      R0,R1
   \   00000024   0x.... 0x....      BL       _Z14do_probe_raisef
   2522          
   2523              #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
   2524                #if ENABLED(Z_PROBE_SLED)
   2525                  #define _AUE_ARGS true, false, false
   2526                #else
   2527                  #define _AUE_ARGS
   2528                #endif
   2529                if (axis_unhomed_error(_AUE_ARGS)) {
   2530                  SERIAL_ERROR_START();
   2531                  SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
   2532                  stop();
   2533                  return true;
   2534                }
   2535              #endif
   2536          
   2537              const float oldXpos = current_position[X_AXIS],
   \   00000028   0x....             LDR.N    R0,??DataTable134_4
   \   0000002A   0x6881             LDR      R1,[R0, #+8]
   \   0000002C   0x9102             STR      R1,[SP, #+8]
   2538                          oldYpos = current_position[Y_AXIS];
   \   0000002E   0x68C1             LDR      R1,[R0, #+12]
   \   00000030   0x9101             STR      R1,[SP, #+4]
   2539          
   2540              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2541                bool _triggered_bool =false;
   2542          	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2543          		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   2544          	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   2545          		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   2546          
   2547                // If endstop is already false, the Z probe is deployed
   2548                if (_triggered_bool == deploy) {
   2549                //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
   2550                                                                 // Would a goto be less ugly?
   2551                  //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
   2552                                                                 // for a triggered when stowed manual probe.
   2553          
   2554                  if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
   2555                                                               // otherwise an Allen-Key probe can't be stowed.
   2556              #endif
   2557          
   2558                  #if ENABLED(SOLENOID_PROBE)
   2559          
   2560                    #if HAS_SOLENOID_1
   2561                      WRITE(SOL1_PIN, deploy);
   2562                    #endif
   2563          
   2564                  #elif ENABLED(Z_PROBE_SLED)
   2565          
   2566                    dock_sled(!deploy);
   2567          
   2568                  #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
   2569          
   2570                    MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
   2571          
   2572                  #elif ENABLED(Z_PROBE_ALLEN_KEY)
   2573          
   2574                    deploy ? run_deploy_moves_script() : run_stow_moves_script();
   2575          
   2576                  #endif
   2577          
   2578              #ifdef _TRIGGERED_WHEN_STOWED_TEST
   2579                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2580                
   2581          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2582          		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   2583          	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   2584          		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   2585          
   2586                //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
   2587                if (_triggered_bool == deploy) { 
   2588          
   2589                  if (IsRunning()) {
   2590                    SERIAL_ERROR_START();
   2591                    SERIAL_ERRORLNPGM("Z-Probe failed");
   2592                    LCD_ALERTMESSAGEPGM("Err: ZPROBE");
   2593                  }
   2594                  stop();
   2595                  return true;
   2596          
   2597                } // _TRIGGERED_WHEN_STOWED_TEST == deploy
   2598          
   2599              #endif
   2600          
   2601              do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x9100             STR      R1,[SP, #+0]
   \   00000036   0xAB00             ADD      R3,SP,#+0
   \   00000038   0xF100 0x0210      ADD      R2,R0,#+16
   \   0000003C   0xA901             ADD      R1,SP,#+4
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   2602              endstops.enable_z_probe(deploy);
   \   00000044   0x4620             MOV      R0,R4
   \   00000046   0x.... 0x....      BL       _ZN8Endstops14enable_z_probeEb
   2603              return false;
   \   0000004A   0x2000             MOVS     R0,#+0
   \                     ??set_probe_deployed_1: (+1)
   \   0000004C   0xB004             ADD      SP,SP,#+16
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   2604            }
   2605          
   2606            /**
   2607             * @brief Used by run_z_probe to do a single Z probe move.
   2608             *
   2609             * @param  z        Z destination
   2610             * @param  fr_mm_s  Feedrate in mm/s
   2611             * @return true to indicate an error
   2612             */

   \                                 In section .text, align 2, keep-with-next
   2613            static bool do_probe_move(const float z, const float fr_mm_m) {
   \                     _Z13do_probe_moveff: (+1)
   \   00000000   0xB531             PUSH     {R0,R4,R5,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x460D             MOV      R5,R1
   2614              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2615                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
   2616              #endif
   2617          
   2618              // Deploy BLTouch at the start of any probe
   2619              //#if ENABLED(BLTOUCH)
   2620              if(MKSTOUCH == 1)
   \   00000006   0x....             LDR.N    R4,??DataTable134_5
   \   00000008   0xF894 0x0100      LDRB     R0,[R4, #+256]
   \   0000000C   0x2801             CMP      R0,#+1
   \   0000000E   0xD104             BNE.N    ??do_probe_move_0
   2621                {if (set_bltouch_deployed(true)) return true;}
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD123             BNE.N    ??do_probe_move_1
   2622              //#endif
   2623          
   2624              #if QUIET_PROBING
   2625                probing_pause(true);
   2626              #endif
   2627          
   2628              // Move down until probe triggered
   2629              do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
   \                     ??do_probe_move_0: (+1)
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x....             LDR.N    R1,??DataTable134_6  ;; 0x42700000
   \   0000001E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000022   0x9000             STR      R0,[SP, #+0]
   \   00000024   0xA900             ADD      R1,SP,#+0
   \   00000026   0xA802             ADD      R0,SP,#+8
   \   00000028   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2630             /*
   2631              // Check to see if the probe was triggered
   2632              const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
   2633                #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   2634                  Z_MIN
   2635                #else
   2636                  Z_MIN_PROBE
   2637                #endif
   2638              );
   2639              */
   2640                bool probe_triggered;
   2641                if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
   \   0000002C   0x.... 0x....      LDR.W    R0,??DataTable148
   \   00000030   0xF894 0x1099      LDRB     R1,[R4, #+153]
   \   00000034   0x2902             CMP      R1,#+2
   \   00000036   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0xD003             BEQ.N    ??do_probe_move_2
   2642                {
   2643                  probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN);
   \   0000003E   0x0880             LSRS     R0,R0,#+2
   \   00000040   0xF000 0x0501      AND      R5,R0,#0x1
   \   00000044   0xE002             B.N      ??do_probe_move_3
   2644                }
   2645                else
   2646                {
   2647                  probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN_PROBE);
   \                     ??do_probe_move_2: (+1)
   \   00000046   0x08C0             LSRS     R0,R0,#+3
   \   00000048   0xF000 0x0501      AND      R5,R0,#0x1
   2648                }
   2649          
   2650              #if QUIET_PROBING
   2651                probing_pause(false);
   2652              #endif
   2653          
   2654              // Retract BLTouch immediately after a probe if it was triggered
   2655              //#if ENABLED(BLTOUCH)
   2656              if(MKSTOUCH == 1)
   \                     ??do_probe_move_3: (+1)
   \   0000004C   0xF894 0x0100      LDRB     R0,[R4, #+256]
   \   00000050   0x2801             CMP      R0,#+1
   \   00000052   0xD108             BNE.N    ??do_probe_move_4
   2657                {if (probe_triggered && set_bltouch_deployed(false)) return true;}
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD006             BEQ.N    ??do_probe_move_4
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD001             BEQ.N    ??do_probe_move_4
   \                     ??do_probe_move_1: (+1)
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0xBD3E             POP      {R1-R5,PC}
   2658              //#endif
   2659          
   2660              // Clear endstop flags
   2661              endstops.hit_on_purpose();
   \                     ??do_probe_move_4: (+1)
   \   00000066   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   2662          
   2663              // Get Z where the steppers were interrupted
   2664              set_current_from_steppers_for_axis(Z_AXIS);
   \   0000006A   0x2002             MOVS     R0,#+2
   \   0000006C   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   2665          
   2666              // Tell the planner where we actually are
   2667              SYNC_PLAN_POSITION_KINEMATIC();
   \   00000070   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   2668          
   2669              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2670                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
   2671              #endif
   2672          
   2673              return !probe_triggered;
   \   00000074   0xF085 0x0001      EOR      R0,R5,#0x1
   \   00000078   0xBD3E             POP      {R1-R5,PC}       ;; return
   2674            }
   2675          
   2676            /**
   2677             * @details Used by probe_pt to do a single Z probe at the current position.
   2678             *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
   2679             *
   2680             * @return The raw Z position where the probe was triggered
   2681             */

   \                                 In section .text, align 2, keep-with-next
   2682            static float run_z_probe() {
   \                     _Z11run_z_probev: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   2683          
   2684              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2685                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
   2686              #endif
   2687          
   2688              // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
   2689              refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   2690          
   2691              // Double-probing does a fast probe followed by a slow probe
   2692              #if MULTIPLE_PROBING == 2
   2693          
   2694                // Do a first probe at the fast speed
   2695                if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
   2696          
   2697                float first_probe_z = current_position[Z_AXIS];
   2698          
   2699                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2700                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
   2701                #endif
   2702          
   2703                // move up to make clearance for the probe
   2704                do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2705          
   2706              #else
   2707          
   2708                // If the nozzle is above the travel height then
   2709                // move down quickly before doing the slow probe
   2710                float z = Z_CLEARANCE_DEPLOY_PROBE;
   \   00000008   0x....             LDR.N    R4,??DataTable134_5
   \   0000000A   0x6E62             LDR      R2,[R4, #+100]
   2711                if (zprobe_zoffset < 0) z -= zprobe_zoffset;
   \   0000000C   0x....             LDR.N    R5,??DataTable134_4
   \   0000000E   0x6F2B             LDR      R3,[R5, #+112]
   \   00000010   0x4618             MOV      R0,R3
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000018   0xD204             BCS.N    ??run_z_probe_0
   \   0000001A   0x4610             MOV      R0,R2
   \   0000001C   0x4619             MOV      R1,R3
   \   0000001E   0x.... 0x....      BL       __aeabi_fsub
   \   00000022   0x4602             MOV      R2,R0
   2712          
   2713                if (z < current_position[Z_AXIS]) {
   \                     ??run_z_probe_0: (+1)
   \   00000024   0x4610             MOV      R0,R2
   \   00000026   0x6929             LDR      R1,[R5, #+16]
   \   00000028   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002C   0xD212             BCS.N    ??run_z_probe_1
   2714          
   2715                  // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
   2716                  if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
   \   0000002E   0x6FA1             LDR      R1,[R4, #+120]
   \   00000030   0x.... 0x....      BL       _Z13do_probe_moveff
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD10D             BNE.N    ??run_z_probe_1
   2717                    do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   \   00000038   0x6929             LDR      R1,[R5, #+16]
   \   0000003A   0x6EA0             LDR      R0,[R4, #+104]
   \   0000003C   0x.... 0x....      BL       __aeabi_fadd
   \   00000040   0x9001             STR      R0,[SP, #+4]
   \   00000042   0x6FA0             LDR      R0,[R4, #+120]
   \   00000044   0x....             LDR.N    R1,??DataTable134_6  ;; 0x42700000
   \   00000046   0x.... 0x....      BL       __aeabi_fdiv
   \   0000004A   0x9000             STR      R0,[SP, #+0]
   \   0000004C   0xA900             ADD      R1,SP,#+0
   \   0000004E   0xA801             ADD      R0,SP,#+4
   \   00000050   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   2718                }
   2719              #endif
   2720          
   2721              #if MULTIPLE_PROBING > 2
   2722                float probes_total = 0;
   2723                for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
   2724              #endif
   2725          
   2726                  // move down slowly to find bed
   2727                  if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
   \                     ??run_z_probe_1: (+1)
   \   00000054   0x6FE1             LDR      R1,[R4, #+124]
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable149  ;; 0xc1200000
   \   0000005A   0x.... 0x....      BL       _Z13do_probe_moveff
   \   0000005E   0x2800             CMP      R0,#+0
   \   00000060   0xD002             BEQ.N    ??run_z_probe_2
   \   00000062   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000066   0xBD3E             POP      {R1-R5,PC}
   2728          
   2729              #if MULTIPLE_PROBING > 2
   2730                  probes_total += current_position[Z_AXIS];
   2731                  if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   2732                }
   2733              #endif
   2734          
   2735              #if MULTIPLE_PROBING > 2
   2736          
   2737                // Return the average value of all probes
   2738                return probes_total * (1.0 / (MULTIPLE_PROBING));
   2739          
   2740              #elif MULTIPLE_PROBING == 2
   2741          
   2742                const float z2 = current_position[Z_AXIS];
   2743          
   2744                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2745                  if (DEBUGGING(LEVELING)) {
   2746                    SERIAL_ECHOPAIR("2nd Probe Z:", z2);
   2747                    SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
   2748                  }
   2749                #endif
   2750          
   2751                // Return a weighted average of the fast and slow probes
   2752                return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
   2753          
   2754              #else
   2755          
   2756                // Return the single probe result
   2757                return current_position[Z_AXIS];
   \                     ??run_z_probe_2: (+1)
   \   00000068   0x6928             LDR      R0,[R5, #+16]
   \   0000006A   0xBD3E             POP      {R1-R5,PC}       ;; return
   2758          
   2759              #endif
   2760          
   2761              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2762                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
   2763              #endif
   2764            }
   2765          
   2766            /**
   2767             * - Move to the given XY
   2768             * - Deploy the probe, if not already deployed
   2769             * - Probe the bed, get the Z position
   2770             * - Depending on the 'stow' flag
   2771             *   - Stow the probe, or
   2772             *   - Raise to the BETWEEN height
   2773             * - Return the probed Z position
   2774             */

   \                                 In section .text, align 2, keep-with-next
   2775            float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
   \                     _Z8probe_ptRKfS0_bhb: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4680             MOV      R8,R0
   \   00000008   0x460C             MOV      R4,R1
   \   0000000A   0x4617             MOV      R7,R2
   \   0000000C   0x4699             MOV      R9,R3
   2776              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2777                if (DEBUGGING(LEVELING)) {
   2778                  SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
   2779                  SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
   2780                  SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
   2781                  SERIAL_ECHOLNPGM("stow)");
   2782                  DEBUG_POS("", current_position);
   2783                }
   2784              #endif
   2785          
   2786              // TODO: Adapt for SCARA, where the offset rotates
   2787              float nx = rx, ny = ry;
   \   0000000E   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000012   0x9002             STR      R0,[SP, #+8]
   \   00000014   0x6820             LDR      R0,[R4, #+0]
   \   00000016   0x9001             STR      R0,[SP, #+4]
   2788              if (probe_relative) {
   \   00000018   0x.... 0x....      LDR.W    R10,??DataTable149_1
   \   0000001C   0xF9BA 0x1058      LDRSH    R1,[R10, #+88]
   \   00000020   0xF240 0x3202      MOVW     R2,#+770
   \   00000024   0x9810             LDR      R0,[SP, #+64]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD025             BEQ.N    ??probe_pt_0
   2789                if(MACHINETPYE & IS_KINEMATIC)
   \   0000002A   0x4211             TST      R1,R2
   \   0000002C   0x4621             MOV      R1,R4
   \   0000002E   0x4640             MOV      R0,R8
   \   00000030   0xD004             BEQ.N    ??probe_pt_1
   2790                {
   2791                  if (!position_is_reachable_by_probe_IS_KINEMATIC(rx, ry)) return NAN;  // The given position is in terms of the probe
   \   00000032   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD104             BNE.N    ??probe_pt_2
   \   0000003A   0xE029             B.N      ??probe_pt_3
   2792                }
   2793                else
   2794                {
   2795                  if (!position_is_reachable_by_probe_IS_CARTESIAN(rx, ry)) return NAN;  // The given position is in terms of the probe
   \                     ??probe_pt_1: (+1)
   \   0000003C   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD025             BEQ.N    ??probe_pt_3
   2796                }
   2797                nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
   \                     ??probe_pt_2: (+1)
   \   00000044   0x9802             LDR      R0,[SP, #+8]
   \   00000046   0xF8DA 0x106C      LDR      R1,[R10, #+108]
   \   0000004A   0x.... 0x....      BL       __aeabi_fsub
   \   0000004E   0x9002             STR      R0,[SP, #+8]
   2798                ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
   \   00000050   0x9801             LDR      R0,[SP, #+4]
   \   00000052   0xF8DA 0x1070      LDR      R1,[R10, #+112]
   \   00000056   0x.... 0x....      BL       __aeabi_fsub
   \   0000005A   0x9001             STR      R0,[SP, #+4]
   2799              }
   2800              else
   2801              {
   2802                  if(MACHINETPYE & IS_KINEMATIC)
   2803                  {
   2804                      if (!position_is_reachable_IS_KINEMATIC(nx, ny)) return NAN;        // The given position is in terms of the nozzle
   2805                  }
   2806                  else
   2807                  {
   2808                      if (!position_is_reachable_IS_CARTESIAN(nx, ny)) return NAN;        // The given position is in terms of the nozzle            
   2809                  }
   2810               }
   2811              //const 
   2812                  float nz;/* =
   2813                #if ENABLED(DELTA)
   2814                  // Move below clip height or xy move will be aborted by do_blocking_move_to
   2815                  min(current_position[Z_AXIS], delta_clip_start_height)
   2816                #else
   2817                  current_position[Z_AXIS]
   2818                #endif
   2819              ;
   2820              */
   2821              if(MACHINETPYE ==  DELTA)
   \                     ??probe_pt_4: (+1)
   \   0000005C   0x.... 0x....      LDR.W    R5,??DataTable149_2
   \   00000060   0x6928             LDR      R0,[R5, #+16]
   \   00000062   0xF9BA 0x1058      LDRSH    R1,[R10, #+88]
   \   00000066   0x2902             CMP      R1,#+2
   \   00000068   0xD117             BNE.N    ??probe_pt_5
   2822              {
   2823                  nz = min(current_position[Z_AXIS], delta_clip_start_height);
   \   0000006A   0x6FE9             LDR      R1,[R5, #+124]
   \   0000006C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000070   0xD211             BCS.N    ??probe_pt_6
   \   00000072   0x9003             STR      R0,[SP, #+12]
   \   00000074   0xE012             B.N      ??probe_pt_7
   2824              }
   \                     ??probe_pt_0: (+1)
   \   00000076   0x4211             TST      R1,R2
   \   00000078   0xA901             ADD      R1,SP,#+4
   \   0000007A   0xA802             ADD      R0,SP,#+8
   \   0000007C   0xD004             BEQ.N    ??probe_pt_8
   \   0000007E   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD1EA             BNE.N    ??probe_pt_4
   \   00000086   0xE003             B.N      ??probe_pt_3
   \                     ??probe_pt_8: (+1)
   \   00000088   0x.... 0x....      BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD1E5             BNE.N    ??probe_pt_4
   \                     ??probe_pt_3: (+1)
   \   00000090   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000094   0xE084             B.N      ??probe_pt_9
   \                     ??probe_pt_6: (+1)
   \   00000096   0x9103             STR      R1,[SP, #+12]
   \   00000098   0xE000             B.N      ??probe_pt_7
   2825              else
   2826              {
   2827                  nz = current_position[Z_AXIS];
   \                     ??probe_pt_5: (+1)
   \   0000009A   0x9003             STR      R0,[SP, #+12]
   2828              }
   2829              const float old_feedrate_mm_s = feedrate_mm_s;
   \                     ??probe_pt_7: (+1)
   \   0000009C   0x6DE8             LDR      R0,[R5, #+92]
   \   0000009E   0x9005             STR      R0,[SP, #+20]
   2830              feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
   \   000000A0   0x6F68             LDR      R0,[R5, #+116]
   \   000000A2   0x65E8             STR      R0,[R5, #+92]
   2831          
   2832              // Move the probe to the starting XYZ
   2833              do_blocking_move_to(nx, ny, nz);
   \   000000A4   0x2000             MOVS     R0,#+0
   \   000000A6   0x9000             STR      R0,[SP, #+0]
   \   000000A8   0xAB00             ADD      R3,SP,#+0
   \   000000AA   0xAA03             ADD      R2,SP,#+12
   \   000000AC   0xA901             ADD      R1,SP,#+4
   \   000000AE   0xA802             ADD      R0,SP,#+8
   \   000000B0   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   2834          
   2835              float measured_z = NAN;
   \   000000B4   0xF06F 0x4B00      MVN      R11,#-2147483648
   \   000000B8   0x465E             MOV      R6,R11
   2836              if (!DEPLOY_PROBE()) {
   \   000000BA   0x2001             MOVS     R0,#+1
   \   000000BC   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   000000C0   0x2800             CMP      R0,#+0
   \   000000C2   0xD120             BNE.N    ??probe_pt_10
   2837                measured_z = run_z_probe() + zprobe_zoffset;
   \   000000C4   0x.... 0x....      BL       _Z11run_z_probev
   \   000000C8   0x4601             MOV      R1,R0
   \   000000CA   0x6F28             LDR      R0,[R5, #+112]
   \   000000CC   0x.... 0x....      BL       __aeabi_fadd
   \   000000D0   0x4606             MOV      R6,R0
   2838          
   2839                if (!stow)
   \   000000D2   0x2F00             CMP      R7,#+0
   \   000000D4   0xD111             BNE.N    ??probe_pt_11
   2840                  do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
   \   000000D6   0x6929             LDR      R1,[R5, #+16]
   \   000000D8   0xF8DA 0x0068      LDR      R0,[R10, #+104]
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x9004             STR      R0,[SP, #+16]
   \   000000E2   0xF8DA 0x0078      LDR      R0,[R10, #+120]
   \   000000E6   0x.... 0x....      LDR.W    R1,??DataTable150  ;; 0x42700000
   \   000000EA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000EE   0x9000             STR      R0,[SP, #+0]
   \   000000F0   0xA900             ADD      R1,SP,#+0
   \   000000F2   0xA804             ADD      R0,SP,#+16
   \   000000F4   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   000000F8   0xE005             B.N      ??probe_pt_10
   2841                else
   2842                  if (STOW_PROBE()) measured_z = NAN;
   \                     ??probe_pt_11: (+1)
   \   000000FA   0x2000             MOVS     R0,#+0
   \   000000FC   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   00000100   0x2800             CMP      R0,#+0
   \   00000102   0xD000             BEQ.N    ??probe_pt_10
   \   00000104   0x465E             MOV      R6,R11
   2843              }
   2844          
   2845              if (verbose_level > 2) {
   \                     ??probe_pt_10: (+1)
   \   00000106   0xF1B9 0x0F03      CMP      R9,#+3
   \   0000010A   0xDB35             BLT.N    ??probe_pt_12
   2846                SERIAL_PROTOCOLPGM("Bed X: ");
   \   0000010C   0x.... 0x....      ADR.W    R0,`?<Constant "Bed X: ">`
   \   00000110   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2847                SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
   \   00000114   0x....             LDR.N    R7,??DataTable137_4
   \   00000116   0x2003             MOVS     R0,#+3
   \   00000118   0x9000             STR      R0,[SP, #+0]
   \   0000011A   0xF8D8 0x1000      LDR      R1,[R8, #+0]
   \   0000011E   0x6BA8             LDR      R0,[R5, #+56]
   \   00000120   0x.... 0x....      BL       __aeabi_fadd
   \   00000124   0x.... 0x....      BL       __aeabi_f2d
   \   00000128   0x4602             MOV      R2,R0
   \   0000012A   0x460B             MOV      R3,R1
   \   0000012C   0x4638             MOV      R0,R7
   \   0000012E   0x.... 0x....      BL       _ZN5Print5printEdi
   2848                SERIAL_PROTOCOLPGM(" Y: ");
   \   00000132   0x.... 0x....      ADR.W    R0,`?<Constant " Y: ">`
   \   00000136   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2849                SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
   \   0000013A   0x2003             MOVS     R0,#+3
   \   0000013C   0x9000             STR      R0,[SP, #+0]
   \   0000013E   0x6821             LDR      R1,[R4, #+0]
   \   00000140   0x6BE8             LDR      R0,[R5, #+60]
   \   00000142   0x.... 0x....      BL       __aeabi_fadd
   \   00000146   0x.... 0x....      BL       __aeabi_f2d
   \   0000014A   0x4602             MOV      R2,R0
   \   0000014C   0x460B             MOV      R3,R1
   \   0000014E   0x4638             MOV      R0,R7
   \   00000150   0x.... 0x....      BL       _ZN5Print5printEdi
   2850                SERIAL_PROTOCOLPGM(" Z: ");
   \   00000154   0x.... 0x....      ADR.W    R0,`?<Constant " Z: ">`
   \   00000158   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2851                SERIAL_PROTOCOL_F(measured_z, 3);
   \   0000015C   0x2003             MOVS     R0,#+3
   \   0000015E   0x9000             STR      R0,[SP, #+0]
   \   00000160   0x4630             MOV      R0,R6
   \   00000162   0x.... 0x....      BL       __aeabi_f2d
   \   00000166   0x4602             MOV      R2,R0
   \   00000168   0x460B             MOV      R3,R1
   \   0000016A   0x4638             MOV      R0,R7
   \   0000016C   0x.... 0x....      BL       _ZN5Print5printEdi
   2852                SERIAL_EOL();
   \   00000170   0x210A             MOVS     R1,#+10
   \   00000172   0x4638             MOV      R0,R7
   \   00000174   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   2853              }
   2854          
   2855              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2856                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
   2857              #endif
   2858          
   2859              feedrate_mm_s = old_feedrate_mm_s;
   \                     ??probe_pt_12: (+1)
   \   00000178   0x9805             LDR      R0,[SP, #+20]
   \   0000017A   0x65E8             STR      R0,[R5, #+92]
   2860          
   2861              if (isnan(measured_z)) {
   \   0000017C   0x4630             MOV      R0,R6
   \   0000017E   0x.... 0x....      BL       __iar_FDtest
   \   00000182   0x2802             CMP      R0,#+2
   \   00000184   0xD10B             BNE.N    ??probe_pt_13
   2862                LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
   \   00000186   0x2100             MOVS     R1,#+0
   \   00000188   0x.... 0x....      ADR.W    R0,`?<Constant "Probing failed">`
   \   0000018C   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   2863                SERIAL_ERROR_START();
   \   00000190   0x....             LDR.N    R0,??DataTable137_5
   \   00000192   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2864                SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
   \   00000196   0x.... 0x....      ADR.W    R0,`?<Constant "Probing failed\\n">`
   \   0000019A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   2865              }
   2866          
   2867              return measured_z;
   \                     ??probe_pt_13: (+1)
   \   0000019E   0x4630             MOV      R0,R6
   \                     ??probe_pt_9: (+1)
   \   000001A0   0xB007             ADD      SP,SP,#+28
   \   000001A2   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   2868            }
   2869          
   2870          #endif // HAS_BED_PROBE
   2871          
   2872          #if 1//HAS_LEVELING
   2873          

   \                                 In section .text, align 2, keep-with-next
   2874            bool leveling_is_valid() {
   \                     _Z17leveling_is_validv: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable149_1
   \   00000004   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000008   0x2820             CMP      R0,#+32
   \   0000000A   0xD103             BNE.N    ??leveling_is_valid_0
   2875            /*
   2876              return
   2877                #if ENABLED(MESH_BED_LEVELING)
   2878                  mbl.has_mesh
   2879                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2880                  !!bilinear_grid_spacing[X_AXIS]
   2881                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   2882                  true
   2883                #else // 3POINT, LINEAR
   2884                  true
   2885                #endif
   2886              ;
   2887              */
   2888                if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   2889                  return mbl.has_mesh;
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable151
   \   00000010   0x7800             LDRB     R0,[R0, #+0]
   \   00000012   0x4770             BX       LR
   2890                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??leveling_is_valid_0: (+1)
   \   00000014   0x2808             CMP      R0,#+8
   \   00000016   0xD106             BNE.N    ??leveling_is_valid_1
   2891                  return !!bilinear_grid_spacing[X_AXIS];
   \   00000018   0x....             LDR.N    R0,??DataTable139
   \   0000001A   0x6900             LDR      R0,[R0, #+16]
   \   0000001C   0x1E40             SUBS     R0,R0,#+1
   \   0000001E   0x4180             SBCS     R0,R0,R0
   \   00000020   0x43C0             MVNS     R0,R0
   \   00000022   0x0FC0             LSRS     R0,R0,#+31
   \   00000024   0x4770             BX       LR
   2892                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??leveling_is_valid_1: (+1)
   \   00000026   0x2810             CMP      R0,#+16
   \   00000028   0xD101             BNE.N    ??leveling_is_valid_2
   2893                  return true;
   \   0000002A   0x2001             MOVS     R0,#+1
   \   0000002C   0x4770             BX       LR
   2894                else
   2895                  return true;
   \                     ??leveling_is_valid_2: (+1)
   \   0000002E   0x2001             MOVS     R0,#+1
   \   00000030   0x4770             BX       LR               ;; return
   2896            }
   2897          
   2898            /**
   2899             * Turn bed leveling on or off, fixing the current
   2900             * position as-needed.
   2901             *
   2902             * Disable: Current position = physical position
   2903             *  Enable: Current position = "unleveled" physical position
   2904             */

   \                                 In section .text, align 2, keep-with-next
   2905            void set_bed_leveling_enabled(const bool enable/*=true*/) {
   \                     _Z24set_bed_leveling_enabledb: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x4605             MOV      R5,R0
   2906              bool can_change;
   2907          /*
   2908              #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2909                const bool can_change = (!enable || leveling_is_valid());
   2910              #else
   2911                constexpr bool can_change = true;
   2912              #endif
   2913          */
   2914              if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \   00000008   0x.... 0x....      LDR.W    R6,??DataTable149_1
   \   0000000C   0xF896 0x7040      LDRB     R7,[R6, #+64]
   \   00000010   0x46B8             MOV      R8,R7
   \   00000012   0xF1B8 0x0F08      CMP      R8,#+8
   \   00000016   0xD106             BNE.N    ??set_bed_leveling_enabled_0
   2915                  can_change = (!enable || leveling_is_valid());
   \   00000018   0x2D00             CMP      R5,#+0
   \   0000001A   0xD002             BEQ.N    ??set_bed_leveling_enabled_1
   \   0000001C   0x.... 0x....      BL       _Z17leveling_is_validv
   \   00000020   0xE002             B.N      ??set_bed_leveling_enabled_2
   \                     ??set_bed_leveling_enabled_1: (+1)
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0xE000             B.N      ??set_bed_leveling_enabled_2
   2916              else
   2917                  can_change = true;
   \                     ??set_bed_leveling_enabled_0: (+1)
   \   00000026   0x2001             MOVS     R0,#+1
   2918                  
   2919              if (can_change && enable != planner.leveling_active) {
   \                     ??set_bed_leveling_enabled_2: (+1)
   \   00000028   0x2800             CMP      R0,#+0
   \   0000002A   0xD060             BEQ.N    ??set_bed_leveling_enabled_3
   \   0000002C   0x.... 0x....      LDR.W    R4,??DataTable151_1
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x4285             CMP      R5,R0
   \   00000034   0xD05B             BEQ.N    ??set_bed_leveling_enabled_3
   2920          
   2921                //#if ENABLED(MESH_BED_LEVELING)
   2922                if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \   00000036   0xF1B8 0x0F20      CMP      R8,#+32
   \   0000003A   0xD119             BNE.N    ??set_bed_leveling_enabled_4
   2923                {
   2924                  if (!enable)
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD109             BNE.N    ??set_bed_leveling_enabled_5
   2925                    planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   \   00000040   0x.... 0x....      LDR.W    R3,??DataTable149_2
   \   00000044   0xF103 0x0210      ADD      R2,R3,#+16
   \   00000048   0xF103 0x010C      ADD      R1,R3,#+12
   \   0000004C   0xF103 0x0008      ADD      R0,R3,#+8
   \   00000050   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   2926          
   2927                  const bool enabling = enable && leveling_is_valid();
   \                     ??set_bed_leveling_enabled_5: (+1)
   \   00000054   0x2D00             CMP      R5,#+0
   \   00000056   0xD002             BEQ.N    ??set_bed_leveling_enabled_6
   \   00000058   0x.... 0x....      BL       _Z17leveling_is_validv
   \   0000005C   0xE000             B.N      ??set_bed_leveling_enabled_7
   \                     ??set_bed_leveling_enabled_6: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   2928                  planner.leveling_active = enabling;
   \                     ??set_bed_leveling_enabled_7: (+1)
   \   00000060   0x7020             STRB     R0,[R4, #+0]
   2929                  if (enabling) planner.unapply_leveling(current_position);
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD043             BEQ.N    ??set_bed_leveling_enabled_3
   \   00000066   0x.... 0x....      LDR.W    R0,??DataTable152
   \   0000006A   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   \   0000006E   0xE03E             B.N      ??set_bed_leveling_enabled_3
   2930                }
   2931                //#elif ENABLED(AUTO_BED_LEVELING_UBL)
   2932                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \                     ??set_bed_leveling_enabled_4: (+1)
   \   00000070   0xF1B8 0x0F10      CMP      R8,#+16
   \   00000074   0xD11A             BNE.N    ??set_bed_leveling_enabled_8
   2933                {
   2934                  //#if PLANNER_LEVELING
   2935                  if(BED_LEVELING_METHOD&ABL_PLANAR)
   \   00000076   0x2106             MOVS     R1,#+6
   \   00000078   0x420F             TST      R7,R1
   \   0000007A   0xD015             BEQ.N    ??set_bed_leveling_enabled_9
   2936                  {
   2937                    if (planner.leveling_active) {                       // leveling from on to off
   \   0000007C   0x.... 0x....      LDR.W    R3,??DataTable149_2
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD00A             BEQ.N    ??set_bed_leveling_enabled_10
   2938                      // change unleveled current_position to physical current_position without moving steppers.
   2939                      planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
   \   00000084   0xF103 0x0210      ADD      R2,R3,#+16
   \   00000088   0xF103 0x010C      ADD      R1,R3,#+12
   \   0000008C   0xF103 0x0008      ADD      R0,R3,#+8
   \   00000090   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
   2940                      planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
   \   00000094   0x2000             MOVS     R0,#+0
   \   00000096   0x7020             STRB     R0,[R4, #+0]
   \   00000098   0xE029             B.N      ??set_bed_leveling_enabled_3
   2941                    }
   2942                    else {                                        // leveling from off to on
   2943                      planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
   \                     ??set_bed_leveling_enabled_10: (+1)
   \   0000009A   0x2001             MOVS     R0,#+1
   \   0000009C   0x7020             STRB     R0,[R4, #+0]
   2944                      // change physical current_position to unleveled current_position without moving steppers.
   2945                      planner.unapply_leveling(current_position);
   \   0000009E   0xF103 0x0008      ADD      R0,R3,#+8
   \   000000A2   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   \   000000A6   0xE022             B.N      ??set_bed_leveling_enabled_3
   2946                    }
   2947                  }
   2948                  //#else
   2949                  else
   2950                    planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
   \                     ??set_bed_leveling_enabled_9: (+1)
   \   000000A8   0x7025             STRB     R5,[R4, #+0]
   \   000000AA   0xE020             B.N      ??set_bed_leveling_enabled_3
   2951                  //#endif
   2952                }
   2953                //#else // ABL
   2954                else
   2955                {
   2956                  //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   2957                  if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
   \                     ??set_bed_leveling_enabled_8: (+1)
   \   000000AC   0xF1B8 0x0F08      CMP      R8,#+8
   \   000000B0   0xD107             BNE.N    ??set_bed_leveling_enabled_11
   2958                  {
   2959                    // Force bilinear_z_offset to re-calculate next time
   2960                    const float reset[XYZ] = { -9999.999, -9999.999, 0 };
   \   000000B2   0xA800             ADD      R0,SP,#+0
   \   000000B4   0x.... 0x....      ADR.W    R1,`?<Constant {(-9.9999990233E+3F), (-9.999999023`
   \   000000B8   0xC98C             LDM      R1!,{R2,R3,R7}
   \   000000BA   0xC08C             STM      R0!,{R2,R3,R7}
   2961                    (void)bilinear_z_offset(reset);
   \   000000BC   0xA800             ADD      R0,SP,#+0
   \   000000BE   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   2962                  }
   2963                  //#endif
   2964          
   2965                  // Enable or disable leveling compensation in the planner
   2966                  planner.leveling_active = enable;
   \                     ??set_bed_leveling_enabled_11: (+1)
   \   000000C2   0x7025             STRB     R5,[R4, #+0]
   2967          
   2968                  if (!enable)
   \   000000C4   0x2D00             CMP      R5,#+0
   \   000000C6   0xD10C             BNE.N    ??set_bed_leveling_enabled_12
   2969                      /*
   2970                    // When disabling just get the current position from the steppers.
   2971                    // This will yield the smallest error when first converted back to steps.
   2972                    set_current_from_steppers_for_axis(
   2973                      #if ABL_PLANAR
   2974                        ALL_AXES
   2975                      #else
   2976                        Z_AXIS
   2977                      #endif
   2978                    );
   2979                    */
   2980                  {
   2981                      if(BED_LEVELING_METHOD&ABL_PLANAR)
   \   000000C8   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   000000CC   0x2106             MOVS     R1,#+6
   \   000000CE   0x4208             TST      R0,R1
   \   000000D0   0xD003             BEQ.N    ??set_bed_leveling_enabled_13
   2982                          set_current_from_steppers_for_axis(ALL_AXES);
   \   000000D2   0x2064             MOVS     R0,#+100
   \   000000D4   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \   000000D8   0xE007             B.N      ??set_bed_leveling_enabled_14
   2983                      else
   2984                          set_current_from_steppers_for_axis(Z_AXIS);
   \                     ??set_bed_leveling_enabled_13: (+1)
   \   000000DA   0x2002             MOVS     R0,#+2
   \   000000DC   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \   000000E0   0xE003             B.N      ??set_bed_leveling_enabled_14
   2985                  }
   2986                  else
   2987                    // When enabling, remove compensation from the current position,
   2988                    // so compensation will give the right stepper counts.
   2989                    planner.unapply_leveling(current_position);
   \                     ??set_bed_leveling_enabled_12: (+1)
   \   000000E2   0x.... 0x....      LDR.W    R0,??DataTable152
   \   000000E6   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   2990          
   2991                  SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??set_bed_leveling_enabled_14: (+1)
   \   000000EA   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   2992                }
   2993                //#endif // ABL
   2994              }
   2995            }
   \                     ??set_bed_leveling_enabled_3: (+1)
   \   000000EE   0xE8BD 0x81FF      POP      {R0-R8,PC}       ;; return
   2996          
   2997            #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   2998          

   \                                 In section .text, align 2, keep-with-next
   2999              void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
   \                     _Z17set_z_fade_heightfb: (+1)
   \   00000000   0xB571             PUSH     {R0,R4-R6,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x460C             MOV      R4,R1
   3000          
   3001                if (planner.z_fade_height == zfh) return; // do nothing if no change
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable152_1
   \   0000000A   0x6800             LDR      R0,[R0, #+0]
   \   0000000C   0x9903             LDR      R1,[SP, #+12]
   \   0000000E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000012   0xD03A             BEQ.N    ??set_z_fade_height_0
   3002          
   3003                const bool level_active = planner.leveling_active;
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable151_1
   \   00000018   0x7806             LDRB     R6,[R0, #+0]
   3004          
   3005                //#if ENABLED(AUTO_BED_LEVELING_UBL)
   3006                if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
   \   0000001A   0x.... 0x....      LDR.W    R5,??DataTable149_1
   \   0000001E   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \   00000022   0x2810             CMP      R0,#+16
   \   00000024   0xD104             BNE.N    ??set_z_fade_height_1
   3007                  if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD002             BEQ.N    ??set_z_fade_height_1
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   3008                //#endif
   3009          
   3010                planner.set_z_fade_height(zfh);
   \                     ??set_z_fade_height_1: (+1)
   \   00000030   0xA803             ADD      R0,SP,#+12
   \   00000032   0x.... 0x....      BL       _ZN7Planner17set_z_fade_heightERKf
   3011          
   3012                if (level_active) {
   \   00000036   0x2E00             CMP      R6,#+0
   \   00000038   0xD027             BEQ.N    ??set_z_fade_height_0
   3013                  const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable149_2
   \   0000003E   0x68B0             LDR      R0,[R6, #+8]
   \   00000040   0x9000             STR      R0,[SP, #+0]
   \   00000042   0x68F0             LDR      R0,[R6, #+12]
   \   00000044   0x9001             STR      R0,[SP, #+4]
   \   00000046   0x6930             LDR      R0,[R6, #+16]
   \   00000048   0x9002             STR      R0,[SP, #+8]
   3014                  //#if ENABLED(AUTO_BED_LEVELING_UBL)
   3015                  if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
   \   0000004A   0xF895 0x0040      LDRB     R0,[R5, #+64]
   \   0000004E   0x2810             CMP      R0,#+16
   \   00000050   0xD103             BNE.N    ??set_z_fade_height_2
   3016                    set_bed_leveling_enabled(true);  // turn back on after changing fade height
   \   00000052   0x2001             MOVS     R0,#+1
   \   00000054   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \   00000058   0xE00B             B.N      ??set_z_fade_height_3
   3017                  //#else
   3018                  else
   3019                  {
   3020                  /*
   3021                    set_current_from_steppers_for_axis(
   3022                      #if ABL_PLANAR
   3023                        ALL_AXES
   3024                      #else
   3025                        Z_AXIS
   3026                      #endif
   3027                    );
   3028                      */
   3029                    if(BED_LEVELING_METHOD&ABL_PLANAR)
   \                     ??set_z_fade_height_2: (+1)
   \   0000005A   0x2106             MOVS     R1,#+6
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD003             BEQ.N    ??set_z_fade_height_4
   3030                    {
   3031                      set_current_from_steppers_for_axis(ALL_AXES);
   \   00000060   0x2064             MOVS     R0,#+100
   \   00000062   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   \   00000066   0xE002             B.N      ??set_z_fade_height_5
   3032                    }
   3033                    else
   3034                    {
   3035                      set_current_from_steppers_for_axis(Z_AXIS);
   \                     ??set_z_fade_height_4: (+1)
   \   00000068   0x2002             MOVS     R0,#+2
   \   0000006A   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
   3036                    }
   3037                      
   3038                    SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??set_z_fade_height_5: (+1)
   \   0000006E   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   3039                  }
   3040                  //#endif
   3041                  if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
   \                     ??set_z_fade_height_3: (+1)
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD009             BEQ.N    ??set_z_fade_height_0
   \   00000076   0x220C             MOVS     R2,#+12
   \   00000078   0xF106 0x0108      ADD      R1,R6,#+8
   \   0000007C   0xA800             ADD      R0,SP,#+0
   \   0000007E   0x.... 0x....      BL       memcmp
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD001             BEQ.N    ??set_z_fade_height_0
   3042                    report_current_position();
   \   00000086   0x.... 0x....      BL       _Z23report_current_positionv
   3043                }
   3044              }
   \                     ??set_z_fade_height_0: (+1)
   \   0000008A   0xBD7F             POP      {R0-R6,PC}       ;; return
   3045          
   3046            #endif // LEVELING_FADE_HEIGHT
   3047          
   3048            /**
   3049             * Reset calibration results to zero.
   3050             */

   \                                 In section .text, align 2, keep-with-next
   3051            void reset_bed_level() {
   \                     _Z15reset_bed_levelv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3052              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3053                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
   3054              #endif
   3055              set_bed_leveling_enabled(false);
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   3056              //#if ENABLED(MESH_BED_LEVELING)
   3057              if(BED_LEVELING_METHOD==MESH_BED_LEVELING)
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable149_1
   \   0000000C   0xF890 0x1040      LDRB     R1,[R0, #+64]
   \   00000010   0x460A             MOV      R2,R1
   \   00000012   0x2A20             CMP      R2,#+32
   \   00000014   0xD10A             BNE.N    ??reset_bed_level_0
   3058              {
   3059                if (leveling_is_valid()) {
   \   00000016   0x.... 0x....      BL       _Z17leveling_is_validv
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD037             BEQ.N    ??reset_bed_level_1
   3060                  mbl.reset();
   \   0000001E   0x.... 0x....      BL       _ZN17mesh_bed_leveling5resetEv
   3061                  mbl.has_mesh = false;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable151
   \   00000028   0x7008             STRB     R0,[R1, #+0]
   \   0000002A   0xBD10             POP      {R4,PC}
   3062                }
   3063              }
   3064              //#elif ENABLED(AUTO_BED_LEVELING_UBL)
   3065              else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
   \                     ??reset_bed_level_0: (+1)
   \   0000002C   0x2A10             CMP      R2,#+16
   \   0000002E   0xD103             BNE.N    ??reset_bed_level_2
   3066                ubl.reset();
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      _ZN20unified_bed_leveling5resetEv
   3067              //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   3068              else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
   \                     ??reset_bed_level_2: (+1)
   \   00000038   0x2A08             CMP      R2,#+8
   \   0000003A   0xD11F             BNE.N    ??reset_bed_level_3
   3069              {
   3070                bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
   3071                bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
   \   0000003C   0x....             LDR.N    R1,??DataTable139
   \   0000003E   0x2200             MOVS     R2,#+0
   \   00000040   0x614A             STR      R2,[R1, #+20]
   \   00000042   0x610A             STR      R2,[R1, #+16]
   \   00000044   0x61CA             STR      R2,[R1, #+28]
   \   00000046   0x618A             STR      R2,[R1, #+24]
   3072                for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   \   00000048   0x4611             MOV      R1,R2
   \   0000004A   0xE011             B.N      ??reset_bed_level_4
   3073                  for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   3074                    z_values[x][y] = NAN;
   \                     ??reset_bed_level_5: (+1)
   \   0000004C   0xEB01 0x0341      ADD      R3,R1,R1, LSL #+1
   \   00000050   0x.... 0x....      LDR.W    R4,??DataTable154
   \   00000054   0xEB04 0x1303      ADD      R3,R4,R3, LSL #+4
   \   00000058   0xF06F 0x4400      MVN      R4,#-2147483648
   \   0000005C   0xF843 0x4022      STR      R4,[R3, R2, LSL #+2]
   \   00000060   0x1C52             ADDS     R2,R2,#+1
   \                     ??reset_bed_level_6: (+1)
   \   00000062   0xF890 0x3061      LDRB     R3,[R0, #+97]
   \   00000066   0xB2D2             UXTB     R2,R2
   \   00000068   0x429A             CMP      R2,R3
   \   0000006A   0xD3EF             BCC.N    ??reset_bed_level_5
   \   0000006C   0x1C49             ADDS     R1,R1,#+1
   \   0000006E   0xB2C9             UXTB     R1,R1
   \                     ??reset_bed_level_4: (+1)
   \   00000070   0xF890 0x2060      LDRB     R2,[R0, #+96]
   \   00000074   0x4291             CMP      R1,R2
   \   00000076   0xDA0A             BGE.N    ??reset_bed_level_1
   \   00000078   0x2200             MOVS     R2,#+0
   \   0000007A   0xE7F2             B.N      ??reset_bed_level_6
   3075              }
   3076              //#elif ABL_PLANAR
   3077              else if(BED_LEVELING_METHOD&ABL_PLANAR)
   \                     ??reset_bed_level_3: (+1)
   \   0000007C   0x2006             MOVS     R0,#+6
   \   0000007E   0x4201             TST      R1,R0
   \   00000080   0xD005             BEQ.N    ??reset_bed_level_1
   3078                planner.bed_level_matrix.set_to_identity();
   \   00000082   0x.... 0x....      LDR.W    R0,??DataTable154_1
   \   00000086   0xE8BD 0x4010      POP      {R4,LR}
   \   0000008A   0x.... 0x....      B.W      _ZN10matrix_3x315set_to_identityEv
   3079              //#endif
   3080            }
   \                     ??reset_bed_level_1: (+1)
   \   0000008E   0xBD10             POP      {R4,PC}          ;; return
   3081          
   3082          #endif // HAS_LEVELING
   3083          
   3084          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
   3085          
   3086            /**
   3087             * Enable to produce output in JSON format suitable
   3088             * for SCAD or JavaScript mesh visualizers.
   3089             *
   3090             * Visualize meshes in OpenSCAD using the included script.
   3091             *
   3092             *   buildroot/shared/scripts/MarlinMesh.scad
   3093             */
   3094            //#define SCAD_MESH_OUTPUT
   3095          
   3096            /**
   3097             * Print calibration results for plotting or manual frame adjustment.
   3098             */
   3099            //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

   \                                 In section .text, align 2, keep-with-next
   3100              static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
   \                     _Z14print_2d_arrayhhhh: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x468A             MOV      R10,R1
   \   00000008   0x4614             MOV      R4,R2
   \   0000000A   0x4698             MOV      R8,R3
   3101              #ifndef SCAD_MESH_OUTPUT
   3102                for (uint8_t x = 0; x < sx; x++) {
   \   0000000C   0x2600             MOVS     R6,#+0
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable154_2
   \   00000012   0xE00C             B.N      ??print_2d_array_0
   3103                  for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
   \                     ??print_2d_array_1: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \                     ??print_2d_array_2: (+1)
   \   00000016   0xB2FF             UXTB     R7,R7
   \   00000018   0x1900             ADDS     R0,R0,R4
   \   0000001A   0x1C80             ADDS     R0,R0,#+2
   \   0000001C   0x4287             CMP      R7,R0
   \   0000001E   0xDB0A             BLT.N    ??print_2d_array_3
   3104                    SERIAL_PROTOCOLCHAR(' ');
   3105                  SERIAL_PROTOCOL((int)x);
   \   00000020   0x220A             MOVS     R2,#+10
   \   00000022   0x4631             MOV      R1,R6
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       _ZN5Print5printEii
   \   0000002A   0x1C76             ADDS     R6,R6,#+1
   \   0000002C   0xB2F6             UXTB     R6,R6
   \                     ??print_2d_array_0: (+1)
   \   0000002E   0x454E             CMP      R6,R9
   \   00000030   0xDA0A             BGE.N    ??print_2d_array_4
   \   00000032   0x2700             MOVS     R7,#+0
   \   00000034   0xE004             B.N      ??print_2d_array_5
   \                     ??print_2d_array_3: (+1)
   \   00000036   0x2120             MOVS     R1,#+32
   \   00000038   0x4628             MOV      R0,R5
   \   0000003A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000003E   0x1C7F             ADDS     R7,R7,#+1
   \                     ??print_2d_array_5: (+1)
   \   00000040   0x2E0A             CMP      R6,#+10
   \   00000042   0xDAE7             BGE.N    ??print_2d_array_1
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0xE7E6             B.N      ??print_2d_array_2
   3106                }
   3107                SERIAL_EOL();
   \                     ??print_2d_array_4: (+1)
   \   00000048   0x210A             MOVS     R1,#+10
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   3108              #endif
   3109              #ifdef SCAD_MESH_OUTPUT
   3110                SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
   3111              #endif
   3112              for (uint8_t y = 0; y < sy; y++) {
   \   00000050   0x2600             MOVS     R6,#+0
   \   00000052   0xE005             B.N      ??print_2d_array_6
   3113                #ifdef SCAD_MESH_OUTPUT
   3114                  SERIAL_PROTOCOLPGM(" [");           // open sub-array
   3115                #else
   3116                  if (y < 10) SERIAL_PROTOCOLCHAR(' ');
   3117                  SERIAL_PROTOCOL((int)y);
   3118                #endif
   3119                for (uint8_t x = 0; x < sx; x++) {
   3120                  SERIAL_PROTOCOLCHAR(' ');
   3121                  //const float offset = fn(x, y);
   3122                  float offset;
   3123          		switch(fn)
   3124          		{
   3125          			case 0:	
   3126          			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   3127          				offset =z_values[x][y];
   3128          			break;
   3129          			case 1:	
   3130          			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3131          				offset =z_values_virt[x][y];	
   3132          			#endif
   3133          			break;
   3134          			case 2:	
   3135          				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   3136                             offset =mbl.z_values[x][y];		
   3137                                    break;
   3138          			default:		break;
   3139          		}        
   3140                  if (!isnan(offset)) {
   3141                    if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
   3142                    SERIAL_PROTOCOL_F(offset, precision);
   3143                  }
   3144                  else {
   3145                    #ifdef SCAD_MESH_OUTPUT
   3146                      for (uint8_t i = 3; i < precision + 3; i++)
   3147                        SERIAL_PROTOCOLCHAR(' ');
   3148                      SERIAL_PROTOCOLPGM("NAN");
   3149                    #else
   3150                      for (uint8_t i = 0; i < precision + 3; i++)
   3151                        SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
   3152                    #endif
   3153                  }
   3154                  #ifdef SCAD_MESH_OUTPUT
   3155                    if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
   3156                  #endif
   3157                }
   3158                #ifdef SCAD_MESH_OUTPUT
   3159                  SERIAL_PROTOCOLCHAR(' ');
   3160                  SERIAL_PROTOCOLCHAR(']');                     // close sub-array
   3161                  if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
   3162                #endif
   3163                SERIAL_EOL();
   \                     ??print_2d_array_7: (+1)
   \   00000054   0x210A             MOVS     R1,#+10
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000005C   0x1C76             ADDS     R6,R6,#+1
   \   0000005E   0xB2F6             UXTB     R6,R6
   \                     ??print_2d_array_6: (+1)
   \   00000060   0x4556             CMP      R6,R10
   \   00000062   0xDA61             BGE.N    ??print_2d_array_8
   \   00000064   0x2E0A             CMP      R6,#+10
   \   00000066   0xDA03             BGE.N    ??print_2d_array_9
   \   00000068   0x2120             MOVS     R1,#+32
   \   0000006A   0x4628             MOV      R0,R5
   \   0000006C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_2d_array_9: (+1)
   \   00000070   0x220A             MOVS     R2,#+10
   \   00000072   0x4631             MOV      R1,R6
   \   00000074   0x4628             MOV      R0,R5
   \   00000076   0x.... 0x....      BL       _ZN5Print5printEii
   \   0000007A   0x2700             MOVS     R7,#+0
   \   0000007C   0xE026             B.N      ??print_2d_array_10
   \                     ??print_2d_array_11: (+1)
   \   0000007E   0x.... 0x....      LDR.W    R0,??DataTable149_1
   \   00000082   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000086   0x2820             CMP      R0,#+32
   \   00000088   0xD107             BNE.N    ??print_2d_array_12
   \   0000008A   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable154_5
   \   00000092   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   00000096   0xF850 0xB026      LDR      R11,[R0, R6, LSL #+2]
   \                     ??print_2d_array_12: (+1)
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x.... 0x....      BL       __iar_FDtest
   \   000000A0   0x2802             CMP      R0,#+2
   \   000000A2   0xD02E             BEQ.N    ??print_2d_array_13
   \   000000A4   0x4658             MOV      R0,R11
   \   000000A6   0x2100             MOVS     R1,#+0
   \   000000A8   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000AC   0xD803             BHI.N    ??print_2d_array_14
   \   000000AE   0x212B             MOVS     R1,#+43
   \   000000B0   0x4628             MOV      R0,R5
   \   000000B2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??print_2d_array_14: (+1)
   \   000000B6   0x9400             STR      R4,[SP, #+0]
   \   000000B8   0x4658             MOV      R0,R11
   \   000000BA   0x.... 0x....      BL       __aeabi_f2d
   \   000000BE   0x4602             MOV      R2,R0
   \   000000C0   0x460B             MOV      R3,R1
   \   000000C2   0x4628             MOV      R0,R5
   \   000000C4   0x.... 0x....      BL       _ZN5Print5printEdi
   \                     ??print_2d_array_15: (+1)
   \   000000C8   0x1C7F             ADDS     R7,R7,#+1
   \   000000CA   0xB2FF             UXTB     R7,R7
   \                     ??print_2d_array_10: (+1)
   \   000000CC   0x454F             CMP      R7,R9
   \   000000CE   0xDAC1             BGE.N    ??print_2d_array_7
   \   000000D0   0x2120             MOVS     R1,#+32
   \   000000D2   0x4628             MOV      R0,R5
   \   000000D4   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000000D8   0x4640             MOV      R0,R8
   \   000000DA   0x2800             CMP      R0,#+0
   \   000000DC   0xD002             BEQ.N    ??print_2d_array_16
   \   000000DE   0x2802             CMP      R0,#+2
   \   000000E0   0xD0CD             BEQ.N    ??print_2d_array_11
   \   000000E2   0xE7DA             B.N      ??print_2d_array_12
   \                     ??print_2d_array_16: (+1)
   \   000000E4   0x.... 0x....      LDR.W    R0,??DataTable149_1
   \   000000E8   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000000EC   0x2808             CMP      R0,#+8
   \   000000EE   0xD1D4             BNE.N    ??print_2d_array_12
   \   000000F0   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000000F4   0x.... 0x....      LDR.W    R1,??DataTable154
   \   000000F8   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   000000FC   0xF850 0xB026      LDR      R11,[R0, R6, LSL #+2]
   \   00000100   0xE7CB             B.N      ??print_2d_array_12
   \                     ??print_2d_array_13: (+1)
   \   00000102   0xF04F 0x0B00      MOV      R11,#+0
   \   00000106   0xE005             B.N      ??print_2d_array_17
   \                     ??print_2d_array_18: (+1)
   \   00000108   0x2120             MOVS     R1,#+32
   \                     ??print_2d_array_19: (+1)
   \   0000010A   0x4628             MOV      R0,R5
   \   0000010C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000110   0xF10B 0x0B01      ADD      R11,R11,#+1
   \                     ??print_2d_array_17: (+1)
   \   00000114   0xFA5F 0xFB8B      UXTB     R11,R11
   \   00000118   0x1CE0             ADDS     R0,R4,#+3
   \   0000011A   0x4583             CMP      R11,R0
   \   0000011C   0xDAD4             BGE.N    ??print_2d_array_15
   \   0000011E   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000122   0xD0F1             BEQ.N    ??print_2d_array_18
   \   00000124   0x213D             MOVS     R1,#+61
   \   00000126   0xE7F0             B.N      ??print_2d_array_19
   3164              }
   3165              #ifdef SCAD_MESH_OUTPUT
   3166                SERIAL_PROTOCOLPGM("];");                       // close 2D array
   3167              #endif
   3168              SERIAL_EOL();
   \                     ??print_2d_array_8: (+1)
   \   00000128   0x210A             MOVS     R1,#+10
   \   0000012A   0x4628             MOV      R0,R5
   \   0000012C   0xE8BD 0x4FF4      POP      {R2,R4-R11,LR}
   \   00000130   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   3169            }
   3170          
   3171          #endif
   3172          
   3173          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
   3174          
   3175            /**
   3176             * Extrapolate a single point from its neighbors
   3177             */

   \                                 In section .text, align 2, keep-with-next
   3178            static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
   \                     _Z21extrapolate_one_pointhhaa: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4682             MOV      R10,R0
   \   00000006   0x4689             MOV      R9,R1
   \   00000008   0x4617             MOV      R7,R2
   \   0000000A   0x4698             MOV      R8,R3
   3179              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3180                if (DEBUGGING(LEVELING)) {
   3181                  SERIAL_ECHOPGM("Extrapolate [");
   3182                  if (x < 10) SERIAL_CHAR(' ');
   3183                  SERIAL_ECHO((int)x);
   3184                  SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
   3185                  SERIAL_CHAR(' ');
   3186                  if (y < 10) SERIAL_CHAR(' ');
   3187                  SERIAL_ECHO((int)y);
   3188                  SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
   3189                  SERIAL_CHAR(']');
   3190                }
   3191              #endif
   3192              if (!isnan(z_values[x][y])) {
   \   0000000C   0x2530             MOVS     R5,#+48
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable154
   \   00000012   0xFB05 0x600A      MLA      R0,R5,R10,R6
   \   00000016   0x9000             STR      R0,[SP, #+0]
   \   00000018   0x464C             MOV      R4,R9
   \   0000001A   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000001E   0x.... 0x....      BL       __iar_FDtest
   \   00000022   0x2802             CMP      R0,#+2
   \   00000024   0xD16E             BNE.N    ??extrapolate_one_point_0
   3193                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3194                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
   3195                #endif
   3196                return;  // Don't overwrite good values.
   3197              }
   3198              SERIAL_EOL();
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable154_2
   \   0000002C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   3199          
   3200              // Get X neighbors, Y neighbors, and XY neighbors
   3201              const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
   \   00000030   0xEB07 0x020A      ADD      R2,R7,R10
   \   00000034   0xB2D2             UXTB     R2,R2
   \   00000036   0xEB08 0x0009      ADD      R0,R8,R9
   \   0000003A   0xB2C0             UXTB     R0,R0
   \   0000003C   0x18BB             ADDS     R3,R7,R2
   \   0000003E   0xB2DB             UXTB     R3,R3
   \   00000040   0xEB08 0x0100      ADD      R1,R8,R0
   \   00000044   0xB2C9             UXTB     R1,R1
   3202              float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
   \   00000046   0xFB05 0x6202      MLA      R2,R5,R2,R6
   \   0000004A   0xF852 0x7024      LDR      R7,[R2, R4, LSL #+2]
   \   0000004E   0xFB05 0x6303      MLA      R3,R5,R3,R6
   \   00000052   0xF853 0x5024      LDR      R5,[R3, R4, LSL #+2]
   3203                    b1 = z_values[x ][y1], b2 = z_values[x ][y2],
   \   00000056   0x9E00             LDR      R6,[SP, #+0]
   \   00000058   0xF856 0x6020      LDR      R6,[R6, R0, LSL #+2]
   \   0000005C   0xF8DD 0xC000      LDR      R12,[SP, #+0]
   \   00000060   0xF85C 0x8021      LDR      R8,[R12, R1, LSL #+2]
   3204                    c1 = z_values[x1][y1], c2 = z_values[x2][y2];
   \   00000064   0xF852 0x9020      LDR      R9,[R2, R0, LSL #+2]
   \   00000068   0xF853 0xA021      LDR      R10,[R3, R1, LSL #+2]
   3205          
   3206              // Treat far unprobed points as zero, near as equal to far
   3207              if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       __iar_FDtest
   \   00000072   0x2802             CMP      R0,#+2
   \   00000074   0xD100             BNE.N    ??extrapolate_one_point_1
   \   00000076   0x2500             MOVS     R5,#+0
   \                     ??extrapolate_one_point_1: (+1)
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x.... 0x....      BL       __iar_FDtest
   \   0000007E   0x2802             CMP      R0,#+2
   \   00000080   0xD100             BNE.N    ??extrapolate_one_point_2
   \   00000082   0x462F             MOV      R7,R5
   3208              if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
   \                     ??extrapolate_one_point_2: (+1)
   \   00000084   0x4640             MOV      R0,R8
   \   00000086   0x.... 0x....      BL       __iar_FDtest
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD101             BNE.N    ??extrapolate_one_point_3
   \   0000008E   0xF04F 0x0800      MOV      R8,#+0
   \                     ??extrapolate_one_point_3: (+1)
   \   00000092   0x4630             MOV      R0,R6
   \   00000094   0x.... 0x....      BL       __iar_FDtest
   \   00000098   0x2802             CMP      R0,#+2
   \   0000009A   0xD100             BNE.N    ??extrapolate_one_point_4
   \   0000009C   0x4646             MOV      R6,R8
   3209              if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
   \                     ??extrapolate_one_point_4: (+1)
   \   0000009E   0x4650             MOV      R0,R10
   \   000000A0   0x.... 0x....      BL       __iar_FDtest
   \   000000A4   0x2802             CMP      R0,#+2
   \   000000A6   0xD101             BNE.N    ??extrapolate_one_point_5
   \   000000A8   0xF04F 0x0A00      MOV      R10,#+0
   \                     ??extrapolate_one_point_5: (+1)
   \   000000AC   0x4648             MOV      R0,R9
   \   000000AE   0x.... 0x....      BL       __iar_FDtest
   \   000000B2   0x2802             CMP      R0,#+2
   \   000000B4   0xD100             BNE.N    ??extrapolate_one_point_6
   \   000000B6   0x46D1             MOV      R9,R10
   3210          
   3211              const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
   3212          
   3213              // Take the average instead of the median
   3214              z_values[x][y] = (a + b + c) / 3.0;
   \                     ??extrapolate_one_point_6: (+1)
   \   000000B8   0xF04F 0x4B80      MOV      R11,#+1073741824
   \   000000BC   0x4638             MOV      R0,R7
   \   000000BE   0x4659             MOV      R1,R11
   \   000000C0   0x.... 0x....      BL       __aeabi_fmul
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0x.... 0x....      BL       __aeabi_fsub
   \   000000CA   0x4605             MOV      R5,R0
   \   000000CC   0x4630             MOV      R0,R6
   \   000000CE   0x4659             MOV      R1,R11
   \   000000D0   0x.... 0x....      BL       __aeabi_fmul
   \   000000D4   0x4641             MOV      R1,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_fsub
   \   000000DA   0x4629             MOV      R1,R5
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x4605             MOV      R5,R0
   \   000000E2   0x4648             MOV      R0,R9
   \   000000E4   0x4659             MOV      R1,R11
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4651             MOV      R1,R10
   \   000000EC   0x.... 0x....      BL       __aeabi_fsub
   \   000000F0   0x4629             MOV      R1,R5
   \   000000F2   0x.... 0x....      BL       __aeabi_fadd
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable155_2  ;; 0x40400000
   \   000000FA   0x.... 0x....      BL       __aeabi_fdiv
   \   000000FE   0x9900             LDR      R1,[SP, #+0]
   \   00000100   0xF841 0x0024      STR      R0,[R1, R4, LSL #+2]
   3215          
   3216              // Median is robust (ignores outliers).
   3217              // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
   3218              //                                : ((c < b) ? b : (a < c) ? a : c);
   3219            }
   \                     ??extrapolate_one_point_0: (+1)
   \   00000104   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   3220          
   3221            //Enable this if your SCARA uses 180掳 of total area
   3222            //#define EXTRAPOLATE_FROM_EDGE
   3223          
   3224            #if ENABLED(EXTRAPOLATE_FROM_EDGE)
   3225              #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
   3226                #define HALF_IN_X
   3227              #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
   3228                #define HALF_IN_Y
   3229              #endif
   3230            #endif
   3231          
   3232            /**
   3233             * Fill in the unprobed points (corners of circular print surface)
   3234             * using linear extrapolation, away from the center.
   3235             */

   \                                 In section .text, align 2, keep-with-next
   3236            static void extrapolate_unprobed_bed_level() {
   \                     _Z30extrapolate_unprobed_bed_levelv: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   3237              #ifdef HALF_IN_X
   3238                constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
   3239              #else
   3240                constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable149_1
   \   0000000A   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   0000000E   0x1E4A             SUBS     R2,R1,#+1
   \   00000010   0xEB02 0x72D2      ADD      R2,R2,R2, LSR #+31
   \   00000014   0x1054             ASRS     R4,R2,#+1
   \   00000016   0xB2E4             UXTB     R4,R4
   3241                                  ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
   \   00000018   0x0849             LSRS     R1,R1,#+1
   \   0000001A   0x9103             STR      R1,[SP, #+12]
   3242                                  xlen = ctrx1;
   \   0000001C   0x4621             MOV      R1,R4
   \   0000001E   0x9102             STR      R1,[SP, #+8]
   \   00000020   0x3060             ADDS     R0,R0,#+96
   \   00000022   0x7840             LDRB     R0,[R0, #+1]
   \   00000024   0x1E41             SUBS     R1,R0,#+1
   \   00000026   0xEB01 0x71D1      ADD      R1,R1,R1, LSR #+31
   \   0000002A   0x104D             ASRS     R5,R1,#+1
   \   0000002C   0xB2ED             UXTB     R5,R5
   3243              #endif
   3244          
   3245              #ifdef HALF_IN_Y
   3246                constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
   3247              #else
   3248                constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
   3249                                  ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
   \   0000002E   0x0840             LSRS     R0,R0,#+1
   \   00000030   0x9001             STR      R0,[SP, #+4]
   3250                                  ylen = ctry1;
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x9000             STR      R0,[SP, #+0]
   3251              #endif
   3252          
   3253              for (uint8_t xo = 0; xo <= xlen; xo++)
   \   00000036   0x2600             MOVS     R6,#+0
   \   00000038   0xE031             B.N      ??extrapolate_unprobed_bed_level_0
   3254                for (uint8_t yo = 0; yo <= ylen; yo++) {
   3255                  uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
   \                     ??extrapolate_unprobed_bed_level_1: (+1)
   \   0000003A   0x9803             LDR      R0,[SP, #+12]
   \   0000003C   0xEB06 0x0800      ADD      R8,R6,R0
   \   00000040   0x9801             LDR      R0,[SP, #+4]
   \   00000042   0xEB07 0x0900      ADD      R9,R7,R0
   3256                  #ifndef HALF_IN_X
   3257                    const uint8_t x1 = ctrx1 - xo;
   3258                  #endif
   3259                  #ifndef HALF_IN_Y
   3260                    const uint8_t y1 = ctry1 - yo;
   \   00000046   0xEBA5 0x0B07      SUB      R11,R5,R7
   3261                    #ifndef HALF_IN_X
   3262                      extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
   \   0000004A   0x2301             MOVS     R3,#+1
   \   0000004C   0x461A             MOV      R2,R3
   \   0000004E   0x4659             MOV      R1,R11
   \   00000050   0xB2C9             UXTB     R1,R1
   \   00000052   0x4650             MOV      R0,R10
   \   00000054   0xB2C0             UXTB     R0,R0
   \   00000056   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3263                    #endif
   3264                    extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
   \   0000005A   0x2301             MOVS     R3,#+1
   \   0000005C   0xF04F 0x32FF      MOV      R2,#-1
   \   00000060   0x4659             MOV      R1,R11
   \   00000062   0xB2C9             UXTB     R1,R1
   \   00000064   0x4640             MOV      R0,R8
   \   00000066   0xB2C0             UXTB     R0,R0
   \   00000068   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3265                  #endif
   3266                  #ifndef HALF_IN_X
   3267                    extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
   \   0000006C   0xF04F 0x33FF      MOV      R3,#-1
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0x4649             MOV      R1,R9
   \   00000074   0xB2C9             UXTB     R1,R1
   \   00000076   0x4650             MOV      R0,R10
   \   00000078   0xB2C0             UXTB     R0,R0
   \   0000007A   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3268                  #endif
   3269                  extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
   \   0000007E   0xF04F 0x33FF      MOV      R3,#-1
   \   00000082   0x461A             MOV      R2,R3
   \   00000084   0x4649             MOV      R1,R9
   \   00000086   0xB2C9             UXTB     R1,R1
   \   00000088   0x4640             MOV      R0,R8
   \   0000008A   0xB2C0             UXTB     R0,R0
   \   0000008C   0x.... 0x....      BL       _Z21extrapolate_one_pointhhaa
   3270                }
   \   00000090   0x1C7F             ADDS     R7,R7,#+1
   \   00000092   0xB2FF             UXTB     R7,R7
   \                     ??extrapolate_unprobed_bed_level_2: (+1)
   \   00000094   0x9800             LDR      R0,[SP, #+0]
   \   00000096   0x42B8             CMP      R0,R7
   \   00000098   0xDACF             BGE.N    ??extrapolate_unprobed_bed_level_1
   \   0000009A   0x1C76             ADDS     R6,R6,#+1
   \   0000009C   0xB2F6             UXTB     R6,R6
   \                     ??extrapolate_unprobed_bed_level_0: (+1)
   \   0000009E   0x9802             LDR      R0,[SP, #+8]
   \   000000A0   0x42B0             CMP      R0,R6
   \   000000A2   0xDB03             BLT.N    ??extrapolate_unprobed_bed_level_3
   \   000000A4   0x2700             MOVS     R7,#+0
   \   000000A6   0xEBA4 0x0A06      SUB      R10,R4,R6
   \   000000AA   0xE7F3             B.N      ??extrapolate_unprobed_bed_level_2
   3271          
   3272            }
   \                     ??extrapolate_unprobed_bed_level_3: (+1)
   \   000000AC   0xB005             ADD      SP,SP,#+20
   \   000000AE   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   3273          

   \                                 In section .text, align 2, keep-with-next
   3274            static void print_bilinear_leveling_grid() {
   \                     _Z28print_bilinear_leveling_gridv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3275              SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
   \   00000002   0x.... 0x....      ADR.W    R0,`?<Constant "Bilinear Leveling Grid:\\n">`
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3276              /*
   3277              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
   3278                [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
   3279              );
   3280              */
   3281              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable149_1
   \   0000000E   0x2300             MOVS     R3,#+0
   \   00000010   0x2203             MOVS     R2,#+3
   \   00000012   0xF890 0x1061      LDRB     R1,[R0, #+97]
   \   00000016   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   0000001A   0xE8BD 0x5000      POP      {R12,LR}
   \   0000001E   0x....             B.N      _Z14print_2d_arrayhhhh
   3282            }
   3283          
   3284            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3285          
   3286              #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3287              #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
   3288              #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
   3289              #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
   3290              float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
   3291              int bilinear_grid_spacing_virt[2] = { 0 };
   3292              float bilinear_grid_factor_virt[2] = { 0 };
   3293          
   3294              static void print_bilinear_leveling_grid_virt() {
   3295                SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
   3296                /*
   3297                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
   3298                  [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
   3299                );
   3300                */
   3301                print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
   3302              }
   3303          
   3304              #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
   3305              float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
   3306                uint8_t ep = 0, ip = 1;
   3307                if (!x || x == ABL_TEMP_POINTS_X - 1) {
   3308                  if (x) {
   3309                    ep = GRID_MAX_POINTS_X - 1;
   3310                    ip = GRID_MAX_POINTS_X - 2;
   3311                  }
   3312                  if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
   3313                    return LINEAR_EXTRAPOLATION(
   3314                      z_values[ep][y - 1],
   3315                      z_values[ip][y - 1]
   3316                    );
   3317                  else
   3318                    return LINEAR_EXTRAPOLATION(
   3319                      bed_level_virt_coord(ep + 1, y),
   3320                      bed_level_virt_coord(ip + 1, y)
   3321                    );
   3322                }
   3323                if (!y || y == ABL_TEMP_POINTS_Y - 1) {
   3324                  if (y) {
   3325                    ep = GRID_MAX_POINTS_Y - 1;
   3326                    ip = GRID_MAX_POINTS_Y - 2;
   3327                  }
   3328                  if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
   3329                    return LINEAR_EXTRAPOLATION(
   3330                      z_values[x - 1][ep],
   3331                      z_values[x - 1][ip]
   3332                    );
   3333                  else
   3334                    return LINEAR_EXTRAPOLATION(
   3335                      bed_level_virt_coord(x, ep + 1),
   3336                      bed_level_virt_coord(x, ip + 1)
   3337                    );
   3338                }
   3339                return z_values[x - 1][y - 1];
   3340              }
   3341          
   3342              static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
   3343                return (
   3344                    p[i-1] * -t * sq(1 - t)
   3345                  + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
   3346                  + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
   3347                  - p[i+2] * sq(t) * (1 - t)
   3348                ) * 0.5;
   3349              }
   3350          
   3351              static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
   3352                float row[4], column[4];
   3353                for (uint8_t i = 0; i < 4; i++) {
   3354                  for (uint8_t j = 0; j < 4; j++) {
   3355                    column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
   3356                  }
   3357                  row[i] = bed_level_virt_cmr(column, 1, ty);
   3358                }
   3359                return bed_level_virt_cmr(row, 1, tx);
   3360              }
   3361          
   3362              void bed_level_virt_interpolate() {
   3363                bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
   3364                bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
   3365                bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
   3366                bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
   3367                for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
   3368                  for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
   3369                    for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
   3370                      for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
   3371                        if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
   3372                          continue;
   3373                        z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
   3374                          bed_level_virt_2cmr(
   3375                            x + 1,
   3376                            y + 1,
   3377                            (float)tx / (BILINEAR_SUBDIVISIONS),
   3378                            (float)ty / (BILINEAR_SUBDIVISIONS)
   3379                          );
   3380                      }
   3381              }
   3382            #endif // ABL_BILINEAR_SUBDIVISION
   3383          
   3384            // Refresh after other values have been updated

   \                                 In section .text, align 2, keep-with-next
   3385            void refresh_bed_level() {
   \                     _Z17refresh_bed_levelv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   3386              bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable154_7
   \   00000006   0x6920             LDR      R0,[R4, #+16]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD102             BNE.N    ??refresh_bed_level_0
   \   0000000C   0x2000             MOVS     R0,#+0
   \   0000000E   0x6220             STR      R0,[R4, #+32]
   \   00000010   0xE00B             B.N      ??refresh_bed_level_1
   \                     ??refresh_bed_level_0: (+1)
   \   00000012   0x.... 0x....      BL       __aeabi_i2d
   \   00000016   0x4602             MOV      R2,R0
   \   00000018   0x460B             MOV      R3,R1
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable155_3  ;; 0x3ff00000
   \   00000020   0x.... 0x....      BL       __aeabi_ddiv
   \   00000024   0x.... 0x....      BL       __aeabi_d2f
   \   00000028   0x6220             STR      R0,[R4, #+32]
   3387              bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
   \                     ??refresh_bed_level_1: (+1)
   \   0000002A   0x6960             LDR      R0,[R4, #+20]
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD102             BNE.N    ??refresh_bed_level_2
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x6260             STR      R0,[R4, #+36]
   \   00000034   0xBD10             POP      {R4,PC}
   \                     ??refresh_bed_level_2: (+1)
   \   00000036   0x.... 0x....      BL       __aeabi_i2d
   \   0000003A   0x4602             MOV      R2,R0
   \   0000003C   0x460B             MOV      R3,R1
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x.... 0x....      LDR.W    R1,??DataTable155_3  ;; 0x3ff00000
   \   00000044   0x.... 0x....      BL       __aeabi_ddiv
   \   00000048   0x.... 0x....      BL       __aeabi_d2f
   \   0000004C   0x6260             STR      R0,[R4, #+36]
   3388              #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   3389                bed_level_virt_interpolate();
   3390              #endif
   3391            }
   \   0000004E   0xBD10             POP      {R4,PC}          ;; return
   3392          
   3393          #endif // AUTO_BED_LEVELING_BILINEAR
   3394          
   3395          /**
   3396           * Home an individual linear axis
   3397           */

   \                                 In section .text, align 2, keep-with-next
   3398          static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
   \                     _Z14do_homing_move8AxisEnumff: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x4681             MOV      R9,R0
   \   00000006   0x4688             MOV      R8,R1
   \   00000008   0x4617             MOV      R7,R2
   3399          
   3400            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3401              if (DEBUGGING(LEVELING)) {
   3402                SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
   3403                SERIAL_ECHOPAIR(", ", distance);
   3404                SERIAL_ECHOPAIR(", ", fr_mm_s);
   3405                SERIAL_CHAR(')');
   3406                SERIAL_EOL();
   3407              }
   3408            #endif
   3409          
   3410            //#if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
   3411            #if HOMING_Z_WITH_PROBE
   3412              //const 
   3413              bool deploy_bltouch;
   3414            if(MKSTOUCH == 1)
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable149_1
   \   0000000E   0xF895 0x0100      LDRB     R0,[R5, #+256]
   \   00000012   0x2801             CMP      R0,#+1
   \   00000014   0xD117             BNE.N    ??do_homing_move_0
   3415            {
   3416            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
   \   00000016   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD513             BPL.N    ??do_homing_move_0
   \   0000001E   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   00000022   0x2801             CMP      R0,#+1
   \   00000024   0xD10F             BNE.N    ??do_homing_move_0
   3417              deploy_bltouch = (axis == Z_AXIS && distance < 0);
   \   00000026   0xF1B9 0x0F02      CMP      R9,#+2
   \   0000002A   0xD106             BNE.N    ??do_homing_move_1
   \   0000002C   0x4640             MOV      R0,R8
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000034   0xD201             BCS.N    ??do_homing_move_1
   \   00000036   0x2401             MOVS     R4,#+1
   \   00000038   0xE000             B.N      ??do_homing_move_2
   \                     ??do_homing_move_1: (+1)
   \   0000003A   0x2400             MOVS     R4,#+0
   3418              if (deploy_bltouch) set_bltouch_deployed(true);
   \                     ??do_homing_move_2: (+1)
   \   0000003C   0x2C00             CMP      R4,#+0
   \   0000003E   0xD002             BEQ.N    ??do_homing_move_0
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   3419              }
   3420            }
   3421            #endif
   3422          
   3423            #if QUIET_PROBING
   3424              if (axis == Z_AXIS) probing_pause(true);
   3425            #endif
   3426          
   3427            // Tell the planner the axis is at 0
   3428            current_position[axis] = 0;
   \                     ??do_homing_move_0: (+1)
   \   00000046   0x.... 0x....      LDR.W    R6,??DataTable149_2
   \   0000004A   0xEB06 0x0989      ADD      R9,R6,R9, LSL #+2
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xF8C9 0x0008      STR      R0,[R9, #+8]
   3429          
   3430            //#if IS_SCARA
   3431            if(MACHINETPYE&IS_SCARA)
   \   00000054   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   00000058   0xF44F 0x7140      MOV      R1,#+768
   \   0000005C   0x4208             TST      R0,R1
   \   0000005E   0xD026             BEQ.N    ??do_homing_move_3
   3432            {
   3433              SYNC_PLAN_POSITION_KINEMATIC();
   \   00000060   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   3434              current_position[axis] = distance;
   \   00000064   0xF8C9 0x8008      STR      R8,[R9, #+8]
   3435              if(MACHINETPYE&IS_SCARA)
   \   00000068   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   0000006C   0xF44F 0x7140      MOV      R1,#+768
   \   00000070   0x4208             TST      R0,R1
   \   00000072   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000076   0xD002             BEQ.N    ??do_homing_move_4
   3436          		inverse_kinematics_MORGAN_SCARA(current_position);
   \   00000078   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   0000007C   0xE001             B.N      ??do_homing_move_5
   3437          	else
   3438                  inverse_kinematics(current_position);
   \                     ??do_homing_move_4: (+1)
   \   0000007E   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   3439              planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \                     ??do_homing_move_5: (+1)
   \   00000082   0x4638             MOV      R0,R7
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000008A   0xD001             BEQ.N    ??do_homing_move_6
   \   0000008C   0x9702             STR      R7,[SP, #+8]
   \   0000008E   0xE002             B.N      ??do_homing_move_7
   \                     ??do_homing_move_6: (+1)
   \   00000090   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   00000094   0x9002             STR      R0,[SP, #+8]
   \                     ??do_homing_move_7: (+1)
   \   00000096   0x78F0             LDRB     R0,[R6, #+3]
   \   00000098   0x9001             STR      R0,[SP, #+4]
   \   0000009A   0xA802             ADD      R0,SP,#+8
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   \   0000009E   0xF106 0x0314      ADD      R3,R6,#+20
   \   000000A2   0x6DB2             LDR      R2,[R6, #+88]
   \   000000A4   0x6D71             LDR      R1,[R6, #+84]
   \   000000A6   0x6D30             LDR      R0,[R6, #+80]
   \   000000A8   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \   000000AC   0xE018             B.N      ??do_homing_move_8
   3440            }
   3441            //#else
   3442            else
   3443            {
   3444              sync_plan_position();
   \                     ??do_homing_move_3: (+1)
   \   000000AE   0x.... 0x....      BL       _Z18sync_plan_positionv
   3445              current_position[axis] = distance;
   \   000000B2   0xF8C9 0x8008      STR      R8,[R9, #+8]
   3446              planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
   \   000000B6   0x4638             MOV      R0,R7
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000BE   0xD001             BEQ.N    ??do_homing_move_9
   \   000000C0   0x9702             STR      R7,[SP, #+8]
   \   000000C2   0xE002             B.N      ??do_homing_move_10
   \                     ??do_homing_move_9: (+1)
   \   000000C4   0xF8D9 0x0028      LDR      R0,[R9, #+40]
   \   000000C8   0x9002             STR      R0,[SP, #+8]
   \                     ??do_homing_move_10: (+1)
   \   000000CA   0x78F0             LDRB     R0,[R6, #+3]
   \   000000CC   0x9001             STR      R0,[SP, #+4]
   \   000000CE   0xA802             ADD      R0,SP,#+8
   \   000000D0   0x9000             STR      R0,[SP, #+0]
   \   000000D2   0xF106 0x0314      ADD      R3,R6,#+20
   \   000000D6   0x6932             LDR      R2,[R6, #+16]
   \   000000D8   0x68F1             LDR      R1,[R6, #+12]
   \   000000DA   0x68B0             LDR      R0,[R6, #+8]
   \   000000DC   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   3447            }
   3448            //#endif
   3449          
   3450            stepper.synchronize();
   \                     ??do_homing_move_8: (+1)
   \   000000E0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   3451          
   3452            #if QUIET_PROBING
   3453              if (axis == Z_AXIS) probing_pause(false);
   3454            #endif
   3455          
   3456            #if HOMING_Z_WITH_PROBE //&& ENABLED(BLTOUCH)
   3457            if(MKSTOUCH == 1)
   \   000000E4   0xF895 0x0100      LDRB     R0,[R5, #+256]
   \   000000E8   0x2801             CMP      R0,#+1
   \   000000EA   0xD10D             BNE.N    ??do_homing_move_11
   3458            {
   3459              if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \   000000EC   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   000000F0   0x2800             CMP      R0,#+0
   \   000000F2   0xD509             BPL.N    ??do_homing_move_11
   \   000000F4   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   000000F8   0x2801             CMP      R0,#+1
   \   000000FA   0xD105             BNE.N    ??do_homing_move_11
   3460              {
   3461                  if (deploy_bltouch) set_bltouch_deployed(false);
   \   000000FC   0xB2E4             UXTB     R4,R4
   \   000000FE   0x2C00             CMP      R4,#+0
   \   00000100   0xD002             BEQ.N    ??do_homing_move_11
   \   00000102   0x2000             MOVS     R0,#+0
   \   00000104   0x.... 0x....      BL       _Z20set_bltouch_deployedb
   3462              }
   3463            }
   3464            #endif
   3465          
   3466            endstops.hit_on_purpose();
   \                     ??do_homing_move_11: (+1)
   \   00000108   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   3467          
   3468            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3469              if (DEBUGGING(LEVELING)) {
   3470                SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
   3471                SERIAL_CHAR(')');
   3472                SERIAL_EOL();
   3473              }
   3474            #endif
   3475          }
   \   0000010C   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
   3476          
   3477          /**
   3478           * TMC2130 specific sensorless homing using stallGuard2.
   3479           * stallGuard2 only works when in spreadCycle mode.
   3480           * spreadCycle and stealthChop are mutually exclusive.
   3481           */
   3482          #if ENABLED(SENSORLESS_HOMING)
   3483            template<typename TMC>
   3484            void tmc_sensorless_homing(TMC &st, bool enable=true) {
   3485              #if ENABLED(STEALTHCHOP)
   3486                if (enable) {
   3487                  st.coolstep_min_speed(1024UL * 1024UL - 1UL);
   3488                  st.stealthChop(0);
   3489                }
   3490                else {
   3491                  st.coolstep_min_speed(0);
   3492                  st.stealthChop(1);
   3493                }
   3494              #endif
   3495          
   3496              st.diag1_stall(enable ? 1 : 0);
   3497            }
   3498          #endif
   3499          
   3500          /**
   3501           * Home an individual "raw axis" to its endstop.
   3502           * This applies to XYZ on Cartesian and Core robots, and
   3503           * to the individual ABC steppers on DELTA and SCARA.
   3504           *
   3505           * At the end of the procedure the axis is marked as
   3506           * homed and the current position of that axis is updated.
   3507           * Kinematic robots should wait till all axes are homed
   3508           * before updating the current position.
   3509           */
   3510          
   3511          #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
   3512          

   \                                 In section .text, align 2, keep-with-next
   3513          static void homeaxis(const AxisEnum axis) {
   \                     _Z8homeaxis8AxisEnum: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
   3514          
   3515          #define CAN_HOME(A) \
   3516              (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
   3517          
   3518            //#if IS_SCARA
   3519            if(MACHINETPYE&IS_SCARA)
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable149_1
   \   0000000A   0xF205 0x0805      ADDW     R8,R5,#+5
   \   0000000E   0x4626             MOV      R6,R4
   \   00000010   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   00000014   0xF44F 0x7140      MOV      R1,#+768
   \   00000018   0x4208             TST      R0,R1
   \   0000001A   0xD002             BEQ.N    ??homeaxis_0
   3520            {
   3521              // Only Z homing (with probe) is permitted
   3522              if (axis != Z_AXIS) { BUZZ(100, 880); return; }
   \   0000001C   0x2E02             CMP      R6,#+2
   \   0000001E   0xD014             BEQ.N    ??homeaxis_1
   \   00000020   0xE12E             B.N      ??homeaxis_2
   3523            }
   3524            //#else
   3525            else
   3526             {
   3527              if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
   \                     ??homeaxis_0: (+1)
   \   00000022   0x2C00             CMP      R4,#+0
   \   00000024   0xD103             BNE.N    ??homeaxis_3
   \   00000026   0xF995 0x0005      LDRSB    R0,[R5, #+5]
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD10D             BNE.N    ??homeaxis_1
   \                     ??homeaxis_3: (+1)
   \   0000002E   0x2E01             CMP      R6,#+1
   \   00000030   0xD103             BNE.N    ??homeaxis_4
   \   00000032   0xF998 0x0001      LDRSB    R0,[R8, #+1]
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD107             BNE.N    ??homeaxis_1
   \                     ??homeaxis_4: (+1)
   \   0000003A   0x2E02             CMP      R6,#+2
   \   0000003C   0xF040 0x8120      BNE.W    ??homeaxis_2
   \   00000040   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   00000044   0x2800             CMP      R0,#+0
   \   00000046   0xF000 0x811B      BEQ.W    ??homeaxis_2
   3528             }
   3529            //#endif
   3530          
   3531            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3532              if (DEBUGGING(LEVELING)) {
   3533                SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
   3534                SERIAL_CHAR(')');
   3535                SERIAL_EOL();
   3536              }
   3537            #endif
   3538          
   3539            const int axis_home_dir =
   3540              #if ENABLED(DUAL_X_CARRIAGE)
   3541                (axis == X_AXIS) ? x_home_dir(active_extruder) :
   3542              #endif
   3543              home_dir(axis);
   \                     ??homeaxis_1: (+1)
   \   0000004A   0x4620             MOV      R0,R4
   \   0000004C   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   00000050   0x4607             MOV      R7,R0
   3544          
   3545            // Homing Z towards the bed? Deploy the Z probe or endstop.
   3546            #if HOMING_Z_WITH_PROBE
   3547            
   3548            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \   00000052   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD50B             BPL.N    ??homeaxis_5
   \   0000005A   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xD107             BNE.N    ??homeaxis_5
   3549            {
   3550              if (axis == Z_AXIS && DEPLOY_PROBE()) return;
   \   00000062   0x2E02             CMP      R6,#+2
   \   00000064   0xD105             BNE.N    ??homeaxis_5
   \   00000066   0x2001             MOVS     R0,#+1
   \   00000068   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xF040 0x8107      BNE.W    ??homeaxis_2
   3551            }
   3552            #endif
   3553          
   3554            // Set flags for X, Y, Z motor locking
   3555            #if ENABLED(X_DUAL_ENDSTOPS)
   3556              if (axis == X_AXIS) stepper.set_homing_flag_x(true);
   3557            #endif
   3558            #if ENABLED(Y_DUAL_ENDSTOPS)
   3559              if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
   3560            #endif
   3561            #if 1//ENABLED(Z_DUAL_ENDSTOPS)
   3562              if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
   \                     ??homeaxis_5: (+1)
   \   00000072   0x2E02             CMP      R6,#+2
   \   00000074   0xD102             BNE.N    ??homeaxis_6
   \   00000076   0x2001             MOVS     R0,#+1
   \   00000078   0x.... 0x....      BL       _ZN7Stepper17set_homing_flag_zEb
   3563            #endif
   3564          
   3565            // Disable stealthChop if used. Enable diag1 pin on driver.
   3566            #if ENABLED(SENSORLESS_HOMING)
   3567              #if ENABLED(X_IS_TMC2130)
   3568                if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
   3569              #endif
   3570              #if ENABLED(Y_IS_TMC2130)
   3571                if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
   3572              #endif
   3573            #endif
   3574          
   3575            // Fast move towards endstop until triggered
   3576            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3577              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
   3578            #endif
   3579            do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
   \                     ??homeaxis_6: (+1)
   \   0000007C   0x4620             MOV      R0,R4
   \   0000007E   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000082   0x2200             MOVS     R2,#+0
   \   00000084   0x4691             MOV      R9,R2
   \   00000086   0x.... 0x....      BL       __aeabi_f2d
   \   0000008A   0x464A             MOV      R2,R9
   \   0000008C   0x.... 0x....      LDR.W    R3,??DataTable155_4  ;; 0x3ff80000
   \   00000090   0x.... 0x....      BL       __aeabi_dmul
   \   00000094   0x4682             MOV      R10,R0
   \   00000096   0x468B             MOV      R11,R1
   \   00000098   0x4638             MOV      R0,R7
   \   0000009A   0x.... 0x....      BL       __aeabi_i2d
   \   0000009E   0x4652             MOV      R2,R10
   \   000000A0   0x465B             MOV      R3,R11
   \   000000A2   0x.... 0x....      BL       __aeabi_dmul
   \   000000A6   0x.... 0x....      BL       __aeabi_d2f
   \   000000AA   0x4601             MOV      R1,R0
   \   000000AC   0x464A             MOV      R2,R9
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3580          
   3581            // When homing Z with probe respect probe clearance
   3582            /*
   3583            const float bump = axis_home_dir * (
   3584              #if HOMING_Z_WITH_PROBE
   3585                (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
   3586              #endif
   3587              home_bump_mm(axis)
   3588            );
   3589            */
   3590              float bump = 0;
   3591              #if HOMING_Z_WITH_PROBE
   3592                  if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))    /*--mks cfg--*/
   \   000000B4   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   000000B8   0x2800             CMP      R0,#+0
   \   000000BA   0xD521             BPL.N    ??homeaxis_7
   \   000000BC   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   000000C0   0x2801             CMP      R0,#+1
   \   000000C2   0xD11D             BNE.N    ??homeaxis_7
   3593                      bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
   \   000000C4   0x2E02             CMP      R6,#+2
   \   000000C6   0xD10F             BNE.N    ??homeaxis_8
   \   000000C8   0xF105 0x0058      ADD      R0,R5,#+88
   \   000000CC   0xF8D0 0x9010      LDR      R9,[R0, #+16]
   \   000000D0   0x2002             MOVS     R0,#+2
   \   000000D2   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   000000D6   0x4649             MOV      R1,R9
   \   000000D8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000DC   0xD308             BCC.N    ??homeaxis_9
   \   000000DE   0x2002             MOVS     R0,#+2
   \   000000E0   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   000000E4   0x4681             MOV      R9,R0
   \   000000E6   0xE003             B.N      ??homeaxis_9
   \                     ??homeaxis_8: (+1)
   \   000000E8   0x4620             MOV      R0,R4
   \   000000EA   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   000000EE   0x4681             MOV      R9,R0
   \                     ??homeaxis_9: (+1)
   \   000000F0   0x4638             MOV      R0,R7
   \   000000F2   0x.... 0x....      BL       __aeabi_i2f
   \   000000F6   0x4649             MOV      R1,R9
   \   000000F8   0x.... 0x....      BL       __aeabi_fmul
   \   000000FC   0x4681             MOV      R9,R0
   \   000000FE   0xE00A             B.N      ??homeaxis_10
   3594                  else
   3595                      bump = axis_home_dir *home_bump_mm(axis);
   \                     ??homeaxis_7: (+1)
   \   00000100   0x4638             MOV      R0,R7
   \   00000102   0x.... 0x....      BL       __aeabi_i2f
   \   00000106   0x4681             MOV      R9,R0
   \   00000108   0x4620             MOV      R0,R4
   \   0000010A   0x.... 0x....      BL       _Z12home_bump_mm8AxisEnum
   \   0000010E   0x4649             MOV      R1,R9
   \   00000110   0x.... 0x....      BL       __aeabi_fmul
   \   00000114   0x4681             MOV      R9,R0
   3596              #else
   3597                  bump = axis_home_dir *home_bump_mm(axis);
   3598              #endif
   3599          
   3600            // If a second homing move is configured...
   3601            if (bump) {
   \                     ??homeaxis_10: (+1)
   \   00000116   0x4648             MOV      R0,R9
   \   00000118   0x2100             MOVS     R1,#+0
   \   0000011A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000011E   0xD015             BEQ.N    ??homeaxis_11
   3602              // Move away from the endstop by the axis HOME_BUMP_MM
   3603              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3604                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
   3605              #endif
   3606              do_homing_move(axis, -bump);
   \   00000120   0x460A             MOV      R2,R1
   \   00000122   0x4649             MOV      R1,R9
   \   00000124   0xF081 0x4100      EOR      R1,R1,#0x80000000
   \   00000128   0x4620             MOV      R0,R4
   \   0000012A   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3607          
   3608              // Slow move towards endstop until triggered
   3609              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3610                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
   3611              #endif
   3612              do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   \   0000012E   0x4620             MOV      R0,R4
   \   00000130   0x.... 0x....      BL       _Z24get_homing_bump_feedrate8AxisEnum
   \   00000134   0x4602             MOV      R2,R0
   \   00000136   0x4692             MOV      R10,R2
   \   00000138   0xF04F 0x4080      MOV      R0,#+1073741824
   \   0000013C   0x4649             MOV      R1,R9
   \   0000013E   0x.... 0x....      BL       __aeabi_fmul
   \   00000142   0x4601             MOV      R1,R0
   \   00000144   0x4652             MOV      R2,R10
   \   00000146   0x4620             MOV      R0,R4
   \   00000148   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3613            }
   3614          
   3615            /**
   3616             * Home axes that have dual endstops... differently
   3617             */
   3618            #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   3619              const bool pos_dir = axis_home_dir > 0;
   \                     ??homeaxis_11: (+1)
   \   0000014C   0x2F01             CMP      R7,#+1
   \   0000014E   0xDB01             BLT.N    ??homeaxis_12
   \   00000150   0x2701             MOVS     R7,#+1
   \   00000152   0xE000             B.N      ??homeaxis_13
   \                     ??homeaxis_12: (+1)
   \   00000154   0x2700             MOVS     R7,#+0
   3620              #if ENABLED(X_DUAL_ENDSTOPS)
   3621                if (axis == X_AXIS) {
   3622                  const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
   3623                  const float adj = FABS(x_endstop_adj);
   3624                  if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
   3625                  do_homing_move(axis, pos_dir ? -adj : adj);
   3626                  if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
   3627                  stepper.set_homing_flag_x(false);
   3628                }
   3629              #endif
   3630              #if ENABLED(Y_DUAL_ENDSTOPS)
   3631                if (axis == Y_AXIS) {
   3632                  const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
   3633                  const float adj = FABS(y_endstop_adj);
   3634                  if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
   3635                  do_homing_move(axis, pos_dir ? -adj : adj);
   3636                  if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
   3637                  stepper.set_homing_flag_y(false);
   3638                }
   3639              #endif
   3640              //#if ENABLED(Z_DUAL_ENDSTOPS)
   3641              if(Z_DUAL_ENDSTOPS==1)
   \                     ??homeaxis_13: (+1)
   \   00000156   0xF895 0x0102      LDRB     R0,[R5, #+258]
   \   0000015A   0x2801             CMP      R0,#+1
   \   0000015C   0xD139             BNE.N    ??homeaxis_14
   3642              {
   3643                if (axis == Z_AXIS) {
   \   0000015E   0x2E02             CMP      R6,#+2
   \   00000160   0xD137             BNE.N    ??homeaxis_14
   3644                  const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable155_5
   \   00000166   0x6800             LDR      R0,[R0, #+0]
   \   00000168   0x2F00             CMP      R7,#+0
   \   0000016A   0xD008             BEQ.N    ??homeaxis_15
   \   0000016C   0x2100             MOVS     R1,#+0
   \   0000016E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000172   0xD202             BCS.N    ??homeaxis_16
   \   00000174   0xF04F 0x0901      MOV      R9,#+1
   \   00000178   0xE009             B.N      ??homeaxis_17
   \                     ??homeaxis_16: (+1)
   \   0000017A   0x4689             MOV      R9,R1
   \   0000017C   0xE007             B.N      ??homeaxis_17
   \                     ??homeaxis_15: (+1)
   \   0000017E   0x2100             MOVS     R1,#+0
   \   00000180   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000184   0xD202             BCS.N    ??homeaxis_18
   \   00000186   0xF04F 0x0901      MOV      R9,#+1
   \   0000018A   0xE000             B.N      ??homeaxis_17
   \                     ??homeaxis_18: (+1)
   \   0000018C   0x4689             MOV      R9,R1
   3645                  const float adj = FABS(z_endstop_adj);
   \                     ??homeaxis_17: (+1)
   \   0000018E   0xF020 0x4A00      BIC      R10,R0,#0x80000000
   3646                  if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
   \   00000192   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000196   0xD003             BEQ.N    ??homeaxis_19
   \   00000198   0x2001             MOVS     R0,#+1
   \   0000019A   0x.... 0x....      BL       _ZN7Stepper10set_z_lockEb
   \   0000019E   0xE002             B.N      ??homeaxis_20
   \                     ??homeaxis_19: (+1)
   \   000001A0   0x2001             MOVS     R0,#+1
   \   000001A2   0x.... 0x....      BL       _ZN7Stepper11set_z2_lockEb
   3647                  do_homing_move(axis, pos_dir ? -adj : adj);
   \                     ??homeaxis_20: (+1)
   \   000001A6   0x2F00             CMP      R7,#+0
   \   000001A8   0xD001             BEQ.N    ??homeaxis_21
   \   000001AA   0xF08A 0x4A00      EOR      R10,R10,#0x80000000
   \                     ??homeaxis_21: (+1)
   \   000001AE   0x2200             MOVS     R2,#+0
   \   000001B0   0x4651             MOV      R1,R10
   \   000001B2   0x4620             MOV      R0,R4
   \   000001B4   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   3648                  if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
   \   000001B8   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001BC   0xD003             BEQ.N    ??homeaxis_22
   \   000001BE   0x2000             MOVS     R0,#+0
   \   000001C0   0x.... 0x....      BL       _ZN7Stepper10set_z_lockEb
   \   000001C4   0xE002             B.N      ??homeaxis_23
   \                     ??homeaxis_22: (+1)
   \   000001C6   0x2000             MOVS     R0,#+0
   \   000001C8   0x.... 0x....      BL       _ZN7Stepper11set_z2_lockEb
   3649                  stepper.set_homing_flag_z(false);
   \                     ??homeaxis_23: (+1)
   \   000001CC   0x2000             MOVS     R0,#+0
   \   000001CE   0x.... 0x....      BL       _ZN7Stepper17set_homing_flag_zEb
   3650                }
   3651              }
   3652              //#endif
   3653            #endif
   3654          
   3655            //#if IS_SCARA
   3656            if(MACHINETPYE&IS_SCARA)
   \                     ??homeaxis_14: (+1)
   \   000001D2   0xF9B5 0x0058      LDRSH    R0,[R5, #+88]
   \   000001D6   0xF44F 0x7140      MOV      R1,#+768
   \   000001DA   0x4208             TST      R0,R1
   \   000001DC   0xD005             BEQ.N    ??homeaxis_24
   3657            {
   3658              set_axis_is_at_home(axis);
   \   000001DE   0x4620             MOV      R0,R4
   \   000001E0   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   3659              SYNC_PLAN_POSITION_KINEMATIC();
   \   000001E4   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \   000001E8   0xE03B             B.N      ??homeaxis_25
   3660            }
   3661            //#elif ENABLED(DELTA)
   3662            else if(MACHINETPYE == DELTA) {
   \                     ??homeaxis_24: (+1)
   \   000001EA   0x2802             CMP      R0,#+2
   \   000001EC   0xD12F             BNE.N    ??homeaxis_26
   3663          
   3664              // Delta has already moved all three towers up in G28
   3665              // so here it re-homes each tower in turn.
   3666              // Delta homing treats the axes as normal linear axes.
   3667          
   3668              // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
   3669              if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
   \   000001EE   0x.... 0x....      LDR.W    R0,??DataTable155_5
   \   000001F2   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   000001F6   0xF8D0 0xA004      LDR      R10,[R0, #+4]
   \   000001FA   0xF998 0x7002      LDRSB    R7,[R8, #+2]
   \   000001FE   0x4638             MOV      R0,R7
   \   00000200   0x.... 0x....      BL       __aeabi_i2f
   \   00000204   0x4651             MOV      R1,R10
   \   00000206   0x.... 0x....      BL       __aeabi_fmul
   \   0000020A   0x2100             MOVS     R1,#+0
   \   0000020C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000210   0xD827             BHI.N    ??homeaxis_25
   3670                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3671                  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
   3672                #endif
   3673                do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
   \   00000212   0x460A             MOV      R2,R1
   \   00000214   0x4691             MOV      R9,R2
   \   00000216   0x4650             MOV      R0,R10
   \   00000218   0x.... 0x....      BL       __aeabi_f2d
   \   0000021C   0x4682             MOV      R10,R0
   \   0000021E   0x468B             MOV      R11,R1
   \   00000220   0x4638             MOV      R0,R7
   \   00000222   0x.... 0x....      BL       __aeabi_i2d
   \   00000226   0x.... 0x....      LDR.W    R2,??DataTable155_6  ;; 0x9999999a
   \   0000022A   0x.... 0x....      LDR.W    R3,??DataTable155_7  ;; 0x3fb99999
   \   0000022E   0x.... 0x....      BL       __aeabi_dmul
   \   00000232   0x4602             MOV      R2,R0
   \   00000234   0x460B             MOV      R3,R1
   \   00000236   0x4650             MOV      R0,R10
   \   00000238   0x4659             MOV      R1,R11
   \   0000023A   0x.... 0x....      BL       __aeabi_dsub
   \   0000023E   0x.... 0x....      BL       __aeabi_d2f
   \   00000242   0x4601             MOV      R1,R0
   \   00000244   0x464A             MOV      R2,R9
   \   00000246   0x4620             MOV      R0,R4
   \   00000248   0x.... 0x....      BL       _Z14do_homing_move8AxisEnumff
   \   0000024C   0xE009             B.N      ??homeaxis_25
   3674              }
   3675            }
   3676            //#else
   3677            else
   3678            {
   3679              // For cartesian/core machines,
   3680              // set the axis to its home position
   3681              set_axis_is_at_home(axis);
   \                     ??homeaxis_26: (+1)
   \   0000024E   0x4620             MOV      R0,R4
   \   00000250   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   3682              sync_plan_position();
   \   00000254   0x.... 0x....      BL       _Z18sync_plan_positionv
   3683          
   3684              destination[axis] = current_position[axis];
   \   00000258   0x....             LDR.N    R0,??DataTable149_2
   \   0000025A   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   0000025E   0x6881             LDR      R1,[R0, #+8]
   \   00000260   0x6181             STR      R1,[R0, #+24]
   3685          
   3686              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3687                if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
   3688              #endif
   3689            }
   3690            //#endif
   3691          
   3692            // Re-enable stealthChop if used. Disable diag1 pin on driver.
   3693            #if ENABLED(SENSORLESS_HOMING)
   3694              #if ENABLED(X_IS_TMC2130)
   3695                if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
   3696              #endif
   3697              #if ENABLED(Y_IS_TMC2130)
   3698                if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
   3699              #endif
   3700            #endif
   3701          
   3702            // Put away the Z probe
   3703            #if HOMING_Z_WITH_PROBE
   3704            if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
   \                     ??homeaxis_25: (+1)
   \   00000262   0xF998 0x0002      LDRSB    R0,[R8, #+2]
   \   00000266   0x2800             CMP      R0,#+0
   \   00000268   0xD50A             BPL.N    ??homeaxis_2
   \   0000026A   0xF895 0x0099      LDRB     R0,[R5, #+153]
   \   0000026E   0x2801             CMP      R0,#+1
   \   00000270   0xD106             BNE.N    ??homeaxis_2
   3705            {    
   3706              if (axis == Z_AXIS && STOW_PROBE()) return;
   \   00000272   0x2E02             CMP      R6,#+2
   \   00000274   0xD104             BNE.N    ??homeaxis_2
   \   00000276   0x2000             MOVS     R0,#+0
   \   00000278   0xE8BD 0x4FF2      POP      {R1,R4-R11,LR}
   \   0000027C   0x.... 0x....      B.W      _Z18set_probe_deployedb
   3707             }
   3708            #endif
   3709          
   3710            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3711              if (DEBUGGING(LEVELING)) {
   3712                SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
   3713                SERIAL_CHAR(')');
   3714                SERIAL_EOL();
   3715              }
   3716            #endif
   3717          } // homeaxis()
   \                     ??homeaxis_2: (+1)
   \   00000280   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   3718          
   3719          #if ENABLED(FWRETRACT)
   3720          
   3721            /**
   3722             * Retract or recover according to firmware settings
   3723             *
   3724             * This function handles retract/recover moves for G10 and G11,
   3725             * plus auto-retract moves sent from G0/G1 when E-only moves are done.
   3726             *
   3727             * To simplify the logic, doubled retract/recover moves are ignored.
   3728             *
   3729             * Note: Z lift is done transparently to the planner. Aborting
   3730             *       a print between G10 and G11 may corrupt the Z position.
   3731             *
   3732             * Note: Auto-retract will apply the set Z hop in addition to any Z hop
   3733             *       included in the G-code. Use M207 Z0 to to prevent double hop.
   3734             */
   3735            void retract(const bool retracting
   3736              #if EXTRUDERS > 1
   3737                , bool swapping = false
   3738              #endif
   3739            ) {
   3740          
   3741              static float hop_amount = 0.0;  // Total amount lifted, for use in recover
   3742          
   3743              // Prevent two retracts or recovers in a row
   3744              if (retracted[active_extruder] == retracting) return;
   3745          
   3746              // Prevent two swap-retract or recovers in a row
   3747              #if EXTRUDERS > 1
   3748                // Allow G10 S1 only after G10
   3749                if (swapping && retracted_swap[active_extruder] == retracting) return;
   3750                // G11 priority to recover the long retract if activated
   3751                if (!retracting) swapping = retracted_swap[active_extruder];
   3752              #else
   3753                const bool swapping = false;
   3754              #endif
   3755          
   3756              /* // debugging
   3757                SERIAL_ECHOLNPAIR("retracting ", retracting);
   3758                SERIAL_ECHOLNPAIR("swapping ", swapping);
   3759                SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
   3760                for (uint8_t i = 0; i < EXTRUDERS; ++i) {
   3761                  SERIAL_ECHOPAIR("retracted[", i);
   3762                  SERIAL_ECHOLNPAIR("] ", retracted[i]);
   3763                  SERIAL_ECHOPAIR("retracted_swap[", i);
   3764                  SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
   3765                }
   3766                SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
   3767                SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
   3768              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
   3769          
   3770              const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
   3771              const float old_feedrate_mm_s = feedrate_mm_s;
   3772          
   3773              // The current position will be the destination for E and Z moves
   3774              set_destination_from_current();
   3775              stepper.synchronize();  // Wait for buffered moves to complete
   3776          
   3777              const float renormalize = 1.0 / planner.e_factor[active_extruder];
   3778          
   3779              if (retracting) {
   3780                // Retract by moving from a faux E position back to the current E position
   3781                feedrate_mm_s = retract_feedrate_mm_s;
   3782                current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
   3783                sync_plan_position_e();
   3784                prepare_move_to_destination();
   3785          
   3786                // Is a Z hop set, and has the hop not yet been done?
   3787                if (has_zhop && !hop_amount) {
   3788                  hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
   3789                  feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
   3790                  current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
   3791                  SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
   3792                  prepare_move_to_destination();                      // Raise up to the old current pos
   3793                  feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
   3794                }
   3795              }
   3796              else {
   3797                // If a hop was done and Z hasn't changed, undo the Z hop
   3798                if (hop_amount) {
   3799                  current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
   3800                  SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
   3801                  feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
   3802                  prepare_move_to_destination();                      // Raise up to the old current pos
   3803                  hop_amount = 0.0;                                   // Clear hop
   3804                }
   3805          
   3806                // A retract multiplier has been added here to get faster swap recovery
   3807                feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
   3808          
   3809                const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
   3810                current_position[E_AXIS] -= move_e * renormalize;
   3811                sync_plan_position_e();
   3812                prepare_move_to_destination();                        // Recover E
   3813              }
   3814          
   3815              feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
   3816          
   3817              retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
   3818          
   3819              // If swap retract/recover update the retracted_swap flag too
   3820              #if EXTRUDERS > 1
   3821                if (swapping) retracted_swap[active_extruder] = retracting;
   3822              #endif
   3823          
   3824              /* // debugging
   3825                SERIAL_ECHOLNPAIR("retracting ", retracting);
   3826                SERIAL_ECHOLNPAIR("swapping ", swapping);
   3827                SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
   3828                for (uint8_t i = 0; i < EXTRUDERS; ++i) {
   3829                  SERIAL_ECHOPAIR("retracted[", i);
   3830                  SERIAL_ECHOLNPAIR("] ", retracted[i]);
   3831                  SERIAL_ECHOPAIR("retracted_swap[", i);
   3832                  SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
   3833                }
   3834                SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
   3835                SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
   3836              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
   3837          
   3838            }
   3839          
   3840          #endif // FWRETRACT
   3841          
   3842          #if ENABLED(MIXING_EXTRUDER)
   3843          
   3844            void normalize_mix() {
   3845              float mix_total = 0.0;
   3846              for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
   3847              // Scale all values if they don't add up to ~1.0
   3848              if (!NEAR(mix_total, 1.0)) {
   3849                SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
   3850                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
   3851              }
   3852            }
   3853          
   3854            #if ENABLED(DIRECT_MIXING_IN_G1)
   3855              // Get mixing parameters from the GCode
   3856              // The total "must" be 1.0 (but it will be normalized)
   3857              // If no mix factors are given, the old mix is preserved
   3858              void gcode_get_mix() {
   3859                const char* mixing_codes = "ABCDHI";
   3860                byte mix_bits = 0;
   3861                for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
   3862                  if (parser.seenval(mixing_codes[i])) {
   3863                    SBI(mix_bits, i);
   3864                    float v = parser.value_float();
   3865                    NOLESS(v, 0.0);
   3866                    mixing_factor[i] = RECIPROCAL(v);
   3867                  }
   3868                }
   3869                // If any mixing factors were included, clear the rest
   3870                // If none were included, preserve the last mix
   3871                if (mix_bits) {
   3872                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
   3873                    if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
   3874                  normalize_mix();
   3875                }
   3876              }
   3877            #endif
   3878          
   3879          #endif
   3880          
   3881          /**
   3882           * ***************************************************************************
   3883           * ***************************** G-CODE HANDLING *****************************
   3884           * ***************************************************************************
   3885           */
   3886          
   3887          /**
   3888           * Set XYZE destination and feedrate from the current GCode command
   3889           *
   3890           *  - Set destination from included axis codes
   3891           *  - Set to current for missing axis codes
   3892           *  - Set the feedrate, if included
   3893           */

   \                                 In section .text, align 2, keep-with-next
   3894          void gcode_get_destination() {
   \                     _Z21gcode_get_destinationv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3895            LOOP_XYZE(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE002             B.N      ??gcode_get_destination_0
   3896              if (parser.seen(axis_codes[i])) {
   3897                const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
   3898                //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
   3899                destination[i] = v;
   3900              }
   3901              else
   3902                destination[i] = current_position[i];
   \                     ??gcode_get_destination_1: (+1)
   \   00000006   0x68A8             LDR      R0,[R5, #+8]
   \   00000008   0x61A8             STR      R0,[R5, #+24]
   \                     ??gcode_get_destination_2: (+1)
   \   0000000A   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_get_destination_0: (+1)
   \   0000000C   0x2C04             CMP      R4,#+4
   \   0000000E   0xDA1A             BGE.N    ??gcode_get_destination_3
   \   00000010   0x....             LDR.N    R0,??DataTable149_2
   \   00000012   0xEB00 0x0584      ADD      R5,R0,R4, LSL #+2
   \   00000016   0x.... 0x....      ADR.W    R0,axis_codes
   \   0000001A   0x5620             LDRSB    R0,[R4, R0]
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD0F0             BEQ.N    ??gcode_get_destination_1
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0xB240             SXTB     R0,R0
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable154_7
   \   00000030   0x5C62             LDRB     R2,[R4, R1]
   \   00000032   0x7949             LDRB     R1,[R1, #+5]
   \   00000034   0x4311             ORRS     R1,R1,R2
   \   00000036   0xD001             BEQ.N    ??gcode_get_destination_4
   \   00000038   0x68A9             LDR      R1,[R5, #+8]
   \   0000003A   0xE000             B.N      ??gcode_get_destination_5
   \                     ??gcode_get_destination_4: (+1)
   \   0000003C   0x2100             MOVS     R1,#+0
   \                     ??gcode_get_destination_5: (+1)
   \   0000003E   0x.... 0x....      BL       __aeabi_fadd
   \   00000042   0x61A8             STR      R0,[R5, #+24]
   \   00000044   0xE7E1             B.N      ??gcode_get_destination_2
   3903            }
   3904          
   3905            if (parser.linearval('F') > 0.0)
   \                     ??gcode_get_destination_3: (+1)
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0x2046             MOVS     R0,#+70
   \   0000004A   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000004E   0x2100             MOVS     R1,#+0
   \   00000050   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000054   0xD206             BCS.N    ??gcode_get_destination_6
   3906              feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
   \   00000056   0x.... 0x....      BL       _ZN11GCodeParser14value_feedrateEv
   \   0000005A   0x....             LDR.N    R1,??DataTable150  ;; 0x42700000
   \   0000005C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000060   0x....             LDR.N    R1,??DataTable149_2
   \   00000062   0x65C8             STR      R0,[R1, #+92]
   3907          
   3908            #if ENABLED(PRINTCOUNTER)
   3909              if (!DEBUGGING(DRYRUN))
   3910                print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
   3911            #endif
   3912          
   3913            // Get ABCDHI mixing factors
   3914            #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
   3915              gcode_get_mix();
   3916            #endif
   3917          }
   \                     ??gcode_get_destination_6: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3918          
   3919          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   3920          
   3921            /**
   3922             * Output a "busy" message at regular intervals
   3923             * while the machine is not accepting commands.
   3924             */

   \                                 In section .text, align 2, keep-with-next
   3925            void host_keepalive() {
   \                     _Z14host_keepalivev: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   3926              const millis_t ms = millis();
   \   00000002   0x.... 0x....      BL       HAL_GetTick
   \   00000006   0x4605             MOV      R5,R0
   3927              if (host_keepalive_interval && busy_state != NOT_BUSY) {
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable154_7
   \   0000000C   0x79E0             LDRB     R0,[R4, #+7]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD029             BEQ.N    ??host_keepalive_0
   \   00000012   0xF994 0x0006      LDRSB    R0,[R4, #+6]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD025             BEQ.N    ??host_keepalive_0
   3928                if (PENDING(ms, next_busy_signal_ms)) return;
   \   0000001A   0x6BE1             LDR      R1,[R4, #+60]
   \   0000001C   0x1A69             SUBS     R1,R5,R1
   \   0000001E   0xD428             BMI.N    ??host_keepalive_1
   3929                switch (busy_state) {
   \   00000020   0x2801             CMP      R0,#+1
   \   00000022   0xD006             BEQ.N    ??host_keepalive_2
   \   00000024   0xD31F             BCC.N    ??host_keepalive_0
   \   00000026   0x2803             CMP      R0,#+3
   \   00000028   0xD00C             BEQ.N    ??host_keepalive_3
   \   0000002A   0xD302             BCC.N    ??host_keepalive_2
   \   0000002C   0x2804             CMP      R0,#+4
   \   0000002E   0xD012             BEQ.N    ??host_keepalive_4
   \   00000030   0xE019             B.N      ??host_keepalive_0
   3930                  case IN_HANDLER:
   3931                  case IN_PROCESS:
   3932                    SERIAL_ECHO_START();
   \                     ??host_keepalive_2: (+1)
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable155_8
   \   00000036   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3933                    SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
   \   0000003A   0x.... 0x....      ADR.W    R0,`?<Constant "busy: processing\\n">`
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3934                    break;
   \   00000042   0xE010             B.N      ??host_keepalive_0
   3935                  case PAUSED_FOR_USER:
   3936                    SERIAL_ECHO_START();
   \                     ??host_keepalive_3: (+1)
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable155_8
   \   00000048   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3937                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
   \   0000004C   0x.... 0x....      ADR.W    R0,`?<Constant "busy: paused for user\\n">`
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3938                    break;
   \   00000054   0xE007             B.N      ??host_keepalive_0
   3939                  case PAUSED_FOR_INPUT:
   3940                    SERIAL_ECHO_START();
   \                     ??host_keepalive_4: (+1)
   \   00000056   0x.... 0x....      LDR.W    R0,??DataTable155_8
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3941                    SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
   \   0000005E   0x.... 0x....      ADR.W    R0,`?<Constant "busy: paused for input\\n">`
   \   00000062   0x.... 0x....      BL       _Z14serialprintPGMPKc
   3942                    break;
   3943                  default:
   3944                    break;
   3945                }
   3946              }
   3947              next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   \                     ??host_keepalive_0: (+1)
   \   00000066   0x79E0             LDRB     R0,[R4, #+7]
   \   00000068   0xF44F 0x717A      MOV      R1,#+1000
   \   0000006C   0xFB01 0x5000      MLA      R0,R1,R0,R5
   \   00000070   0x63E0             STR      R0,[R4, #+60]
   3948            }
   \                     ??host_keepalive_1: (+1)
   \   00000072   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   3949          
   3950          #endif // HOST_KEEPALIVE_FEATURE
   3951          
   3952          
   3953          /**************************************************
   3954           ***************** GCode Handlers *****************
   3955           **************************************************/
   3956          
   3957          #if ENABLED(NO_MOTION_BEFORE_HOMING)
   3958            #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
   3959          #else
   3960            #define G0_G1_CONDITION true
   3961          #endif
   3962          
   3963          /**
   3964           * G0, G1: Coordinated movement of X Y Z E axes
   3965           */

   \                                 In section .text, align 2
   3966          inline void gcode_G0_G1(
   3967            #if 0//IS_SCARA
   3968              bool fast_move=false
   3969            #endif
   3970          ) {
   \                     _Z11gcode_G0_G1v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   3971            if (IsRunning() && G0_G1_CONDITION) {
   \   00000002   0x.... 0x....      BL       _Z9IsRunningv
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD005             BEQ.N    ??gcode_G0_G1_0
   3972              gcode_get_destination(); // For X Y Z E F
   \   0000000A   0x.... 0x....      BL       _Z21gcode_get_destinationv
   3973              
   3974             /*    
   3975              if (gCfgItems.breakpoint_reprint_flg == 1) 
   3976              {
   3977                  if ((destination[2] <= gCfgItems.breakpoint_z_pos)&&(card.sdpos >= 5000)) //断点续打需要大于5k之后的内容才能进行续打。
   3978                  {
   3979                      return;
   3980                  }
   3981              }
   3982              */
   3983              #if ENABLED(FWRETRACT)
   3984                if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
   3985                  // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
   3986                  if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
   3987                    const float echange = destination[E_AXIS] - current_position[E_AXIS];
   3988                    // Is this a retract or recover move?
   3989                    if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
   3990                      current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
   3991                      sync_plan_position_e();                         // AND from the planner
   3992                      return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
   3993                    }
   3994                  }
   3995                }
   3996              #endif // FWRETRACT
   3997          
   3998              #if 0//IS_SCARA
   3999                fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
   4000              #else
   4001                prepare_move_to_destination();
   \   0000000E   0xE8BD 0x4001      POP      {R0,LR}
   \   00000012   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   4002              #endif
   4003          
   4004              #if ENABLED(NANODLP_Z_SYNC)
   4005                #if ENABLED(NANODLP_ALL_AXIS)
   4006                  #define _MOVE_SYNC true                 // For any move wait and output sync message
   4007                #else
   4008                  #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
   4009                #endif
   4010                if (_MOVE_SYNC) {
   4011                  stepper.synchronize();
   4012                  SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4013                }
   4014              #endif
   4015            }
   4016          }
   \                     ??gcode_G0_G1_0: (+1)
   \   00000016   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 2
   4017          inline void gcode_G0_G1_SCARA(
   4018          	  bool fast_move=false
   4019            )
   4020            {
   \                     _Z17gcode_G0_G1_SCARAb: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4021              if (IsRunning() && G0_G1_CONDITION) {
   \   00000004   0x.... 0x....      BL       _Z9IsRunningv
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??gcode_G0_G1_SCARA_0
   4022                gcode_get_destination(); // For X Y Z E F
   \   0000000C   0x.... 0x....      BL       _Z21gcode_get_destinationv
   4023          
   4024              #if ENABLED(FWRETRACT)
   4025                  if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
   4026                    // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
   4027                    if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
   4028                      const float echange = destination[E_AXIS] - current_position[E_AXIS];
   4029                      // Is this a retract or recover move?
   4030                      if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
   4031                        current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
   4032                        sync_plan_position_e();                         // AND from the planner
   4033                        return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
   4034                      }
   4035                    }
   4036                  }
   4037              #endif // FWRETRACT
   4038          
   4039              #if 1//IS_SCARA
   4040                  fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
   \   00000010   0x2C00             CMP      R4,#+0
   \   00000012   0xD004             BEQ.N    ??gcode_G0_G1_SCARA_1
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _Z42prepare_uninterpolated_move_to_destinationf
   \                     ??gcode_G0_G1_SCARA_1: (+1)
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   4041              #else
   4042                  prepare_move_to_destination();
   4043              #endif
   4044          
   4045              #if ENABLED(NANODLP_Z_SYNC)
   4046              #if ENABLED(NANODLP_ALL_AXIS)
   4047                  #define _MOVE_SYNC true                 // For any move wait and output sync message
   4048              #else
   4049                  #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
   4050              #endif
   4051                  if (_MOVE_SYNC) {
   4052                    stepper.synchronize();
   4053                    SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4054                  }
   4055              #endif
   4056              }
   4057          }
   \                     ??gcode_G0_G1_SCARA_0: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   4058          
   4059          /**
   4060           * G2: Clockwise Arc
   4061           * G3: Counterclockwise Arc
   4062           *
   4063           * This command has two forms: IJ-form and R-form.
   4064           *
   4065           *  - I specifies an X offset. J specifies a Y offset.
   4066           *    At least one of the IJ parameters is required.
   4067           *    X and Y can be omitted to do a complete circle.
   4068           *    The given XY is not error-checked. The arc ends
   4069           *     based on the angle of the destination.
   4070           *    Mixing I or J with R will throw an error.
   4071           *
   4072           *  - R specifies the radius. X or Y is required.
   4073           *    Omitting both X and Y will throw an error.
   4074           *    X or Y must differ from the current XY.
   4075           *    Mixing R with I or J will throw an error.
   4076           *
   4077           *  - P specifies the number of full circles to do
   4078           *    before the specified arc move.
   4079           *
   4080           *  Examples:
   4081           *
   4082           *    G2 I10           ; CW circle centered at X+10
   4083           *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
   4084           */
   4085          #if ENABLED(ARC_SUPPORT)
   4086          

   \                                 In section .text, align 4
   4087            inline void gcode_G2_G3(const bool clockwise) {
   \                     _Z11gcode_G2_G3b: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB088             SUB      SP,SP,#+32
   4088              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   4089                if (axis_unhomed_error()) return;
   4090              #endif
   4091          
   4092              if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xF000 0x8113      BEQ.W    ??gcode_G2_G3_0
   4093          
   4094                #if ENABLED(SF_ARC_FIX)
   4095                  const bool relative_mode_backup = relative_mode;
   4096                  relative_mode = true;
   4097                #endif
   4098          
   4099                gcode_get_destination();
   \   00000010   0x.... 0x....      BL       _Z21gcode_get_destinationv
   4100          
   4101                #if ENABLED(SF_ARC_FIX)
   4102                  relative_mode = relative_mode_backup;
   4103                #endif
   4104          
   4105                float arc_offset[2] = { 0.0, 0.0 };
   \   00000014   0xA804             ADD      R0,SP,#+16
   \   00000016   0x2100             MOVS     R1,#+0
   \   00000018   0x460A             MOV      R2,R1
   \   0000001A   0xC006             STM      R0!,{R1,R2}
   4106                if (parser.seenval('R')) {
   \   0000001C   0x2052             MOVS     R0,#+82
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xF000 0x80DF      BEQ.W    ??gcode_G2_G3_1
   4107                  const float r = parser.value_linear_units(),
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000002C   0x4604             MOV      R4,R0
   4108                              p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
   \   0000002E   0x4883             LDR.N    R0,??gcode_G2_G3_2
   \   00000030   0x6881             LDR      R1,[R0, #+8]
   \   00000032   0x9101             STR      R1,[SP, #+4]
   \   00000034   0x68C1             LDR      R1,[R0, #+12]
   \   00000036   0x9100             STR      R1,[SP, #+0]
   4109                              p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
   \   00000038   0x6981             LDR      R1,[R0, #+24]
   \   0000003A   0x9103             STR      R1,[SP, #+12]
   \   0000003C   0x69C0             LDR      R0,[R0, #+28]
   \   0000003E   0x9002             STR      R0,[SP, #+8]
   4110                  if (r && (p2 != p1 || q2 != q1)) {
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x2100             MOVS     R1,#+0
   \   00000044   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000048   0xF000 0x80DD      BEQ.W    ??gcode_G2_G3_3
   \   0000004C   0x9803             LDR      R0,[SP, #+12]
   \   0000004E   0x9901             LDR      R1,[SP, #+4]
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000054   0xD105             BNE.N    ??gcode_G2_G3_4
   \   00000056   0x9802             LDR      R0,[SP, #+8]
   \   00000058   0x9900             LDR      R1,[SP, #+0]
   \   0000005A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000005E   0xF000 0x80D2      BEQ.W    ??gcode_G2_G3_3
   4111                    const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
   \                     ??gcode_G2_G3_4: (+1)
   \   00000062   0x4620             MOV      R0,R4
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000006A   0xD201             BCS.N    ??gcode_G2_G3_5
   \   0000006C   0x2001             MOVS     R0,#+1
   \   0000006E   0xE000             B.N      ??gcode_G2_G3_6
   \                     ??gcode_G2_G3_5: (+1)
   \   00000070   0x4608             MOV      R0,R1
   \                     ??gcode_G2_G3_6: (+1)
   \   00000072   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000076   0xF89D 0x1020      LDRB     R1,[SP, #+32]
   \   0000007A   0xEA90 0x0F01      TEQ      R0,R1
   \   0000007E   0xD001             BEQ.N    ??gcode_G2_G3_7
   \   00000080   0x4E6F             LDR.N    R6,??gcode_G2_G3_2+0x4  ;; 0xbf800000
   \   00000082   0xE000             B.N      ??gcode_G2_G3_8
   \                     ??gcode_G2_G3_7: (+1)
   \   00000084   0x463E             MOV      R6,R7
   4112                                dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
   \                     ??gcode_G2_G3_8: (+1)
   \   00000086   0x9803             LDR      R0,[SP, #+12]
   \   00000088   0x9901             LDR      R1,[SP, #+4]
   \   0000008A   0x.... 0x....      BL       __aeabi_fsub
   \   0000008E   0x9007             STR      R0,[SP, #+28]
   \   00000090   0x9802             LDR      R0,[SP, #+8]
   \   00000092   0x9900             LDR      R1,[SP, #+0]
   \   00000094   0x.... 0x....      BL       __aeabi_fsub
   \   00000098   0x9006             STR      R0,[SP, #+24]
   4113                                d = HYPOT(dx, dy),                          // Linear distance between the points
   \   0000009A   0xF8DD 0x801C      LDR      R8,[SP, #+28]
   \   0000009E   0xF04F 0x0902      MOV      R9,#+2
   \   000000A2   0x463D             MOV      R5,R7
   \   000000A4   0xE004             B.N      ??gcode_G2_G3_9
   \                     ??gcode_G2_G3_10: (+1)
   \   000000A6   0x4640             MOV      R0,R8
   \   000000A8   0x4641             MOV      R1,R8
   \   000000AA   0x.... 0x....      BL       __aeabi_fmul
   \   000000AE   0x4680             MOV      R8,R0
   \                     ??gcode_G2_G3_9: (+1)
   \   000000B0   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000B4   0xD504             BPL.N    ??gcode_G2_G3_11
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x4641             MOV      R1,R8
   \   000000BA   0x.... 0x....      BL       __aeabi_fmul
   \   000000BE   0x4605             MOV      R5,R0
   \                     ??gcode_G2_G3_11: (+1)
   \   000000C0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000C4   0xD1EF             BNE.N    ??gcode_G2_G3_10
   \   000000C6   0xF8DD 0x8018      LDR      R8,[SP, #+24]
   \   000000CA   0xF04F 0x0902      MOV      R9,#+2
   \   000000CE   0x46BA             MOV      R10,R7
   \   000000D0   0xE004             B.N      ??gcode_G2_G3_12
   \                     ??gcode_G2_G3_13: (+1)
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0x4641             MOV      R1,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_fmul
   \   000000DA   0x4680             MOV      R8,R0
   \                     ??gcode_G2_G3_12: (+1)
   \   000000DC   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000E0   0xD504             BPL.N    ??gcode_G2_G3_14
   \   000000E2   0x4650             MOV      R0,R10
   \   000000E4   0x4641             MOV      R1,R8
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4682             MOV      R10,R0
   \                     ??gcode_G2_G3_14: (+1)
   \   000000EC   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000F0   0xD1EF             BNE.N    ??gcode_G2_G3_13
   \   000000F2   0x4628             MOV      R0,R5
   \   000000F4   0x4651             MOV      R1,R10
   \   000000F6   0x.... 0x....      BL       __aeabi_fadd
   \   000000FA   0x.... 0x....      BL       sqrtf
   \   000000FE   0x4682             MOV      R10,R0
   4114                                h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
   \   00000100   0x2502             MOVS     R5,#+2
   \   00000102   0xE004             B.N      ??gcode_G2_G3_15
   \                     ??gcode_G2_G3_16: (+1)
   \   00000104   0x4620             MOV      R0,R4
   \   00000106   0x4621             MOV      R1,R4
   \   00000108   0x.... 0x....      BL       __aeabi_fmul
   \   0000010C   0x4604             MOV      R4,R0
   \                     ??gcode_G2_G3_15: (+1)
   \   0000010E   0x07E8             LSLS     R0,R5,#+31
   \   00000110   0xD504             BPL.N    ??gcode_G2_G3_17
   \   00000112   0x4638             MOV      R0,R7
   \   00000114   0x4621             MOV      R1,R4
   \   00000116   0x.... 0x....      BL       __aeabi_fmul
   \   0000011A   0x4607             MOV      R7,R0
   \                     ??gcode_G2_G3_17: (+1)
   \   0000011C   0x086D             LSRS     R5,R5,#+1
   \   0000011E   0xD1F1             BNE.N    ??gcode_G2_G3_16
   \   00000120   0x4650             MOV      R0,R10
   \   00000122   0x.... 0x....      BL       __aeabi_f2d
   \   00000126   0x2200             MOVS     R2,#+0
   \   00000128   0x4B46             LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
   \   0000012A   0x.... 0x....      BL       __aeabi_dmul
   \   0000012E   0x4680             MOV      R8,R0
   \   00000130   0x4689             MOV      R9,R1
   \   00000132   0xF04F 0x0B02      MOV      R11,#+2
   \   00000136   0x2400             MOVS     R4,#+0
   \   00000138   0x4D43             LDR.N    R5,??gcode_G2_G3_2+0xC  ;; 0x3ff00000
   \   0000013A   0xE007             B.N      ??gcode_G2_G3_18
   \                     ??gcode_G2_G3_19: (+1)
   \   0000013C   0x4640             MOV      R0,R8
   \   0000013E   0x4649             MOV      R1,R9
   \   00000140   0x4642             MOV      R2,R8
   \   00000142   0x464B             MOV      R3,R9
   \   00000144   0x.... 0x....      BL       __aeabi_dmul
   \   00000148   0x4680             MOV      R8,R0
   \   0000014A   0x4689             MOV      R9,R1
   \                     ??gcode_G2_G3_18: (+1)
   \   0000014C   0xEA5F 0x70CB      LSLS     R0,R11,#+31
   \   00000150   0xD507             BPL.N    ??gcode_G2_G3_20
   \   00000152   0x4642             MOV      R2,R8
   \   00000154   0x464B             MOV      R3,R9
   \   00000156   0x4620             MOV      R0,R4
   \   00000158   0x4629             MOV      R1,R5
   \   0000015A   0x.... 0x....      BL       __aeabi_dmul
   \   0000015E   0x4604             MOV      R4,R0
   \   00000160   0x460D             MOV      R5,R1
   \                     ??gcode_G2_G3_20: (+1)
   \   00000162   0xEA5F 0x0B5B      LSRS     R11,R11,#+1
   \   00000166   0xD1E9             BNE.N    ??gcode_G2_G3_19
   \   00000168   0x4638             MOV      R0,R7
   \   0000016A   0x.... 0x....      BL       __aeabi_f2d
   \   0000016E   0x4622             MOV      R2,R4
   \   00000170   0x462B             MOV      R3,R5
   \   00000172   0x.... 0x....      BL       __aeabi_dsub
   \   00000176   0x.... 0x....      BL       sqrt
   \   0000017A   0x.... 0x....      BL       __aeabi_d2f
   4115                                mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
   4116                                sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
   4117                                cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
   4118                    arc_offset[0] = cx - p1;
   \   0000017E   0x4631             MOV      R1,R6
   \   00000180   0x.... 0x....      BL       __aeabi_fmul
   \   00000184   0x4604             MOV      R4,R0
   \   00000186   0xF04F 0x557C      MOV      R5,#+1056964608
   \   0000018A   0x9901             LDR      R1,[SP, #+4]
   \   0000018C   0x9803             LDR      R0,[SP, #+12]
   \   0000018E   0x.... 0x....      BL       __aeabi_fadd
   \   00000192   0x4629             MOV      R1,R5
   \   00000194   0x.... 0x....      BL       __aeabi_fmul
   \   00000198   0x4606             MOV      R6,R0
   \   0000019A   0x9806             LDR      R0,[SP, #+24]
   \   0000019C   0x4651             MOV      R1,R10
   \   0000019E   0x.... 0x....      BL       __aeabi_fdiv
   \   000001A2   0x4621             MOV      R1,R4
   \   000001A4   0x.... 0x....      BL       __aeabi_fmul
   \   000001A8   0x4601             MOV      R1,R0
   \   000001AA   0x4630             MOV      R0,R6
   \   000001AC   0x.... 0x....      BL       __aeabi_fsub
   \   000001B0   0x9901             LDR      R1,[SP, #+4]
   \   000001B2   0x.... 0x....      BL       __aeabi_fsub
   \   000001B6   0x9004             STR      R0,[SP, #+16]
   4119                    arc_offset[1] = cy - q1;
   \   000001B8   0x9900             LDR      R1,[SP, #+0]
   \   000001BA   0x9802             LDR      R0,[SP, #+8]
   \   000001BC   0x.... 0x....      BL       __aeabi_fadd
   \   000001C0   0x4629             MOV      R1,R5
   \   000001C2   0x.... 0x....      BL       __aeabi_fmul
   \   000001C6   0x4605             MOV      R5,R0
   \   000001C8   0x9807             LDR      R0,[SP, #+28]
   \   000001CA   0x4651             MOV      R1,R10
   \   000001CC   0x.... 0x....      BL       __aeabi_fdiv
   \   000001D0   0x4621             MOV      R1,R4
   \   000001D2   0x.... 0x....      BL       __aeabi_fmul
   \   000001D6   0x4629             MOV      R1,R5
   \   000001D8   0x.... 0x....      BL       __aeabi_fadd
   \   000001DC   0x9900             LDR      R1,[SP, #+0]
   \   000001DE   0x.... 0x....      BL       __aeabi_fsub
   \   000001E2   0x9005             STR      R0,[SP, #+20]
   \   000001E4   0xE00F             B.N      ??gcode_G2_G3_3
   4120                  }
   4121                }
   4122                else {
   4123                  if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
   \                     ??gcode_G2_G3_1: (+1)
   \   000001E6   0x2049             MOVS     R0,#+73
   \   000001E8   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001EC   0x2800             CMP      R0,#+0
   \   000001EE   0xD002             BEQ.N    ??gcode_G2_G3_21
   \   000001F0   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001F4   0x9004             STR      R0,[SP, #+16]
   4124                  if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
   \                     ??gcode_G2_G3_21: (+1)
   \   000001F6   0x204A             MOVS     R0,#+74
   \   000001F8   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001FC   0x2800             CMP      R0,#+0
   \   000001FE   0xD002             BEQ.N    ??gcode_G2_G3_3
   \   00000200   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000204   0x9005             STR      R0,[SP, #+20]
   4125                }
   4126          
   4127                if (arc_offset[0] || arc_offset[1]) {
   \                     ??gcode_G2_G3_3: (+1)
   \   00000206   0x9804             LDR      R0,[SP, #+16]
   \   00000208   0x2100             MOVS     R1,#+0
   \   0000020A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000020E   0xD103             BNE.N    ??gcode_G2_G3_22
   \   00000210   0x9805             LDR      R0,[SP, #+20]
   \   00000212   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000216   0xD008             BEQ.N    ??gcode_G2_G3_23
   4128          
   4129                  #if ENABLED(ARC_P_CIRCLES)
   4130                    // P indicates number of circles to do
   4131                    int8_t circles_to_do = parser.byteval('P');
   4132                    if (!WITHIN(circles_to_do, 0, 100)) {
   4133                      SERIAL_ERROR_START();
   4134                      SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   4135                    }
   4136                    while (circles_to_do--)
   4137                      plan_arc(current_position, arc_offset, clockwise);
   4138                  #endif
   4139          
   4140                  // Send the arc to the planner
   4141                  plan_arc(destination, arc_offset, clockwise);
   \                     ??gcode_G2_G3_22: (+1)
   \   00000218   0xF89D 0x2020      LDRB     R2,[SP, #+32]
   \   0000021C   0xA904             ADD      R1,SP,#+16
   \   0000021E   0x480B             LDR.N    R0,??gcode_G2_G3_2+0x10
   \   00000220   0x.... 0x....      BL       _Z8plan_arcRA4_KfRA2_S_b
   4142                  refresh_cmd_timeout();
   \   00000224   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   \   00000228   0xE005             B.N      ??gcode_G2_G3_0
   4143                }
   4144                else {
   4145                  // Bad arguments
   4146                  SERIAL_ERROR_START();
   \                     ??gcode_G2_G3_23: (+1)
   \   0000022A   0x4809             LDR.N    R0,??gcode_G2_G3_2+0x14
   \   0000022C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4147                  SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
   \   00000230   0x4808             LDR.N    R0,??gcode_G2_G3_2+0x18
   \   00000232   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4148                }
   4149              }
   4150            }
   \                     ??gcode_G2_G3_0: (+1)
   \   00000236   0xB009             ADD      SP,SP,#+36
   \   00000238   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??gcode_G2_G3_2:
   \   0000023C   0x........         DC32     mks_heating_busy
   \   00000240   0xBF800000         DC32     0xbf800000
   \   00000244   0x3FE00000         DC32     0x3fe00000
   \   00000248   0x3FF00000         DC32     0x3ff00000
   \   0000024C   0x........         DC32     mks_heating_busy+0x18
   \   00000250   0x........         DC32     errormagic
   \   00000254   0x........         DC32     _ZZ11gcode_G2_G3bEs
   4151          
   4152          #endif // ARC_SUPPORT
   4153          

   \                                 In section .text, align 2, keep-with-next
   4154          void dwell(millis_t time) {
   \                     _Z5dwellm: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4155            refresh_cmd_timeout();
   \   00000004   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   4156            time += previous_cmd_ms;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable156
   \   0000000C   0x6DC0             LDR      R0,[R0, #+92]
   \   0000000E   0x1904             ADDS     R4,R0,R4
   \   00000010   0xE001             B.N      ??dwell_0
   4157            while (PENDING(millis(), time)) idle();
   \                     ??dwell_1: (+1)
   \   00000012   0x.... 0x....      BL       _Z4idlev
   \                     ??dwell_0: (+1)
   \   00000016   0x.... 0x....      BL       HAL_GetTick
   \   0000001A   0x1B00             SUBS     R0,R0,R4
   \   0000001C   0xD4F9             BMI.N    ??dwell_1
   4158          }
   \   0000001E   0xBD10             POP      {R4,PC}          ;; return
   4159          
   4160          /**
   4161           * G4: Dwell S<seconds> or P<milliseconds>
   4162           */

   \                                 In section .text, align 4
   4163          inline void gcode_G4() {
   \                     _Z8gcode_G4v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4164            millis_t dwell_ms = 0;
   \   00000002   0x2400             MOVS     R4,#+0
   4165          
   4166            if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??gcode_G4_0
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser12value_millisEv
   \   00000012   0x4604             MOV      R4,R0
   4167            if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
   \                     ??gcode_G4_0: (+1)
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??gcode_G4_1
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000022   0x4604             MOV      R4,R0
   4168          
   4169            stepper.synchronize();
   \                     ??gcode_G4_1: (+1)
   \   00000024   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4170            #if ENABLED(NANODLP_Z_SYNC)
   4171              SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4172            #endif
   4173          
   4174            if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
   \   00000028   0x.... 0x....      BL       _Z13lcd_hasstatusv
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD103             BNE.N    ??gcode_G4_2
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x4804             LDR.N    R0,??gcode_G4_3
   \   00000034   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   4175          
   4176            dwell(dwell_ms);
   \                     ??gcode_G4_2: (+1)
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000003E   0x.... 0x....      B.W      _Z5dwellm
   \   00000042   0xBF00             Nop      
   \                     ??gcode_G4_3:
   \   00000044   0x........         DC32     _ZZ8gcode_G4vEs
   4177          }
   4178          
   4179          #if ENABLED(BEZIER_CURVE_SUPPORT)
   4180          
   4181            /**
   4182             * Parameters interpreted according to:
   4183             * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
   4184             * However I, J omission is not supported at this point; all
   4185             * parameters can be omitted and default to zero.
   4186             */
   4187          
   4188            /**
   4189             * G5: Cubic B-spline
   4190             */
   4191            inline void gcode_G5() {
   4192              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   4193                if (axis_unhomed_error()) return;
   4194              #endif
   4195          
   4196              if (IsRunning()) {
   4197          
   4198                #if ENABLED(CNC_WORKSPACE_PLANES)
   4199                  if (workspace_plane != PLANE_XY) {
   4200                    SERIAL_ERROR_START();
   4201                    SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
   4202                    return;
   4203                  }
   4204                #endif
   4205          
   4206                gcode_get_destination();
   4207          
   4208                const float offset[] = {
   4209                  parser.linearval('I'),
   4210                  parser.linearval('J'),
   4211                  parser.linearval('P'),
   4212                  parser.linearval('Q')
   4213                };
   4214          
   4215                plan_cubic_move(offset);
   4216              }
   4217            }
   4218          
   4219          #endif // BEZIER_CURVE_SUPPORT
   4220          
   4221          #if ENABLED(FWRETRACT)
   4222          
   4223            /**
   4224             * G10 - Retract filament according to settings of M207
   4225             */
   4226            inline void gcode_G10() {
   4227              #if EXTRUDERS > 1
   4228                const bool rs = parser.boolval('S');
   4229                retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
   4230              #endif
   4231              retract(true
   4232                #if EXTRUDERS > 1
   4233                  , rs
   4234                #endif
   4235              );
   4236            }
   4237          
   4238            /**
   4239             * G11 - Recover filament according to settings of M208
   4240             */
   4241            inline void gcode_G11() { retract(false); }
   4242          
   4243          #endif // FWRETRACT
   4244          
   4245          #if ENABLED(NOZZLE_CLEAN_FEATURE)
   4246            /**
   4247             * G12: Clean the nozzle
   4248             */
   4249            inline void gcode_G12() {
   4250              // Don't allow nozzle cleaning without homing first
   4251              if (axis_unhomed_error()) return;
   4252          
   4253              const uint8_t pattern = parser.ushortval('P', 0),
   4254                            strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
   4255                            objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
   4256              const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
   4257          
   4258              Nozzle::clean(pattern, strokes, radius, objects);
   4259            }
   4260          #endif
   4261          
   4262          #if ENABLED(CNC_WORKSPACE_PLANES)
   4263          
   4264            inline void report_workspace_plane() {
   4265              SERIAL_ECHO_START();
   4266              SERIAL_ECHOPGM("Workspace Plane ");
   4267              serialprintPGM(
   4268                workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
   4269                workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
   4270                                              PSTR("XY\n")
   4271              );
   4272            }
   4273          
   4274            inline void set_workspace_plane(const WorkspacePlane plane) {
   4275              workspace_plane = plane;
   4276              if (DEBUGGING(INFO)) report_workspace_plane();
   4277            }
   4278          
   4279            /**
   4280             * G17: Select Plane XY
   4281             * G18: Select Plane ZX
   4282             * G19: Select Plane YZ
   4283             */
   4284            inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
   4285            inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
   4286            inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
   4287          
   4288          #endif // CNC_WORKSPACE_PLANES
   4289          
   4290          #if ENABLED(CNC_COORDINATE_SYSTEMS)
   4291          
   4292            /**
   4293             * Select a coordinate system and update the workspace offset.
   4294             * System index -1 is used to specify machine-native.
   4295             */
   4296            bool select_coordinate_system(const int8_t _new) {
   4297              if (active_coordinate_system == _new) return false;
   4298              float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
   4299              if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
   4300                COPY(old_offset, coordinate_system[active_coordinate_system]);
   4301              if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
   4302                COPY(new_offset, coordinate_system[_new]);
   4303              active_coordinate_system = _new;
   4304              LOOP_XYZ(i) {
   4305                const float diff = new_offset[i] - old_offset[i];
   4306                if (diff) {
   4307                  position_shift[i] += diff;
   4308                  update_software_endstops((AxisEnum)i);
   4309                }
   4310              }
   4311              return true;
   4312            }
   4313          
   4314            /**
   4315             * In CNC G-code G53 is like a modifier
   4316             * It precedes a movement command (or other modifiers) on the same line.
   4317             * This is the first command to use parser.chain() to make this possible.
   4318             */
   4319            inline void gcode_G53() {
   4320              // If this command has more following...
   4321              if (parser.chain()) {
   4322                const int8_t _system = active_coordinate_system;
   4323                active_coordinate_system = -1;
   4324                process_parsed_command();
   4325                active_coordinate_system = _system;
   4326              }
   4327            }
   4328          
   4329            /**
   4330             * G54-G59.3: Select a new workspace
   4331             *
   4332             * A workspace is an XYZ offset to the machine native space.
   4333             * All workspaces default to 0,0,0 at start, or with EEPROM
   4334             * support they may be restored from a previous session.
   4335             *
   4336             * G92 is used to set the current workspace's offset.
   4337             */
   4338            inline void gcode_G54_59(uint8_t subcode=0) {
   4339              const int8_t _space = parser.codenum - 54 + subcode;
   4340              if (select_coordinate_system(_space)) {
   4341                SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
   4342                report_current_position();
   4343              }
   4344            }
   4345            FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
   4346            FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
   4347            FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
   4348            FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
   4349            FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
   4350            FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
   4351          
   4352          #endif
   4353          
   4354          #if ENABLED(INCH_MODE_SUPPORT)
   4355            /**
   4356             * G20: Set input mode to inches
   4357             */
   4358            inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
   4359          
   4360            /**
   4361             * G21: Set input mode to millimeters
   4362             */
   4363            inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
   4364          #endif
   4365          
   4366          #if ENABLED(NOZZLE_PARK_FEATURE)
   4367            /**
   4368             * G27: Park the nozzle
   4369             */
   4370            inline void gcode_G27() {
   4371              // Don't allow nozzle parking without homing first
   4372              if (axis_unhomed_error()) return;
   4373              Nozzle::park(parser.ushortval('P'));
   4374            }
   4375          #endif // NOZZLE_PARK_FEATURE
   4376          
   4377          #if 1//ENABLED(QUICK_HOME)
   4378          

   \                                 In section .text, align 2, keep-with-next
   4379            static void quick_home_xy() {
   \                     _Z13quick_home_xyv: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   4380          
   4381              // Pretend the current position is 0,0
   4382              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   \   00000004   0x.... 0x....      LDR.W    R6,??DataTable156_1
   \   00000008   0x2000             MOVS     R0,#+0
   \   0000000A   0x60F0             STR      R0,[R6, #+12]
   \   0000000C   0x60B0             STR      R0,[R6, #+8]
   4383              sync_plan_position();
   \   0000000E   0x.... 0x....      BL       _Z18sync_plan_positionv
   4384          
   4385              const int x_axis_home_dir =
   4386                #if ENABLED(DUAL_X_CARRIAGE)
   4387                  x_home_dir(active_extruder)
   4388                #else
   4389                  home_dir(X_AXIS)
   4390                #endif
   4391              ;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   00000018   0x4681             MOV      R9,R0
   4392          
   4393              const float mlx = max_length(X_AXIS),
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000020   0x4680             MOV      R8,R0
   4394                          mly = max_length(Y_AXIS),
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x.... 0x....      BL       _Z10max_length8AxisEnum
   \   00000028   0x4607             MOV      R7,R0
   4395                          mlratio = mlx > mly ? mly / mlx : mlx / mly,
   \   0000002A   0x4641             MOV      R1,R8
   \   0000002C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000030   0xD203             BCS.N    ??quick_home_xy_0
   \   00000032   0x.... 0x....      BL       __aeabi_fdiv
   \   00000036   0x4682             MOV      R10,R0
   \   00000038   0xE004             B.N      ??quick_home_xy_1
   \                     ??quick_home_xy_0: (+1)
   \   0000003A   0x4640             MOV      R0,R8
   \   0000003C   0x4639             MOV      R1,R7
   \   0000003E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000042   0x4682             MOV      R10,R0
   4396                          fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
   \                     ??quick_home_xy_1: (+1)
   \   00000044   0xF8D6 0xB02C      LDR      R11,[R6, #+44]
   \   00000048   0x6AB0             LDR      R0,[R6, #+40]
   \   0000004A   0x4659             MOV      R1,R11
   \   0000004C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000050   0xD200             BCS.N    ??quick_home_xy_2
   \   00000052   0x4683             MOV      R11,R0
   \                     ??quick_home_xy_2: (+1)
   \   00000054   0x2502             MOVS     R5,#+2
   \   00000056   0xF04F 0x547E      MOV      R4,#+1065353216
   \   0000005A   0xE004             B.N      ??quick_home_xy_3
   \                     ??quick_home_xy_4: (+1)
   \   0000005C   0x4650             MOV      R0,R10
   \   0000005E   0x4651             MOV      R1,R10
   \   00000060   0x.... 0x....      BL       __aeabi_fmul
   \   00000064   0x4682             MOV      R10,R0
   \                     ??quick_home_xy_3: (+1)
   \   00000066   0x07E8             LSLS     R0,R5,#+31
   \   00000068   0xD504             BPL.N    ??quick_home_xy_5
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x4651             MOV      R1,R10
   \   0000006E   0x.... 0x....      BL       __aeabi_fmul
   \   00000072   0x4604             MOV      R4,R0
   \                     ??quick_home_xy_5: (+1)
   \   00000074   0x086D             LSRS     R5,R5,#+1
   \   00000076   0xD1F1             BNE.N    ??quick_home_xy_4
   \   00000078   0x4658             MOV      R0,R11
   \   0000007A   0x.... 0x....      BL       __aeabi_f2d
   \   0000007E   0x4682             MOV      R10,R0
   \   00000080   0x468B             MOV      R11,R1
   \   00000082   0x4620             MOV      R0,R4
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x2200             MOVS     R2,#+0
   \   0000008A   0x.... 0x....      LDR.W    R3,??DataTable155_3  ;; 0x3ff00000
   \   0000008E   0x.... 0x....      BL       __aeabi_dadd
   \   00000092   0x.... 0x....      BL       sqrt
   \   00000096   0x4652             MOV      R2,R10
   \   00000098   0x465B             MOV      R3,R11
   \   0000009A   0x.... 0x....      BL       __aeabi_dmul
   \   0000009E   0x.... 0x....      BL       __aeabi_d2f
   \   000000A2   0x9000             STR      R0,[SP, #+0]
   4397          
   4398              do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
   \   000000A4   0x2400             MOVS     R4,#+0
   \   000000A6   0x.... 0x....      LDR.W    R5,??DataTable155_4  ;; 0x3ff80000
   \   000000AA   0x4640             MOV      R0,R8
   \   000000AC   0x.... 0x....      BL       __aeabi_f2d
   \   000000B0   0x4622             MOV      R2,R4
   \   000000B2   0x462B             MOV      R3,R5
   \   000000B4   0x.... 0x....      BL       __aeabi_dmul
   \   000000B8   0x4682             MOV      R10,R0
   \   000000BA   0x468B             MOV      R11,R1
   \   000000BC   0x4648             MOV      R0,R9
   \   000000BE   0x.... 0x....      BL       __aeabi_i2d
   \   000000C2   0x4652             MOV      R2,R10
   \   000000C4   0x465B             MOV      R3,R11
   \   000000C6   0x.... 0x....      BL       __aeabi_dmul
   \   000000CA   0x.... 0x....      BL       __aeabi_d2f
   \   000000CE   0x9002             STR      R0,[SP, #+8]
   \   000000D0   0x4638             MOV      R0,R7
   \   000000D2   0x.... 0x....      BL       __aeabi_f2d
   \   000000D6   0x4622             MOV      R2,R4
   \   000000D8   0x462B             MOV      R3,R5
   \   000000DA   0x.... 0x....      BL       __aeabi_dmul
   \   000000DE   0x4604             MOV      R4,R0
   \   000000E0   0x460D             MOV      R5,R1
   \   000000E2   0x2001             MOVS     R0,#+1
   \   000000E4   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   000000E8   0x.... 0x....      BL       __aeabi_i2d
   \   000000EC   0x4622             MOV      R2,R4
   \   000000EE   0x462B             MOV      R3,R5
   \   000000F0   0x.... 0x....      BL       __aeabi_dmul
   \   000000F4   0x.... 0x....      BL       __aeabi_d2f
   \   000000F8   0x9001             STR      R0,[SP, #+4]
   \   000000FA   0xAA00             ADD      R2,SP,#+0
   \   000000FC   0xA901             ADD      R1,SP,#+4
   \   000000FE   0xA802             ADD      R0,SP,#+8
   \   00000100   0x.... 0x....      BL       _Z22do_blocking_move_to_xyRKfS0_S0_
   4399              endstops.hit_on_purpose(); // clear endstop hit flags
   \   00000104   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   4400              current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x60F0             STR      R0,[R6, #+12]
   \   0000010C   0x60B0             STR      R0,[R6, #+8]
   4401            }
   \   0000010E   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   4402          
   4403          #endif // QUICK_HOME
   4404          
   4405          #if ENABLED(DEBUG_LEVELING_FEATURE)
   4406          
   4407            void log_machine_info() {
   4408              SERIAL_ECHOPGM("Machine Type: ");
   4409              #if ENABLED(DELTA)
   4410                SERIAL_ECHOLNPGM("Delta");
   4411              #elif IS_SCARA
   4412                SERIAL_ECHOLNPGM("SCARA");
   4413              #elif IS_CORE
   4414                SERIAL_ECHOLNPGM("Core");
   4415              #else
   4416                SERIAL_ECHOLNPGM("Cartesian");
   4417              #endif
   4418          
   4419              SERIAL_ECHOPGM("Probe: ");
   4420              #if ENABLED(PROBE_MANUALLY)
   4421                SERIAL_ECHOLNPGM("PROBE_MANUALLY");
   4422              #elif ENABLED(FIX_MOUNTED_PROBE)
   4423                SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
   4424              #elif ENABLED(BLTOUCH)
   4425                SERIAL_ECHOLNPGM("BLTOUCH");
   4426              #elif HAS_Z_SERVO_ENDSTOP
   4427                SERIAL_ECHOLNPGM("SERVO PROBE");
   4428              #elif ENABLED(Z_PROBE_SLED)
   4429                SERIAL_ECHOLNPGM("Z_PROBE_SLED");
   4430              #elif ENABLED(Z_PROBE_ALLEN_KEY)
   4431                SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
   4432              #else
   4433                SERIAL_ECHOLNPGM("NONE");
   4434              #endif
   4435          
   4436              #if HAS_BED_PROBE
   4437                SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
   4438                SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
   4439                SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
   4440                #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
   4441                  SERIAL_ECHOPGM(" (Right");
   4442                #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
   4443                  SERIAL_ECHOPGM(" (Left");
   4444                #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
   4445                  SERIAL_ECHOPGM(" (Middle");
   4446                #else
   4447                  SERIAL_ECHOPGM(" (Aligned With");
   4448                #endif
   4449                #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
   4450                  SERIAL_ECHOPGM("-Back");
   4451                #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
   4452                  SERIAL_ECHOPGM("-Front");
   4453                #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
   4454                  SERIAL_ECHOPGM("-Center");
   4455                #endif
   4456                if (zprobe_zoffset < 0)
   4457                  SERIAL_ECHOPGM(" & Below");
   4458                else if (zprobe_zoffset > 0)
   4459                  SERIAL_ECHOPGM(" & Above");
   4460                else
   4461                  SERIAL_ECHOPGM(" & Same Z as");
   4462                SERIAL_ECHOLNPGM(" Nozzle)");
   4463              #endif
   4464          
   4465              #if HAS_ABL
   4466                SERIAL_ECHOPGM("Auto Bed Leveling: ");
   4467                #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   4468                  SERIAL_ECHOPGM("LINEAR");
   4469                #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4470                  SERIAL_ECHOPGM("BILINEAR");
   4471                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   4472                  SERIAL_ECHOPGM("3POINT");
   4473                #elif ENABLED(AUTO_BED_LEVELING_UBL)
   4474                  SERIAL_ECHOPGM("UBL");
   4475                #endif
   4476                if (planner.leveling_active) {
   4477                  SERIAL_ECHOLNPGM(" (enabled)");
   4478                  #if ABL_PLANAR
   4479                    const float diff[XYZ] = {
   4480                      stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
   4481                      stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
   4482                      stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
   4483                    };
   4484                    SERIAL_ECHOPGM("ABL Adjustment X");
   4485                    if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
   4486                    SERIAL_ECHO(diff[X_AXIS]);
   4487                    SERIAL_ECHOPGM(" Y");
   4488                    if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
   4489                    SERIAL_ECHO(diff[Y_AXIS]);
   4490                    SERIAL_ECHOPGM(" Z");
   4491                    if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
   4492                    SERIAL_ECHO(diff[Z_AXIS]);
   4493                  #elif ENABLED(AUTO_BED_LEVELING_UBL)
   4494                    SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
   4495                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   4496                    SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
   4497                  #endif
   4498                }
   4499                else
   4500                  SERIAL_ECHOLNPGM(" (disabled)");
   4501          
   4502                SERIAL_EOL();
   4503          
   4504              #elif ENABLED(MESH_BED_LEVELING)
   4505          
   4506                SERIAL_ECHOPGM("Mesh Bed Leveling");
   4507                if (planner.leveling_active) {
   4508                  float rz = current_position[Z_AXIS];
   4509                  planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
   4510                  SERIAL_ECHOLNPGM(" (enabled)");
   4511                  SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
   4512                }
   4513                else
   4514                  SERIAL_ECHOPGM(" (disabled)");
   4515          
   4516                SERIAL_EOL();
   4517          
   4518              #endif // MESH_BED_LEVELING
   4519            }
   4520          
   4521          #endif // DEBUG_LEVELING_FEATURE
   4522          
   4523          #if 1//ENABLED(DELTA)
   4524          
   4525            /**
   4526             * A delta can only safely home all axes at the same time
   4527             * This is like quick_home_xy() but for 3 towers.
   4528             */

   \                                 In section .text, align 4
   4529            inline bool home_delta() {
   \                     _Z10home_deltav: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   4530              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4531                if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
   4532              #endif
   4533              // Init the current position of all carriages to 0,0,0
   4534              ZERO(current_position);
   \   00000002   0x4C20             LDR.N    R4,??home_delta_0
   \   00000004   0x2210             MOVS     R2,#+16
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000000C   0x.... 0x....      BL       memset
   4535              sync_plan_position();
   \   00000010   0x.... 0x....      BL       _Z18sync_plan_positionv
   4536          
   4537              // Move all carriages together linearly until an endstop is hit.
   4538              current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
   \   00000014   0x6FA0             LDR      R0,[R4, #+120]
   \   00000016   0x491C             LDR.N    R1,??home_delta_0+0x4  ;; 0x41200000
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x6120             STR      R0,[R4, #+16]
   \   0000001E   0x60E0             STR      R0,[R4, #+12]
   \   00000020   0x60A0             STR      R0,[R4, #+8]
   4539              feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
   \   00000022   0x6AA0             LDR      R0,[R4, #+40]
   \   00000024   0x65E0             STR      R0,[R4, #+92]
   4540              buffer_line_to_current_position();
   \   00000026   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   4541              stepper.synchronize();
   \   0000002A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4542          
   4543              // If an endstop was not hit, then damage can occur if homing is continued.
   4544              // This can occur if the delta height not set correctly.
   4545              if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
   \   0000002E   0x4817             LDR.N    R0,??home_delta_0+0x8
   \   00000030   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000034   0x2170             MOVS     R1,#+112
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD10B             BNE.N    ??home_delta_1
   4546                LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
   \   0000003A   0x2100             MOVS     R1,#+0
   \   0000003C   0x4814             LDR.N    R0,??home_delta_0+0xC
   \   0000003E   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   4547                SERIAL_ERROR_START();
   \   00000042   0x4814             LDR.N    R0,??home_delta_0+0x10
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4548                SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
   \   00000048   0x4813             LDR.N    R0,??home_delta_0+0x14
   \   0000004A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4549                return false;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xBD10             POP      {R4,PC}
   4550              }
   4551          
   4552              endstops.hit_on_purpose(); // clear endstop hit flags
   \                     ??home_delta_1: (+1)
   \   00000052   0x.... 0x....      BL       _ZN8Endstops14hit_on_purposeEv
   4553          
   4554              // At least one carriage has reached the top.
   4555              // Now re-home each carriage separately.
   4556              HOMEAXIS(A);
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4557              HOMEAXIS(B);
   \   0000005C   0x2001             MOVS     R0,#+1
   \   0000005E   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4558              HOMEAXIS(C);
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4559          
   4560              // Set all carriages to their home positions
   4561              // Do this here all at once for Delta, because
   4562              // XYZ isn't ABC. Applying this per-tower would
   4563              // give the impression that they are the same.
   4564              LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
   \   00000068   0x2400             MOVS     R4,#+0
   \   0000006A   0xE004             B.N      ??home_delta_2
   \                     ??home_delta_3: (+1)
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0xB240             SXTB     R0,R0
   \   00000070   0x.... 0x....      BL       _Z19set_axis_is_at_home8AxisEnum
   \   00000074   0x1C64             ADDS     R4,R4,#+1
   \                     ??home_delta_2: (+1)
   \   00000076   0x2C03             CMP      R4,#+3
   \   00000078   0xDBF8             BLT.N    ??home_delta_3
   4565          
   4566              SYNC_PLAN_POSITION_KINEMATIC();
   \   0000007A   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   4567          
   4568              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4569                if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
   4570              #endif
   4571          
   4572              return true;
   \   0000007E   0x2001             MOVS     R0,#+1
   \   00000080   0xBD10             POP      {R4,PC}          ;; return
   \   00000082   0xBF00             Nop      
   \                     ??home_delta_0:
   \   00000084   0x........         DC32     mks_heating_busy
   \   00000088   0x41200000         DC32     0x41200000
   \   0000008C   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE
   \   00000090   0x........         DC32     _ZZ10home_deltavEs
   \   00000094   0x........         DC32     errormagic
   \   00000098   0x........         DC32     _ZZ10home_deltavEs_0
   4573            }
   4574          
   4575          #endif // DELTA
   4576          
   4577          #if ENABLED(Z_SAFE_HOMING)
   4578          
   4579            inline void home_z_safely() {
   4580          
   4581              // Disallow Z homing if X or Y are unknown
   4582              if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
   4583                LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
   4584                SERIAL_ECHO_START();
   4585                SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
   4586                return;
   4587              }
   4588          
   4589              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4590                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
   4591              #endif
   4592          
   4593              SYNC_PLAN_POSITION_KINEMATIC();
   4594          
   4595              /**
   4596               * Move the Z probe (or just the nozzle) to the safe homing point
   4597               */
   4598              destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
   4599              destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
   4600              destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
   4601          
   4602              #if HOMING_Z_WITH_PROBE
   4603              if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))  /*--mks cfg--*/
   4604              {      
   4605                  destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   4606                  destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   4607              }
   4608              #endif
   4609          if(MACHINETPYE & IS_KINEMATIC)
   4610          {
   4611              if (position_is_reachable_IS_KINEMATIC(destination[X_AXIS], destination[Y_AXIS])) {
   4612          
   4613                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4614                  if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
   4615                #endif
   4616          
   4617                // This causes the carriage on Dual X to unpark
   4618                #if ENABLED(DUAL_X_CARRIAGE)
   4619                  active_extruder_parked = false;
   4620                #endif
   4621          
   4622                do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
   4623                HOMEAXIS(Z);
   4624              }
   4625              else {
   4626                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   4627                SERIAL_ECHO_START();
   4628                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   4629              }
   4630          }
   4631          else
   4632          {
   4633              if (position_is_reachable_IS_CARTESIAN(destination[X_AXIS], destination[Y_AXIS])) {
   4634          
   4635                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4636                  if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
   4637                #endif
   4638          
   4639                // This causes the carriage on Dual X to unpark
   4640                #if ENABLED(DUAL_X_CARRIAGE)
   4641                  active_extruder_parked = false;
   4642                #endif
   4643          
   4644                do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
   4645                HOMEAXIS(Z);
   4646              }
   4647              else {
   4648                LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   4649                SERIAL_ECHO_START();
   4650                SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   4651              }    
   4652          }
   4653              #if ENABLED(DEBUG_LEVELING_FEATURE)
   4654                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
   4655              #endif
   4656            }
   4657          
   4658          #endif // Z_SAFE_HOMING
   4659          
   4660          #if ENABLED(PROBE_MANUALLY)
   4661            bool g29_in_progress = false;
   4662          #else
   4663            constexpr bool g29_in_progress = false;
   4664          #endif
   4665          
   4666          /**
   4667           * G28: Home all axes according to settings
   4668           *
   4669           * Parameters
   4670           *
   4671           *  None  Home to all axes with no parameters.
   4672           *        With QUICK_HOME enabled XY will home together, then Z.
   4673           *
   4674           * Cartesian parameters
   4675           *
   4676           *  X   Home to the X endstop
   4677           *  Y   Home to the Y endstop
   4678           *  Z   Home to the Z endstop
   4679           *
   4680           */

   \                                 In section .text, align 4
   4681          inline void gcode_G28(const bool always_home_all) {
   \                     _Z9gcode_G28b: (+1)
   \   00000000   0xE92D 0x4FFE      PUSH     {R1-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   4682          
   4683            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4684              if (DEBUGGING(LEVELING)) {
   4685                SERIAL_ECHOLNPGM(">>> gcode_G28");
   4686                log_machine_info();
   4687              }
   4688            #endif
   4689          
   4690            // Wait for planner moves to finish!
   4691            stepper.synchronize();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   4692          
   4693            // Cancel the active G29 session
   4694            #if ENABLED(PROBE_MANUALLY)
   4695              g29_in_progress = false;
   4696            #endif
   4697          
   4698            // Disable the leveling matrix before homing
   4699            //#if HAS_LEVELING
   4700            	//const 
   4701            	bool ubl_state_at_entry;
   4702              //#if ENABLED(AUTO_BED_LEVELING_UBL)
   4703              if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \   0000000A   0x4D5E             LDR.N    R5,??gcode_G28_0
   \   0000000C   0xF205 0x003F      ADDW     R0,R5,#+63
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x7840             LDRB     R0,[R0, #+1]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xD101             BNE.N    ??gcode_G28_1
   4704              {
   4705              	ubl_state_at_entry = planner.leveling_active;
   \   00000018   0x495B             LDR.N    R1,??gcode_G28_0+0x4
   \   0000001A   0x780C             LDRB     R4,[R1, #+0]
   4706              }
   4707              //#endif
   4708              if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??gcode_G28_1: (+1)
   \   0000001C   0x213E             MOVS     R1,#+62
   \   0000001E   0x4208             TST      R0,R1
   \   00000020   0xD002             BEQ.N    ??gcode_G28_2
   4709              {
   4710              	set_bed_leveling_enabled(false);
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4711              }
   4712            //#endif
   4713          
   4714            #if ENABLED(CNC_WORKSPACE_PLANES)
   4715              workspace_plane = PLANE_XY;
   4716            #endif
   4717          
   4718            // Always home with tool 0 active
   4719            #if HOTENDS > 1
   4720              const uint8_t old_tool_index = active_extruder;
   \                     ??gcode_G28_2: (+1)
   \   00000028   0x4E58             LDR.N    R6,??gcode_G28_0+0x8
   \   0000002A   0x78F0             LDRB     R0,[R6, #+3]
   \   0000002C   0xF88D 0x0008      STRB     R0,[SP, #+8]
   4721              tool_change(0, 0, true);
   \   00000030   0x2201             MOVS     R2,#+1
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0x4608             MOV      R0,R1
   \   00000036   0x.... 0x....      BL       _Z11tool_changehfb
   4722            #endif
   4723          
   4724            #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   4725              extruder_duplication_enabled = false;
   4726            #endif
   4727          
   4728            setup_for_endstop_or_probe_move();
   \   0000003A   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   4729            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4730              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
   4731            #endif
   4732            endstops.enable(true); // Enable endstops for next homing move
   \   0000003E   0x2001             MOVS     R0,#+1
   \   00000040   0x.... 0x....      BL       _ZN8Endstops6enableEb
   4733          
   4734            //#if ENABLED(DELTA)
   4735            if(MACHINETPYE == DELTA)
   \   00000044   0xF9B5 0x0058      LDRSH    R0,[R5, #+88]
   \   00000048   0x2802             CMP      R0,#+2
   \   0000004A   0xD102             BNE.N    ??gcode_G28_3
   4736            {
   4737              home_delta();
   \   0000004C   0x.... 0x....      BL       _Z10home_deltav
   4738              UNUSED(always_home_all);
   \   00000050   0xE080             B.N      ??gcode_G28_4
   4739            }
   4740            //#else // NOT DELTA
   4741            else
   4742            {
   4743              const bool homeX = always_home_all || parser.seen('X'),
   \                     ??gcode_G28_3: (+1)
   \   00000052   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000056   0xD104             BNE.N    ??gcode_G28_5
   \   00000058   0x2058             MOVS     R0,#+88
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000005E   0x4683             MOV      R11,R0
   \   00000060   0xE001             B.N      ??gcode_G28_6
   \                     ??gcode_G28_5: (+1)
   \   00000062   0xF04F 0x0B01      MOV      R11,#+1
   4744                         homeY = always_home_all || parser.seen('Y'),
   \                     ??gcode_G28_6: (+1)
   \   00000066   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000006A   0xD104             BNE.N    ??gcode_G28_7
   \   0000006C   0x2059             MOVS     R0,#+89
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000072   0x4607             MOV      R7,R0
   \   00000074   0xE000             B.N      ??gcode_G28_8
   \                     ??gcode_G28_7: (+1)
   \   00000076   0x2701             MOVS     R7,#+1
   4745                         homeZ = always_home_all || parser.seen('Z'),
   \                     ??gcode_G28_8: (+1)
   \   00000078   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000007C   0xD104             BNE.N    ??gcode_G28_9
   \   0000007E   0x205A             MOVS     R0,#+90
   \   00000080   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000084   0x4680             MOV      R8,R0
   \   00000086   0xE001             B.N      ??gcode_G28_10
   \                     ??gcode_G28_9: (+1)
   \   00000088   0xF04F 0x0801      MOV      R8,#+1
   4746                         home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
   \                     ??gcode_G28_10: (+1)
   \   0000008C   0xEA07 0x090B      AND      R9,R7,R11
   \   00000090   0xEA47 0x000B      ORR      R0,R7,R11
   \   00000094   0xEA48 0x0000      ORR      R0,R8,R0
   \   00000098   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000009C   0xEA08 0x0109      AND      R1,R8,R9
   \   000000A0   0xEA41 0x0A00      ORR      R10,R1,R0
   4747          
   4748              set_destination_from_current();
   \   000000A4   0x.... 0x....      BL       _Z28set_destination_from_currentv
   4749          
   4750              //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
   4751          	if(Z_HOME_DIR > 0)
   \   000000A8   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   000000AC   0x2801             CMP      R0,#+1
   \   000000AE   0xDB05             BLT.N    ??gcode_G28_11
   4752          	{
   4753                if (home_all || homeZ) {
   \   000000B0   0xEA58 0x000A      ORRS     R0,R8,R10
   \   000000B4   0xD002             BEQ.N    ??gcode_G28_11
   4754                  HOMEAXIS(Z);
   \   000000B6   0x2002             MOVS     R0,#+2
   \   000000B8   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4755                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4756                    if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
   4757                  #endif
   4758                }
   4759          	}
   4760              //#endif
   4761          
   4762              if ((home_all || homeX || homeY) 
   4763                  #if 1
   4764          		&& ((mksReprint.mks_printer_state != MKS_REPRINTING)
   4765          	  	||(mksReprint.mks_printer_state != MKS_REPRINTED))
   4766          	  	#endif
   4767                  )
   \                     ??gcode_G28_11: (+1)
   \   000000BC   0xEA4B 0x0B0A      ORR      R11,R11,R10
   \   000000C0   0xEA57 0x000B      ORRS     R0,R7,R11
   \   000000C4   0xD013             BEQ.N    ??gcode_G28_12
   \   000000C6   0x4832             LDR.N    R0,??gcode_G28_0+0xC
   \   000000C8   0xF890 0x0AA0      LDRB     R0,[R0, #+2720]
   \   000000CC   0x28AB             CMP      R0,#+171
   \   000000CE   0xD101             BNE.N    ??gcode_G28_13
   \   000000D0   0x28AC             CMP      R0,#+172
   \   000000D2   0xD00C             BEQ.N    ??gcode_G28_12
   4768                {
   4769                // Raise Z before homing any other axes and z is not already high enough (never lower z)
   4770                destination[Z_AXIS] = Z_HOMING_HEIGHT;
   \                     ??gcode_G28_13: (+1)
   \   000000D4   0x492F             LDR.N    R1,??gcode_G28_0+0x10  ;; 0x40a00000
   \   000000D6   0x6231             STR      R1,[R6, #+32]
   4771                if (destination[Z_AXIS] > current_position[Z_AXIS]) {
   \   000000D8   0x6930             LDR      R0,[R6, #+16]
   \   000000DA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000DE   0xD206             BCS.N    ??gcode_G28_12
   4772          
   4773                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4774                    if (DEBUGGING(LEVELING))
   4775                      SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
   4776                  #endif
   4777          
   4778                  do_blocking_move_to_z(destination[Z_AXIS]);
   \   000000E0   0x2000             MOVS     R0,#+0
   \   000000E2   0x9001             STR      R0,[SP, #+4]
   \   000000E4   0xA901             ADD      R1,SP,#+4
   \   000000E6   0xF106 0x0020      ADD      R0,R6,#+32
   \   000000EA   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   4779                }
   4780              }
   4781          
   4782              //#if ENABLED(QUICK_HOME)
   4783          	if(MACHINETPYE&IS_SCARA)
   \                     ??gcode_G28_12: (+1)
   \   000000EE   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   000000F2   0xF44F 0x7140      MOV      R1,#+768
   \   000000F6   0x4208             TST      R0,R1
   \   000000F8   0xD004             BEQ.N    ??gcode_G28_14
   4784          	{
   4785                if (home_all || (homeX && homeY)) quick_home_xy();
   \   000000FA   0xEA59 0x000A      ORRS     R0,R9,R10
   \   000000FE   0xD001             BEQ.N    ??gcode_G28_14
   \   00000100   0x.... 0x....      BL       _Z13quick_home_xyv
   4786          	}
   4787              //#endif
   4788          
   4789              //#if ENABLED(HOME_Y_BEFORE_X)
   4790          	if(MACHINETPYE&IS_SCARA)
   \                     ??gcode_G28_14: (+1)
   \   00000104   0xF8B5 0x0058      LDRH     R0,[R5, #+88]
   \   00000108   0xF44F 0x7140      MOV      R1,#+768
   \   0000010C   0x4208             TST      R0,R1
   \   0000010E   0xD005             BEQ.N    ??gcode_G28_15
   4791          	{
   4792                // Home Y
   4793                if (home_all || homeY) {
   \   00000110   0xEA57 0x000A      ORRS     R0,R7,R10
   \   00000114   0xD002             BEQ.N    ??gcode_G28_15
   4794                  HOMEAXIS(Y);
   \   00000116   0x2001             MOVS     R0,#+1
   \   00000118   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4795                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4796                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4797                  #endif
   4798                }
   4799          	}
   4800              //#endif
   4801          
   4802              // Home X
   4803              if (home_all || homeX) {
   \                     ??gcode_G28_15: (+1)
   \   0000011C   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000120   0xD002             BEQ.N    ??gcode_G28_16
   4804          
   4805                #if ENABLED(DUAL_X_CARRIAGE)
   4806          
   4807                  // Always home the 2nd (right) extruder first
   4808                  active_extruder = 1;
   4809                  HOMEAXIS(X);
   4810          
   4811                  // Remember this extruder's position for later tool change
   4812                  inactive_extruder_x_pos = current_position[X_AXIS];
   4813          
   4814                  // Home the 1st (left) extruder
   4815                  active_extruder = 0;
   4816                  HOMEAXIS(X);
   4817          
   4818                  // Consider the active extruder to be parked
   4819                  COPY(raised_parked_position, current_position);
   4820                  delayed_move_time = 0;
   4821                  active_extruder_parked = true;
   4822          
   4823                #else
   4824          
   4825                  HOMEAXIS(X);
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4826          
   4827                #endif
   4828          
   4829                #if ENABLED(DEBUG_LEVELING_FEATURE)
   4830                  if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
   4831                #endif
   4832              }
   4833          
   4834              //#if DISABLED(HOME_Y_BEFORE_X)
   4835          	if(!HOME_Y_BEFORE_X)
   \                     ??gcode_G28_16: (+1)
   \   00000128   0xF895 0x003F      LDRB     R0,[R5, #+63]
   \   0000012C   0x2800             CMP      R0,#+0
   \   0000012E   0xD105             BNE.N    ??gcode_G28_17
   4836          	{
   4837                // Home Y
   4838                if (home_all || homeY) {
   \   00000130   0xEA57 0x000A      ORRS     R0,R7,R10
   \   00000134   0xD002             BEQ.N    ??gcode_G28_17
   4839                  HOMEAXIS(Y);
   \   00000136   0x2001             MOVS     R0,#+1
   \   00000138   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4840                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4841                    if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
   4842                  #endif
   4843                }
   4844          	}
   4845              //#endif
   4846          
   4847              // Home Z last if homing towards the bed
   4848              //#if Z_HOME_DIR < 0
   4849              if(Z_HOME_DIR < 0)
   \                     ??gcode_G28_17: (+1)
   \   0000013C   0xF995 0x0007      LDRSB    R0,[R5, #+7]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD505             BPL.N    ??gcode_G28_18
   4850              {
   4851                if (home_all || homeZ) {
   \   00000144   0xEA58 0x000A      ORRS     R0,R8,R10
   \   00000148   0xD002             BEQ.N    ??gcode_G28_18
   4852                  #if ENABLED(Z_SAFE_HOMING)
   4853                    home_z_safely();
   4854                  #else
   4855                    HOMEAXIS(Z);
   \   0000014A   0x2002             MOVS     R0,#+2
   \   0000014C   0x.... 0x....      BL       _Z8homeaxis8AxisEnum
   4856                  #endif
   4857                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   4858                    if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
   4859                  #endif
   4860                } // home_all || homeZ
   4861              }
   4862              //#endif // Z_HOME_DIR < 0
   4863          
   4864              SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??gcode_G28_18: (+1)
   \   00000150   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   4865          }
   4866            //#endif // !DELTA (gcode_G28)
   4867          
   4868            endstops.not_homing();
   \                     ??gcode_G28_4: (+1)
   \   00000154   0x.... 0x....      BL       _ZN8Endstops10not_homingEv
   4869          
   4870            #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   4871              // move to a height where we can use the full xy-area
   4872              do_blocking_move_to_z(delta_clip_start_height);
   4873            #endif
   4874          
   4875            //#if ENABLED(AUTO_BED_LEVELING_UBL)
   4876            if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   \   00000158   0x9800             LDR      R0,[SP, #+0]
   \   0000015A   0x7840             LDRB     R0,[R0, #+1]
   \   0000015C   0x2810             CMP      R0,#+16
   \   0000015E   0xD103             BNE.N    ??gcode_G28_19
   4877              set_bed_leveling_enabled(ubl_state_at_entry);
   \   00000160   0x4620             MOV      R0,R4
   \   00000162   0xB2C0             UXTB     R0,R0
   \   00000164   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   4878            //#endif
   4879          
   4880            clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G28_19: (+1)
   \   00000168   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   4881          
   4882            // Restore the active tool after homing
   4883            #if HOTENDS > 1
   4884              #if ENABLED(PARKING_EXTRUDER)
   4885                #define NO_FETCH false // fetch the previous toolhead
   4886              #else
   4887                #define NO_FETCH true
   4888              #endif
   4889              tool_change(old_tool_index, 0, NO_FETCH);
   \   0000016C   0x2201             MOVS     R2,#+1
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0xF89D 0x0008      LDRB     R0,[SP, #+8]
   \   00000174   0x.... 0x....      BL       _Z11tool_changehfb
   4890            #endif
   4891          
   4892            lcd_refresh();
   \   00000178   0x.... 0x....      BL       _Z11lcd_refreshv
   4893          
   4894            report_current_position();
   \   0000017C   0x.... 0x....      BL       _Z23report_current_positionv
   4895          
   4896            #if ENABLED(NANODLP_Z_SYNC)
   4897              #if ENABLED(NANODLP_ALL_AXIS)
   4898                #define _HOME_SYNC true                 // For any axis, output sync text.
   4899              #else
   4900                #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
   4901              #endif
   4902              if (_HOME_SYNC)
   4903                SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
   4904            #endif
   4905          
   4906            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4907              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
   4908            #endif
   4909          } // G28
   \   00000180   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??gcode_G28_0:
   \   00000184   0x........         DC32     mksCfg
   \   00000188   0x........         DC32     _ZN7Planner15leveling_activeE
   \   0000018C   0x........         DC32     mks_heating_busy
   \   00000190   0x........         DC32     card
   \   00000194   0x40A00000         DC32     0x40a00000
   4910          

   \                                 In section .text, align 2, keep-with-next
   4911          void home_all_axes() { gcode_G28(true); }
   \                     _Z13home_all_axesv: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _Z9gcode_G28b
   4912          
   4913          #if HAS_PROBING_PROCEDURE
   4914          

   \                                 In section .text, align 2, keep-with-next
   4915            void out_of_range_error(const char* p_edge) {
   \                     _Z18out_of_range_errorPKc: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
   4916              SERIAL_PROTOCOLPGM("?Probe ");
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "?Probe ">`
   \   00000008   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4917              serialprintPGM(p_edge);
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4918              SERIAL_PROTOCOLLNPGM(" position out of range.");
   \   00000012   0x.... 0x....      ADR.W    R0,`?<Constant " position out of range.\\n">`
   \   00000016   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   4919            }
   4920          
   4921          #endif
   4922          
   4923          #if 1//ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
   4924          
   4925            #if ENABLED(LCD_BED_LEVELING)
   4926              //extern 
   4927              bool lcd_wait_for_move;
   4928            #else
   4929              constexpr bool lcd_wait_for_move = false;
   4930            #endif
   4931          

   \                                 In section .text, align 4
   4932            inline void _manual_goto_xy(const float &rx, const float &ry) {
   \                     _Z15_manual_goto_xyRKfS0_: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
   4933          
   4934              //#if MANUAL_PROBE_HEIGHT > 0
   4935              if(MANUAL_PROBE_HEIGHT > 0)
   \   00000008   0x4E13             LDR.N    R6,??_manual_goto_xy_0
   \   0000000A   0x4A14             LDR.N    R2,??_manual_goto_xy_0+0x4
   \   0000000C   0x6E90             LDR      R0,[R2, #+104]
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000014   0xD210             BCS.N    ??_manual_goto_xy_1
   4936              {
   4937                const float prev_z = current_position[Z_AXIS];
   \   00000016   0x6930             LDR      R0,[R6, #+16]
   \   00000018   0x9002             STR      R0,[SP, #+8]
   4938                do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
   \   0000001A   0x4608             MOV      R0,R1
   \   0000001C   0x9001             STR      R0,[SP, #+4]
   \   0000001E   0xAB01             ADD      R3,SP,#+4
   \   00000020   0x3268             ADDS     R2,R2,#+104
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x4620             MOV      R0,R4
   \   00000026   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
   4939                do_blocking_move_to_z(prev_z);
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x9000             STR      R0,[SP, #+0]
   \   0000002E   0xA900             ADD      R1,SP,#+0
   \   00000030   0xA802             ADD      R0,SP,#+8
   \   00000032   0x.... 0x....      BL       _Z21do_blocking_move_to_zRKfS0_
   \   00000036   0xE006             B.N      ??_manual_goto_xy_2
   4940              }
   4941              //#else
   4942              else
   4943              {
   4944                do_blocking_move_to_xy(rx, ry);
   \                     ??_manual_goto_xy_1: (+1)
   \   00000038   0x4608             MOV      R0,R1
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xAA00             ADD      R2,SP,#+0
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x4620             MOV      R0,R4
   \   00000042   0x.... 0x....      BL       _Z22do_blocking_move_to_xyRKfS0_S0_
   4945              }
   4946              //#endif
   4947          
   4948              current_position[X_AXIS] = rx;
   \                     ??_manual_goto_xy_2: (+1)
   \   00000046   0x6820             LDR      R0,[R4, #+0]
   \   00000048   0x60B0             STR      R0,[R6, #+8]
   4949              current_position[Y_AXIS] = ry;
   \   0000004A   0x6828             LDR      R0,[R5, #+0]
   \   0000004C   0x60F0             STR      R0,[R6, #+12]
   4950          
   4951              #if ENABLED(LCD_BED_LEVELING)
   4952                lcd_wait_for_move = false;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x4903             LDR.N    R1,??_manual_goto_xy_0+0x8
   \   00000052   0x7248             STRB     R0,[R1, #+9]
   4953              #endif
   4954            }
   \   00000054   0xBD7F             POP      {R0-R6,PC}       ;; return
   \   00000056   0xBF00             Nop      
   \                     ??_manual_goto_xy_0:
   \   00000058   0x........         DC32     mks_heating_busy
   \   0000005C   0x........         DC32     mksCfg
   \   00000060   0x........         DC32     axis_homed
   4955          
   4956          #endif
   4957          
   4958          #if 1//ENABLED(MESH_BED_LEVELING)
   4959          
   4960            // Save 130 bytes with non-duplication of PSTR

   \                                 In section .text, align 2, keep-with-next
   4961            void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
   \                     _Z16echo_not_enteredv: (+1)
   \   00000000   0x.... 0x....      ADR.W    R0,`?<Constant " not entered.\\n">`
   \   00000004   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   4962          

   \                                 In section .text, align 2, keep-with-next
   4963            void mbl_mesh_report() {
   \                     _Z15mbl_mesh_reportv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   4964              //SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
   4965              SERIAL_PROTOCOLPGM("Num X,Y: ");
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "Num X,Y: ">`
   \   00000008   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4966              SERIAL_PROTOCOL((int)GRID_MAX_POINTS_X);
   \   0000000C   0x....             LDR.N    R4,??DataTable154_2
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable158
   \   00000012   0x220A             MOVS     R2,#+10
   \   00000014   0xF895 0x1060      LDRB     R1,[R5, #+96]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0x.... 0x....      BL       _ZN5Print5printEii
   4967              SERIAL_PROTOCOLCHAR(',');
   \   0000001E   0x212C             MOVS     R1,#+44
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   4968              SERIAL_PROTOCOL((int)GRID_MAX_POINTS_Y);
   \   00000026   0xF105 0x0660      ADD      R6,R5,#+96
   \   0000002A   0x220A             MOVS     R2,#+10
   \   0000002C   0x7871             LDRB     R1,[R6, #+1]
   \   0000002E   0x4620             MOV      R0,R4
   \   00000030   0x.... 0x....      BL       _ZN5Print5printEii
   4969              SERIAL_EOL();
   \   00000034   0x210A             MOVS     R1,#+10
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   4970              SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
   \   0000003C   0x.... 0x....      ADR.W    R0,`?<Constant "Z offset: ">`
   \   00000040   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000044   0x2005             MOVS     R0,#+5
   \   00000046   0x9000             STR      R0,[SP, #+0]
   \   00000048   0x.... 0x....      LDR.W    R0,??DataTable159
   \   0000004C   0x6800             LDR      R0,[R0, #+0]
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x460B             MOV      R3,R1
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0x.... 0x....      BL       _ZN5Print5printEdi
   4971              SERIAL_PROTOCOLLNPGM("\nMeasured points:");
   \   0000005C   0x.... 0x....      ADR.W    R0,`?<Constant "\\nMeasured points:\\n">`
   \   00000060   0x.... 0x....      BL       _Z14serialprintPGMPKc
   4972          	/*
   4973              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
   4974                [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
   4975              );
   4976              */
   4977              print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
   \   00000064   0x2302             MOVS     R3,#+2
   \   00000066   0x2205             MOVS     R2,#+5
   \   00000068   0x7871             LDRB     R1,[R6, #+1]
   \   0000006A   0xF895 0x0060      LDRB     R0,[R5, #+96]
   \   0000006E   0xB002             ADD      SP,SP,#+8
   \   00000070   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000074   0x.... 0x....      B.W      _Z14print_2d_arrayhhhh
   4978            }
   4979          
   4980            /**
   4981             * G29: Mesh-based Z probe, probes a grid and produces a
   4982             *      mesh to compensate for variable bed height
   4983             *
   4984             * Parameters With MESH_BED_LEVELING:
   4985             *
   4986             *  S0              Produce a mesh report
   4987             *  S1              Start probing mesh points
   4988             *  S2              Probe the next mesh point
   4989             *  S3 Xn Yn Zn.nn  Manually modify a single point
   4990             *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
   4991             *  S5              Reset and disable mesh
   4992             *
   4993             * The S0 report the points as below
   4994             *
   4995             *  +----> X-axis  1-n
   4996             *  |
   4997             *  |
   4998             *  v Y-axis  1-n
   4999             *
   5000             */
   5001          //  inline void gcode_G29() {

   \                                 In section .text, align 4
   5002          inline void gcode_G29_MESH_BED_LEVELING() {
   \                     _Z27gcode_G29_MESH_BED_LEVELINGv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB082             SUB      SP,SP,#+8
   5003          
   5004              static int mbl_probe_index = -1;
   5005              #if HAS_SOFTWARE_ENDSTOPS
   5006                static bool enable_soft_endstops;
   5007              #endif
   5008          
   5009              const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x2053             MOVS     R0,#+83
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   0000000E   0x4604             MOV      R4,R0
   \   00000010   0xB264             SXTB     R4,R4
   5010              if (!WITHIN(state, 0, 5)) {
   \   00000012   0x2C06             CMP      R4,#+6
   \   00000014   0xD303             BCC.N    ??gcode_G29_MESH_BED_LEVELING_1
   5011                SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
   \   00000016   0x4888             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2
   \   00000018   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5012                return;
   \   0000001C   0xE10A             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5013              }
   5014          
   5015              int8_t px, py;
   5016          
   5017              switch (state) {
   \                     ??gcode_G29_MESH_BED_LEVELING_1: (+1)
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x2805             CMP      R0,#+5
   \   00000022   0xF200 0x80E5      BHI.W    ??gcode_G29_MESH_BED_LEVELING_4
   \   00000026   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_G29_MESH_BED_LEVELING_0:
   \   0000002A   0x03 0x1C          DC8      0x3,0x1C,0x2B,0x7F
   \              0x2B 0x7F    
   \   0000002E   0xD0 0xE1          DC8      0xD0,0xE1
   5018                case MeshReport:
   5019                  if (leveling_is_valid()) {
   \                     ??gcode_G29_MESH_BED_LEVELING_5: (+1)
   \   00000030   0x.... 0x....      BL       _Z17leveling_is_validv
   \   00000034   0x2800             CMP      R0,#+0
   \   00000036   0xD010             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_6
   5020                    SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
   \   00000038   0x4880             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x4
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_7
   \   00000040   0x497F             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x8
   \   00000042   0xE000             B.N      ??gcode_G29_MESH_BED_LEVELING_8
   \                     ??gcode_G29_MESH_BED_LEVELING_7: (+1)
   \   00000044   0x497F             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0xC
   \                     ??gcode_G29_MESH_BED_LEVELING_8: (+1)
   \   00000046   0x4880             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x10
   \   00000048   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0x487F             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   00000050   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5021                    mbl_mesh_report();
   \   00000054   0x.... 0x....      BL       _Z15mbl_mesh_reportv
   \   00000058   0xE0CA             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5022                  }
   5023                  else
   5024                    SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
   \                     ??gcode_G29_MESH_BED_LEVELING_6: (+1)
   \   0000005A   0x487D             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x18
   \   0000005C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000060   0xE0C6             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5025                  break;
   5026          
   5027                case MeshStart:
   5028                  mbl.reset();
   \                     ??gcode_G29_MESH_BED_LEVELING_9: (+1)
   \   00000062   0x.... 0x....      BL       _ZN17mesh_bed_leveling5resetEv
   5029                  mbl_probe_index = 0;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x497A             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x1C
   \   0000006A   0x6008             STR      R0,[R1, #+0]
   5030                  enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
   \   0000006C   0x487A             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x20
   \   0000006E   0x7A40             LDRB     R0,[R0, #+9]
   \   00000070   0x2800             CMP      R0,#+0
   \   00000072   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_10
   \   00000074   0x4879             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x24
   \   00000076   0xE000             B.N      ??gcode_G29_MESH_BED_LEVELING_11
   \                     ??gcode_G29_MESH_BED_LEVELING_10: (+1)
   \   00000078   0x4879             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x28
   \                     ??gcode_G29_MESH_BED_LEVELING_11: (+1)
   \   0000007A   0x.... 0x....      BL       _Z27enqueue_and_echo_commands_PPKc
   5031                  break;
   \   0000007E   0xE0B7             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5032          
   5033                case MeshNext:
   5034                  if (mbl_probe_index < 0) {
   \                     ??gcode_G29_MESH_BED_LEVELING_12: (+1)
   \   00000080   0x4D74             LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
   \   00000082   0x6828             LDR      R0,[R5, #+0]
   \   00000084   0x2800             CMP      R0,#+0
   \   00000086   0xD503             BPL.N    ??gcode_G29_MESH_BED_LEVELING_13
   5035                    SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
   \   00000088   0x4876             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x2C
   \   0000008A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5036                    return;
   \   0000008E   0xE0D1             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5037                  }
   5038                  // For each G29 S2...
   5039                  if (mbl_probe_index == 0) {
   \                     ??gcode_G29_MESH_BED_LEVELING_13: (+1)
   \   00000090   0x4E75             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x30
   \   00000092   0x4F71             LDR.N    R7,??gcode_G29_MESH_BED_LEVELING_2+0x20
   \   00000094   0xD102             BNE.N    ??gcode_G29_MESH_BED_LEVELING_14
   5040                    #if HAS_SOFTWARE_ENDSTOPS
   5041                      // For the initial G29 S2 save software endstop state
   5042                      enable_soft_endstops = soft_endstops_enabled;
   \   00000096   0x7A38             LDRB     R0,[R7, #+8]
   \   00000098   0x7030             STRB     R0,[R6, #+0]
   \   0000009A   0xE006             B.N      ??gcode_G29_MESH_BED_LEVELING_15
   5043                    #endif
   5044                  }
   5045                  else {
   5046                    // For G29 S2 after adjusting Z.
   5047                    mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
   \                     ??gcode_G29_MESH_BED_LEVELING_14: (+1)
   \   0000009C   0x4973             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x34
   \   0000009E   0x1E40             SUBS     R0,R0,#+1
   \   000000A0   0xB240             SXTB     R0,R0
   \   000000A2   0x.... 0x....      BL       _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
   5048                    #if HAS_SOFTWARE_ENDSTOPS
   5049                      soft_endstops_enabled = enable_soft_endstops;
   \   000000A6   0x7830             LDRB     R0,[R6, #+0]
   \   000000A8   0x7238             STRB     R0,[R7, #+8]
   5050                    #endif
   5051                  }
   5052                  // If there's another point to sample, move there with optional lift.
   5053                  if (mbl_probe_index < GRID_MAX_POINTS) {
   \                     ??gcode_G29_MESH_BED_LEVELING_15: (+1)
   \   000000AA   0x6828             LDR      R0,[R5, #+0]
   \   000000AC   0x4E70             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
   \   000000AE   0xF106 0x0860      ADD      R8,R6,#+96
   \   000000B2   0xF896 0x1060      LDRB     R1,[R6, #+96]
   \   000000B6   0xF898 0x2001      LDRB     R2,[R8, #+1]
   \   000000BA   0x4351             MULS     R1,R2,R1
   \   000000BC   0x4288             CMP      R0,R1
   \   000000BE   0xDA17             BGE.N    ??gcode_G29_MESH_BED_LEVELING_16
   5054                    mbl.zigzag(mbl_probe_index, px, py);
   \   000000C0   0xAA00             ADD      R2,SP,#+0
   \   000000C2   0xF10D 0x0101      ADD      R1,SP,#+1
   \   000000C6   0xB240             SXTB     R0,R0
   \   000000C8   0x.... 0x....      BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
   5055                    _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
   \   000000CC   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   000000D0   0x4968             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x3C
   \   000000D2   0xEB01 0x0180      ADD      R1,R1,R0, LSL #+2
   \   000000D6   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \   000000DA   0x4A67             LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x40
   \   000000DC   0xEB02 0x0080      ADD      R0,R2,R0, LSL #+2
   \   000000E0   0x.... 0x....      BL       _Z15_manual_goto_xyRKfS0_
   5056          
   5057                    #if HAS_SOFTWARE_ENDSTOPS
   5058                      // Disable software endstops to allow manual adjustment
   5059                      // If G29 is not completed, they will not be re-enabled
   5060                      soft_endstops_enabled = false;
   \   000000E4   0x2000             MOVS     R0,#+0
   \   000000E6   0x7238             STRB     R0,[R7, #+8]
   5061                    #endif
   5062          
   5063                    mbl_probe_index++;
   \   000000E8   0x6828             LDR      R0,[R5, #+0]
   \   000000EA   0x1C40             ADDS     R0,R0,#+1
   \   000000EC   0x6028             STR      R0,[R5, #+0]
   \   000000EE   0xE07F             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5064                  }
   5065                  else {
   5066                    // One last "return to the bed" (as originally coded) at completion
   5067                    current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
   \                     ??gcode_G29_MESH_BED_LEVELING_16: (+1)
   \   000000F0   0x6930             LDR      R0,[R6, #+16]
   \   000000F2   0xF8D8 0x1008      LDR      R1,[R8, #+8]
   \   000000F6   0x.... 0x....      BL       __aeabi_fadd
   \   000000FA   0x4960             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x44
   \   000000FC   0x6108             STR      R0,[R1, #+16]
   5068                    buffer_line_to_current_position();
   \   000000FE   0x.... 0x....      BL       _Z31buffer_line_to_current_positionv
   5069                    stepper.synchronize();
   \   00000102   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   5070          
   5071                    // After recording the last point, activate home and activate
   5072                    mbl_probe_index = -1;
   \   00000106   0xF04F 0x30FF      MOV      R0,#-1
   \   0000010A   0x6028             STR      R0,[R5, #+0]
   5073                    SERIAL_PROTOCOLLNPGM("Mesh probing done.");
   \   0000010C   0x485C             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x48
   \   0000010E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5074                    BUZZ(100, 659);
   5075                    BUZZ(100, 698);
   5076                    mbl.has_mesh = true;
   \   00000112   0x2001             MOVS     R0,#+1
   \   00000114   0x495B             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x4C
   \   00000116   0x7008             STRB     R0,[R1, #+0]
   5077          
   5078                    home_all_axes();
   \   00000118   0x.... 0x....      BL       _Z13home_all_axesv
   5079                    set_bed_leveling_enabled(true);
   \   0000011C   0x2001             MOVS     R0,#+1
   \   0000011E   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5080          
   5081                    #if ENABLED(MESH_G28_REST_ORIGIN)
   5082                      current_position[Z_AXIS] = Z_MIN_POS;
   5083                      set_destination_from_current();
   5084                      buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
   5085                      stepper.synchronize();
   5086                    #endif
   5087          
   5088                    #if ENABLED(LCD_BED_LEVELING)
   5089                      lcd_wait_for_move = false;
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x7278             STRB     R0,[R7, #+9]
   \   00000126   0xE063             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5090                    #endif
   5091                  }
   5092                  break;
   5093          
   5094                case MeshSet:
   5095                  if (parser.seenval('X')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_17: (+1)
   \   00000128   0x2058             MOVS     R0,#+88
   \   0000012A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD01E             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_18
   5096                    px = parser.value_int() - 1;
   \   00000132   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000136   0x1E40             SUBS     R0,R0,#+1
   \   00000138   0xF88D 0x0001      STRB     R0,[SP, #+1]
   5097                    if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
   \   0000013C   0xF99D 0x0001      LDRSB    R0,[SP, #+1]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD405             BMI.N    ??gcode_G29_MESH_BED_LEVELING_19
   \   00000144   0x4E4A             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
   \   00000146   0xF896 0x1060      LDRB     R1,[R6, #+96]
   \   0000014A   0x1E49             SUBS     R1,R1,#+1
   \   0000014C   0x4281             CMP      R1,R0
   \   0000014E   0xDA03             BGE.N    ??gcode_G29_MESH_BED_LEVELING_20
   5098                      SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
   \                     ??gcode_G29_MESH_BED_LEVELING_19: (+1)
   \   00000150   0x484D             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x50
   \   00000152   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5099                      return;
   \   00000156   0xE06D             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5100                    }
   5101                  }
   5102                  else {
   5103                    SERIAL_CHAR('X'); echo_not_entered();
   5104                    return;
   5105                  }
   5106          
   5107                  if (parser.seenval('Y')) {
   \                     ??gcode_G29_MESH_BED_LEVELING_20: (+1)
   \   00000158   0x2059             MOVS     R0,#+89
   \   0000015A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000015E   0x2800             CMP      R0,#+0
   \   00000160   0xD10D             BNE.N    ??gcode_G29_MESH_BED_LEVELING_21
   5108                    py = parser.value_int() - 1;
   5109                    if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
   5110                      SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
   5111                      return;
   5112                    }
   5113                  }
   5114                  else {
   5115                    SERIAL_CHAR('Y'); echo_not_entered();
   \   00000162   0x2159             MOVS     R1,#+89
   \   00000164   0x4839             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   00000166   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   0000016A   0x.... 0x....      BL       _Z16echo_not_enteredv
   5116                    return;
   \   0000016E   0xE061             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5117                  }
   \                     ??gcode_G29_MESH_BED_LEVELING_18: (+1)
   \   00000170   0x2158             MOVS     R1,#+88
   \   00000172   0x4836             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   00000174   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000178   0x.... 0x....      BL       _Z16echo_not_enteredv
   \   0000017C   0xE05A             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   \                     ??gcode_G29_MESH_BED_LEVELING_21: (+1)
   \   0000017E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000182   0x1E40             SUBS     R0,R0,#+1
   \   00000184   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000188   0xF99D 0x0000      LDRSB    R0,[SP, #+0]
   \   0000018C   0x2800             CMP      R0,#+0
   \   0000018E   0xD405             BMI.N    ??gcode_G29_MESH_BED_LEVELING_22
   \   00000190   0xF106 0x0160      ADD      R1,R6,#+96
   \   00000194   0x7849             LDRB     R1,[R1, #+1]
   \   00000196   0x1E49             SUBS     R1,R1,#+1
   \   00000198   0x4281             CMP      R1,R0
   \   0000019A   0xDA03             BGE.N    ??gcode_G29_MESH_BED_LEVELING_23
   \                     ??gcode_G29_MESH_BED_LEVELING_22: (+1)
   \   0000019C   0x483B             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x54
   \   0000019E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000001A2   0xE047             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5118          
   5119                  if (parser.seenval('Z'))
   \                     ??gcode_G29_MESH_BED_LEVELING_23: (+1)
   \   000001A4   0x205A             MOVS     R0,#+90
   \   000001A6   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001AA   0x2800             CMP      R0,#+0
   \   000001AC   0xD017             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
   5120                    mbl.z_values[px][py] = parser.value_linear_units();
   \   000001AE   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001B2   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   000001B6   0xF99D 0x2001      LDRSB    R2,[SP, #+1]
   \   000001BA   0xEB02 0x0342      ADD      R3,R2,R2, LSL #+1
   \   000001BE   0x4A34             LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x58
   \   000001C0   0xEB02 0x1203      ADD      R2,R2,R3, LSL #+4
   \   000001C4   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
   5121                  else {
   5122                    SERIAL_CHAR('Z'); echo_not_entered();
   5123                    return;
   5124                  }
   5125                  break;
   \   000001C8   0xE012             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   5126          
   5127                case MeshSetZOffset:
   5128                  if (parser.seenval('Z'))
   \                     ??gcode_G29_MESH_BED_LEVELING_25: (+1)
   \   000001CA   0x205A             MOVS     R0,#+90
   \   000001CC   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000001D0   0x2800             CMP      R0,#+0
   \   000001D2   0xD004             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
   5129                    mbl.z_offset = parser.value_linear_units();
   \   000001D4   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000001D8   0x492E             LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x5C
   \   000001DA   0x6008             STR      R0,[R1, #+0]
   5130                  else {
   5131                    SERIAL_CHAR('Z'); echo_not_entered();
   5132                    return;
   5133                  }
   5134                  break;
   \   000001DC   0xE008             B.N      ??gcode_G29_MESH_BED_LEVELING_4
   \                     ??gcode_G29_MESH_BED_LEVELING_24: (+1)
   \   000001DE   0x215A             MOVS     R1,#+90
   \   000001E0   0x481A             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   000001E2   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000001E6   0x.... 0x....      BL       _Z16echo_not_enteredv
   \   000001EA   0xE023             B.N      ??gcode_G29_MESH_BED_LEVELING_3
   5135          
   5136                case MeshReset:
   5137                  reset_bed_level();
   \                     ??gcode_G29_MESH_BED_LEVELING_26: (+1)
   \   000001EC   0x.... 0x....      BL       _Z15reset_bed_levelv
   5138                  break;
   5139          
   5140              } // switch(state)
   5141          
   5142              if (state == MeshStart || state == MeshNext) {
   \                     ??gcode_G29_MESH_BED_LEVELING_4: (+1)
   \   000001F0   0x2C01             CMP      R4,#+1
   \   000001F2   0xD001             BEQ.N    ??gcode_G29_MESH_BED_LEVELING_27
   \   000001F4   0x2C02             CMP      R4,#+2
   \   000001F6   0xD11B             BNE.N    ??gcode_G29_MESH_BED_LEVELING_28
   5143                SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
   \                     ??gcode_G29_MESH_BED_LEVELING_27: (+1)
   \   000001F8   0x4E1D             LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
   \   000001FA   0xF106 0x0860      ADD      R8,R6,#+96
   \   000001FE   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000202   0xF898 0x1001      LDRB     R1,[R8, #+1]
   \   00000206   0x4341             MULS     R1,R1,R0
   \   00000208   0x4D12             LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
   \   0000020A   0x6828             LDR      R0,[R5, #+0]
   \   0000020C   0x4288             CMP      R0,R1
   \   0000020E   0xDA00             BGE.N    ??gcode_G29_MESH_BED_LEVELING_29
   \   00000210   0x4601             MOV      R1,R0
   \                     ??gcode_G29_MESH_BED_LEVELING_29: (+1)
   \   00000212   0x4821             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x60
   \   00000214   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   5144                SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
   \   00000218   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   0000021C   0xF898 0x1001      LDRB     R1,[R8, #+1]
   \   00000220   0x4341             MULS     R1,R1,R0
   \   00000222   0x481E             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x64
   \   00000224   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000228   0x210A             MOVS     R1,#+10
   \   0000022A   0x4808             LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
   \   0000022C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5145              }
   5146          
   5147              report_current_position();
   \                     ??gcode_G29_MESH_BED_LEVELING_28: (+1)
   \   00000230   0x.... 0x....      BL       _Z23report_current_positionv
   5148            }
   \                     ??gcode_G29_MESH_BED_LEVELING_3: (+1)
   \   00000234   0xE8BD 0x81F3      POP      {R0,R1,R4-R8,PC}  ;; return
   \                     ??gcode_G29_MESH_BED_LEVELING_2:
   \   00000238   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
   \   0000023C   0x........         DC32     _ZN7Planner15leveling_activeE
   \   00000240   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
   \   00000244   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
   \   00000248   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
   \   0000024C   0x........         DC32     Serial3
   \   00000250   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
   \   00000254   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
   \   00000258   0x........         DC32     axis_homed
   \   0000025C   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
   \   00000260   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
   \   00000264   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
   \   00000268   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
   \   0000026C   0x........         DC32     mks_heating_busy+0x10
   \   00000270   0x........         DC32     mksCfg
   \   00000274   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \   00000278   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \   0000027C   0x........         DC32     mks_heating_busy
   \   00000280   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
   \   00000284   0x........         DC32     _ZN17mesh_bed_leveling8has_meshE
   \   00000288   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
   \   0000028C   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
   \   00000290   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE
   \   00000294   0x........         DC32     _ZN17mesh_bed_leveling8z_offsetE
   \   00000298   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
   \   0000029C   0x........         DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
   5149          #endif
   5150          //#if 1
   5151          //#elif OLDSCHOOL_ABL
   5152          
   5153            #if 1//ABL_GRID
   5154              #if ENABLED(PROBE_Y_FIRST)
   5155                #define PR_OUTER_VAR xCount
   5156                #define PR_OUTER_END abl_grid_points_x
   5157                #define PR_INNER_VAR yCount
   5158                #define PR_INNER_END abl_grid_points_y
   5159              #else
   5160                #define PR_OUTER_VAR yCount
   5161                #define PR_OUTER_END abl_grid_points_y
   5162                #define PR_INNER_VAR xCount
   5163                #define PR_INNER_END abl_grid_points_x
   5164              #endif
   5165            #endif
   5166          
   5167            /**
   5168             * G29: Detailed Z probe, probes the bed at 3 or more points.
   5169             *      Will fail if the printer has not been homed with G28.
   5170             *
   5171             * Enhanced G29 Auto Bed Leveling Probe Routine
   5172             *
   5173             *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
   5174             *     or alter the bed level data. Useful to check the topology
   5175             *     after a first run of G29.
   5176             *
   5177             *  J  Jettison current bed leveling data
   5178             *
   5179             *  V  Set the verbose level (0-4). Example: "G29 V3"
   5180             *
   5181             * Parameters With LINEAR leveling only:
   5182             *
   5183             *  P  Set the size of the grid that will be probed (P x P points).
   5184             *     Example: "G29 P4"
   5185             *
   5186             *  X  Set the X size of the grid that will be probed (X x Y points).
   5187             *     Example: "G29 X7 Y5"
   5188             *
   5189             *  Y  Set the Y size of the grid that will be probed (X x Y points).
   5190             *
   5191             *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
   5192             *     This is useful for manual bed leveling and finding flaws in the bed (to
   5193             *     assist with part placement).
   5194             *     Not supported by non-linear delta printer bed leveling.
   5195             *
   5196             * Parameters With LINEAR and BILINEAR leveling only:
   5197             *
   5198             *  S  Set the XY travel speed between probe points (in units/min)
   5199             *
   5200             *  F  Set the Front limit of the probing grid
   5201             *  B  Set the Back limit of the probing grid
   5202             *  L  Set the Left limit of the probing grid
   5203             *  R  Set the Right limit of the probing grid
   5204             *
   5205             * Parameters with DEBUG_LEVELING_FEATURE only:
   5206             *
   5207             *  C  Make a totally fake grid with no actual probing.
   5208             *     For use in testing when no probing is possible.
   5209             *
   5210             * Parameters with BILINEAR leveling only:
   5211             *
   5212             *  Z  Supply an additional Z probe offset
   5213             *
   5214             * Extra parameters with PROBE_MANUALLY:
   5215             *
   5216             *  To do manual probing simply repeat G29 until the procedure is complete.
   5217             *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
   5218             *
   5219             *  Q  Query leveling and G29 state
   5220             *
   5221             *  A  Abort current leveling procedure
   5222             *
   5223             * Extra parameters with BILINEAR only:
   5224             *
   5225             *  W  Write a mesh point. (If G29 is idle.)
   5226             *  I  X index for mesh point
   5227             *  J  Y index for mesh point
   5228             *  X  X for mesh point, overrides I
   5229             *  Y  Y for mesh point, overrides J
   5230             *  Z  Z for mesh point. Otherwise, raw current Z.
   5231             *
   5232             * Without PROBE_MANUALLY:
   5233             *
   5234             *  E  By default G29 will engage the Z probe, test the bed, then disengage.
   5235             *     Include "E" to engage/disengage the Z probe for each sample.
   5236             *     There's no extra effect if you have a fixed Z probe.
   5237             *
   5238             */

   \                                 In section .text, align 4
   5239            inline void gcode_G29() {
   \                     _Z9gcode_G29v: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xF5AD 0x7D4B      SUB      SP,SP,#+812
   5240          
   5241              // G29 Q is also available if debugging
   5242              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5243                const bool query = parser.seen('Q');
   5244                const uint8_t old_debug_flags = marlin_debug_flags;
   5245                if (query) marlin_debug_flags |= DEBUG_LEVELING;
   5246                if (DEBUGGING(LEVELING)) {
   5247                  DEBUG_POS(">>> G29", current_position);
   5248                  log_machine_info();
   5249                }
   5250                marlin_debug_flags = old_debug_flags;
   5251                #if DISABLED(PROBE_MANUALLY)
   5252                  if (query) return;
   5253                #endif
   5254              #endif
   5255          
   5256              #if ENABLED(PROBE_MANUALLY)
   5257                const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
   5258              #endif
   5259          
   5260              #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
   5261                const bool faux = parser.boolval('C');
   5262              #elif ENABLED(PROBE_MANUALLY)
   5263                const bool faux = no_action;
   5264              #else
   5265                bool constexpr faux = false;
   5266              #endif
   5267          
   5268              // Don't allow auto-leveling without homing first
   5269              if (axis_unhomed_error()) return;
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0x4611             MOV      R1,R2
   \   0000000C   0x4608             MOV      R0,R1
   \   0000000E   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xF040 0x8673      BNE.W    ??gcode_G29_0
   5270          
   5271              // Define local vars 'static' for manual probing, 'auto' otherwise
   5272              #if ENABLED(PROBE_MANUALLY)
   5273                #define ABL_VAR static
   5274              #else
   5275                #define ABL_VAR
   5276              #endif
   5277          
   5278              ABL_VAR int verbose_level=0;
   5279              ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x900E             STR      R0,[SP, #+56]
   \   0000001C   0x900D             STR      R0,[SP, #+52]
   \   0000001E   0x9009             STR      R0,[SP, #+36]
   5280              ABL_VAR bool dryrun=false, abl_should_enable=false;
   5281          
   5282              //#if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   5283                ABL_VAR int abl_probe_index=0;
   \   00000020   0x4606             MOV      R6,R0
   5284              //#endif
   5285          
   5286              #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
   5287                ABL_VAR bool enable_soft_endstops = true;
   5288              #endif
   5289          
   5290              #if 1//ABL_GRID
   5291          
   5292                #if ENABLED(PROBE_MANUALLY)
   5293                  ABL_VAR uint8_t PR_OUTER_VAR;
   5294                  ABL_VAR  int8_t PR_INNER_VAR;
   5295                #endif
   5296          
   5297                ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
   \   00000022   0x9005             STR      R0,[SP, #+20]
   \   00000024   0x9002             STR      R0,[SP, #+8]
   5298                ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
   \   00000026   0x9012             STR      R0,[SP, #+72]
   \   00000028   0x9007             STR      R0,[SP, #+28]
   \   0000002A   0xF8DF 0x0CDC      LDR.W    R0,??gcode_G29_1
   \   0000002E   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   00000032   0x900C             STR      R0,[SP, #+48]
   5299          
   5300                //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5301                  ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
   5302                                  abl_grid_points_y = GRID_MAX_POINTS_Y;
   \   00000034   0xF8DF 0x1CD4      LDR.W    R1,??gcode_G29_1+0x4
   \   00000038   0x9108             STR      R1,[SP, #+32]
   \   0000003A   0x7849             LDRB     R1,[R1, #+1]
   \   0000003C   0x9104             STR      R1,[SP, #+16]
   5303                  ABL_VAR bool do_topography_map=0;
   \   0000003E   0x4632             MOV      R2,R6
   \   00000040   0xF88D 0x200C      STRB     R2,[SP, #+12]
   5304                //#else // Bilinear
   5305                //  uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
   5306                //                    abl_grid_points_y = GRID_MAX_POINTS_Y;
   5307                //#endif
   5308          
   5309                //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5310                  ABL_VAR int abl2;
   5311                //#elif ENABLED(PROBE_MANUALLY) // Bilinear
   5312                //  int constexpr abl2 = GRID_MAX_POINTS;
   5313                //#endif
   5314                if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = GRID_MAX_POINTS;
   \   00000044   0x4348             MULS     R0,R1,R0
   \   00000046   0xF8DF 0x1CC0      LDR.W    R1,??gcode_G29_1
   \   0000004A   0xF891 0x1040      LDRB     R1,[R1, #+64]
   \   0000004E   0x2206             MOVS     R2,#+6
   \   00000050   0x4211             TST      R1,R2
   \   00000052   0xD100             BNE.N    ??gcode_G29_2
   \   00000054   0x9011             STR      R0,[SP, #+68]
   5315          
   5316                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5317          
   5318                  ABL_VAR float zoffset;
   5319          
   5320                //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5321          
   5322                  ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
   5323          
   5324                  ABL_VAR float *eqnAMatrix=NULL,//[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
   5325                                *eqnBVector=NULL,//[GRID_MAX_POINTS],     // "B" vector of Z points
   5326                                mean;
   5327          		eqnAMatrix = (float *)malloc((GRID_MAX_POINTS * 3 + 1) * sizeof(float));
   \                     ??gcode_G29_2: (+1)
   \   00000056   0xEB00 0x0040      ADD      R0,R0,R0, LSL #+1
   \   0000005A   0x1C40             ADDS     R0,R0,#+1
   \   0000005C   0x0080             LSLS     R0,R0,#+2
   \   0000005E   0x.... 0x....      BL       malloc
   \   00000062   0x900B             STR      R0,[SP, #+44]
   5328          		if(eqnAMatrix == NULL)
   \   00000064   0x2800             CMP      R0,#+0
   \   00000066   0xD107             BNE.N    ??gcode_G29_3
   5329          			{
   5330          			Running = false;
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0xF8DF 0x1CA4      LDR.W    R1,??gcode_G29_1+0x8
   \   0000006E   0x7108             STRB     R0,[R1, #+4]
   5331          			kill("malloc eqnAMatrix err!");
   \   00000070   0xF8DF 0x0CA0      LDR.W    R0,??gcode_G29_1+0xC
   \   00000074   0x.... 0x....      BL       _Z4killPKc
   5332          			}
   5333          		for(int i=0;i<GRID_MAX_POINTS * 3 + 1;i++)
   \                     ??gcode_G29_3: (+1)
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0xE004             B.N      ??gcode_G29_4
   5334                      *(eqnAMatrix+i) = 0.0;
   \                     ??gcode_G29_5: (+1)
   \   0000007C   0x4631             MOV      R1,R6
   \   0000007E   0x9A0B             LDR      R2,[SP, #+44]
   \   00000080   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   00000084   0x1C40             ADDS     R0,R0,#+1
   \                     ??gcode_G29_4: (+1)
   \   00000086   0xF8DF 0x1C80      LDR.W    R1,??gcode_G29_1
   \   0000008A   0xF891 0x1060      LDRB     R1,[R1, #+96]
   \   0000008E   0x9A08             LDR      R2,[SP, #+32]
   \   00000090   0x7852             LDRB     R2,[R2, #+1]
   \   00000092   0x4351             MULS     R1,R2,R1
   \   00000094   0xEB01 0x0241      ADD      R2,R1,R1, LSL #+1
   \   00000098   0x1C52             ADDS     R2,R2,#+1
   \   0000009A   0x4290             CMP      R0,R2
   \   0000009C   0xDBEE             BLT.N    ??gcode_G29_5
   5335          
   5336          		
   5337          		eqnBVector = (float *)malloc((GRID_MAX_POINTS + 1) * sizeof(float));
   \   0000009E   0x1C48             ADDS     R0,R1,#+1
   \   000000A0   0x0080             LSLS     R0,R0,#+2
   \   000000A2   0x.... 0x....      BL       malloc
   \   000000A6   0x9010             STR      R0,[SP, #+64]
   5338          		if(eqnBVector == NULL)
   \   000000A8   0x2800             CMP      R0,#+0
   \   000000AA   0xD107             BNE.N    ??gcode_G29_6
   5339          		{
   5340          			Running = false;
   \   000000AC   0x4630             MOV      R0,R6
   \   000000AE   0xF8DF 0x1C60      LDR.W    R1,??gcode_G29_1+0x8
   \   000000B2   0x7108             STRB     R0,[R1, #+4]
   5341          			kill("malloc eqnBVector err!");
   \   000000B4   0xF8DF 0x0C60      LDR.W    R0,??gcode_G29_1+0x10
   \   000000B8   0x.... 0x....      BL       _Z4killPKc
   5342          		}
   5343          		for(int i=0;i<GRID_MAX_POINTS + 1;i++) 	*(eqnBVector+i) = 0.0;        
   \                     ??gcode_G29_6: (+1)
   \   000000BC   0x4630             MOV      R0,R6
   \   000000BE   0xE004             B.N      ??gcode_G29_7
   \                     ??gcode_G29_8: (+1)
   \   000000C0   0x4631             MOV      R1,R6
   \   000000C2   0x9A10             LDR      R2,[SP, #+64]
   \   000000C4   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
   \   000000C8   0x1C40             ADDS     R0,R0,#+1
   \                     ??gcode_G29_7: (+1)
   \   000000CA   0xF8DF 0x1C3C      LDR.W    R1,??gcode_G29_1
   \   000000CE   0xF891 0x1060      LDRB     R1,[R1, #+96]
   \   000000D2   0x9A08             LDR      R2,[SP, #+32]
   \   000000D4   0x7852             LDRB     R2,[R2, #+1]
   \   000000D6   0x4351             MULS     R1,R2,R1
   \   000000D8   0x1C49             ADDS     R1,R1,#+1
   \   000000DA   0x4288             CMP      R0,R1
   \   000000DC   0xDBF0             BLT.N    ??gcode_G29_8
   5344                //#endif
   5345          
   5346             // #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5347          
   5348                #if ENABLED(PROBE_MANUALLY)
   5349                  int constexpr abl2 = 3; // used to show total points
   5350                #endif
   5351          
   5352                // Probe at 3 arbitrary points
   5353                ABL_VAR vector_3 points[3] = {
   \   000000DE   0x4633             MOV      R3,R6
   \   000000E0   0x9808             LDR      R0,[SP, #+32]
   \   000000E2   0x6C02             LDR      R2,[R0, #+64]
   \   000000E4   0x6BC1             LDR      R1,[R0, #+60]
   \   000000E6   0xA816             ADD      R0,SP,#+88
   \   000000E8   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   000000EC   0x4633             MOV      R3,R6
   \   000000EE   0x9808             LDR      R0,[SP, #+32]
   \   000000F0   0x6C82             LDR      R2,[R0, #+72]
   \   000000F2   0x6C41             LDR      R1,[R0, #+68]
   \   000000F4   0xA819             ADD      R0,SP,#+100
   \   000000F6   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   000000FA   0x4633             MOV      R3,R6
   \   000000FC   0x9808             LDR      R0,[SP, #+32]
   \   000000FE   0x6D02             LDR      R2,[R0, #+80]
   \   00000100   0x6CC1             LDR      R1,[R0, #+76]
   \   00000102   0xA81C             ADD      R0,SP,#+112
   \   00000104   0x.... 0x....      BL       _ZN8vector_3C1Efff
   5354                  vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
   5355                  vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
   5356                  vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
   5357                };
   5358          
   5359             // #endif // AUTO_BED_LEVELING_3POINT
   5360          
   5361              //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5362              struct linear_fit_data lsf_results;
   5363              if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_LINEAR)
   \   00000108   0xF8DF 0x0BFC      LDR.W    R0,??gcode_G29_1
   \   0000010C   0xF890 0x4040      LDRB     R4,[R0, #+64]
   \   00000110   0xF014 0x0504      ANDS     R5,R4,#0x4
   \   00000114   0xD002             BEQ.N    ??gcode_G29_9
   5364              {
   5365                incremental_LSF_reset(&lsf_results);
   \   00000116   0xA82B             ADD      R0,SP,#+172
   \   00000118   0x.... 0x....      BL       _Z21incremental_LSF_resetP15linear_fit_data
   5366              }
   5367              //#endif
   5368          
   5369              /**
   5370               * On the initial G29 fetch command parameters.
   5371               */
   5372              if (!g29_in_progress) {
   5373          #if 0
   5374                #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
   5375                  abl_probe_index = -1;
   5376                #endif
   5377          #else
   5378                if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   \                     ??gcode_G29_9: (+1)
   \   0000011C   0x2D00             CMP      R5,#+0
   \   0000011E   0xD001             BEQ.N    ??gcode_G29_10
   5379                   abl_probe_index = -1;
   \   00000120   0xF04F 0x36FF      MOV      R6,#-1
   \                     ??gcode_G29_10: (+1)
   \   00000124   0xF8DF 0x0BF4      LDR.W    R0,??gcode_G29_1+0x14
   \   00000128   0xF890 0x9000      LDRB     R9,[R0, #+0]
   5380          #endif
   5381                abl_should_enable = planner.leveling_active;
   5382          
   5383                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5384                if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
   \   0000012C   0x2C08             CMP      R4,#+8
   \   0000012E   0xF040 0x80CD      BNE.W    ??gcode_G29_11
   5385          
   5386                  if (parser.seen('W')) {
   \   00000132   0x2057             MOVS     R0,#+87
   \   00000134   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000138   0x2800             CMP      R0,#+0
   \   0000013A   0xF000 0x80C7      BEQ.W    ??gcode_G29_11
   5387                    if (!leveling_is_valid()) {
   \   0000013E   0x.... 0x....      BL       _Z17leveling_is_validv
   \   00000142   0x2800             CMP      R0,#+0
   \   00000144   0xD109             BNE.N    ??gcode_G29_12
   5388                      SERIAL_ERROR_START();
   \   00000146   0xF8DF 0x0BD8      LDR.W    R0,??gcode_G29_1+0x18
   \   0000014A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5389                      SERIAL_ERRORLNPGM("No bilinear grid");
   \   0000014E   0xF8DF 0x0BD4      LDR.W    R0,??gcode_G29_1+0x1C
   \   00000152   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5390                      return;
   \   00000156   0xF000 0xBDD2      B.W      ??gcode_G29_0
   5391                    }
   5392          
   5393                    const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
   \                     ??gcode_G29_12: (+1)
   \   0000015A   0xF8DF 0x4BCC      LDR.W    R4,??gcode_G29_1+0x20
   \   0000015E   0x205A             MOVS     R0,#+90
   \   00000160   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000164   0x2800             CMP      R0,#+0
   \   00000166   0xD006             BEQ.N    ??gcode_G29_13
   \   00000168   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000016C   0x6C21             LDR      R1,[R4, #+64]
   \   0000016E   0x.... 0x....      BL       __aeabi_fsub
   \   00000172   0x4605             MOV      R5,R0
   \   00000174   0xE000             B.N      ??gcode_G29_14
   \                     ??gcode_G29_13: (+1)
   \   00000176   0x6925             LDR      R5,[R4, #+16]
   5394                    if (!WITHIN(rz, -10, 10)) {
   \                     ??gcode_G29_14: (+1)
   \   00000178   0x4628             MOV      R0,R5
   \   0000017A   0xF8DF 0x1BB0      LDR.W    R1,??gcode_G29_1+0x24  ;; 0xc1200000
   \   0000017E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000182   0xD804             BHI.N    ??gcode_G29_15
   \   00000184   0xF8DF 0x1BA8      LDR.W    R1,??gcode_G29_1+0x28  ;; 0x41200001
   \   00000188   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000018C   0xD309             BCC.N    ??gcode_G29_16
   5395                      SERIAL_ERROR_START();
   \                     ??gcode_G29_15: (+1)
   \   0000018E   0xF8DF 0x0B90      LDR.W    R0,??gcode_G29_1+0x18
   \   00000192   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5396                      SERIAL_ERRORLNPGM("Bad Z value");
   \   00000196   0xF8DF 0x0B9C      LDR.W    R0,??gcode_G29_1+0x2C
   \   0000019A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5397                      return;
   \   0000019E   0xF000 0xBDAE      B.W      ??gcode_G29_0
   5398                    }
   5399          
   5400                    const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
   \                     ??gcode_G29_16: (+1)
   \   000001A2   0xF06F 0x4600      MVN      R6,#-2147483648
   \   000001A6   0x4631             MOV      R1,R6
   \   000001A8   0x2058             MOVS     R0,#+88
   \   000001AA   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   000001AE   0x6BA1             LDR      R1,[R4, #+56]
   \   000001B0   0x.... 0x....      BL       __aeabi_fsub
   \   000001B4   0x4680             MOV      R8,R0
   5401                                ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
   \   000001B6   0x4631             MOV      R1,R6
   \   000001B8   0x2059             MOVS     R0,#+89
   \   000001BA   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   000001BE   0x6BE1             LDR      R1,[R4, #+60]
   \   000001C0   0x.... 0x....      BL       __aeabi_fsub
   \   000001C4   0x4606             MOV      R6,R0
   5402                    int8_t i = parser.byteval('I', -1),
   \   000001C6   0x21FF             MOVS     R1,#+255
   \   000001C8   0x2049             MOVS     R0,#+73
   \   000001CA   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   000001CE   0x4607             MOV      R7,R0
   \   000001D0   0xB27F             SXTB     R7,R7
   5403                           j = parser.byteval('J', -1);
   \   000001D2   0x21FF             MOVS     R1,#+255
   \   000001D4   0x204A             MOVS     R0,#+74
   \   000001D6   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   000001DA   0x4604             MOV      R4,R0
   \   000001DC   0xB264             SXTB     R4,R4
   5404          
   5405                    if (!isnan(rx) && !isnan(ry)) {
   \   000001DE   0x4640             MOV      R0,R8
   \   000001E0   0x.... 0x....      BL       __iar_FDtest
   \   000001E4   0x2802             CMP      R0,#+2
   \   000001E6   0xD048             BEQ.N    ??gcode_G29_17
   \   000001E8   0x4630             MOV      R0,R6
   \   000001EA   0x.... 0x....      BL       __iar_FDtest
   \   000001EE   0x2802             CMP      R0,#+2
   \   000001F0   0xD043             BEQ.N    ??gcode_G29_17
   5406                      // Get nearest i / j from rx / ry
   5407                      i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000001F2   0xF8DF 0x4B1C      LDR.W    R4,??gcode_G29_1+0x8
   \   000001F6   0x69A0             LDR      R0,[R4, #+24]
   \   000001F8   0x.... 0x....      BL       __aeabi_i2f
   \   000001FC   0x4601             MOV      R1,R0
   \   000001FE   0x4640             MOV      R0,R8
   \   00000200   0x.... 0x....      BL       __aeabi_fsub
   \   00000204   0x.... 0x....      BL       __aeabi_f2d
   \   00000208   0x2200             MOVS     R2,#+0
   \   0000020A   0x4613             MOV      R3,R2
   \   0000020C   0x.... 0x....      BL       __aeabi_dadd
   \   00000210   0x2200             MOVS     R2,#+0
   \   00000212   0x4613             MOV      R3,R2
   \   00000214   0x.... 0x....      BL       __aeabi_ddiv
   \   00000218   0x.... 0x....      BL       __aeabi_d2iz
   \   0000021C   0x4607             MOV      R7,R0
   \   0000021E   0xB27F             SXTB     R7,R7
   5408                      j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000220   0x69E0             LDR      R0,[R4, #+28]
   \   00000222   0x.... 0x....      BL       __aeabi_i2f
   \   00000226   0x4601             MOV      R1,R0
   \   00000228   0x4630             MOV      R0,R6
   \   0000022A   0x.... 0x....      BL       __aeabi_fsub
   \   0000022E   0x.... 0x....      BL       __aeabi_f2d
   \   00000232   0x2200             MOVS     R2,#+0
   \   00000234   0x4613             MOV      R3,R2
   \   00000236   0x.... 0x....      BL       __aeabi_dadd
   \   0000023A   0x2200             MOVS     R2,#+0
   \   0000023C   0x4613             MOV      R3,R2
   \   0000023E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000242   0x.... 0x....      BL       __aeabi_d2iz
   \   00000246   0x4604             MOV      R4,R0
   \   00000248   0xB264             SXTB     R4,R4
   5409                      i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
   \   0000024A   0x2F00             CMP      R7,#+0
   \   0000024C   0xD501             BPL.N    ??gcode_G29_18
   \   0000024E   0x2700             MOVS     R7,#+0
   \   00000250   0xE007             B.N      ??gcode_G29_19
   \                     ??gcode_G29_18: (+1)
   \   00000252   0xF8DF 0x0AB4      LDR.W    R0,??gcode_G29_1
   \   00000256   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   0000025A   0x1E41             SUBS     R1,R0,#+1
   \   0000025C   0x42B9             CMP      R1,R7
   \   0000025E   0xDA00             BGE.N    ??gcode_G29_19
   \   00000260   0x1E47             SUBS     R7,R0,#+1
   \                     ??gcode_G29_19: (+1)
   \   00000262   0xB27F             SXTB     R7,R7
   5410                      j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
   \   00000264   0x2C00             CMP      R4,#+0
   \   00000266   0xD501             BPL.N    ??gcode_G29_20
   \   00000268   0x2400             MOVS     R4,#+0
   \   0000026A   0xE005             B.N      ??gcode_G29_21
   \                     ??gcode_G29_20: (+1)
   \   0000026C   0x9808             LDR      R0,[SP, #+32]
   \   0000026E   0x7840             LDRB     R0,[R0, #+1]
   \   00000270   0x1E41             SUBS     R1,R0,#+1
   \   00000272   0x42A1             CMP      R1,R4
   \   00000274   0xDA00             BGE.N    ??gcode_G29_21
   \   00000276   0x1E44             SUBS     R4,R0,#+1
   \                     ??gcode_G29_21: (+1)
   \   00000278   0xB264             SXTB     R4,R4
   5411                    }
   5412                    if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
   \                     ??gcode_G29_17: (+1)
   \   0000027A   0x2F00             CMP      R7,#+0
   \   0000027C   0xF100 0x853F      BMI.W    ??gcode_G29_0
   \   00000280   0xF8DF 0x0A84      LDR.W    R0,??gcode_G29_1
   \   00000284   0xF890 0x0060      LDRB     R0,[R0, #+96]
   \   00000288   0x1E40             SUBS     R0,R0,#+1
   \   0000028A   0x42B8             CMP      R0,R7
   \   0000028C   0xF2C0 0x8537      BLT.W    ??gcode_G29_0
   \   00000290   0x2C00             CMP      R4,#+0
   \   00000292   0xF100 0x8534      BMI.W    ??gcode_G29_0
   \   00000296   0x9808             LDR      R0,[SP, #+32]
   \   00000298   0x7840             LDRB     R0,[R0, #+1]
   \   0000029A   0x42A0             CMP      R0,R4
   \   0000029C   0xF2C0 0x852F      BLT.W    ??gcode_G29_0
   5413                      set_bed_leveling_enabled(false);
   \   000002A0   0x2000             MOVS     R0,#+0
   \   000002A2   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5414                      z_values[i][j] = rz;
   \   000002A6   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000002AA   0xF8DF 0x1A8C      LDR.W    R1,??gcode_G29_1+0x30
   \   000002AE   0xEB01 0x1000      ADD      R0,R1,R0, LSL #+4
   \   000002B2   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   5415                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5416                        bed_level_virt_interpolate();
   5417                      #endif
   5418                      set_bed_leveling_enabled(abl_should_enable);
   \   000002B6   0x4648             MOV      R0,R9
   \   000002B8   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5419                      if (abl_should_enable) report_current_position();
   \   000002BC   0xF1B9 0x0F00      CMP      R9,#+0
   \   000002C0   0xF000 0x851D      BEQ.W    ??gcode_G29_0
   \   000002C4   0x.... 0x....      BL       _Z23report_current_positionv
   5420                    }
   5421                    return;
   \   000002C8   0xF000 0xBD19      B.W      ??gcode_G29_0
   5422                  } // parser.seen('W')
   5423                }
   5424                //#endif
   5425          
   5426                // Jettison bed leveling data
   5427                if (parser.seen('J')) {
   \                     ??gcode_G29_11: (+1)
   \   000002CC   0x204A             MOVS     R0,#+74
   \   000002CE   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000002D2   0x2800             CMP      R0,#+0
   \   000002D4   0xD003             BEQ.N    ??gcode_G29_22
   5428                  reset_bed_level();
   \   000002D6   0x.... 0x....      BL       _Z15reset_bed_levelv
   5429                  return;
   \   000002DA   0xF000 0xBD10      B.W      ??gcode_G29_0
   5430                }
   5431          
   5432                verbose_level = parser.intval('V');
   \                     ??gcode_G29_22: (+1)
   \   000002DE   0x2100             MOVS     R1,#+0
   \   000002E0   0x2056             MOVS     R0,#+86
   \   000002E2   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   000002E6   0x900A             STR      R0,[SP, #+40]
   5433                if (!WITHIN(verbose_level, 0, 4)) {
   \   000002E8   0x2805             CMP      R0,#+5
   \   000002EA   0xD305             BCC.N    ??gcode_G29_23
   5434                  SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   \   000002EC   0xF8DF 0x0A4C      LDR.W    R0,??gcode_G29_1+0x34
   \   000002F0   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5435                  return;
   \   000002F4   0xF000 0xBD03      B.W      ??gcode_G29_0
   5436                }
   5437          
   5438                dryrun = parser.boolval('D')
   5439                  #if ENABLED(PROBE_MANUALLY)
   5440                    || no_action
   5441                  #endif
   5442                ;
   \                     ??gcode_G29_23: (+1)
   \   000002F8   0x2044             MOVS     R0,#+68
   \   000002FA   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   000002FE   0x900F             STR      R0,[SP, #+60]
   5443          
   5444                //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5445                if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   \   00000300   0xF8DF 0x0A04      LDR.W    R0,??gcode_G29_1
   \   00000304   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000308   0x0741             LSLS     R1,R0,#+29
   \   0000030A   0xD53A             BPL.N    ??gcode_G29_24
   5446                  {
   5447                  do_topography_map = verbose_level > 2 || parser.boolval('T');
   \   0000030C   0x980A             LDR      R0,[SP, #+40]
   \   0000030E   0x2803             CMP      R0,#+3
   \   00000310   0xDA05             BGE.N    ??gcode_G29_25
   \   00000312   0x2054             MOVS     R0,#+84
   \   00000314   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000318   0xF88D 0x000C      STRB     R0,[SP, #+12]
   \   0000031C   0xE002             B.N      ??gcode_G29_26
   \                     ??gcode_G29_25: (+1)
   \   0000031E   0x2001             MOVS     R0,#+1
   \   00000320   0xF88D 0x000C      STRB     R0,[SP, #+12]
   5448          
   5449                  // X and Y specify points in each direction, overriding the default
   5450                  // These values may be saved with the completed mesh
   5451                  abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
   \                     ??gcode_G29_26: (+1)
   \   00000324   0xF8DF 0x09E0      LDR.W    R0,??gcode_G29_1
   \   00000328   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   0000032C   0x2058             MOVS     R0,#+88
   \   0000032E   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000332   0xB2C0             UXTB     R0,R0
   \   00000334   0x900C             STR      R0,[SP, #+48]
   5452                  abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
   \   00000336   0x9808             LDR      R0,[SP, #+32]
   \   00000338   0x7841             LDRB     R1,[R0, #+1]
   \   0000033A   0x2059             MOVS     R0,#+89
   \   0000033C   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000340   0xB2C0             UXTB     R0,R0
   \   00000342   0x9004             STR      R0,[SP, #+16]
   5453                  if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
   \   00000344   0x2050             MOVS     R0,#+80
   \   00000346   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000034A   0x2800             CMP      R0,#+0
   \   0000034C   0xD006             BEQ.N    ??gcode_G29_27
   \   0000034E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000352   0xB2C0             UXTB     R0,R0
   \   00000354   0x9004             STR      R0,[SP, #+16]
   \   00000356   0xA804             ADD      R0,SP,#+16
   \   00000358   0x7800             LDRB     R0,[R0, #+0]
   \   0000035A   0x900C             STR      R0,[SP, #+48]
   5454          
   5455                  if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
   \                     ??gcode_G29_27: (+1)
   \   0000035C   0x980C             LDR      R0,[SP, #+48]
   \   0000035E   0x2802             CMP      R0,#+2
   \   00000360   0xDB02             BLT.N    ??gcode_G29_28
   \   00000362   0x9804             LDR      R0,[SP, #+16]
   \   00000364   0x2802             CMP      R0,#+2
   \   00000366   0xDA05             BGE.N    ??gcode_G29_29
   5456                    SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
   \                     ??gcode_G29_28: (+1)
   \   00000368   0xF8DF 0x09D4      LDR.W    R0,??gcode_G29_1+0x38
   \   0000036C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5457                    return;
   \   00000370   0xF000 0xBCC5      B.W      ??gcode_G29_0
   5458                  }
   5459          
   5460                  abl2 = abl_grid_points_x * abl_grid_points_y;
   \                     ??gcode_G29_29: (+1)
   \   00000374   0x980C             LDR      R0,[SP, #+48]
   \   00000376   0x9904             LDR      R1,[SP, #+16]
   \   00000378   0x4348             MULS     R0,R1,R0
   \   0000037A   0x9011             STR      R0,[SP, #+68]
   5461                  mean = 0;
   \   0000037C   0xF04F 0x0800      MOV      R8,#+0
   \   00000380   0xE006             B.N      ??gcode_G29_30
   5462                  }
   5463                //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5464                else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_G29_24: (+1)
   \   00000382   0x0700             LSLS     R0,R0,#+28
   \   00000384   0xD504             BPL.N    ??gcode_G29_30
   5465                {
   5466                  zoffset = parser.linearval('Z');
   \   00000386   0x2100             MOVS     R1,#+0
   \   00000388   0x205A             MOVS     R0,#+90
   \   0000038A   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000038E   0x9015             STR      R0,[SP, #+84]
   5467                }
   5468          
   5469                //#endif
   5470          
   5471                //#if ABL_GRID
   5472                if(BED_LEVELING_METHOD&ABL_GRID)  {
   \                     ??gcode_G29_30: (+1)
   \   00000390   0xF8DF 0x0974      LDR.W    R0,??gcode_G29_1
   \   00000394   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000398   0x210C             MOVS     R1,#+12
   \   0000039A   0x4208             TST      R0,R1
   \   0000039C   0xF000 0x80D6      BEQ.W    ??gcode_G29_31
   5473          
   5474                  xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
   \   000003A0   0xF8DF 0x4984      LDR.W    R4,??gcode_G29_1+0x20
   \   000003A4   0x9808             LDR      R0,[SP, #+32]
   \   000003A6   0x6941             LDR      R1,[R0, #+20]
   \   000003A8   0x2053             MOVS     R0,#+83
   \   000003AA   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   000003AE   0xF8DF 0x1994      LDR.W    R1,??gcode_G29_1+0x3C  ;; 0x42700000
   \   000003B2   0x.... 0x....      BL       __aeabi_fdiv
   \   000003B6   0x6760             STR      R0,[R4, #+116]
   5475          
   5476                  left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000003B8   0x204C             MOVS     R0,#+76
   \   000003BA   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000003BE   0x2800             CMP      R0,#+0
   \   000003C0   0xD008             BEQ.N    ??gcode_G29_32
   \   000003C2   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000003C6   0x6BA1             LDR      R1,[R4, #+56]
   \   000003C8   0x.... 0x....      BL       __aeabi_fsub
   \   000003CC   0x.... 0x....      BL       __aeabi_f2iz
   \   000003D0   0x9005             STR      R0,[SP, #+20]
   \   000003D2   0xE004             B.N      ??gcode_G29_33
   \                     ??gcode_G29_32: (+1)
   \   000003D4   0x9808             LDR      R0,[SP, #+32]
   \   000003D6   0x6A80             LDR      R0,[R0, #+40]
   \   000003D8   0x.... 0x....      BL       __aeabi_f2iz
   \   000003DC   0x9005             STR      R0,[SP, #+20]
   5477                  right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_33: (+1)
   \   000003DE   0x2052             MOVS     R0,#+82
   \   000003E0   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000003E4   0x2800             CMP      R0,#+0
   \   000003E6   0xD008             BEQ.N    ??gcode_G29_34
   \   000003E8   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000003EC   0x6BA1             LDR      R1,[R4, #+56]
   \   000003EE   0x.... 0x....      BL       __aeabi_fsub
   \   000003F2   0x.... 0x....      BL       __aeabi_f2iz
   \   000003F6   0x4605             MOV      R5,R0
   \   000003F8   0xE004             B.N      ??gcode_G29_35
   \                     ??gcode_G29_34: (+1)
   \   000003FA   0x9808             LDR      R0,[SP, #+32]
   \   000003FC   0x6AC0             LDR      R0,[R0, #+44]
   \   000003FE   0x.... 0x....      BL       __aeabi_f2iz
   \   00000402   0x4605             MOV      R5,R0
   5478                  front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_35: (+1)
   \   00000404   0x2046             MOVS     R0,#+70
   \   00000406   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000040A   0x2800             CMP      R0,#+0
   \   0000040C   0xD008             BEQ.N    ??gcode_G29_36
   \   0000040E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000412   0x6BE1             LDR      R1,[R4, #+60]
   \   00000414   0x.... 0x....      BL       __aeabi_fsub
   \   00000418   0x.... 0x....      BL       __aeabi_f2iz
   \   0000041C   0x9002             STR      R0,[SP, #+8]
   \   0000041E   0xE004             B.N      ??gcode_G29_37
   \                     ??gcode_G29_36: (+1)
   \   00000420   0x9808             LDR      R0,[SP, #+32]
   \   00000422   0x6B00             LDR      R0,[R0, #+48]
   \   00000424   0x.... 0x....      BL       __aeabi_f2iz
   \   00000428   0x9002             STR      R0,[SP, #+8]
   5479                  back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
                                                  ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_G29_37: (+1)
   \   0000042A   0x2042             MOVS     R0,#+66
   \   0000042C   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000430   0x2800             CMP      R0,#+0
   \   00000432   0xD008             BEQ.N    ??gcode_G29_38
   \   00000434   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000438   0x6BE1             LDR      R1,[R4, #+60]
   \   0000043A   0x.... 0x....      BL       __aeabi_fsub
   \   0000043E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000442   0x4604             MOV      R4,R0
   \   00000444   0xE004             B.N      ??gcode_G29_39
   \                     ??gcode_G29_38: (+1)
   \   00000446   0x9808             LDR      R0,[SP, #+32]
   \   00000448   0x6B40             LDR      R0,[R0, #+52]
   \   0000044A   0x.... 0x....      BL       __aeabi_f2iz
   \   0000044E   0x4604             MOV      R4,R0
   5480          
   5481                  const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
   \                     ??gcode_G29_39: (+1)
   \   00000450   0xF8DF 0x78F4      LDR.W    R7,??gcode_G29_1+0x40
   \   00000454   0x9805             LDR      R0,[SP, #+20]
   \   00000456   0x.... 0x....      BL       __aeabi_i2f
   \   0000045A   0x6839             LDR      R1,[R7, #+0]
   \   0000045C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000460   0xD304             BCC.N    ??gcode_G29_40
   5482                             left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
   \   00000462   0xF1A5 0x000A      SUB      R0,R5,#+10
   \   00000466   0x9905             LDR      R1,[SP, #+20]
   \   00000468   0x4288             CMP      R0,R1
   \   0000046A   0xDA03             BGE.N    ??gcode_G29_41
   \                     ??gcode_G29_40: (+1)
   \   0000046C   0x2001             MOVS     R0,#+1
   \   0000046E   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000472   0xE002             B.N      ??gcode_G29_42
   \                     ??gcode_G29_41: (+1)
   \   00000474   0x2000             MOVS     R0,#+0
   \   00000476   0xF88D 0x0000      STRB     R0,[SP, #+0]
   5483                             right_out_r = right_probe_bed_position > MAX_PROBE_X,
   \                     ??gcode_G29_42: (+1)
   \   0000047A   0x4628             MOV      R0,R5
   \   0000047C   0x.... 0x....      BL       __aeabi_i2f
   \   00000480   0x4601             MOV      R1,R0
   \   00000482   0x6878             LDR      R0,[R7, #+4]
   \   00000484   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000488   0xD303             BCC.N    ??gcode_G29_43
   5484                             right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
   \   0000048A   0x9805             LDR      R0,[SP, #+20]
   \   0000048C   0x300A             ADDS     R0,R0,#+10
   \   0000048E   0x4285             CMP      R5,R0
   \   00000490   0xDA02             BGE.N    ??gcode_G29_44
   \                     ??gcode_G29_43: (+1)
   \   00000492   0xF04F 0x0A01      MOV      R10,#+1
   \   00000496   0xE001             B.N      ??gcode_G29_45
   \                     ??gcode_G29_44: (+1)
   \   00000498   0xF04F 0x0A00      MOV      R10,#+0
   5485                             front_out_f = front_probe_bed_position < MIN_PROBE_Y,
   \                     ??gcode_G29_45: (+1)
   \   0000049C   0x9802             LDR      R0,[SP, #+8]
   \   0000049E   0x.... 0x....      BL       __aeabi_i2f
   \   000004A2   0x68B9             LDR      R1,[R7, #+8]
   \   000004A4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000004A8   0xD304             BCC.N    ??gcode_G29_46
   5486                             front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
   \   000004AA   0xF1A4 0x000A      SUB      R0,R4,#+10
   \   000004AE   0x9902             LDR      R1,[SP, #+8]
   \   000004B0   0x4288             CMP      R0,R1
   \   000004B2   0xDA02             BGE.N    ??gcode_G29_47
   \                     ??gcode_G29_46: (+1)
   \   000004B4   0xF04F 0x0B01      MOV      R11,#+1
   \   000004B8   0xE001             B.N      ??gcode_G29_48
   \                     ??gcode_G29_47: (+1)
   \   000004BA   0xF04F 0x0B00      MOV      R11,#+0
   5487                             back_out_b = back_probe_bed_position > MAX_PROBE_Y,
   \                     ??gcode_G29_48: (+1)
   \   000004BE   0x4620             MOV      R0,R4
   \   000004C0   0x.... 0x....      BL       __aeabi_i2f
   \   000004C4   0x4601             MOV      R1,R0
   \   000004C6   0x68F8             LDR      R0,[R7, #+12]
   \   000004C8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000004CC   0xD303             BCC.N    ??gcode_G29_49
   5488                             back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
   \   000004CE   0x9802             LDR      R0,[SP, #+8]
   \   000004D0   0x300A             ADDS     R0,R0,#+10
   \   000004D2   0x4284             CMP      R4,R0
   \   000004D4   0xDA01             BGE.N    ??gcode_G29_50
   \                     ??gcode_G29_49: (+1)
   \   000004D6   0x2701             MOVS     R7,#+1
   \   000004D8   0xE000             B.N      ??gcode_G29_51
   \                     ??gcode_G29_50: (+1)
   \   000004DA   0x2700             MOVS     R7,#+0
   5489          
   5490                  if (left_out || right_out || front_out || back_out) {
   \                     ??gcode_G29_51: (+1)
   \   000004DC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000004E0   0xEA4A 0x0000      ORR      R0,R10,R0
   \   000004E4   0xEA4B 0x0000      ORR      R0,R11,R0
   \   000004E8   0x4338             ORRS     R0,R7,R0
   \   000004EA   0xD01D             BEQ.N    ??gcode_G29_52
   5491                    if (left_out) {
   \   000004EC   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   000004F0   0x2800             CMP      R0,#+0
   \   000004F2   0xD003             BEQ.N    ??gcode_G29_53
   5492                      out_of_range_error(PSTR("(L)eft"));
   \   000004F4   0xF8DF 0x0854      LDR.W    R0,??gcode_G29_1+0x44
   \   000004F8   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5493                      left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   5494                    }
   5495                    if (right_out) {
   \                     ??gcode_G29_53: (+1)
   \   000004FC   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000500   0xD003             BEQ.N    ??gcode_G29_54
   5496                      out_of_range_error(PSTR("(R)ight"));
   \   00000502   0xF8DF 0x084C      LDR.W    R0,??gcode_G29_1+0x48
   \   00000506   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5497                      right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   5498                    }
   5499                    if (front_out) {
   \                     ??gcode_G29_54: (+1)
   \   0000050A   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000050E   0xD003             BEQ.N    ??gcode_G29_55
   5500                      out_of_range_error(PSTR("(F)ront"));
   \   00000510   0xF8DF 0x0840      LDR.W    R0,??gcode_G29_1+0x4C
   \   00000514   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5501                      front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
                                                      ^
Warning[Pa093]: implicit conversion from floating point to integer
   5502                    }
   5503                    if (back_out) {
   \                     ??gcode_G29_55: (+1)
   \   00000518   0x2F00             CMP      R7,#+0
   \   0000051A   0xF000 0x83F0      BEQ.W    ??gcode_G29_0
   5504                      out_of_range_error(PSTR("(B)ack"));
   \   0000051E   0xF8DF 0x0838      LDR.W    R0,??gcode_G29_1+0x50
   \   00000522   0x.... 0x....      BL       _Z18out_of_range_errorPKc
   5505                      back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
                                                     ^
Warning[Pa093]: implicit conversion from floating point to integer
   5506                    }
   5507                    return;
   \   00000526   0xE3EA             B.N      ??gcode_G29_0
   5508                  }
   5509          
   5510                  // probe at the points of a lattice grid
   5511                  xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
   \                     ??gcode_G29_52: (+1)
   \   00000528   0x9805             LDR      R0,[SP, #+20]
   \   0000052A   0x1A28             SUBS     R0,R5,R0
   \   0000052C   0x990C             LDR      R1,[SP, #+48]
   \   0000052E   0x1E49             SUBS     R1,R1,#+1
   \   00000530   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000534   0x.... 0x....      BL       __aeabi_i2f
   \   00000538   0x9012             STR      R0,[SP, #+72]
   5512                  yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
   \   0000053A   0x9802             LDR      R0,[SP, #+8]
   \   0000053C   0x1A20             SUBS     R0,R4,R0
   \   0000053E   0x9904             LDR      R1,[SP, #+16]
   \   00000540   0x1E49             SUBS     R1,R1,#+1
   \   00000542   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000546   0x.... 0x....      BL       __aeabi_i2f
   \   0000054A   0x9007             STR      R0,[SP, #+28]
   5513                }
   5514                //#endif // ABL_GRID
   5515          
   5516                if (verbose_level > 0) {
   \                     ??gcode_G29_31: (+1)
   \   0000054C   0x980A             LDR      R0,[SP, #+40]
   \   0000054E   0x2801             CMP      R0,#+1
   \   00000550   0xDB0F             BLT.N    ??gcode_G29_56
   5517                  SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
   \   00000552   0xF8DF 0x0808      LDR.W    R0,??gcode_G29_1+0x54
   \   00000556   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5518                  if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
   \   0000055A   0x980F             LDR      R0,[SP, #+60]
   \   0000055C   0x2800             CMP      R0,#+0
   \   0000055E   0xD003             BEQ.N    ??gcode_G29_57
   \   00000560   0xF8DF 0x07FC      LDR.W    R0,??gcode_G29_1+0x58
   \   00000564   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5519                  SERIAL_EOL();
   \                     ??gcode_G29_57: (+1)
   \   00000568   0x210A             MOVS     R1,#+10
   \   0000056A   0xF8DF 0x07F8      LDR.W    R0,??gcode_G29_1+0x5C
   \   0000056E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5520                }
   5521          
   5522                stepper.synchronize();
   \                     ??gcode_G29_56: (+1)
   \   00000572   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   5523          
   5524                // Disable auto bed leveling during G29.
   5525                // Be formal so G29 can be done successively without G28.
   5526                set_bed_leveling_enabled(false);
   \   00000576   0x2000             MOVS     R0,#+0
   \   00000578   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5527          
   5528                #if HAS_BED_PROBE
   5529                  // Deploy the probe. Probe will raise if needed.
   5530                  if (DEPLOY_PROBE()) {
   \   0000057C   0x2001             MOVS     R0,#+1
   \   0000057E   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   00000582   0x2800             CMP      R0,#+0
   \   00000584   0xD003             BEQ.N    ??gcode_G29_58
   5531                    set_bed_leveling_enabled(abl_should_enable);
   \   00000586   0x4648             MOV      R0,R9
   \   00000588   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5532                    return;
   \   0000058C   0xE3B7             B.N      ??gcode_G29_0
   5533                  }
   5534                #endif
   5535          
   5536                if (!faux) setup_for_endstop_or_probe_move();
   \                     ??gcode_G29_58: (+1)
   \   0000058E   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   5537          
   5538                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5539                if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \   00000592   0xF8DF 0x0774      LDR.W    R0,??gcode_G29_1
   \   00000596   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000059A   0x2808             CMP      R0,#+8
   \   0000059C   0xD129             BNE.N    ??gcode_G29_59
   5540                {
   5541                  #if ENABLED(PROBE_MANUALLY)
   5542                    if (!no_action)
   5543                  #endif
   5544                  if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
   5545                    || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
   5546                    || left_probe_bed_position != bilinear_start[X_AXIS]
   5547                    || front_probe_bed_position != bilinear_start[Y_AXIS]
   5548                  ) {
   \   0000059E   0xF8DF 0x4770      LDR.W    R4,??gcode_G29_1+0x8
   \   000005A2   0x6920             LDR      R0,[R4, #+16]
   \   000005A4   0x.... 0x....      BL       __aeabi_i2f
   \   000005A8   0x4601             MOV      R1,R0
   \   000005AA   0x9812             LDR      R0,[SP, #+72]
   \   000005AC   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000005B0   0xD10F             BNE.N    ??gcode_G29_60
   \   000005B2   0x6960             LDR      R0,[R4, #+20]
   \   000005B4   0x.... 0x....      BL       __aeabi_i2f
   \   000005B8   0x4601             MOV      R1,R0
   \   000005BA   0x9807             LDR      R0,[SP, #+28]
   \   000005BC   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000005C0   0xD107             BNE.N    ??gcode_G29_60
   \   000005C2   0x9805             LDR      R0,[SP, #+20]
   \   000005C4   0x69A1             LDR      R1,[R4, #+24]
   \   000005C6   0x4288             CMP      R0,R1
   \   000005C8   0xD103             BNE.N    ??gcode_G29_60
   \   000005CA   0x9802             LDR      R0,[SP, #+8]
   \   000005CC   0x69E1             LDR      R1,[R4, #+28]
   \   000005CE   0x4288             CMP      R0,R1
   \   000005D0   0xD00F             BEQ.N    ??gcode_G29_59
   5549                    // Reset grid to 0.0 or "not probed". (Also disables ABL)
   5550                    reset_bed_level();
   \                     ??gcode_G29_60: (+1)
   \   000005D2   0x.... 0x....      BL       _Z15reset_bed_levelv
   5551          
   5552                    // Initialize a grid with the given dimensions
   5553                    bilinear_grid_spacing[X_AXIS] = xGridSpacing;
                                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000005D6   0x9812             LDR      R0,[SP, #+72]
   \   000005D8   0x.... 0x....      BL       __aeabi_f2iz
   \   000005DC   0x6120             STR      R0,[R4, #+16]
   5554                    bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
                                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000005DE   0x9807             LDR      R0,[SP, #+28]
   \   000005E0   0x.... 0x....      BL       __aeabi_f2iz
   \   000005E4   0x6160             STR      R0,[R4, #+20]
   5555                    bilinear_start[X_AXIS] = left_probe_bed_position;
   \   000005E6   0x9805             LDR      R0,[SP, #+20]
   \   000005E8   0x61A0             STR      R0,[R4, #+24]
   5556                    bilinear_start[Y_AXIS] = front_probe_bed_position;
   \   000005EA   0x9802             LDR      R0,[SP, #+8]
   \   000005EC   0x61E0             STR      R0,[R4, #+28]
   5557          
   5558                    // Can't re-enable (on error) until the new grid is written
   5559                    abl_should_enable = false;
   \   000005EE   0xF04F 0x0900      MOV      R9,#+0
   5560                  }
   5561                }
   5562                //#endif // AUTO_BED_LEVELING_BILINEAR
   5563          
   5564                //#if ENABLED(AUTO_BED_LEVELING_3POINT)
   5565                if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
   \                     ??gcode_G29_59: (+1)
   \   000005F2   0xF8DF 0x0714      LDR.W    R0,??gcode_G29_1
   \   000005F6   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000005FA   0x2802             CMP      R0,#+2
   \   000005FC   0xD104             BNE.N    ??gcode_G29_61
   5566                {
   5567                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5568                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
   5569                  #endif
   5570          
   5571                  // Probe at 3 arbitrary points
   5572                  points[0].z = points[1].z = points[2].z = 0;
   \   000005FE   0xAC16             ADD      R4,SP,#+88
   \   00000600   0x2000             MOVS     R0,#+0
   \   00000602   0x6220             STR      R0,[R4, #+32]
   \   00000604   0x6160             STR      R0,[R4, #+20]
   \   00000606   0x60A0             STR      R0,[R4, #+8]
   5573                }
   5574                //#endif // AUTO_BED_LEVELING_3POINT
   5575          
   5576              } // !g29_in_progress
   5577          
   5578              #if ENABLED(PROBE_MANUALLY)
   5579          
   5580                // For manual probing, get the next index to probe now.
   5581                // On the first probe this will be incremented to 0.
   5582                if (!no_action) {
   5583                  ++abl_probe_index;
   5584                  g29_in_progress = true;
   5585                }
   5586          
   5587                // Abort current G29 procedure, go back to idle state
   5588                if (seenA && g29_in_progress) {
   5589                  SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
   5590                  #if HAS_SOFTWARE_ENDSTOPS
   5591                    soft_endstops_enabled = enable_soft_endstops;
   5592                  #endif
   5593                  set_bed_leveling_enabled(abl_should_enable);
   5594                  g29_in_progress = false;
   5595                  #if ENABLED(LCD_BED_LEVELING)
   5596                    lcd_wait_for_move = false;
   5597                  #endif
   5598                }
   5599          
   5600                // Query G29 status
   5601                if (verbose_level || seenQ) {
   5602                  SERIAL_PROTOCOLPGM("Manual G29 ");
   5603                  if (g29_in_progress) {
   5604                    SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
   5605                    SERIAL_PROTOCOLLNPAIR(" of ", abl2);
   5606                  }
   5607                  else
   5608                    SERIAL_PROTOCOLLNPGM("idle");
   5609                }
   5610          
   5611                if (no_action) return;
   5612          
   5613                if (abl_probe_index == 0) {
   5614                  // For the initial G29 save software endstop state
   5615                  #if HAS_SOFTWARE_ENDSTOPS
   5616                    enable_soft_endstops = soft_endstops_enabled;
   5617                  #endif
   5618                }
   5619                else {
   5620                  // For G29 after adjusting Z.
   5621                  // Save the previous Z before going to the next point
   5622                  measured_z = current_position[Z_AXIS];
   5623          
   5624                  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5625          
   5626                    mean += measured_z;
   5627                    eqnBVector[abl_probe_index] = measured_z;
   5628                    eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5629                    eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5630                    eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5631          
   5632                    incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
   5633          
   5634                  #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5635          
   5636                    z_values[xCount][yCount] = measured_z + zoffset;
   5637          
   5638                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   5639                      if (DEBUGGING(LEVELING)) {
   5640                        SERIAL_PROTOCOLPAIR("Save X", xCount);
   5641                        SERIAL_PROTOCOLPAIR(" Y", yCount);
   5642                        SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
   5643                      }
   5644                    #endif
   5645          
   5646                  #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5647          
   5648                    points[abl_probe_index].z = measured_z;
   5649          
   5650                  #endif
   5651                }
   5652          
   5653                //
   5654                // If there's another point to sample, move there with optional lift.
   5655                //
   5656          
   5657                #if ABL_GRID
   5658          
   5659                  // Skip any unreachable points
   5660                  while (abl_probe_index < abl2) {
   5661          
   5662                    // Set xCount, yCount based on abl_probe_index, with zig-zag
   5663                    PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
   5664                    PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
   5665          
   5666                    // Probe in reverse order for every other row/column
   5667                    bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
   5668          
   5669                    if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
   5670          
   5671                    const float xBase = xCount * xGridSpacing + left_probe_bed_position,
   5672                                yBase = yCount * yGridSpacing + front_probe_bed_position;
   5673          
   5674                    xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
   5675                    yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
   5676          
   5677                    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5678                      indexIntoAB[xCount][yCount] = abl_probe_index;
   5679                    #endif
   5680          
   5681                    // Keep looping till a reachable point is found
   5682                    if(MACHINETPYE & IS_KINEMATIC)
   5683                      if (position_is_reachable_IS_KINEMATIC(xProbe, yProbe)) break;
   5684                    else
   5685                      if (position_is_reachable_IS_CARTESIAN(xProbe, yProbe)) break;
   5686                      
   5687                    ++abl_probe_index;
   5688                  }
   5689          
   5690                  // Is there a next point to move to?
   5691                  if (abl_probe_index < abl2) {
   5692                    _manual_goto_xy(xProbe, yProbe); // Can be used here too!
   5693                    #if HAS_SOFTWARE_ENDSTOPS
   5694                      // Disable software endstops to allow manual adjustment
   5695                      // If G29 is not completed, they will not be re-enabled
   5696                      soft_endstops_enabled = false;
   5697                    #endif
   5698                    return;
   5699                  }
   5700                  else {
   5701          
   5702                    // Leveling done! Fall through to G29 finishing code below
   5703          
   5704                    SERIAL_PROTOCOLLNPGM("Grid probing done.");
   5705          
   5706                    // Re-enable software endstops, if needed
   5707                    #if HAS_SOFTWARE_ENDSTOPS
   5708                      soft_endstops_enabled = enable_soft_endstops;
   5709                    #endif
   5710                  }
   5711          
   5712                #elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5713          
   5714                  // Probe at 3 arbitrary points
   5715                  if (abl_probe_index < abl2) {
   5716                    xProbe = points[abl_probe_index].x;
   5717                    yProbe = points[abl_probe_index].y;
   5718                    _manual_goto_xy(xProbe, yProbe);
   5719                    #if HAS_SOFTWARE_ENDSTOPS
   5720                      // Disable software endstops to allow manual adjustment
   5721                      // If G29 is not completed, they will not be re-enabled
   5722                      soft_endstops_enabled = false;
   5723                    #endif
   5724                    return;
   5725                  }
   5726                  else {
   5727          
   5728                    SERIAL_PROTOCOLLNPGM("3-point probing done.");
   5729          
   5730                    // Re-enable software endstops, if needed
   5731                    #if HAS_SOFTWARE_ENDSTOPS
   5732                      soft_endstops_enabled = enable_soft_endstops;
   5733                    #endif
   5734          
   5735                    if (!dryrun) {
   5736                      vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   5737                      if (planeNormal.z < 0) {
   5738                        planeNormal.x *= -1;
   5739                        planeNormal.y *= -1;
   5740                        planeNormal.z *= -1;
   5741                      }
   5742                      planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   5743          
   5744                      // Can't re-enable (on error) until the new grid is written
   5745                      abl_should_enable = false;
   5746                    }
   5747          
   5748                  }
   5749          
   5750                #endif // AUTO_BED_LEVELING_3POINT
   5751          
   5752              #else // !PROBE_MANUALLY
   5753              {
   5754                const bool stow_probe_after_each = parser.boolval('E');
   \                     ??gcode_G29_61: (+1)
   \   00000608   0x2045             MOVS     R0,#+69
   \   0000060A   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000060E   0xF88D 0x0005      STRB     R0,[SP, #+5]
   5755          
   5756                measured_z = 0;
   \   00000612   0x2000             MOVS     R0,#+0
   \   00000614   0x9009             STR      R0,[SP, #+36]
   5757          
   5758                //#if ABL_GRID
   5759                  if(BED_LEVELING_METHOD&ABL_GRID)
   \   00000616   0xF8DF 0x06F0      LDR.W    R0,??gcode_G29_1
   \   0000061A   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000061E   0x210C             MOVS     R1,#+12
   \   00000620   0x4208             TST      R0,R1
   \   00000622   0xF000 0x80F8      BEQ.W    ??gcode_G29_62
   5760                  {
   5761                  bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
   \   00000626   0x9804             LDR      R0,[SP, #+16]
   \   00000628   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000062C   0xF88D 0x0004      STRB     R0,[SP, #+4]
   5762          
   5763                  measured_z = 0;
   5764          
   5765                  // Outer loop is Y with PROBE_Y_FIRST disabled
   5766                  for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
   \   00000630   0x2000             MOVS     R0,#+0
   \   00000632   0x9006             STR      R0,[SP, #+24]
   \   00000634   0xE0B0             B.N      ??gcode_G29_63
   5767          
   5768                    int8_t inStart, inStop, inInc;
   5769          
   5770                    if (zig) { // away from origin
   5771                      inStart = 0;
   5772                      inStop = PR_INNER_END;
   5773                      inInc = 1;
   5774                    }
   5775                    else {     // towards origin
   5776                      inStart = PR_INNER_END - 1;
   \                     ??gcode_G29_64: (+1)
   \   00000636   0x980C             LDR      R0,[SP, #+48]
   \   00000638   0x1E47             SUBS     R7,R0,#+1
   5777                      inStop = -1;
   \   0000063A   0xF04F 0x30FF      MOV      R0,#-1
   \   0000063E   0x9014             STR      R0,[SP, #+80]
   5778                      inInc = -1;
   \   00000640   0x9013             STR      R0,[SP, #+76]
   5779                    }
   5780          
   5781                    zig ^= true; // zag
   \                     ??gcode_G29_65: (+1)
   \   00000642   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   00000646   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000064A   0x1E40             SUBS     R0,R0,#+1
   \   0000064C   0x4180             SBCS     R0,R0,R0
   \   0000064E   0x43C0             MVNS     R0,R0
   \   00000650   0x0FC0             LSRS     R0,R0,#+31
   \   00000652   0xF88D 0x0004      STRB     R0,[SP, #+4]
   5782          
   5783                    // Inner loop is Y with PROBE_Y_FIRST enabled
   5784                    for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
   \   00000656   0xB27F             SXTB     R7,R7
   \   00000658   0xE015             B.N      ??gcode_G29_66
   5785          
   5786                      float xBase = left_probe_bed_position + xGridSpacing * xCount,
   5787                            yBase = front_probe_bed_position + yGridSpacing * yCount;
   5788          
   5789                      xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
   5790                      yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
   5791          
   5792                      //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5793                      if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   5794                        indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
   5795                      //#endif
   5796          
   5797                      //#if IS_KINEMATIC
   5798                      if(MACHINETPYE & IS_KINEMATIC)
   5799                        // Avoid probing outside the round or hexagonal area
   5800                        if (!position_is_reachable_by_probe_IS_KINEMATIC(xProbe, yProbe)) continue;
   5801                      //#endif
   5802                      
   5803                      int16_t randData = rand()%200;
   5804                      if(randData > 100)  randData = 100 - randData;
   5805          
   5806                      measured_z = faux ? 0.001 * randData/*random(-100, 101) */: probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5807          
   5808                      if (isnan(measured_z)) {
   5809                        set_bed_leveling_enabled(abl_should_enable);
   5810                        break;
   5811                      }
   5812          
   5813                      //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
   5814                      if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
   5815                      {
   5816                        mean += measured_z;
   5817                        /*
   5818                        eqnBVector[abl_probe_index] = measured_z;
   5819                        eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
   5820                        eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
   5821                        eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
   5822                        */
   5823                      *(eqnBVector+abl_probe_index) = measured_z;
   5824                      *(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
   5825                      *(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
   5826                      *(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
   5827          
   5828                        incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
   5829                      }
   5830                      //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5831                      else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
   \                     ??gcode_G29_67: (+1)
   \   0000065A   0x0700             LSLS     R0,R0,#+28
   \   0000065C   0xD50C             BPL.N    ??gcode_G29_68
   5832                      {
   5833                        z_values[xCount][yCount] = measured_z + zoffset;
   \   0000065E   0x9C06             LDR      R4,[SP, #+24]
   \   00000660   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   00000664   0xF8DF 0x16D0      LDR.W    R1,??gcode_G29_1+0x30
   \   00000668   0xEB01 0x1500      ADD      R5,R1,R0, LSL #+4
   \   0000066C   0x9909             LDR      R1,[SP, #+36]
   \   0000066E   0x9815             LDR      R0,[SP, #+84]
   \   00000670   0x.... 0x....      BL       __aeabi_fadd
   \   00000674   0xF845 0x0024      STR      R0,[R5, R4, LSL #+2]
   5834                      }
   5835                      //#endif
   5836          
   5837                      abl_should_enable = false;
   \                     ??gcode_G29_68: (+1)
   \   00000678   0xF04F 0x0900      MOV      R9,#+0
   5838                      idle();
   \   0000067C   0x.... 0x....      BL       _Z4idlev
   \                     ??gcode_G29_69: (+1)
   \   00000680   0x9813             LDR      R0,[SP, #+76]
   \   00000682   0x19C7             ADDS     R7,R0,R7
   \   00000684   0xB27F             SXTB     R7,R7
   \                     ??gcode_G29_66: (+1)
   \   00000686   0x9814             LDR      R0,[SP, #+80]
   \   00000688   0x4287             CMP      R7,R0
   \   0000068A   0xF000 0x8081      BEQ.W    ??gcode_G29_70
   \   0000068E   0x9805             LDR      R0,[SP, #+20]
   \   00000690   0x.... 0x....      BL       __aeabi_i2f
   \   00000694   0x4604             MOV      R4,R0
   \   00000696   0x4638             MOV      R0,R7
   \   00000698   0x.... 0x....      BL       __aeabi_i2f
   \   0000069C   0x4601             MOV      R1,R0
   \   0000069E   0x9812             LDR      R0,[SP, #+72]
   \   000006A0   0x.... 0x....      BL       __aeabi_fmul
   \   000006A4   0x4601             MOV      R1,R0
   \   000006A6   0x4620             MOV      R0,R4
   \   000006A8   0x.... 0x....      BL       __aeabi_fadd
   \   000006AC   0x4683             MOV      R11,R0
   \   000006AE   0x9802             LDR      R0,[SP, #+8]
   \   000006B0   0x.... 0x....      BL       __aeabi_i2f
   \   000006B4   0x4604             MOV      R4,R0
   \   000006B6   0xA806             ADD      R0,SP,#+24
   \   000006B8   0x7800             LDRB     R0,[R0, #+0]
   \   000006BA   0x.... 0x....      BL       __aeabi_ui2f
   \   000006BE   0x4601             MOV      R1,R0
   \   000006C0   0x9807             LDR      R0,[SP, #+28]
   \   000006C2   0x.... 0x....      BL       __aeabi_fmul
   \   000006C6   0x4601             MOV      R1,R0
   \   000006C8   0x4620             MOV      R0,R4
   \   000006CA   0x.... 0x....      BL       __aeabi_fadd
   \   000006CE   0x4682             MOV      R10,R0
   \   000006D0   0x4658             MOV      R0,R11
   \   000006D2   0x2100             MOVS     R1,#+0
   \   000006D4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000006D8   0x460C             MOV      R4,R1
   \   000006DA   0xD201             BCS.N    ??gcode_G29_71
   \   000006DC   0x460D             MOV      R5,R1
   \   000006DE   0xE001             B.N      ??gcode_G29_72
   \                     ??gcode_G29_71: (+1)
   \   000006E0   0xF8DF 0x5684      LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
   \                     ??gcode_G29_72: (+1)
   \   000006E4   0x.... 0x....      BL       __aeabi_f2d
   \   000006E8   0x4602             MOV      R2,R0
   \   000006EA   0x460B             MOV      R3,R1
   \   000006EC   0x4620             MOV      R0,R4
   \   000006EE   0x4629             MOV      R1,R5
   \   000006F0   0x.... 0x....      BL       __aeabi_dadd
   \   000006F4   0x.... 0x....      BL       floor
   \   000006F8   0x.... 0x....      BL       __aeabi_d2f
   \   000006FC   0x900E             STR      R0,[SP, #+56]
   \   000006FE   0x4650             MOV      R0,R10
   \   00000700   0x4621             MOV      R1,R4
   \   00000702   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000706   0xD201             BCS.N    ??gcode_G29_73
   \   00000708   0x460D             MOV      R5,R1
   \   0000070A   0xE001             B.N      ??gcode_G29_74
   \                     ??gcode_G29_73: (+1)
   \   0000070C   0xF8DF 0x5658      LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
   \                     ??gcode_G29_74: (+1)
   \   00000710   0x.... 0x....      BL       __aeabi_f2d
   \   00000714   0x4622             MOV      R2,R4
   \   00000716   0x462B             MOV      R3,R5
   \   00000718   0x.... 0x....      BL       __aeabi_dadd
   \   0000071C   0x.... 0x....      BL       floor
   \   00000720   0x.... 0x....      BL       __aeabi_d2f
   \   00000724   0x900D             STR      R0,[SP, #+52]
   \   00000726   0xF8DF 0x05E0      LDR.W    R0,??gcode_G29_1
   \   0000072A   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000072E   0x0740             LSLS     R0,R0,#+29
   \   00000730   0xD508             BPL.N    ??gcode_G29_75
   \   00000732   0x1C76             ADDS     R6,R6,#+1
   \   00000734   0x9806             LDR      R0,[SP, #+24]
   \   00000736   0xEB07 0x0147      ADD      R1,R7,R7, LSL #+1
   \   0000073A   0xAA3A             ADD      R2,SP,#+232
   \   0000073C   0xEB02 0x1101      ADD      R1,R2,R1, LSL #+4
   \   00000740   0xF841 0x6020      STR      R6,[R1, R0, LSL #+2]
   \                     ??gcode_G29_75: (+1)
   \   00000744   0xF8DF 0x05C0      LDR.W    R0,??gcode_G29_1
   \   00000748   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   0000074C   0xF240 0x3102      MOVW     R1,#+770
   \   00000750   0x4208             TST      R0,R1
   \   00000752   0xD005             BEQ.N    ??gcode_G29_76
   \   00000754   0xA90D             ADD      R1,SP,#+52
   \   00000756   0xA80E             ADD      R0,SP,#+56
   \   00000758   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
   \   0000075C   0x2800             CMP      R0,#+0
   \   0000075E   0xD08F             BEQ.N    ??gcode_G29_69
   \                     ??gcode_G29_76: (+1)
   \   00000760   0x.... 0x....      BL       rand
   \   00000764   0x2001             MOVS     R0,#+1
   \   00000766   0x9000             STR      R0,[SP, #+0]
   \   00000768   0x9B0A             LDR      R3,[SP, #+40]
   \   0000076A   0xB2DB             UXTB     R3,R3
   \   0000076C   0xF89D 0x2005      LDRB     R2,[SP, #+5]
   \   00000770   0xA90D             ADD      R1,SP,#+52
   \   00000772   0xA80E             ADD      R0,SP,#+56
   \   00000774   0x.... 0x....      BL       _Z8probe_ptRKfS0_bhb
   \   00000778   0x.... 0x....      BL       __aeabi_f2d
   \   0000077C   0x.... 0x....      BL       __aeabi_d2f
   \   00000780   0x9009             STR      R0,[SP, #+36]
   \   00000782   0x.... 0x....      BL       __iar_FDtest
   \   00000786   0x2802             CMP      R0,#+2
   \   00000788   0xD11E             BNE.N    ??gcode_G29_77
   \   0000078A   0x4648             MOV      R0,R9
   \   0000078C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \                     ??gcode_G29_70: (+1)
   \   00000790   0x9806             LDR      R0,[SP, #+24]
   \   00000792   0x1C40             ADDS     R0,R0,#+1
   \   00000794   0xB2C0             UXTB     R0,R0
   \   00000796   0x9006             STR      R0,[SP, #+24]
   \                     ??gcode_G29_63: (+1)
   \   00000798   0x9806             LDR      R0,[SP, #+24]
   \   0000079A   0x9904             LDR      R1,[SP, #+16]
   \   0000079C   0x4288             CMP      R0,R1
   \   0000079E   0xF280 0x80C6      BGE.W    ??gcode_G29_78
   \   000007A2   0x9809             LDR      R0,[SP, #+36]
   \   000007A4   0x.... 0x....      BL       __iar_FDtest
   \   000007A8   0x2802             CMP      R0,#+2
   \   000007AA   0xF000 0x80C0      BEQ.W    ??gcode_G29_78
   \   000007AE   0xF89D 0x0004      LDRB     R0,[SP, #+4]
   \   000007B2   0x2800             CMP      R0,#+0
   \   000007B4   0xF43F 0xAF3F      BEQ.W    ??gcode_G29_64
   \   000007B8   0x2700             MOVS     R7,#+0
   \   000007BA   0xA80C             ADD      R0,SP,#+48
   \   000007BC   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   000007C0   0x9014             STR      R0,[SP, #+80]
   \   000007C2   0x2001             MOVS     R0,#+1
   \   000007C4   0x9013             STR      R0,[SP, #+76]
   \   000007C6   0xE73C             B.N      ??gcode_G29_65
   \                     ??gcode_G29_77: (+1)
   \   000007C8   0xF8DF 0x053C      LDR.W    R0,??gcode_G29_1
   \   000007CC   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   000007D0   0x0741             LSLS     R1,R0,#+29
   \   000007D2   0xF57F 0xAF42      BPL.W    ??gcode_G29_67
   \   000007D6   0x9909             LDR      R1,[SP, #+36]
   \   000007D8   0x4640             MOV      R0,R8
   \   000007DA   0x.... 0x....      BL       __aeabi_fadd
   \   000007DE   0x4680             MOV      R8,R0
   \   000007E0   0x9809             LDR      R0,[SP, #+36]
   \   000007E2   0x9910             LDR      R1,[SP, #+64]
   \   000007E4   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   000007E8   0x980E             LDR      R0,[SP, #+56]
   \   000007EA   0x990B             LDR      R1,[SP, #+44]
   \   000007EC   0xF841 0x0026      STR      R0,[R1, R6, LSL #+2]
   \   000007F0   0x980B             LDR      R0,[SP, #+44]
   \   000007F2   0xEB00 0x0086      ADD      R0,R0,R6, LSL #+2
   \   000007F6   0x990D             LDR      R1,[SP, #+52]
   \   000007F8   0x9A11             LDR      R2,[SP, #+68]
   \   000007FA   0xF840 0x1022      STR      R1,[R0, R2, LSL #+2]
   \   000007FE   0xF04F 0x517E      MOV      R1,#+1065353216
   \   00000802   0x9A11             LDR      R2,[SP, #+68]
   \   00000804   0xF840 0x1032      STR      R1,[R0, R2, LSL #+3]
   \   00000808   0xAB09             ADD      R3,SP,#+36
   \   0000080A   0xAA0D             ADD      R2,SP,#+52
   \   0000080C   0xA90E             ADD      R1,SP,#+56
   \   0000080E   0xA82B             ADD      R0,SP,#+172
   \   00000810   0x.... 0x....      BL       _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
   \   00000814   0xE730             B.N      ??gcode_G29_68
   5839          
   5840                    } // inner
   5841                  } // outer
   5842                }
   5843                //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
   5844                else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_3POINT)
   \                     ??gcode_G29_62: (+1)
   \   00000816   0x0780             LSLS     R0,R0,#+30
   \   00000818   0xF140 0x8089      BPL.W    ??gcode_G29_78
   5845                {
   5846                  // Probe at 3 arbitrary points
   5847          
   5848                  for (uint8_t i = 0; i < 3; ++i) {
   \   0000081C   0x2400             MOVS     R4,#+0
   \   0000081E   0xE003             B.N      ??gcode_G29_79
   5849                    // Retain the last probe position
   5850                    xProbe = points[i].x;
   5851                    yProbe = points[i].y;
   5852                    int16_t randData = rand()%200;
   5853          	      if(randData > 100)	randData = 100 - randData;
   5854                    measured_z = faux ? 0.001 * randData/*random(-100, 101)*/ : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
   5855                    if (isnan(measured_z)) {
   5856                      set_bed_leveling_enabled(abl_should_enable);
   5857                      break;
   5858                    }
   5859                    points[i].z = measured_z;
   \                     ??gcode_G29_80: (+1)
   \   00000820   0x9809             LDR      R0,[SP, #+36]
   \   00000822   0x60A8             STR      R0,[R5, #+8]
   \   00000824   0x1C64             ADDS     R4,R4,#+1
   \   00000826   0xB2E4             UXTB     R4,R4
   \                     ??gcode_G29_79: (+1)
   \   00000828   0x2C03             CMP      R4,#+3
   \   0000082A   0xDA21             BGE.N    ??gcode_G29_81
   \   0000082C   0xEB04 0x0044      ADD      R0,R4,R4, LSL #+1
   \   00000830   0x0080             LSLS     R0,R0,#+2
   \   00000832   0xA916             ADD      R1,SP,#+88
   \   00000834   0x5841             LDR      R1,[R0, R1]
   \   00000836   0x910E             STR      R1,[SP, #+56]
   \   00000838   0xA916             ADD      R1,SP,#+88
   \   0000083A   0x1845             ADDS     R5,R0,R1
   \   0000083C   0x6868             LDR      R0,[R5, #+4]
   \   0000083E   0x900D             STR      R0,[SP, #+52]
   \   00000840   0x.... 0x....      BL       rand
   \   00000844   0x2001             MOVS     R0,#+1
   \   00000846   0x9000             STR      R0,[SP, #+0]
   \   00000848   0x9B0A             LDR      R3,[SP, #+40]
   \   0000084A   0xB2DB             UXTB     R3,R3
   \   0000084C   0xF89D 0x2005      LDRB     R2,[SP, #+5]
   \   00000850   0xA90D             ADD      R1,SP,#+52
   \   00000852   0xA80E             ADD      R0,SP,#+56
   \   00000854   0x.... 0x....      BL       _Z8probe_ptRKfS0_bhb
   \   00000858   0x.... 0x....      BL       __aeabi_f2d
   \   0000085C   0x.... 0x....      BL       __aeabi_d2f
   \   00000860   0x9009             STR      R0,[SP, #+36]
   \   00000862   0x.... 0x....      BL       __iar_FDtest
   \   00000866   0x2802             CMP      R0,#+2
   \   00000868   0xD1DA             BNE.N    ??gcode_G29_80
   \   0000086A   0x4648             MOV      R0,R9
   \   0000086C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5860                  }
   5861          
   5862                  if (!dryrun && !isnan(measured_z)) {
   \                     ??gcode_G29_81: (+1)
   \   00000870   0x980F             LDR      R0,[SP, #+60]
   \   00000872   0x2800             CMP      R0,#+0
   \   00000874   0xD15B             BNE.N    ??gcode_G29_78
   \   00000876   0x9809             LDR      R0,[SP, #+36]
   \   00000878   0x.... 0x....      BL       __iar_FDtest
   \   0000087C   0x2802             CMP      R0,#+2
   \   0000087E   0xD056             BEQ.N    ??gcode_G29_78
   5863                    vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
   \   00000880   0xAC16             ADD      R4,SP,#+88
   \   00000882   0xF104 0x000C      ADD      R0,R4,#+12
   \   00000886   0xB082             SUB      SP,SP,#+8
   \   00000888   0x4669             MOV      R1,SP
   \   0000088A   0xC80C             LDM      R0!,{R2,R3}
   \   0000088C   0xC10C             STM      R1!,{R2,R3}
   \   0000088E   0x6802             LDR      R2,[R0, #0]
   \   00000890   0x600A             STR      R2,[R1, #+0]
   \   00000892   0xBC0C             POP      {R2,R3}
   \   00000894   0xA91C             ADD      R1,SP,#+112
   \   00000896   0xA822             ADD      R0,SP,#+136
   \   00000898   0x.... 0x....      BL       _ZN8vector_3miES_
   \   0000089C   0xF104 0x000C      ADD      R0,R4,#+12
   \   000008A0   0xB082             SUB      SP,SP,#+8
   \   000008A2   0x4669             MOV      R1,SP
   \   000008A4   0xC80C             LDM      R0!,{R2,R3}
   \   000008A6   0xC10C             STM      R1!,{R2,R3}
   \   000008A8   0x6802             LDR      R2,[R0, #0]
   \   000008AA   0x600A             STR      R2,[R1, #+0]
   \   000008AC   0xBC0C             POP      {R2,R3}
   \   000008AE   0xA916             ADD      R1,SP,#+88
   \   000008B0   0xA812             ADD      R0,SP,#+72
   \   000008B2   0x.... 0x....      BL       _ZN8vector_3miES_
   \   000008B6   0xA822             ADD      R0,SP,#+136
   \   000008B8   0x466A             MOV      R2,SP
   \   000008BA   0xC80A             LDM      R0!,{R1,R3}
   \   000008BC   0xC20A             STM      R2!,{R1,R3}
   \   000008BE   0x6803             LDR      R3,[R0, #0]
   \   000008C0   0x6013             STR      R3,[R2, #+0]
   \   000008C2   0xA812             ADD      R0,SP,#+72
   \   000008C4   0xE890 0x000E      LDM      R0,{R1-R3}
   \   000008C8   0xA805             ADD      R0,SP,#+20
   \   000008CA   0x.... 0x....      BL       _ZN8vector_35crossES_S_
   \   000008CE   0xA81F             ADD      R0,SP,#+124
   \   000008D0   0xA905             ADD      R1,SP,#+20
   \   000008D2   0xC91C             LDM      R1!,{R2-R4}
   \   000008D4   0xC01C             STM      R0!,{R2-R4}
   \   000008D6   0xA91F             ADD      R1,SP,#+124
   \   000008D8   0xA805             ADD      R0,SP,#+20
   \   000008DA   0x.... 0x....      BL       _ZN8vector_310get_normalEv
   \   000008DE   0xA800             ADD      R0,SP,#+0
   \   000008E0   0xA905             ADD      R1,SP,#+20
   \   000008E2   0xC91C             LDM      R1!,{R2-R4}
   \   000008E4   0xC01C             STM      R0!,{R2-R4}
   5864                    if (planeNormal.z < 0) {
   \   000008E6   0x4620             MOV      R0,R4
   \   000008E8   0x2100             MOVS     R1,#+0
   \   000008EA   0x.... 0x....      BL       __aeabi_cfcmple
   \   000008EE   0xD210             BCS.N    ??gcode_G29_82
   5865                      planeNormal.x *= -1;
   \   000008F0   0xF8DF 0x5478      LDR.W    R5,??gcode_G29_1+0x64  ;; 0xbf800000
   \   000008F4   0x4611             MOV      R1,R2
   \   000008F6   0x4628             MOV      R0,R5
   \   000008F8   0x.... 0x....      BL       __aeabi_fmul
   \   000008FC   0x9000             STR      R0,[SP, #+0]
   5866                      planeNormal.y *= -1;
   \   000008FE   0x9901             LDR      R1,[SP, #+4]
   \   00000900   0x4628             MOV      R0,R5
   \   00000902   0x.... 0x....      BL       __aeabi_fmul
   \   00000906   0x9001             STR      R0,[SP, #+4]
   5867                      planeNormal.z *= -1;
   \   00000908   0x4620             MOV      R0,R4
   \   0000090A   0x4629             MOV      R1,R5
   \   0000090C   0x.... 0x....      BL       __aeabi_fmul
   \   00000910   0x9002             STR      R0,[SP, #+8]
   5868                    }
   5869                    planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   \                     ??gcode_G29_82: (+1)
   \   00000912   0xA800             ADD      R0,SP,#+0
   \   00000914   0xE890 0x000E      LDM      R0,{R1-R3}
   \   00000918   0xA822             ADD      R0,SP,#+136
   \   0000091A   0x.... 0x....      BL       _ZN10matrix_3x314create_look_atE8vector_3
   \   0000091E   0xF8DF 0x0450      LDR.W    R0,??gcode_G29_1+0x68
   \   00000922   0xA922             ADD      R1,SP,#+136
   \   00000924   0x2224             MOVS     R2,#+36
   \   00000926   0x.... 0x....      BL       __aeabi_memcpy4
   5870          
   5871                    // Can't re-enable (on error) until the new grid is written
   5872                    abl_should_enable = false;
   \   0000092A   0xF04F 0x0900      MOV      R9,#+0
   5873                  }
   5874                }
   5875                //#endif // AUTO_BED_LEVELING_3POINT
   5876          
   5877                // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
   5878                if (STOW_PROBE()) {
   \                     ??gcode_G29_78: (+1)
   \   0000092E   0x2000             MOVS     R0,#+0
   \   00000930   0x.... 0x....      BL       _Z18set_probe_deployedb
   \   00000934   0x2800             CMP      R0,#+0
   \   00000936   0xD005             BEQ.N    ??gcode_G29_83
   5879                  set_bed_leveling_enabled(abl_should_enable);
   \   00000938   0x4648             MOV      R0,R9
   \   0000093A   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   5880                  measured_z = NAN;
   \   0000093E   0xF06F 0x4000      MVN      R0,#-2147483648
   \   00000942   0x9009             STR      R0,[SP, #+36]
   5881                }
   5882              }
   5883              #endif // !PROBE_MANUALLY
   5884          
   5885              //
   5886              // G29 Finishing Code
   5887              //
   5888              // Unless this is a dry run, auto bed leveling will
   5889              // definitely be enabled after this point.
   5890              //
   5891              // If code above wants to continue leveling, it should
   5892              // return or loop before this point.
   5893              //
   5894          
   5895              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5896                if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
   5897              #endif
   5898          
   5899              #if ENABLED(PROBE_MANUALLY)
   5900                g29_in_progress = false;
   5901                #if ENABLED(LCD_BED_LEVELING)
   5902                  lcd_wait_for_move = false;
   5903                #endif
   5904              #endif
   5905          
   5906              // Calculate leveling, print reports, correct the position
   5907              if (!isnan(measured_z)) {
   \                     ??gcode_G29_83: (+1)
   \   00000944   0x9809             LDR      R0,[SP, #+36]
   \   00000946   0x.... 0x....      BL       __iar_FDtest
   \   0000094A   0x2802             CMP      R0,#+2
   \   0000094C   0xF000 0x81C4      BEQ.W    ??gcode_G29_84
   \   00000950   0xF8DF 0x03B4      LDR.W    R0,??gcode_G29_1
   \   00000954   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000958   0x2808             CMP      R0,#+8
   \   0000095A   0xD109             BNE.N    ??gcode_G29_85
   5908                //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
   5909                  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   5910                  {
   5911                      if (!dryrun) extrapolate_unprobed_bed_level();
   \   0000095C   0x980F             LDR      R0,[SP, #+60]
   \   0000095E   0x2800             CMP      R0,#+0
   \   00000960   0xD101             BNE.N    ??gcode_G29_86
   \   00000962   0x.... 0x....      BL       _Z30extrapolate_unprobed_bed_levelv
   5912                      print_bilinear_leveling_grid();
   \                     ??gcode_G29_86: (+1)
   \   00000966   0x.... 0x....      BL       _Z28print_bilinear_leveling_gridv
   5913          
   5914                      refresh_bed_level();
   \   0000096A   0x.... 0x....      BL       _Z17refresh_bed_levelv
   \   0000096E   0xE14C             B.N      ??gcode_G29_87
   5915          
   5916                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
   5917                        print_bilinear_leveling_grid_virt();
   5918                      #endif
   5919                 }
   5920                //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
   5921                 else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
   \                     ??gcode_G29_85: (+1)
   \   00000970   0x2804             CMP      R0,#+4
   \   00000972   0xF040 0x814A      BNE.W    ??gcode_G29_87
   5922                  {
   5923                  // For LINEAR leveling calculate matrix, print reports, correct the position
   5924          
   5925                  /**
   5926                   * solve the plane equation ax + by + d = z
   5927                   * A is the matrix with rows [x y 1] for all the probed points
   5928                   * B is the vector of the Z positions
   5929                   * the normal vector to the plane is formed by the coefficients of the
   5930                   * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
   5931                   * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
   5932                   */
   5933                  float plane_equation_coefficients[3];
   5934          
   5935                  finish_incremental_LSF(&lsf_results);
   \   00000976   0xA82B             ADD      R0,SP,#+172
   \   00000978   0x.... 0x....      BL       _Z22finish_incremental_LSFP15linear_fit_data
   5936                  plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
   \   0000097C   0x9F36             LDR      R7,[SP, #+216]
   \   0000097E   0x46BB             MOV      R11,R7
   \   00000980   0xF08B 0x4B00      EOR      R11,R11,#0x80000000
   5937                  plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
   \   00000984   0x9E37             LDR      R6,[SP, #+220]
   \   00000986   0x4635             MOV      R5,R6
   \   00000988   0xF085 0x4500      EOR      R5,R5,#0x80000000
   5938                  plane_equation_coefficients[2] = -lsf_results.D;
   \   0000098C   0xF8DD 0xA0E0      LDR      R10,[SP, #+224]
   \   00000990   0xF08A 0x4A00      EOR      R10,R10,#0x80000000
   5939          
   5940                  mean /= abl2;
   \   00000994   0x9811             LDR      R0,[SP, #+68]
   \   00000996   0x.... 0x....      BL       __aeabi_i2f
   \   0000099A   0x4601             MOV      R1,R0
   \   0000099C   0x4640             MOV      R0,R8
   \   0000099E   0x.... 0x....      BL       __aeabi_fdiv
   \   000009A2   0x4680             MOV      R8,R0
   5941          
   5942                  if (verbose_level) {
   \   000009A4   0x980A             LDR      R0,[SP, #+40]
   \   000009A6   0x2800             CMP      R0,#+0
   \   000009A8   0xD043             BEQ.N    ??gcode_G29_88
   5943                    SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
   \   000009AA   0xF8DF 0x03C8      LDR.W    R0,??gcode_G29_1+0x6C
   \   000009AE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5944                    SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
   \   000009B2   0xF8DF 0x43B0      LDR.W    R4,??gcode_G29_1+0x5C
   \   000009B6   0x2008             MOVS     R0,#+8
   \   000009B8   0x9000             STR      R0,[SP, #+0]
   \   000009BA   0x4658             MOV      R0,R11
   \   000009BC   0x.... 0x....      BL       __aeabi_f2d
   \   000009C0   0x4602             MOV      R2,R0
   \   000009C2   0x460B             MOV      R3,R1
   \   000009C4   0x4620             MOV      R0,R4
   \   000009C6   0x.... 0x....      BL       _ZN5Print5printEdi
   5945                    SERIAL_PROTOCOLPGM(" b: ");
   \   000009CA   0xF8DF 0x03AC      LDR.W    R0,??gcode_G29_1+0x70
   \   000009CE   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5946                    SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
   \   000009D2   0x2008             MOVS     R0,#+8
   \   000009D4   0x9000             STR      R0,[SP, #+0]
   \   000009D6   0x4628             MOV      R0,R5
   \   000009D8   0x.... 0x....      BL       __aeabi_f2d
   \   000009DC   0x4602             MOV      R2,R0
   \   000009DE   0x460B             MOV      R3,R1
   \   000009E0   0x4620             MOV      R0,R4
   \   000009E2   0x.... 0x....      BL       _ZN5Print5printEdi
   5947                    SERIAL_PROTOCOLPGM(" d: ");
   \   000009E6   0xF8DF 0x0394      LDR.W    R0,??gcode_G29_1+0x74
   \   000009EA   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5948                    SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
   \   000009EE   0x2008             MOVS     R0,#+8
   \   000009F0   0x9000             STR      R0,[SP, #+0]
   \   000009F2   0x4650             MOV      R0,R10
   \   000009F4   0x.... 0x....      BL       __aeabi_f2d
   \   000009F8   0x4602             MOV      R2,R0
   \   000009FA   0x460B             MOV      R3,R1
   \   000009FC   0x4620             MOV      R0,R4
   \   000009FE   0x.... 0x....      BL       _ZN5Print5printEdi
   5949                    SERIAL_EOL();
   \   00000A02   0x210A             MOVS     R1,#+10
   \   00000A04   0x4620             MOV      R0,R4
   \   00000A06   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5950                    if (verbose_level > 2) {
   \   00000A0A   0x980A             LDR      R0,[SP, #+40]
   \   00000A0C   0x2803             CMP      R0,#+3
   \   00000A0E   0xDB10             BLT.N    ??gcode_G29_88
   5951                      SERIAL_PROTOCOLPGM("Mean of sampled points: ");
   \   00000A10   0x48DB             LDR.N    R0,??gcode_G29_1+0x78
   \   00000A12   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5952                      SERIAL_PROTOCOL_F(mean, 8);
   \   00000A16   0x2008             MOVS     R0,#+8
   \   00000A18   0x9000             STR      R0,[SP, #+0]
   \   00000A1A   0x4640             MOV      R0,R8
   \   00000A1C   0x.... 0x....      BL       __aeabi_f2d
   \   00000A20   0x4602             MOV      R2,R0
   \   00000A22   0x460B             MOV      R3,R1
   \   00000A24   0x4620             MOV      R0,R4
   \   00000A26   0x.... 0x....      BL       _ZN5Print5printEdi
   5953                      SERIAL_EOL();
   \   00000A2A   0x210A             MOVS     R1,#+10
   \   00000A2C   0x4620             MOV      R0,R4
   \   00000A2E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   5954                    }
   5955                  }
   5956          
   5957                  // Create the matrix but don't correct the position yet
   5958                  if (!dryrun)
   \                     ??gcode_G29_88: (+1)
   \   00000A32   0x980F             LDR      R0,[SP, #+60]
   \   00000A34   0x2800             CMP      R0,#+0
   \   00000A36   0xD111             BNE.N    ??gcode_G29_89
   5959                    planner.bed_level_matrix = matrix_3x3::create_look_at(
   5960                      vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
   5961                    );
   \   00000A38   0xF04F 0x537E      MOV      R3,#+1065353216
   \   00000A3C   0x4632             MOV      R2,R6
   \   00000A3E   0x4639             MOV      R1,R7
   \   00000A40   0xA800             ADD      R0,SP,#+0
   \   00000A42   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   00000A46   0xA800             ADD      R0,SP,#+0
   \   00000A48   0xE890 0x000E      LDM      R0,{R1-R3}
   \   00000A4C   0xA81F             ADD      R0,SP,#+124
   \   00000A4E   0x.... 0x....      BL       _ZN10matrix_3x314create_look_atE8vector_3
   \   00000A52   0x48C7             LDR.N    R0,??gcode_G29_1+0x68
   \   00000A54   0xA91F             ADD      R1,SP,#+124
   \   00000A56   0x2224             MOVS     R2,#+36
   \   00000A58   0x.... 0x....      BL       __aeabi_memcpy4
   5962          
   5963                  // Show the Topography map if enabled
   5964                  if (do_topography_map) {
   \                     ??gcode_G29_89: (+1)
   \   00000A5C   0xF89D 0x000C      LDRB     R0,[SP, #+12]
   \   00000A60   0x2800             CMP      R0,#+0
   \   00000A62   0xF000 0x80D2      BEQ.W    ??gcode_G29_87
   5965          
   5966                    SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
   5967                                           "   +--- BACK --+\n"
   5968                                           "   |           |\n"
   5969                                           " L |    (+)    | R\n"
   5970                                           " E |           | I\n"
   5971                                           " F | (-) N (+) | G\n"
   5972                                           " T |           | H\n"
   5973                                           "   |    (-)    | T\n"
   5974                                           "   |           |\n"
   5975                                           "   O-- FRONT --+\n"
   5976                                           " (0,0)");
   \   00000A66   0x48C7             LDR.N    R0,??gcode_G29_1+0x7C
   \   00000A68   0x.... 0x....      BL       _Z14serialprintPGMPKc
   5977          
   5978                    float min_diff = 999;
   \   00000A6C   0x4FC6             LDR.N    R7,??gcode_G29_1+0x80  ;; 0x4479c000
   5979          
   5980                    for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   \   00000A6E   0x9804             LDR      R0,[SP, #+16]
   \   00000A70   0xF1A0 0x0B01      SUB      R11,R0,#+1
   \   00000A74   0xFA4F 0xFB8B      SXTB     R11,R11
   \   00000A78   0x46DA             MOV      R10,R11
   \   00000A7A   0xE007             B.N      ??gcode_G29_90
   5981                      for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   5982                        int ind = indexIntoAB[xx][yy];
   5983                        /*
   5984                        float diff = eqnBVector[ind] - mean,
   5985                              x_tmp = eqnAMatrix[ind + 0 * abl2],
   5986                              y_tmp = eqnAMatrix[ind + 1 * abl2],
   5987                              z_tmp = 0;
   5988                              */
   5989                            float diff = *(eqnBVector+ind) - mean,
   5990                                  x_tmp = *(eqnAMatrix+ind + 0 * abl2),
   5991                                  y_tmp = *(eqnAMatrix+ind + 1 * abl2),
   5992                                  z_tmp = 0;
   5993          
   5994                        apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   5995          
   5996                        //NOMORE(min_diff, eqnBVector[ind] - z_tmp);
   5997                        NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
   5998          
   5999                        if (diff >= 0.0)
   6000                          SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
   6001                        else
   6002                          SERIAL_PROTOCOLCHAR(' ');
   6003                        SERIAL_PROTOCOL_F(diff, 5);
   6004                      } // xx
   6005                      SERIAL_EOL();
   \                     ??gcode_G29_91: (+1)
   \   00000A7C   0x210A             MOVS     R1,#+10
   \   00000A7E   0x48B9             LDR.N    R0,??gcode_G29_1+0x5C
   \   00000A80   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000A84   0xF1AA 0x0A01      SUB      R10,R10,#+1
   \   00000A88   0xFA4F 0xFA8A      SXTB     R10,R10
   \                     ??gcode_G29_90: (+1)
   \   00000A8C   0xF1BA 0x0F00      CMP      R10,#+0
   \   00000A90   0xD454             BMI.N    ??gcode_G29_92
   \   00000A92   0x2500             MOVS     R5,#+0
   \   00000A94   0xE00E             B.N      ??gcode_G29_93
   \                     ??gcode_G29_94: (+1)
   \   00000A96   0x2120             MOVS     R1,#+32
   \   00000A98   0x4620             MOV      R0,R4
   \   00000A9A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??gcode_G29_95: (+1)
   \   00000A9E   0x2005             MOVS     R0,#+5
   \   00000AA0   0x9000             STR      R0,[SP, #+0]
   \   00000AA2   0x4630             MOV      R0,R6
   \   00000AA4   0x.... 0x....      BL       __aeabi_f2d
   \   00000AA8   0x4602             MOV      R2,R0
   \   00000AAA   0x460B             MOV      R3,R1
   \   00000AAC   0x4620             MOV      R0,R4
   \   00000AAE   0x.... 0x....      BL       _ZN5Print5printEdi
   \   00000AB2   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_G29_93: (+1)
   \   00000AB4   0xB2ED             UXTB     R5,R5
   \   00000AB6   0x4628             MOV      R0,R5
   \   00000AB8   0x990C             LDR      R1,[SP, #+48]
   \   00000ABA   0x4288             CMP      R0,R1
   \   00000ABC   0xDADE             BGE.N    ??gcode_G29_91
   \   00000ABE   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000AC2   0xA83A             ADD      R0,SP,#+232
   \   00000AC4   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   00000AC8   0xF850 0x402A      LDR      R4,[R0, R10, LSL #+2]
   \   00000ACC   0x9810             LDR      R0,[SP, #+64]
   \   00000ACE   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000AD2   0x4641             MOV      R1,R8
   \   00000AD4   0x.... 0x....      BL       __aeabi_fsub
   \   00000AD8   0x4606             MOV      R6,R0
   \   00000ADA   0x980B             LDR      R0,[SP, #+44]
   \   00000ADC   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000AE0   0x9014             STR      R0,[SP, #+80]
   \   00000AE2   0x9811             LDR      R0,[SP, #+68]
   \   00000AE4   0x990B             LDR      R1,[SP, #+44]
   \   00000AE6   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   00000AEA   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000AEE   0x9013             STR      R0,[SP, #+76]
   \   00000AF0   0x2000             MOVS     R0,#+0
   \   00000AF2   0x9012             STR      R0,[SP, #+72]
   \   00000AF4   0xA812             ADD      R0,SP,#+72
   \   00000AF6   0x9007             STR      R0,[SP, #+28]
   \   00000AF8   0xA813             ADD      R0,SP,#+76
   \   00000AFA   0x9006             STR      R0,[SP, #+24]
   \   00000AFC   0xA814             ADD      R0,SP,#+80
   \   00000AFE   0x9005             STR      R0,[SP, #+20]
   \   00000B00   0x499B             LDR.N    R1,??gcode_G29_1+0x68
   \   00000B02   0xB084             SUB      SP,SP,#+16
   \   00000B04   0x4668             MOV      R0,SP
   \   00000B06   0x2224             MOVS     R2,#+36
   \   00000B08   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000B0C   0xBC0F             POP      {R0-R3}
   \   00000B0E   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
   \   00000B12   0x9810             LDR      R0,[SP, #+64]
   \   00000B14   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000B18   0x9912             LDR      R1,[SP, #+72]
   \   00000B1A   0x.... 0x....      BL       __aeabi_fsub
   \   00000B1E   0x4639             MOV      R1,R7
   \   00000B20   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000B24   0xD200             BCS.N    ??gcode_G29_96
   \   00000B26   0x4607             MOV      R7,R0
   \                     ??gcode_G29_96: (+1)
   \   00000B28   0x4C8E             LDR.N    R4,??gcode_G29_1+0x5C
   \   00000B2A   0x4630             MOV      R0,R6
   \   00000B2C   0x2100             MOVS     R1,#+0
   \   00000B2E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000B32   0xD8B0             BHI.N    ??gcode_G29_94
   \   00000B34   0x4895             LDR.N    R0,??gcode_G29_1+0x84
   \   00000B36   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000B3A   0xE7B0             B.N      ??gcode_G29_95
   6006                    } // yy
   6007                    SERIAL_EOL();
   \                     ??gcode_G29_92: (+1)
   \   00000B3C   0x4C89             LDR.N    R4,??gcode_G29_1+0x5C
   \   00000B3E   0x210A             MOVS     R1,#+10
   \   00000B40   0x4620             MOV      R0,R4
   \   00000B42   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   6008          
   6009                    if (verbose_level > 3) {
   \   00000B46   0x980A             LDR      R0,[SP, #+40]
   \   00000B48   0x2804             CMP      R0,#+4
   \   00000B4A   0xDB5E             BLT.N    ??gcode_G29_87
   6010                      SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
   \   00000B4C   0x4890             LDR.N    R0,??gcode_G29_1+0x88
   \   00000B4E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   6011          
   6012                      for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
   \   00000B52   0x46D8             MOV      R8,R11
   \   00000B54   0xE007             B.N      ??gcode_G29_97
   6013                        for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
   6014                          int ind = indexIntoAB[xx][yy];
   6015                          /*
   6016                          float x_tmp = eqnAMatrix[ind + 0 * abl2],
   6017                                y_tmp = eqnAMatrix[ind + 1 * abl2],
   6018                                z_tmp = 0;
   6019                                */
   6020                          float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
   6021                                y_tmp = *(eqnAMatrix+ind + 1 * abl2),
   6022                                z_tmp = 0;
   6023          
   6024                          apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
   6025          
   6026                          //float diff = eqnBVector[ind] - z_tmp - min_diff;
   6027                          float diff = *(eqnBVector+ind) - z_tmp - min_diff;
   6028                          if (diff >= 0.0)
   6029                            SERIAL_PROTOCOLPGM(" +");
   6030                          // Include + for column alignment
   6031                          else
   6032                            SERIAL_PROTOCOLCHAR(' ');
   6033                          SERIAL_PROTOCOL_F(diff, 5);
   6034                        } // xx
   6035                        SERIAL_EOL();
   \                     ??gcode_G29_98: (+1)
   \   00000B56   0x210A             MOVS     R1,#+10
   \   00000B58   0x4620             MOV      R0,R4
   \   00000B5A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000B5E   0xF1A8 0x0801      SUB      R8,R8,#+1
   \   00000B62   0xFA4F 0xF888      SXTB     R8,R8
   \                     ??gcode_G29_97: (+1)
   \   00000B66   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000B6A   0xD44A             BMI.N    ??gcode_G29_99
   \   00000B6C   0x2500             MOVS     R5,#+0
   \   00000B6E   0xE00E             B.N      ??gcode_G29_100
   \                     ??gcode_G29_101: (+1)
   \   00000B70   0x2120             MOVS     R1,#+32
   \   00000B72   0x4620             MOV      R0,R4
   \   00000B74   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \                     ??gcode_G29_102: (+1)
   \   00000B78   0x2005             MOVS     R0,#+5
   \   00000B7A   0x9000             STR      R0,[SP, #+0]
   \   00000B7C   0x4630             MOV      R0,R6
   \   00000B7E   0x.... 0x....      BL       __aeabi_f2d
   \   00000B82   0x4602             MOV      R2,R0
   \   00000B84   0x460B             MOV      R3,R1
   \   00000B86   0x4620             MOV      R0,R4
   \   00000B88   0x.... 0x....      BL       _ZN5Print5printEdi
   \   00000B8C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_G29_100: (+1)
   \   00000B8E   0xB2ED             UXTB     R5,R5
   \   00000B90   0x4628             MOV      R0,R5
   \   00000B92   0x990C             LDR      R1,[SP, #+48]
   \   00000B94   0x4288             CMP      R0,R1
   \   00000B96   0xDADE             BGE.N    ??gcode_G29_98
   \   00000B98   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   00000B9C   0xA83A             ADD      R0,SP,#+232
   \   00000B9E   0xEB00 0x1001      ADD      R0,R0,R1, LSL #+4
   \   00000BA2   0xF850 0x6028      LDR      R6,[R0, R8, LSL #+2]
   \   00000BA6   0x980B             LDR      R0,[SP, #+44]
   \   00000BA8   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000BAC   0x9014             STR      R0,[SP, #+80]
   \   00000BAE   0x9811             LDR      R0,[SP, #+68]
   \   00000BB0   0x990B             LDR      R1,[SP, #+44]
   \   00000BB2   0xEB01 0x0186      ADD      R1,R1,R6, LSL #+2
   \   00000BB6   0xF851 0x0020      LDR      R0,[R1, R0, LSL #+2]
   \   00000BBA   0x9013             STR      R0,[SP, #+76]
   \   00000BBC   0x2000             MOVS     R0,#+0
   \   00000BBE   0x9012             STR      R0,[SP, #+72]
   \   00000BC0   0xA812             ADD      R0,SP,#+72
   \   00000BC2   0x9007             STR      R0,[SP, #+28]
   \   00000BC4   0xA813             ADD      R0,SP,#+76
   \   00000BC6   0x9006             STR      R0,[SP, #+24]
   \   00000BC8   0xA814             ADD      R0,SP,#+80
   \   00000BCA   0x9005             STR      R0,[SP, #+20]
   \   00000BCC   0x4968             LDR.N    R1,??gcode_G29_1+0x68
   \   00000BCE   0xB084             SUB      SP,SP,#+16
   \   00000BD0   0x4668             MOV      R0,SP
   \   00000BD2   0x2224             MOVS     R2,#+36
   \   00000BD4   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000BD8   0xBC0F             POP      {R0-R3}
   \   00000BDA   0x.... 0x....      BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
   \   00000BDE   0x9810             LDR      R0,[SP, #+64]
   \   00000BE0   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000BE4   0x9912             LDR      R1,[SP, #+72]
   \   00000BE6   0x.... 0x....      BL       __aeabi_fsub
   \   00000BEA   0x4639             MOV      R1,R7
   \   00000BEC   0x.... 0x....      BL       __aeabi_fsub
   \   00000BF0   0x4606             MOV      R6,R0
   \   00000BF2   0x2100             MOVS     R1,#+0
   \   00000BF4   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000BF8   0xD8BA             BHI.N    ??gcode_G29_101
   \   00000BFA   0x4864             LDR.N    R0,??gcode_G29_1+0x84
   \   00000BFC   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   00000C00   0xE7BA             B.N      ??gcode_G29_102
   6036                      } // yy
   6037                      SERIAL_EOL();
   \                     ??gcode_G29_99: (+1)
   \   00000C02   0x210A             MOVS     R1,#+10
   \   00000C04   0x4620             MOV      R0,R4
   \   00000C06   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   6038                    }
   6039                  } //do_topography_map
   6040                  }
   6041                //#endif // AUTO_BED_LEVELING_LINEAR
   6042          
   6043                //#if ABL_PLANAR
   6044                if(BED_LEVELING_METHOD&ABL_PLANAR)  {
   \                     ??gcode_G29_87: (+1)
   \   00000C0A   0x483F             LDR.N    R0,??gcode_G29_1
   \   00000C0C   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000C10   0x2106             MOVS     R1,#+6
   \   00000C12   0x4208             TST      R0,R1
   \   00000C14   0xD047             BEQ.N    ??gcode_G29_103
   6045          
   6046                  // For LINEAR and 3POINT leveling correct the current position
   6047          
   6048                  if (verbose_level > 0)
   \   00000C16   0x980A             LDR      R0,[SP, #+40]
   \   00000C18   0x2801             CMP      R0,#+1
   \   00000C1A   0xDB03             BLT.N    ??gcode_G29_104
   6049                    planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
   \   00000C1C   0x495D             LDR.N    R1,??gcode_G29_1+0x8C
   \   00000C1E   0x4854             LDR.N    R0,??gcode_G29_1+0x68
   \   00000C20   0x.... 0x....      BL       _ZN10matrix_3x35debugEPKc
   6050          
   6051                  if (!dryrun) {
   \                     ??gcode_G29_104: (+1)
   \   00000C24   0x980F             LDR      R0,[SP, #+60]
   \   00000C26   0x2800             CMP      R0,#+0
   \   00000C28   0xD14C             BNE.N    ??gcode_G29_105
   6052                    //
   6053                    // Correct the current XYZ position based on the tilted plane.
   6054                    //
   6055          
   6056                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6057                      if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
   6058                    #endif
   6059          
   6060                    float converted[XYZ];
   6061                    COPY(converted, current_position);
   \   00000C2A   0x4C3F             LDR.N    R4,??gcode_G29_1+0x20
   \   00000C2C   0x220C             MOVS     R2,#+12
   \   00000C2E   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000C32   0xA800             ADD      R0,SP,#+0
   \   00000C34   0x.... 0x....      BL       memcpy
   6062          
   6063                    planner.leveling_active = true;
   \   00000C38   0x2001             MOVS     R0,#+1
   \   00000C3A   0x4938             LDR.N    R1,??gcode_G29_1+0x14
   \   00000C3C   0x7008             STRB     R0,[R1, #+0]
   6064                    planner.unapply_leveling(converted); // use conversion machinery
   \   00000C3E   0xA800             ADD      R0,SP,#+0
   \   00000C40   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
   6065                    planner.leveling_active = false;
   \   00000C44   0x2000             MOVS     R0,#+0
   \   00000C46   0x4935             LDR.N    R1,??gcode_G29_1+0x14
   \   00000C48   0x7008             STRB     R0,[R1, #+0]
   6066          
   6067                    // Use the last measured distance to the bed, if possible
   6068                    if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
   6069                      && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
   6070                    ) {
   \   00000C4A   0x9808             LDR      R0,[SP, #+32]
   \   00000C4C   0x68C0             LDR      R0,[R0, #+12]
   \   00000C4E   0x990E             LDR      R1,[SP, #+56]
   \   00000C50   0x.... 0x....      BL       __aeabi_fsub
   \   00000C54   0x68A1             LDR      R1,[R4, #+8]
   \   00000C56   0x.... 0x....      BL       __aeabi_fadd
   \   00000C5A   0x4D4F             LDR.N    R5,??gcode_G29_1+0x90  ;; 0xb58637bd
   \   00000C5C   0x4629             MOV      R1,R5
   \   00000C5E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000C62   0xD819             BHI.N    ??gcode_G29_106
   \   00000C64   0x4E4D             LDR.N    R6,??gcode_G29_1+0x94  ;; 0x358637be
   \   00000C66   0x4631             MOV      R1,R6
   \   00000C68   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C6C   0xD214             BCS.N    ??gcode_G29_106
   \   00000C6E   0x9808             LDR      R0,[SP, #+32]
   \   00000C70   0x6900             LDR      R0,[R0, #+16]
   \   00000C72   0x990D             LDR      R1,[SP, #+52]
   \   00000C74   0x.... 0x....      BL       __aeabi_fsub
   \   00000C78   0x68E1             LDR      R1,[R4, #+12]
   \   00000C7A   0x.... 0x....      BL       __aeabi_fadd
   \   00000C7E   0x4629             MOV      R1,R5
   \   00000C80   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000C84   0xD808             BHI.N    ??gcode_G29_106
   \   00000C86   0x4631             MOV      R1,R6
   \   00000C88   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000C8C   0xD204             BCS.N    ??gcode_G29_106
   6071                      const float simple_z = current_position[Z_AXIS] - measured_z;
   6072                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   6073                        if (DEBUGGING(LEVELING)) {
   6074                          SERIAL_ECHOPAIR("Z from Probe:", simple_z);
   6075                          SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
   6076                          SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
   6077                        }
   6078                      #endif
   6079                      converted[Z_AXIS] = simple_z;
   \   00000C8E   0x6920             LDR      R0,[R4, #+16]
   \   00000C90   0x9909             LDR      R1,[SP, #+36]
   \   00000C92   0x.... 0x....      BL       __aeabi_fsub
   \   00000C96   0x9002             STR      R0,[SP, #+8]
   6080                    }
   6081          
   6082                    // The rotated XY and corrected Z are now current_position
   6083                    COPY(current_position, converted);
   \                     ??gcode_G29_106: (+1)
   \   00000C98   0x220C             MOVS     R2,#+12
   \   00000C9A   0xA900             ADD      R1,SP,#+0
   \   00000C9C   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000CA0   0x.... 0x....      BL       memcpy
   \   00000CA4   0xE00E             B.N      ??gcode_G29_105
   6084          
   6085                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6086                      if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
   6087                    #endif
   6088                  }
   6089                  }
   6090                //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
   6091                else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
   \                     ??gcode_G29_103: (+1)
   \   00000CA6   0x2808             CMP      R0,#+8
   \   00000CA8   0xD10C             BNE.N    ??gcode_G29_105
   6092          
   6093                  if (!dryrun) {
   \   00000CAA   0x980F             LDR      R0,[SP, #+60]
   \   00000CAC   0x2800             CMP      R0,#+0
   \   00000CAE   0xD109             BNE.N    ??gcode_G29_105
   6094                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6095                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
   6096                    #endif
   6097          
   6098                    // Unapply the offset because it is going to be immediately applied
   6099                    // and cause compensation movement in Z
   6100                    current_position[Z_AXIS] -= bilinear_z_offset(current_position);
   \   00000CB0   0x4C1D             LDR.N    R4,??gcode_G29_1+0x20
   \   00000CB2   0xF104 0x0008      ADD      R0,R4,#+8
   \   00000CB6   0x.... 0x....      BL       _Z17bilinear_z_offsetPKf
   \   00000CBA   0x4601             MOV      R1,R0
   \   00000CBC   0x6920             LDR      R0,[R4, #+16]
   \   00000CBE   0x.... 0x....      BL       __aeabi_fsub
   \   00000CC2   0x6120             STR      R0,[R4, #+16]
   6101          
   6102                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   6103                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
   6104                    #endif
   6105                  }
   6106                  }
   6107                //#endif // ABL_PLANAR
   6108          
   6109                #ifdef Z_PROBE_END_SCRIPT
   6110                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   6111                    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
   6112                  #endif
   6113                  enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
   6114                  stepper.synchronize();
   6115                #endif
   6116          
   6117                // Auto Bed Leveling is complete! Enable if possible.
   6118                planner.leveling_active = dryrun ? abl_should_enable : true;
   \                     ??gcode_G29_105: (+1)
   \   00000CC4   0x980F             LDR      R0,[SP, #+60]
   \   00000CC6   0x2800             CMP      R0,#+0
   \   00000CC8   0xD003             BEQ.N    ??gcode_G29_107
   \   00000CCA   0x4814             LDR.N    R0,??gcode_G29_1+0x14
   \   00000CCC   0xF880 0x9000      STRB     R9,[R0, #+0]
   \   00000CD0   0xE002             B.N      ??gcode_G29_84
   \                     ??gcode_G29_107: (+1)
   \   00000CD2   0x2001             MOVS     R0,#+1
   \   00000CD4   0x4911             LDR.N    R1,??gcode_G29_1+0x14
   \   00000CD6   0x7008             STRB     R0,[R1, #+0]
   6119              } // !isnan(measured_z)
   6120          
   6121              // Restore state after probing
   6122              if (!faux) clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G29_84: (+1)
   \   00000CD8   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   6123          
   6124              #if ENABLED(DEBUG_LEVELING_FEATURE)
   6125                if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
   6126              #endif
   6127          
   6128              report_current_position();
   \   00000CDC   0x.... 0x....      BL       _Z23report_current_positionv
   6129          
   6130              KEEPALIVE_STATE(IN_HANDLER);
   \   00000CE0   0x2001             MOVS     R0,#+1
   \   00000CE2   0x490B             LDR.N    R1,??gcode_G29_1+0x8
   \   00000CE4   0x7188             STRB     R0,[R1, #+6]
   6131          
   6132              if (planner.leveling_active)
   \   00000CE6   0x480D             LDR.N    R0,??gcode_G29_1+0x14
   \   00000CE8   0x7800             LDRB     R0,[R0, #+0]
   \   00000CEA   0x2800             CMP      R0,#+0
   \   00000CEC   0xD001             BEQ.N    ??gcode_G29_108
   6133                SYNC_PLAN_POSITION_KINEMATIC();
   \   00000CEE   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   6134          
   6135              free(eqnBVector);
   \                     ??gcode_G29_108: (+1)
   \   00000CF2   0x9810             LDR      R0,[SP, #+64]
   \   00000CF4   0x.... 0x....      BL       free
   6136          	free(eqnAMatrix);
   \   00000CF8   0x980B             LDR      R0,[SP, #+44]
   \   00000CFA   0x.... 0x....      BL       free
   6137            }
   \                     ??gcode_G29_0: (+1)
   \   00000CFE   0xF50D 0x7D4B      ADD      SP,SP,#+812
   \   00000D02   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   00000D06   0xBF00             Nop      
   \                     ??gcode_G29_1:
   \   00000D08   0x........         DC32     mksCfg
   \   00000D0C   0x........         DC32     mksCfg+0x60
   \   00000D10   0x........         DC32     axis_relative_modes
   \   00000D14   0x........         DC32     _ZZ9gcode_G29vEs
   \   00000D18   0x........         DC32     _ZZ9gcode_G29vEs_0
   \   00000D1C   0x........         DC32     _ZN7Planner15leveling_activeE
   \   00000D20   0x........         DC32     errormagic
   \   00000D24   0x........         DC32     _ZZ9gcode_G29vEs_1
   \   00000D28   0x........         DC32     mks_heating_busy
   \   00000D2C   0xC1200000         DC32     0xc1200000
   \   00000D30   0x41200001         DC32     0x41200001
   \   00000D34   0x........         DC32     _ZZ9gcode_G29vEs_2
   \   00000D38   0x........         DC32     z_values
   \   00000D3C   0x........         DC32     _ZZ9gcode_G29vEs_3
   \   00000D40   0x........         DC32     _ZZ9gcode_G29vEs_4
   \   00000D44   0x42700000         DC32     0x42700000
   \   00000D48   0x........         DC32     mksTmp
   \   00000D4C   0x........         DC32     _ZZ9gcode_G29vEs_5
   \   00000D50   0x........         DC32     _ZZ9gcode_G29vEs_6
   \   00000D54   0x........         DC32     _ZZ9gcode_G29vEs_7
   \   00000D58   0x........         DC32     _ZZ9gcode_G29vEs_8
   \   00000D5C   0x........         DC32     _ZZ9gcode_G29vEs_9
   \   00000D60   0x........         DC32     _ZZ9gcode_G29vEs__10_
   \   00000D64   0x........         DC32     Serial3
   \   00000D68   0x3FE00000         DC32     0x3fe00000
   \   00000D6C   0xBF800000         DC32     0xbf800000
   \   00000D70   0x........         DC32     _ZN7Planner16bed_level_matrixE
   \   00000D74   0x........         DC32     _ZZ9gcode_G29vEs__11_
   \   00000D78   0x........         DC32     _ZZ9gcode_G29vEs__12_
   \   00000D7C   0x........         DC32     _ZZ9gcode_G29vEs__13_
   \   00000D80   0x........         DC32     _ZZ9gcode_G29vEs__14_
   \   00000D84   0x........         DC32     _ZZ9gcode_G29vEs__15_
   \   00000D88   0x4479C000         DC32     0x4479c000
   \   00000D8C   0x........         DC32     _ZZ9gcode_G29vEs__16_
   \   00000D90   0x........         DC32     _ZZ9gcode_G29vEs__17_
   \   00000D94   0x........         DC32     _ZZ9gcode_G29vEs__18_
   \   00000D98   0xB58637BD         DC32     0xb58637bd
   \   00000D9C   0x358637BE         DC32     0x358637be
   6138          
   6139          #endif // OLDSCHOOL_ABL
   6140          
   6141          #if HAS_BED_PROBE
   6142          
   6143            /**
   6144             * G30: Do a single Z probe at the current XY
   6145             *
   6146             * Parameters:
   6147             *
   6148             *   X   Probe X position (default current X)
   6149             *   Y   Probe Y position (default current Y)
   6150             *   E   Engage the probe for each probe
   6151             */

   \                                 In section .text, align 4
   6152            inline void gcode_G30() {
   \                     _Z9gcode_G30v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
   6153              const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
   \   00000004   0x4C37             LDR.N    R4,??gcode_G30_0
   \   00000006   0xF104 0x0540      ADD      R5,R4,#+64
   \   0000000A   0x4E37             LDR.N    R6,??gcode_G30_0+0x4
   \   0000000C   0x68B1             LDR      R1,[R6, #+8]
   \   0000000E   0x6AE8             LDR      R0,[R5, #+44]
   \   00000010   0x.... 0x....      BL       __aeabi_fadd
   \   00000014   0x4601             MOV      R1,R0
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000001C   0x9002             STR      R0,[SP, #+8]
   6154                          ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
   \   0000001E   0x68F1             LDR      R1,[R6, #+12]
   \   00000020   0x6B28             LDR      R0,[R5, #+48]
   \   00000022   0x.... 0x....      BL       __aeabi_fadd
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x2059             MOVS     R0,#+89
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   0000002E   0x9001             STR      R0,[SP, #+4]
   6155              if(MACHINETPYE & IS_KINEMATIC)
   \   00000030   0x8B28             LDRH     R0,[R5, #+24]
   \   00000032   0xF240 0x3102      MOVW     R1,#+770
   \   00000036   0x4208             TST      R0,R1
   \   00000038   0xD00B             BEQ.N    ??gcode_G30_1
   6156                  if (!position_is_reachable_by_probe_IS_KINEMATIC(xpos, ypos)) return;
   \   0000003A   0xA901             ADD      R1,SP,#+4
   \   0000003C   0xA802             ADD      R0,SP,#+8
   \   0000003E   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD04D             BEQ.N    ??gcode_G30_2
   6157              else
   6158                  if (!position_is_reachable_by_probe_IS_CARTESIAN(xpos, ypos)) return;
   \   00000046   0xA901             ADD      R1,SP,#+4
   \   00000048   0xA802             ADD      R0,SP,#+8
   \   0000004A   0x.... 0x....      BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
   \   0000004E   0x2800             CMP      R0,#+0
   \   00000050   0xD047             BEQ.N    ??gcode_G30_2
   6159          
   6160              // Disable leveling so the planner won't mess with us
   6161              //#if HAS_LEVELING
   6162          	if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??gcode_G30_1: (+1)
   \   00000052   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000056   0x213E             MOVS     R1,#+62
   \   00000058   0x4208             TST      R0,R1
   \   0000005A   0xD002             BEQ.N    ??gcode_G30_3
   6163                set_bed_leveling_enabled(false);
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   6164              //#endif
   6165          
   6166              setup_for_endstop_or_probe_move();
   \                     ??gcode_G30_3: (+1)
   \   00000062   0x.... 0x....      BL       _Z31setup_for_endstop_or_probe_movev
   6167          
   6168              const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
   \   00000066   0x2045             MOVS     R0,#+69
   \   00000068   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000006C   0x2101             MOVS     R1,#+1
   \   0000006E   0x9100             STR      R1,[SP, #+0]
   \   00000070   0x460B             MOV      R3,R1
   \   00000072   0x4602             MOV      R2,R0
   \   00000074   0xA901             ADD      R1,SP,#+4
   \   00000076   0xA802             ADD      R0,SP,#+8
   \   00000078   0x.... 0x....      BL       _Z8probe_ptRKfS0_bhb
   \   0000007C   0x4606             MOV      R6,R0
   6169          
   6170              if (!isnan(measured_z)) {
   \   0000007E   0x.... 0x....      BL       __iar_FDtest
   \   00000082   0x2802             CMP      R0,#+2
   \   00000084   0xD029             BEQ.N    ??gcode_G30_4
   6171                SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
   \   00000086   0x4C19             LDR.N    R4,??gcode_G30_0+0x8  ;; 0x88e368f1
   \   00000088   0x4D19             LDR.N    R5,??gcode_G30_0+0xC  ;; 0x3ee4f8b5
   \   0000008A   0x9802             LDR      R0,[SP, #+8]
   \   0000008C   0x.... 0x....      BL       __aeabi_f2d
   \   00000090   0x4622             MOV      R2,R4
   \   00000092   0x462B             MOV      R3,R5
   \   00000094   0x.... 0x....      BL       __aeabi_dadd
   \   00000098   0x4602             MOV      R2,R0
   \   0000009A   0x460B             MOV      R3,R1
   \   0000009C   0x4815             LDR.N    R0,??gcode_G30_0+0x10
   \   0000009E   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   6172                SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
   \   000000A2   0x9801             LDR      R0,[SP, #+4]
   \   000000A4   0x.... 0x....      BL       __aeabi_f2d
   \   000000A8   0x4622             MOV      R2,R4
   \   000000AA   0x462B             MOV      R3,R5
   \   000000AC   0x.... 0x....      BL       __aeabi_dadd
   \   000000B0   0x4602             MOV      R2,R0
   \   000000B2   0x460B             MOV      R3,R1
   \   000000B4   0x4810             LDR.N    R0,??gcode_G30_0+0x14
   \   000000B6   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   6173                SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
   \   000000BA   0x4630             MOV      R0,R6
   \   000000BC   0x.... 0x....      BL       __aeabi_f2d
   \   000000C0   0x4622             MOV      R2,R4
   \   000000C2   0x462B             MOV      R3,R5
   \   000000C4   0x.... 0x....      BL       __aeabi_dadd
   \   000000C8   0x4602             MOV      R2,R0
   \   000000CA   0x460B             MOV      R3,R1
   \   000000CC   0x480B             LDR.N    R0,??gcode_G30_0+0x18
   \   000000CE   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   \   000000D2   0x210A             MOVS     R1,#+10
   \   000000D4   0x480A             LDR.N    R0,??gcode_G30_0+0x1C
   \   000000D6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   6174              }
   6175          
   6176              clean_up_after_endstop_or_probe_move();
   \                     ??gcode_G30_4: (+1)
   \   000000DA   0x.... 0x....      BL       _Z36clean_up_after_endstop_or_probe_movev
   6177          
   6178              report_current_position();
   \   000000DE   0x.... 0x....      BL       _Z23report_current_positionv
   6179            }
   \                     ??gcode_G30_2: (+1)
   \   000000E2   0xBD7F             POP      {R0-R6,PC}       ;; return
   \                     ??gcode_G30_0:
   \   000000E4   0x........         DC32     mksCfg
   \   000000E8   0x........         DC32     mks_heating_busy
   \   000000EC   0x88E368F1         DC32     0x88e368f1
   \   000000F0   0x3EE4F8B5         DC32     0x3ee4f8b5
   \   000000F4   0x........         DC32     _ZZ9gcode_G30vEs
   \   000000F8   0x........         DC32     _ZZ9gcode_G30vEs_0
   \   000000FC   0x........         DC32     _ZZ9gcode_G30vEs_1
   \   00000100   0x........         DC32     Serial3
   6180          
   6181            #if ENABLED(Z_PROBE_SLED)
   6182          
   6183              /**
   6184               * G31: Deploy the Z probe
   6185               */
   6186              inline void gcode_G31() { DEPLOY_PROBE(); }
   6187          
   6188              /**
   6189               * G32: Stow the Z probe
   6190               */
   6191              inline void gcode_G32() { STOW_PROBE(); }
   6192          
   6193            #endif // Z_PROBE_SLED
   6194          
   6195          #endif // HAS_BED_PROBE
   6196          
   6197          #if ENABLED(DELTA_AUTO_CALIBRATION)
   6198          
   6199            constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
   6200                              _4P_STEP = _7P_STEP * 2,   // 4-point step
   6201                              NPP      = _7P_STEP * 6;   // number of calibration points on the radius
   6202            enum CalEnum {                               // the 7 main calibration points - add definitions if needed
   6203              CEN      = 0,
   6204              __A      = 1,
   6205              _AB      = __A + _7P_STEP,
   6206              __B      = _AB + _7P_STEP,
   6207              _BC      = __B + _7P_STEP,
   6208              __C      = _BC + _7P_STEP,
   6209              _CA      = __C + _7P_STEP,
   6210            };
   6211          
   6212            #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
   6213            #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
   6214            #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
   6215            #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
   6216            #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
   6217            #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
   6218          
   6219            static void print_signed_float(const char * const prefix, const float &f) {
   6220              SERIAL_PROTOCOLPGM("  ");
   6221              serialprintPGM(prefix);
   6222              SERIAL_PROTOCOLCHAR(':');
   6223              if (f >= 0) SERIAL_CHAR('+');
   6224              SERIAL_PROTOCOL_F(f, 2);
   6225            }
   6226          
   6227            static void print_G33_settings(const bool end_stops, const bool tower_angles) {
   6228              SERIAL_PROTOCOLPAIR(".Height:", delta_height);
   6229              if (end_stops) {
   6230                print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
   6231                print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
   6232                print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
   6233              }
   6234              if (end_stops && tower_angles) {
   6235                SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   6236                SERIAL_EOL();
   6237                SERIAL_CHAR('.');
   6238                SERIAL_PROTOCOL_SP(13);
   6239              }
   6240              if (tower_angles) {
   6241                print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
   6242                print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
   6243                print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
   6244              }
   6245              if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
   6246                SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
   6247              }
   6248              SERIAL_EOL();
   6249            }
   6250          
   6251            static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
   6252              SERIAL_PROTOCOLPGM(".    ");
   6253              print_signed_float(PSTR("c"), z_at_pt[CEN]);
   6254              if (tower_points) {
   6255                print_signed_float(PSTR(" x"), z_at_pt[__A]);
   6256                print_signed_float(PSTR(" y"), z_at_pt[__B]);
   6257                print_signed_float(PSTR(" z"), z_at_pt[__C]);
   6258              }
   6259              if (tower_points && opposite_points) {
   6260                SERIAL_EOL();
   6261                SERIAL_CHAR('.');
   6262                SERIAL_PROTOCOL_SP(13);
   6263              }
   6264              if (opposite_points) {
   6265                print_signed_float(PSTR("yz"), z_at_pt[_BC]);
   6266                print_signed_float(PSTR("zx"), z_at_pt[_CA]);
   6267                print_signed_float(PSTR("xy"), z_at_pt[_AB]);
   6268              }
   6269              SERIAL_EOL();
   6270            }
   6271          
   6272            /**
   6273             * After G33:
   6274             *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
   6275             *  - Stow the probe
   6276             *  - Restore endstops state
   6277             *  - Select the old tool, if needed
   6278             */
   6279            static void G33_cleanup(
   6280              #if HOTENDS > 1
   6281                const uint8_t old_tool_index
   6282              #endif
   6283            ) {
   6284              #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
   6285                do_blocking_move_to_z(delta_clip_start_height);
   6286              #endif
   6287              STOW_PROBE();
   6288              clean_up_after_endstop_or_probe_move();
   6289              #if HOTENDS > 1
   6290                tool_change(old_tool_index, 0, true);
   6291              #endif
   6292            }
   6293          
   6294            inline float calibration_probe(const float nx, const float ny, const bool stow) {
   6295              #if HAS_BED_PROBE
   6296                return probe_pt(nx, ny, stow, 0, false);
   6297              #else
   6298                UNUSED(stow);
   6299                return lcd_probe_pt(nx, ny);
   6300              #endif
   6301            }
   6302          
   6303            static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
   6304              const bool _0p_calibration      = probe_points == 0,
   6305                         _1p_calibration      = probe_points == 1,
   6306                         _4p_calibration      = probe_points == 2,
   6307                         _4p_opposite_points  = _4p_calibration && !towers_set,
   6308                         _7p_calibration      = probe_points >= 3 || probe_points == 0,
   6309                         _7p_no_intermediates = probe_points == 3,
   6310                         _7p_1_intermediates  = probe_points == 4,
   6311                         _7p_2_intermediates  = probe_points == 5,
   6312                         _7p_4_intermediates  = probe_points == 6,
   6313                         _7p_6_intermediates  = probe_points == 7,
   6314                         _7p_8_intermediates  = probe_points == 8,
   6315                         _7p_11_intermediates = probe_points == 9,
   6316                         _7p_14_intermediates = probe_points == 10,
   6317                         _7p_intermed_points  = probe_points >= 4,
   6318                         _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
   6319                         _7p_9_centre         = probe_points >= 8;
   6320          
   6321              LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
   6322          
   6323              if (!_0p_calibration) {
   6324          
   6325                if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
   6326                  z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
   6327                  if (isnan(z_at_pt[CEN])) return NAN;
   6328                }
   6329          
   6330                if (_7p_calibration) { // probe extra center points
   6331                  const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
   6332                              steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
   6333                  I_LOOP_CAL_PT(axis, start, steps) {
   6334                    const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6335                                r = delta_calibration_radius * 0.1;
   6336                    z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
   6337                    if (isnan(z_at_pt[CEN])) return NAN;
   6338                 }
   6339                  z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
   6340                }
   6341          
   6342                if (!_1p_calibration) {  // probe the radius
   6343                  const CalEnum start  = _4p_opposite_points ? _AB : __A;
   6344                  const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
   6345                                         _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
   6346                                         _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
   6347                                         _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
   6348                                         _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
   6349                                         _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
   6350                                         _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
   6351                                         _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
   6352                                         _4P_STEP;                                // .5r * 6 +  1c = 4
   6353                  bool zig_zag = true;
   6354                  F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
   6355                    const int8_t offset = _7p_9_centre ? 1 : 0;
   6356                    for (int8_t circle = -offset; circle <= offset; circle++) {
   6357                      const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6358                                  r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
   6359                                  interpol = fmod(axis, 1);
   6360                      const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
   6361                      if (isnan(z_temp)) return NAN;
   6362                      // split probe point to neighbouring calibration points
   6363                      z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
   6364                      z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
   6365                    }
   6366                    zig_zag = !zig_zag;
   6367                  }
   6368                  if (_7p_intermed_points)
   6369                    LOOP_CAL_RAD(axis)
   6370                      z_at_pt[axis] /= _7P_STEP / steps;
   6371                }
   6372          
   6373                float S1 = z_at_pt[CEN],
   6374                      S2 = sq(z_at_pt[CEN]);
   6375                int16_t N = 1;
   6376                if (!_1p_calibration) { // std dev from zero plane
   6377                  LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
   6378                    S1 += z_at_pt[axis];
   6379                    S2 += sq(z_at_pt[axis]);
   6380                    N++;
   6381                  }
   6382                  return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
   6383                }
   6384              }
   6385          
   6386              return 0.00001;
   6387            }
   6388          
   6389            #if HAS_BED_PROBE
   6390          
   6391              static bool G33_auto_tune() {
   6392                float z_at_pt[NPP + 1]      = { 0.0 },
   6393                      z_at_pt_base[NPP + 1] = { 0.0 },
   6394                      z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
   6395          
   6396                #define ZP(N,I) ((N) * z_at_pt[I])
   6397                #define Z06(I)  ZP(6, I)
   6398                #define Z03(I)  ZP(3, I)
   6399                #define Z02(I)  ZP(2, I)
   6400                #define Z01(I)  ZP(1, I)
   6401                #define Z32(I)  ZP(3/2, I)
   6402          
   6403                SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
   6404                SERIAL_EOL();
   6405                if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
   6406                print_G33_results(z_at_pt_base, true, true);
   6407          
   6408                LOOP_XYZ(axis) {
   6409                  delta_endstop_adj[axis] -= 1.0;
   6410                  recalc_delta_settings();
   6411          
   6412                  endstops.enable(true);
   6413                  if (!home_delta()) return false;
   6414                  endstops.not_homing();
   6415          
   6416                  SERIAL_PROTOCOLPGM("Tuning E");
   6417                  SERIAL_CHAR(tolower(axis_codes[axis]));
   6418                  SERIAL_EOL();
   6419          
   6420                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6421                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6422                  print_G33_results(z_at_pt, true, true);
   6423                  delta_endstop_adj[axis] += 1.0;
   6424                  recalc_delta_settings();
   6425                  switch (axis) {
   6426                    case A_AXIS :
   6427                      h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
   6428                      break;
   6429                    case B_AXIS :
   6430                      h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
   6431                      break;
   6432                    case C_AXIS :
   6433                      h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
   6434                      break;
   6435                  }
   6436                }
   6437                h_fac /= 3.0;
   6438                h_fac *= norm; // Normalize to 1.02 for Kossel mini
   6439          
   6440                for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
   6441                  delta_radius += 1.0 * zig_zag;
   6442                  recalc_delta_settings();
   6443          
   6444                  endstops.enable(true);
   6445                  if (!home_delta()) return false;
   6446                  endstops.not_homing();
   6447          
   6448                  SERIAL_PROTOCOLPGM("Tuning R");
   6449                  SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
   6450                  SERIAL_EOL();
   6451                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6452                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6453                  print_G33_results(z_at_pt, true, true);
   6454                  delta_radius -= 1.0 * zig_zag;
   6455                  recalc_delta_settings();
   6456                  r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
   6457                }
   6458                r_fac /= 2.0;
   6459                r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
   6460          
   6461                LOOP_XYZ(axis) {
   6462                  delta_tower_angle_trim[axis] += 1.0;
   6463                  delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
   6464                  delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
   6465                  z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6466                  delta_height -= z_temp;
   6467                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6468                  recalc_delta_settings();
   6469          
   6470                  endstops.enable(true);
   6471                  if (!home_delta()) return false;
   6472                  endstops.not_homing();
   6473          
   6474                  SERIAL_PROTOCOLPGM("Tuning T");
   6475                  SERIAL_CHAR(tolower(axis_codes[axis]));
   6476                  SERIAL_EOL();
   6477          
   6478                  if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
   6479                  LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
   6480                  print_G33_results(z_at_pt, true, true);
   6481          
   6482                  delta_tower_angle_trim[axis] -= 1.0;
   6483                  delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
   6484                  delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
   6485                  z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6486                  delta_height -= z_temp;
   6487                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6488                  recalc_delta_settings();
   6489                  switch (axis) {
   6490                    case A_AXIS :
   6491                      a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
   6492                      break;
   6493                    case B_AXIS :
   6494                      a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
   6495                      break;
   6496                    case C_AXIS :
   6497                      a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
   6498                      break;
   6499                  }
   6500                }
   6501                a_fac /= 3.0;
   6502                a_fac *= norm; // Normalize to 0.83 for Kossel mini
   6503          
   6504                endstops.enable(true);
   6505                if (!home_delta()) return false;
   6506                endstops.not_homing();
   6507                print_signed_float(PSTR( "H_FACTOR: "), h_fac);
   6508                print_signed_float(PSTR(" R_FACTOR: "), r_fac);
   6509                print_signed_float(PSTR(" A_FACTOR: "), a_fac);
   6510                SERIAL_EOL();
   6511                SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
   6512                SERIAL_EOL();
   6513                return true;
   6514              }
   6515          
   6516            #endif // HAS_BED_PROBE
   6517          
   6518            /**
   6519             * G33 - Delta '1-4-7-point' Auto-Calibration
   6520             *       Calibrate height, endstops, delta radius, and tower angles.
   6521             *
   6522             * Parameters:
   6523             *
   6524             *   Pn  Number of probe points:
   6525             *      P0     No probe. Normalize only.
   6526             *      P1     Probe center and set height only.
   6527             *      P2     Probe center and towers. Set height, endstops and delta radius.
   6528             *      P3     Probe all positions: center, towers and opposite towers. Set all.
   6529             *      P4-P10 Probe all positions + at different itermediate locations and average them.
   6530             *
   6531             *   T   Don't calibrate tower angle corrections
   6532             *
   6533             *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
   6534             *
   6535             *   Fn  Force to run at least n iterations and takes the best result
   6536             *
   6537             *   A   Auto tune calibartion factors (set in Configuration.h)
   6538             *
   6539             *   Vn  Verbose level:
   6540             *      V0  Dry-run mode. Report settings and probe results. No calibration.
   6541             *      V1  Report start and end settings only
   6542             *      V2  Report settings at each iteration
   6543             *      V3  Report settings and probe results
   6544             *
   6545             *   E   Engage the probe for each point
   6546             */
   6547            inline void gcode_G33() {
   6548          
   6549              const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
   6550              if (!WITHIN(probe_points, 0, 10)) {
   6551                SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
   6552                return;
   6553              }
   6554          
   6555              const int8_t verbose_level = parser.byteval('V', 1);
   6556              if (!WITHIN(verbose_level, 0, 3)) {
   6557                SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
   6558                return;
   6559              }
   6560          
   6561              const float calibration_precision = parser.floatval('C', 0.0);
   6562              if (calibration_precision < 0) {
   6563                SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
   6564                return;
   6565              }
   6566          
   6567              const int8_t force_iterations = parser.intval('F', 0);
   6568              if (!WITHIN(force_iterations, 0, 30)) {
   6569                SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
   6570                return;
   6571              }
   6572          
   6573              const bool towers_set           = !parser.boolval('T'),
   6574                         auto_tune            = parser.boolval('A'),
   6575                         stow_after_each      = parser.boolval('E'),
   6576                         _0p_calibration      = probe_points == 0,
   6577                         _1p_calibration      = probe_points == 1,
   6578                         _4p_calibration      = probe_points == 2,
   6579                         _7p_9_centre         = probe_points >= 8,
   6580                         _tower_results       = (_4p_calibration && towers_set)
   6581                                                || probe_points >= 3 || probe_points == 0,
   6582                         _opposite_results    = (_4p_calibration && !towers_set)
   6583                                                || probe_points >= 3 || probe_points == 0,
   6584                         _endstop_results     = probe_points != 1,
   6585                         _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
   6586              const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
   6587              int8_t iterations = 0;
   6588              float test_precision,
   6589                    zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
   6590                    zero_std_dev_min = zero_std_dev,
   6591                    e_old[ABC] = {
   6592                      delta_endstop_adj[A_AXIS],
   6593                      delta_endstop_adj[B_AXIS],
   6594                      delta_endstop_adj[C_AXIS]
   6595                    },
   6596                    dr_old = delta_radius,
   6597                    zh_old = delta_height,
   6598                    ta_old[ABC] = {
   6599                      delta_tower_angle_trim[A_AXIS],
   6600                      delta_tower_angle_trim[B_AXIS],
   6601                      delta_tower_angle_trim[C_AXIS]
   6602                    };
   6603          
   6604              SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
   6605          
   6606              if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
   6607                LOOP_CAL_RAD(axis) {
   6608                  const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
   6609                              r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
   6610                  if(MACHINETPYE & IS_KINEMATIC)
   6611                  {
   6612                  if (!position_is_reachable_IS_KINEMATIC(cos(a) * r, sin(a) * r)) {
   6613                    SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
   6614                    return;
   6615                  }
   6616                  else
   6617                  {
   6618                  if (!position_is_reachable_IS_CARTESIAN(cos(a) * r, sin(a) * r)) {
   6619                    SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
   6620                    return;        
   6621                  }
   6622                  }
   6623                }
   6624              }
   6625          
   6626              stepper.synchronize();
   6627              //#if HAS_LEVELING
   6628              if(BED_LEVELING_METHOD&HAS_LEVELING)
   6629                reset_bed_level(); // After calibration bed-level data is no longer valid
   6630              //#endif
   6631          
   6632              #if HOTENDS > 1
   6633                const uint8_t old_tool_index = active_extruder;
   6634                tool_change(0, 0, true);
   6635                #define G33_CLEANUP() G33_cleanup(old_tool_index)
   6636              #else
   6637                #define G33_CLEANUP() G33_cleanup()
   6638              #endif
   6639          
   6640              setup_for_endstop_or_probe_move();
   6641              endstops.enable(true);
   6642              if (!_0p_calibration) {
   6643                if (!home_delta())
   6644                  return;
   6645                endstops.not_homing();
   6646              }
   6647          
   6648              if (auto_tune) {
   6649                #if HAS_BED_PROBE
   6650                  G33_auto_tune();
   6651                #else
   6652                  SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
   6653                #endif
   6654                G33_CLEANUP();
   6655                return;
   6656              }
   6657          
   6658              // Report settings
   6659          
   6660              const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
   6661              serialprintPGM(checkingac);
   6662              if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
   6663              SERIAL_EOL();
   6664              lcd_setstatusPGM(checkingac);
   6665          
   6666              print_G33_settings(_endstop_results, _angle_results);
   6667          
   6668              do {
   6669          
   6670                float z_at_pt[NPP + 1] = { 0.0 };
   6671          
   6672                test_precision = zero_std_dev;
   6673          
   6674                iterations++;
   6675          
   6676                // Probe the points
   6677          
   6678                zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
   6679                if (isnan(zero_std_dev)) {
   6680                  SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
   6681                  SERIAL_EOL();
   6682                  return G33_CLEANUP();
   6683                }
   6684          
   6685                // Solve matrices
   6686          
   6687                if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
   6688                  if (zero_std_dev < zero_std_dev_min) {
   6689                    COPY(e_old, delta_endstop_adj);
   6690                    dr_old = delta_radius;
   6691                    zh_old = delta_height;
   6692                    COPY(ta_old, delta_tower_angle_trim);
   6693                  }
   6694          
   6695                  float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
   6696                  const float r_diff = delta_radius - delta_calibration_radius,
   6697                              h_factor = 1 / 6.0 *
   6698                                #ifdef H_FACTOR
   6699                                  (H_FACTOR),                                       // Set in Configuration.h
   6700                                #else
   6701                                  (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
   6702                                #endif
   6703                              r_factor = 1 / 6.0 *
   6704                                #ifdef R_FACTOR
   6705                                  -(R_FACTOR),                                      // Set in Configuration.h
   6706                                #else
   6707                                  -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
   6708                                #endif
   6709                              a_factor = 1 / 6.0 *
   6710                                #ifdef A_FACTOR
   6711                                  (A_FACTOR);                                       // Set in Configuration.h
   6712                                #else
   6713                                  (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
   6714                                #endif
   6715          
   6716                  #define ZP(N,I) ((N) * z_at_pt[I])
   6717                  #define Z6(I) ZP(6, I)
   6718                  #define Z4(I) ZP(4, I)
   6719                  #define Z2(I) ZP(2, I)
   6720                  #define Z1(I) ZP(1, I)
   6721          
   6722                  #if !HAS_BED_PROBE
   6723                    test_precision = 0.00; // forced end
   6724                  #endif
   6725          
   6726                  switch (probe_points) {
   6727                    case 0:
   6728                      test_precision = 0.00; // forced end
   6729                      break;
   6730          
   6731                    case 1:
   6732                      test_precision = 0.00; // forced end
   6733                      LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
   6734                      break;
   6735          
   6736                    case 2:
   6737                      if (towers_set) {
   6738                        e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
   6739                        e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
   6740                        e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
   6741                        r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
   6742                      }
   6743                      else {
   6744                        e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
   6745                        e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
   6746                        e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
   6747                        r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
   6748                      }
   6749                      break;
   6750          
   6751                    default:
   6752                      e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
   6753                      e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
   6754                      e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
   6755                      r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
   6756          
   6757                      if (towers_set) {
   6758                        t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
   6759                        t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
   6760                        t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
   6761                        e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
   6762                        e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
   6763                        e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
   6764                      }
   6765                      break;
   6766                  }
   6767          
   6768                  LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
   6769                  delta_radius += r_delta;
   6770                  LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
   6771                }
   6772                else if (zero_std_dev >= test_precision) {   // step one back
   6773                  COPY(delta_endstop_adj, e_old);
   6774                  delta_radius = dr_old;
   6775                  delta_height = zh_old;
   6776                  COPY(delta_tower_angle_trim, ta_old);
   6777                }
   6778          
   6779                if (verbose_level != 0) {                                    // !dry run
   6780                  // normalise angles to least squares
   6781                  if (_angle_results) {
   6782                    float a_sum = 0.0;
   6783                    LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
   6784                    LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
   6785                  }
   6786          
   6787                  // adjust delta_height and endstops by the max amount
   6788                  const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
   6789                  delta_height -= z_temp;
   6790                  LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
   6791                }
   6792                recalc_delta_settings();
   6793                NOMORE(zero_std_dev_min, zero_std_dev);
   6794          
   6795                // print report
   6796          
   6797                if (verbose_level > 2)
   6798                  print_G33_results(z_at_pt, _tower_results, _opposite_results);
   6799          
   6800                if (verbose_level != 0) {                                    // !dry run
   6801                  if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
   6802                    SERIAL_PROTOCOLPGM("Calibration OK");
   6803                    SERIAL_PROTOCOL_SP(32);
   6804                    #if HAS_BED_PROBE
   6805                      if (zero_std_dev >= test_precision && !_1p_calibration)
   6806                        SERIAL_PROTOCOLPGM("rolling back.");
   6807                      else
   6808                    #endif
   6809                      {
   6810                        SERIAL_PROTOCOLPGM("std dev:");
   6811                        SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
   6812                      }
   6813                    SERIAL_EOL();
   6814                    char mess[21];
   6815                    strcpy_P(mess, PSTR("Calibration sd:"));
   6816                    if (zero_std_dev_min < 1)
   6817                      sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
   6818                    else
   6819                      sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
   6820                    lcd_setstatus(mess);
   6821                    print_G33_settings(_endstop_results, _angle_results);
   6822                    serialprintPGM(save_message);
   6823                    SERIAL_EOL();
   6824                  }
   6825                  else {                                                     // !end iterations
   6826                    char mess[15];
   6827                    if (iterations < 31)
   6828                      sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
   6829                    else
   6830                      strcpy_P(mess, PSTR("No convergence"));
   6831                    SERIAL_PROTOCOL(mess);
   6832                    SERIAL_PROTOCOL_SP(32);
   6833                    SERIAL_PROTOCOLPGM("std dev:");
   6834                    SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6835                    SERIAL_EOL();
   6836                    lcd_setstatus(mess);
   6837                    if (verbose_level > 1)
   6838                      print_G33_settings(_endstop_results, _angle_results);
   6839                  }
   6840                }
   6841                else {                                                       // dry run
   6842                  const char *enddryrun = PSTR("End DRY-RUN");
   6843                  serialprintPGM(enddryrun);
   6844                  SERIAL_PROTOCOL_SP(35);
   6845                  SERIAL_PROTOCOLPGM("std dev:");
   6846                  SERIAL_PROTOCOL_F(zero_std_dev, 3);
   6847                  SERIAL_EOL();
   6848          
   6849                  char mess[21];
   6850                  strcpy_P(mess, enddryrun);
   6851                  strcpy_P(&mess[11], PSTR(" sd:"));
   6852                  if (zero_std_dev < 1)
   6853                    sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
   6854                  else
   6855                    sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
   6856                  lcd_setstatus(mess);
   6857                }
   6858          
   6859                endstops.enable(true);
   6860                if (!home_delta())
   6861                  return;
   6862                endstops.not_homing();
   6863          
   6864              }
   6865              while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
   6866          
   6867              G33_CLEANUP();
   6868            }
   6869          
   6870          #endif // DELTA_AUTO_CALIBRATION
   6871          
   6872          #if ENABLED(G38_PROBE_TARGET)
   6873          
   6874            static bool G38_run_probe() {
   6875          
   6876              bool G38_pass_fail = false;
   6877          
   6878              #if MULTIPLE_PROBING > 1
   6879                // Get direction of move and retract
   6880                float retract_mm[XYZ];
   6881                LOOP_XYZ(i) {
   6882                  float dist = destination[i] - current_position[i];
   6883                  retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
   6884                }
   6885              #endif
   6886          
   6887              stepper.synchronize();  // wait until the machine is idle
   6888          
   6889              // Move until destination reached or target hit
   6890              endstops.enable(true);
   6891              G38_move = true;
   6892              G38_endstop_hit = false;
   6893              prepare_move_to_destination();
   6894              stepper.synchronize();
   6895              G38_move = false;
   6896          
   6897              endstops.hit_on_purpose();
   6898              set_current_from_steppers_for_axis(ALL_AXES);
   6899              SYNC_PLAN_POSITION_KINEMATIC();
   6900          
   6901              if (G38_endstop_hit) {
   6902          
   6903                G38_pass_fail = true;
   6904          
   6905                #if MULTIPLE_PROBING > 1
   6906                  // Move away by the retract distance
   6907                  set_destination_from_current();
   6908                  LOOP_XYZ(i) destination[i] += retract_mm[i];
   6909                  endstops.enable(false);
   6910                  prepare_move_to_destination();
   6911                  stepper.synchronize();
   6912          
   6913                  feedrate_mm_s /= 4;
   6914          
   6915                  // Bump the target more slowly
   6916                  LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
   6917          
   6918                  endstops.enable(true);
   6919                  G38_move = true;
   6920                  prepare_move_to_destination();
   6921                  stepper.synchronize();
   6922                  G38_move = false;
   6923          
   6924                  set_current_from_steppers_for_axis(ALL_AXES);
   6925                  SYNC_PLAN_POSITION_KINEMATIC();
   6926                #endif
   6927              }
   6928          
   6929              endstops.hit_on_purpose();
   6930              endstops.not_homing();
   6931              return G38_pass_fail;
   6932            }
   6933          
   6934            /**
   6935             * G38.2 - probe toward workpiece, stop on contact, signal error if failure
   6936             * G38.3 - probe toward workpiece, stop on contact
   6937             *
   6938             * Like G28 except uses Z min probe for all axes
   6939             */
   6940            inline void gcode_G38(bool is_38_2) {
   6941              // Get X Y Z E F
   6942              gcode_get_destination();
   6943          
   6944              setup_for_endstop_or_probe_move();
   6945          
   6946              // If any axis has enough movement, do the move
   6947              LOOP_XYZ(i)
   6948                if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
   6949                  if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
   6950                  // If G38.2 fails throw an error
   6951                  if (!G38_run_probe() && is_38_2) {
   6952                    SERIAL_ERROR_START();
   6953                    SERIAL_ERRORLNPGM("Failed to reach target");
   6954                  }
   6955                  break;
   6956                }
   6957          
   6958              clean_up_after_endstop_or_probe_move();
   6959            }
   6960          
   6961          #endif // G38_PROBE_TARGET
   6962          
   6963          #if 1//HAS_MESH
   6964          
   6965            /**
   6966             * G42: Move X & Y axes to mesh coordinates (I & J)
   6967             */

   \                                 In section .text, align 4
   6968            inline void gcode_G42() {
   \                     _Z9gcode_G42v: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   6969              #if ENABLED(NO_MOTION_BEFORE_HOMING)
   6970                if (axis_unhomed_error()) return;
   6971              #endif
   6972          
   6973              if (IsRunning()) {
   \   00000004   0x.... 0x....      BL       _Z9IsRunningv
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xF000 0x80AF      BEQ.W    ??gcode_G42_0
   6974                const bool hasI = parser.seenval('I');
   \   0000000E   0x2049             MOVS     R0,#+73
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000014   0x0004             MOVS     R4,R0
   6975                const int8_t ix = hasI ? parser.value_int() : 0;
   \   00000016   0xD004             BEQ.N    ??gcode_G42_1
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001C   0x4605             MOV      R5,R0
   \   0000001E   0xB26D             SXTB     R5,R5
   \   00000020   0xE000             B.N      ??gcode_G42_2
   \                     ??gcode_G42_1: (+1)
   \   00000022   0x2500             MOVS     R5,#+0
   6976                const bool hasJ = parser.seenval('J');
   \                     ??gcode_G42_2: (+1)
   \   00000024   0x204A             MOVS     R0,#+74
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002A   0x0006             MOVS     R6,R0
   6977                const int8_t iy = hasJ ? parser.value_int() : 0;
   \   0000002C   0xD004             BEQ.N    ??gcode_G42_3
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000032   0x4607             MOV      R7,R0
   \   00000034   0xB27F             SXTB     R7,R7
   \   00000036   0xE000             B.N      ??gcode_G42_4
   \                     ??gcode_G42_3: (+1)
   \   00000038   0x2700             MOVS     R7,#+0
   6978          
   6979                if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
   \                     ??gcode_G42_4: (+1)
   \   0000003A   0xF8DF 0x8134      LDR.W    R8,??gcode_G42_5
   \   0000003E   0x2C00             CMP      R4,#+0
   \   00000040   0xD006             BEQ.N    ??gcode_G42_6
   \   00000042   0x2D00             CMP      R5,#+0
   \   00000044   0xD40E             BMI.N    ??gcode_G42_7
   \   00000046   0xF898 0x0060      LDRB     R0,[R8, #+96]
   \   0000004A   0x1E40             SUBS     R0,R0,#+1
   \   0000004C   0x42A8             CMP      R0,R5
   \   0000004E   0xDB09             BLT.N    ??gcode_G42_7
   \                     ??gcode_G42_6: (+1)
   \   00000050   0x2E00             CMP      R6,#+0
   \   00000052   0xD00C             BEQ.N    ??gcode_G42_8
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD405             BMI.N    ??gcode_G42_7
   \   00000058   0xF108 0x0060      ADD      R0,R8,#+96
   \   0000005C   0x7840             LDRB     R0,[R0, #+1]
   \   0000005E   0x1E40             SUBS     R0,R0,#+1
   \   00000060   0x42B8             CMP      R0,R7
   \   00000062   0xDA04             BGE.N    ??gcode_G42_8
   6980                  SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
   \                     ??gcode_G42_7: (+1)
   \   00000064   0x4843             LDR.N    R0,??gcode_G42_5+0x4
   \   00000066   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   6981                  return;
   6982                }
   6983          
   6984                set_destination_from_current();
   \                     ??gcode_G42_8: (+1)
   \   0000006E   0x.... 0x....      BL       _Z28set_destination_from_currentv
   6985                if (hasI) 
   \   00000072   0xF8DF 0x9104      LDR.W    R9,??gcode_G42_5+0x8
   \   00000076   0x2C00             CMP      R4,#+0
   \   00000078   0xD01F             BEQ.N    ??gcode_G42_9
   6986                {
   6987                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \   0000007A   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   0000007E   0x0700             LSLS     R0,R0,#+28
   \   00000080   0xD508             BPL.N    ??gcode_G42_10
   6988                      destination[X_AXIS] = _GET_MESH_X_ABL(ix);
   \   00000082   0x483E             LDR.N    R0,??gcode_G42_5+0xC
   \   00000084   0x6981             LDR      R1,[R0, #+24]
   \   00000086   0x6900             LDR      R0,[R0, #+16]
   \   00000088   0xFB00 0x1005      MLA      R0,R0,R5,R1
   \   0000008C   0x.... 0x....      BL       __aeabi_i2f
   \   00000090   0xF8C9 0x0018      STR      R0,[R9, #+24]
   6989                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??gcode_G42_10: (+1)
   \   00000094   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   00000098   0x06C0             LSLS     R0,R0,#+27
   \   0000009A   0xD505             BPL.N    ??gcode_G42_11
   6990                      destination[X_AXIS] = _GET_MESH_X_UBL(ix);
   \   0000009C   0x4628             MOV      R0,R5
   \   0000009E   0xB2C0             UXTB     R0,R0
   \   000000A0   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
   \   000000A4   0xF8C9 0x0018      STR      R0,[R9, #+24]
   6991                  if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??gcode_G42_11: (+1)
   \   000000A8   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000AC   0x0680             LSLS     R0,R0,#+26
   \   000000AE   0xD504             BPL.N    ??gcode_G42_9
   6992                      destination[X_AXIS] = _GET_MESH_X_MBL(ix);        
   \   000000B0   0x4833             LDR.N    R0,??gcode_G42_5+0x10
   \   000000B2   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   000000B6   0xF8C9 0x0018      STR      R0,[R9, #+24]
   6993                }
   6994                if (hasJ) 
   \                     ??gcode_G42_9: (+1)
   \   000000BA   0x2E00             CMP      R6,#+0
   \   000000BC   0xD01F             BEQ.N    ??gcode_G42_12
   6995                {
   6996                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \   000000BE   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000C2   0x0700             LSLS     R0,R0,#+28
   \   000000C4   0xD508             BPL.N    ??gcode_G42_13
   6997                      destination[Y_AXIS] = _GET_MESH_Y_ABL (iy);
   \   000000C6   0x482D             LDR.N    R0,??gcode_G42_5+0xC
   \   000000C8   0x69C1             LDR      R1,[R0, #+28]
   \   000000CA   0x6940             LDR      R0,[R0, #+20]
   \   000000CC   0xFB00 0x1007      MLA      R0,R0,R7,R1
   \   000000D0   0x.... 0x....      BL       __aeabi_i2f
   \   000000D4   0xF8C9 0x001C      STR      R0,[R9, #+28]
   6998                  if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??gcode_G42_13: (+1)
   \   000000D8   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000DC   0x06C0             LSLS     R0,R0,#+27
   \   000000DE   0xD505             BPL.N    ??gcode_G42_14
   6999                      destination[Y_AXIS] = _GET_MESH_Y_UBL(iy);
   \   000000E0   0x4638             MOV      R0,R7
   \   000000E2   0xB2C0             UXTB     R0,R0
   \   000000E4   0x.... 0x....      BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
   \   000000E8   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7000                  if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??gcode_G42_14: (+1)
   \   000000EC   0xF898 0x0040      LDRB     R0,[R8, #+64]
   \   000000F0   0x0680             LSLS     R0,R0,#+26
   \   000000F2   0xD504             BPL.N    ??gcode_G42_12
   7001                      destination[Y_AXIS] = _GET_MESH_Y_MBL(iy);        
   \   000000F4   0x4823             LDR.N    R0,??gcode_G42_5+0x14
   \   000000F6   0xF850 0x0027      LDR      R0,[R0, R7, LSL #+2]
   \   000000FA   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7002                }         
   7003                if (parser.boolval('P')) {
   \                     ??gcode_G42_12: (+1)
   \   000000FE   0x2050             MOVS     R0,#+80
   \   00000100   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000104   0x2800             CMP      R0,#+0
   \   00000106   0xD015             BEQ.N    ??gcode_G42_15
   7004                  if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
   \   00000108   0x2C00             CMP      R4,#+0
   \   0000010A   0xD008             BEQ.N    ??gcode_G42_16
   \   0000010C   0xF8D9 0x0018      LDR      R0,[R9, #+24]
   \   00000110   0xF108 0x0160      ADD      R1,R8,#+96
   \   00000114   0x68C9             LDR      R1,[R1, #+12]
   \   00000116   0x.... 0x....      BL       __aeabi_fsub
   \   0000011A   0xF8C9 0x0018      STR      R0,[R9, #+24]
   7005                  if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
   \                     ??gcode_G42_16: (+1)
   \   0000011E   0x2E00             CMP      R6,#+0
   \   00000120   0xD008             BEQ.N    ??gcode_G42_15
   \   00000122   0xF8D9 0x001C      LDR      R0,[R9, #+28]
   \   00000126   0xF108 0x0160      ADD      R1,R8,#+96
   \   0000012A   0x6909             LDR      R1,[R1, #+16]
   \   0000012C   0x.... 0x....      BL       __aeabi_fsub
   \   00000130   0xF8C9 0x001C      STR      R0,[R9, #+28]
   7006                }
   7007          
   7008                const float fval = parser.linearval('F');
   \                     ??gcode_G42_15: (+1)
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0x2046             MOVS     R0,#+70
   \   00000138   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   7009                if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
   \   0000013C   0x2100             MOVS     R1,#+0
   \   0000013E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000142   0xD204             BCS.N    ??gcode_G42_17
   \   00000144   0x4910             LDR.N    R1,??gcode_G42_5+0x18  ;; 0x42700000
   \   00000146   0x.... 0x....      BL       __aeabi_fdiv
   \   0000014A   0xF8C9 0x005C      STR      R0,[R9, #+92]
   7010          
   7011                // SCARA kinematic has "safe" XY raw moves
   7012                //#if IS_SCARA
   7013                if(MACHINETPYE & IS_SCARA)
   \                     ??gcode_G42_17: (+1)
   \   0000014E   0xF8B8 0x0058      LDRH     R0,[R8, #+88]
   \   00000152   0xF44F 0x7140      MOV      R1,#+768
   \   00000156   0x4208             TST      R0,R1
   \   00000158   0xD004             BEQ.N    ??gcode_G42_18
   7014                  prepare_uninterpolated_move_to_destination();
   \   0000015A   0x2000             MOVS     R0,#+0
   \   0000015C   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000160   0x.... 0x....      B.W      _Z42prepare_uninterpolated_move_to_destinationf
   7015                //#else
   7016                else
   7017                  prepare_move_to_destination();
   \                     ??gcode_G42_18: (+1)
   \   00000164   0xE8BD 0x43F1      POP      {R0,R4-R9,LR}
   \   00000168   0x.... 0x....      B.W      _Z27prepare_move_to_destinationv
   7018                //#endif
   7019              }
   7020            }
   \                     ??gcode_G42_0: (+1)
   \   0000016C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??gcode_G42_5:
   \   00000170   0x........         DC32     mksCfg
   \   00000174   0x........         DC32     _ZZ9gcode_G42vEs
   \   00000178   0x........         DC32     mks_heating_busy
   \   0000017C   0x........         DC32     axis_relative_modes
   \   00000180   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE
   \   00000184   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE
   \   00000188   0x42700000         DC32     0x42700000
   7021          
   7022          #endif // HAS_MESH
   7023          #if 0
   7024          /**
   7025           * G92: Set current position to given X Y Z E
   7026           */
   7027          inline void gcode_G92() {
   7028          
   7029            stepper.synchronize();
   7030          
   7031            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   7032              switch (parser.subcode) {
   7033                case 1:
   7034                  // Zero the G92 values and restore current position
   7035                  #if !IS_SCARA
   7036                    LOOP_XYZ(i) {
   7037                      const float v = position_shift[i];
   7038                      if (v) {
   7039                        position_shift[i] = 0;
   7040                        update_software_endstops((AxisEnum)i);
   7041                      }
   7042                    }
   7043                  #endif // Not SCARA
   7044                  return;
   7045              }
   7046            #endif
   7047          
   7048            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   7049              #define IS_G92_0 (parser.subcode == 0)
   7050            #else
   7051              #define IS_G92_0 true
   7052            #endif
   7053          
   7054            bool didE = false;
   7055            bool didXYZ = false;
   7056            //#if IS_SCARA || !HAS_POSITION_SHIFT
   7057            if(MACHINETPYE&IS_SCARA) {
   7058              //bool 
   7059              didXYZ = false;
   7060            }
   7061            //#else
   7062            else
   7063            {
   7064            	#if !HAS_POSITION_SHIFT
   7065          		//bool 
   7066          		didXYZ = false;	
   7067            	#else
   7068          		//constexpr bool 
   7069          		didXYZ = false;
   7070          	#endif
   7071            }
   7072            //#endif
   7073          
   7074            if (IS_G92_0) LOOP_XYZE(i) {
   7075              if (parser.seenval(axis_codes[i])) {
   7076                const float l = parser.value_axis_units((AxisEnum)i),
   7077                            v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
   7078                            d = v - current_position[i];
   7079                if (!NEAR_ZERO(d)) {
   7080                  //#if IS_SCARA || !HAS_POSITION_SHIFT
   7081                  if(MACHINETPYE&IS_SCARA) {
   7082                    if (i == E_AXIS) didE = true; else didXYZ = true;
   7083                    current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
   7084                  }
   7085          		else
   7086          		{
   7087          			#if HAS_POSITION_SHIFT
   7088          	          if (i == E_AXIS) {
   7089          	            didE = true;
   7090          	            current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
   7091          	          }
   7092          	          else {
   7093          	            position_shift[i] += d;       // Other axes simply offset the coordinate space
   7094          	            update_software_endstops((AxisEnum)i);
   7095          	          }
   7096          			
   7097                  	#endif
   7098          		}
   7099                }
   7100              }
   7101            }
   7102          
   7103            #if ENABLED(CNC_COORDINATE_SYSTEMS)
   7104              // Apply workspace offset to the active coordinate system
   7105              if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
   7106                COPY(coordinate_system[active_coordinate_system], position_shift);
   7107            #endif
   7108          
   7109            if (didXYZ)
   7110              SYNC_PLAN_POSITION_KINEMATIC();
   7111            else if (didE)
   7112              sync_plan_position_e();
   7113          
   7114            report_current_position();
   7115          }
   7116          #else
   7117          
   7118          /**
   7119           * G92: Set current position to given X Y Z E
   7120           */

   \                                 In section .text, align 4
   7121          inline void gcode_G92() {
   \                     _Z9gcode_G92v: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   7122            bool didXYZ = false,
   \   00000004   0x2500             MOVS     R5,#+0
   7123                 didE = parser.seen('E');
   \   00000006   0x2045             MOVS     R0,#+69
   \   00000008   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000C   0x0004             MOVS     R4,R0
   7124          
   7125            if (!didE) stepper.synchronize();
   \   0000000E   0xD101             BNE.N    ??gcode_G92_0
   \   00000010   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   7126          
   7127            LOOP_XYZE(i) {
   \                     ??gcode_G92_0: (+1)
   \   00000014   0x462E             MOV      R6,R5
   \   00000016   0xE015             B.N      ??gcode_G92_1
   7128              if (parser.seenval(axis_codes[i])) {
   7129                //#if IS_SCARA
   7130                if(MACHINETPYE&IS_SCARA)
   7131                {
   7132                  current_position[i] = parser.value_axis_units((AxisEnum)i);
   7133                  if (i != E_AXIS) didXYZ = true;
   7134                }
   7135                //#else
   7136                else
   7137                {
   7138                  #if HAS_POSITION_SHIFT
   7139                    const float p = current_position[i];
   \                     ??gcode_G92_2: (+1)
   \   00000018   0xF8D7 0x8008      LDR      R8,[R7, #+8]
   7140                  #endif
   7141                  float v = parser.value_axis_units((AxisEnum)i);
   \   0000001C   0x4630             MOV      R0,R6
   \   0000001E   0xB240             SXTB     R0,R0
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   7142          
   7143                  current_position[i] = v;
   \   00000024   0x60B8             STR      R0,[R7, #+8]
   7144          
   7145                  if (i != E_AXIS) {
   \   00000026   0x2E03             CMP      R6,#+3
   \   00000028   0xD00B             BEQ.N    ??gcode_G92_3
   7146                    didXYZ = true;
   \   0000002A   0x2501             MOVS     R5,#+1
   7147                    #if HAS_POSITION_SHIFT
   7148                      position_shift[i] += v - p; // Offset the coordinate space
   \   0000002C   0x4641             MOV      R1,R8
   \   0000002E   0x.... 0x....      BL       __aeabi_fsub
   \   00000032   0x6E39             LDR      R1,[R7, #+96]
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x6638             STR      R0,[R7, #+96]
   7149                      update_software_endstops((AxisEnum)i);
   \   0000003A   0x4630             MOV      R0,R6
   \   0000003C   0xB240             SXTB     R0,R0
   \   0000003E   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
   7150                    #endif
   7151                  }
   7152                }
   \                     ??gcode_G92_3: (+1)
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \                     ??gcode_G92_1: (+1)
   \   00000044   0x2E04             CMP      R6,#+4
   \   00000046   0xDA18             BGE.N    ??gcode_G92_4
   \   00000048   0x4812             LDR.N    R0,??gcode_G92_5
   \   0000004A   0x5630             LDRSB    R0,[R6, R0]
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD0F6             BEQ.N    ??gcode_G92_3
   \   00000054   0x4810             LDR.N    R0,??gcode_G92_5+0x4
   \   00000056   0xEB00 0x0786      ADD      R7,R0,R6, LSL #+2
   \   0000005A   0x4810             LDR.N    R0,??gcode_G92_5+0x8
   \   0000005C   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000060   0xF44F 0x7140      MOV      R1,#+768
   \   00000064   0x4208             TST      R0,R1
   \   00000066   0xD0D7             BEQ.N    ??gcode_G92_2
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0xB240             SXTB     R0,R0
   \   0000006C   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   00000070   0x60B8             STR      R0,[R7, #+8]
   \   00000072   0x2E03             CMP      R6,#+3
   \   00000074   0xD0E5             BEQ.N    ??gcode_G92_3
   \   00000076   0x2501             MOVS     R5,#+1
   \   00000078   0xE7E3             B.N      ??gcode_G92_3
   7153                //#endif
   7154              }
   7155            }
   7156            if (didXYZ)
   \                     ??gcode_G92_4: (+1)
   \   0000007A   0x2D00             CMP      R5,#+0
   \   0000007C   0xD002             BEQ.N    ??gcode_G92_6
   7157              SYNC_PLAN_POSITION_KINEMATIC();
   \   0000007E   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
   \   00000082   0xE003             B.N      ??gcode_G92_7
   7158            else if (didE)
   \                     ??gcode_G92_6: (+1)
   \   00000084   0x2C00             CMP      R4,#+0
   \   00000086   0xD001             BEQ.N    ??gcode_G92_7
   7159              sync_plan_position_e();
   \   00000088   0x.... 0x....      BL       _Z20sync_plan_position_ev
   7160          
   7161            report_current_position();
   \                     ??gcode_G92_7: (+1)
   \   0000008C   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   00000090   0x.... 0x....      B.W      _Z23report_current_positionv
   \                     ??gcode_G92_5:
   \   00000094   0x........         DC32     axis_codes
   \   00000098   0x........         DC32     mks_heating_busy
   \   0000009C   0x........         DC32     mksCfg
   7162          }
   7163          
   7164          #endif
   7165          #if HAS_RESUME_CONTINUE
   7166          
   7167            /**
   7168             * M0: Unconditional stop - Wait for user button press on LCD
   7169             * M1: Conditional stop   - Wait for user button press on LCD
   7170             */
   7171            inline void gcode_M0_M1() {
   7172              const char * const args = parser.string_arg;
   7173          
   7174              millis_t ms = 0;
   7175              bool hasP = false, hasS = false;
   7176              if (parser.seenval('P')) {
   7177                ms = parser.value_millis(); // milliseconds to wait
   7178                hasP = ms > 0;
   7179              }
   7180              if (parser.seenval('S')) {
   7181                ms = parser.value_millis_from_seconds(); // seconds to wait
   7182                hasS = ms > 0;
   7183              }
   7184          
   7185              #if ENABLED(ULTIPANEL)
   7186          
   7187                if (!hasP && !hasS && args && *args)
   7188                  lcd_setstatus(args, true);
   7189                else {
   7190                  LCD_MESSAGEPGM(MSG_USERWAIT);
   7191                  #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   7192                    dontExpireStatus();
   7193                  #endif
   7194                }
   7195          
   7196              #else
   7197          
   7198                if (!hasP && !hasS && args && *args) {
   7199                  SERIAL_ECHO_START();
   7200                  SERIAL_ECHOLN(args);
   7201                }
   7202          
   7203              #endif
   7204          
   7205              KEEPALIVE_STATE(PAUSED_FOR_USER);
   7206              wait_for_user = true;
   7207          
   7208              stepper.synchronize();
   7209              refresh_cmd_timeout();
   7210          
   7211              if (ms > 0) {
   7212                ms += previous_cmd_ms;  // wait until this time for a click
   7213                while (PENDING(millis(), ms) && wait_for_user) idle();
   7214              }
   7215              else {
   7216                #if ENABLED(ULTIPANEL)
   7217                  if (lcd_detected()) {
   7218                    while (wait_for_user) idle();
   7219                    print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
   7220                  }
   7221                #else
   7222                  while (wait_for_user) idle();
   7223                #endif
   7224              }
   7225          
   7226              wait_for_user = false;
   7227              KEEPALIVE_STATE(IN_HANDLER);
   7228            }
   7229          
   7230          #endif // HAS_RESUME_CONTINUE
   7231          
   7232          #if ENABLED(SPINDLE_LASER_ENABLE)
   7233            /**
   7234             * M3: Spindle Clockwise
   7235             * M4: Spindle Counter-clockwise
   7236             *
   7237             *  S0 turns off spindle.
   7238             *
   7239             *  If no speed PWM output is defined then M3/M4 just turns it on.
   7240             *
   7241             *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
   7242             *  Hardware PWM is required. ISRs are too slow.
   7243             *
   7244             * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
   7245             *       No other settings give a PWM signal that goes from 0 to 5 volts.
   7246             *
   7247             *       The system automatically sets WGM to Mode 1, so no special
   7248             *       initialization is needed.
   7249             *
   7250             *       WGM bits for timer 2 are automatically set by the system to
   7251             *       Mode 1. This produces an acceptable 0 to 5 volt signal.
   7252             *       No special initialization is needed.
   7253             *
   7254             * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
   7255             *       factors for timers 2, 3, 4, and 5 are acceptable.
   7256             *
   7257             *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
   7258             *  the spindle/laser during power-up or when connecting to the host
   7259             *  (usually goes through a reset which sets all I/O pins to tri-state)
   7260             *
   7261             *  PWM duty cycle goes from 0 (off) to 255 (always on).
   7262             */
   7263          
   7264            // Wait for spindle to come up to speed
   7265            inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
   7266          
   7267            // Wait for spindle to stop turning
   7268            inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
   7269          
   7270            /**
   7271             * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
   7272             *
   7273             * it accepts inputs of 0-255
   7274             */
   7275          
   7276            inline void ocr_val_mode() {
   7277              uint8_t spindle_laser_power = parser.value_byte();
   7278              WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
   7279              if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
   7280              analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
   7281            }
   7282          
   7283            inline void gcode_M3_M4(bool is_M3) {
   7284          
   7285              stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
   7286              #if SPINDLE_DIR_CHANGE
   7287                const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
   7288                if (SPINDLE_STOP_ON_DIR_CHANGE \
   7289                   && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
   7290                   && READ(SPINDLE_DIR_PIN) != rotation_dir
   7291                ) {
   7292                  WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
   7293                  delay_for_power_down();
   7294                }
   7295                WRITE(SPINDLE_DIR_PIN, rotation_dir);
   7296              #endif
   7297          
   7298              /**
   7299               * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
   7300               * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
   7301               * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
   7302               */
   7303              #if ENABLED(SPINDLE_LASER_PWM)
   7304                if (parser.seen('O')) ocr_val_mode();
   7305                else {
   7306                  const float spindle_laser_power = parser.floatval('S');
   7307                  if (spindle_laser_power == 0) {
   7308                    WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
   7309                    analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
   7310                    delay_for_power_down();
   7311                  }
   7312                  else {
   7313                    int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
   7314                    NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
   7315                    if (spindle_laser_power <= SPEED_POWER_MIN)
   7316                      ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
   7317                    if (spindle_laser_power >= SPEED_POWER_MAX)
   7318                      ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
   7319                    if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
   7320                    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
   7321                    analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
   7322                    delay_for_power_up();
   7323                  }
   7324                }
   7325              #else
   7326                WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
   7327                delay_for_power_up();
   7328              #endif
   7329            }
   7330          
   7331           /**
   7332            * M5 turn off spindle
   7333            */
   7334            inline void gcode_M5() {
   7335              stepper.synchronize();
   7336              WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
   7337              delay_for_power_down();
   7338            }
   7339          
   7340          #endif // SPINDLE_LASER_ENABLE
   7341          
   7342          /**
   7343           * M17: Enable power on all stepper motors
   7344           */

   \                                 In section .text, align 4
   7345          inline void gcode_M17() {
   \                     _Z9gcode_M17v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   7346            LCD_MESSAGEPGM(MSG_NO_MOVE);
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x4803             LDR.N    R0,??gcode_M17_0
   \   00000006   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   7347            enable_all_steppers();
   \   0000000A   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000E   0x.... 0x....      B.W      _Z19enable_all_steppersv
   \   00000012   0xBF00             Nop      
   \                     ??gcode_M17_0:
   \   00000014   0x........         DC32     _ZZ9gcode_M17vEs
   7348          }
   7349          
   7350          #if ENABLED(ADVANCED_PAUSE_FEATURE)
   7351          
   7352            static float resume_position[XYZE];
   7353            static bool move_away_flag = false;
   7354            #if ENABLED(SDSUPPORT)
   7355              static bool sd_print_paused = false;
   7356            #endif
   7357          
   7358            static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
   7359              static millis_t next_buzz = 0;
   7360              static int8_t runout_beep = 0;
   7361          
   7362              if (init) next_buzz = runout_beep = 0;
   7363          
   7364              const millis_t ms = millis();
   7365              if (ELAPSED(ms, next_buzz)) {
   7366                if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
   7367                  next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
   7368                  BUZZ(300, 2000);
   7369                  runout_beep++;
   7370                }
   7371              }
   7372            }
   7373          
   7374            static void ensure_safe_temperature() {
   7375              bool heaters_heating = true;
   7376          
   7377              wait_for_heatup = true;    // M108 will clear this
   7378              while (wait_for_heatup && heaters_heating) {
   7379                idle();
   7380                heaters_heating = false;
   7381                HOTEND_LOOP() {
   7382                  if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
   7383                    heaters_heating = true;
   7384                    #if ENABLED(ULTIPANEL)
   7385                      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
   7386                    #endif
   7387                    break;
   7388                  }
   7389                }
   7390              }
   7391            }
   7392          
   7393            #if IS_KINEMATIC
   7394              #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
   7395            #else
   7396              #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
   7397            #endif
   7398          
   7399            void do_pause_e_move(const float &length, const float fr) {
   7400              current_position[E_AXIS] += length / planner.e_factor[active_extruder];
   7401              set_destination_from_current();
   7402              RUNPLAN(fr);
   7403              stepper.synchronize();
   7404            }
   7405          
   7406            static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
   7407                                    const int8_t max_beep_count = 0, const bool show_lcd = false
   7408            ) {
   7409              if (move_away_flag) return false; // already paused
   7410          
   7411              #ifdef ACTION_ON_PAUSE
   7412                SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
   7413              #endif
   7414          
   7415              if (!DEBUGGING(DRYRUN) && unload_length != 0) {
   7416                #if ENABLED(PREVENT_COLD_EXTRUSION)
   7417                  if (!thermalManager.allow_cold_extrude &&
   7418                      thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
   7419                    SERIAL_ERROR_START();
   7420                    SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
   7421                    return false;
   7422                  }
   7423                #endif
   7424          
   7425                ensure_safe_temperature(); // wait for extruder to heat up before unloading
   7426              }
   7427          
   7428              // Indicate that the printer is paused
   7429              move_away_flag = true;
   7430          
   7431              // Pause the print job and timer
   7432              #if ENABLED(SDSUPPORT)
   7433                if (card.sdprinting) {
   7434                  card.pauseSDPrint();
   7435                  sd_print_paused = true;
   7436                }
   7437              #endif
   7438              print_job_timer.pause();
   7439          
   7440              // Show initial message and wait for synchronize steppers
   7441              if (show_lcd) {
   7442                #if ENABLED(ULTIPANEL)
   7443                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
   7444                #endif
   7445              }
   7446          
   7447              // Save current position
   7448              stepper.synchronize();
   7449              COPY(resume_position, current_position);
   7450          
   7451              // Initial retract before move to filament change position
   7452              if (retract && !thermalManager.tooColdToExtrude(active_extruder))
   7453                do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
   7454          
   7455              // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
   7456              Nozzle::park(2, park_point);
   7457          
   7458              if (unload_length != 0) {
   7459                if (show_lcd) {
   7460                  #if ENABLED(ULTIPANEL)
   7461                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
   7462                    idle();
   7463                  #endif
   7464                }
   7465          
   7466                // Unload filament
   7467                do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
   7468              }
   7469          
   7470              if (show_lcd) {
   7471                #if ENABLED(ULTIPANEL)
   7472                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7473                #endif
   7474              }
   7475          
   7476              #if HAS_BUZZER
   7477                filament_change_beep(max_beep_count, true);
   7478              #endif
   7479          
   7480              idle();
   7481          
   7482              // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
   7483              #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
   7484                disable_e_steppers();
   7485                safe_delay(100);
   7486              #endif
   7487          
   7488              // Start the heater idle timers
   7489              const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
   7490          
   7491              HOTEND_LOOP()
   7492                thermalManager.start_heater_idle_timer(e, nozzle_timeout);
   7493          
   7494              return true;
   7495            }
   7496          
   7497            static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
   7498              bool nozzle_timed_out = false;
   7499          
   7500              // Wait for filament insert by user and press button
   7501              KEEPALIVE_STATE(PAUSED_FOR_USER);
   7502              wait_for_user = true;    // LCD click or M108 will clear this
   7503              while (wait_for_user) {
   7504                #if HAS_BUZZER
   7505                  filament_change_beep(max_beep_count);
   7506                #endif
   7507          
   7508                // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
   7509                // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
   7510                if (!nozzle_timed_out)
   7511                  HOTEND_LOOP()
   7512                    nozzle_timed_out |= thermalManager.is_heater_idle(e);
   7513          
   7514                if (nozzle_timed_out) {
   7515                  #if ENABLED(ULTIPANEL)
   7516                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
   7517                  #endif
   7518          
   7519                  // Wait for LCD click or M108
   7520                  while (wait_for_user) idle(true);
   7521          
   7522                  // Re-enable the heaters if they timed out
   7523                  HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
   7524          
   7525                  // Wait for the heaters to reach the target temperatures
   7526                  ensure_safe_temperature();
   7527          
   7528                  #if ENABLED(ULTIPANEL)
   7529                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7530                  #endif
   7531          
   7532                  // Start the heater idle timers
   7533                  const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
   7534          
   7535                  HOTEND_LOOP()
   7536                    thermalManager.start_heater_idle_timer(e, nozzle_timeout);
   7537          
   7538                  wait_for_user = true; /* Wait for user to load filament */
   7539                  nozzle_timed_out = false;
   7540          
   7541                  #if HAS_BUZZER
   7542                    filament_change_beep(max_beep_count, true);
   7543                  #endif
   7544                }
   7545          
   7546                idle(true);
   7547              }
   7548              KEEPALIVE_STATE(IN_HANDLER);
   7549            }
   7550          
   7551            static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
   7552              bool nozzle_timed_out = false;
   7553          
   7554              if (!move_away_flag) return;
   7555          
   7556              // Re-enable the heaters if they timed out
   7557              HOTEND_LOOP() {
   7558                nozzle_timed_out |= thermalManager.is_heater_idle(e);
   7559                thermalManager.reset_heater_idle_timer(e);
   7560              }
   7561          
   7562              if (nozzle_timed_out) ensure_safe_temperature();
   7563          
   7564              #if HAS_BUZZER
   7565                filament_change_beep(max_beep_count, true);
   7566              #endif
   7567          
   7568              set_destination_from_current();
   7569          
   7570              if (load_length != 0) {
   7571                #if ENABLED(ULTIPANEL)
   7572                  // Show "insert filament"
   7573                  if (nozzle_timed_out)
   7574                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
   7575                #endif
   7576          
   7577                KEEPALIVE_STATE(PAUSED_FOR_USER);
   7578                wait_for_user = true;    // LCD click or M108 will clear this
   7579                while (wait_for_user && nozzle_timed_out) {
   7580                  #if HAS_BUZZER
   7581                    filament_change_beep(max_beep_count);
   7582                  #endif
   7583                  idle(true);
   7584                }
   7585                KEEPALIVE_STATE(IN_HANDLER);
   7586          
   7587                #if ENABLED(ULTIPANEL)
   7588                  // Show "load" message
   7589                  lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
   7590                #endif
   7591          
   7592                // Load filament
   7593                do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
   7594              }
   7595          
   7596              #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
   7597          
   7598                if (!thermalManager.tooColdToExtrude(active_extruder)) {
   7599                  float extrude_length = initial_extrude_length;
   7600          
   7601                  do {
   7602                    if (extrude_length > 0) {
   7603                      // "Wait for filament extrude"
   7604                      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
   7605          
   7606                      // Extrude filament to get into hotend
   7607                      do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
   7608                    }
   7609          
   7610                    // Show "Extrude More" / "Resume" menu and wait for reply
   7611                    KEEPALIVE_STATE(PAUSED_FOR_USER);
   7612                    wait_for_user = false;
   7613                    lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
   7614                    while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
   7615                    KEEPALIVE_STATE(IN_HANDLER);
   7616          
   7617                    extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
   7618          
   7619                    // Keep looping if "Extrude More" was selected
   7620                  } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
   7621                }
   7622          
   7623              #endif
   7624          
   7625              #if ENABLED(ULTIPANEL)
   7626                // "Wait for print to resume"
   7627                lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
   7628              #endif
   7629          
   7630              // Set extruder to saved position
   7631              destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
   7632              planner.set_e_position_mm(current_position[E_AXIS]);
   7633          
   7634              // Move XY to starting position, then Z
   7635              do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
   7636              do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
   7637          
   7638              #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   7639                filament_ran_out = false;
   7640              #endif
   7641          
   7642              #if ENABLED(ULTIPANEL)
   7643                // Show status screen
   7644                lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
   7645              #endif
   7646          
   7647              #ifdef ACTION_ON_RESUME
   7648                SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
   7649              #endif
   7650          
   7651              #if ENABLED(SDSUPPORT)
   7652                if (sd_print_paused) {
   7653                  card.startFileprint();
   7654                  sd_print_paused = false;
   7655                }
   7656              #endif
   7657          
   7658              move_away_flag = false;
   7659            }
   7660          #endif // ADVANCED_PAUSE_FEATURE
   7661          
   7662          #if ENABLED(SDSUPPORT)
   7663          
   7664            /**
   7665             * M20: List SD card to serial output
   7666             */

   \                                 In section .text, align 4
   7667            inline void gcode_M20() {
   \                     _Z9gcode_M20v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   7668              SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
   \   00000002   0x4805             LDR.N    R0,??gcode_M20_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7669              card.ls();
   \   00000008   0x4804             LDR.N    R0,??gcode_M20_0+0x4
   \   0000000A   0x.... 0x....      BL       _ZN10CardReader2lsEv
   7670              SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
   \   0000000E   0x4804             LDR.N    R0,??gcode_M20_0+0x8
   \   00000010   0xE8BD 0x4002      POP      {R1,LR}
   \   00000014   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \                     ??gcode_M20_0:
   \   00000018   0x........         DC32     _ZZ9gcode_M20vEs
   \   0000001C   0x........         DC32     card
   \   00000020   0x........         DC32     _ZZ9gcode_M20vEs_0
   7671            }
   7672          
   7673            /**
   7674             * M21: Init SD Card
   7675             */
   7676            inline void gcode_M21() { card.initsd(); }
   7677          
   7678            /**
   7679             * M22: Release SD Card
   7680             */

   \                                 In section .text, align 4
   7681            inline void gcode_M22() { card.release(); }
   \                     _Z9gcode_M22v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M22_0
   \   00000002   0x.... 0x....      B.W      _ZN10CardReader7releaseEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M22_0:
   \   00000008   0x........         DC32     card
   7682          
   7683            /**
   7684             * M23: Open a file
   7685             */
   7686             #ifdef USE_MKS_WIFI    
   7687            inline void gcode_M23() { 
   7688            	if(card.openFile(parser.command_ptr, true) < 0)
   7689            	{
   7690            		/*for 8.3 principle*/
   7691          		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
   7692          		if(!gSuffix)
   7693          		{
   7694          			gSuffix = strstr((char *)parser.command_ptr, ".G");		
   7695          		}
   7696          		if(gSuffix)
   7697          		{
   7698          			*(gSuffix + 2) = '\0';
   7699          			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
   7700          			{
   7701          				parser.command_ptr[7] = '~';
   7702          				parser.command_ptr[8] = '.';
   7703          				parser.command_ptr[9] = 'g';
   7704          				parser.command_ptr[10] = '\0';
   7705          			}
   7706          			card.openFile(parser.command_ptr, true) ;
   7707          		}
   7708            	}
   7709            }
   7710          #else

   \                                 In section .text, align 4
   7711            inline void gcode_M23() {
   \                     _Z9gcode_M23v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7712              // Simplify3D includes the size, so zero out all spaces (#7227)
   7713              for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
   \   00000002   0x480D             LDR.N    R0,??gcode_M23_0
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0xE004             B.N      ??gcode_M23_1
   \                     ??gcode_M23_2: (+1)
   \   00000008   0x2A20             CMP      R2,#+32
   \   0000000A   0xD101             BNE.N    ??gcode_M23_3
   \   0000000C   0x2200             MOVS     R2,#+0
   \   0000000E   0x700A             STRB     R2,[R1, #+0]
   \                     ??gcode_M23_3: (+1)
   \   00000010   0x1C49             ADDS     R1,R1,#+1
   \                     ??gcode_M23_1: (+1)
   \   00000012   0xF991 0x2000      LDRSB    R2,[R1, #+0]
   \   00000016   0x2A00             CMP      R2,#+0
   \   00000018   0xD1F6             BNE.N    ??gcode_M23_2
   7714              card.openFile(parser.string_arg, true);
   \   0000001A   0x4C08             LDR.N    R4,??gcode_M23_0+0x4
   \   0000001C   0x2301             MOVS     R3,#+1
   \   0000001E   0x461A             MOV      R2,R3
   \   00000020   0x6801             LDR      R1,[R0, #+0]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   7715              strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
   \   00000028   0xF604 0x11D4      ADDW     R1,R4,#+2516
   \   0000002C   0x4804             LDR.N    R0,??gcode_M23_0+0x8
   \   0000002E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000032   0x.... 0x....      B.W      strcpy
   \   00000036   0xBF00             Nop      
   \                     ??gcode_M23_0:
   \   00000038   0x........         DC32     _ZN11GCodeParser10string_argE
   \   0000003C   0x........         DC32     card
   \   00000040   0x........         DC32     curFileName
   7716            }
   7717          #endif
   7718            /**
   7719             * M24: Start or Resume SD Print
   7720             */

   \                                 In section .text, align 4
   7721            inline void gcode_M24() {
   \                     _Z9gcode_M24v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7722            	mks_resumePrint();
   \   00000002   0x.... 0x....      BL       mks_resumePrint
   7723            
   7724              #if ENABLED(PARK_HEAD_ON_PAUSE)
   7725                resume_print();
   7726              #endif
   7727          	
   7728          	#ifdef USE_MKS_WIFI
   7729          	if(card.lastOpenOk())
   7730          	#endif	
   7731          		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
   \   00000006   0x4C08             LDR.N    R4,??gcode_M24_0
   \   00000008   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000000C   0x28AB             CMP      R0,#+171
   \   0000000E   0xD00A             BEQ.N    ??gcode_M24_1
   \   00000010   0x28AC             CMP      R0,#+172
   \   00000012   0xD008             BEQ.N    ??gcode_M24_1
   7732          		{
   7733          
   7734          	    	card.startFileprint();
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   7735          	    	print_job_timer.start();
   \   0000001A   0xF604 0x506C      ADDW     R0,R4,#+3436
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   7736          		}
   7737            }
   \                     ??gcode_M24_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M24_0:
   \   00000028   0x........         DC32     card
   7738          
   7739            /**
   7740             * M25: Pause SD Print
   7741             */

   \                                 In section .text, align 4
   7742            inline void gcode_M25() {
   \                     _Z9gcode_M25v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7743              card.pauseSDPrint();
   \   00000002   0x4C06             LDR.N    R4,??gcode_M25_0
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
   7744              print_job_timer.pause();
   \   0000000A   0xF604 0x506C      ADDW     R0,R4,#+3436
   \   0000000E   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
   7745          
   7746              #if ENABLED(PARK_HEAD_ON_PAUSE)
   7747                enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
   7748              #endif
   7749          	
   7750          	mksReprint.mks_printer_state = MKS_PAUSING;
   \   00000012   0x20A9             MOVS     R0,#+169
   \   00000014   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   7751            }
   \   00000018   0xBD10             POP      {R4,PC}          ;; return
   \   0000001A   0xBF00             Nop      
   \                     ??gcode_M25_0:
   \   0000001C   0x........         DC32     card
   7752          /**
   7753          	 * M998: Stop SD Print
   7754          */

   \                                 In section .text, align 4
   7755          	inline void gcode_M998() {
   \                     _Z10gcode_M998v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7756          		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
   \   00000002   0x4C17             LDR.N    R4,??gcode_M998_0
   \   00000004   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000008   0x28AC             CMP      R0,#+172
   \   0000000A   0xD027             BEQ.N    ??gcode_M998_1
   7757          		return;
   7758          			
   7759          		mksReprint.mks_printer_state = MKS_IDLE;
   \   0000000C   0x20A6             MOVS     R0,#+166
   \   0000000E   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   7760                  if(gCfgItems.pwroff_save_mode != 1)
   \   00000012   0x4814             LDR.N    R0,??gcode_M998_0+0x4
   \   00000014   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000018   0x2801             CMP      R0,#+1
   \   0000001A   0xD006             BEQ.N    ??gcode_M998_2
   7761          		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
   \   0000001C   0x2201             MOVS     R2,#+1
   \   0000001E   0xF504 0x612A      ADD      R1,R4,#+2720
   \   00000022   0xF44F 0x6096      MOV      R0,#+1200
   \   00000026   0x.... 0x....      BL       epr_write_data
   7762          
   7763          		card.stopSDPrint();
   \                     ??gcode_M998_2: (+1)
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader11stopSDPrintEv
   7764          		clear_command_queue();
   \   00000030   0x.... 0x....      BL       _Z19clear_command_queuev
   7765          		quickstop_stepper();
   \   00000034   0x.... 0x....      BL       _Z17quickstop_stepperv
   7766          		print_job_timer.stop();
   \   00000038   0xF604 0x506C      ADDW     R0,R4,#+3436
   \   0000003C   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   7767          		thermalManager.disable_all_heaters();
   \   00000040   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   7768          		#if FAN_COUNT > 0
   7769          			for (uint8_t i = 0; i < FAN_COUNT; i++) 
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xE004             B.N      ??gcode_M998_3
   7770                      {         
   7771                          fanSpeeds[i] = 0;
   \                     ??gcode_M998_4: (+1)
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x66C8             STR      R0,[R1, #+108]
   7772                          #if 1
   7773                          MKS_FAN_TIM = 0 ;
   \   0000004C   0x4906             LDR.N    R1,??gcode_M998_0+0x8  ;; 0x40000440
   \   0000004E   0x6008             STR      R0,[R1, #+0]
   7774                          #endif
   7775                       }
   \   00000050   0x2001             MOVS     R0,#+1
   \                     ??gcode_M998_3: (+1)
   \   00000052   0x4906             LDR.N    R1,??gcode_M998_0+0xC
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD0F7             BEQ.N    ??gcode_M998_4
   7776          		#endif
   7777          		wait_for_heatup = false;
   \   00000058   0x2000             MOVS     R0,#+0
   \   0000005A   0x7108             STRB     R0,[R1, #+4]
   7778          	}
   \                     ??gcode_M998_1: (+1)
   \   0000005C   0xBD10             POP      {R4,PC}          ;; return
   \   0000005E   0xBF00             Nop      
   \                     ??gcode_M998_0:
   \   00000060   0x........         DC32     card
   \   00000064   0x........         DC32     gCfgItems
   \   00000068   0x40000440         DC32     0x40000440
   \   0000006C   0x........         DC32     mks_heating_busy
   7779          
   7780            /**
   7781             * M26: Set SD Card file index
   7782             */

   \                                 In section .text, align 4
   7783            inline void gcode_M26() {
   \                     _Z9gcode_M26v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7784              if (card.cardOK && parser.seenval('S'))
   \   00000002   0x4C09             LDR.N    R4,??gcode_M26_0
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00C             BEQ.N    ??gcode_M26_1
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD007             BEQ.N    ??gcode_M26_1
   7785                card.setIndex(parser.value_long());
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   0000001A   0x4601             MOV      R1,R0
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000022   0x.... 0x....      B.W      _ZN10CardReader8setIndexEl
   7786            }
   \                     ??gcode_M26_1: (+1)
   \   00000026   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M26_0:
   \   00000028   0x........         DC32     card
   7787          
   7788            /**
   7789             * M27: Get SD Card status
   7790             */

   \                                 In section .text, align 4
   7791            inline void gcode_M27() { card.getStatus(); }
   \                     _Z9gcode_M27v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M27_0
   \   00000002   0x.... 0x....      B.W      _ZN10CardReader9getStatusEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M27_0:
   \   00000008   0x........         DC32     card
   7792          
   7793            /**
   7794             * M28: Start SD Write
   7795             */

   \                                 In section .text, align 4
   7796            inline void gcode_M28() { card.openFile(parser.string_arg, false); }
   \                     _Z9gcode_M28v: (+1)
   \   00000000   0x2301             MOVS     R3,#+1
   \   00000002   0x2200             MOVS     R2,#+0
   \   00000004   0x4802             LDR.N    R0,??gcode_M28_0
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x4802             LDR.N    R0,??gcode_M28_0+0x4
   \   0000000A   0x.... 0x....      B.W      _ZN10CardReader8openFileEPcbb
   \   0000000E   0xBF00             Nop      
   \                     ??gcode_M28_0:
   \   00000010   0x........         DC32     _ZN11GCodeParser10string_argE
   \   00000014   0x........         DC32     card
   7797          
   7798            /**
   7799             * M29: Stop SD Write
   7800             * Processed in write to file routine above
   7801             */

   \                                 In section .text, align 2
   7802            inline void gcode_M29() {
   7803              // card.saving = false;
   7804            }
   \                     _Z9gcode_M29v: (+1)
   \   00000000   0x4770             BX       LR               ;; return
   7805          
   7806            /**
   7807             * M30 <filename>: Delete SD Card file
   7808             */

   \                                 In section .text, align 4
   7809            inline void gcode_M30() {
   \                     _Z9gcode_M30v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   7810              if (card.cardOK) {
   \   00000002   0x4C08             LDR.N    R4,??gcode_M30_0
   \   00000004   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00A             BEQ.N    ??gcode_M30_1
   7811                card.closefile();
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _ZN10CardReader9closefileEb
   7812                card.removeFile(parser.string_arg);
   \   00000014   0x4804             LDR.N    R0,??gcode_M30_0+0x4
   \   00000016   0x6801             LDR      R1,[R0, #+0]
   \   00000018   0x4620             MOV      R0,R4
   \   0000001A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN10CardReader10removeFileEPc
   7813              }
   7814            }
   \                     ??gcode_M30_1: (+1)
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M30_0:
   \   00000024   0x........         DC32     card
   \   00000028   0x........         DC32     _ZN11GCodeParser10string_argE
   7815          
   7816          #endif // SDSUPPORT
   7817          
   7818          /**
   7819           * M31: Get the time since the start of SD Print (or last M109)
   7820           */

   \                                 In section .text, align 4
   7821          inline void gcode_M31() {
   \                     _Z9gcode_M31v: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
   7822            char buffer[21];
   7823            duration_t elapsed = print_job_timer.duration();
   \   00000004   0x480D             LDR.N    R0,??gcode_M31_0
   \   00000006   0x.... 0x....      BL       _ZN9Stopwatch8durationEv
   \   0000000A   0x9000             STR      R0,[SP, #+0]
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0xA801             ADD      R0,SP,#+4
   \   00000010   0x.... 0x....      BL       _ZN10duration_tC1ERKj
   7824            elapsed.toString(buffer);
   \   00000014   0xA902             ADD      R1,SP,#+8
   \   00000016   0x.... 0x....      BL       _ZNK10duration_t8toStringEPc
   7825            lcd_setstatus(buffer);
   \   0000001A   0x2100             MOVS     R1,#+0
   \   0000001C   0xA802             ADD      R0,SP,#+8
   \   0000001E   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   7826          
   7827            SERIAL_ECHO_START();
   \   00000022   0x4807             LDR.N    R0,??gcode_M31_0+0x4
   \   00000024   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7828            SERIAL_ECHOLNPAIR("Print time: ", buffer);
   \   00000028   0xA902             ADD      R1,SP,#+8
   \   0000002A   0x4806             LDR.N    R0,??gcode_M31_0+0x8
   \   0000002C   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000030   0x210A             MOVS     R1,#+10
   \   00000032   0x4805             LDR.N    R0,??gcode_M31_0+0xC
   \   00000034   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   7829          }
   \   00000038   0xB009             ADD      SP,SP,#+36
   \   0000003A   0xBD00             POP      {PC}             ;; return
   \                     ??gcode_M31_0:
   \   0000003C   0x........         DC32     card+0xD6C
   \   00000040   0x........         DC32     echomagic
   \   00000044   0x........         DC32     _ZZ9gcode_M31vEs
   \   00000048   0x........         DC32     Serial3
   7830          
   7831          #if ENABLED(SDSUPPORT)
   7832          
   7833            /**
   7834             * M32: Select file and start SD Print
   7835             *
   7836             * Examples:
   7837             *
   7838             *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
   7839             *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
   7840             *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
   7841             *
   7842             */

   \                                 In section .text, align 4
   7843            inline void gcode_M32() {
   \                     _Z9gcode_M32v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   7844              if (card.sdprinting) stepper.synchronize();
   \   00000002   0x4C17             LDR.N    R4,??gcode_M32_0
   \   00000004   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD001             BEQ.N    ??gcode_M32_1
   \   0000000C   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   7845          
   7846              if (card.cardOK|| card.usbOK) {
   \                     ??gcode_M32_1: (+1)
   \   00000010   0xF604 0x10B8      ADDW     R0,R4,#+2488
   \   00000014   0x78C1             LDRB     R1,[R0, #+3]
   \   00000016   0x7900             LDRB     R0,[R0, #+4]
   \   00000018   0x4308             ORRS     R0,R0,R1
   \   0000001A   0xD020             BEQ.N    ??gcode_M32_2
   7847                const bool call_procedure = parser.boolval('P');
   \   0000001C   0x2050             MOVS     R0,#+80
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000022   0x4605             MOV      R5,R0
   7848          
   7849                card.openFile(parser.string_arg, true, call_procedure);
   \   00000024   0x462B             MOV      R3,R5
   \   00000026   0x2201             MOVS     R2,#+1
   \   00000028   0x480E             LDR.N    R0,??gcode_M32_0+0x4
   \   0000002A   0x6801             LDR      R1,[R0, #+0]
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   7850          
   7851                if (parser.seenval('S')) card.setIndex(parser.value_long());
   \   00000032   0x2053             MOVS     R0,#+83
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD005             BEQ.N    ??gcode_M32_3
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000040   0x4601             MOV      R1,R0
   \   00000042   0x4620             MOV      R0,R4
   \   00000044   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   7852          
   7853                card.startFileprint();
   \                     ??gcode_M32_3: (+1)
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   7854          
   7855                // Procedure calls count as normal print time.
   7856                if (!call_procedure) print_job_timer.start();
   \   0000004E   0x2D00             CMP      R5,#+0
   \   00000050   0xD105             BNE.N    ??gcode_M32_2
   \   00000052   0xF604 0x506C      ADDW     R0,R4,#+3436
   \   00000056   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000005A   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   7857              }
   7858            }
   \                     ??gcode_M32_2: (+1)
   \   0000005E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M32_0:
   \   00000060   0x........         DC32     card
   \   00000064   0x........         DC32     _ZN11GCodeParser10string_argE
   7859          
   7860            #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
   7861          
   7862              /**
   7863               * M33: Get the long full path of a file or folder
   7864               *
   7865               * Parameters:
   7866               *   <dospath> Case-insensitive DOS-style path to a file or folder
   7867               *
   7868               * Example:
   7869               *   M33 miscel~1/armchair/armcha~1.gco
   7870               *
   7871               * Output:
   7872               *   /Miscellaneous/Armchair/Armchair.gcode
   7873               */
   7874              inline void gcode_M33() {
   7875                card.printLongPath(parser.string_arg);
   7876              }
   7877          
   7878            #endif
   7879          
   7880            #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
   7881              /**
   7882               * M34: Set SD Card Sorting Options
   7883               */
   7884              inline void gcode_M34() {
   7885                if (parser.seen('S')) card.setSortOn(parser.value_bool());
   7886                if (parser.seenval('F')) {
   7887                  const int v = parser.value_long();
   7888                  card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
   7889                }
   7890                //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
   7891              }
   7892            #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
   7893          
   7894            /**
   7895             * M928: Start SD Write
   7896             */

   \                                 In section .text, align 4
   7897            inline void gcode_M928() {
   7898              card.openLogFile(parser.string_arg);
   \                     _Z10gcode_M928v: (+1)
   \   00000000   0x4802             LDR.N    R0,??gcode_M928_0
   \   00000002   0x6801             LDR      R1,[R0, #+0]
   \   00000004   0x4802             LDR.N    R0,??gcode_M928_0+0x4
   \   00000006   0x.... 0x....      B.W      _ZN10CardReader11openLogFileEPc
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_M928_0:
   \   0000000C   0x........         DC32     _ZN11GCodeParser10string_argE
   \   00000010   0x........         DC32     card
   7899            }
   7900          
   7901          #endif // SDSUPPORT
   7902          
   7903          /**
   7904           * Sensitive pin test for M42, M226
   7905           */

   \                                 In section .text, align 2, keep-with-next
   7906          static bool pin_is_protected(const int8_t pin) {
   7907            static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   7908            for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
   \                     _Z16pin_is_protecteda: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0xE000             B.N      ??pin_is_protected_0
   \                     ??pin_is_protected_1: (+1)
   \   00000004   0x1C49             ADDS     R1,R1,#+1
   \                     ??pin_is_protected_0: (+1)
   \   00000006   0xB2C9             UXTB     R1,R1
   \   00000008   0x2933             CMP      R1,#+51
   \   0000000A   0xD206             BCS.N    ??pin_is_protected_2
   7909              if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   \   0000000C   0x.... 0x....      ADR.W    R2,??sensitive_pins
   \   00000010   0x568A             LDRSB    R2,[R1, R2]
   \   00000012   0x4290             CMP      R0,R2
   \   00000014   0xD1F6             BNE.N    ??pin_is_protected_1
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x4770             BX       LR
   7910            return false;
   \                     ??pin_is_protected_2: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x4770             BX       LR               ;; return
   7911          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??sensitive_pins:
   \   00000000   0x00 0x01          DC8 0, 1, 1, 0, 2, 3, 3, 6, 5, 7, 8, 8, 11, 10, 12, 13, 14, 14, -1, 21
   \              0x01 0x00    
   \              0x02 0x03    
   \              0x03 0x06    
   \              0x05 0x07    
   \              0x08 0x08    
   \              0x0B 0x0A    
   \              0x0C 0x0D    
   \              0x0E 0x0E    
   \              0xFF 0x15    
   \   00000014   0x11 0xFF          DC8 17, -1, -1, -1, 16, 15, 17, -1, -1, 19, 18, 20, -1, -1, 21, 78, 22
   \              0xFF 0xFF    
   \              0x10 0x0F    
   \              0x11 0xFF    
   \              0xFF 0x13    
   \              0x12 0x14    
   \              0xFF 0xFF    
   \              0x15 0x4E    
   \              0x16         
   \   00000025   0xFF 0x4F          DC8 -1, 79, 23, -1, 80, 19, 18, 20, -1, -1, -1, -1, -1, -1, 0
   \              0x17 0xFF    
   \              0x50 0x13    
   \              0x12 0x14    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0xFF 0xFF    
   \              0x00         
   7912          
   7913          /**
   7914           * M42: Change pin status via GCode
   7915           *
   7916           *  P<pin>  Pin number (LED if omitted)
   7917           *  S<byte> Pin status from 0 - 255
   7918           */

   \                                 In section .text, align 4
   7919          inline void gcode_M42() {
   \                     _Z9gcode_M42v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   7920            if (!parser.seenval('S')) return;
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD02B             BEQ.N    ??gcode_M42_0
   7921            const byte pin_status = parser.value_byte();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4604             MOV      R4,R0
   7922          
   7923            const int pin_number = parser.intval('P', LED_PIN);
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x2050             MOVS     R0,#+80
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x0005             MOVS     R5,R0
   7924            if (pin_number < 0) return;
   \   0000001E   0xD421             BMI.N    ??gcode_M42_0
   7925          
   7926            if (pin_is_protected(pin_number)) {
   \   00000020   0xB240             SXTB     R0,R0
   \   00000022   0x.... 0x....      BL       _Z16pin_is_protecteda
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD007             BEQ.N    ??gcode_M42_1
   7927              SERIAL_ERROR_START();
   \   0000002A   0x480F             LDR.N    R0,??gcode_M42_2
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   7928              SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
   \   00000030   0x480E             LDR.N    R0,??gcode_M42_2+0x4
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   7929              return;
   7930            }
   7931          
   7932            pinMode(pin_number, OUTPUT);
   7933            digitalWrite(pin_number, pin_status);
   \                     ??gcode_M42_1: (+1)
   \   0000003A   0x2D00             CMP      R5,#+0
   \   0000003C   0x4622             MOV      R2,R4
   \   0000003E   0xB252             SXTB     R2,R2
   \   00000040   0xD408             BMI.N    ??gcode_M42_3
   \   00000042   0x480B             LDR.N    R0,??gcode_M42_2+0x8
   \   00000044   0xF830 0x1015      LDRH     R1,[R0, R5, LSL #+1]
   \   00000048   0x480A             LDR.N    R0,??gcode_M42_2+0xC
   \   0000004A   0xF850 0x0025      LDR      R0,[R0, R5, LSL #+2]
   \   0000004E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000052   0xE003             B.N      ??gcode_M42_4
   \                     ??gcode_M42_3: (+1)
   \   00000054   0x2100             MOVS     R1,#+0
   \   00000056   0x4608             MOV      R0,R1
   \   00000058   0x.... 0x....      BL       HAL_GPIO_WritePin
   7934            //analogWrite(pin_number, pin_status);
   7935          
   7936            #if FAN_COUNT > 0
   7937              switch (pin_number) {
   \                     ??gcode_M42_4: (+1)
   \   0000005C   0x2D11             CMP      R5,#+17
   \   0000005E   0xD101             BNE.N    ??gcode_M42_0
   7938                #if HAS_FAN0
   7939                  case FAN_PIN: fanSpeeds[0] = pin_status; break;
   \   00000060   0x4805             LDR.N    R0,??gcode_M42_2+0x10
   \   00000062   0x66C4             STR      R4,[R0, #+108]
   7940                #endif
   7941                #if HAS_FAN1
   7942                  case FAN1_PIN: fanSpeeds[1] = pin_status; break;
   7943                #endif
   7944                #if HAS_FAN2
   7945                  case FAN2_PIN: fanSpeeds[2] = pin_status; break;
   7946                #endif
   7947              }
   7948            #endif
   7949          }
   \                     ??gcode_M42_0: (+1)
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000066   0xBF00             Nop      
   \                     ??gcode_M42_2:
   \   00000068   0x........         DC32     errormagic
   \   0000006C   0x........         DC32     _ZZ9gcode_M42vEs
   \   00000070   0x........         DC32     gArrayGpioPin
   \   00000074   0x........         DC32     gArrayGpioPort
   \   00000078   0x........         DC32     mks_heating_busy
   7950          
   7951          #if ENABLED(PINS_DEBUGGING)
   7952          
   7953            #include "pinsDebug.h"
   7954          
   7955            inline void toggle_pins() {
   7956              const bool I_flag = parser.boolval('I');
   7957              const int repeat = parser.intval('R', 1),
   7958                        start = parser.intval('S'),
   7959                        end = parser.intval('L', NUM_DIGITAL_PINS - 1),
   7960                        wait = parser.intval('W', 500);
   7961          
   7962              for (uint8_t pin = start; pin <= end; pin++) {
   7963                //report_pin_state_extended(pin, I_flag, false);
   7964          
   7965                if (!I_flag && pin_is_protected(pin)) {
   7966                  report_pin_state_extended(pin, I_flag, true, "Untouched ");
   7967                  SERIAL_EOL();
   7968                }
   7969                else {
   7970                  report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
   7971                  #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
   7972                    if (pin == TEENSY_E2) {
   7973                      SET_OUTPUT(TEENSY_E2);
   7974                      for (int16_t j = 0; j < repeat; j++) {
   7975                        WRITE(TEENSY_E2, LOW);  safe_delay(wait);
   7976                        WRITE(TEENSY_E2, HIGH); safe_delay(wait);
   7977                        WRITE(TEENSY_E2, LOW);  safe_delay(wait);
   7978                      }
   7979                    }
   7980                    else if (pin == TEENSY_E3) {
   7981                      SET_OUTPUT(TEENSY_E3);
   7982                      for (int16_t j = 0; j < repeat; j++) {
   7983                        WRITE(TEENSY_E3, LOW);  safe_delay(wait);
   7984                        WRITE(TEENSY_E3, HIGH); safe_delay(wait);
   7985                        WRITE(TEENSY_E3, LOW);  safe_delay(wait);
   7986                      }
   7987                    }
   7988                    else
   7989                  #endif
   7990                  {
   7991                    pinMode(pin, OUTPUT);
   7992                    for (int16_t j = 0; j < repeat; j++) {
   7993                      digitalWrite(pin, 0); safe_delay(wait);
   7994                      digitalWrite(pin, 1); safe_delay(wait);
   7995                      digitalWrite(pin, 0); safe_delay(wait);
   7996                    }
   7997                  }
   7998          
   7999                }
   8000                SERIAL_EOL();
   8001              }
   8002              SERIAL_ECHOLNPGM("Done.");
   8003          
   8004            } // toggle_pins
   8005          
   8006            inline void servo_probe_test() {
   8007              #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
   8008          
   8009                SERIAL_ERROR_START();
   8010                SERIAL_ERRORLNPGM("SERVO not setup");
   8011          
   8012              #elif !HAS_Z_SERVO_ENDSTOP
   8013          
   8014                SERIAL_ERROR_START();
   8015                SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
   8016          
   8017              #else // HAS_Z_SERVO_ENDSTOP
   8018          
   8019                const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
   8020          
   8021                SERIAL_PROTOCOLLNPGM("Servo probe test");
   8022                SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
   8023                SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
   8024                SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
   8025          
   8026                bool probe_inverting;
   8027          
   8028                //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   8029                uint8_t PROBE_TEST_PIN = 0;
   8030          	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
   8031          	  {
   8032          
   8033                 // #define PROBE_TEST_PIN Z_MIN_PIN
   8034          	   PROBE_TEST_PIN = Z_MIN_PIN;
   8035          
   8036                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
   8037                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
   8038                  SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
   8039          /*
   8040                  #if Z_MIN_ENDSTOP_INVERTING
   8041                    SERIAL_PROTOCOLLNPGM("true");
   8042                  #else
   8043                    SERIAL_PROTOCOLLNPGM("false");
   8044                  #endif
   8045          */		if(Z_MIN_ENDSTOP_INVERTING)
   8046          			SERIAL_PROTOCOLLNPGM("true");
   8047          		else
   8048          			SERIAL_PROTOCOLLNPGM("false");
   8049          		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
   8050          
   8051                  probe_inverting = Z_MIN_ENDSTOP_INVERTING;
   8052          	  }
   8053                //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
   8054          	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
   8055          	  {
   8056                  //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
   8057                  PROBE_TEST_PIN = Z_MAX_PIN;
   8058                  SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
   8059                  SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
   8060                  SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
   8061          /*
   8062                  #if Z_MIN_PROBE_ENDSTOP_INVERTING
   8063                    SERIAL_PROTOCOLLNPGM("true");
   8064                  #else
   8065                    SERIAL_PROTOCOLLNPGM("false");
   8066                  #endif
   8067          */
   8068          		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
   8069          			SERIAL_PROTOCOLLNPGM("true");
   8070          		else
   8071          			SERIAL_PROTOCOLLNPGM("false");
   8072          	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
   8073          
   8074                  probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
   8075          	  }
   8076                //#endif
   8077          
   8078                SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
   8079                SET_INPUT_PULLUP(PROBE_TEST_PIN);
   8080                bool deploy_state, stow_state;
   8081                for (uint8_t i = 0; i < 4; i++) {
   8082                  MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
   8083                  safe_delay(500);
   8084                  deploy_state = READ(PROBE_TEST_PIN);
   8085                  MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
   8086                  safe_delay(500);
   8087                  stow_state = READ(PROBE_TEST_PIN);
   8088                }
   8089                if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
   8090          
   8091                refresh_cmd_timeout();
   8092          
   8093                if (deploy_state != stow_state) {
   8094                  SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
   8095                  if (deploy_state) {
   8096                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
   8097                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
   8098                  }
   8099                  else {
   8100                    SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
   8101                    SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
   8102                  }
   8103                  //#if ENABLED(BLTOUCH)
   8104                  if(MKSTOUCH == 1)
   8105                    SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
   8106                  //#endif
   8107          
   8108                }
   8109                else {                                           // measure active signal length
   8110                  MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
   8111                  safe_delay(500);
   8112                  SERIAL_PROTOCOLLNPGM("please trigger probe");
   8113                  uint16_t probe_counter = 0;
   8114          
   8115                  // Allow 30 seconds max for operator to trigger probe
   8116                  for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
   8117          
   8118                    safe_delay(2);
   8119          
   8120                    if (0 == j % (500 * 1)) // keep cmd_timeout happy
   8121                      refresh_cmd_timeout();
   8122          
   8123                    if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
   8124          
   8125                      for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
   8126                        safe_delay(2);
   8127          
   8128                      if (probe_counter == 50)
   8129                        SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
   8130                      else if (probe_counter >= 2)
   8131                        SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
   8132                      else
   8133                        SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
   8134          
   8135                      MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
   8136          
   8137                    }  // pulse detected
   8138          
   8139                  } // for loop waiting for trigger
   8140          
   8141                  if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
   8142          
   8143                } // measure active signal length
   8144          
   8145              #endif
   8146          
   8147            } // servo_probe_test
   8148          
   8149            /**
   8150             * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
   8151             *
   8152             *  M43         - report name and state of pin(s)
   8153             *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
   8154             *                  I       Flag to ignore Marlin's pin protection.
   8155             *
   8156             *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
   8157             *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
   8158             *                  I       Flag to ignore Marlin's pin protection.
   8159             *
   8160             *  M43 E<bool> - Enable / disable background endstop monitoring
   8161             *                  - Machine continues to operate
   8162             *                  - Reports changes to endstops
   8163             *                  - Toggles LED_PIN when an endstop changes
   8164             *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
   8165             *
   8166             *  M43 T       - Toggle pin(s) and report which pin is being toggled
   8167             *                  S<pin>  - Start Pin number.   If not given, will default to 0
   8168             *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
   8169             *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
   8170             *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
   8171             *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
   8172             *
   8173             *  M43 S       - Servo probe test
   8174             *                  P<index> - Probe index (optional - defaults to 0
   8175             */
   8176            inline void gcode_M43() {
   8177          
   8178              if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
   8179                toggle_pins();
   8180                return;
   8181              }
   8182          
   8183              // Enable or disable endstop monitoring
   8184              if (parser.seen('E')) {
   8185                endstop_monitor_flag = parser.value_bool();
   8186                SERIAL_PROTOCOLPGM("endstop monitor ");
   8187                serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
   8188                SERIAL_PROTOCOLLNPGM("abled");
   8189                return;
   8190              }
   8191          
   8192              if (parser.seen('S')) {
   8193                servo_probe_test();
   8194                return;
   8195              }
   8196          
   8197              // Get the range of pins to test or watch
   8198              const uint8_t first_pin = parser.byteval('P'),
   8199                            last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
   8200          
   8201              if (first_pin > last_pin) return;
   8202          
   8203              const bool ignore_protection = parser.boolval('I');
   8204          
   8205              // Watch until click, M108, or reset
   8206              if (parser.boolval('W')) {
   8207                SERIAL_PROTOCOLLNPGM("Watching pins");
   8208                byte pin_state[last_pin - first_pin + 1];
   8209                for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   8210                  if (pin_is_protected(pin) && !ignore_protection) continue;
   8211                  pinMode(pin, INPUT_PULLUP);
   8212                  delay(1);
   8213                  /*
   8214                    if (IS_ANALOG(pin))
   8215                      pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
   8216                    else
   8217                  //
   8218                  */
   8219                      pin_state[pin - first_pin] = digitalRead(pin);
   8220                }
   8221          
   8222                #if HAS_RESUME_CONTINUE
   8223                  wait_for_user = true;
   8224                  KEEPALIVE_STATE(PAUSED_FOR_USER);
   8225                #endif
   8226          
   8227                for (;;) {
   8228                  for (int8_t pin = first_pin; pin <= last_pin; pin++) {
   8229                    if (pin_is_protected(pin) && !ignore_protection) continue;
   8230                    const byte val =
   8231                      /*
   8232                        IS_ANALOG(pin)
   8233                          ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
   8234                          :
   8235                      //
   8236                      */
   8237                        digitalRead(pin);
   8238                    if (val != pin_state[pin - first_pin]) {
   8239                      report_pin_state_extended(pin, ignore_protection, false);
   8240                      pin_state[pin - first_pin] = val;
   8241                    }
   8242                  }
   8243          
   8244                  #if HAS_RESUME_CONTINUE
   8245                    if (!wait_for_user) {
   8246                      KEEPALIVE_STATE(IN_HANDLER);
   8247                      break;
   8248                    }
   8249                  #endif
   8250          
   8251                  safe_delay(200);
   8252                }
   8253                return;
   8254              }
   8255          
   8256              // Report current state of selected pin(s)
   8257              for (uint8_t pin = first_pin; pin <= last_pin; pin++)
   8258                report_pin_state_extended(pin, ignore_protection, true);
   8259            }
   8260          
   8261          #endif // PINS_DEBUGGING
   8262          
   8263          #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   8264          
   8265            /**
   8266             * M48: Z probe repeatability measurement function.
   8267             *
   8268             * Usage:
   8269             *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
   8270             *     P = Number of sampled points (4-50, default 10)
   8271             *     X = Sample X position
   8272             *     Y = Sample Y position
   8273             *     V = Verbose level (0-4, default=1)
   8274             *     E = Engage Z probe for each reading
   8275             *     L = Number of legs of movement before probe
   8276             *     S = Schizoid (Or Star if you prefer)
   8277             *
   8278             * This function requires the machine to be homed before invocation.
   8279             */
   8280            inline void gcode_M48() {
   8281          
   8282              if (axis_unhomed_error()) return;
   8283          
   8284              const int8_t verbose_level = parser.byteval('V', 1);
   8285              if (!WITHIN(verbose_level, 0, 4)) {
   8286                SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
   8287                return;
   8288              }
   8289          
   8290              if (verbose_level > 0)
   8291                SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
   8292          
   8293              const int8_t n_samples = parser.byteval('P', 10);
   8294              if (!WITHIN(n_samples, 4, 50)) {
   8295                SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
   8296                return;
   8297              }
   8298          
   8299              const bool stow_probe_after_each = parser.boolval('E');
   8300          
   8301              float X_current = current_position[X_AXIS],
   8302                    Y_current = current_position[Y_AXIS];
   8303          
   8304              const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
   8305                          Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
   8306          
   8307              //#if DISABLED(DELTA)
   8308              if(MACHINETPYE != DELTA)
   8309              {
   8310                if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
   8311                  out_of_range_error(PSTR("X"));
   8312                  return;
   8313                }
   8314                if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
   8315                  out_of_range_error(PSTR("Y"));
   8316                  return;
   8317                }
   8318              }
   8319              //#else
   8320              else
   8321               {
   8322               if(MACHINETPYE & IS_KINEMATIC)
   8323                  {
   8324                if (!position_is_reachable_by_probe_IS_KINEMATIC(X_probe_location, Y_probe_location)) {
   8325                  SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
   8326                  return;
   8327                }
   8328                  }
   8329               else
   8330                  {
   8331                if (!position_is_reachable_by_probe_IS_CARTESIAN(X_probe_location, Y_probe_location)) {
   8332                  SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
   8333                  return;
   8334                }
   8335                  }        
   8336               }
   8337              //#endif
   8338          
   8339              bool seen_L = parser.seen('L');
   8340              uint8_t n_legs = seen_L ? parser.value_byte() : 0;
   8341              if (n_legs > 15) {
   8342                SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
   8343                return;
   8344              }
   8345              if (n_legs == 1) n_legs = 2;
   8346          
   8347              const bool schizoid_flag = parser.boolval('S');
   8348              if (schizoid_flag && !seen_L) n_legs = 7;
   8349          
   8350              /**
   8351               * Now get everything to the specified probe point So we can safely do a
   8352               * probe to get us close to the bed.  If the Z-Axis is far from the bed,
   8353               * we don't want to use that as a starting point for each probe.
   8354               */
   8355              if (verbose_level > 2)
   8356                SERIAL_PROTOCOLLNPGM("Positioning the probe...");
   8357          
   8358              // Disable bed level correction in M48 because we want the raw data when we probe
   8359          /*
   8360              #if HAS_LEVELING
   8361                const bool was_enabled = planner.leveling_active;
   8362                set_bed_leveling_enabled(false);
   8363              #endif
   8364          */
   8365          	bool was_enabled;
   8366          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
   8367          		was_enabled = ubl.state.active;
   8368          	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   8369          		was_enabled = mbl.active();
   8370          	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
   8371          		was_enabled = planner.leveling_active;
   8372          
   8373          	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
   8374          		set_bed_leveling_enabled(false);
   8375          
   8376              setup_for_endstop_or_probe_move();
   8377          
   8378              double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
   8379          
   8380              // Move to the first point, deploy, and probe
   8381              const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
   8382              bool probing_good = !isnan(t);
   8383          
   8384              if (probing_good) {
   8385                //randomSeed(millis());
   8386          	  srand(millis());
   8387          
   8388                for (uint8_t n = 0; n < n_samples; n++) {
   8389                  if (n_legs) {
   8390                    const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
   8391                    float angle = random(0.0, 360.0);
   8392                    const float radius = random(
   8393                      #if ENABLED(DELTA)
   8394                        0.1250000000 * (DELTA_PROBEABLE_RADIUS),
   8395                        0.3333333333 * (DELTA_PROBEABLE_RADIUS)
   8396                      #else
   8397                        5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
   8398                      #endif
   8399                    );
   8400          
   8401                    if (verbose_level > 3) {
   8402                      SERIAL_ECHOPAIR("Starting radius: ", radius);
   8403                      SERIAL_ECHOPAIR("   angle: ", angle);
   8404                      SERIAL_ECHOPGM(" Direction: ");
   8405                      if (dir > 0) SERIAL_ECHOPGM("Counter-");
   8406                      SERIAL_ECHOLNPGM("Clockwise");
   8407                    }
   8408          
   8409                    for (uint8_t l = 0; l < n_legs - 1; l++) {
   8410                      double delta_angle;
   8411          
   8412                      if (schizoid_flag)
   8413                        // The points of a 5 point star are 72 degrees apart.  We need to
   8414                        // skip a point and go to the next one on the star.
   8415                        delta_angle = dir * 2.0 * 72.0;
   8416          
   8417                      else
   8418                        // If we do this line, we are just trying to move further
   8419                        // around the circle.
   8420                        delta_angle = dir * (float) random(25, 45);
   8421          
   8422                      angle += delta_angle;
   8423          
   8424                      while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
   8425                        angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
   8426                      while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
   8427                        angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
   8428          
   8429                      X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
   8430                      Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
   8431          
   8432                      //#if DISABLED(DELTA)
   8433                      if(MACHINETPYE != DELTA)
   8434                      {
   8435                        X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
   8436                        Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
   8437                      }
   8438                      //#else
   8439                      else
   8440                      {
   8441                        // If we have gone out too far, we can do a simple fix and scale the numbers
   8442                        // back in closer to the origin.
   8443                        if(MACHINETPYE & IS_KINEMATIC)
   8444                          {
   8445                        while (!position_is_reachable_by_probe_IS_KINEMATIC(X_current, Y_current)) {
   8446                          X_current *= 0.8;
   8447                          Y_current *= 0.8;
   8448                          if (verbose_level > 3) {
   8449                            SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
   8450                            SERIAL_ECHOLNPAIR(", ", Y_current);
   8451                          }
   8452                        }
   8453                          }
   8454                        else
   8455                           {
   8456                        while (!position_is_reachable_by_probe_IS_CARTESIAN(X_current, Y_current)) {
   8457                          X_current *= 0.8;
   8458                          Y_current *= 0.8;
   8459                          if (verbose_level > 3) {
   8460                            SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
   8461                            SERIAL_ECHOLNPAIR(", ", Y_current);
   8462                          }
   8463                        }
   8464                          }               
   8465                      }
   8466                      //#endif
   8467                      if (verbose_level > 3) {
   8468                        SERIAL_PROTOCOLPGM("Going to:");
   8469                        SERIAL_ECHOPAIR(" X", X_current);
   8470                        SERIAL_ECHOPAIR(" Y", Y_current);
   8471                        SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
   8472                      }
   8473                      do_blocking_move_to_xy(X_current, Y_current);
   8474                    } // n_legs loop
   8475                  } // n_legs
   8476          
   8477                  // Probe a single point
   8478                  sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
   8479          
   8480                  // Break the loop if the probe fails
   8481                  probing_good = !isnan(sample_set[n]);
   8482                  if (!probing_good) break;
   8483          
   8484                  /**
   8485                   * Get the current mean for the data points we have so far
   8486                   */
   8487                  double sum = 0.0;
   8488                  for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
   8489                  mean = sum / (n + 1);
   8490          
   8491                  NOMORE(min, sample_set[n]);
   8492                  NOLESS(max, sample_set[n]);
   8493          
   8494                  /**
   8495                   * Now, use that mean to calculate the standard deviation for the
   8496                   * data points we have so far
   8497                   */
   8498                  sum = 0.0;
   8499                  for (uint8_t j = 0; j <= n; j++)
   8500                    sum += sq(sample_set[j] - mean);
   8501          
   8502                  sigma = SQRT(sum / (n + 1));
   8503                  if (verbose_level > 0) {
   8504                    if (verbose_level > 1) {
   8505                      SERIAL_PROTOCOL(n + 1);
   8506                      SERIAL_PROTOCOLPGM(" of ");
   8507                      SERIAL_PROTOCOL((int)n_samples);
   8508                      SERIAL_PROTOCOLPGM(": z: ");
   8509                      SERIAL_PROTOCOL_F(sample_set[n], 3);
   8510                      if (verbose_level > 2) {
   8511                        SERIAL_PROTOCOLPGM(" mean: ");
   8512                        SERIAL_PROTOCOL_F(mean, 4);
   8513                        SERIAL_PROTOCOLPGM(" sigma: ");
   8514                        SERIAL_PROTOCOL_F(sigma, 6);
   8515                        SERIAL_PROTOCOLPGM(" min: ");
   8516                        SERIAL_PROTOCOL_F(min, 3);
   8517                        SERIAL_PROTOCOLPGM(" max: ");
   8518                        SERIAL_PROTOCOL_F(max, 3);
   8519                        SERIAL_PROTOCOLPGM(" range: ");
   8520                        SERIAL_PROTOCOL_F(max-min, 3);
   8521                      }
   8522                      SERIAL_EOL();
   8523                    }
   8524                  }
   8525          
   8526                } // n_samples loop
   8527              }
   8528          
   8529              STOW_PROBE();
   8530          
   8531              if (probing_good) {
   8532                SERIAL_PROTOCOLLNPGM("Finished!");
   8533          
   8534                if (verbose_level > 0) {
   8535                  SERIAL_PROTOCOLPGM("Mean: ");
   8536                  SERIAL_PROTOCOL_F(mean, 6);
   8537                  SERIAL_PROTOCOLPGM(" Min: ");
   8538                  SERIAL_PROTOCOL_F(min, 3);
   8539                  SERIAL_PROTOCOLPGM(" Max: ");
   8540                  SERIAL_PROTOCOL_F(max, 3);
   8541                  SERIAL_PROTOCOLPGM(" Range: ");
   8542                  SERIAL_PROTOCOL_F(max-min, 3);
   8543                  SERIAL_EOL();
   8544                }
   8545          
   8546                SERIAL_PROTOCOLPGM("Standard Deviation: ");
   8547                SERIAL_PROTOCOL_F(sigma, 6);
   8548                SERIAL_EOL();
   8549                SERIAL_EOL();
   8550              }
   8551          
   8552              clean_up_after_endstop_or_probe_move();
   8553          
   8554              // Re-enable bed level correction if it had been on
   8555              //#if HAS_LEVELING
   8556              if(BED_LEVELING_METHOD&HAS_LEVELING)
   8557                set_bed_leveling_enabled(was_enabled);
   8558              //#endif
   8559          
   8560              report_current_position();
   8561            }
   8562          
   8563          #endif // Z_MIN_PROBE_REPEATABILITY_TEST
   8564          
   8565          #if 1//ENABLED(G26_MESH_VALIDATION)
   8566          

   \                                 In section .text, align 4
   8567            inline void gcode_M49() {
   \                     _Z9gcode_M49v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   8568              g26_debug_flag ^= true;
   \   00000002   0x4C0B             LDR.N    R4,??gcode_M49_0
   \   00000004   0x7820             LDRB     R0,[R4, #+0]
   \   00000006   0xF080 0x0001      EOR      R0,R0,#0x1
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
   \   0000000C   0x4180             SBCS     R0,R0,R0
   \   0000000E   0x43C0             MVNS     R0,R0
   \   00000010   0x0FC0             LSRS     R0,R0,#+31
   \   00000012   0x7020             STRB     R0,[R4, #+0]
   8569              SERIAL_PROTOCOLPGM("G26 Debug ");
   \   00000014   0x4807             LDR.N    R0,??gcode_M49_0+0x4
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8570              serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
   \   0000001A   0x7820             LDRB     R0,[R4, #+0]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD001             BEQ.N    ??gcode_M49_1
   \   00000020   0x4805             LDR.N    R0,??gcode_M49_0+0x8
   \   00000022   0xE000             B.N      ??gcode_M49_2
   \                     ??gcode_M49_1: (+1)
   \   00000024   0x4805             LDR.N    R0,??gcode_M49_0+0xC
   \                     ??gcode_M49_2: (+1)
   \   00000026   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   0000002E   0xBF00             Nop      
   \                     ??gcode_M49_0:
   \   00000030   0x........         DC32     g26_debug_flag
   \   00000034   0x........         DC32     _ZZ9gcode_M49vEs
   \   00000038   0x........         DC32     _ZZ9gcode_M49vEs_0
   \   0000003C   0x........         DC32     _ZZ9gcode_M49vEs_1
   8571            }
   8572          
   8573          #endif // G26_MESH_VALIDATION
   8574          
   8575          #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
   8576            /**
   8577             * M73: Set percentage complete (for display on LCD)
   8578             *
   8579             * Example:
   8580             *   M73 P25 ; Set progress to 25%
   8581             *
   8582             * Notes:
   8583             *   This has no effect during an SD print job
   8584             */
   8585            inline void gcode_M73() {
   8586              if (!IS_SD_PRINTING && parser.seen('P')) {
   8587                progress_bar_percent = parser.value_byte();
   8588                NOMORE(progress_bar_percent, 100);
   8589              }
   8590            }
   8591          #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
   8592          
   8593          /**
   8594           * M75: Start print timer
   8595           */

   \                                 In section .text, align 4
   8596          inline void gcode_M75() { print_job_timer.start(); }
   \                     _Z9gcode_M75v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M75_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch5startEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M75_0:
   \   00000008   0x........         DC32     card+0xD6C
   8597          
   8598          /**
   8599           * M76: Pause print timer
   8600           */

   \                                 In section .text, align 4
   8601          inline void gcode_M76() { print_job_timer.pause(); }
   \                     _Z9gcode_M76v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M76_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch5pauseEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M76_0:
   \   00000008   0x........         DC32     card+0xD6C
   8602          
   8603          /**
   8604           * M77: Stop print timer
   8605           */

   \                                 In section .text, align 4
   8606          inline void gcode_M77() { print_job_timer.stop(); }
   \                     _Z9gcode_M77v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M77_0
   \   00000002   0x.... 0x....      B.W      _ZN9Stopwatch4stopEv
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M77_0:
   \   00000008   0x........         DC32     card+0xD6C
   8607          
   8608          #if ENABLED(PRINTCOUNTER)
   8609            /**
   8610             * M78: Show print statistics
   8611             */
   8612            inline void gcode_M78() {
   8613              // "M78 S78" will reset the statistics
   8614              if (parser.intval('S') == 78)
   8615                print_job_timer.initStats();
   8616              else
   8617                print_job_timer.showStats();
   8618            }
   8619          #endif
   8620          
   8621          /**
   8622           * M104: Set hot end temperature
   8623           */

   \                                 In section .text, align 4
   8624          inline void gcode_M104() {
   \                     _Z10gcode_M104v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   8625            if (get_target_extruder_from_command(104)) return;
   \   00000002   0x2068             MOVS     R0,#+104
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD157             BNE.N    ??gcode_M104_1
   8626            if (DEBUGGING(DRYRUN)) return;
   \   0000000C   0x4C2C             LDR.N    R4,??gcode_M104_2
   \   0000000E   0x7860             LDRB     R0,[R4, #+1]
   \   00000010   0x0700             LSLS     R0,R0,#+28
   \   00000012   0xD453             BMI.N    ??gcode_M104_1
   8627          
   8628            #if ENABLED(SINGLENOZZLE)
   8629              if (target_extruder != active_extruder) return;
   8630            #endif
   8631          
   8632            if (parser.seenval('S')) {
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD04A             BEQ.N    ??gcode_M104_3
   8633              const int16_t temp = parser.value_celsius();
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000022   0x.... 0x....      BL       __aeabi_f2iz
   8634              thermalManager.setTargetHotend(temp, target_extruder);
   \   00000026   0x7961             LDRB     R1,[R4, #+5]
   \   00000028   0x460D             MOV      R5,R1
   \   0000002A   0xB200             SXTH     R0,R0
   \   0000002C   0x.... 0x....      BL       __aeabi_i2f
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   8635          
   8636              #if ENABLED(DUAL_X_CARRIAGE)
   8637                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   8638                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   8639              #endif
   8640          
   8641              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8642                /**
   8643                 * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
   8644                 * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
   8645                 * standby mode, for instance in a dual extruder setup, without affecting
   8646                 * the running print timer.
   8647                 */
   8648                if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000003A   0x4605             MOV      R5,R0
   \   0000003C   0x4821             LDR.N    R0,??gcode_M104_2+0x4
   \   0000003E   0x6AC1             LDR      R1,[R0, #+44]
   \   00000040   0xF04F 0x507C      MOV      R0,#+1056964608
   \   00000044   0x.... 0x....      BL       __aeabi_fmul
   \   00000048   0x4629             MOV      R1,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000004E   0xD806             BHI.N    ??gcode_M104_4
   8649                  print_job_timer.stop();
   \   00000050   0x481D             LDR.N    R0,??gcode_M104_2+0x8
   \   00000052   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   8650                  LCD_MESSAGEPGM(WELCOME_MSG);
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x481C             LDR.N    R0,??gcode_M104_2+0xC
   \   0000005A   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8651                }
   8652              #endif
   8653          
   8654              //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
   8655              //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   8656          		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M104_4: (+1)
   \   0000005E   0x7960             LDRB     R0,[R4, #+5]
   \   00000060   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000064   0x4605             MOV      R5,R0
   \   00000066   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4628             MOV      R0,R5
   \   0000006E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000072   0xD21F             BCS.N    ??gcode_M104_3
   8657          		{
   8658          		switch(target_extruder)
   \   00000074   0x7960             LDRB     R0,[R4, #+5]
   \   00000076   0x2804             CMP      R0,#+4
   \   00000078   0xD81C             BHI.N    ??gcode_M104_3
   \   0000007A   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M104_0:
   \   0000007E   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \   00000082   0x17 0x00          DC8      0x17,0x0
   8659          			{
   8660          			case 0:
   8661          				LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M104_5: (+1)
   \   00000084   0x2100             MOVS     R1,#+0
   \   00000086   0x4812             LDR.N    R0,??gcode_M104_2+0x10
   \   00000088   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8662          				break;
   \   0000008C   0xE012             B.N      ??gcode_M104_3
   8663          			case 1:
   8664          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M104_6: (+1)
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0x4810             LDR.N    R0,??gcode_M104_2+0x14
   \   00000092   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8665          				break;
   \   00000096   0xE00D             B.N      ??gcode_M104_3
   8666          			case 2:
   8667          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M104_7: (+1)
   \   00000098   0x2100             MOVS     R1,#+0
   \   0000009A   0x480F             LDR.N    R0,??gcode_M104_2+0x18
   \   0000009C   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8668          				break;
   \   000000A0   0xE008             B.N      ??gcode_M104_3
   8669          			case 3:
   8670          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M104_8: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x480D             LDR.N    R0,??gcode_M104_2+0x1C
   \   000000A6   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8671          				break;
   \   000000AA   0xE003             B.N      ??gcode_M104_3
   8672          			case 4:
   8673          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M104_9: (+1)
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x480C             LDR.N    R0,??gcode_M104_2+0x20
   \   000000B0   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8674          				break;
   8675          			default: break;
   8676          				
   8677          			}
   8678          		}    
   8679            }
   8680          
   8681            #if ENABLED(AUTOTEMP)
   8682              planner.autotemp_M104_M109();
   \                     ??gcode_M104_3: (+1)
   \   000000B4   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   000000B8   0x.... 0x....      B.W      _ZN7Planner18autotemp_M104_M109Ev
   \                     ??gcode_M104_1: (+1)
   \   000000BC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   000000BE   0xBF00             Nop      
   \                     ??gcode_M104_2:
   \   000000C0   0x........         DC32     mks_heating_busy
   \   000000C4   0x........         DC32     mksCfg
   \   000000C8   0x........         DC32     card+0xD6C
   \   000000CC   0x........         DC32     _ZZ10gcode_M104vEs
   \   000000D0   0x........         DC32     _ZZ10gcode_M104vEs_0
   \   000000D4   0x........         DC32     _ZZ10gcode_M104vEs_1
   \   000000D8   0x........         DC32     _ZZ10gcode_M104vEs_2
   \   000000DC   0x........         DC32     _ZZ10gcode_M104vEs_3
   \   000000E0   0x........         DC32     _ZZ10gcode_M104vEs_4
   8683            #endif
   8684          }
   8685          
   8686          /**
   8687           * M105: Read hot end and bed temperature
   8688           */

   \                                 In section .text, align 4
   8689          inline void gcode_M105() {
   \                     _Z10gcode_M105v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8690            if (get_target_extruder_from_command(105)) return;
   \   00000002   0x2069             MOVS     R0,#+105
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD10A             BNE.N    ??gcode_M105_0
   8691          /*
   8692            #if HAS_TEMP_HOTEND || HAS_TEMP_BED
   8693              SERIAL_PROTOCOLPGM(MSG_OK);
   8694              thermalManager.print_heaterstates();
   8695            #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
   8696              SERIAL_ERROR_START();
   8697              SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
   8698            #endif
   8699          */
   8700            SERIAL_PROTOCOLPGM(MSG_OK);
   \   0000000C   0x4805             LDR.N    R0,??gcode_M105_1
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8701            thermalManager.print_heaterstates();
   \   00000012   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   8702          
   8703            SERIAL_EOL();
   \   00000016   0x210A             MOVS     R1,#+10
   \   00000018   0x4803             LDR.N    R0,??gcode_M105_1+0x4
   \   0000001A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M105_0: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M105_1:
   \   00000024   0x........         DC32     _ZZ10gcode_M105vEs
   \   00000028   0x........         DC32     Serial3
   8704          }
   8705          
   8706          #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND /*|| HAS_TEMP_BED*/)
   8707          
   8708            /**
   8709             * M155: Set temperature auto-report interval. M155 S<seconds>
   8710             */

   \                                 In section .text, align 4
   8711            inline void gcode_M155() {
   \                     _Z10gcode_M155v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8712              if (parser.seenval('S'))
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD007             BEQ.N    ??gcode_M155_0
   8713                thermalManager.set_auto_report_interval(parser.value_byte());
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x4803             LDR.N    R0,??gcode_M155_1
   \   00000014   0xE8BD 0x4004      POP      {R2,LR}
   \   00000018   0x.... 0x....      B.W      _ZN11Temperature24set_auto_report_intervalEh
   8714            }
   \                     ??gcode_M155_0: (+1)
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
   \   0000001E   0xBF00             Nop      
   \                     ??gcode_M155_1:
   \   00000020   0x........         DC32     thermalManager
   8715          
   8716          #endif // AUTO_REPORT_TEMPERATURES
   8717          
   8718          #if FAN_COUNT > 0
   8719          
   8720            /**
   8721             * M106: Set Fan Speed
   8722             *
   8723             *  S<int>   Speed between 0-255
   8724             *  P<index> Fan index, if more than one fan
   8725             *
   8726             * With EXTRA_FAN_SPEED enabled:
   8727             *
   8728             *  T<int>   Restore/Use/Set Temporary Speed:
   8729             *           1     = Restore previous speed after T2
   8730             *           2     = Use temporary speed set with T3-255
   8731             *           3-255 = Set the speed for use with T2
   8732             */

   \                                 In section .text, align 4
   8733            inline void gcode_M106() {
   \                     _Z10gcode_M106v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8734              const uint8_t p = parser.byteval('P');
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   8735              if (p < FAN_COUNT) {
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD111             BNE.N    ??gcode_M106_0
   8736                #if ENABLED(EXTRA_FAN_SPEED)
   8737                  const int16_t t = parser.intval('T');
   8738                  if (t > 0) {
   8739                    switch (t) {
   8740                      case 1:
   8741                        fanSpeeds[p] = old_fanSpeeds[p];
   8742                        break;
   8743                      case 2:
   8744                        old_fanSpeeds[p] = fanSpeeds[p];
   8745                        fanSpeeds[p] = new_fanSpeeds[p];
   8746                        break;
   8747                      default:
   8748                        new_fanSpeeds[p] = min(t, 255);
   8749                        break;
   8750                    }
   8751                    return;
   8752                  }
   8753                #endif // EXTRA_FAN_SPEED
   8754                const uint16_t s = parser.ushortval('S', 255);
   \   0000000E   0x21FF             MOVS     R1,#+255
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser9ushortvalEct
   8755                fanSpeeds[p] = min(s, 255);
   \   00000016   0x21FF             MOVS     R1,#+255
   \   00000018   0x28FF             CMP      R0,#+255
   \   0000001A   0xDC00             BGT.N    ??gcode_M106_1
   \   0000001C   0x4601             MOV      R1,R0
   \                     ??gcode_M106_1: (+1)
   \   0000001E   0x4A05             LDR.N    R2,??gcode_M106_2
   \   00000020   0x66D1             STR      R1,[R2, #+108]
   8756          	  MKS_FAN_TIM = s*10000/255;
   \   00000022   0xF242 0x7110      MOVW     R1,#+10000
   \   00000026   0x4348             MULS     R0,R1,R0
   \   00000028   0x21FF             MOVS     R1,#+255
   \   0000002A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000002E   0x4902             LDR.N    R1,??gcode_M106_2+0x4  ;; 0x40000440
   \   00000030   0x6008             STR      R0,[R1, #+0]
   8757              }
   8758            }
   \                     ??gcode_M106_0: (+1)
   \   00000032   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M106_2:
   \   00000034   0x........         DC32     mks_heating_busy
   \   00000038   0x40000440         DC32     0x40000440
   8759          
   8760            /**
   8761             * M107: Fan Off
   8762             */

   \                                 In section .text, align 4
   8763            inline void gcode_M107() {
   \                     _Z10gcode_M107v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   8764              const uint16_t p = parser.ushortval('P');
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2050             MOVS     R0,#+80
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser9ushortvalEct
   8765              if (p < FAN_COUNT) 
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD104             BNE.N    ??gcode_M107_0
   8766              {
   8767          		fanSpeeds[p] = 0;
   \   0000000E   0x2000             MOVS     R0,#+0
   \   00000010   0x4902             LDR.N    R1,??gcode_M107_1
   \   00000012   0x66C8             STR      R0,[R1, #+108]
   8768          		MKS_FAN_TIM = 0 ;
   \   00000014   0x4902             LDR.N    R1,??gcode_M107_1+0x4  ;; 0x40000440
   \   00000016   0x6008             STR      R0,[R1, #+0]
   8769              }
   8770            }
   \                     ??gcode_M107_0: (+1)
   \   00000018   0xBD01             POP      {R0,PC}          ;; return
   \   0000001A   0xBF00             Nop      
   \                     ??gcode_M107_1:
   \   0000001C   0x........         DC32     mks_heating_busy
   \   00000020   0x40000440         DC32     0x40000440
   8771          
   8772          #endif // FAN_COUNT > 0
   8773          
   8774          #if DISABLED(EMERGENCY_PARSER)
   8775          
   8776            /**
   8777             * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
   8778             */

   \                                 In section .text, align 4
   8779            inline void gcode_M108() { wait_for_heatup = false; }
   \                     _Z10gcode_M108v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??gcode_M108_0
   \   00000004   0x7108             STRB     R0,[R1, #+4]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M108_0:
   \   00000008   0x........         DC32     mks_heating_busy
   8780          
   8781          
   8782            /**
   8783             * M112: Emergency Stop
   8784             */

   \                                 In section .text, align 4
   8785            inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
   \                     _Z10gcode_M112v: (+1)
   \   00000000   0x4801             LDR.N    R0,??gcode_M112_0
   \   00000002   0x.... 0x....      B.W      _Z4killPKc
   \   00000006   0xBF00             Nop      
   \                     ??gcode_M112_0:
   \   00000008   0x........         DC32     _ZZ10gcode_M112vEs
   8786          
   8787          
   8788            /**
   8789             * M410: Quickstop - Abort all planned moves
   8790             *
   8791             * This will stop the carriages mid-move, so most likely they
   8792             * will be out of sync with the stepper position after this.
   8793             */

   \                                 In section .text, align 2
   8794            inline void gcode_M410() { quickstop_stepper(); }
   \                     _Z10gcode_M410v: (+1)
   \   00000000   0x.... 0x....      B.W      _Z17quickstop_stepperv
   8795          
   8796          #endif
   8797          
   8798          /**
   8799           * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
   8800           *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
   8801           */
   8802          
   8803          #ifndef MIN_COOLING_SLOPE_DEG
   8804            #define MIN_COOLING_SLOPE_DEG 1.50
   8805          #endif
   8806          #ifndef MIN_COOLING_SLOPE_TIME
   8807            #define MIN_COOLING_SLOPE_TIME 60
   8808          #endif
   8809          

   \                                 In section .text, align 4
   8810          inline void gcode_M109() {
   \                     _Z10gcode_M109v: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   8811          
   8812            if (get_target_extruder_from_command(109)) return;
   \   00000006   0x206D             MOVS     R0,#+109
   \   00000008   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF040 0x80F9      BNE.W    ??gcode_M109_1
   8813            if (DEBUGGING(DRYRUN)) return;
   \   00000012   0x4C7D             LDR.N    R4,??gcode_M109_2
   \   00000014   0x7860             LDRB     R0,[R4, #+1]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xF100 0x80F4      BMI.W    ??gcode_M109_1
   8814          
   8815            #if ENABLED(SINGLENOZZLE)
   8816              if (target_extruder != active_extruder) return;
   8817            #endif
   8818          
   8819            const bool no_wait_for_cooling = parser.seenval('S');
   \   0000001C   0x2053             MOVS     R0,#+83
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000022   0x9001             STR      R0,[SP, #+4]
   8820            if (no_wait_for_cooling || parser.seenval('R')) {
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD105             BNE.N    ??gcode_M109_3
   \   00000028   0x2052             MOVS     R0,#+82
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xF000 0x80E8      BEQ.W    ??gcode_M109_1
   8821              const int16_t temp = parser.value_celsius();
                                          ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??gcode_M109_3: (+1)
   \   00000034   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000038   0x.... 0x....      BL       __aeabi_f2iz
   8822              thermalManager.setTargetHotend(temp, target_extruder);
   \   0000003C   0x7961             LDRB     R1,[R4, #+5]
   \   0000003E   0x460D             MOV      R5,R1
   \   00000040   0xB200             SXTH     R0,R0
   \   00000042   0x.... 0x....      BL       __aeabi_i2f
   \   00000046   0x4629             MOV      R1,R5
   \   00000048   0x.... 0x....      BL       _ZN11Temperature15setTargetHotendEfh
   8823          
   8824              #if ENABLED(DUAL_X_CARRIAGE)
   8825                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   8826                  thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
   8827              #endif
   8828          
   8829              #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   8830                /**
   8831                 * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
   8832                 * standby mode, (e.g., in a dual extruder setup) without affecting
   8833                 * the running print timer.
   8834                 */
   8835                if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000050   0x4605             MOV      R5,R0
   \   00000052   0x4E6E             LDR.N    R6,??gcode_M109_2+0x4
   \   00000054   0x486E             LDR.N    R0,??gcode_M109_2+0x8
   \   00000056   0x6AC1             LDR      R1,[R0, #+44]
   \   00000058   0xF04F 0x507C      MOV      R0,#+1056964608
   \   0000005C   0x.... 0x....      BL       __aeabi_fmul
   \   00000060   0x4629             MOV      R1,R5
   \   00000062   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000066   0x4630             MOV      R0,R6
   \   00000068   0xD806             BHI.N    ??gcode_M109_4
   8836                  print_job_timer.stop();
   \   0000006A   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   8837                  LCD_MESSAGEPGM(WELCOME_MSG);
   \   0000006E   0x2100             MOVS     R1,#+0
   \   00000070   0x4868             LDR.N    R0,??gcode_M109_2+0xC
   \   00000072   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   \   00000076   0xE001             B.N      ??gcode_M109_5
   8838                }
   8839                else
   8840                  print_job_timer.start();
   \                     ??gcode_M109_4: (+1)
   \   00000078   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   8841              #endif
   8842          
   8843              //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
   8844          	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
   \                     ??gcode_M109_5: (+1)
   \   0000007C   0x7960             LDRB     R0,[R4, #+5]
   \   0000007E   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000082   0x4605             MOV      R5,R0
   \   00000084   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000088   0x4601             MOV      R1,R0
   \   0000008A   0x4628             MOV      R0,R5
   \   0000008C   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000090   0xD21F             BCS.N    ??gcode_M109_6
   8845          	{
   8846          			switch(target_extruder)
   \   00000092   0x7960             LDRB     R0,[R4, #+5]
   \   00000094   0x2804             CMP      R0,#+4
   \   00000096   0xD81C             BHI.N    ??gcode_M109_6
   \   00000098   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??gcode_M109_0:
   \   0000009C   0x03 0x08          DC8      0x3,0x8,0xD,0x12
   \              0x0D 0x12    
   \   000000A0   0x17 0x00          DC8      0x17,0x0
   8847          			{
   8848          			case 0:
   8849          				LCD_MESSAGEPGM("E1 Heating...");
   \                     ??gcode_M109_7: (+1)
   \   000000A2   0x2100             MOVS     R1,#+0
   \   000000A4   0x485C             LDR.N    R0,??gcode_M109_2+0x10
   \   000000A6   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8850          				break;
   \   000000AA   0xE012             B.N      ??gcode_M109_6
   8851          			case 1:
   8852          				LCD_MESSAGEPGM("E2 Heating...");
   \                     ??gcode_M109_8: (+1)
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x485B             LDR.N    R0,??gcode_M109_2+0x14
   \   000000B0   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8853          				break;
   \   000000B4   0xE00D             B.N      ??gcode_M109_6
   8854          			case 2:
   8855          				LCD_MESSAGEPGM("E3 Heating...");
   \                     ??gcode_M109_9: (+1)
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x4859             LDR.N    R0,??gcode_M109_2+0x18
   \   000000BA   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8856          				break;
   \   000000BE   0xE008             B.N      ??gcode_M109_6
   8857          			case 3:
   8858          				LCD_MESSAGEPGM("E4 Heating...");
   \                     ??gcode_M109_10: (+1)
   \   000000C0   0x2100             MOVS     R1,#+0
   \   000000C2   0x4858             LDR.N    R0,??gcode_M109_2+0x1C
   \   000000C4   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8859          				break;
   \   000000C8   0xE003             B.N      ??gcode_M109_6
   8860          			case 4:
   8861          				LCD_MESSAGEPGM("E5 Heating...");
   \                     ??gcode_M109_11: (+1)
   \   000000CA   0x2100             MOVS     R1,#+0
   \   000000CC   0x4856             LDR.N    R0,??gcode_M109_2+0x20
   \   000000CE   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   8862          				break;
   8863          			default: break;
   8864          			}
   8865          	}
   8866          
   8867            }
   8868            else return;
   8869          
   8870            #if ENABLED(AUTOTEMP)
   8871              planner.autotemp_M104_M109();
   \                     ??gcode_M109_6: (+1)
   \   000000D2   0x.... 0x....      BL       _ZN7Planner18autotemp_M104_M109Ev
   8872            #endif
   8873          
   8874            #if TEMP_RESIDENCY_TIME > 0
   8875              millis_t residency_start_ms = 0;
   \   000000D6   0x2500             MOVS     R5,#+0
   8876              // Loop until the temperature has stabilized
   8877              #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
   8878            #else
   8879              // Loop until the temperature is very close target
   8880              #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
   8881            #endif
   8882          
   8883            float target_temp = -1.0, old_temp = 9999.0;
   \   000000D8   0xF8DF 0x8150      LDR.W    R8,??gcode_M109_2+0x24  ;; 0xbf800000
   \   000000DC   0x4E54             LDR.N    R6,??gcode_M109_2+0x28  ;; 0x461c3c00
   8884            bool wants_to_cool = false;
   \   000000DE   0x462F             MOV      R7,R5
   8885            wait_for_heatup = true;
   \   000000E0   0x2001             MOVS     R0,#+1
   \   000000E2   0x7120             STRB     R0,[R4, #+4]
   8886            millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \   000000E4   0x4628             MOV      R0,R5
   \   000000E6   0x9000             STR      R0,[SP, #+0]
   \   000000E8   0x4681             MOV      R9,R0
   8887          
   8888            #if DISABLED(BUSY_WHILE_HEATING)
   8889              KEEPALIVE_STATE(NOT_BUSY);
   8890            #endif
   8891          
   8892            #if ENABLED(PRINTER_EVENT_LEDS)
   8893              const float start_temp = thermalManager.degHotend(target_extruder);
   8894              uint8_t old_blue = 0;
   8895            #endif
   8896            
   8897            #if WATCH_HOTENDS
   8898              thermalManager.start_watching_heater(target_extruder);
   \   000000EA   0x7960             LDRB     R0,[R4, #+5]
   \   000000EC   0x.... 0x....      BL       _ZN11Temperature21start_watching_heaterEh
   8899            #endif
   8900                
   8901            mks_heating_busy = 1;
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x7020             STRB     R0,[R4, #+0]
   8902          
   8903            do {
   8904              // Target temperature might be changed during the loop
   8905              if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
   \                     ??gcode_M109_12: (+1)
   \   000000F4   0xF894 0xA005      LDRB     R10,[R4, #+5]
   \   000000F8   0x4650             MOV      R0,R10
   \   000000FA   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   000000FE   0x4601             MOV      R1,R0
   \   00000100   0x4640             MOV      R0,R8
   \   00000102   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000106   0xD00C             BEQ.N    ??gcode_M109_13
   8906                wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
   \   00000108   0x4650             MOV      R0,R10
   \   0000010A   0x.... 0x....      BL       _ZN11Temperature15isCoolingHotendEh
   \   0000010E   0x4607             MOV      R7,R0
   8907                target_temp = thermalManager.degTargetHotend(target_extruder);
   \   00000110   0x4650             MOV      R0,R10
   \   00000112   0x.... 0x....      BL       _ZN11Temperature15degTargetHotendEh
   \   00000116   0x4680             MOV      R8,R0
   8908          
   8909                // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   8910                if (no_wait_for_cooling && wants_to_cool) break;
   \   00000118   0x9801             LDR      R0,[SP, #+4]
   \   0000011A   0x4639             MOV      R1,R7
   \   0000011C   0xB2C0             UXTB     R0,R0
   \   0000011E   0x4208             TST      R0,R1
   \   00000120   0xD164             BNE.N    ??gcode_M109_14
   8911              }
   8912          
   8913              now = millis();
   \                     ??gcode_M109_13: (+1)
   \   00000122   0x.... 0x....      BL       HAL_GetTick
   \   00000126   0x4682             MOV      R10,R0
   8914              if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
   \   00000128   0x9800             LDR      R0,[SP, #+0]
   \   0000012A   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   0000012E   0xD421             BMI.N    ??gcode_M109_15
   8915                next_temp_ms = now + 1000UL;
   \   00000130   0xF50A 0x707A      ADD      R0,R10,#+1000
   \   00000134   0x9000             STR      R0,[SP, #+0]
   8916                thermalManager.print_heaterstates();
   \   00000136   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   8917                #if TEMP_RESIDENCY_TIME > 0
   8918                  SERIAL_PROTOCOLPGM(" W:");
   \   0000013A   0x483E             LDR.N    R0,??gcode_M109_2+0x2C
   \   0000013C   0x.... 0x....      BL       _Z14serialprintPGMPKc
   8919                  if (residency_start_ms)
   \   00000140   0xF8DF 0xB0F4      LDR.W    R11,??gcode_M109_2+0x30
   \   00000144   0x2D00             CMP      R5,#+0
   \   00000146   0xD00D             BEQ.N    ??gcode_M109_16
   8920                    SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
   \   00000148   0x220A             MOVS     R2,#+10
   \   0000014A   0xF242 0x7010      MOVW     R0,#+10000
   \   0000014E   0xEBA0 0x000A      SUB      R0,R0,R10
   \   00000152   0x1828             ADDS     R0,R5,R0
   \   00000154   0xF44F 0x717A      MOV      R1,#+1000
   \   00000158   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000015C   0x4658             MOV      R0,R11
   \   0000015E   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000162   0xE003             B.N      ??gcode_M109_17
   8921                  else
   8922                    SERIAL_PROTOCOLCHAR('?');
   \                     ??gcode_M109_16: (+1)
   \   00000164   0x213F             MOVS     R1,#+63
   \   00000166   0x4658             MOV      R0,R11
   \   00000168   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8923                #endif
   8924                SERIAL_EOL();
   \                     ??gcode_M109_17: (+1)
   \   0000016C   0x210A             MOVS     R1,#+10
   \   0000016E   0x4658             MOV      R0,R11
   \   00000170   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   8925              }
   8926          
   8927              idle();
   \                     ??gcode_M109_15: (+1)
   \   00000174   0x.... 0x....      BL       _Z4idlev
   8928              refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \   00000178   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   8929          
   8930              const float temp = thermalManager.degHotend(target_extruder);
   \   0000017C   0x7960             LDRB     R0,[R4, #+5]
   \   0000017E   0x.... 0x....      BL       _ZN11Temperature9degHotendEh
   \   00000182   0x4683             MOV      R11,R0
   8931          
   8932              #if ENABLED(PRINTER_EVENT_LEDS)
   8933                // Gradually change LED strip from violet to red as nozzle heats up
   8934                if (!wants_to_cool) {
   8935                  const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
   8936                  if (blue != old_blue) {
   8937                    old_blue = blue;
   8938                    leds.set_color(
   8939                      MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
   8940                      #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
   8941                        , true
   8942                      #endif
   8943                    );
   8944                  }
   8945                }
   8946              #endif
   8947          
   8948              #if TEMP_RESIDENCY_TIME > 0
   8949          
   8950                const float temp_diff = FABS(target_temp - temp);
   \   00000184   0x4640             MOV      R0,R8
   \   00000186   0x4659             MOV      R1,R11
   \   00000188   0x.... 0x....      BL       __aeabi_fsub
   \   0000018C   0xF020 0x4000      BIC      R0,R0,#0x80000000
   8951          
   8952                if (!residency_start_ms) {
   \   00000190   0x2D00             CMP      R5,#+0
   \   00000192   0xD106             BNE.N    ??gcode_M109_18
   8953                  // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
   8954                  if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
   \   00000194   0xF04F 0x517E      MOV      R1,#+1065353216
   \   00000198   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000019C   0xD206             BCS.N    ??gcode_M109_19
   \   0000019E   0x4655             MOV      R5,R10
   \   000001A0   0xE004             B.N      ??gcode_M109_19
   8955                }
   8956                else if (temp_diff > TEMP_HYSTERESIS) {
   \                     ??gcode_M109_18: (+1)
   \   000001A2   0x4926             LDR.N    R1,??gcode_M109_2+0x34  ;; 0x40000001
   \   000001A4   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000001A8   0xD800             BHI.N    ??gcode_M109_19
   8957                  // Restart the timer whenever the temperature falls outside the hysteresis.
   8958                  residency_start_ms = now;
   \   000001AA   0x4655             MOV      R5,R10
   8959                }
   8960          
   8961              #endif
   8962          
   8963              // Prevent a wait-forever situation if R is misused i.e. M109 R0
   8964              if (wants_to_cool) {
   \                     ??gcode_M109_19: (+1)
   \   000001AC   0x2F00             CMP      R7,#+0
   \   000001AE   0xD013             BEQ.N    ??gcode_M109_20
   8965                // break after MIN_COOLING_SLOPE_TIME seconds
   8966                // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
   8967                if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \   000001B0   0xF1B9 0x0F00      CMP      R9,#+0
   \   000001B4   0xD002             BEQ.N    ??gcode_M109_21
   \   000001B6   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   000001BA   0xD40D             BMI.N    ??gcode_M109_20
   8968                  if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
   \                     ??gcode_M109_21: (+1)
   \   000001BC   0x4630             MOV      R0,R6
   \   000001BE   0x4659             MOV      R1,R11
   \   000001C0   0x.... 0x....      BL       __aeabi_fsub
   \   000001C4   0xF04F 0x517F      MOV      R1,#+1069547520
   \   000001C8   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001CC   0xD30E             BCC.N    ??gcode_M109_14
   8969                  next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
   \   000001CE   0xF50A 0x496A      ADD      R9,R10,#+59904
   \   000001D2   0xF109 0x0960      ADD      R9,R9,#+96
   8970                  old_temp = temp;
   \   000001D6   0x465E             MOV      R6,R11
   8971                }
   8972              }
   8973          
   8974            } while (wait_for_heatup && TEMP_CONDITIONS);
   \                     ??gcode_M109_20: (+1)
   \   000001D8   0x7920             LDRB     R0,[R4, #+4]
   \   000001DA   0x2800             CMP      R0,#+0
   \   000001DC   0xD006             BEQ.N    ??gcode_M109_14
   \   000001DE   0x2D00             CMP      R5,#+0
   \   000001E0   0xD088             BEQ.N    ??gcode_M109_12
   \   000001E2   0xEBAA 0x0005      SUB      R0,R10,R5
   \   000001E6   0x4916             LDR.N    R1,??gcode_M109_2+0x38  ;; 0xffffd8f0
   \   000001E8   0x1808             ADDS     R0,R1,R0
   \   000001EA   0xD483             BMI.N    ??gcode_M109_12
   8975            
   8976            mks_heating_busy = 0;
   \                     ??gcode_M109_14: (+1)
   \   000001EC   0x2000             MOVS     R0,#+0
   \   000001EE   0x7020             STRB     R0,[R4, #+0]
   8977          
   8978            if (wait_for_heatup) {
   \   000001F0   0x7920             LDRB     R0,[R4, #+4]
   \   000001F2   0x2800             CMP      R0,#+0
   \   000001F4   0xD006             BEQ.N    ??gcode_M109_1
   8979              LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
   \   000001F6   0x2100             MOVS     R1,#+0
   \   000001F8   0x4812             LDR.N    R0,??gcode_M109_2+0x3C
   \   000001FA   0xB003             ADD      SP,SP,#+12
   \   000001FC   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000200   0x.... 0x....      B.W      _Z16lcd_setstatusPGMPKca
   8980              #if ENABLED(PRINTER_EVENT_LEDS)
   8981                leds.set_white();
   8982              #endif
   8983            }
   8984          
   8985            #if DISABLED(BUSY_WHILE_HEATING)
   8986              KEEPALIVE_STATE(IN_HANDLER);
   8987            #endif
   8988          }
   \                     ??gcode_M109_1: (+1)
   \   00000204   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \                     ??gcode_M109_2:
   \   00000208   0x........         DC32     mks_heating_busy
   \   0000020C   0x........         DC32     card+0xD6C
   \   00000210   0x........         DC32     mksCfg
   \   00000214   0x........         DC32     _ZZ10gcode_M109vEs
   \   00000218   0x........         DC32     _ZZ10gcode_M109vEs_0
   \   0000021C   0x........         DC32     _ZZ10gcode_M109vEs_1
   \   00000220   0x........         DC32     _ZZ10gcode_M109vEs_2
   \   00000224   0x........         DC32     _ZZ10gcode_M109vEs_3
   \   00000228   0x........         DC32     _ZZ10gcode_M109vEs_4
   \   0000022C   0xBF800000         DC32     0xbf800000
   \   00000230   0x461C3C00         DC32     0x461c3c00
   \   00000234   0x........         DC32     _ZZ10gcode_M109vEs_5
   \   00000238   0x........         DC32     Serial3
   \   0000023C   0x40000001         DC32     0x40000001
   \   00000240   0xFFFFD8F0         DC32     0xffffd8f0
   \   00000244   0x........         DC32     _ZZ10gcode_M109vEs_6
   8989          
   8990          #if 1//HAS_TEMP_BED
   8991          
   8992            #ifndef MIN_COOLING_SLOPE_DEG_BED
   8993              #define MIN_COOLING_SLOPE_DEG_BED 1.50
   8994            #endif
   8995            #ifndef MIN_COOLING_SLOPE_TIME_BED
   8996              #define MIN_COOLING_SLOPE_TIME_BED 60
   8997            #endif
   8998          
   8999            /**
   9000             * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
   9001             *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
   9002             */

   \                                 In section .text, align 4
   9003            inline void gcode_M190() {
   \                     _Z10gcode_M190v: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB083             SUB      SP,SP,#+12
   9004              if (DEBUGGING(DRYRUN)) return;
   \   00000006   0x4C5A             LDR.N    R4,??gcode_M190_0
   \   00000008   0x7860             LDRB     R0,[R4, #+1]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xF100 0x80AD      BMI.W    ??gcode_M190_1
   9005          
   9006              LCD_MESSAGEPGM(MSG_BED_HEATING);
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x4858             LDR.N    R0,??gcode_M190_0+0x4
   \   00000014   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
   9007              const bool no_wait_for_cooling = parser.seenval('S');
   \   00000018   0x2053             MOVS     R0,#+83
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001E   0x9001             STR      R0,[SP, #+4]
   9008              if (no_wait_for_cooling || parser.seenval('R')) {
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD105             BNE.N    ??gcode_M190_2
   \   00000024   0x2052             MOVS     R0,#+82
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xF000 0x809D      BEQ.W    ??gcode_M190_1
   9009                thermalManager.setTargetBed(parser.value_celsius());
   \                     ??gcode_M190_2: (+1)
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000034   0x.... 0x....      BL       _ZN11Temperature12setTargetBedEf
   9010                #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
   9011                  if (parser.value_celsius() > BED_MINTEMP)
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000003C   0x494E             LDR.N    R1,??gcode_M190_0+0x8  ;; 0x40a00001
   \   0000003E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000042   0xD802             BHI.N    ??gcode_M190_3
   9012                    print_job_timer.start();
   \   00000044   0x484D             LDR.N    R0,??gcode_M190_0+0xC
   \   00000046   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   9013                #endif
   9014              }
   9015              else return;
   9016          
   9017              #if TEMP_BED_RESIDENCY_TIME > 0
   9018                millis_t residency_start_ms = 0;
   \                     ??gcode_M190_3: (+1)
   \   0000004A   0x2500             MOVS     R5,#+0
   9019                // Loop until the temperature has stabilized
   9020                #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
   9021              #else
   9022                // Loop until the temperature is very close target
   9023                #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
   9024              #endif
   9025          
   9026              float target_temp = -1.0, old_temp = 9999.0;
   \   0000004C   0xF8DF 0x8130      LDR.W    R8,??gcode_M190_0+0x10  ;; 0xbf800000
   \   00000050   0x4E4C             LDR.N    R6,??gcode_M190_0+0x14  ;; 0x461c3c00
   9027              bool wants_to_cool = false;
   \   00000052   0x462F             MOV      R7,R5
   9028              wait_for_heatup = true;
   \   00000054   0x2001             MOVS     R0,#+1
   \   00000056   0x7120             STRB     R0,[R4, #+4]
   9029              millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
   \   00000058   0x4628             MOV      R0,R5
   \   0000005A   0x9000             STR      R0,[SP, #+0]
   \   0000005C   0x4681             MOV      R9,R0
   9030          
   9031              #if DISABLED(BUSY_WHILE_HEATING)
   9032                KEEPALIVE_STATE(NOT_BUSY);
   9033              #endif
   9034          
   9035              target_extruder = active_extruder; // for print_heaterstates
   \   0000005E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000060   0x7160             STRB     R0,[R4, #+5]
   9036          
   9037              #if ENABLED(PRINTER_EVENT_LEDS)
   9038                const float start_temp = thermalManager.degBed();
   9039                uint8_t old_red = 255;
   9040              #endif
   9041          	mks_heating_busy = 1;
   \   00000062   0x2001             MOVS     R0,#+1
   \   00000064   0x7020             STRB     R0,[R4, #+0]
   9042          
   9043              do {
   9044                // Target temperature might be changed during the loop
   9045                if (target_temp != thermalManager.degTargetBed()) {
   \                     ??gcode_M190_4: (+1)
   \   00000066   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000072   0xD00A             BEQ.N    ??gcode_M190_5
   9046                  wants_to_cool = thermalManager.isCoolingBed();
   \   00000074   0x.... 0x....      BL       _ZN11Temperature12isCoolingBedEv
   \   00000078   0x4607             MOV      R7,R0
   9047                  target_temp = thermalManager.degTargetBed();
   \   0000007A   0x.... 0x....      BL       _ZN11Temperature12degTargetBedEv
   \   0000007E   0x4680             MOV      R8,R0
   9048          
   9049                  // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
   9050                  if (no_wait_for_cooling && wants_to_cool) break;
   \   00000080   0x9801             LDR      R0,[SP, #+4]
   \   00000082   0x4639             MOV      R1,R7
   \   00000084   0xB2C0             UXTB     R0,R0
   \   00000086   0x4208             TST      R0,R1
   \   00000088   0xD163             BNE.N    ??gcode_M190_6
   9051                }
   9052          
   9053                now = millis();
   \                     ??gcode_M190_5: (+1)
   \   0000008A   0x.... 0x....      BL       HAL_GetTick
   \   0000008E   0x4682             MOV      R10,R0
   9054                if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
   \   00000090   0x9800             LDR      R0,[SP, #+0]
   \   00000092   0xEBBA 0x0000      SUBS     R0,R10,R0
   \   00000096   0xD421             BMI.N    ??gcode_M190_7
   9055                  next_temp_ms = now + 1000UL;
   \   00000098   0xF50A 0x707A      ADD      R0,R10,#+1000
   \   0000009C   0x9000             STR      R0,[SP, #+0]
   9056                  thermalManager.print_heaterstates();
   \   0000009E   0x.... 0x....      BL       _ZN11Temperature18print_heaterstatesEv
   9057                  #if TEMP_BED_RESIDENCY_TIME > 0
   9058                    SERIAL_PROTOCOLPGM(" W:");
   \   000000A2   0x4839             LDR.N    R0,??gcode_M190_0+0x18
   \   000000A4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9059                    if (residency_start_ms)
   \   000000A8   0xF8DF 0xB0E0      LDR.W    R11,??gcode_M190_0+0x1C
   \   000000AC   0x2D00             CMP      R5,#+0
   \   000000AE   0xD00D             BEQ.N    ??gcode_M190_8
   9060                      SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
   \   000000B0   0x220A             MOVS     R2,#+10
   \   000000B2   0xF242 0x7010      MOVW     R0,#+10000
   \   000000B6   0xEBA0 0x000A      SUB      R0,R0,R10
   \   000000BA   0x1828             ADDS     R0,R5,R0
   \   000000BC   0xF44F 0x717A      MOV      R1,#+1000
   \   000000C0   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   000000C4   0x4658             MOV      R0,R11
   \   000000C6   0x.... 0x....      BL       _ZN5Print5printEli
   \   000000CA   0xE003             B.N      ??gcode_M190_9
   9061                    else
   9062                      SERIAL_PROTOCOLCHAR('?');
   \                     ??gcode_M190_8: (+1)
   \   000000CC   0x213F             MOVS     R1,#+63
   \   000000CE   0x4658             MOV      R0,R11
   \   000000D0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9063                  #endif
   9064                  SERIAL_EOL();
   \                     ??gcode_M190_9: (+1)
   \   000000D4   0x210A             MOVS     R1,#+10
   \   000000D6   0x4658             MOV      R0,R11
   \   000000D8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9065                }
   9066          
   9067                idle();
   \                     ??gcode_M190_7: (+1)
   \   000000DC   0x.... 0x....      BL       _Z4idlev
   9068                refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
   \   000000E0   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
   9069          
   9070                const float temp = thermalManager.degBed();
   \   000000E4   0x.... 0x....      BL       _ZN11Temperature6degBedEv
   \   000000E8   0x4683             MOV      R11,R0
   9071          
   9072                #if ENABLED(PRINTER_EVENT_LEDS)
   9073                  // Gradually change LED strip from blue to violet as bed heats up
   9074                  if (!wants_to_cool) {
   9075                    const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
   9076                    if (red != old_red) {
   9077                      old_red = red;
   9078                      leds.set_color(
   9079                        MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
   9080                        #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
   9081                          , true
   9082                        #endif
   9083                      );
   9084                    }
   9085                  }
   9086                #endif
   9087          
   9088                #if TEMP_BED_RESIDENCY_TIME > 0
   9089          
   9090                  const float temp_diff = FABS(target_temp - temp);
   \   000000EA   0x4640             MOV      R0,R8
   \   000000EC   0x4659             MOV      R1,R11
   \   000000EE   0x.... 0x....      BL       __aeabi_fsub
   \   000000F2   0xF020 0x4000      BIC      R0,R0,#0x80000000
   9091          
   9092                  if (!residency_start_ms) {
   \   000000F6   0x2D00             CMP      R5,#+0
   \   000000F8   0xD106             BNE.N    ??gcode_M190_10
   9093                    // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
   9094                    if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
   \   000000FA   0xF04F 0x517E      MOV      R1,#+1065353216
   \   000000FE   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000102   0xD206             BCS.N    ??gcode_M190_11
   \   00000104   0x4655             MOV      R5,R10
   \   00000106   0xE004             B.N      ??gcode_M190_11
   9095                  }
   9096                  else if (temp_diff > TEMP_BED_HYSTERESIS) {
   \                     ??gcode_M190_10: (+1)
   \   00000108   0x4921             LDR.N    R1,??gcode_M190_0+0x20  ;; 0x40000001
   \   0000010A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000010E   0xD800             BHI.N    ??gcode_M190_11
   9097                    // Restart the timer whenever the temperature falls outside the hysteresis.
   9098                    residency_start_ms = now;
   \   00000110   0x4655             MOV      R5,R10
   9099                  }
   9100          
   9101                #endif // TEMP_BED_RESIDENCY_TIME > 0
   9102          
   9103                // Prevent a wait-forever situation if R is misused i.e. M190 R0
   9104                if (wants_to_cool) {
   \                     ??gcode_M190_11: (+1)
   \   00000112   0x2F00             CMP      R7,#+0
   \   00000114   0xD013             BEQ.N    ??gcode_M190_12
   9105                  // Break after MIN_COOLING_SLOPE_TIME_BED seconds
   9106                  // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
   9107                  if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
   \   00000116   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000011A   0xD002             BEQ.N    ??gcode_M190_13
   \   0000011C   0xEBBA 0x0009      SUBS     R0,R10,R9
   \   00000120   0xD40D             BMI.N    ??gcode_M190_12
   9108                    if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
   \                     ??gcode_M190_13: (+1)
   \   00000122   0x4630             MOV      R0,R6
   \   00000124   0x4659             MOV      R1,R11
   \   00000126   0x.... 0x....      BL       __aeabi_fsub
   \   0000012A   0xF04F 0x517F      MOV      R1,#+1069547520
   \   0000012E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000132   0xD30E             BCC.N    ??gcode_M190_6
   9109                    next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
   \   00000134   0xF50A 0x496A      ADD      R9,R10,#+59904
   \   00000138   0xF109 0x0960      ADD      R9,R9,#+96
   9110                    old_temp = temp;
   \   0000013C   0x465E             MOV      R6,R11
   9111                  }
   9112                }
   9113          
   9114              } while (wait_for_heatup && TEMP_BED_CONDITIONS);
   \                     ??gcode_M190_12: (+1)
   \   0000013E   0x7920             LDRB     R0,[R4, #+4]
   \   00000140   0x2800             CMP      R0,#+0
   \   00000142   0xD006             BEQ.N    ??gcode_M190_6
   \   00000144   0x2D00             CMP      R5,#+0
   \   00000146   0xD08E             BEQ.N    ??gcode_M190_4
   \   00000148   0xEBAA 0x0005      SUB      R0,R10,R5
   \   0000014C   0x4911             LDR.N    R1,??gcode_M190_0+0x24  ;; 0xffffd8f0
   \   0000014E   0x1808             ADDS     R0,R1,R0
   \   00000150   0xD489             BMI.N    ??gcode_M190_4
   9115          
   9116          	mks_heating_busy = 0;
   \                     ??gcode_M190_6: (+1)
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0x7020             STRB     R0,[R4, #+0]
   9117          
   9118              if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
   \   00000156   0x7920             LDRB     R0,[R4, #+4]
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD006             BEQ.N    ??gcode_M190_1
   \   0000015C   0x2100             MOVS     R1,#+0
   \   0000015E   0x480E             LDR.N    R0,??gcode_M190_0+0x28
   \   00000160   0xB003             ADD      SP,SP,#+12
   \   00000162   0xE8BD 0x4FF0      POP      {R4-R11,LR}
   \   00000166   0x.... 0x....      B.W      _Z16lcd_setstatusPGMPKca
   9119              #if DISABLED(BUSY_WHILE_HEATING)
   9120                KEEPALIVE_STATE(IN_HANDLER);
   9121              #endif
   9122            }
   \                     ??gcode_M190_1: (+1)
   \   0000016A   0xE8BD 0x8FF7      POP      {R0-R2,R4-R11,PC}  ;; return
   \   0000016E   0xBF00             Nop      
   \                     ??gcode_M190_0:
   \   00000170   0x........         DC32     mks_heating_busy
   \   00000174   0x........         DC32     _ZZ10gcode_M190vEs
   \   00000178   0x40A00001         DC32     0x40a00001
   \   0000017C   0x........         DC32     card+0xD6C
   \   00000180   0xBF800000         DC32     0xbf800000
   \   00000184   0x461C3C00         DC32     0x461c3c00
   \   00000188   0x........         DC32     _ZZ10gcode_M190vEs_0
   \   0000018C   0x........         DC32     Serial3
   \   00000190   0x40000001         DC32     0x40000001
   \   00000194   0xFFFFD8F0         DC32     0xffffd8f0
   \   00000198   0x........         DC32     _ZZ10gcode_M190vEs_1
   9123          
   9124          #endif // HAS_TEMP_BED
   9125          
   9126          /**
   9127           * M110: Set Current Line Number
   9128           */

   \                                 In section .text, align 4
   9129          inline void gcode_M110() {
   \                     _Z10gcode_M110v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9130            if (parser.seenval('N')) gcode_LastN = parser.value_long();
   \   00000002   0x204E             MOVS     R0,#+78
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M110_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_longEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M110_1
   \   00000012   0x62C8             STR      R0,[R1, #+44]
   9131          }
   \                     ??gcode_M110_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M110_1:
   \   00000018   0x........         DC32     axis_relative_modes
   9132          
   9133          /**
   9134           * M111: Set the debug level
   9135           */

   \                                 In section .text, align 4
   9136          inline void gcode_M111() {
   \                     _Z10gcode_M111v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   9137            if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
   \   00000002   0x4C1B             LDR.N    R4,??gcode_M111_0
   \   00000004   0x2053             MOVS     R0,#+83
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD004             BEQ.N    ??gcode_M111_1
   \   0000000E   0x2100             MOVS     R1,#+0
   \   00000010   0x2053             MOVS     R0,#+83
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   00000016   0x7060             STRB     R0,[R4, #+1]
   9138          
   9139            const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
   9140                              str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
   9141                              str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
   9142                              str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
   9143                              str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
   9144                              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9145                                , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
   9146                              #endif
   9147                              ;
   9148          
   9149            const static char* const debug_strings[] PROGMEM = {
   9150              str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
   9151              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9152                , str_debug_32
   9153              #endif
   9154            };
   9155          
   9156            SERIAL_ECHO_START();
   \                     ??gcode_M111_1: (+1)
   \   00000018   0x4816             LDR.N    R0,??gcode_M111_0+0x4
   \   0000001A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9157            SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
   \   0000001E   0x4816             LDR.N    R0,??gcode_M111_0+0x8
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9158            if (marlin_debug_flags) {
   \   00000024   0x7860             LDRB     R0,[R4, #+1]
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD018             BEQ.N    ??gcode_M111_2
   9159              uint8_t comma = 0;
   \   0000002A   0x2600             MOVS     R6,#+0
   9160              for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
   \   0000002C   0x4635             MOV      R5,R6
   \                     ??gcode_M111_3: (+1)
   \   0000002E   0x2D05             CMP      R5,#+5
   \   00000030   0xD217             BCS.N    ??gcode_M111_4
   9161                if (TEST(marlin_debug_flags, i)) {
   \   00000032   0x7860             LDRB     R0,[R4, #+1]
   \   00000034   0x2101             MOVS     R1,#+1
   \   00000036   0x40A9             LSLS     R1,R1,R5
   \   00000038   0x4208             TST      R0,R1
   \   0000003A   0xD00D             BEQ.N    ??gcode_M111_5
   9162                  if (comma++) SERIAL_CHAR(',');
   \   0000003C   0x4630             MOV      R0,R6
   \   0000003E   0x1C46             ADDS     R6,R0,#+1
   \   00000040   0xB2C0             UXTB     R0,R0
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD003             BEQ.N    ??gcode_M111_6
   \   00000046   0x212C             MOVS     R1,#+44
   \   00000048   0x480C             LDR.N    R0,??gcode_M111_0+0xC
   \   0000004A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9163                  //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
   9164                  serialprintPGM((char*)&(debug_strings[i]));
   \                     ??gcode_M111_6: (+1)
   \   0000004E   0x480C             LDR.N    R0,??gcode_M111_0+0x10
   \   00000050   0xEB00 0x0085      ADD      R0,R0,R5, LSL #+2
   \   00000054   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9165                }
   9166              }
   \                     ??gcode_M111_5: (+1)
   \   00000058   0x1C6D             ADDS     R5,R5,#+1
   \   0000005A   0xE7E8             B.N      ??gcode_M111_3
   9167            }
   9168            else {
   9169              SERIAL_ECHOPGM(MSG_DEBUG_OFF);
   \                     ??gcode_M111_2: (+1)
   \   0000005C   0x4809             LDR.N    R0,??gcode_M111_0+0x14
   \   0000005E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9170            }
   9171            SERIAL_EOL();
   \                     ??gcode_M111_4: (+1)
   \   00000062   0x210A             MOVS     R1,#+10
   \   00000064   0x4805             LDR.N    R0,??gcode_M111_0+0xC
   \   00000066   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006A   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000006E   0xBF00             Nop      
   \                     ??gcode_M111_0:
   \   00000070   0x........         DC32     mks_heating_busy
   \   00000074   0x........         DC32     echomagic
   \   00000078   0x........         DC32     _ZZ10gcode_M111vEs_4
   \   0000007C   0x........         DC32     Serial3
   \   00000080   0x........         DC32     _ZZ10gcode_M111vE13debug_strings
   \   00000084   0x........         DC32     _ZZ10gcode_M111vEs_5
   9172          }

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_1:
   \   00000000   0x45 0x43          DC8 "ECHO"
   \              0x48 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_2:
   \   00000000   0x49 0x4E          DC8 "INFO"
   \              0x46 0x4F    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_4:
   \   00000000   0x45 0x52          DC8 "ERRORS"
   \              0x52 0x4F    
   \              0x52 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE11str_debug_8:
   \   00000000   0x44 0x52          DC8 "DRYRUN"
   \              0x59 0x52    
   \              0x55 0x4E    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE12str_debug_16:
   \   00000000   0x43 0x4F          DC8 "COMMUNICATION"
   \              0x4D 0x4D    
   \              0x55 0x4E    
   \              0x49 0x43    
   \              0x41 0x54    
   \              0x49 0x4F    
   \              0x4E 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     _ZZ10gcode_M111vE13debug_strings:
   \   00000000   0x........         DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
   \              0x........   
   \   00000008   0x........         DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
   \              0x........   
   \   00000010   0x........         DC32 _ZZ10gcode_M111vE12str_debug_16
   9173          
   9174          #if ENABLED(HOST_KEEPALIVE_FEATURE)
   9175          
   9176            /**
   9177             * M113: Get or set Host Keepalive interval (0 to disable)
   9178             *
   9179             *   S<seconds> Optional. Set the keepalive interval.
   9180             */

   \                                 In section .text, align 4
   9181            inline void gcode_M113() {
   \                     _Z10gcode_M113v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9182              if (parser.seenval('S')) {
   \   00000002   0x4C0E             LDR.N    R4,??gcode_M113_0
   \   00000004   0x2053             MOVS     R0,#+83
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD007             BEQ.N    ??gcode_M113_1
   9183                host_keepalive_interval = parser.value_byte();
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser10value_byteEv
   \   00000012   0x71E0             STRB     R0,[R4, #+7]
   9184                NOMORE(host_keepalive_interval, 60);
   \   00000014   0x283D             CMP      R0,#+61
   \   00000016   0xDB0F             BLT.N    ??gcode_M113_2
   \   00000018   0x203C             MOVS     R0,#+60
   \   0000001A   0x71E0             STRB     R0,[R4, #+7]
   \   0000001C   0xBD10             POP      {R4,PC}
   9185              }
   9186              else {
   9187                SERIAL_ECHO_START();
   \                     ??gcode_M113_1: (+1)
   \   0000001E   0x4808             LDR.N    R0,??gcode_M113_0+0x4
   \   00000020   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9188                SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
   \   00000024   0x79E1             LDRB     R1,[R4, #+7]
   \   00000026   0x4807             LDR.N    R0,??gcode_M113_0+0x8
   \   00000028   0x.... 0x....      BL       _Z17serial_echopair_PPKcm
   \   0000002C   0x210A             MOVS     R1,#+10
   \   0000002E   0x4806             LDR.N    R0,??gcode_M113_0+0xC
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9189              }
   9190            }
   \                     ??gcode_M113_2: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
   \   0000003A   0xBF00             Nop      
   \                     ??gcode_M113_0:
   \   0000003C   0x........         DC32     axis_relative_modes
   \   00000040   0x........         DC32     echomagic
   \   00000044   0x........         DC32     _ZZ10gcode_M113vEs
   \   00000048   0x........         DC32     Serial3
   9191          
   9192          #endif
   9193          
   9194          #if ENABLED(BARICUDA)
   9195          
   9196            #if HAS_HEATER_1
   9197              /**
   9198               * M126: Heater 1 valve open
   9199               */
   9200              inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
   9201              /**
   9202               * M127: Heater 1 valve close
   9203               */
   9204              inline void gcode_M127() { baricuda_valve_pressure = 0; }
   9205            #endif
   9206          
   9207            #if HAS_HEATER_2
   9208              /**
   9209               * M128: Heater 2 valve open
   9210               */
   9211              inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
   9212              /**
   9213               * M129: Heater 2 valve close
   9214               */
   9215              inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
   9216            #endif
   9217          
   9218          #endif // BARICUDA
   9219          
   9220          /**
   9221           * M140: Set bed temperature
   9222           */

   \                                 In section .text, align 4
   9223          inline void gcode_M140() {
   9224            if (DEBUGGING(DRYRUN)) return;
   \                     _Z10gcode_M140v: (+1)
   \   00000000   0x4808             LDR.N    R0,??gcode_M140_0
   \   00000002   0x7840             LDRB     R0,[R0, #+1]
   \   00000004   0x0700             LSLS     R0,R0,#+28
   \   00000006   0xD500             BPL.N    ??gcode_M140_1
   \   00000008   0x4770             BX       LR
   9225            if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
   \                     ??gcode_M140_1: (+1)
   \   0000000A   0xB580             PUSH     {R7,LR}
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD005             BEQ.N    ??gcode_M140_2
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   0000001A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000001E   0x.... 0x....      B.W      _ZN11Temperature12setTargetBedEf
   9226          }
   \                     ??gcode_M140_2: (+1)
   \   00000022   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M140_0:
   \   00000024   0x........         DC32     mks_heating_busy
   9227          
   9228          #if ENABLED(ULTIPANEL)
   9229          
   9230            /**
   9231             * M145: Set the heatup state for a material in the LCD menu
   9232             *
   9233             *   S<material> (0=PLA, 1=ABS)
   9234             *   H<hotend temp>
   9235             *   B<bed temp>
   9236             *   F<fan speed>
   9237             */
   9238            inline void gcode_M145() {
   9239              const uint8_t material = (uint8_t)parser.intval('S');
   9240              if (material >= COUNT(lcd_preheat_hotend_temp)) {
   9241                SERIAL_ERROR_START();
   9242                SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
   9243              }
   9244              else {
   9245                int v;
   9246                if (parser.seenval('H')) {
   9247                  v = parser.value_int();
   9248                  lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
   9249                }
   9250                if (parser.seenval('F')) {
   9251                  v = parser.value_int();
   9252                  lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
   9253                }
   9254                #if TEMP_SENSOR_BED != 0
   9255                  if (parser.seenval('B')) {
   9256                    v = parser.value_int();
   9257                    lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
   9258                  }
   9259                #endif
   9260              }
   9261            }
   9262          
   9263          #endif // ULTIPANEL
   9264          
   9265          #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   9266            /**
   9267             * M149: Set temperature units
   9268             */
   9269            inline void gcode_M149() {
   9270                   if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
   9271              else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
   9272              else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
   9273            }
   9274          #endif
   9275          
   9276          #if HAS_POWER_SWITCH
   9277          
   9278            /**
   9279             * M80   : Turn on the Power Supply
   9280             * M80 S : Report the current state and exit
   9281             */
   9282            inline void gcode_M80() {
   9283          
   9284              // S: Report the current power supply state and exit
   9285              if (parser.seen('S')) {
   9286                serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
   9287                return;
   9288              }
   9289          
   9290              OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
   9291          
   9292              /**
   9293               * If you have a switch on suicide pin, this is useful
   9294               * if you want to start another print with suicide feature after
   9295               * a print without suicide...
   9296               */
   9297              #if HAS_SUICIDE
   9298                OUT_WRITE(SUICIDE_PIN, HIGH);
   9299              #endif
   9300          
   9301              #if ENABLED(HAVE_TMC2130)
   9302                delay(100);
   9303                tmc2130_init(); // Settings only stick when the driver has power
   9304              #endif
   9305          
   9306              powersupply_on = true;
   9307          
   9308              #if ENABLED(ULTIPANEL)
   9309                LCD_MESSAGEPGM(WELCOME_MSG);
   9310              #endif
   9311          
   9312              #if ENABLED(HAVE_TMC2208)
   9313                delay(100);
   9314                tmc2208_init();
   9315              #endif
   9316            }
   9317          
   9318          #endif // HAS_POWER_SWITCH
   9319          
   9320          /**
   9321           * M81: Turn off Power, including Power Supply, if there is one.
   9322           *
   9323           *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
   9324           */

   \                                 In section .text, align 4
   9325          inline void gcode_M81() {
   \                     _Z9gcode_M81v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9326            thermalManager.disable_all_heaters();
   \   00000002   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   9327            stepper.finish_and_disable();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper18finish_and_disableEv
   9328          
   9329            #if FAN_COUNT > 0
   9330              for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4906             LDR.N    R1,??gcode_M81_0
   \   0000000E   0xE002             B.N      ??gcode_M81_1
   \                     ??gcode_M81_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \   00000012   0x66C8             STR      R0,[R1, #+108]
   \   00000014   0x2001             MOVS     R0,#+1
   \                     ??gcode_M81_1: (+1)
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD0FA             BEQ.N    ??gcode_M81_2
   9331              #if ENABLED(PROBING_FANS_OFF)
   9332                fans_paused = false;
   9333                ZERO(paused_fanSpeeds);
   9334              #endif
   9335            #endif
   9336          
   9337            safe_delay(1000); // Wait 1 second before switching off
   \   0000001A   0xF44F 0x707A      MOV      R0,#+1000
   \   0000001E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000022   0x.... 0x....      B.W      _Z10safe_delaym
   \   00000026   0xBF00             Nop      
   \                     ??gcode_M81_0:
   \   00000028   0x........         DC32     mks_heating_busy
   9338          
   9339            #if HAS_SUICIDE
   9340              stepper.synchronize();
   9341              suicide();
   9342            #elif HAS_POWER_SWITCH
   9343              OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   9344              powersupply_on = false;
   9345            #endif
   9346          
   9347            #if ENABLED(ULTIPANEL)
   9348              //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
   9349                if(LCD_LANGUAGE)
   9350                  LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
   9351                else
   9352                  LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");    
   9353            #endif
   9354          }
   9355          
   9356          /**
   9357           * M82: Set E codes absolute (default)
   9358           */

   \                                 In section .text, align 4
   9359          inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
   \                     _Z9gcode_M82v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x4901             LDR.N    R1,??gcode_M82_0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M82_0:
   \   00000008   0x........         DC32     axis_relative_modes
   9360          
   9361          /**
   9362           * M83: Set E codes relative while in Absolute Coordinates (G90) mode
   9363           */

   \                                 In section .text, align 4
   9364          inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
   \                     _Z9gcode_M83v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x4901             LDR.N    R1,??gcode_M83_0
   \   00000004   0x70C8             STRB     R0,[R1, #+3]
   \   00000006   0x4770             BX       LR               ;; return
   \                     ??gcode_M83_0:
   \   00000008   0x........         DC32     axis_relative_modes
   9365          
   9366          /**
   9367           * M18, M84: Disable stepper motors
   9368           */

   \                                 In section .text, align 4
   9369          inline void gcode_M18_M84() {
   \                     _Z13gcode_M18_M84v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   9370            if (parser.seenval('S')) {
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD004             BEQ.N    ??gcode_M18_M84_0
   9371              stepper_inactive_time = parser.value_millis_from_seconds();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000010   0x4939             LDR.N    R1,??gcode_M18_M84_1
   \   00000012   0x6648             STR      R0,[R1, #+100]
   \   00000014   0xBD70             POP      {R4-R6,PC}
   9372            }
   9373            else {
   9374              bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
   \                     ??gcode_M18_M84_0: (+1)
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD111             BNE.N    ??gcode_M18_M84_2
   \   00000020   0x2059             MOVS     R0,#+89
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD10C             BNE.N    ??gcode_M18_M84_2
   \   0000002A   0x205A             MOVS     R0,#+90
   \   0000002C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD107             BNE.N    ??gcode_M18_M84_2
   \   00000034   0x2045             MOVS     R0,#+69
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003A   0xF000 0x0001      AND      R0,R0,#0x1
   \   0000003E   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000042   0xE000             B.N      ??gcode_M18_M84_3
   \                     ??gcode_M18_M84_2: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   9375              if (all_axis) {
   \                     ??gcode_M18_M84_3: (+1)
   \   00000046   0x2800             CMP      R0,#+0
   \   00000048   0xD003             BEQ.N    ??gcode_M18_M84_4
   9376                stepper.finish_and_disable();
   \   0000004A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000004E   0x.... 0x....      B.W      _ZN7Stepper18finish_and_disableEv
   9377              }
   9378              else {
   9379                stepper.synchronize();
   \                     ??gcode_M18_M84_4: (+1)
   \   00000052   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9380                if (parser.seen('X')) disable_X();
   \   00000056   0x2058             MOVS     R0,#+88
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD00F             BEQ.N    ??gcode_M18_M84_5
   \   00000060   0x4826             LDR.N    R0,??gcode_M18_M84_1+0x4
   \   00000062   0xF890 0x0104      LDRB     R0,[R0, #+260]
   \   00000066   0x1E42             SUBS     R2,R0,#+1
   \   00000068   0x4192             SBCS     R2,R2,R2
   \   0000006A   0x0FD2             LSRS     R2,R2,#+31
   \   0000006C   0xB252             SXTB     R2,R2
   \   0000006E   0x4824             LDR.N    R0,??gcode_M18_M84_1+0x8
   \   00000070   0x8881             LDRH     R1,[R0, #+4]
   \   00000072   0x4824             LDR.N    R0,??gcode_M18_M84_1+0xC
   \   00000074   0x6880             LDR      R0,[R0, #+8]
   \   00000076   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000007A   0x2000             MOVS     R0,#+0
   \   0000007C   0x491E             LDR.N    R1,??gcode_M18_M84_1
   \   0000007E   0x7108             STRB     R0,[R1, #+4]
   9381                if (parser.seen('Y')) disable_Y();
   \                     ??gcode_M18_M84_5: (+1)
   \   00000080   0x2059             MOVS     R0,#+89
   \   00000082   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD00E             BEQ.N    ??gcode_M18_M84_6
   \   0000008A   0x481F             LDR.N    R0,??gcode_M18_M84_1+0x10
   \   0000008C   0x7840             LDRB     R0,[R0, #+1]
   \   0000008E   0x1E42             SUBS     R2,R0,#+1
   \   00000090   0x4192             SBCS     R2,R2,R2
   \   00000092   0x0FD2             LSRS     R2,R2,#+31
   \   00000094   0xB252             SXTB     R2,R2
   \   00000096   0x481A             LDR.N    R0,??gcode_M18_M84_1+0x8
   \   00000098   0x89C1             LDRH     R1,[R0, #+14]
   \   0000009A   0x481A             LDR.N    R0,??gcode_M18_M84_1+0xC
   \   0000009C   0x69C0             LDR      R0,[R0, #+28]
   \   0000009E   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x4914             LDR.N    R1,??gcode_M18_M84_1
   \   000000A6   0x7148             STRB     R0,[R1, #+5]
   9382                if (parser.seen('Z')) disable_Z();
   \                     ??gcode_M18_M84_6: (+1)
   \   000000A8   0x205A             MOVS     R0,#+90
   \   000000AA   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000000AE   0x2800             CMP      R0,#+0
   \   000000B0   0xD017             BEQ.N    ??gcode_M18_M84_7
   \   000000B2   0x4C15             LDR.N    R4,??gcode_M18_M84_1+0x10
   \   000000B4   0x78A0             LDRB     R0,[R4, #+2]
   \   000000B6   0x1E42             SUBS     R2,R0,#+1
   \   000000B8   0x4192             SBCS     R2,R2,R2
   \   000000BA   0x0FD2             LSRS     R2,R2,#+31
   \   000000BC   0x4D11             LDR.N    R5,??gcode_M18_M84_1+0xC
   \   000000BE   0x4E10             LDR.N    R6,??gcode_M18_M84_1+0x8
   \   000000C0   0xB252             SXTB     R2,R2
   \   000000C2   0x8B31             LDRH     R1,[R6, #+24]
   \   000000C4   0x6B28             LDR      R0,[R5, #+48]
   \   000000C6   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000CA   0x78A0             LDRB     R0,[R4, #+2]
   \   000000CC   0x1E42             SUBS     R2,R0,#+1
   \   000000CE   0x4192             SBCS     R2,R2,R2
   \   000000D0   0x0FD2             LSRS     R2,R2,#+31
   \   000000D2   0xB252             SXTB     R2,R2
   \   000000D4   0x8D31             LDRH     R1,[R6, #+40]
   \   000000D6   0x6D28             LDR      R0,[R5, #+80]
   \   000000D8   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000DC   0x2000             MOVS     R0,#+0
   \   000000DE   0x4906             LDR.N    R1,??gcode_M18_M84_1
   \   000000E0   0x7188             STRB     R0,[R1, #+6]
   9383                #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
   9384                  if (parser.seen('E')) disable_e_steppers();
   \                     ??gcode_M18_M84_7: (+1)
   \   000000E2   0x2045             MOVS     R0,#+69
   \   000000E4   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD003             BEQ.N    ??gcode_M18_M84_8
   \   000000EC   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   000000F0   0x.... 0x....      B.W      _Z18disable_e_steppersv
   9385                #endif
   9386              }
   9387          
   9388              #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
   9389                ubl.lcd_map_control = defer_return_to_status = false;
   9390              #endif
   9391            }
   9392          }
   \                     ??gcode_M18_M84_8: (+1)
   \   000000F4   0xBD70             POP      {R4-R6,PC}       ;; return
   \   000000F6   0xBF00             Nop      
   \                     ??gcode_M18_M84_1:
   \   000000F8   0x........         DC32     axis_homed
   \   000000FC   0x........         DC32     mksCfg
   \   00000100   0x........         DC32     gArrayGpioPin
   \   00000104   0x........         DC32     gArrayGpioPort
   \   00000108   0x........         DC32     mksCfg+0x104
   9393          
   9394          /**
   9395           * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
   9396           */

   \                                 In section .text, align 4
   9397          inline void gcode_M85() {
   \                     _Z9gcode_M85v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9398            if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M85_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser25value_millis_from_secondsEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M85_1
   \   00000012   0x6608             STR      R0,[R1, #+96]
   9399          }
   \                     ??gcode_M85_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M85_1:
   \   00000018   0x........         DC32     axis_homed
   9400          
   9401          /**
   9402           * Multi-stepper support for M92, M201, M203
   9403           */
   9404          #if ENABLED(DISTINCT_E_FACTORS)
   9405            #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
   9406            #define TARGET_EXTRUDER target_extruder
   9407          #else
   9408            #define GET_TARGET_EXTRUDER(CMD) NOOP
   9409            #define TARGET_EXTRUDER 0
   9410          #endif
   9411          
   9412          /**
   9413           * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
   9414           *      (Follows the same syntax as G92)
   9415           *
   9416           *      With multiple extruders use T to specify which one.
   9417           */

   \                                 In section .text, align 4
   9418          inline void gcode_M92() {
   \                     _Z9gcode_M92v: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   9419          
   9420            GET_TARGET_EXTRUDER(92);
   \   00000004   0x205C             MOVS     R0,#+92
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD14C             BNE.N    ??gcode_M92_0
   9421          
   9422            LOOP_XYZE(i) {
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0xE006             B.N      ??gcode_M92_1
   9423              if (parser.seen(axis_codes[i])) {
   9424                if (i == E_AXIS) {
   9425                  const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
   9426                  if (value < 20.0) {
   9427                    float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
   9428                    planner.max_jerk[E_AXIS] *= factor;
   9429                    planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
   9430                    planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
   9431                  }
   9432                  planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
   9433                }
   9434                else {
   9435                  planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
   \                     ??gcode_M92_2: (+1)
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0xB240             SXTB     R0,R0
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
   \   0000001A   0xF847 0x0024      STR      R0,[R7, R4, LSL #+2]
   9436                }
   \                     ??gcode_M92_3: (+1)
   \   0000001E   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M92_1: (+1)
   \   00000020   0x2C04             CMP      R4,#+4
   \   00000022   0xDA3D             BGE.N    ??gcode_M92_4
   \   00000024   0x4821             LDR.N    R0,??gcode_M92_5
   \   00000026   0x5620             LDRSB    R0,[R4, R0]
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD0F6             BEQ.N    ??gcode_M92_3
   \   00000030   0x4F1F             LDR.N    R7,??gcode_M92_5+0x4
   \   00000032   0x2C03             CMP      R4,#+3
   \   00000034   0xD1ED             BNE.N    ??gcode_M92_2
   \   00000036   0x4E1F             LDR.N    R6,??gcode_M92_5+0x8
   \   00000038   0xF996 0x0005      LDRSB    R0,[R6, #+5]
   \   0000003C   0x1CC0             ADDS     R0,R0,#+3
   \   0000003E   0xB240             SXTB     R0,R0
   \   00000040   0x.... 0x....      BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
   \   00000044   0x4605             MOV      R5,R0
   \   00000046   0x7976             LDRB     R6,[R6, #+5]
   \   00000048   0xEB07 0x0786      ADD      R7,R7,R6, LSL #+2
   \   0000004C   0x491A             LDR.N    R1,??gcode_M92_5+0xC  ;; 0x41a00000
   \   0000004E   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000052   0xD223             BCS.N    ??gcode_M92_6
   \   00000054   0x68F8             LDR      R0,[R7, #+12]
   \   00000056   0x4629             MOV      R1,R5
   \   00000058   0x.... 0x....      BL       __aeabi_fdiv
   \   0000005C   0x4680             MOV      R8,R0
   \   0000005E   0xF8DF 0x905C      LDR.W    R9,??gcode_M92_5+0x10
   \   00000062   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   00000066   0x4641             MOV      R1,R8
   \   00000068   0x.... 0x....      BL       __aeabi_fmul
   \   0000006C   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   00000070   0x4813             LDR.N    R0,??gcode_M92_5+0x14
   \   00000072   0xEB00 0x0986      ADD      R9,R0,R6, LSL #+2
   \   00000076   0xF8D9 0x000C      LDR      R0,[R9, #+12]
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0xF8C9 0x000C      STR      R0,[R9, #+12]
   \   00000084   0x480F             LDR.N    R0,??gcode_M92_5+0x18
   \   00000086   0xEB00 0x0686      ADD      R6,R0,R6, LSL #+2
   \   0000008A   0x68F0             LDR      R0,[R6, #+12]
   \   0000008C   0x.... 0x....      BL       __aeabi_ui2f
   \   00000090   0x4641             MOV      R1,R8
   \   00000092   0x.... 0x....      BL       __aeabi_fmul
   \   00000096   0x.... 0x....      BL       __aeabi_f2uiz
   \   0000009A   0x60F0             STR      R0,[R6, #+12]
   \                     ??gcode_M92_6: (+1)
   \   0000009C   0x60FD             STR      R5,[R7, #+12]
   \   0000009E   0xE7BE             B.N      ??gcode_M92_3
   9437              }
   9438            }
   9439            planner.refresh_positioning();
   \                     ??gcode_M92_4: (+1)
   \   000000A0   0xE8BD 0x43F1      POP      {R0,R4-R9,LR}
   \   000000A4   0x.... 0x....      B.W      _ZN7Planner19refresh_positioningEv
   \                     ??gcode_M92_0: (+1)
   \   000000A8   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??gcode_M92_5:
   \   000000AC   0x........         DC32     axis_codes
   \   000000B0   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
   \   000000B4   0x........         DC32     mks_heating_busy
   \   000000B8   0x41A00000         DC32     0x41a00000
   \   000000BC   0x........         DC32     _ZN7Planner8max_jerkE
   \   000000C0   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE
   \   000000C4   0x........         DC32     _ZN7Planner29max_acceleration_steps_per_s2E
   9440          }
   9441          
   9442          /**
   9443           * Output the current position to serial
   9444           */

   \                                 In section .text, align 2, keep-with-next
   9445          void report_current_position() {
   \                     _Z23report_current_positionv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9446            SERIAL_PROTOCOLPGM("X:");
   \   00000002   0x....             ADR.N    R0,??DataTable154_3  ;; 0x58, 0x3A, 0x00, 0x00
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9447            SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
   \   00000008   0x....             LDR.N    R4,??DataTable154_2
   \   0000000A   0x.... 0x....      LDR.W    R5,??DataTable156_1
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x9000             STR      R0,[SP, #+0]
   \   00000012   0x68A8             LDR      R0,[R5, #+8]
   \   00000014   0x.... 0x....      BL       __aeabi_f2d
   \   00000018   0x4602             MOV      R2,R0
   \   0000001A   0x460B             MOV      R3,R1
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _ZN5Print5printEdi
   9448            SERIAL_PROTOCOLPGM(" Y:");
   \   00000022   0x....             ADR.N    R0,??DataTable154_4  ;; " Y:"
   \   00000024   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9449            SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
   \   00000028   0x2002             MOVS     R0,#+2
   \   0000002A   0x9000             STR      R0,[SP, #+0]
   \   0000002C   0x68E8             LDR      R0,[R5, #+12]
   \   0000002E   0x.... 0x....      BL       __aeabi_f2d
   \   00000032   0x4602             MOV      R2,R0
   \   00000034   0x460B             MOV      R3,R1
   \   00000036   0x4620             MOV      R0,R4
   \   00000038   0x.... 0x....      BL       _ZN5Print5printEdi
   9450            SERIAL_PROTOCOLPGM(" Z:");
   \   0000003C   0x....             ADR.N    R0,??DataTable154_6  ;; " Z:"
   \   0000003E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9451            SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
   \   00000042   0x2002             MOVS     R0,#+2
   \   00000044   0x9000             STR      R0,[SP, #+0]
   \   00000046   0x6928             LDR      R0,[R5, #+16]
   \   00000048   0x.... 0x....      BL       __aeabi_f2d
   \   0000004C   0x4602             MOV      R2,R0
   \   0000004E   0x460B             MOV      R3,R1
   \   00000050   0x4620             MOV      R0,R4
   \   00000052   0x.... 0x....      BL       _ZN5Print5printEdi
   9452            SERIAL_PROTOCOLPGM(" E:");
   \   00000056   0x....             ADR.N    R0,??DataTable155  ;; " E:"
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9453            SERIAL_PROTOCOL(current_position[E_AXIS]);
   \   0000005C   0x2002             MOVS     R0,#+2
   \   0000005E   0x9000             STR      R0,[SP, #+0]
   \   00000060   0x6968             LDR      R0,[R5, #+20]
   \   00000062   0x.... 0x....      BL       __aeabi_f2d
   \   00000066   0x4602             MOV      R2,R0
   \   00000068   0x460B             MOV      R3,R1
   \   0000006A   0x4620             MOV      R0,R4
   \   0000006C   0x.... 0x....      BL       _ZN5Print5printEdi
   9454          
   9455            stepper.report_positions();
   \   00000070   0x.... 0x....      BL       _ZN7Stepper16report_positionsEv
   9456          
   9457            //#if IS_SCARA
   9458            if(MACHINETPYE&IS_SCARA)  
   \   00000074   0x.... 0x....      LDR.W    R0,??DataTable158
   \   00000078   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   0000007C   0xF44F 0x7140      MOV      R1,#+768
   \   00000080   0x4208             TST      R0,R1
   \   00000082   0xD019             BEQ.N    ??report_current_position_0
   9459            {
   9460              SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   0000008A   0x4601             MOV      R1,R0
   \   0000008C   0x.... 0x....      ADR.W    R0,`?<Constant "SCARA Theta:">`
   \   00000090   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   9461              SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
   \   00000094   0x2001             MOVS     R0,#+1
   \   00000096   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   0000009A   0x4601             MOV      R1,R0
   \   0000009C   0x.... 0x....      ADR.W    R0,`?<Constant "   Psi+Theta:">`
   \   000000A0   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000000A4   0x210A             MOVS     R1,#+10
   \   000000A6   0x4620             MOV      R0,R4
   \   000000A8   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9462              SERIAL_EOL();
   \   000000AC   0x210A             MOVS     R1,#+10
   \   000000AE   0x4620             MOV      R0,R4
   \   000000B0   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   000000B4   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9463            }
   9464            //#endif
   9465          }
   \                     ??report_current_position_0: (+1)
   \   000000B8   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   9466          
   9467          #ifdef M114_DETAIL
   9468          
   9469            void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
   9470              char str[12];
   9471              for (uint8_t i = 0; i < n; i++) {
   9472                SERIAL_CHAR(' ');
   9473                SERIAL_CHAR(axis_codes[i]);
   9474                SERIAL_CHAR(':');
   9475                SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
   9476              }
   9477              SERIAL_EOL();
   9478            }
   9479          
   9480            inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
   9481          
   9482            void report_current_position_detail() {
   9483          
   9484              stepper.synchronize();
   9485          
   9486              SERIAL_PROTOCOLPGM("\nLogical:");
   9487              const float logical[XYZ] = {
   9488                LOGICAL_X_POSITION(current_position[X_AXIS]),
   9489                LOGICAL_Y_POSITION(current_position[Y_AXIS]),
   9490                LOGICAL_Z_POSITION(current_position[Z_AXIS])
   9491              };
   9492              report_xyze(logical);
   9493          
   9494              SERIAL_PROTOCOLPGM("Raw:    ");
   9495              report_xyz(current_position);
   9496          
   9497              float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   9498          
   9499              #if PLANNER_LEVELING
   9500                SERIAL_PROTOCOLPGM("Leveled:");
   9501                planner.apply_leveling(leveled);
   9502                report_xyz(leveled);
   9503          
   9504                SERIAL_PROTOCOLPGM("UnLevel:");
   9505                float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
   9506                planner.unapply_leveling(unleveled);
   9507                report_xyz(unleveled);
   9508              #endif
   9509          
   9510              #if IS_KINEMATIC
   9511                #if IS_SCARA
   9512                  SERIAL_PROTOCOLPGM("ScaraK: ");
   9513                #else
   9514                  SERIAL_PROTOCOLPGM("DeltaK: ");
   9515                #endif
   9516                inverse_kinematics(leveled);  // writes delta[]
   9517                report_xyz(delta);
   9518              #endif
   9519          
   9520              SERIAL_PROTOCOLPGM("Stepper:");
   9521              LOOP_XYZE(i) {
   9522                SERIAL_CHAR(' ');
   9523                SERIAL_CHAR(axis_codes[i]);
   9524                SERIAL_CHAR(':');
   9525                SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
   9526              }
   9527              SERIAL_EOL();
   9528          
   9529              #if IS_SCARA
   9530                const float deg[XYZ] = {
   9531                  stepper.get_axis_position_degrees(A_AXIS),
   9532                  stepper.get_axis_position_degrees(B_AXIS)
   9533                };
   9534                SERIAL_PROTOCOLPGM("Degrees:");
   9535                report_xyze(deg, 2);
   9536              #endif
   9537          
   9538              SERIAL_PROTOCOLPGM("FromStp:");
   9539              get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
   9540              const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
   9541              report_xyze(from_steppers);
   9542          
   9543              const float diff[XYZE] = {
   9544                from_steppers[X_AXIS] - leveled[X_AXIS],
   9545                from_steppers[Y_AXIS] - leveled[Y_AXIS],
   9546                from_steppers[Z_AXIS] - leveled[Z_AXIS],
   9547                from_steppers[E_AXIS] - current_position[E_AXIS]
   9548              };
   9549              SERIAL_PROTOCOLPGM("Differ: ");
   9550              report_xyze(diff);
   9551            }
   9552          #endif // M114_DETAIL
   9553          
   9554          /**
   9555           * M114: Report current position to host
   9556           */

   \                                 In section .text, align 2
   9557          inline void gcode_M114() {
   \                     _Z10gcode_M114v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9558          
   9559            #ifdef M114_DETAIL
   9560              if (parser.seen('D')) {
   9561                report_current_position_detail();
   9562                return;
   9563              }
   9564            #endif
   9565          
   9566            stepper.synchronize();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   9567            report_current_position();
   \   00000006   0xE8BD 0x4001      POP      {R0,LR}
   \   0000000A   0x.... 0x....      B.W      _Z23report_current_positionv
   9568          }
   9569          
   9570          /**
   9571           * M115: Capabilities string
   9572           */
   9573          
   9574          #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

   \                                 In section .text, align 2, keep-with-next
   9575            static void cap_line(const char * const name, bool ena=false) {
   \                     _Z8cap_linePKcb: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   9576              SERIAL_PROTOCOLPGM("Cap:");
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant "Cap:">`
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9577              serialprintPGM(name);
   \   0000000E   0x4620             MOV      R0,R4
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9578              SERIAL_PROTOCOLPGM(":");
   \   00000014   0x....             ADR.N    R0,??DataTable155_1  ;; ":"
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9579              SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
   \   0000001A   0x....             LDR.N    R4,??DataTable154_2
   \   0000001C   0x220A             MOVS     R2,#+10
   \   0000001E   0x4629             MOV      R1,R5
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN5Print5printEii
   \   00000026   0x210A             MOVS     R1,#+10
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   0000002E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9580            }
   9581          #endif
   9582          

   \                                 In section .text, align 4
   9583          inline void gcode_M115() {
   \                     _Z10gcode_M115v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9584            SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
   \   00000002   0x481E             LDR.N    R0,??gcode_M115_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9585          
   9586            #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
   9587          
   9588              // SERIAL_XON_XOFF
   9589              cap_line(PSTR("SERIAL_XON_XOFF")
   9590                #if ENABLED(SERIAL_XON_XOFF)
   9591                  , true
   9592                #endif
   9593              );
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0x481D             LDR.N    R0,??gcode_M115_0+0x4
   \   0000000C   0x.... 0x....      BL       _Z8cap_linePKcb
   9594          
   9595              // EEPROM (M500, M501)
   9596              cap_line(PSTR("EEPROM")
   9597                #if ENABLED(EEPROM_SETTINGS)
   9598                  , true
   9599                #endif
   9600              );
   \   00000010   0x2101             MOVS     R1,#+1
   \   00000012   0x481C             LDR.N    R0,??gcode_M115_0+0x8
   \   00000014   0x.... 0x....      BL       _Z8cap_linePKcb
   9601          
   9602              // Volumetric Extrusion (M200)
   9603              cap_line(PSTR("VOLUMETRIC")
   9604                #if DISABLED(NO_VOLUMETRICS)
   9605                  , true
   9606                #endif
   9607              );
   \   00000018   0x2101             MOVS     R1,#+1
   \   0000001A   0x481B             LDR.N    R0,??gcode_M115_0+0xC
   \   0000001C   0x.... 0x....      BL       _Z8cap_linePKcb
   9608          
   9609              // AUTOREPORT_TEMP (M155)
   9610              cap_line(PSTR("AUTOREPORT_TEMP")
   9611                #if ENABLED(AUTO_REPORT_TEMPERATURES)
   9612                  , true
   9613                #endif
   9614              );
   \   00000020   0x2101             MOVS     R1,#+1
   \   00000022   0x481A             LDR.N    R0,??gcode_M115_0+0x10
   \   00000024   0x.... 0x....      BL       _Z8cap_linePKcb
   9615          
   9616              // PROGRESS (M530 S L, M531 <file>, M532 X L)
   9617              cap_line(PSTR("PROGRESS"));
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x4819             LDR.N    R0,??gcode_M115_0+0x14
   \   0000002C   0x.... 0x....      BL       _Z8cap_linePKcb
   9618          
   9619              // Print Job timer M75, M76, M77
   9620              cap_line(PSTR("PRINT_JOB"), true);
   \   00000030   0x2101             MOVS     R1,#+1
   \   00000032   0x4818             LDR.N    R0,??gcode_M115_0+0x18
   \   00000034   0x.... 0x....      BL       _Z8cap_linePKcb
   9621          
   9622              // AUTOLEVEL (G29)
   9623              cap_line(PSTR("AUTOLEVEL")
   9624                #if HAS_AUTOLEVEL
   9625                  , true
   9626                #endif
   9627              );
   \   00000038   0x2101             MOVS     R1,#+1
   \   0000003A   0x4817             LDR.N    R0,??gcode_M115_0+0x1C
   \   0000003C   0x.... 0x....      BL       _Z8cap_linePKcb
   9628          
   9629              // Z_PROBE (G30)
   9630              cap_line(PSTR("Z_PROBE")
   9631                #if HAS_BED_PROBE
   9632                  , true
   9633                #endif
   9634              );
   \   00000040   0x2101             MOVS     R1,#+1
   \   00000042   0x4816             LDR.N    R0,??gcode_M115_0+0x20
   \   00000044   0x.... 0x....      BL       _Z8cap_linePKcb
   9635          
   9636              // MESH_REPORT (M420 V)
   9637              cap_line(PSTR("LEVELING_DATA")
   9638                #if HAS_LEVELING
   9639                  , true
   9640                #endif
   9641              );
   \   00000048   0x2101             MOVS     R1,#+1
   \   0000004A   0x4815             LDR.N    R0,??gcode_M115_0+0x24
   \   0000004C   0x.... 0x....      BL       _Z8cap_linePKcb
   9642          
   9643              // BUILD_PERCENT (M73)
   9644              cap_line(PSTR("BUILD_PERCENT")
   9645                #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
   9646                  , true
   9647                #endif
   9648              );
   \   00000050   0x2100             MOVS     R1,#+0
   \   00000052   0x4814             LDR.N    R0,??gcode_M115_0+0x28
   \   00000054   0x.... 0x....      BL       _Z8cap_linePKcb
   9649          
   9650              // SOFTWARE_POWER (M80, M81)
   9651              cap_line(PSTR("SOFTWARE_POWER")
   9652                #if HAS_POWER_SWITCH
   9653                  , true
   9654                #endif
   9655              );
   \   00000058   0x2100             MOVS     R1,#+0
   \   0000005A   0x4813             LDR.N    R0,??gcode_M115_0+0x2C
   \   0000005C   0x.... 0x....      BL       _Z8cap_linePKcb
   9656          
   9657              // CASE LIGHTS (M355)
   9658              cap_line(PSTR("TOGGLE_LIGHTS")
   9659                #if HAS_CASE_LIGHT
   9660                  , true
   9661                #endif
   9662              );
   \   00000060   0x2100             MOVS     R1,#+0
   \   00000062   0x4812             LDR.N    R0,??gcode_M115_0+0x30
   \   00000064   0x.... 0x....      BL       _Z8cap_linePKcb
   9663              cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
   9664                #if HAS_CASE_LIGHT
   9665                  , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
   9666                #endif
   9667              );
   \   00000068   0x2100             MOVS     R1,#+0
   \   0000006A   0x4811             LDR.N    R0,??gcode_M115_0+0x34
   \   0000006C   0x.... 0x....      BL       _Z8cap_linePKcb
   9668          
   9669              // EMERGENCY_PARSER (M108, M112, M410)
   9670              cap_line(PSTR("EMERGENCY_PARSER")
   9671                #if ENABLED(EMERGENCY_PARSER)
   9672                  , true
   9673                #endif
   9674              );
   \   00000070   0x2100             MOVS     R1,#+0
   \   00000072   0x4810             LDR.N    R0,??gcode_M115_0+0x38
   \   00000074   0xE8BD 0x4004      POP      {R2,LR}
   \   00000078   0x.... 0x....      B.W      _Z8cap_linePKcb
   \                     ??gcode_M115_0:
   \   0000007C   0x........         DC32     _ZZ10gcode_M115vEs
   \   00000080   0x........         DC32     _ZZ10gcode_M115vEs_0
   \   00000084   0x........         DC32     _ZZ10gcode_M115vEs_1
   \   00000088   0x........         DC32     _ZZ10gcode_M115vEs_2
   \   0000008C   0x........         DC32     _ZZ10gcode_M115vEs_3
   \   00000090   0x........         DC32     _ZZ10gcode_M115vEs_4
   \   00000094   0x........         DC32     _ZZ10gcode_M115vEs_5
   \   00000098   0x........         DC32     _ZZ10gcode_M115vEs_6
   \   0000009C   0x........         DC32     _ZZ10gcode_M115vEs_7
   \   000000A0   0x........         DC32     _ZZ10gcode_M115vEs_8
   \   000000A4   0x........         DC32     _ZZ10gcode_M115vEs_9
   \   000000A8   0x........         DC32     _ZZ10gcode_M115vEs__10_
   \   000000AC   0x........         DC32     _ZZ10gcode_M115vEs__11_
   \   000000B0   0x........         DC32     _ZZ10gcode_M115vEs__12_
   \   000000B4   0x........         DC32     _ZZ10gcode_M115vEs__13_
   9675          
   9676            #endif // EXTENDED_CAPABILITIES_REPORT
   9677          }
   9678          
   9679          /**
   9680           * M117: Set LCD Status Message
   9681           */

   \                                 In section .text, align 4
   9682          inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
   \                     _Z10gcode_M117v: (+1)
   \   00000000   0x2100             MOVS     R1,#+0
   \   00000002   0x4802             LDR.N    R0,??gcode_M117_0
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x.... 0x....      B.W      _Z13lcd_setstatusPKcb
   \   0000000A   0xBF00             Nop      
   \                     ??gcode_M117_0:
   \   0000000C   0x........         DC32     _ZN11GCodeParser10string_argE
   9683          
   9684          /**
   9685           * M118: Display a message in the host console.
   9686           *
   9687           *  A1  Append '// ' for an action command, as in OctoPrint
   9688           *  E1  Have the host 'echo:' the text
   9689           */

   \                                 In section .text, align 4
   9690          inline void gcode_M118() {
   \                     _Z10gcode_M118v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9691            if (parser.boolval('E')) SERIAL_ECHO_START();
   \   00000002   0x2045             MOVS     R0,#+69
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD002             BEQ.N    ??gcode_M118_0
   \   0000000C   0x480B             LDR.N    R0,??gcode_M118_1
   \   0000000E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9692            if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
   \                     ??gcode_M118_0: (+1)
   \   00000012   0x2041             MOVS     R0,#+65
   \   00000014   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD002             BEQ.N    ??gcode_M118_2
   \   0000001C   0x4808             LDR.N    R0,??gcode_M118_1+0x4
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
   9693            SERIAL_ECHOLN(parser.string_arg);
   \                     ??gcode_M118_2: (+1)
   \   00000022   0x4C08             LDR.N    R4,??gcode_M118_1+0x8
   \   00000024   0x4808             LDR.N    R0,??gcode_M118_1+0xC
   \   00000026   0x6801             LDR      R1,[R0, #+0]
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0xE8BD 0x4010      POP      {R4,LR}
   \   00000036   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000003A   0xBF00             Nop      
   \                     ??gcode_M118_1:
   \   0000003C   0x........         DC32     echomagic
   \   00000040   0x........         DC32     _ZZ10gcode_M118vEs
   \   00000044   0x........         DC32     Serial3
   \   00000048   0x........         DC32     _ZN11GCodeParser10string_argE
   9694          }
   9695          
   9696          /**
   9697           * M119: Output endstop states to serial output
   9698           */

   \                                 In section .text, align 2
   9699          inline void gcode_M119() { endstops.M119(); }
   \                     _Z10gcode_M119v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN8Endstops4M119Ev
   9700          
   9701          /**
   9702           * M120: Enable endstops and set non-homing endstop state to "enabled"
   9703           */

   \                                 In section .text, align 2
   9704          inline void gcode_M120() { endstops.enable_globally(true); }
   \                     _Z10gcode_M120v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   9705          
   9706          /**
   9707           * M121: Disable endstops and set non-homing endstop state to "disabled"
   9708           */

   \                                 In section .text, align 2
   9709          inline void gcode_M121() { endstops.enable_globally(false); }
   \                     _Z10gcode_M121v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      _ZN8Endstops15enable_globallyEb
   9710          
   9711          #if ENABLED(PARK_HEAD_ON_PAUSE)
   9712          
   9713            /**
   9714             * M125: Store current position and move to filament change position.
   9715             *       Called on pause (by M25) to prevent material leaking onto the
   9716             *       object. On resume (M24) the head will be moved back and the
   9717             *       print will resume.
   9718             *
   9719             *       If Marlin is compiled without SD Card support, M125 can be
   9720             *       used directly to pause the print and move to park position,
   9721             *       resuming with a button click or M108.
   9722             *
   9723             *    L = override retract length
   9724             *    X = override X
   9725             *    Y = override Y
   9726             *    Z = override Z raise
   9727             */
   9728            inline void gcode_M125() {
   9729          
   9730              // Initial retract before move to filament change position
   9731              const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
   9732                #ifdef PAUSE_PARK_RETRACT_LENGTH
   9733                  - (PAUSE_PARK_RETRACT_LENGTH)
   9734                #endif
   9735              ;
   9736          
   9737              point_t park_point = NOZZLE_PARK_POINT;
   9738          
   9739              // Move XY axes to filament change position or given position
   9740              if (parser.seenval('X')) park_point.x = parser.linearval('X');
   9741              if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
   9742          
   9743              // Lift Z axis
   9744              if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
   9745          
   9746              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
   9747                park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
   9748                park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
   9749              #endif
   9750          
   9751              #if DISABLED(SDSUPPORT)
   9752                const bool job_running = print_job_timer.isRunning();
   9753              #endif
   9754          
   9755              if (pause_print(retract, park_point)) {
   9756                #if DISABLED(SDSUPPORT)
   9757                  // Wait for lcd click or M108
   9758                  wait_for_filament_reload();
   9759          
   9760                  // Return to print position and continue
   9761                  resume_print();
   9762          
   9763                  if (job_running) print_job_timer.start();
   9764                #endif
   9765              }
   9766            }
   9767          
   9768          #endif // PARK_HEAD_ON_PAUSE
   9769          
   9770          #if HAS_COLOR_LEDS
   9771          
   9772            /**
   9773             * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
   9774             *       and Brightness       - Use P (for NEOPIXEL only)
   9775             *
   9776             * Always sets all 3 or 4 components. If a component is left out, set to 0.
   9777             *                                    If brightness is left out, no value changed
   9778             *
   9779             * Examples:
   9780             *
   9781             *   M150 R255       ; Turn LED red
   9782             *   M150 R255 U127  ; Turn LED orange (PWM only)
   9783             *   M150            ; Turn LED off
   9784             *   M150 R U B      ; Turn LED white
   9785             *   M150 W          ; Turn LED white using a white LED
   9786             *   M150 P127       ; Set LED 50% brightness
   9787             *   M150 P          ; Set LED full brightness
   9788             */
   9789            inline void gcode_M150() {
   9790              leds.set_color(MakeLEDColor(
   9791                parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9792                parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9793                parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9794                parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
   9795                parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
   9796              ));
   9797            }
   9798          
   9799          #endif // HAS_COLOR_LEDS
   9800          
   9801          #if DISABLED(NO_VOLUMETRICS)
   9802          
   9803            /**
   9804             * M200: Set filament diameter and set E axis units to cubic units
   9805             *
   9806             *    T<extruder> - Optional extruder number. Current extruder if omitted.
   9807             *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
   9808             */

   \                                 In section .text, align 4
   9809            inline void gcode_M200() {
   \                     _Z10gcode_M200v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   9810          
   9811              if (get_target_extruder_from_command(200)) return;
   \   00000004   0x20C8             MOVS     R0,#+200
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD11D             BNE.N    ??gcode_M200_0
   9812          
   9813              if (parser.seen('D')) {
   \   0000000E   0x2044             MOVS     R0,#+68
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD016             BEQ.N    ??gcode_M200_1
   9814                // setting any extruder filament size disables volumetric on the assumption that
   9815                // slicers either generate in extruder values as cubic mm or as as filament feeds
   9816                // for all extruders
   9817                if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
   \   00000018   0x4C0C             LDR.N    R4,??gcode_M200_2
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000001E   0x2100             MOVS     R1,#+0
   \   00000020   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000024   0xD002             BEQ.N    ??gcode_M200_3
   \   00000026   0x2001             MOVS     R0,#+1
   \   00000028   0x7020             STRB     R0,[R4, #+0]
   \   0000002A   0xE001             B.N      ??gcode_M200_4
   \                     ??gcode_M200_3: (+1)
   \   0000002C   0x4608             MOV      R0,R1
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
   \                     ??gcode_M200_4: (+1)
   \   00000030   0x7820             LDRB     R0,[R4, #+0]
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD007             BEQ.N    ??gcode_M200_1
   9818                  planner.set_filament_size(target_extruder, parser.value_linear_units());
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000003A   0x9000             STR      R0,[SP, #+0]
   \   0000003C   0xA900             ADD      R1,SP,#+0
   \   0000003E   0x4804             LDR.N    R0,??gcode_M200_2+0x4
   \   00000040   0x7940             LDRB     R0,[R0, #+5]
   \   00000042   0x.... 0x....      BL       _ZN7Planner17set_filament_sizeEhRKf
   9819              }
   9820              planner.calculate_volumetric_multipliers();
   \                     ??gcode_M200_1: (+1)
   \   00000046   0x.... 0x....      BL       _ZN7Planner32calculate_volumetric_multipliersEv
   9821            }
   \                     ??gcode_M200_0: (+1)
   \   0000004A   0xBD13             POP      {R0,R1,R4,PC}    ;; return
   \                     ??gcode_M200_2:
   \   0000004C   0x........         DC32     _ZN11GCodeParser18volumetric_enabledE
   \   00000050   0x........         DC32     mks_heating_busy
   9822          
   9823          #endif // !NO_VOLUMETRICS
   9824          
   9825          /**
   9826           * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
   9827           *
   9828           *       With multiple extruders use T to specify which one.
   9829           */

   \                                 In section .text, align 4
   9830          inline void gcode_M201() {
   \                     _Z10gcode_M201v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9831          
   9832            GET_TARGET_EXTRUDER(201);
   \   00000002   0x20C9             MOVS     R0,#+201
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD11F             BNE.N    ??gcode_M201_0
   9833          
   9834            LOOP_XYZE(i) {
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE00C             B.N      ??gcode_M201_1
   9835              if (parser.seen(axis_codes[i])) {
   9836                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   \                     ??gcode_M201_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??gcode_M201_3: (+1)
   \   00000012   0x1905             ADDS     R5,R0,R4
   \   00000014   0xB2ED             UXTB     R5,R5
   9837                planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
                                                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xB240             SXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000001E   0x.... 0x....      BL       __aeabi_f2uiz
   \   00000022   0x490B             LDR.N    R1,??gcode_M201_4
   \   00000024   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \                     ??gcode_M201_5: (+1)
   \   00000028   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M201_1: (+1)
   \   0000002A   0x2C04             CMP      R4,#+4
   \   0000002C   0xDA0A             BGE.N    ??gcode_M201_6
   \   0000002E   0x4809             LDR.N    R0,??gcode_M201_4+0x4
   \   00000030   0x5620             LDRSB    R0,[R4, R0]
   \   00000032   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD0F6             BEQ.N    ??gcode_M201_5
   \   0000003A   0x2C03             CMP      R4,#+3
   \   0000003C   0xD1E8             BNE.N    ??gcode_M201_2
   \   0000003E   0x4806             LDR.N    R0,??gcode_M201_4+0x8
   \   00000040   0x7940             LDRB     R0,[R0, #+5]
   \   00000042   0xE7E6             B.N      ??gcode_M201_3
   9838              }
   9839            }
   9840            // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
   9841            planner.reset_acceleration_rates();
   \                     ??gcode_M201_6: (+1)
   \   00000044   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000048   0x.... 0x....      B.W      _ZN7Planner24reset_acceleration_ratesEv
   \                     ??gcode_M201_0: (+1)
   \   0000004C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   0000004E   0xBF00             Nop      
   \                     ??gcode_M201_4:
   \   00000050   0x........         DC32     _ZN7Planner26max_acceleration_mm_per_s2E
   \   00000054   0x........         DC32     axis_codes
   \   00000058   0x........         DC32     mks_heating_busy
   9842          }
   9843          
   9844          #if 0 // Not used for Sprinter/grbl gen6
   9845            inline void gcode_M202() {
   9846              LOOP_XYZE(i) {
   9847                if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
   9848              }
   9849            }
   9850          #endif
   9851          
   9852          
   9853          /**
   9854           * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
   9855           *
   9856           *       With multiple extruders use T to specify which one.
   9857           */

   \                                 In section .text, align 4
   9858          inline void gcode_M203() {
   \                     _Z10gcode_M203v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9859          
   9860            GET_TARGET_EXTRUDER(203);
   \   00000002   0x20CB             MOVS     R0,#+203
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD119             BNE.N    ??gcode_M203_0
   9861          
   9862            LOOP_XYZE(i)
   \   0000000C   0x2400             MOVS     R4,#+0
   \   0000000E   0xE00A             B.N      ??gcode_M203_1
   9863              if (parser.seen(axis_codes[i])) {
   9864                const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
   \                     ??gcode_M203_2: (+1)
   \   00000010   0x2000             MOVS     R0,#+0
   \                     ??gcode_M203_3: (+1)
   \   00000012   0x1905             ADDS     R5,R0,R4
   \   00000014   0xB2ED             UXTB     R5,R5
   9865                planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
   \   00000016   0x4628             MOV      R0,R5
   \   00000018   0xB240             SXTB     R0,R0
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
   \   0000001E   0x4909             LDR.N    R1,??gcode_M203_4
   \   00000020   0xF841 0x0025      STR      R0,[R1, R5, LSL #+2]
   \                     ??gcode_M203_5: (+1)
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M203_1: (+1)
   \   00000026   0x2C04             CMP      R4,#+4
   \   00000028   0xDA0A             BGE.N    ??gcode_M203_0
   \   0000002A   0x4807             LDR.N    R0,??gcode_M203_4+0x4
   \   0000002C   0x5620             LDRSB    R0,[R4, R0]
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD0F6             BEQ.N    ??gcode_M203_5
   \   00000036   0x2C03             CMP      R4,#+3
   \   00000038   0xD1EA             BNE.N    ??gcode_M203_2
   \   0000003A   0x4804             LDR.N    R0,??gcode_M203_4+0x8
   \   0000003C   0x7940             LDRB     R0,[R0, #+5]
   \   0000003E   0xE7E8             B.N      ??gcode_M203_3
   9866              }
   9867          }
   \                     ??gcode_M203_0: (+1)
   \   00000040   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \   00000042   0xBF00             Nop      
   \                     ??gcode_M203_4:
   \   00000044   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE
   \   00000048   0x........         DC32     axis_codes
   \   0000004C   0x........         DC32     mks_heating_busy
   9868          
   9869          /**
   9870           * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
   9871           *
   9872           *    P = Printing moves
   9873           *    R = Retract only (no X, Y, Z) moves
   9874           *    T = Travel (non printing) moves
   9875           *
   9876           *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
   9877           */

   \                                 In section .text, align 4
   9878          inline void gcode_M204() {
   \                     _Z10gcode_M204v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9879            if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD00D             BEQ.N    ??gcode_M204_0
   9880              planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x4920             LDR.N    R1,??gcode_M204_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
   \   00000014   0x4920             LDR.N    R1,??gcode_M204_1+0x4
   \   00000016   0x6008             STR      R0,[R1, #+0]
   9881              SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
   \   00000018   0x4601             MOV      R1,R0
   \   0000001A   0x4820             LDR.N    R0,??gcode_M204_1+0x8
   \   0000001C   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0x481F             LDR.N    R0,??gcode_M204_1+0xC
   \   00000024   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9882            }
   9883            if (parser.seen('P')) {
   \                     ??gcode_M204_0: (+1)
   \   00000028   0x2050             MOVS     R0,#+80
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002E   0x2800             CMP      R0,#+0
   \   00000030   0xD00B             BEQ.N    ??gcode_M204_2
   9884              planner.acceleration = parser.value_linear_units();
   \   00000032   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000036   0x4917             LDR.N    R1,??gcode_M204_1
   \   00000038   0x6008             STR      R0,[R1, #+0]
   9885              SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
   \   0000003A   0x4601             MOV      R1,R0
   \   0000003C   0x4819             LDR.N    R0,??gcode_M204_1+0x10
   \   0000003E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000042   0x210A             MOVS     R1,#+10
   \   00000044   0x4816             LDR.N    R0,??gcode_M204_1+0xC
   \   00000046   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9886            }
   9887            if (parser.seen('R')) {
   \                     ??gcode_M204_2: (+1)
   \   0000004A   0x2052             MOVS     R0,#+82
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD00B             BEQ.N    ??gcode_M204_3
   9888              planner.retract_acceleration = parser.value_linear_units();
   \   00000054   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000058   0x4913             LDR.N    R1,??gcode_M204_1+0x14
   \   0000005A   0x6008             STR      R0,[R1, #+0]
   9889              SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
   \   0000005C   0x4601             MOV      R1,R0
   \   0000005E   0x4813             LDR.N    R0,??gcode_M204_1+0x18
   \   00000060   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000064   0x210A             MOVS     R1,#+10
   \   00000066   0x480E             LDR.N    R0,??gcode_M204_1+0xC
   \   00000068   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   9890            }
   9891            if (parser.seen('T')) {
   \                     ??gcode_M204_3: (+1)
   \   0000006C   0x2054             MOVS     R0,#+84
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD00D             BEQ.N    ??gcode_M204_4
   9892              planner.travel_acceleration = parser.value_linear_units();
   \   00000076   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000007A   0x4907             LDR.N    R1,??gcode_M204_1+0x4
   \   0000007C   0x6008             STR      R0,[R1, #+0]
   9893              SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
   \   0000007E   0x4601             MOV      R1,R0
   \   00000080   0x480B             LDR.N    R0,??gcode_M204_1+0x1C
   \   00000082   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000086   0x210A             MOVS     R1,#+10
   \   00000088   0x4805             LDR.N    R0,??gcode_M204_1+0xC
   \   0000008A   0xE8BD 0x4004      POP      {R2,LR}
   \   0000008E   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   9894            }
   9895          }
   \                     ??gcode_M204_4: (+1)
   \   00000092   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M204_1:
   \   00000094   0x........         DC32     _ZN7Planner12accelerationE
   \   00000098   0x........         DC32     _ZN7Planner19travel_accelerationE
   \   0000009C   0x........         DC32     _ZZ10gcode_M204vEs
   \   000000A0   0x........         DC32     Serial3
   \   000000A4   0x........         DC32     _ZZ10gcode_M204vEs_0
   \   000000A8   0x........         DC32     _ZN7Planner20retract_accelerationE
   \   000000AC   0x........         DC32     _ZZ10gcode_M204vEs_1
   \   000000B0   0x........         DC32     _ZZ10gcode_M204vEs_2
   9896          
   9897          /**
   9898           * M205: Set Advanced Settings
   9899           *
   9900           *    S = Min Feed Rate (units/s)
   9901           *    T = Min Travel Feed Rate (units/s)
   9902           *    B = Min Segment Time (碌s)
   9903           *    X = Max X Jerk (units/sec^2)
   9904           *    Y = Max Y Jerk (units/sec^2)
   9905           *    Z = Max Z Jerk (units/sec^2)
   9906           *    E = Max E Jerk (units/sec^2)
   9907           */

   \                                 In section .text, align 4
   9908          inline void gcode_M205() {
   \                     _Z10gcode_M205v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   9909            if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M205_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x491C             LDR.N    R1,??gcode_M205_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
   9910            if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
   \                     ??gcode_M205_0: (+1)
   \   00000014   0x2054             MOVS     R0,#+84
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD003             BEQ.N    ??gcode_M205_2
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000022   0x4919             LDR.N    R1,??gcode_M205_1+0x4
   \   00000024   0x6008             STR      R0,[R1, #+0]
   9911            if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
   \                     ??gcode_M205_2: (+1)
   \   00000026   0x2042             MOVS     R0,#+66
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD003             BEQ.N    ??gcode_M205_3
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser11value_ulongEv
   \   00000034   0x4915             LDR.N    R1,??gcode_M205_1+0x8
   \   00000036   0x6008             STR      R0,[R1, #+0]
   9912            if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_3: (+1)
   \   00000038   0x2058             MOVS     R0,#+88
   \   0000003A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD003             BEQ.N    ??gcode_M205_4
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000046   0x4912             LDR.N    R1,??gcode_M205_1+0xC
   \   00000048   0x6008             STR      R0,[R1, #+0]
   9913            if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_4: (+1)
   \   0000004A   0x2059             MOVS     R0,#+89
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000050   0x2800             CMP      R0,#+0
   \   00000052   0xD003             BEQ.N    ??gcode_M205_5
   \   00000054   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000058   0x490D             LDR.N    R1,??gcode_M205_1+0xC
   \   0000005A   0x6048             STR      R0,[R1, #+4]
   9914            if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_5: (+1)
   \   0000005C   0x205A             MOVS     R0,#+90
   \   0000005E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD003             BEQ.N    ??gcode_M205_6
   \   00000066   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000006A   0x4909             LDR.N    R1,??gcode_M205_1+0xC
   \   0000006C   0x6088             STR      R0,[R1, #+8]
   9915            if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
   \                     ??gcode_M205_6: (+1)
   \   0000006E   0x2045             MOVS     R0,#+69
   \   00000070   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD003             BEQ.N    ??gcode_M205_7
   \   00000078   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000007C   0x4904             LDR.N    R1,??gcode_M205_1+0xC
   \   0000007E   0x60C8             STR      R0,[R1, #+12]
   9916          }
   \                     ??gcode_M205_7: (+1)
   \   00000080   0xBD01             POP      {R0,PC}          ;; return
   \   00000082   0xBF00             Nop      
   \                     ??gcode_M205_1:
   \   00000084   0x........         DC32     _ZN7Planner17min_feedrate_mm_sE
   \   00000088   0x........         DC32     _ZN7Planner24min_travel_feedrate_mm_sE
   \   0000008C   0x........         DC32     _ZN7Planner19min_segment_time_usE
   \   00000090   0x........         DC32     _ZN7Planner8max_jerkE
   9917          
   9918          #if 1//HAS_M206_COMMAND
   9919          
   9920            /**
   9921             * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
   9922             *
   9923             * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
   9924             * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
   9925             * ***              In the next 1.2 release, it will simply be disabled by default.
   9926             */

   \                                 In section .text, align 4
   9927            inline void gcode_M206() {
   \                     _Z10gcode_M206v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9928            if(MACHINETPYE == DELTA) return;
   \   00000002   0x4C1B             LDR.N    R4,??gcode_M206_0
   \   00000004   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000008   0x2802             CMP      R0,#+2
   \   0000000A   0xD030             BEQ.N    ??gcode_M206_1
   9929              LOOP_XYZ(i)
   \   0000000C   0x2500             MOVS     R5,#+0
   \   0000000E   0xE00D             B.N      ??gcode_M206_2
   9930                if (parser.seen(axis_codes[i]))
   \                     ??gcode_M206_3: (+1)
   \   00000010   0x4818             LDR.N    R0,??gcode_M206_0+0x4
   \   00000012   0x5628             LDRSB    R0,[R5, R0]
   \   00000014   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD006             BEQ.N    ??gcode_M206_4
   9931                  set_home_offset((AxisEnum)i, parser.value_linear_units());
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0x4628             MOV      R0,R5
   \   00000024   0xB240             SXTB     R0,R0
   \   00000026   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   \                     ??gcode_M206_4: (+1)
   \   0000002A   0x1C6D             ADDS     R5,R5,#+1
   \                     ??gcode_M206_2: (+1)
   \   0000002C   0x2D03             CMP      R5,#+3
   \   0000002E   0xDBEF             BLT.N    ??gcode_M206_3
   9932          
   9933              //#if ENABLED(MORGAN_SCARA)
   9934              if(MACHINETPYE == MORGAN_SCARA)
   \   00000030   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000034   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000038   0xD115             BNE.N    ??gcode_M206_5
   9935              {
   9936                if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
   \   0000003A   0x2054             MOVS     R0,#+84
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD005             BEQ.N    ??gcode_M206_6
   \   00000044   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000048   0x4601             MOV      R1,R0
   \   0000004A   0x2000             MOVS     R0,#+0
   \   0000004C   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   9937                if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
   \                     ??gcode_M206_6: (+1)
   \   00000050   0x2050             MOVS     R0,#+80
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD005             BEQ.N    ??gcode_M206_5
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000005E   0x4601             MOV      R1,R0
   \   00000060   0x2001             MOVS     R0,#+1
   \   00000062   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   9938              }
   9939              //#endif
   9940          
   9941              report_current_position();
   \                     ??gcode_M206_5: (+1)
   \   00000066   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000006A   0x.... 0x....      B.W      _Z23report_current_positionv
   \                     ??gcode_M206_1: (+1)
   \   0000006E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M206_0:
   \   00000070   0x........         DC32     mksCfg
   \   00000074   0x........         DC32     axis_codes
   9942            }
   9943          
   9944          #endif // HAS_M206_COMMAND
   9945          
   9946          #if 1//ENABLED(DELTA)
   9947            /**
   9948             * M665: Set delta configurations
   9949             *
   9950             *    H = delta height
   9951             *    L = diagonal rod
   9952             *    R = delta radius
   9953             *    S = segments per second
   9954             *    B = delta calibration radius
   9955             *    X = Alpha (Tower 1) angle trim
   9956             *    Y = Beta (Tower 2) angle trim
   9957             *    Z = Rotate A and B by this angle
   9958             */

   \                                 In section .text, align 4
   9959            inline void gcode_M665() {
   \                     _Z10gcode_M665v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   9960              if (parser.seen('H')) delta_height                   = parser.value_linear_units();
   \   00000002   0x2048             MOVS     R0,#+72
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M665_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000010   0x491F             LDR.N    R1,??gcode_M665_1
   \   00000012   0x6788             STR      R0,[R1, #+120]
   9961              if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
   \                     ??gcode_M665_0: (+1)
   \   00000014   0x4C1F             LDR.N    R4,??gcode_M665_1+0x4
   \   00000016   0x204C             MOVS     R0,#+76
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD002             BEQ.N    ??gcode_M665_2
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000024   0x66E0             STR      R0,[R4, #+108]
   9962              if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
   \                     ??gcode_M665_2: (+1)
   \   00000026   0x2052             MOVS     R0,#+82
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD002             BEQ.N    ??gcode_M665_3
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000034   0x66A0             STR      R0,[R4, #+104]
   9963              if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
   \                     ??gcode_M665_3: (+1)
   \   00000036   0x2053             MOVS     R0,#+83
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003C   0x2800             CMP      R0,#+0
   \   0000003E   0xD002             BEQ.N    ??gcode_M665_4
   \   00000040   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000044   0x6760             STR      R0,[R4, #+116]
   9964              if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
   \                     ??gcode_M665_4: (+1)
   \   00000046   0x2042             MOVS     R0,#+66
   \   00000048   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000004C   0x2800             CMP      R0,#+0
   \   0000004E   0xD002             BEQ.N    ??gcode_M665_5
   \   00000050   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000054   0x6720             STR      R0,[R4, #+112]
   9965              if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
   \                     ??gcode_M665_5: (+1)
   \   00000056   0x2058             MOVS     R0,#+88
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD002             BEQ.N    ??gcode_M665_6
   \   00000060   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000064   0x6320             STR      R0,[R4, #+48]
   9966              if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
   \                     ??gcode_M665_6: (+1)
   \   00000066   0x2059             MOVS     R0,#+89
   \   00000068   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000006C   0x2800             CMP      R0,#+0
   \   0000006E   0xD002             BEQ.N    ??gcode_M665_7
   \   00000070   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000074   0x6360             STR      R0,[R4, #+52]
   9967              if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
   \                     ??gcode_M665_7: (+1)
   \   00000076   0x205A             MOVS     R0,#+90
   \   00000078   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000007C   0x2800             CMP      R0,#+0
   \   0000007E   0xD002             BEQ.N    ??gcode_M665_8
   \   00000080   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000084   0x63A0             STR      R0,[R4, #+56]
   9968              recalc_delta_settings();
   \                     ??gcode_M665_8: (+1)
   \   00000086   0xE8BD 0x4010      POP      {R4,LR}
   \   0000008A   0x.... 0x....      B.W      _Z21recalc_delta_settingsv
   \   0000008E   0xBF00             Nop      
   \                     ??gcode_M665_1:
   \   00000090   0x........         DC32     mks_heating_busy
   \   00000094   0x........         DC32     axis_homed
   9969            }
   9970            /**
   9971             * M666: Set delta endstop adjustment
   9972             */

   \                                 In section .text, align 4
   9973            inline void gcode_M666() {
   \                     _Z10gcode_M666v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   9974              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9975                if (DEBUGGING(LEVELING)) {
   9976                  SERIAL_ECHOLNPGM(">>> gcode_M666");
   9977                }
   9978              #endif
   9979              LOOP_XYZ(i) {
   \   00000002   0x2400             MOVS     R4,#+0
   \   00000004   0xE01B             B.N      ??gcode_M666_0
   9980                if (parser.seen(axis_codes[i])) {
   \                     ??gcode_M666_1: (+1)
   \   00000006   0x480F             LDR.N    R0,??gcode_M666_2
   \   00000008   0x5620             LDRSB    R0,[R4, R0]
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD014             BEQ.N    ??gcode_M666_3
   9981                  if (parser.value_linear_units() * Z_HOME_DIR <= 0)
   \   00000012   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000016   0x4605             MOV      R5,R0
   \   00000018   0x480B             LDR.N    R0,??gcode_M666_2+0x4
   \   0000001A   0xF990 0x0007      LDRSB    R0,[R0, #+7]
   \   0000001E   0x.... 0x....      BL       __aeabi_i2f
   \   00000022   0x4629             MOV      R1,R5
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002E   0xD805             BHI.N    ??gcode_M666_3
   9982                    delta_endstop_adj[i] = parser.value_linear_units();
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000034   0x4905             LDR.N    R1,??gcode_M666_2+0x8
   \   00000036   0xEB01 0x0184      ADD      R1,R1,R4, LSL #+2
   \   0000003A   0x6048             STR      R0,[R1, #+4]
   9983                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   9984                    if (DEBUGGING(LEVELING)) {
   9985                      SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
   9986                      SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
   9987                    }
   9988                  #endif
   9989                }
   9990              }
   \                     ??gcode_M666_3: (+1)
   \   0000003C   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M666_0: (+1)
   \   0000003E   0x2C03             CMP      R4,#+3
   \   00000040   0xDBE1             BLT.N    ??gcode_M666_1
   9991              #if ENABLED(DEBUG_LEVELING_FEATURE)
   9992                if (DEBUGGING(LEVELING)) {
   9993                  SERIAL_ECHOLNPGM("<<< gcode_M666");
   9994                }
   9995              #endif
   9996            }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M666_2:
   \   00000044   0x........         DC32     axis_codes
   \   00000048   0x........         DC32     mksCfg
   \   0000004C   0x........         DC32     z_endstop_adj
   9997          
   9998          #elif IS_SCARA
   9999          
  10000            /**
  10001             * M665: Set SCARA settings
  10002             *
  10003             * Parameters:
  10004             *
  10005             *   S[segments-per-second] - Segments-per-second
  10006             *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
  10007             *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
  10008             *
  10009             *   A, P, and X are all aliases for the shoulder angle
  10010             *   B, T, and Y are all aliases for the elbow angle
  10011             */
  10012            inline void gcode_M665() {
  10013              if (parser.seen('S')) delta_segments_per_second = parser.value_float();
  10014          
  10015              const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
  10016              const uint8_t sumAPX = hasA + hasP + hasX;
  10017              if (sumAPX == 1)
  10018                home_offset[A_AXIS] = parser.value_float();
  10019              else if (sumAPX > 1) {
  10020                SERIAL_ERROR_START();
  10021                SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
  10022                return;
  10023              }
  10024          
  10025              const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
  10026              const uint8_t sumBTY = hasB + hasT + hasY;
  10027              if (sumBTY == 1)
  10028                home_offset[B_AXIS] = parser.value_float();
  10029              else if (sumBTY > 1) {
  10030                SERIAL_ERROR_START();
  10031                SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
  10032                return;
  10033              }
  10034            }
  10035          
  10036          
  10037          #endif
  10038          //#elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
  10039          
  10040            /**
  10041             * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
  10042             */

   \                                 In section .text, align 4
  10043            inline void gcode_M666_dual() {
   \                     _Z15gcode_M666_dualv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10044              SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
   \   00000002   0x480D             LDR.N    R0,??gcode_M666_dual_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10045              #if ENABLED(X_DUAL_ENDSTOPS)
  10046                if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
  10047                SERIAL_ECHOPAIR(" X", x_endstop_adj);
  10048              #endif
  10049              #if ENABLED(Y_DUAL_ENDSTOPS)
  10050                if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
  10051                SERIAL_ECHOPAIR(" Y", y_endstop_adj);
  10052              #endif
  10053              //#if ENABLED(Z_DUAL_ENDSTOPS)
  10054              if(Z_DUAL_ENDSTOPS==1)
   \   00000008   0x480C             LDR.N    R0,??gcode_M666_dual_0+0x4
   \   0000000A   0xF890 0x0102      LDRB     R0,[R0, #+258]
   \   0000000E   0x2801             CMP      R0,#+1
   \   00000010   0xD10C             BNE.N    ??gcode_M666_dual_1
  10055              {
  10056                if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
   \   00000012   0x4C0B             LDR.N    R4,??gcode_M666_dual_0+0x8
   \   00000014   0x205A             MOVS     R0,#+90
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD002             BEQ.N    ??gcode_M666_dual_2
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000022   0x6020             STR      R0,[R4, #+0]
  10057                SERIAL_ECHOPAIR(" Z", z_endstop_adj);
   \                     ??gcode_M666_dual_2: (+1)
   \   00000024   0x6821             LDR      R1,[R4, #+0]
   \   00000026   0x4807             LDR.N    R0,??gcode_M666_dual_0+0xC
   \   00000028   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10058              }
  10059              //#endif
  10060              SERIAL_EOL();
   \                     ??gcode_M666_dual_1: (+1)
   \   0000002C   0x210A             MOVS     R1,#+10
   \   0000002E   0x4806             LDR.N    R0,??gcode_M666_dual_0+0x10
   \   00000030   0xE8BD 0x4010      POP      {R4,LR}
   \   00000034   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M666_dual_0:
   \   00000038   0x........         DC32     _ZZ15gcode_M666_dualvEs
   \   0000003C   0x........         DC32     mksCfg
   \   00000040   0x........         DC32     z_endstop_adj
   \   00000044   0x........         DC32     _ZZ15gcode_M666_dualvEs_0
   \   00000048   0x........         DC32     Serial3
  10061            }
  10062          
  10063          //#endif // !DELTA && Z_DUAL_ENDSTOPS
  10064          
  10065          #if ENABLED(FWRETRACT)
  10066          
  10067            /**
  10068             * M207: Set firmware retraction values
  10069             *
  10070             *   S[+units]    retract_length
  10071             *   W[+units]    swap_retract_length (multi-extruder)
  10072             *   F[units/min] retract_feedrate_mm_s
  10073             *   Z[units]     retract_zlift
  10074             */
  10075            inline void gcode_M207() {
  10076              if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
  10077              if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
  10078              if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
  10079              if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
  10080            }
  10081          
  10082            /**
  10083             * M208: Set firmware un-retraction values
  10084             *
  10085             *   S[+units]    retract_recover_length (in addition to M207 S*)
  10086             *   W[+units]    swap_retract_recover_length (multi-extruder)
  10087             *   F[units/min] retract_recover_feedrate_mm_s
  10088             *   R[units/min] swap_retract_recover_feedrate_mm_s
  10089             */
  10090            inline void gcode_M208() {
  10091              if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
  10092              if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
  10093              if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
  10094              if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
  10095            }
  10096          
  10097            /**
  10098             * M209: Enable automatic retract (M209 S1)
  10099             *   For slicers that don't support G10/11, reversed extrude-only
  10100             *   moves will be classified as retraction.
  10101             */
  10102            inline void gcode_M209() {
  10103              if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
  10104                if (parser.seen('S')) {
  10105                  autoretract_enabled = parser.value_bool();
  10106                  for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
  10107                }
  10108              }
  10109            }
  10110          
  10111          #endif // FWRETRACT
  10112          
  10113          /**
  10114           * M211: Enable, Disable, and/or Report software endstops
  10115           *
  10116           * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
  10117           */

   \                                 In section .text, align 4
  10118          inline void gcode_M211() {
   \                     _Z10gcode_M211v: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
  10119            SERIAL_ECHO_START();
   \   00000004   0x482B             LDR.N    R0,??gcode_M211_0
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10120            #if HAS_SOFTWARE_ENDSTOPS
  10121              if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
   \   0000000A   0x4C2B             LDR.N    R4,??gcode_M211_0+0x4
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD002             BEQ.N    ??gcode_M211_1
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   0000001A   0x7220             STRB     R0,[R4, #+8]
  10122              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
   \                     ??gcode_M211_1: (+1)
   \   0000001C   0x4827             LDR.N    R0,??gcode_M211_0+0x8
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10123              serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
   \   00000022   0x7A20             LDRB     R0,[R4, #+8]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD001             BEQ.N    ??gcode_M211_2
   \   00000028   0x4825             LDR.N    R0,??gcode_M211_0+0xC
   \   0000002A   0xE000             B.N      ??gcode_M211_3
   \                     ??gcode_M211_2: (+1)
   \   0000002C   0x4825             LDR.N    R0,??gcode_M211_0+0x10
   \                     ??gcode_M211_3: (+1)
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10124            #else
  10125              SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
  10126              SERIAL_ECHOPGM(MSG_OFF);
  10127            #endif
  10128            SERIAL_ECHOPGM(MSG_SOFT_MIN);
   \   00000032   0x4825             LDR.N    R0,??gcode_M211_0+0x14
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10129            SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
   \   00000038   0x4D24             LDR.N    R5,??gcode_M211_0+0x18
   \   0000003A   0x4E25             LDR.N    R6,??gcode_M211_0+0x1C
   \   0000003C   0x6C71             LDR      R1,[R6, #+68]
   \   0000003E   0x6BB0             LDR      R0,[R6, #+56]
   \   00000040   0x.... 0x....      BL       __aeabi_fadd
   \   00000044   0x4601             MOV      R1,R0
   \   00000046   0x4628             MOV      R0,R5
   \   00000048   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10130            SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
   \   0000004C   0x4F21             LDR.N    R7,??gcode_M211_0+0x20
   \   0000004E   0x6CB1             LDR      R1,[R6, #+72]
   \   00000050   0x6BF0             LDR      R0,[R6, #+60]
   \   00000052   0x.... 0x....      BL       __aeabi_fadd
   \   00000056   0x4601             MOV      R1,R0
   \   00000058   0x4638             MOV      R0,R7
   \   0000005A   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10131            SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
   \   0000005E   0xF8DF 0x8078      LDR.W    R8,??gcode_M211_0+0x24
   \   00000062   0x6CF1             LDR      R1,[R6, #+76]
   \   00000064   0x6C30             LDR      R0,[R6, #+64]
   \   00000066   0x.... 0x....      BL       __aeabi_fadd
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10132            SERIAL_ECHOPGM(MSG_SOFT_MAX);
   \   00000072   0x481A             LDR.N    R0,??gcode_M211_0+0x28
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10133            SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
   \   00000078   0x6A61             LDR      R1,[R4, #+36]
   \   0000007A   0x6BB0             LDR      R0,[R6, #+56]
   \   0000007C   0x.... 0x....      BL       __aeabi_fadd
   \   00000080   0x4601             MOV      R1,R0
   \   00000082   0x4628             MOV      R0,R5
   \   00000084   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10134            SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
   \   00000088   0x6AA1             LDR      R1,[R4, #+40]
   \   0000008A   0x6BF0             LDR      R0,[R6, #+60]
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x4601             MOV      R1,R0
   \   00000092   0x4638             MOV      R0,R7
   \   00000094   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10135            SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
   \   00000098   0x6AE1             LDR      R1,[R4, #+44]
   \   0000009A   0x6C30             LDR      R0,[R6, #+64]
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x4601             MOV      R1,R0
   \   000000A2   0x4640             MOV      R0,R8
   \   000000A4   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   000000A8   0x210A             MOVS     R1,#+10
   \   000000AA   0x480D             LDR.N    R0,??gcode_M211_0+0x2C
   \   000000AC   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000000B0   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M211_0:
   \   000000B4   0x........         DC32     echomagic
   \   000000B8   0x........         DC32     axis_homed
   \   000000BC   0x........         DC32     _ZZ10gcode_M211vEs
   \   000000C0   0x........         DC32     _ZZ10gcode_M211vEs_0
   \   000000C4   0x........         DC32     _ZZ10gcode_M211vEs_1
   \   000000C8   0x........         DC32     _ZZ10gcode_M211vEs_2
   \   000000CC   0x........         DC32     _ZZ10gcode_M211vEs_3
   \   000000D0   0x........         DC32     mks_heating_busy
   \   000000D4   0x........         DC32     _ZZ10gcode_M211vEs_4
   \   000000D8   0x........         DC32     _ZZ10gcode_M211vEs_5
   \   000000DC   0x........         DC32     _ZZ10gcode_M211vEs_6
   \   000000E0   0x........         DC32     Serial3
  10136          }
  10137          
  10138          #if HOTENDS > 1
  10139          
  10140            /**
  10141             * M218 - set hotend offset (in linear units)
  10142             *
  10143             *   T<tool>
  10144             *   X<xoffset>
  10145             *   Y<yoffset>
  10146             *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
  10147             */

   \                                 In section .text, align 4
  10148            inline void gcode_M218() {
   \                     _Z10gcode_M218v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
  10149              if (get_target_extruder_from_command(218) || target_extruder == 0) return;
   \   00000004   0x20DA             MOVS     R0,#+218
   \   00000006   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD150             BNE.N    ??gcode_M218_0
   \   0000000E   0x4C29             LDR.N    R4,??gcode_M218_1
   \   00000010   0x7960             LDRB     R0,[R4, #+5]
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD04C             BEQ.N    ??gcode_M218_0
  10150          
  10151              if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
   \   00000016   0x2058             MOVS     R0,#+88
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD005             BEQ.N    ??gcode_M218_2
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000024   0x7961             LDRB     R1,[R4, #+5]
   \   00000026   0x4A24             LDR.N    R2,??gcode_M218_1+0x4
   \   00000028   0xF842 0x0021      STR      R0,[R2, R1, LSL #+2]
  10152              if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
   \                     ??gcode_M218_2: (+1)
   \   0000002C   0x2059             MOVS     R0,#+89
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000032   0x2800             CMP      R0,#+0
   \   00000034   0xD006             BEQ.N    ??gcode_M218_3
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000003A   0x7961             LDRB     R1,[R4, #+5]
   \   0000003C   0x4A1E             LDR.N    R2,??gcode_M218_1+0x4
   \   0000003E   0xEB02 0x0181      ADD      R1,R2,R1, LSL #+2
   \   00000042   0x6088             STR      R0,[R1, #+8]
  10153          
  10154              #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
  10155                if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
  10156              #endif
  10157          
  10158              SERIAL_ECHO_START();
   \                     ??gcode_M218_3: (+1)
   \   00000044   0x481D             LDR.N    R0,??gcode_M218_1+0x8
   \   00000046   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10159              SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
   \   0000004A   0x481D             LDR.N    R0,??gcode_M218_1+0xC
   \   0000004C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10160              HOTEND_LOOP() {
   \   00000050   0x2400             MOVS     R4,#+0
   \   00000052   0x4D1C             LDR.N    R5,??gcode_M218_1+0x10
   \   00000054   0x4E18             LDR.N    R6,??gcode_M218_1+0x4
   \   00000056   0xE020             B.N      ??gcode_M218_4
  10161                SERIAL_CHAR(' ');
   \                     ??gcode_M218_5: (+1)
   \   00000058   0x2120             MOVS     R1,#+32
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10162                SERIAL_ECHO(hotend_offset[X_AXIS][e]);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x9000             STR      R0,[SP, #+0]
   \   00000064   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   00000068   0x.... 0x....      BL       __aeabi_f2d
   \   0000006C   0x4602             MOV      R2,R0
   \   0000006E   0x460B             MOV      R3,R1
   \   00000070   0x4628             MOV      R0,R5
   \   00000072   0x.... 0x....      BL       _ZN5Print5printEdi
  10163                SERIAL_CHAR(',');
   \   00000076   0x212C             MOVS     R1,#+44
   \   00000078   0x4628             MOV      R0,R5
   \   0000007A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10164                SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
   \   0000007E   0x2002             MOVS     R0,#+2
   \   00000080   0x9000             STR      R0,[SP, #+0]
   \   00000082   0xEB06 0x0084      ADD      R0,R6,R4, LSL #+2
   \   00000086   0x6880             LDR      R0,[R0, #+8]
   \   00000088   0x.... 0x....      BL       __aeabi_f2d
   \   0000008C   0x4602             MOV      R2,R0
   \   0000008E   0x460B             MOV      R3,R1
   \   00000090   0x4628             MOV      R0,R5
   \   00000092   0x.... 0x....      BL       _ZN5Print5printEdi
  10165                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
  10166                  SERIAL_CHAR(',');
  10167                  SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
  10168                #endif
  10169              }
   \   00000096   0x1C64             ADDS     R4,R4,#+1
   \   00000098   0xB264             SXTB     R4,R4
   \                     ??gcode_M218_4: (+1)
   \   0000009A   0x480B             LDR.N    R0,??gcode_M218_1+0x14
   \   0000009C   0xF890 0x00F7      LDRB     R0,[R0, #+247]
   \   000000A0   0x4284             CMP      R4,R0
   \   000000A2   0xDBD9             BLT.N    ??gcode_M218_5
  10170              SERIAL_EOL();
   \   000000A4   0x210A             MOVS     R1,#+10
   \   000000A6   0x4628             MOV      R0,R5
   \   000000A8   0xE8BD 0x407C      POP      {R2-R6,LR}
   \   000000AC   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M218_0: (+1)
   \   000000B0   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return
   \   000000B2   0xBF00             Nop      
   \                     ??gcode_M218_1:
   \   000000B4   0x........         DC32     mks_heating_busy
   \   000000B8   0x........         DC32     hotend_offset
   \   000000BC   0x........         DC32     echomagic
   \   000000C0   0x........         DC32     _ZZ10gcode_M218vEs
   \   000000C4   0x........         DC32     Serial3
   \   000000C8   0x........         DC32     mksCfg
  10171            }
  10172          
  10173          #endif // HOTENDS > 1
  10174          
  10175          /**
  10176           * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
  10177           */

   \                                 In section .text, align 4
  10178          inline void gcode_M220() {
   \                     _Z10gcode_M220v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10179            if (parser.seenval('S')) feedrate_percentage = parser.value_int();
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M220_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4901             LDR.N    R1,??gcode_M220_1
   \   00000012   0x80C8             STRH     R0,[R1, #+6]
  10180          }
   \                     ??gcode_M220_0: (+1)
   \   00000014   0xBD01             POP      {R0,PC}          ;; return
   \   00000016   0xBF00             Nop      
   \                     ??gcode_M220_1:
   \   00000018   0x........         DC32     mks_heating_busy
  10181          
  10182          /**
  10183           * M221: Set extrusion percentage (M221 T0 S95)
  10184           */

   \                                 In section .text, align 4
  10185          inline void gcode_M221() {
   \                     _Z10gcode_M221v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10186            if (get_target_extruder_from_command(221)) return;
   \   00000002   0x20DD             MOVS     R0,#+221
   \   00000004   0x.... 0x....      BL       _Z32get_target_extruder_from_commandt
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD110             BNE.N    ??gcode_M221_0
  10187            if (parser.seenval('S')) {
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD00B             BEQ.N    ??gcode_M221_0
  10188              planner.flow_percentage[target_extruder] = parser.value_int();
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001A   0x4905             LDR.N    R1,??gcode_M221_1
   \   0000001C   0x7949             LDRB     R1,[R1, #+5]
   \   0000001E   0x4A05             LDR.N    R2,??gcode_M221_1+0x4
   \   00000020   0xF822 0x0011      STRH     R0,[R2, R1, LSL #+1]
  10189              planner.refresh_e_factor(target_extruder);
   \   00000024   0x4608             MOV      R0,R1
   \   00000026   0xE8BD 0x4002      POP      {R1,LR}
   \   0000002A   0x.... 0x....      B.W      _ZN7Planner16refresh_e_factorEh
  10190            }
  10191          }
   \                     ??gcode_M221_0: (+1)
   \   0000002E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M221_1:
   \   00000030   0x........         DC32     mks_heating_busy
   \   00000034   0x........         DC32     _ZN7Planner15flow_percentageE
  10192          
  10193          /**
  10194           * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
  10195           */

   \                                 In section .text, align 4
  10196          inline void gcode_M226() {
   \                     _Z10gcode_M226v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  10197            if (parser.seen('P')) {
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD03E             BEQ.N    ??gcode_M226_0
  10198              const int pin_number = parser.value_int(),
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x4604             MOV      R4,R0
  10199                        pin_state = parser.intval('S', -1); // required pin state - default is inverted
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x2053             MOVS     R0,#+83
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4605             MOV      R5,R0
  10200          
  10201              if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
   \   0000001E   0x1C68             ADDS     R0,R5,#+1
   \   00000020   0x2803             CMP      R0,#+3
   \   00000022   0xD232             BCS.N    ??gcode_M226_0
   \   00000024   0x2C00             CMP      R4,#+0
   \   00000026   0xD430             BMI.N    ??gcode_M226_0
   \   00000028   0x4620             MOV      R0,R4
   \   0000002A   0xB240             SXTB     R0,R0
   \   0000002C   0x.... 0x....      BL       _Z16pin_is_protecteda
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD12A             BNE.N    ??gcode_M226_0
  10202          
  10203                int target = LOW;
   \   00000034   0x2600             MOVS     R6,#+0
  10204          
  10205                stepper.synchronize();
   \   00000036   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10206          
  10207                pinMode(pin_number, INPUT);
  10208                switch (pin_state) {
   \   0000003A   0x2D01             CMP      R5,#+1
   \   0000003C   0xD003             BEQ.N    ??gcode_M226_1
   \   0000003E   0xF1B5 0x3FFF      CMP      R5,#-1
   \   00000042   0xD002             BEQ.N    ??gcode_M226_2
   \   00000044   0xE00F             B.N      ??gcode_M226_3
  10209                  case 1:
  10210                    target = HIGH;
   \                     ??gcode_M226_1: (+1)
   \   00000046   0x2601             MOVS     R6,#+1
  10211                    break;
   \   00000048   0xE00D             B.N      ??gcode_M226_3
  10212                  case 0:
  10213                    target = LOW;
  10214                    break;
  10215                  case -1:
  10216                    target = !digitalRead(pin_number);
   \                     ??gcode_M226_2: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD50B             BPL.N    ??gcode_M226_3
   \   0000004E   0x480F             LDR.N    R0,??gcode_M226_4
   \   00000050   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000054   0x480E             LDR.N    R0,??gcode_M226_4+0x4
   \   00000056   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   0000005A   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000005E   0x4606             MOV      R6,R0
   \   00000060   0xE001             B.N      ??gcode_M226_3
  10217                    break;
  10218                }
  10219          
  10220                while (digitalRead(pin_number) != target) idle();
   \                     ??gcode_M226_5: (+1)
   \   00000062   0x.... 0x....      BL       _Z4idlev
   \                     ??gcode_M226_3: (+1)
   \   00000066   0x2C00             CMP      R4,#+0
   \   00000068   0xD408             BMI.N    ??gcode_M226_6
   \   0000006A   0x4808             LDR.N    R0,??gcode_M226_4
   \   0000006C   0xF830 0x1014      LDRH     R1,[R0, R4, LSL #+1]
   \   00000070   0x4807             LDR.N    R0,??gcode_M226_4+0x4
   \   00000072   0xF850 0x0024      LDR      R0,[R0, R4, LSL #+2]
   \   00000076   0x.... 0x....      BL       HAL_GPIO_ReadPin
   \   0000007A   0xE004             B.N      ??gcode_M226_7
   \                     ??gcode_M226_6: (+1)
   \   0000007C   0x4630             MOV      R0,R6
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x4180             SBCS     R0,R0,R0
   \   00000082   0x43C0             MVNS     R0,R0
   \   00000084   0x0FC0             LSRS     R0,R0,#+31
   \                     ??gcode_M226_7: (+1)
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD1EB             BNE.N    ??gcode_M226_5
  10221          
  10222              } // pin_state -1 0 1 && pin_number > -1
  10223            } // parser.seen('P')
  10224          }
   \                     ??gcode_M226_0: (+1)
   \   0000008A   0xBD70             POP      {R4-R6,PC}       ;; return
   \                     ??gcode_M226_4:
   \   0000008C   0x........         DC32     gArrayGpioPin
   \   00000090   0x........         DC32     gArrayGpioPort
  10225          
  10226          #if ENABLED(EXPERIMENTAL_I2CBUS)
  10227          
  10228            /**
  10229             * M260: Send data to a I2C slave device
  10230             *
  10231             * This is a PoC, the formating and arguments for the GCODE will
  10232             * change to be more compatible, the current proposal is:
  10233             *
  10234             *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
  10235             *
  10236             *  M260 B<byte-1 value in base 10>
  10237             *  M260 B<byte-2 value in base 10>
  10238             *  M260 B<byte-3 value in base 10>
  10239             *
  10240             *  M260 S1 ; Send the buffered data and reset the buffer
  10241             *  M260 R1 ; Reset the buffer without sending data
  10242             *
  10243             */
  10244            inline void gcode_M260() {
  10245              // Set the target address
  10246              if (parser.seen('A')) i2c.address(parser.value_byte());
  10247          
  10248              // Add a new byte to the buffer
  10249              if (parser.seen('B')) i2c.addbyte(parser.value_byte());
  10250          
  10251              // Flush the buffer to the bus
  10252              if (parser.seen('S')) i2c.send();
  10253          
  10254              // Reset and rewind the buffer
  10255              else if (parser.seen('R')) i2c.reset();
  10256            }
  10257          
  10258            /**
  10259             * M261: Request X bytes from I2C slave device
  10260             *
  10261             * Usage: M261 A<slave device address base 10> B<number of bytes>
  10262             */
  10263            inline void gcode_M261() {
  10264              if (parser.seen('A')) i2c.address(parser.value_byte());
  10265          
  10266              uint8_t bytes = parser.byteval('B', 1);
  10267          
  10268              if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
  10269                i2c.relay(bytes);
  10270              }
  10271              else {
  10272                SERIAL_ERROR_START();
  10273                SERIAL_ERRORLN("Bad i2c request");
  10274              }
  10275            }
  10276          
  10277          #endif // EXPERIMENTAL_I2CBUS
  10278          
  10279          //#if HAS_SERVOS
  10280          
  10281            /**
  10282             * M280: Get or set servo position. P<index> [S<angle>]
  10283             */

   \                                 In section .text, align 4
  10284            inline void gcode_M280() {
   \                     _Z10gcode_M280v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10285            	int mksAngle;
  10286            #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
  10287              if (!parser.seen('P')) return;
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD03C             BEQ.N    ??gcode_M280_0
  10288              const int servo_index = parser.value_int();
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000010   0x0004             MOVS     R4,R0
  10289              if (WITHIN(servo_index, 0, 0/*NUM_SERVOS - 1*/)) {
   \   00000012   0xD12C             BNE.N    ??gcode_M280_1
  10290              if (parser.seen('S'))
   \   00000014   0x2053             MOVS     R0,#+83
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD01B             BEQ.N    ??gcode_M280_2
  10291              //MOVE_SERVO(servo_index, parser.value_int());
  10292              {
  10293               switch(parser.value_int())
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000022   0x280A             CMP      R0,#+10
   \   00000024   0xD006             BEQ.N    ??gcode_M280_3
   \   00000026   0x283C             CMP      R0,#+60
   \   00000028   0xD00D             BEQ.N    ??gcode_M280_4
   \   0000002A   0x285A             CMP      R0,#+90
   \   0000002C   0xD005             BEQ.N    ??gcode_M280_5
   \   0000002E   0x2878             CMP      R0,#+120
   \   00000030   0xD006             BEQ.N    ??gcode_M280_6
   \   00000032   0xE00B             B.N      ??gcode_M280_7
  10294              	{
  10295              	case 10:
  10296          			mksAngle = 700/2;
   \                     ??gcode_M280_3: (+1)
   \   00000034   0xF44F 0x70AF      MOV      R0,#+350
  10297          			break;
   \   00000038   0xE00A             B.N      ??gcode_M280_8
  10298          		case 90:
  10299          			mksAngle = 1500/2;
   \                     ??gcode_M280_5: (+1)
   \   0000003A   0xF240 0x20EE      MOVW     R0,#+750
  10300          			break;
   \   0000003E   0xE007             B.N      ??gcode_M280_8
  10301          			case 120:
  10302          			mksAngle = 1800/2;
   \                     ??gcode_M280_6: (+1)
   \   00000040   0xF44F 0x7061      MOV      R0,#+900
  10303          			break;
   \   00000044   0xE004             B.N      ??gcode_M280_8
  10304          		case 160:
  10305          			mksAngle = 2200/2;
  10306          			break;
  10307          		case 60:
  10308          			mksAngle = 1200/2;
   \                     ??gcode_M280_4: (+1)
   \   00000046   0xF44F 0x7016      MOV      R0,#+600
  10309          			break;
   \   0000004A   0xE001             B.N      ??gcode_M280_8
  10310          		default:
  10311          			mksAngle = 2200/2;
   \                     ??gcode_M280_7: (+1)
   \   0000004C   0xF240 0x404C      MOVW     R0,#+1100
  10312          			break;
  10313          			
  10314              	}
  10315          		MKS_TOUCH_TIM = mksAngle;
   \                     ??gcode_M280_8: (+1)
   \   00000050   0x490D             LDR.N    R1,??gcode_M280_9  ;; 0x40012c34
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0xBD10             POP      {R4,PC}
  10316              }        
  10317                else {
  10318                  SERIAL_ECHO_START();
   \                     ??gcode_M280_2: (+1)
   \   00000056   0x480D             LDR.N    R0,??gcode_M280_9+0x4
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10319                  SERIAL_ECHOPAIR(" Servo ", servo_index);
   \   0000005C   0x2100             MOVS     R1,#+0
   \   0000005E   0x480C             LDR.N    R0,??gcode_M280_9+0x8
   \   00000060   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  10320          		SERIAL_ECHOLNPGM(" out of range");
   \   00000064   0x480B             LDR.N    R0,??gcode_M280_9+0xC
   \   00000066   0xE8BD 0x4010      POP      {R4,LR}
   \   0000006A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10321                  //SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
  10322                }
  10323              }
  10324              else {
  10325                SERIAL_ERROR_START();
   \                     ??gcode_M280_1: (+1)
   \   0000006E   0x480A             LDR.N    R0,??gcode_M280_9+0x10
   \   00000070   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10326                SERIAL_ECHOPAIR("Servo ", servo_index);
   \   00000074   0x4621             MOV      R1,R4
   \   00000076   0x4809             LDR.N    R0,??gcode_M280_9+0x14
   \   00000078   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  10327                SERIAL_ECHOLNPGM(" out of range");
   \   0000007C   0x4805             LDR.N    R0,??gcode_M280_9+0xC
   \   0000007E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000082   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10328              }
  10329              #endif
  10330            }
   \                     ??gcode_M280_0: (+1)
   \   00000086   0xBD10             POP      {R4,PC}          ;; return
   \                     ??gcode_M280_9:
   \   00000088   0x40012C34         DC32     0x40012c34
   \   0000008C   0x........         DC32     echomagic
   \   00000090   0x........         DC32     _ZZ10gcode_M280vEs
   \   00000094   0x........         DC32     _ZZ10gcode_M280vEs_0
   \   00000098   0x........         DC32     errormagic
   \   0000009C   0x........         DC32     _ZZ10gcode_M280vEs_1
  10331          
  10332          //#endif // HAS_SERVOS
  10333          
  10334          #if ENABLED(BABYSTEPPING)
  10335          
  10336            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
  10337              FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
  10338                zprobe_zoffset += offs;
  10339                SERIAL_ECHO_START();
  10340                SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
  10341              }
  10342            #endif
  10343          
  10344            /**
  10345             * M290: Babystepping
  10346             */
  10347            inline void gcode_M290() {
  10348              #if ENABLED(BABYSTEP_XY)
  10349                for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
  10350                  if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
  10351                    const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
  10352                    thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
  10353                    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
  10354                      if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
  10355                    #endif
  10356                  }
  10357              #else
  10358                if (parser.seenval('Z') || parser.seenval('S')) {
  10359                  const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
  10360                  thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
  10361                  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
  10362                    if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
  10363                  #endif
  10364                }
  10365              #endif
  10366            }
  10367          
  10368          #endif // BABYSTEPPING
  10369          
  10370          #if HAS_BUZZER
  10371          
  10372            /**
  10373             * M300: Play beep sound S<frequency Hz> P<duration ms>
  10374             */
  10375            inline void gcode_M300() {
  10376              uint16_t const frequency = parser.ushortval('S', 260);
  10377              uint16_t duration = parser.ushortval('P', 1000);
  10378          
  10379              // Limits the tone duration to 0-5 seconds.
  10380              NOMORE(duration, 5000);
  10381          
  10382              BUZZ(duration, frequency);
  10383            }
  10384          
  10385          #endif // HAS_BUZZER
  10386          
  10387          #if 1//ENABLED(PIDTEMP)
  10388          
  10389            /**
  10390             * M301: Set PID parameters P I D (and optionally C, L)
  10391             *
  10392             *   P[float] Kp term
  10393             *   I[float] Ki term (unscaled)
  10394             *   D[float] Kd term (unscaled)
  10395             *
  10396             * With PID_EXTRUSION_SCALING:
  10397             *
  10398             *   C[float] Kc term
  10399             *   L[float] LPQ length
  10400             */

   \                                 In section .text, align 4
  10401            inline void gcode_M301() {
   \                     _Z10gcode_M301v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10402          
  10403              // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
  10404              // default behaviour (omitting E parameter) is to update for extruder 0 only
  10405              const uint8_t e = parser.byteval('E'); // extruder being updated
  10406          
  10407              if (e < HOTENDS) { // catch bad input value
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x2045             MOVS     R0,#+69
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser7bytevalEch
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xDA53             BGE.N    ??gcode_M301_0
  10408                if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
   \   0000000E   0x2050             MOVS     R0,#+80
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??gcode_M301_1
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000001C   0x492D             LDR.N    R1,??gcode_M301_2
   \   0000001E   0x6008             STR      R0,[R1, #+0]
  10409                if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
   \                     ??gcode_M301_1: (+1)
   \   00000020   0x2049             MOVS     R0,#+73
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000026   0x2800             CMP      R0,#+0
   \   00000028   0xD00B             BEQ.N    ??gcode_M301_3
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   0000002E   0x.... 0x....      BL       __aeabi_f2d
   \   00000032   0x4A29             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000034   0x4B29             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   00000036   0x.... 0x....      BL       __aeabi_dmul
   \   0000003A   0x.... 0x....      BL       __aeabi_d2f
   \   0000003E   0x4928             LDR.N    R1,??gcode_M301_2+0xC
   \   00000040   0x6008             STR      R0,[R1, #+0]
  10410                if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
   \                     ??gcode_M301_3: (+1)
   \   00000042   0x4C28             LDR.N    R4,??gcode_M301_2+0x10
   \   00000044   0x2044             MOVS     R0,#+68
   \   00000046   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000004A   0x2800             CMP      R0,#+0
   \   0000004C   0xD00A             BEQ.N    ??gcode_M301_4
   \   0000004E   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000052   0x.... 0x....      BL       __aeabi_f2d
   \   00000056   0x4A20             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000058   0x4B20             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   0000005A   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005E   0x.... 0x....      BL       __aeabi_d2f
   \   00000062   0x6020             STR      R0,[R4, #+0]
  10411                #if ENABLED(PID_EXTRUSION_SCALING)
  10412                  if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
  10413                  if (parser.seen('L')) lpq_len = parser.value_float();
  10414                  NOMORE(lpq_len, LPQ_MAX_LEN);
  10415                #endif
  10416          
  10417                thermalManager.updatePID();
   \                     ??gcode_M301_4: (+1)
   \   00000064   0x.... 0x....      BL       _ZN11Temperature9updatePIDEv
  10418                SERIAL_ECHO_START();
   \   00000068   0x481F             LDR.N    R0,??gcode_M301_2+0x14
   \   0000006A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10419                #if ENABLED(PID_PARAMS_PER_HOTEND)
  10420                  SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
  10421                #endif // PID_PARAMS_PER_HOTEND
  10422                SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
   \   0000006E   0x4819             LDR.N    R0,??gcode_M301_2
   \   00000070   0x6801             LDR      R1,[R0, #+0]
   \   00000072   0x481E             LDR.N    R0,??gcode_M301_2+0x18
   \   00000074   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10423                SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
   \   00000078   0x4819             LDR.N    R0,??gcode_M301_2+0xC
   \   0000007A   0x6800             LDR      R0,[R0, #+0]
   \   0000007C   0x.... 0x....      BL       __aeabi_f2d
   \   00000080   0x4A15             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   00000082   0x4B16             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   00000084   0x.... 0x....      BL       __aeabi_ddiv
   \   00000088   0x4602             MOV      R2,R0
   \   0000008A   0x460B             MOV      R3,R1
   \   0000008C   0x4818             LDR.N    R0,??gcode_M301_2+0x1C
   \   0000008E   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
  10424                SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
   \   00000092   0x6820             LDR      R0,[R4, #+0]
   \   00000094   0x.... 0x....      BL       __aeabi_f2d
   \   00000098   0x4A0F             LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
   \   0000009A   0x4B10             LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
   \   0000009C   0x.... 0x....      BL       __aeabi_dmul
   \   000000A0   0x4602             MOV      R2,R0
   \   000000A2   0x460B             MOV      R3,R1
   \   000000A4   0x4813             LDR.N    R0,??gcode_M301_2+0x20
   \   000000A6   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
  10425                #if ENABLED(PID_EXTRUSION_SCALING)
  10426                  //Kc does not have scaling applied above, or in resetting defaults
  10427                  SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
  10428                #endif
  10429                SERIAL_EOL();
   \   000000AA   0x210A             MOVS     R1,#+10
   \   000000AC   0x4812             LDR.N    R0,??gcode_M301_2+0x24
   \   000000AE   0xE8BD 0x4010      POP      {R4,LR}
   \   000000B2   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
  10430              }
  10431              else {
  10432                SERIAL_ERROR_START();
   \                     ??gcode_M301_0: (+1)
   \   000000B6   0x4811             LDR.N    R0,??gcode_M301_2+0x28
   \   000000B8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10433                SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
   \   000000BC   0x4C0E             LDR.N    R4,??gcode_M301_2+0x24
   \   000000BE   0x4910             LDR.N    R1,??gcode_M301_2+0x2C
   \   000000C0   0x4620             MOV      R0,R4
   \   000000C2   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   000000C6   0x210A             MOVS     R1,#+10
   \   000000C8   0x4620             MOV      R0,R4
   \   000000CA   0xE8BD 0x4010      POP      {R4,LR}
   \   000000CE   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   000000D2   0xBF00             Nop      
   \                     ??gcode_M301_2:
   \   000000D4   0x........         DC32     _ZN11Temperature2KpE
   \   000000D8   0x88E368F1         DC32     0x88e368f1
   \   000000DC   0x3FC4F8B5         DC32     0x3fc4f8b5
   \   000000E0   0x........         DC32     _ZN11Temperature2KiE
   \   000000E4   0x........         DC32     _ZN11Temperature2KdE
   \   000000E8   0x........         DC32     echomagic
   \   000000EC   0x........         DC32     _ZZ10gcode_M301vEs
   \   000000F0   0x........         DC32     _ZZ10gcode_M301vEs_0
   \   000000F4   0x........         DC32     _ZZ10gcode_M301vEs_1
   \   000000F8   0x........         DC32     Serial3
   \   000000FC   0x........         DC32     errormagic
   \   00000100   0x........         DC32     _ZZ10gcode_M301vEs_2
  10434              }
  10435            }
  10436          
  10437          #endif // PIDTEMP
  10438          
  10439          #if 1//ENABLED(PIDTEMPBED)
  10440          

   \                                 In section .text, align 4
  10441            inline void gcode_M304() {
   \                     _Z10gcode_M304v: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  10442              if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
   \   00000002   0x2050             MOVS     R0,#+80
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD003             BEQ.N    ??gcode_M304_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000010   0x4925             LDR.N    R1,??gcode_M304_1
   \   00000012   0x6008             STR      R0,[R1, #+0]
  10443              if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
   \                     ??gcode_M304_0: (+1)
   \   00000014   0x2049             MOVS     R0,#+73
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD00B             BEQ.N    ??gcode_M304_2
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000022   0x.... 0x....      BL       __aeabi_f2d
   \   00000026   0x4A21             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   00000028   0x4B21             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   0000002A   0x.... 0x....      BL       __aeabi_dmul
   \   0000002E   0x.... 0x....      BL       __aeabi_d2f
   \   00000032   0x4920             LDR.N    R1,??gcode_M304_1+0xC
   \   00000034   0x6008             STR      R0,[R1, #+0]
  10444              if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
   \                     ??gcode_M304_2: (+1)
   \   00000036   0x4C20             LDR.N    R4,??gcode_M304_1+0x10
   \   00000038   0x2044             MOVS     R0,#+68
   \   0000003A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xD00A             BEQ.N    ??gcode_M304_3
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser11value_floatEv
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x4A18             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   0000004C   0x4B18             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   0000004E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000052   0x.... 0x....      BL       __aeabi_d2f
   \   00000056   0x6020             STR      R0,[R4, #+0]
  10445          
  10446              SERIAL_ECHO_START();
   \                     ??gcode_M304_3: (+1)
   \   00000058   0x4818             LDR.N    R0,??gcode_M304_1+0x14
   \   0000005A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10447              SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
   \   0000005E   0x4812             LDR.N    R0,??gcode_M304_1
   \   00000060   0x6801             LDR      R1,[R0, #+0]
   \   00000062   0x4817             LDR.N    R0,??gcode_M304_1+0x18
   \   00000064   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
  10448              SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
   \   00000068   0x4812             LDR.N    R0,??gcode_M304_1+0xC
   \   0000006A   0x6800             LDR      R0,[R0, #+0]
   \   0000006C   0x.... 0x....      BL       __aeabi_f2d
   \   00000070   0x4A0E             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   00000072   0x4B0F             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   00000074   0x.... 0x....      BL       __aeabi_ddiv
   \   00000078   0x4602             MOV      R2,R0
   \   0000007A   0x460B             MOV      R3,R1
   \   0000007C   0x4811             LDR.N    R0,??gcode_M304_1+0x1C
   \   0000007E   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
  10449              SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
   \   00000082   0x6820             LDR      R0,[R4, #+0]
   \   00000084   0x.... 0x....      BL       __aeabi_f2d
   \   00000088   0x4A08             LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
   \   0000008A   0x4B09             LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
   \   0000008C   0x.... 0x....      BL       __aeabi_dmul
   \   00000090   0x4602             MOV      R2,R0
   \   00000092   0x460B             MOV      R3,R1
   \   00000094   0x480C             LDR.N    R0,??gcode_M304_1+0x20
   \   00000096   0x.... 0x....      BL       _Z17serial_echopair_PPKcd
   \   0000009A   0x210A             MOVS     R1,#+10
   \   0000009C   0x480B             LDR.N    R0,??gcode_M304_1+0x24
   \   0000009E   0xE8BD 0x4010      POP      {R4,LR}
   \   000000A2   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   000000A6   0xBF00             Nop      
   \                     ??gcode_M304_1:
   \   000000A8   0x........         DC32     _ZN11Temperature5bedKpE
   \   000000AC   0x88E368F1         DC32     0x88e368f1
   \   000000B0   0x3FC4F8B5         DC32     0x3fc4f8b5
   \   000000B4   0x........         DC32     _ZN11Temperature5bedKiE
   \   000000B8   0x........         DC32     _ZN11Temperature5bedKdE
   \   000000BC   0x........         DC32     echomagic
   \   000000C0   0x........         DC32     _ZZ10gcode_M304vEs
   \   000000C4   0x........         DC32     _ZZ10gcode_M304vEs_0
   \   000000C8   0x........         DC32     _ZZ10gcode_M304vEs_1
   \   000000CC   0x........         DC32     Serial3
  10450            }
  10451          
  10452          #endif // PIDTEMPBED
  10453          
  10454          #if defined(CHDK) || HAS_PHOTOGRAPH
  10455          
  10456            /**
  10457             * M240: Trigger a camera by emulating a Canon RC-1
  10458             *       See http://www.doc-diy.net/photo/rc-1_hacked/
  10459             */
  10460            inline void gcode_M240() {
  10461              #ifdef CHDK
  10462          
  10463                OUT_WRITE(CHDK, HIGH);
  10464                chdkHigh = millis();
  10465                chdkActive = true;
  10466          
  10467              #elif HAS_PHOTOGRAPH
  10468          
  10469                const uint8_t NUM_PULSES = 16;
  10470                const float PULSE_LENGTH = 0.01524;
  10471                for (int i = 0; i < NUM_PULSES; i++) {
  10472                  WRITE(PHOTOGRAPH_PIN, HIGH);
  10473                  _delay_ms(PULSE_LENGTH);
  10474                  WRITE(PHOTOGRAPH_PIN, LOW);
  10475                  _delay_ms(PULSE_LENGTH);
  10476                }
  10477                delay(7.33);
  10478                for (int i = 0; i < NUM_PULSES; i++) {
  10479                  WRITE(PHOTOGRAPH_PIN, HIGH);
  10480                  _delay_ms(PULSE_LENGTH);
  10481                  WRITE(PHOTOGRAPH_PIN, LOW);
  10482                  _delay_ms(PULSE_LENGTH);
  10483                }
  10484          
  10485              #endif // !CHDK && HAS_PHOTOGRAPH
  10486            }
  10487          
  10488          #endif // CHDK || PHOTOGRAPH_PIN
  10489          
  10490          #if HAS_LCD_CONTRAST
  10491          
  10492            /**
  10493             * M250: Read and optionally set the LCD contrast
  10494             */
  10495            inline void gcode_M250() {
  10496              if (parser.seen('C')) set_lcd_contrast(parser.value_int());
  10497              SERIAL_PROTOCOLPGM("lcd contrast value: ");
  10498              SERIAL_PROTOCOL(lcd_contrast);
  10499              SERIAL_EOL();
  10500            }
  10501          
  10502          #endif // HAS_LCD_CONTRAST
  10503          
  10504          #if ENABLED(PREVENT_COLD_EXTRUSION)
  10505          
  10506            /**
  10507             * M302: Allow cold extrudes, or set the minimum extrude temperature
  10508             *
  10509             *       S<temperature> sets the minimum extrude temperature
  10510             *       P<bool> enables (1) or disables (0) cold extrusion
  10511             *
  10512             *  Examples:
  10513             *
  10514             *       M302         ; report current cold extrusion state
  10515             *       M302 P0      ; enable cold extrusion checking
  10516             *       M302 P1      ; disables cold extrusion checking
  10517             *       M302 S0      ; always allow extrusion (disables checking)
  10518             *       M302 S170    ; only allow extrusion above 170
  10519             *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
  10520             */

   \                                 In section .text, align 4
  10521            inline void gcode_M302() {
   \                     _Z10gcode_M302v: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  10522              const bool seen_S = parser.seen('S');
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x0004             MOVS     R4,R0
  10523              if (seen_S) {
   \   0000000A   0xD00C             BEQ.N    ??gcode_M302_0
  10524                thermalManager.extrude_min_temp = parser.value_celsius();
                                                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000000C   0x4D1C             LDR.N    R5,??gcode_M302_1
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser13value_celsiusEv
   \   00000012   0x.... 0x....      BL       __aeabi_f2iz
   \   00000016   0x8028             STRH     R0,[R5, #+0]
  10525                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
   \   00000018   0xF9B5 0x0000      LDRSH    R0,[R5, #+0]
   \   0000001C   0x1E41             SUBS     R1,R0,#+1
   \   0000001E   0x4189             SBCS     R1,R1,R1
   \   00000020   0x0FC9             LSRS     R1,R1,#+31
   \   00000022   0x4818             LDR.N    R0,??gcode_M302_1+0x4
   \   00000024   0x7001             STRB     R1,[R0, #+0]
  10526              }
  10527          
  10528              if (parser.seen('P'))
   \                     ??gcode_M302_0: (+1)
   \   00000026   0x2050             MOVS     R0,#+80
   \   00000028   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000002C   0x2800             CMP      R0,#+0
   \   0000002E   0xD00C             BEQ.N    ??gcode_M302_2
  10529                thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
   \   00000030   0x4C14             LDR.N    R4,??gcode_M302_1+0x4
   \   00000032   0x4813             LDR.N    R0,??gcode_M302_1
   \   00000034   0xF9B0 0x0000      LDRSH    R0,[R0, #+0]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD003             BEQ.N    ??gcode_M302_3
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000040   0x7020             STRB     R0,[R4, #+0]
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??gcode_M302_3: (+1)
   \   00000044   0x2001             MOVS     R0,#+1
   \   00000046   0x7020             STRB     R0,[R4, #+0]
   \   00000048   0xBD31             POP      {R0,R4,R5,PC}
  10530              else if (!seen_S) {
   \                     ??gcode_M302_2: (+1)
   \   0000004A   0x2C00             CMP      R4,#+0
   \   0000004C   0xD117             BNE.N    ??gcode_M302_4
  10531                // Report current state
  10532                SERIAL_ECHO_START();
   \   0000004E   0x480E             LDR.N    R0,??gcode_M302_1+0x8
   \   00000050   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10533                SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
   \   00000054   0x480B             LDR.N    R0,??gcode_M302_1+0x4
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD001             BEQ.N    ??gcode_M302_5
   \   0000005C   0x490B             LDR.N    R1,??gcode_M302_1+0xC
   \   0000005E   0xE000             B.N      ??gcode_M302_6
   \                     ??gcode_M302_5: (+1)
   \   00000060   0x490B             LDR.N    R1,??gcode_M302_1+0x10
   \                     ??gcode_M302_6: (+1)
   \   00000062   0x480C             LDR.N    R0,??gcode_M302_1+0x14
   \   00000064   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
  10534                SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
   \   00000068   0x4805             LDR.N    R0,??gcode_M302_1
   \   0000006A   0xF9B0 0x1000      LDRSH    R1,[R0, #+0]
   \   0000006E   0x480A             LDR.N    R0,??gcode_M302_1+0x18
   \   00000070   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  10535                SERIAL_ECHOLNPGM("C)");
   \   00000074   0x4809             LDR.N    R0,??gcode_M302_1+0x1C
   \   00000076   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000007A   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10536              }
  10537            }
   \                     ??gcode_M302_4: (+1)
   \   0000007E   0xBD31             POP      {R0,R4,R5,PC}    ;; return
   \                     ??gcode_M302_1:
   \   00000080   0x........         DC32     _ZN11Temperature16extrude_min_tempE
   \   00000084   0x........         DC32     _ZN11Temperature18allow_cold_extrudeE
   \   00000088   0x........         DC32     echomagic
   \   0000008C   0x........         DC32     _ZZ10gcode_M302vEs_0
   \   00000090   0x........         DC32     _ZZ10gcode_M302vEs_1
   \   00000094   0x........         DC32     _ZZ10gcode_M302vEs
   \   00000098   0x........         DC32     _ZZ10gcode_M302vEs_2
   \   0000009C   0x........         DC32     _ZZ10gcode_M302vEs_3
  10538          
  10539          #endif // PREVENT_COLD_EXTRUSION
  10540          
  10541          /**
  10542           * M303: PID relay autotune
  10543           *
  10544           *       S<temperature> sets the target temperature. (default 150C)
  10545           *       E<extruder> (-1 for the bed) (default 0)
  10546           *       C<cycles>
  10547           *       U<bool> with a non-zero value will apply the result to current settings
  10548           */

   \                                 In section .text, align 4
  10549          inline void gcode_M303() {
   \                     _Z10gcode_M303v: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  10550            //#if HAS_PID_HEATING
  10551            if(HAS_PID_HEATING) {
   \   00000002   0x4820             LDR.N    R0,??gcode_M303_0
   \   00000004   0xF890 0x1034      LDRB     R1,[R0, #+52]
   \   00000008   0x2900             CMP      R1,#+0
   \   0000000A   0xD103             BNE.N    ??gcode_M303_1
   \   0000000C   0xF890 0x0035      LDRB     R0,[R0, #+53]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD02E             BEQ.N    ??gcode_M303_2
  10552              const int e = parser.intval('E'), c = parser.intval('C', 5);
   \                     ??gcode_M303_1: (+1)
   \   00000014   0x2100             MOVS     R1,#+0
   \   00000016   0x2045             MOVS     R0,#+69
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4604             MOV      R4,R0
   \   0000001E   0x2105             MOVS     R1,#+5
   \   00000020   0x2043             MOVS     R0,#+67
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   00000026   0x4605             MOV      R5,R0
  10553              const bool u = parser.boolval('U');
   \   00000028   0x2055             MOVS     R0,#+85
   \   0000002A   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   0000002E   0x4606             MOV      R6,R0
  10554          
  10555              int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
                                    ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000030   0x2C00             CMP      R4,#+0
   \   00000032   0xD501             BPL.N    ??gcode_M303_3
   \   00000034   0x2046             MOVS     R0,#+70
   \   00000036   0xE000             B.N      ??gcode_M303_4
   \                     ??gcode_M303_3: (+1)
   \   00000038   0x2096             MOVS     R0,#+150
   \                     ??gcode_M303_4: (+1)
   \   0000003A   0x.... 0x....      BL       __aeabi_i2f
   \   0000003E   0x4601             MOV      R1,R0
   \   00000040   0x2053             MOVS     R0,#+83
   \   00000042   0x.... 0x....      BL       _ZN11GCodeParser10celsiusvalEcf
   \   00000046   0x.... 0x....      BL       __aeabi_f2iz
  10556          
  10557              if (WITHIN(e, 0, HOTENDS - 1))
   \   0000004A   0x2C02             CMP      R4,#+2
   \   0000004C   0xD201             BCS.N    ??gcode_M303_5
  10558                target_extruder = e;
   \   0000004E   0x490E             LDR.N    R1,??gcode_M303_0+0x4
   \   00000050   0x714C             STRB     R4,[R1, #+5]
  10559          
  10560              #if DISABLED(BUSY_WHILE_HEATING)
  10561                KEEPALIVE_STATE(NOT_BUSY);
  10562              #endif
  10563          
  10564              thermalManager.PID_autotune(temp, e, c, u);
   \                     ??gcode_M303_5: (+1)
   \   00000052   0x462A             MOV      R2,R5
   \   00000054   0xB252             SXTB     R2,R2
   \   00000056   0x4621             MOV      R1,R4
   \   00000058   0xB249             SXTB     R1,R1
   \   0000005A   0x460C             MOV      R4,R1
   \   0000005C   0x4615             MOV      R5,R2
   \   0000005E   0xB200             SXTH     R0,R0
   \   00000060   0x.... 0x....      BL       __aeabi_i2f
   \   00000064   0x4633             MOV      R3,R6
   \   00000066   0x462A             MOV      R2,R5
   \   00000068   0x4621             MOV      R1,R4
   \   0000006A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000006E   0x.... 0x....      B.W      _ZN11Temperature12PID_autotuneEfaab
  10565          
  10566              #if DISABLED(BUSY_WHILE_HEATING)
  10567                KEEPALIVE_STATE(IN_HANDLER);
  10568              #endif
  10569            }
  10570            //#else
  10571            else
  10572            {
  10573              SERIAL_ERROR_START();
   \                     ??gcode_M303_2: (+1)
   \   00000072   0x4806             LDR.N    R0,??gcode_M303_0+0x8
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10574              SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
   \   00000078   0x4805             LDR.N    R0,??gcode_M303_0+0xC
   \   0000007A   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000007E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   00000082   0xBF00             Nop      
   \                     ??gcode_M303_0:
   \   00000084   0x........         DC32     mksCfg
   \   00000088   0x........         DC32     mks_heating_busy
   \   0000008C   0x........         DC32     errormagic
   \   00000090   0x........         DC32     _ZZ10gcode_M303vEs
  10575            }
  10576            //#endif
  10577          }
  10578          
  10579          #if 1//ENABLED(MORGAN_SCARA)
  10580          

   \                                 In section .text, align 2, keep-with-next
  10581            bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
   \                     _Z17SCARA_move_to_calhh: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
  10582              if (IsRunning()) {
   \   00000008   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xD019             BEQ.N    ??SCARA_move_to_cal_0
  10583                forward_kinematics_SCARA(delta_a, delta_b);
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       __aeabi_ui2f
   \   00000016   0x9001             STR      R0,[SP, #+4]
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       __aeabi_ui2f
   \   0000001E   0x9000             STR      R0,[SP, #+0]
   \   00000020   0xA900             ADD      R1,SP,#+0
   \   00000022   0xA801             ADD      R0,SP,#+4
   \   00000024   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
  10584                destination[X_AXIS] = cartes[X_AXIS];
   \   00000028   0x.... 0x....      LDR.W    R0,??DataTable156_1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable156
   \   00000030   0x6C8A             LDR      R2,[R1, #+72]
   \   00000032   0x6182             STR      R2,[R0, #+24]
  10585                destination[Y_AXIS] = cartes[Y_AXIS];
   \   00000034   0x6CC9             LDR      R1,[R1, #+76]
   \   00000036   0x61C1             STR      R1,[R0, #+28]
  10586                destination[Z_AXIS] = current_position[Z_AXIS];
   \   00000038   0x6901             LDR      R1,[R0, #+16]
   \   0000003A   0x6201             STR      R1,[R0, #+32]
  10587                prepare_move_to_destination();
   \   0000003C   0x.... 0x....      BL       _Z27prepare_move_to_destinationv
  10588                return true;
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0xBD3E             POP      {R1-R5,PC}
  10589              }
  10590              return false;
   \                     ??SCARA_move_to_cal_0: (+1)
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0xBD3E             POP      {R1-R5,PC}       ;; return
  10591            }
  10592          
  10593            /**
  10594             * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
  10595             */

   \                                 In section .text, align 4
  10596            inline bool gcode_M360() {
   \                     _Z10gcode_M360v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10597              SERIAL_ECHOLNPGM(" Cal: Theta 0");
   \   00000002   0x4804             LDR.N    R0,??gcode_M360_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10598              return SCARA_move_to_cal(0, 120);
   \   00000008   0x2178             MOVS     R1,#+120
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M360_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M360vEs
  10599            }
  10600          
  10601            /**
  10602             * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
  10603             */

   \                                 In section .text, align 4
  10604            inline bool gcode_M361() {
   \                     _Z10gcode_M361v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10605              SERIAL_ECHOLNPGM(" Cal: Theta 90");
   \   00000002   0x4804             LDR.N    R0,??gcode_M361_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10606              return SCARA_move_to_cal(90, 130);
   \   00000008   0x2182             MOVS     R1,#+130
   \   0000000A   0x205A             MOVS     R0,#+90
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M361_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M361vEs
  10607            }
  10608          
  10609            /**
  10610             * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
  10611             */

   \                                 In section .text, align 4
  10612            inline bool gcode_M362() {
   \                     _Z10gcode_M362v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10613              SERIAL_ECHOLNPGM(" Cal: Psi 0");
   \   00000002   0x4804             LDR.N    R0,??gcode_M362_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10614              return SCARA_move_to_cal(60, 180);
   \   00000008   0x21B4             MOVS     R1,#+180
   \   0000000A   0x203C             MOVS     R0,#+60
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M362_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M362vEs
  10615            }
  10616          
  10617            /**
  10618             * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
  10619             */

   \                                 In section .text, align 4
  10620            inline bool gcode_M363() {
   \                     _Z10gcode_M363v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10621              SERIAL_ECHOLNPGM(" Cal: Psi 90");
   \   00000002   0x4804             LDR.N    R0,??gcode_M363_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10622              return SCARA_move_to_cal(50, 90);
   \   00000008   0x215A             MOVS     R1,#+90
   \   0000000A   0x2032             MOVS     R0,#+50
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M363_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M363vEs
  10623            }
  10624          
  10625            /**
  10626             * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
  10627             */

   \                                 In section .text, align 4
  10628            inline bool gcode_M364() {
   \                     _Z10gcode_M364v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10629              SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
   \   00000002   0x4804             LDR.N    R0,??gcode_M364_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10630              return SCARA_move_to_cal(45, 135);
   \   00000008   0x2187             MOVS     R1,#+135
   \   0000000A   0x202D             MOVS     R0,#+45
   \   0000000C   0xE8BD 0x4004      POP      {R2,LR}
   \   00000010   0x.... 0x....      B.W      _Z17SCARA_move_to_calhh
   \                     ??gcode_M364_0:
   \   00000014   0x........         DC32     _ZZ10gcode_M364vEs
  10631            }
  10632          
  10633          #endif // SCARA
  10634          
  10635          #if ENABLED(EXT_SOLENOID)
  10636          
  10637            void enable_solenoid(const uint8_t num) {
  10638              switch (num) {
  10639                case 0:
  10640                  OUT_WRITE(SOL0_PIN, HIGH);
  10641                  break;
  10642                  #if HAS_SOLENOID_1 && EXTRUDERS > 1
  10643                    case 1:
  10644                      OUT_WRITE(SOL1_PIN, HIGH);
  10645                      break;
  10646                  #endif
  10647                  #if HAS_SOLENOID_2 && EXTRUDERS > 2
  10648                    case 2:
  10649                      OUT_WRITE(SOL2_PIN, HIGH);
  10650                      break;
  10651                  #endif
  10652                  #if HAS_SOLENOID_3 && EXTRUDERS > 3
  10653                    case 3:
  10654                      OUT_WRITE(SOL3_PIN, HIGH);
  10655                      break;
  10656                  #endif
  10657                  #if HAS_SOLENOID_4 && EXTRUDERS > 4
  10658                    case 4:
  10659                      OUT_WRITE(SOL4_PIN, HIGH);
  10660                      break;
  10661                  #endif
  10662                default:
  10663                  SERIAL_ECHO_START();
  10664                  SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
  10665                  break;
  10666              }
  10667            }
  10668          
  10669            void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
  10670          
  10671            void disable_all_solenoids() {
  10672              OUT_WRITE(SOL0_PIN, LOW);
  10673              #if HAS_SOLENOID_1 && EXTRUDERS > 1
  10674                OUT_WRITE(SOL1_PIN, LOW);
  10675              #endif
  10676              #if HAS_SOLENOID_2 && EXTRUDERS > 2
  10677                OUT_WRITE(SOL2_PIN, LOW);
  10678              #endif
  10679              #if HAS_SOLENOID_3 && EXTRUDERS > 3
  10680                OUT_WRITE(SOL3_PIN, LOW);
  10681              #endif
  10682              #if HAS_SOLENOID_4 && EXTRUDERS > 4
  10683                OUT_WRITE(SOL4_PIN, LOW);
  10684              #endif
  10685            }
  10686          
  10687            /**
  10688             * M380: Enable solenoid on the active extruder
  10689             */
  10690            inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
  10691          
  10692            /**
  10693             * M381: Disable all solenoids
  10694             */
  10695            inline void gcode_M381() { disable_all_solenoids(); }
  10696          
  10697          #endif // EXT_SOLENOID
  10698          
  10699          /**
  10700           * M400: Finish all moves
  10701           */

   \                                 In section .text, align 2
  10702          inline void gcode_M400() { stepper.synchronize(); }
   \                     _Z10gcode_M400v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN7Stepper11synchronizeEv
  10703          
  10704          #if HAS_BED_PROBE
  10705          
  10706            /**
  10707             * M401: Engage Z Servo endstop if available
  10708             */

   \                                 In section .text, align 2
  10709            inline void gcode_M401() { DEPLOY_PROBE(); }
   \                     _Z10gcode_M401v: (+1)
   \   00000000   0x2001             MOVS     R0,#+1
   \   00000002   0x.... 0x....      B.W      _Z18set_probe_deployedb
  10710          
  10711            /**
  10712             * M402: Retract Z Servo endstop if enabled
  10713             */

   \                                 In section .text, align 2
  10714            inline void gcode_M402() { STOW_PROBE(); }
   \                     _Z10gcode_M402v: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      B.W      _Z18set_probe_deployedb
  10715          
  10716          #endif // HAS_BED_PROBE
  10717          
  10718          #if ENABLED(FILAMENT_WIDTH_SENSOR)
  10719          
  10720            /**
  10721             * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
  10722             */
  10723            inline void gcode_M404() {
  10724              if (parser.seen('W')) {
  10725                filament_width_nominal = parser.value_linear_units();
  10726                planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
  10727              }
  10728              else {
  10729                SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
  10730                SERIAL_PROTOCOLLN(filament_width_nominal);
  10731              }
  10732            }
  10733          
  10734            /**
  10735             * M405: Turn on filament sensor for control
  10736             */
  10737            inline void gcode_M405() {
  10738              // This is technically a linear measurement, but since it's quantized to centimeters and is a different
  10739              // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
  10740              if (parser.seen('D')) {
  10741                meas_delay_cm = parser.value_byte();
  10742                NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
  10743              }
  10744          
  10745              if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
  10746                const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
  10747          
  10748                for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
  10749                  measurement_delay[i] = temp_ratio;
  10750          
  10751                filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
  10752              }
  10753          
  10754              filament_sensor = true;
  10755            }
  10756          
  10757            /**
  10758             * M406: Turn off filament sensor for control
  10759             */
  10760            inline void gcode_M406() {
  10761              filament_sensor = false;
  10762              planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
  10763            }
  10764          
  10765            /**
  10766             * M407: Get measured filament diameter on serial output
  10767             */
  10768            inline void gcode_M407() {
  10769              SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
  10770              SERIAL_PROTOCOLLN(filament_width_meas);
  10771            }
  10772          
  10773          #endif // FILAMENT_WIDTH_SENSOR
  10774          

   \                                 In section .text, align 2, keep-with-next
  10775          void quickstop_stepper() {
   \                     _Z17quickstop_stepperv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  10776            stepper.quick_stop();
   \   00000002   0x.... 0x....      BL       _ZN7Stepper10quick_stopEv
  10777            stepper.synchronize();
   \   00000006   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  10778            set_current_from_steppers_for_axis(ALL_AXES);
   \   0000000A   0x2064             MOVS     R0,#+100
   \   0000000C   0x.... 0x....      BL       _Z34set_current_from_steppers_for_axis8AxisEnum
  10779            SYNC_PLAN_POSITION_KINEMATIC();
   \   00000010   0xE8BD 0x4001      POP      {R0,LR}
   \   00000014   0x.... 0x....      B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
  10780          }
  10781          
  10782          #if 1//HAS_LEVELING
  10783            /**
  10784             * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
  10785             *
  10786             *   S[bool]   Turns leveling on or off
  10787             *   Z[height] Sets the Z fade height (0 or none to disable)
  10788             *   V[bool]   Verbose - Print the leveling grid
  10789             *
  10790             * With AUTO_BED_LEVELING_UBL only:
  10791             *
  10792             *   L[index]  Load UBL mesh from index (0 is default)
  10793             */

   \                                 In section .text, align 4
  10794            inline void gcode_M420() {
   \                     _Z10gcode_M420v: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
  10795          
  10796              const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
   \   00000004   0x4C71             LDR.N    R4,??gcode_M420_0
   \   00000006   0x68A0             LDR      R0,[R4, #+8]
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x68E0             LDR      R0,[R4, #+12]
   \   0000000C   0x9002             STR      R0,[SP, #+8]
   \   0000000E   0x6920             LDR      R0,[R4, #+16]
   \   00000010   0x9003             STR      R0,[SP, #+12]
  10797          
  10798              //#if ENABLED(AUTO_BED_LEVELING_UBL)
  10799          	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	
   \   00000012   0x4E6F             LDR.N    R6,??gcode_M420_0+0x4
   \   00000014   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   00000018   0x2810             CMP      R0,#+16
   \   0000001A   0xD153             BNE.N    ??gcode_M420_1
  10800          	{
  10801                // L to load a mesh from the EEPROM
  10802                if (parser.seen('L')) {
   \   0000001C   0x204C             MOVS     R0,#+76
   \   0000001E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD02A             BEQ.N    ??gcode_M420_2
  10803          
  10804                  #if ENABLED(EEPROM_SETTINGS)
  10805                    const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
   \   00000026   0x.... 0x....      BL       _ZN11GCodeParser9has_valueEv
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD003             BEQ.N    ??gcode_M420_3
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000032   0x4605             MOV      R5,R0
   \   00000034   0xE002             B.N      ??gcode_M420_4
   \                     ??gcode_M420_3: (+1)
   \   00000036   0x4867             LDR.N    R0,??gcode_M420_0+0x8
   \   00000038   0xF990 0x5000      LDRSB    R5,[R0, #+0]
  10806                    const int16_t a = settings.calc_num_meshes();
   \                     ??gcode_M420_4: (+1)
   \   0000003C   0x.... 0x....      BL       _ZN14MarlinSettings15calc_num_meshesEv
   \   00000040   0xB200             SXTH     R0,R0
  10807          
  10808                    if (!a) {
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD103             BNE.N    ??gcode_M420_5
  10809                      SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
   \   00000046   0x4864             LDR.N    R0,??gcode_M420_0+0xC
   \   00000048   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10810                      return;
   \   0000004C   0xE0BB             B.N      ??gcode_M420_6
  10811                    }
  10812          
  10813                    if (!WITHIN(storage_slot, 0, a - 1)) {
   \                     ??gcode_M420_5: (+1)
   \   0000004E   0x1E47             SUBS     R7,R0,#+1
   \   00000050   0xB26D             SXTB     R5,R5
   \   00000052   0x0028             MOVS     R0,R5
   \   00000054   0xD401             BMI.N    ??gcode_M420_7
   \   00000056   0x4287             CMP      R7,R0
   \   00000058   0xDA0B             BGE.N    ??gcode_M420_8
  10814                      SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
   \                     ??gcode_M420_7: (+1)
   \   0000005A   0x4860             LDR.N    R0,??gcode_M420_0+0x10
   \   0000005C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10815                      SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
   \   00000060   0x4639             MOV      R1,R7
   \   00000062   0x485F             LDR.N    R0,??gcode_M420_0+0x14
   \   00000064   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000068   0x210A             MOVS     R1,#+10
   \   0000006A   0x485E             LDR.N    R0,??gcode_M420_0+0x18
   \   0000006C   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10816                      return;
   \   00000070   0xE0A9             B.N      ??gcode_M420_6
  10817                    }
  10818          
  10819                    settings.load_mesh(storage_slot);
   \                     ??gcode_M420_8: (+1)
   \   00000072   0x2100             MOVS     R1,#+0
   \   00000074   0x.... 0x....      BL       _ZN14MarlinSettings9load_meshEaPv
  10820                    ubl.storage_slot = storage_slot;
   \   00000078   0x4856             LDR.N    R0,??gcode_M420_0+0x8
   \   0000007A   0x7005             STRB     R5,[R0, #+0]
  10821          
  10822                  #else
  10823          
  10824                    SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
  10825                    return;
  10826          
  10827                  #endif
  10828                }
  10829          
  10830                // L to load a mesh from the EEPROM
  10831                if (parser.seen('L') || parser.seen('V')) {
   \                     ??gcode_M420_2: (+1)
   \   0000007C   0x204C             MOVS     R0,#+76
   \   0000007E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000082   0x2800             CMP      R0,#+0
   \   00000084   0xD104             BNE.N    ??gcode_M420_9
   \   00000086   0x2056             MOVS     R0,#+86
   \   00000088   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000008C   0x2800             CMP      R0,#+0
   \   0000008E   0xD019             BEQ.N    ??gcode_M420_1
  10832                  ubl.display_map(0);  // Currently only supports one map type
   \                     ??gcode_M420_9: (+1)
   \   00000090   0x2000             MOVS     R0,#+0
   \   00000092   0x.... 0x....      BL       _ZN20unified_bed_leveling11display_mapEi
  10833                  SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
   \   00000096   0xF104 0x0084      ADD      R0,R4,#+132
   \   0000009A   0x.... 0x....      BL       _ZN20unified_bed_leveling13mesh_is_validEv
   \   0000009E   0x4601             MOV      R1,R0
   \   000000A0   0x4851             LDR.N    R0,??gcode_M420_0+0x1C
   \   000000A2   0x.... 0x....      BL       _Z17serial_echopair_PPKcb
   \   000000A6   0x4D4F             LDR.N    R5,??gcode_M420_0+0x18
   \   000000A8   0x210A             MOVS     R1,#+10
   \   000000AA   0x4628             MOV      R0,R5
   \   000000AC   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10834                  SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
   \   000000B0   0x4848             LDR.N    R0,??gcode_M420_0+0x8
   \   000000B2   0xF990 0x1000      LDRSB    R1,[R0, #+0]
   \   000000B6   0x484D             LDR.N    R0,??gcode_M420_0+0x20
   \   000000B8   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   000000BC   0x210A             MOVS     R1,#+10
   \   000000BE   0x4628             MOV      R0,R5
   \   000000C0   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10835                }
  10836          	}
  10837              //#endif // AUTO_BED_LEVELING_UBL
  10838          
  10839              // V to print the matrix or mesh
  10840              if (parser.seen('V')) {
   \                     ??gcode_M420_1: (+1)
   \   000000C4   0x2056             MOVS     R0,#+86
   \   000000C6   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   000000CA   0x2800             CMP      R0,#+0
   \   000000CC   0xD019             BEQ.N    ??gcode_M420_10
  10841                //#if ABL_PLANAR
  10842                if(BED_LEVELING_METHOD&ABL_PLANAR)
   \   000000CE   0xF896 0x5040      LDRB     R5,[R6, #+64]
   \   000000D2   0x2006             MOVS     R0,#+6
   \   000000D4   0x4205             TST      R5,R0
   \   000000D6   0xD004             BEQ.N    ??gcode_M420_11
  10843                  planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
   \   000000D8   0x4945             LDR.N    R1,??gcode_M420_0+0x24
   \   000000DA   0x4846             LDR.N    R0,??gcode_M420_0+0x28
   \   000000DC   0x.... 0x....      BL       _ZN10matrix_3x35debugEPKc
   \   000000E0   0xE00F             B.N      ??gcode_M420_10
  10844          	  else
  10845          	  {
  10846                //#else
  10847                  if (leveling_is_valid()) {
   \                     ??gcode_M420_11: (+1)
   \   000000E2   0x.... 0x....      BL       _Z17leveling_is_validv
   \   000000E6   0x2800             CMP      R0,#+0
   \   000000E8   0xD00B             BEQ.N    ??gcode_M420_10
  10848                    //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
  10849                    if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \   000000EA   0x2D08             CMP      R5,#+8
   \   000000EC   0xD102             BNE.N    ??gcode_M420_12
  10850                    {
  10851                      print_bilinear_leveling_grid();
   \   000000EE   0x.... 0x....      BL       _Z28print_bilinear_leveling_gridv
   \   000000F2   0xE006             B.N      ??gcode_M420_10
  10852                      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  10853                        print_bilinear_leveling_grid_virt();
  10854                      #endif
  10855                    }
  10856                   //#elif ENABLED(MESH_BED_LEVELING)
  10857                   else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??gcode_M420_12: (+1)
   \   000000F4   0x2D20             CMP      R5,#+32
   \   000000F6   0xD104             BNE.N    ??gcode_M420_10
  10858                   {
  10859                      SERIAL_ECHOLNPGM("Mesh Bed Level data:");
   \   000000F8   0x483F             LDR.N    R0,??gcode_M420_0+0x2C
   \   000000FA   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10860                      mbl_mesh_report();
   \   000000FE   0x.... 0x....      BL       _Z15mbl_mesh_reportv
  10861                   }
  10862                   // #endif
  10863                  }
  10864          	  }
  10865                //#endif
  10866              }
  10867          
  10868              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  10869          	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \                     ??gcode_M420_10: (+1)
   \   00000102   0xF9B6 0x0058      LDRSH    R0,[R6, #+88]
   \   00000106   0x2802             CMP      R0,#+2
   \   00000108   0xD00D             BEQ.N    ??gcode_M420_13
   \   0000010A   0xF896 0x0040      LDRB     R0,[R6, #+64]
   \   0000010E   0x06C0             LSLS     R0,R0,#+27
   \   00000110   0xD509             BPL.N    ??gcode_M420_13
  10870          	{
  10871                if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
   \   00000112   0x205A             MOVS     R0,#+90
   \   00000114   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000118   0x2800             CMP      R0,#+0
   \   0000011A   0xD004             BEQ.N    ??gcode_M420_13
   \   0000011C   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x.... 0x....      BL       _Z17set_z_fade_heightfb
  10872          	}
  10873              #endif
  10874          
  10875              bool to_enable = false;
   \                     ??gcode_M420_13: (+1)
   \   00000126   0x2500             MOVS     R5,#+0
  10876              if (parser.seen('S')) {
   \   00000128   0x2053             MOVS     R0,#+83
   \   0000012A   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD004             BEQ.N    ??gcode_M420_14
  10877                to_enable = parser.value_bool();
   \   00000132   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000136   0x4605             MOV      R5,R0
  10878                set_bed_leveling_enabled(to_enable);
   \   00000138   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
  10879              }
  10880          
  10881              const bool new_status = planner.leveling_active;
   \                     ??gcode_M420_14: (+1)
   \   0000013C   0x482F             LDR.N    R0,??gcode_M420_0+0x30
   \   0000013E   0x7806             LDRB     R6,[R0, #+0]
  10882          
  10883              if (to_enable && !new_status) {
   \   00000140   0xF086 0x0001      EOR      R0,R6,#0x1
   \   00000144   0x4629             MOV      R1,R5
   \   00000146   0x4201             TST      R1,R0
   \   00000148   0xD005             BEQ.N    ??gcode_M420_15
  10884                SERIAL_ERROR_START();
   \   0000014A   0x482D             LDR.N    R0,??gcode_M420_0+0x34
   \   0000014C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10885                SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
   \   00000150   0x482C             LDR.N    R0,??gcode_M420_0+0x38
   \   00000152   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10886              }
  10887          
  10888              SERIAL_ECHO_START();
   \                     ??gcode_M420_15: (+1)
   \   00000156   0x4F2C             LDR.N    R7,??gcode_M420_0+0x3C
   \   00000158   0x4638             MOV      R0,R7
   \   0000015A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10889              SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
   \   0000015E   0x2E00             CMP      R6,#+0
   \   00000160   0xD001             BEQ.N    ??gcode_M420_16
   \   00000162   0x492A             LDR.N    R1,??gcode_M420_0+0x40
   \   00000164   0xE000             B.N      ??gcode_M420_17
   \                     ??gcode_M420_16: (+1)
   \   00000166   0x492A             LDR.N    R1,??gcode_M420_0+0x44
   \                     ??gcode_M420_17: (+1)
   \   00000168   0x482A             LDR.N    R0,??gcode_M420_0+0x48
   \   0000016A   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   0000016E   0x4D1D             LDR.N    R5,??gcode_M420_0+0x18
   \   00000170   0x210A             MOVS     R1,#+10
   \   00000172   0x4628             MOV      R0,R5
   \   00000174   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  10890          
  10891              #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  10892                SERIAL_ECHO_START();
   \   00000178   0x4638             MOV      R0,R7
   \   0000017A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10893                SERIAL_ECHOPGM("Fade Height ");
   \   0000017E   0x4826             LDR.N    R0,??gcode_M420_0+0x4C
   \   00000180   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10894                if (planner.z_fade_height > 0.0)
   \   00000184   0x4825             LDR.N    R0,??gcode_M420_0+0x50
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x2100             MOVS     R1,#+0
   \   0000018A   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000018E   0xD20D             BCS.N    ??gcode_M420_18
  10895                  SERIAL_ECHOLN(planner.z_fade_height);
   \   00000190   0x2102             MOVS     R1,#+2
   \   00000192   0x9100             STR      R1,[SP, #+0]
   \   00000194   0x.... 0x....      BL       __aeabi_f2d
   \   00000198   0x4602             MOV      R2,R0
   \   0000019A   0x460B             MOV      R3,R1
   \   0000019C   0x4628             MOV      R0,R5
   \   0000019E   0x.... 0x....      BL       _ZN5Print5printEdi
   \   000001A2   0x210A             MOVS     R1,#+10
   \   000001A4   0x4628             MOV      R0,R5
   \   000001A6   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   000001AA   0xE002             B.N      ??gcode_M420_19
  10896                else
  10897                  SERIAL_ECHOLNPGM(MSG_OFF);
   \                     ??gcode_M420_18: (+1)
   \   000001AC   0x481C             LDR.N    R0,??gcode_M420_0+0x54
   \   000001AE   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10898              #endif
  10899          
  10900              // Report change in position
  10901              if (memcmp(oldpos, current_position, sizeof(oldpos)))
   \                     ??gcode_M420_19: (+1)
   \   000001B2   0x220C             MOVS     R2,#+12
   \   000001B4   0xF104 0x0108      ADD      R1,R4,#+8
   \   000001B8   0xA801             ADD      R0,SP,#+4
   \   000001BA   0x.... 0x....      BL       memcmp
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD001             BEQ.N    ??gcode_M420_6
  10902                report_current_position();
   \   000001C2   0x.... 0x....      BL       _Z23report_current_positionv
  10903            }
   \                     ??gcode_M420_6: (+1)
   \   000001C6   0xB005             ADD      SP,SP,#+20
   \   000001C8   0xBDF0             POP      {R4-R7,PC}       ;; return
   \   000001CA   0xBF00             Nop      
   \                     ??gcode_M420_0:
   \   000001CC   0x........         DC32     mks_heating_busy
   \   000001D0   0x........         DC32     mksCfg
   \   000001D4   0x........         DC32     _ZN20unified_bed_leveling12storage_slotE
   \   000001D8   0x........         DC32     _ZZ10gcode_M420vEs
   \   000001DC   0x........         DC32     _ZZ10gcode_M420vEs_0
   \   000001E0   0x........         DC32     _ZZ10gcode_M420vEs_1
   \   000001E4   0x........         DC32     Serial3
   \   000001E8   0x........         DC32     _ZZ10gcode_M420vEs_2
   \   000001EC   0x........         DC32     _ZZ10gcode_M420vEs_3
   \   000001F0   0x........         DC32     _ZZ10gcode_M420vEs_4
   \   000001F4   0x........         DC32     _ZN7Planner16bed_level_matrixE
   \   000001F8   0x........         DC32     _ZZ10gcode_M420vEs_5
   \   000001FC   0x........         DC32     _ZN7Planner15leveling_activeE
   \   00000200   0x........         DC32     errormagic
   \   00000204   0x........         DC32     _ZZ10gcode_M420vEs_6
   \   00000208   0x........         DC32     echomagic
   \   0000020C   0x........         DC32     _ZZ10gcode_M420vEs_8
   \   00000210   0x........         DC32     _ZZ10gcode_M420vEs_9
   \   00000214   0x........         DC32     _ZZ10gcode_M420vEs_7
   \   00000218   0x........         DC32     _ZZ10gcode_M420vEs__10_
   \   0000021C   0x........         DC32     _ZN7Planner13z_fade_heightE
   \   00000220   0x........         DC32     _ZZ10gcode_M420vEs__11_
  10904          #endif
  10905          
  10906          #if 1//ENABLED(MESH_BED_LEVELING)
  10907          
  10908            /**
  10909             * M421: Set a single Mesh Bed Leveling Z coordinate
  10910             *
  10911             * Usage:
  10912             *   M421 X<linear> Y<linear> Z<linear>
  10913             *   M421 X<linear> Y<linear> Q<offset>
  10914             *   M421 I<xindex> J<yindex> Z<linear>
  10915             *   M421 I<xindex> J<yindex> Q<offset>
  10916             */

   \                                 In section .text, align 4
  10917            inline void gcode_M421_MESH_BED_LEVELING() {
   \                     _Z28gcode_M421_MESH_BED_LEVELINGv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
  10918              const bool hasX = parser.seen('X'), hasI = parser.seen('I');
   \   00000004   0x2058             MOVS     R0,#+88
   \   00000006   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000000A   0x4604             MOV      R4,R0
   \   0000000C   0x2049             MOVS     R0,#+73
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000012   0x0005             MOVS     R5,R0
  10919              const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
   \   00000014   0xD003             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_0
   \   00000016   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   0000001A   0x4606             MOV      R6,R0
   \   0000001C   0xE00B             B.N      ??gcode_M421_MESH_BED_LEVELING_1
   \                     ??gcode_M421_MESH_BED_LEVELING_0: (+1)
   \   0000001E   0x2C00             CMP      R4,#+0
   \   00000020   0xD007             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_2
   \   00000022   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000026   0x9000             STR      R0,[SP, #+0]
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       _ZN17mesh_bed_leveling13probe_index_xERKf
   \   0000002E   0x4606             MOV      R6,R0
   \   00000030   0xE001             B.N      ??gcode_M421_MESH_BED_LEVELING_1
   \                     ??gcode_M421_MESH_BED_LEVELING_2: (+1)
   \   00000032   0xF04F 0x36FF      MOV      R6,#-1
  10920              const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
   \                     ??gcode_M421_MESH_BED_LEVELING_1: (+1)
   \   00000036   0x2059             MOVS     R0,#+89
   \   00000038   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x204A             MOVS     R0,#+74
   \   00000040   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000044   0x4680             MOV      R8,R0
  10921              const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
   \   00000046   0xF1B8 0x0F00      CMP      R8,#+0
   \   0000004A   0xD003             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser9value_intEv
   \   00000050   0x4681             MOV      R9,R0
   \   00000052   0xE00B             B.N      ??gcode_M421_MESH_BED_LEVELING_4
   \                     ??gcode_M421_MESH_BED_LEVELING_3: (+1)
   \   00000054   0x2F00             CMP      R7,#+0
   \   00000056   0xD007             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000005C   0x9000             STR      R0,[SP, #+0]
   \   0000005E   0xA800             ADD      R0,SP,#+0
   \   00000060   0x.... 0x....      BL       _ZN17mesh_bed_leveling13probe_index_yERKf
   \   00000064   0x4681             MOV      R9,R0
   \   00000066   0xE001             B.N      ??gcode_M421_MESH_BED_LEVELING_4
   \                     ??gcode_M421_MESH_BED_LEVELING_5: (+1)
   \   00000068   0xF04F 0x39FF      MOV      R9,#-1
  10922              const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
   \                     ??gcode_M421_MESH_BED_LEVELING_4: (+1)
   \   0000006C   0x205A             MOVS     R0,#+90
   \   0000006E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000072   0x4683             MOV      R11,R0
   \   00000074   0xF1BB 0x0F00      CMP      R11,#+0
   \   00000078   0xD104             BNE.N    ??gcode_M421_MESH_BED_LEVELING_6
   \   0000007A   0x2051             MOVS     R0,#+81
   \   0000007C   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000080   0x4682             MOV      R10,R0
   \   00000082   0xE001             B.N      ??gcode_M421_MESH_BED_LEVELING_7
   \                     ??gcode_M421_MESH_BED_LEVELING_6: (+1)
   \   00000084   0xF04F 0x0A00      MOV      R10,#+0
  10923          
  10924              if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
   \                     ??gcode_M421_MESH_BED_LEVELING_7: (+1)
   \   00000088   0xEA08 0x0005      AND      R0,R8,R5
   \   0000008C   0xEA07 0x0104      AND      R1,R7,R4
   \   00000090   0x1808             ADDS     R0,R1,R0
   \   00000092   0x2801             CMP      R0,#+1
   \   00000094   0xD102             BNE.N    ??gcode_M421_MESH_BED_LEVELING_8
   \   00000096   0xEA5A 0x000B      ORRS     R0,R10,R11
   \   0000009A   0xD106             BNE.N    ??gcode_M421_MESH_BED_LEVELING_9
  10925                SERIAL_ERROR_START();
   \                     ??gcode_M421_MESH_BED_LEVELING_8: (+1)
   \   0000009C   0x4816             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
   \   0000009E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10926                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \   000000A2   0x4816             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x4
   \   000000A4   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000A8   0xE024             B.N      ??gcode_M421_MESH_BED_LEVELING_11
  10927              }
  10928              else if (ix < 0 || iy < 0) {
   \                     ??gcode_M421_MESH_BED_LEVELING_9: (+1)
   \   000000AA   0xB276             SXTB     R6,R6
   \   000000AC   0x0034             MOVS     R4,R6
   \   000000AE   0xD404             BMI.N    ??gcode_M421_MESH_BED_LEVELING_12
   \   000000B0   0xFA4F 0xF989      SXTB     R9,R9
   \   000000B4   0x464D             MOV      R5,R9
   \   000000B6   0x2D00             CMP      R5,#+0
   \   000000B8   0xD506             BPL.N    ??gcode_M421_MESH_BED_LEVELING_13
  10929                SERIAL_ERROR_START();
   \                     ??gcode_M421_MESH_BED_LEVELING_12: (+1)
   \   000000BA   0x480F             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
   \   000000BC   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10930                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \   000000C0   0x480F             LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x8
   \   000000C2   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000000C6   0xE015             B.N      ??gcode_M421_MESH_BED_LEVELING_11
  10931              }
  10932              else
  10933                mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
   \                     ??gcode_M421_MESH_BED_LEVELING_13: (+1)
   \   000000C8   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000000CC   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000D0   0xD007             BEQ.N    ??gcode_M421_MESH_BED_LEVELING_14
   \   000000D2   0xEB04 0x0144      ADD      R1,R4,R4, LSL #+1
   \   000000D6   0x4A0B             LDR.N    R2,??gcode_M421_MESH_BED_LEVELING_10+0xC
   \   000000D8   0xEB02 0x1101      ADD      R1,R2,R1, LSL #+4
   \   000000DC   0xF851 0x1025      LDR      R1,[R1, R5, LSL #+2]
   \   000000E0   0xE000             B.N      ??gcode_M421_MESH_BED_LEVELING_15
   \                     ??gcode_M421_MESH_BED_LEVELING_14: (+1)
   \   000000E2   0x2100             MOVS     R1,#+0
   \                     ??gcode_M421_MESH_BED_LEVELING_15: (+1)
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x9000             STR      R0,[SP, #+0]
   \   000000EA   0xAA00             ADD      R2,SP,#+0
   \   000000EC   0x4649             MOV      R1,R9
   \   000000EE   0x4630             MOV      R0,R6
   \   000000F0   0x.... 0x....      BL       _ZN17mesh_bed_leveling5set_zEaaRKf
  10934            }
   \                     ??gcode_M421_MESH_BED_LEVELING_11: (+1)
   \   000000F4   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
   \                     ??gcode_M421_MESH_BED_LEVELING_10:
   \   000000F8   0x........         DC32     errormagic
   \   000000FC   0x........         DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
   \   00000100   0x........         DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
   \   00000104   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE
  10935          #endif
  10936          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
  10937          
  10938            /**
  10939             * M421: Set a single Mesh Bed Leveling Z coordinate
  10940             *
  10941             * Usage:
  10942             *   M421 I<xindex> J<yindex> Z<linear>
  10943             *   M421 I<xindex> J<yindex> Q<offset>
  10944             */

   \                                 In section .text, align 4
  10945            inline void gcode_M421_AUTO_BED_LEVELING_BILINEAR() {
   \                     _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
  10946              int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x2049             MOVS     R0,#+73
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000000E   0x4606             MOV      R6,R0
   \   00000010   0xB276             SXTB     R6,R6
   \   00000012   0xF04F 0x31FF      MOV      R1,#-1
   \   00000016   0x204A             MOVS     R0,#+74
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001C   0x4604             MOV      R4,R0
   \   0000001E   0xB264             SXTB     R4,R4
  10947              const bool hasI = ix >= 0,
   \   00000020   0x4637             MOV      R7,R6
   \   00000022   0x43FF             MVNS     R7,R7
  10948                         hasJ = iy >= 0,
   \   00000024   0x46A0             MOV      R8,R4
   \   00000026   0xEA6F 0x0808      MVN      R8,R8
   \   0000002A   0xEA4F 0x78D8      LSR      R8,R8,#+31
  10949                         hasZ = parser.seen('Z'),
   \   0000002E   0x205A             MOVS     R0,#+90
   \   00000030   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000034   0x4681             MOV      R9,R0
  10950                         hasQ = !hasZ && parser.seen('Q');
   \   00000036   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000003A   0xD104             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0
   \   0000003C   0x2051             MOVS     R0,#+81
   \   0000003E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000042   0x4605             MOV      R5,R0
   \   00000044   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0: (+1)
   \   00000046   0x2500             MOVS     R5,#+0
  10951          
  10952              if (!hasI || !hasJ || !(hasZ || hasQ)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1: (+1)
   \   00000048   0xEA08 0x70D7      AND      R0,R8,R7, LSR #+31
   \   0000004C   0xEA45 0x0109      ORR      R1,R5,R9
   \   00000050   0x4208             TST      R0,R1
   \   00000052   0xD107             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2
  10953                SERIAL_ERROR_START();
   \   00000054   0x4818             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
   \   00000056   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10954                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \   0000005A   0x4818             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x4
   \   0000005C   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   00000060   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10955              }
  10956              else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2: (+1)
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD40C             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
   \   00000068   0x4815             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x8
   \   0000006A   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   0000006E   0x1E49             SUBS     R1,R1,#+1
   \   00000070   0x42B1             CMP      R1,R6
   \   00000072   0xDB06             BLT.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
   \   00000074   0x2C00             CMP      R4,#+0
   \   00000076   0xD404             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
   \   00000078   0xF890 0x0061      LDRB     R0,[R0, #+97]
   \   0000007C   0x1E40             SUBS     R0,R0,#+1
   \   0000007E   0x42A0             CMP      R0,R4
   \   00000080   0xDA07             BGE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5
  10957                SERIAL_ERROR_START();
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4: (+1)
   \   00000082   0x480D             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
   \   00000084   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10958                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \   00000088   0x480E             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0xC
   \   0000008A   0xE8BD 0x43F2      POP      {R1,R4-R9,LR}
   \   0000008E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10959              }
  10960              else {
  10961                z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5: (+1)
   \   00000092   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000096   0xEB06 0x0146      ADD      R1,R6,R6, LSL #+1
   \   0000009A   0x4A0B             LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x10
   \   0000009C   0xEB02 0x1601      ADD      R6,R2,R1, LSL #+4
   \   000000A0   0x2D00             CMP      R5,#+0
   \   000000A2   0xD002             BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6
   \   000000A4   0xF856 0x1024      LDR      R1,[R6, R4, LSL #+2]
   \   000000A8   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6: (+1)
   \   000000AA   0x2100             MOVS     R1,#+0
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7: (+1)
   \   000000AC   0x.... 0x....      BL       __aeabi_fadd
   \   000000B0   0xF846 0x0024      STR      R0,[R6, R4, LSL #+2]
  10962                #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  10963                  bed_level_virt_interpolate();
  10964                #endif
  10965              }
  10966            }
   \   000000B4   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
   \                     ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3:
   \   000000B8   0x........         DC32     errormagic
   \   000000BC   0x........         DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
   \   000000C0   0x........         DC32     mksCfg
   \   000000C4   0x........         DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
   \   000000C8   0x........         DC32     z_values
  10967          #endif
  10968          #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
  10969          
  10970            /**
  10971             * M421: Set a single Mesh Bed Leveling Z coordinate
  10972             *
  10973             * Usage:
  10974             *   M421 I<xindex> J<yindex> Z<linear>
  10975             *   M421 I<xindex> J<yindex> Q<offset>
  10976             *   M421 C Z<linear>
  10977             *   M421 C Q<offset>
  10978             */

   \                                 In section .text, align 4
  10979            inline void gcode_M421_AUTO_BED_LEVELING_UBL() {
   \                     _Z32gcode_M421_AUTO_BED_LEVELING_UBLv: (+1)
   \   00000000   0xE92D 0x47FF      PUSH     {R0-R10,LR}
  10980              int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
   \   00000004   0xF04F 0x31FF      MOV      R1,#-1
   \   00000008   0x2049             MOVS     R0,#+73
   \   0000000A   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000000E   0x4682             MOV      R10,R0
   \   00000010   0xFA4F 0xFA8A      SXTB     R10,R10
   \   00000014   0xF04F 0x31FF      MOV      R1,#-1
   \   00000018   0x204A             MOVS     R0,#+74
   \   0000001A   0x.... 0x....      BL       _ZN11GCodeParser6intvalEcs
   \   0000001E   0x4605             MOV      R5,R0
   \   00000020   0xB26D             SXTB     R5,R5
  10981              const bool hasI = ix >= 0,
   \   00000022   0x4656             MOV      R6,R10
   \   00000024   0x43F6             MVNS     R6,R6
  10982                         hasJ = iy >= 0,
   \   00000026   0x462F             MOV      R7,R5
   \   00000028   0x43FF             MVNS     R7,R7
   \   0000002A   0x0FFF             LSRS     R7,R7,#+31
  10983                         hasC = parser.seen('C'),
   \   0000002C   0x2043             MOVS     R0,#+67
   \   0000002E   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000032   0x4680             MOV      R8,R0
  10984                         hasZ = parser.seen('Z'),
   \   00000034   0x205A             MOVS     R0,#+90
   \   00000036   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   0000003A   0x4681             MOV      R9,R0
  10985                         hasQ = !hasZ && parser.seen('Q');
   \   0000003C   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000040   0xD104             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_0
   \   00000042   0x2051             MOVS     R0,#+81
   \   00000044   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000048   0x4604             MOV      R4,R0
   \   0000004A   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_1
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_0: (+1)
   \   0000004C   0x2400             MOVS     R4,#+0
  10986          
  10987              if (hasC) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_1: (+1)
   \   0000004E   0xF1B8 0x0F00      CMP      R8,#+0
   \   00000052   0xD00F             BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_2
  10988                const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
   \   00000054   0x4826             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0x9101             STR      R1,[SP, #+4]
   \   0000005A   0x9100             STR      R1,[SP, #+0]
   \   0000005C   0xF100 0x030C      ADD      R3,R0,#+12
   \   00000060   0xF100 0x0208      ADD      R2,R0,#+8
   \   00000064   0x2101             MOVS     R1,#+1
   \   00000066   0xA802             ADD      R0,SP,#+8
   \   00000068   0x.... 0x....      BL       _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
  10989                ix = location.x_index;
   \   0000006C   0xF99D 0xA008      LDRSB    R10,[SP, #+8]
  10990                iy = location.y_index;
   \   00000070   0xF99D 0x5009      LDRSB    R5,[SP, #+9]
  10991              }
  10992          
  10993              if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_2: (+1)
   \   00000074   0xEA07 0x70D6      AND      R0,R7,R6, LSR #+31
   \   00000078   0x4440             ADD      R0,R0,R8
   \   0000007A   0x2801             CMP      R0,#+1
   \   0000007C   0xD102             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_4
   \   0000007E   0xEA54 0x0009      ORRS     R0,R4,R9
   \   00000082   0xD108             BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_5
  10994                SERIAL_ERROR_START();
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_4: (+1)
   \   00000084   0x481B             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
   \   00000086   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10995                SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
   \   0000008A   0x481B             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x8
   \   0000008C   0xB004             ADD      SP,SP,#+16
   \   0000008E   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   00000092   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  10996              }
  10997              else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_5: (+1)
   \   00000096   0xF1BA 0x0F00      CMP      R10,#+0
   \   0000009A   0xD40C             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
   \   0000009C   0x4817             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0xC
   \   0000009E   0xF890 0x1060      LDRB     R1,[R0, #+96]
   \   000000A2   0x1E49             SUBS     R1,R1,#+1
   \   000000A4   0x4551             CMP      R1,R10
   \   000000A6   0xDB06             BLT.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
   \   000000A8   0x2D00             CMP      R5,#+0
   \   000000AA   0xD404             BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
   \   000000AC   0xF890 0x0061      LDRB     R0,[R0, #+97]
   \   000000B0   0x1E40             SUBS     R0,R0,#+1
   \   000000B2   0x42A8             CMP      R0,R5
   \   000000B4   0xDA08             BGE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_7
  10998                SERIAL_ERROR_START();
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_6: (+1)
   \   000000B6   0x480F             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
   \   000000B8   0x.... 0x....      BL       _Z14serialprintPGMPKc
  10999                SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
   \   000000BC   0x4810             LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x10
   \   000000BE   0xB004             ADD      SP,SP,#+16
   \   000000C0   0xE8BD 0x47F0      POP      {R4-R10,LR}
   \   000000C4   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  11000              }
  11001              else
  11002                ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_7: (+1)
   \   000000C8   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   000000CC   0xEB0A 0x014A      ADD      R1,R10,R10, LSL #+1
   \   000000D0   0x4A0C             LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x14
   \   000000D2   0xEB02 0x1601      ADD      R6,R2,R1, LSL #+4
   \   000000D6   0x2C00             CMP      R4,#+0
   \   000000D8   0xD002             BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_8
   \   000000DA   0xF856 0x1025      LDR      R1,[R6, R5, LSL #+2]
   \   000000DE   0xE000             B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_9
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_8: (+1)
   \   000000E0   0x2100             MOVS     R1,#+0
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_9: (+1)
   \   000000E2   0x.... 0x....      BL       __aeabi_fadd
   \   000000E6   0xF846 0x0025      STR      R0,[R6, R5, LSL #+2]
  11003            }
   \   000000EA   0xE8BD 0x87FF      POP      {R0-R10,PC}      ;; return
   \   000000EE   0xBF00             Nop      
   \                     ??gcode_M421_AUTO_BED_LEVELING_UBL_3:
   \   000000F0   0x........         DC32     mks_heating_busy
   \   000000F4   0x........         DC32     errormagic
   \   000000F8   0x........         DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
   \   000000FC   0x........         DC32     mksCfg
   \   00000100   0x........         DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
   \   00000104   0x........         DC32     _ZN20unified_bed_leveling8z_valuesE
  11004          
  11005          #endif // AUTO_BED_LEVELING_UBL
  11006          
  11007          #if 1//HAS_M206_COMMAND
  11008          
  11009            /**
  11010             * M428: Set home_offset based on the distance between the
  11011             *       current_position and the nearest "reference point."
  11012             *       If an axis is past center its endstop position
  11013             *       is the reference-point. Otherwise it uses 0. This allows
  11014             *       the Z offset to be set near the bed when using a max endstop.
  11015             *
  11016             *       M428 can't be used more than 2cm away from 0 or an endstop.
  11017             *
  11018             *       Use M206 to set these values directly.
  11019             */

   \                                 In section .text, align 4
  11020            inline void gcode_M428() {
  11021            
  11022            	if(MACHINETPYE == DELTA) return;
   \                     _Z10gcode_M428v: (+1)
   \   00000000   0x482D             LDR.N    R0,??gcode_M428_0
   \   00000002   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000006   0x2802             CMP      R0,#+2
   \   00000008   0xD100             BNE.N    ??gcode_M428_1
   \   0000000A   0x4770             BX       LR
  11023          	
  11024              if (axis_unhomed_error()) return;
   \                     ??gcode_M428_1: (+1)
   \   0000000C   0xB5FE             PUSH     {R1-R7,LR}
   \   0000000E   0x2201             MOVS     R2,#+1
   \   00000010   0x4611             MOV      R1,R2
   \   00000012   0x4608             MOV      R0,R1
   \   00000014   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD14C             BNE.N    ??gcode_M428_2
  11025          
  11026              float diff[XYZ];
  11027              LOOP_XYZ(i) {
   \   0000001C   0x2400             MOVS     R4,#+0
   \   0000001E   0xAE00             ADD      R6,SP,#+0
   \   00000020   0x4F26             LDR.N    R7,??gcode_M428_0+0x4  ;; 0xc1a00000
   \   00000022   0xE001             B.N      ??gcode_M428_3
   \                     ??gcode_M428_4: (+1)
   \   00000024   0x1C64             ADDS     R4,R4,#+1
   \   00000026   0xB2E4             UXTB     R4,R4
   \                     ??gcode_M428_3: (+1)
   \   00000028   0x2C03             CMP      R4,#+3
   \   0000002A   0xDA32             BGE.N    ??gcode_M428_5
   \   0000002C   0x4824             LDR.N    R0,??gcode_M428_0+0x8
   \   0000002E   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000032   0x6885             LDR      R5,[R0, #+8]
   \   00000034   0x4620             MOV      R0,R4
   \   00000036   0xB240             SXTB     R0,R0
  11028                diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
   \   00000038   0x.... 0x....      BL       _Z13base_home_pos8AxisEnum
   \   0000003C   0x4629             MOV      R1,R5
   \   0000003E   0x.... 0x....      BL       __aeabi_fsub
   \   00000042   0xF846 0x0024      STR      R0,[R6, R4, LSL #+2]
  11029                if (!WITHIN(diff[i], -20, 20) && home_dir((AxisEnum)i) > 0)
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000004C   0xD803             BHI.N    ??gcode_M428_6
   \   0000004E   0x491D             LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
   \   00000050   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000054   0xD309             BCC.N    ??gcode_M428_7
   \                     ??gcode_M428_6: (+1)
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xB240             SXTB     R0,R0
   \   0000005A   0x.... 0x....      BL       _Z8home_dir8AxisEnum
   \   0000005E   0x2801             CMP      R0,#+1
   \   00000060   0xDB03             BLT.N    ??gcode_M428_7
  11030                  diff[i] = -current_position[i];
   \   00000062   0xF085 0x4500      EOR      R5,R5,#0x80000000
   \   00000066   0xF846 0x5024      STR      R5,[R6, R4, LSL #+2]
  11031                if (!WITHIN(diff[i], -20, 20)) {
   \                     ??gcode_M428_7: (+1)
   \   0000006A   0xF856 0x0024      LDR      R0,[R6, R4, LSL #+2]
   \   0000006E   0x4639             MOV      R1,R7
   \   00000070   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000074   0xD803             BHI.N    ??gcode_M428_8
   \   00000076   0x4913             LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
   \   00000078   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000007C   0xD3D2             BCC.N    ??gcode_M428_4
  11032                  SERIAL_ERROR_START();
   \                     ??gcode_M428_8: (+1)
   \   0000007E   0x4812             LDR.N    R0,??gcode_M428_0+0x10
   \   00000080   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11033                  SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
   \   00000084   0x4811             LDR.N    R0,??gcode_M428_0+0x14
   \   00000086   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11034                  LCD_ALERTMESSAGEPGM("Err: Too far!");
   \   0000008A   0x4811             LDR.N    R0,??gcode_M428_0+0x18
   \   0000008C   0x.... 0x....      BL       _Z21lcd_setalertstatusPGMPKc
  11035                  BUZZ(200, 40);
  11036                  return;
   \   00000090   0xBDF7             POP      {R0-R2,R4-R7,PC}
  11037                }
  11038              }
  11039          
  11040              LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
   \                     ??gcode_M428_5: (+1)
   \   00000092   0x2400             MOVS     R4,#+0
   \   00000094   0xE007             B.N      ??gcode_M428_9
   \                     ??gcode_M428_10: (+1)
   \   00000096   0xA800             ADD      R0,SP,#+0
   \   00000098   0xF850 0x1024      LDR      R1,[R0, R4, LSL #+2]
   \   0000009C   0x4620             MOV      R0,R4
   \   0000009E   0xB240             SXTB     R0,R0
   \   000000A0   0x.... 0x....      BL       _Z15set_home_offset8AxisEnumf
   \   000000A4   0x1C64             ADDS     R4,R4,#+1
   \                     ??gcode_M428_9: (+1)
   \   000000A6   0x2C03             CMP      R4,#+3
   \   000000A8   0xDBF5             BLT.N    ??gcode_M428_10
  11041              report_current_position();
   \   000000AA   0x.... 0x....      BL       _Z23report_current_positionv
  11042              LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
   \   000000AE   0x2100             MOVS     R1,#+0
   \   000000B0   0x4808             LDR.N    R0,??gcode_M428_0+0x1C
   \   000000B2   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
  11043              BUZZ(100, 659);
  11044              BUZZ(100, 698);
  11045            }
   \                     ??gcode_M428_2: (+1)
   \   000000B6   0xBDF7             POP      {R0-R2,R4-R7,PC}  ;; return
   \                     ??gcode_M428_0:
   \   000000B8   0x........         DC32     mksCfg
   \   000000BC   0xC1A00000         DC32     0xc1a00000
   \   000000C0   0x........         DC32     mks_heating_busy
   \   000000C4   0x41A00001         DC32     0x41a00001
   \   000000C8   0x........         DC32     errormagic
   \   000000CC   0x........         DC32     _ZZ10gcode_M428vEs
   \   000000D0   0x........         DC32     _ZZ10gcode_M428vEs_0
   \   000000D4   0x........         DC32     _ZZ10gcode_M428vEs_1
  11046          
  11047          #endif // HAS_M206_COMMAND
  11048          
  11049          /**
  11050           * M500: Store settings in EEPROM
  11051           */

   \                                 In section .text, align 2
  11052          inline void gcode_M500() {
  11053            (void)settings.save();
   \                     _Z10gcode_M500v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings4saveEv
  11054          }
  11055          
  11056          /**
  11057           * M501: Read settings from EEPROM
  11058           */

   \                                 In section .text, align 2
  11059          inline void gcode_M501() {
  11060            (void)settings.load();
   \                     _Z10gcode_M501v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings4loadEv
  11061          }
  11062          
  11063          /**
  11064           * M502: Revert to default settings
  11065           */

   \                                 In section .text, align 2
  11066          inline void gcode_M502() {
  11067            (void)settings.reset();
   \                     _Z10gcode_M502v: (+1)
   \   00000000   0x.... 0x....      B.W      _ZN14MarlinSettings5resetEv
  11068          }
  11069          
  11070          #if DISABLED(DISABLE_M503)
  11071            /**
  11072             * M503: print settings currently in memory
  11073             */

   \                                 In section .text, align 2
  11074            inline void gcode_M503() {
   \                     _Z10gcode_M503v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  11075              (void)settings.report(parser.seen('S') && !parser.value_bool());
   \   00000002   0x2053             MOVS     R0,#+83
   \   00000004   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD006             BEQ.N    ??gcode_M503_0
   \   0000000C   0x.... 0x....      BL       _ZN11GCodeParser10value_boolEv
   \   00000010   0xF000 0x0001      AND      R0,R0,#0x1
   \   00000014   0xF080 0x0001      EOR      R0,R0,#0x1
   \   00000018   0xE000             B.N      ??gcode_M503_1
   \                     ??gcode_M503_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \                     ??gcode_M503_1: (+1)
   \   0000001C   0xE8BD 0x4002      POP      {R1,LR}
   \   00000020   0x.... 0x....      B.W      _ZN14MarlinSettings6reportEb
  11076            }
  11077          #endif
  11078          
  11079          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  11080          
  11081            /**
  11082             * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
  11083             */
  11084            inline void gcode_M540() {
  11085              if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
  11086            }
  11087          
  11088          #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
  11089          
  11090          #if HAS_BED_PROBE
  11091          

   \                                 In section .text, align 4
  11092            inline void gcode_M851() {
   \                     _Z10gcode_M851v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  11093              SERIAL_ECHO_START();
   \   00000002   0x4813             LDR.N    R0,??gcode_M851_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11094              SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
   \   00000008   0x4812             LDR.N    R0,??gcode_M851_0+0x4
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  11095              if (parser.seen('Z')) {
   \   0000000E   0x205A             MOVS     R0,#+90
   \   00000010   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD010             BEQ.N    ??gcode_M851_1
  11096                const float value = parser.value_linear_units();
   \   00000018   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
  11097                if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
   \   0000001C   0x490E             LDR.N    R1,??gcode_M851_0+0x8  ;; 0xc1a00000
   \   0000001E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000022   0xD803             BHI.N    ??gcode_M851_2
   \   00000024   0x490D             LDR.N    R1,??gcode_M851_0+0xC  ;; 0x41a00001
   \   00000026   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000002A   0xD304             BCC.N    ??gcode_M851_3
  11098                  SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
   \                     ??gcode_M851_2: (+1)
   \   0000002C   0x480C             LDR.N    R0,??gcode_M851_0+0x10
   \   0000002E   0xE8BD 0x4002      POP      {R1,LR}
   \   00000032   0x.... 0x....      B.W      _Z14serialprintPGMPKc
  11099                  return;
  11100                }
  11101                zprobe_zoffset = value;
   \                     ??gcode_M851_3: (+1)
   \   00000036   0x490B             LDR.N    R1,??gcode_M851_0+0x14
   \   00000038   0x6708             STR      R0,[R1, #+112]
  11102              }
  11103              SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
   \                     ??gcode_M851_1: (+1)
   \   0000003A   0x480A             LDR.N    R0,??gcode_M851_0+0x14
   \   0000003C   0x6F01             LDR      R1,[R0, #+112]
   \   0000003E   0x480A             LDR.N    R0,??gcode_M851_0+0x18
   \   00000040   0x.... 0x....      BL       _Z17serial_echopair_PPKcf
   \   00000044   0x210A             MOVS     R1,#+10
   \   00000046   0x4809             LDR.N    R0,??gcode_M851_0+0x1C
   \   00000048   0xE8BD 0x4004      POP      {R2,LR}
   \   0000004C   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??gcode_M851_0:
   \   00000050   0x........         DC32     echomagic
   \   00000054   0x........         DC32     _ZZ10gcode_M851vEs
   \   00000058   0xC1A00000         DC32     0xc1a00000
   \   0000005C   0x41A00001         DC32     0x41a00001
   \   00000060   0x........         DC32     _ZZ10gcode_M851vEs_0
   \   00000064   0x........         DC32     mks_heating_busy
   \   00000068   0x........         DC32     _ZZ10gcode_M851vEs_1
   \   0000006C   0x........         DC32     Serial3
  11104            }
  11105          
  11106          #endif // HAS_BED_PROBE
  11107          
  11108          #if ENABLED(SKEW_CORRECTION_GCODE)
  11109          
  11110            /**
  11111             * M852: Get or set the machine skew factors. Reports current values with no arguments.
  11112             *
  11113             *  S[xy_factor] - Alias for 'I'
  11114             *  I[xy_factor] - New XY skew factor
  11115             *  J[xz_factor] - New XZ skew factor
  11116             *  K[yz_factor] - New YZ skew factor
  11117             */
  11118            inline void gcode_M852() {
  11119              uint8_t ijk = 0, badval = 0, setval = 0;
  11120          
  11121              if (parser.seen('I') || parser.seen('S')) {
  11122                ++ijk;
  11123                const float value = parser.value_linear_units();
  11124                if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  11125                  if (planner.xy_skew_factor != value) {
  11126                    planner.xy_skew_factor = value;
  11127                    ++setval;
  11128                  }
  11129                }
  11130                else
  11131                  ++badval;
  11132              }
  11133          
  11134              #if ENABLED(SKEW_CORRECTION_FOR_Z)
  11135          
  11136                if (parser.seen('J')) {
  11137                  ++ijk;
  11138                  const float value = parser.value_linear_units();
  11139                  if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  11140                    if (planner.xz_skew_factor != value) {
  11141                      planner.xz_skew_factor = value;
  11142                      ++setval;
  11143                    }
  11144                  }
  11145                  else
  11146                    ++badval;
  11147                }
  11148          
  11149                if (parser.seen('K')) {
  11150                  ++ijk;
  11151                  const float value = parser.value_linear_units();
  11152                  if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
  11153                    if (planner.yz_skew_factor != value) {
  11154                      planner.yz_skew_factor = value;
  11155                      ++setval;
  11156                    }
  11157                  }
  11158                  else
  11159                    ++badval;
  11160                }
  11161          
  11162              #endif
  11163          
  11164              if (badval)
  11165                SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
  11166          
  11167              // When skew is changed the current position changes
  11168              if (setval) {
  11169                set_current_from_steppers_for_axis(ALL_AXES);
  11170                SYNC_PLAN_POSITION_KINEMATIC();
  11171                report_current_position();
  11172              }
  11173          
  11174              if (!ijk) {
  11175                SERIAL_ECHO_START();
  11176                SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
  11177                #if ENABLED(SKEW_CORRECTION_FOR_Z)
  11178                  SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
  11179                  SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
  11180                #else
  11181                  SERIAL_EOL();
  11182                #endif
  11183              }
  11184            }
  11185          
  11186          #endif // SKEW_CORRECTION_GCODE
  11187          
  11188          #if ENABLED(ADVANCED_PAUSE_FEATURE)
  11189          
  11190            /**
  11191             * M600: Pause for filament change
  11192             *
  11193             *  E[distance] - Retract the filament this far (negative value)
  11194             *  Z[distance] - Move the Z axis by this distance
  11195             *  X[position] - Move to this X position, with Y
  11196             *  Y[position] - Move to this Y position, with X
  11197             *  U[distance] - Retract distance for removal (negative value) (manual reload)
  11198             *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
  11199             *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
  11200             *
  11201             *  Default values are used for omitted arguments.
  11202             *
  11203             */
  11204            inline void gcode_M600() {
  11205              point_t park_point = NOZZLE_PARK_POINT;
  11206          
  11207              #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
  11208                // Don't allow filament change without homing first
  11209                if (axis_unhomed_error()) home_all_axes();
  11210              #endif
  11211          
  11212              // Initial retract before move to filament change position
  11213              const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
  11214                #ifdef PAUSE_PARK_RETRACT_LENGTH
  11215                  - (PAUSE_PARK_RETRACT_LENGTH)
  11216                #endif
  11217              ;
  11218          
  11219              // Lift Z axis
  11220              if (parser.seenval('Z'))
  11221                park_point.z = parser.linearval('Z');
  11222          
  11223              // Move XY axes to filament change position or given position
  11224              if (parser.seenval('X'))
  11225                park_point.x = parser.linearval('X');
  11226          
  11227              if (parser.seenval('Y'))
  11228                park_point.y = parser.linearval('Y');
  11229          
  11230              #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
  11231                park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
  11232                park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
  11233              #endif
  11234          
  11235              // Unload filament
  11236              const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
  11237                #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
  11238                  - (FILAMENT_CHANGE_UNLOAD_LENGTH)
  11239                #endif
  11240              ;
  11241          
  11242              // Load filament
  11243              const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
  11244                #ifdef FILAMENT_CHANGE_LOAD_LENGTH
  11245                  + FILAMENT_CHANGE_LOAD_LENGTH
  11246                #endif
  11247              ;
  11248          
  11249              const int beep_count = parser.intval('B',
  11250                #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
  11251                  FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
  11252                #else
  11253                  -1
  11254                #endif
  11255              );
  11256          
  11257              const bool job_running = print_job_timer.isRunning();
  11258          
  11259              if (pause_print(retract, park_point, unload_length, beep_count, true)) {
  11260                wait_for_filament_reload(beep_count);
  11261                resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
  11262              }
  11263          
  11264              // Resume the print job timer if it was running
  11265              if (job_running) print_job_timer.start();
  11266            }
  11267          
  11268          #endif // ADVANCED_PAUSE_FEATURE
  11269          
  11270          #if ENABLED(MK2_MULTIPLEXER)
  11271          
  11272            inline void select_multiplexed_stepper(const uint8_t e) {
  11273              stepper.synchronize();
  11274              disable_e_steppers();
  11275              WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
  11276              WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
  11277              WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
  11278              safe_delay(100);
  11279            }
  11280          
  11281            /**
  11282             * M702: Unload all extruders
  11283             */
  11284            inline void gcode_M702() {
  11285              for (uint8_t s = 0; s < E_STEPPERS; s++) {
  11286                select_multiplexed_stepper(e);
  11287                // TODO: standard unload filament function
  11288                // MK2 firmware behavior:
  11289                //  - Make sure temperature is high enough
  11290                //  - Raise Z to at least 15 to make room
  11291                //  - Extrude 1cm of filament in 1 second
  11292                //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
  11293                //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
  11294                //  - Restore E max feedrate to 50
  11295              }
  11296              // Go back to the last active extruder
  11297              select_multiplexed_stepper(active_extruder);
  11298              disable_e_steppers();
  11299            }
  11300          
  11301          #endif // MK2_MULTIPLEXER
  11302          
  11303          #if ENABLED(DUAL_X_CARRIAGE)
  11304          
  11305            /**
  11306             * M605: Set dual x-carriage movement mode
  11307             *
  11308             *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
  11309             *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
  11310             *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
  11311             *                         units x-offset and an optional differential hotend temperature of
  11312             *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
  11313             *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
  11314             *
  11315             *    Note: the X axis should be homed after changing dual x-carriage mode.
  11316             */
  11317            inline void gcode_M605() {
  11318              stepper.synchronize();
  11319              if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
  11320              switch (dual_x_carriage_mode) {
  11321                case DXC_FULL_CONTROL_MODE:
  11322                case DXC_AUTO_PARK_MODE:
  11323                  break;
  11324                case DXC_DUPLICATION_MODE:
  11325                  if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
  11326                  if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
  11327                  SERIAL_ECHO_START();
  11328                  SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
  11329                  SERIAL_CHAR(' ');
  11330                  SERIAL_ECHO(hotend_offset[X_AXIS][0]);
  11331                  SERIAL_CHAR(',');
  11332                  SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
  11333                  SERIAL_CHAR(' ');
  11334                  SERIAL_ECHO(duplicate_extruder_x_offset);
  11335                  SERIAL_CHAR(',');
  11336                  SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
  11337                  break;
  11338                default:
  11339                  dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
  11340                  break;
  11341              }
  11342              active_extruder_parked = false;
  11343              extruder_duplication_enabled = false;
  11344              delayed_move_time = 0;
  11345            }
  11346          
  11347          #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  11348          
  11349            inline void gcode_M605() {
  11350              stepper.synchronize();
  11351              extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
  11352              SERIAL_ECHO_START();
  11353              SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
  11354            }
  11355          
  11356          #endif // DUAL_NOZZLE_DUPLICATION_MODE
  11357          
  11358          #if ENABLED(LIN_ADVANCE)
  11359            /**
  11360             * M900: Set and/or Get advance K factor and WH/D ratio
  11361             *
  11362             *  K<factor>                  Set advance K factor
  11363             *  R<ratio>                   Set ratio directly (overrides WH/D)
  11364             *  W<width> H<height> D<diam> Set ratio from WH/D
  11365             */
  11366            inline void gcode_M900() {
  11367              stepper.synchronize();
  11368          
  11369              const float newK = parser.floatval('K', -1);
  11370              if (newK >= 0) planner.extruder_advance_k = newK;
  11371          
  11372              float newR = parser.floatval('R', -1);
  11373              if (newR < 0) {
  11374                const float newD = parser.floatval('D', -1),
  11375                            newW = parser.floatval('W', -1),
  11376                            newH = parser.floatval('H', -1);
  11377                if (newD >= 0 && newW >= 0 && newH >= 0)
  11378                  newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
  11379              }
  11380              if (newR >= 0) planner.advance_ed_ratio = newR;
  11381          
  11382              SERIAL_ECHO_START();
  11383              SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
  11384              SERIAL_ECHOPGM(" E/D=");
  11385              const float ratio = planner.advance_ed_ratio;
  11386              if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
  11387              SERIAL_EOL();
  11388            }
  11389          #endif // LIN_ADVANCE
  11390          
  11391          #if HAS_TRINAMIC
  11392            static bool report_tmc_status = false;
  11393            const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
  11394            enum TMC_AxisEnum {
  11395              TMC_X,
  11396              TMC_X2,
  11397              TMC_Y,
  11398              TMC_Y2,
  11399              TMC_Z,
  11400              TMC_Z2,
  11401              TMC_E0,
  11402              TMC_E1,
  11403              TMC_E2,
  11404              TMC_E3,
  11405              TMC_E4
  11406            };
  11407            #if ENABLED(TMC_DEBUG)
  11408              enum TMC_debug_enum {
  11409                TMC_CODES,
  11410                TMC_ENABLED,
  11411                TMC_CURRENT,
  11412                TMC_RMS_CURRENT,
  11413                TMC_MAX_CURRENT,
  11414                TMC_IRUN,
  11415                TMC_IHOLD,
  11416                TMC_CS_ACTUAL,
  11417                TMC_PWM_SCALE,
  11418                TMC_VSENSE,
  11419                TMC_STEALTHCHOP,
  11420                TMC_MICROSTEPS,
  11421                TMC_TSTEP,
  11422                TMC_TPWMTHRS,
  11423                TMC_TPWMTHRS_MMS,
  11424                TMC_OTPW,
  11425                TMC_OTPW_TRIGGERED,
  11426                TMC_TOFF,
  11427                TMC_TBL,
  11428                TMC_HEND,
  11429                TMC_HSTRT,
  11430                TMC_SGT
  11431              };
  11432              enum TMC_drv_status_enum {
  11433                TMC_DRV_CODES,
  11434                TMC_STST,
  11435                TMC_OLB,
  11436                TMC_OLA,
  11437                TMC_S2GB,
  11438                TMC_S2GA,
  11439                TMC_DRV_OTPW,
  11440                TMC_OT,
  11441                TMC_STALLGUARD,
  11442                TMC_DRV_CS_ACTUAL,
  11443                TMC_FSACTIVE,
  11444                TMC_SG_RESULT,
  11445                TMC_DRV_STATUS_HEX,
  11446                TMC_T157,
  11447                TMC_T150,
  11448                TMC_T143,
  11449                TMC_T120,
  11450                TMC_STEALTH,
  11451                TMC_S2VSB,
  11452                TMC_S2VSA
  11453              };
  11454              static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
  11455                SERIAL_ECHO(name);
  11456                SERIAL_ECHOPGM(" = 0x");
  11457                for(int B=24; B>=8; B-=8){
  11458                  MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
  11459                  MYSERIAL.print((drv_status>>B)&0xF, HEX);
  11460                  MYSERIAL.print(':');
  11461                }
  11462                MYSERIAL.print((drv_status>>4)&0xF, HEX);
  11463                MYSERIAL.print((drv_status)&0xF, HEX);
  11464                SERIAL_EOL();
  11465              }
  11466          
  11467              #if ENABLED(HAVE_TMC2130)
  11468                static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
  11469                  switch(i) {
  11470                    case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
  11471                    case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
  11472                    case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
  11473                    case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
  11474                    default: break;
  11475                  }
  11476                }
  11477                static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
  11478                  switch(i) {
  11479                    case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
  11480                    case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
  11481                    case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
  11482                    default: break;
  11483                  }
  11484                }
  11485              #endif
  11486              #if ENABLED(HAVE_TMC2208)
  11487                static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
  11488                  switch(i) {
  11489                    case TMC_TSTEP:
  11490                      {
  11491                        uint32_t data = 0;
  11492                        st.TSTEP(&data);
  11493                        MYSERIAL.print(data);
  11494                        break;
  11495                      }
  11496                    case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
  11497                    case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
  11498                    case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
  11499                    case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
  11500                    default: break;
  11501                  }
  11502                }
  11503                static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
  11504                  switch(i) {
  11505                    case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
  11506                    case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
  11507                    case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
  11508                    case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
  11509                    default: break;
  11510                  }
  11511                }
  11512              #endif
  11513              template <typename TMC>
  11514              static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
  11515                SERIAL_ECHO('\t');
  11516                switch(i) {
  11517                  case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
  11518                  case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
  11519                  case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
  11520                  case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
  11521                  case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
  11522                  case TMC_IRUN:
  11523                    MYSERIAL.print(st.irun(), DEC);
  11524                    SERIAL_ECHOPGM("/31");
  11525                    break;
  11526                  case TMC_IHOLD:
  11527                    MYSERIAL.print(st.ihold(), DEC);
  11528                    SERIAL_ECHOPGM("/31");
  11529                    break;
  11530                  case TMC_CS_ACTUAL:
  11531                    MYSERIAL.print(st.cs_actual(), DEC);
  11532                    SERIAL_ECHOPGM("/31");
  11533                    break;
  11534          
  11535                  case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
  11536          
  11537                  case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
  11538                  case TMC_TPWMTHRS:
  11539                    {
  11540                      uint32_t tpwmthrs_val = st.TPWMTHRS();
  11541                      SERIAL_ECHO(tpwmthrs_val);
  11542                    }
  11543                    break;
  11544                  case TMC_TPWMTHRS_MMS:
  11545                    {
  11546                      uint32_t tpwmthrs_val = st.TPWMTHRS();
  11547                      tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
  11548                    }
  11549                    break;
  11550                  case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
  11551                  case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
  11552                  case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
  11553                  case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
  11554                  case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
  11555                  case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
  11556                  default: tmc_status(st, i); break;
  11557                }
  11558              }
  11559              template <typename TMC>
  11560              static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
  11561                SERIAL_ECHOPGM("\t");
  11562                switch(i) {
  11563                  case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
  11564                  case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
  11565                  case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
  11566                  case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
  11567                  case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
  11568                  case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
  11569                  case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
  11570                  case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
  11571                  case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
  11572                  case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
  11573                  default: tmc_parse_drv_status(st, i); break;
  11574                }
  11575              }
  11576          
  11577              static void tmc_debug_loop(const TMC_debug_enum i) {
  11578                #if X_IS_TRINAMIC
  11579                  tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
  11580                #endif
  11581                #if X2_IS_TRINAMIC
  11582                  tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
  11583                #endif
  11584          
  11585                #if Y_IS_TRINAMIC
  11586                  tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
  11587                #endif
  11588                #if Y2_IS_TRINAMIC
  11589                  tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
  11590                #endif
  11591          
  11592                #if Z_IS_TRINAMIC
  11593                  tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
  11594                #endif
  11595                #if Z2_IS_TRINAMIC
  11596                  tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
  11597                #endif
  11598          
  11599                #if E0_IS_TRINAMIC
  11600                  tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
  11601                #endif
  11602                #if E1_IS_TRINAMIC
  11603                  tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
  11604                #endif
  11605                #if E2_IS_TRINAMIC
  11606                  tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
  11607                #endif
  11608                #if E3_IS_TRINAMIC
  11609                  tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
  11610                #endif
  11611                #if E4_IS_TRINAMIC
  11612                  tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
  11613                #endif
  11614          
  11615                SERIAL_EOL();
  11616              }
  11617          
  11618              static void drv_status_loop(const TMC_drv_status_enum i) {
  11619                #if X_IS_TRINAMIC
  11620                  tmc_parse_drv_status(stepperX, TMC_X, i);
  11621                #endif
  11622                #if X2_IS_TRINAMIC
  11623                  tmc_parse_drv_status(stepperX2, TMC_X2, i);
  11624                #endif
  11625          
  11626                #if Y_IS_TRINAMIC
  11627                  tmc_parse_drv_status(stepperY, TMC_Y, i);
  11628                #endif
  11629                #if Y2_IS_TRINAMIC
  11630                  tmc_parse_drv_status(stepperY2, TMC_Y2, i);
  11631                #endif
  11632          
  11633                #if Z_IS_TRINAMIC
  11634                  tmc_parse_drv_status(stepperZ, TMC_Z, i);
  11635                #endif
  11636                #if Z2_IS_TRINAMIC
  11637                  tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
  11638                #endif
  11639          
  11640                #if E0_IS_TRINAMIC
  11641                  tmc_parse_drv_status(stepperE0, TMC_E0, i);
  11642                #endif
  11643                #if E1_IS_TRINAMIC
  11644                  tmc_parse_drv_status(stepperE1, TMC_E1, i);
  11645                #endif
  11646                #if E2_IS_TRINAMIC
  11647                  tmc_parse_drv_status(stepperE2, TMC_E2, i);
  11648                #endif
  11649                #if E3_IS_TRINAMIC
  11650                  tmc_parse_drv_status(stepperE3, TMC_E3, i);
  11651                #endif
  11652                #if E4_IS_TRINAMIC
  11653                  tmc_parse_drv_status(stepperE4, TMC_E4, i);
  11654                #endif
  11655          
  11656                SERIAL_EOL();
  11657              }
  11658          
  11659              inline void gcode_M122() {
  11660                if (parser.seen('S')) {
  11661                  if (parser.value_bool()) {
  11662                    SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
  11663                    report_tmc_status = true;
  11664                  } else
  11665                    report_tmc_status = false;
  11666                } else {
  11667                  SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
  11668                  SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
  11669                  SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
  11670                  SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
  11671                  SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
  11672                  SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
  11673                  SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
  11674                  SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
  11675                  SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
  11676                  SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
  11677                  SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
  11678                  SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
  11679                  SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
  11680                  SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
  11681                  SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
  11682                  SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
  11683                  SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
  11684                  SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
  11685                  SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
  11686                  SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
  11687                  SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
  11688                  SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
  11689          
  11690                  SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
  11691                  #if ENABLED(HAVE_TMC2130)
  11692                    SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
  11693                    SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
  11694                    SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
  11695                  #endif
  11696                  SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
  11697                  SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
  11698                  SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
  11699                  SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
  11700                  SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
  11701                  SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
  11702                  SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
  11703                  #if ENABLED(HAVE_TMC2208)
  11704                    SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
  11705                    SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
  11706                    SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
  11707                    SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
  11708                    SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
  11709                    SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
  11710                  #endif
  11711                  SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
  11712                }
  11713              }
  11714            #endif
  11715          
  11716            template<typename TMC>
  11717            static void tmc_get_current(TMC &st, const char name[]) {
  11718              SERIAL_ECHO(name);
  11719              SERIAL_ECHOPGM(" axis driver current: ");
  11720              SERIAL_ECHOLN(st.getCurrent());
  11721            }
  11722            template<typename TMC>
  11723            static void tmc_set_current(TMC &st, const char name[], const int mA) {
  11724              st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
  11725              tmc_get_current(st, name);
  11726            }
  11727          
  11728            template<typename TMC>
  11729            static void tmc_report_otpw(TMC &st, const char name[]) {
  11730              SERIAL_ECHO(name);
  11731              SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
  11732              serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
  11733              SERIAL_EOL();
  11734            }
  11735            template<typename TMC>
  11736            static void tmc_clear_otpw(TMC &st, const char name[]) {
  11737              st.clear_otpw();
  11738              SERIAL_ECHO(name);
  11739              SERIAL_ECHOLNPGM(" prewarn flag cleared");
  11740            }
  11741          
  11742            template<typename TMC>
  11743            static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
  11744              SERIAL_ECHO(name);
  11745              SERIAL_ECHOPGM(" stealthChop max speed set to ");
  11746              SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
  11747            }
  11748            template<typename TMC>
  11749            static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
  11750              st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
  11751              tmc_get_pwmthrs(st, name, spmm);
  11752            }
  11753          
  11754            template<typename TMC>
  11755            static void tmc_get_sgt(TMC &st, const char name[]) {
  11756              SERIAL_ECHO(name);
  11757              SERIAL_ECHOPGM(" driver homing sensitivity set to ");
  11758              MYSERIAL.println(st.sgt(), DEC);
  11759            }
  11760            template<typename TMC>
  11761            static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
  11762              st.sgt(sgt_val);
  11763              tmc_get_sgt(st, name);
  11764            }
  11765          
  11766            /**
  11767             * M906: Set motor current in milliamps using axis codes X, Y, Z, E
  11768             * Report driver currents when no axis specified
  11769             */
  11770            inline void gcode_M906() {
  11771              uint16_t values[XYZE];
  11772              LOOP_XYZE(i)
  11773                values[i] = parser.intval(axis_codes[i]);
  11774          
  11775              #if X_IS_TRINAMIC
  11776                if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
  11777                else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
  11778              #endif
  11779              #if X2_IS_TRINAMIC
  11780                if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
  11781                else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
  11782              #endif
  11783              #if Y_IS_TRINAMIC
  11784                if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
  11785                else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
  11786              #endif
  11787              #if Y2_IS_TRINAMIC
  11788                if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
  11789                else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
  11790              #endif
  11791              #if Z_IS_TRINAMIC
  11792                if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
  11793                else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
  11794              #endif
  11795              #if Z2_IS_TRINAMIC
  11796                if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
  11797                else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
  11798              #endif
  11799              #if E0_IS_TRINAMIC
  11800                if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
  11801                else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
  11802              #endif
  11803              #if E1_IS_TRINAMIC
  11804                if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
  11805                else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
  11806              #endif
  11807              #if E2_IS_TRINAMIC
  11808                if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
  11809                else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
  11810              #endif
  11811              #if E3_IS_TRINAMIC
  11812                if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
  11813                else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
  11814              #endif
  11815              #if E4_IS_TRINAMIC
  11816                if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
  11817                else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
  11818              #endif
  11819          
  11820            }
  11821          
  11822            /**
  11823             * M911: Report TMC stepper driver overtemperature pre-warn flag
  11824             * The flag is held by the library and persist until manually cleared by M912
  11825             */
  11826            inline void gcode_M911() {
  11827              #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11828                tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
  11829              #endif
  11830              #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11831                tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
  11832              #endif
  11833              #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11834                tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
  11835              #endif
  11836              #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
  11837                tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
  11838              #endif
  11839            }
  11840          
  11841            /**
  11842             * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
  11843             */
  11844            inline void gcode_M912() {
  11845              const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
  11846                       clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
  11847              #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
  11848                if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
  11849              #endif
  11850              #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
  11851                if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
  11852              #endif
  11853          
  11854              #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
  11855                if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
  11856              #endif
  11857          
  11858              #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
  11859                if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
  11860              #endif
  11861          
  11862              #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
  11863                if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
  11864              #endif
  11865            }
  11866          
  11867            /**
  11868             * M913: Set HYBRID_THRESHOLD speed.
  11869             */
  11870            #if ENABLED(HYBRID_THRESHOLD)
  11871              inline void gcode_M913() {
  11872                uint16_t values[XYZE];
  11873                LOOP_XYZE(i)
  11874                  values[i] = parser.intval(axis_codes[i]);
  11875          
  11876                #if X_IS_TRINAMIC
  11877                  if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  11878                  else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
  11879                #endif
  11880                #if X2_IS_TRINAMIC
  11881                  if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
  11882                  else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
  11883                #endif
  11884          
  11885                #if Y_IS_TRINAMIC
  11886                  if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  11887                  else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
  11888                #endif
  11889                #if Y2_IS_TRINAMIC
  11890                  if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
  11891                  else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
  11892                #endif
  11893          
  11894                #if Z_IS_TRINAMIC
  11895                  if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  11896                  else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
  11897                #endif
  11898                #if Z2_IS_TRINAMIC
  11899                  if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
  11900                  else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
  11901                #endif
  11902          
  11903                #if E0_IS_TRINAMIC
  11904                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11905                  else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
  11906                #endif
  11907                #if E1_IS_TRINAMIC
  11908                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11909                  else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
  11910                #endif
  11911                #if E2_IS_TRINAMIC
  11912                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11913                  else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
  11914                #endif
  11915                #if E3_IS_TRINAMIC
  11916                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11917                  else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
  11918                #endif
  11919                #if E4_IS_TRINAMIC
  11920                  if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
  11921                  else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
  11922                #endif
  11923              }
  11924            #endif // HYBRID_THRESHOLD
  11925          
  11926            /**
  11927             * M914: Set SENSORLESS_HOMING sensitivity.
  11928             */
  11929            #if ENABLED(SENSORLESS_HOMING)
  11930              inline void gcode_M914() {
  11931                #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
  11932                  if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
  11933                  else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
  11934                #endif
  11935                #if ENABLED(X2_IS_TMC2130)
  11936                  if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
  11937                  else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
  11938                #endif
  11939                #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
  11940                  if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
  11941                  else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
  11942                #endif
  11943                #if ENABLED(Y2_IS_TMC2130)
  11944                  if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
  11945                  else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
  11946                #endif
  11947              }
  11948            #endif // SENSORLESS_HOMING
  11949          
  11950            /**
  11951             * TMC Z axis calibration routine
  11952             */
  11953            #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
  11954              inline void gcode_M915() {
  11955                uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
  11956                uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
  11957          
  11958                if (!axis_known_position[Z_AXIS]) {
  11959                  SERIAL_ECHOLNPGM("\nPlease home Z axis first");
  11960                  return;
  11961                }
  11962          
  11963                uint16_t Z_current_1 = stepperZ.getCurrent();
  11964                uint16_t Z2_current_1 = stepperZ.getCurrent();
  11965          
  11966                stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
  11967                stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
  11968                SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
  11969          
  11970                soft_endstops_enabled = false;
  11971          
  11972                do_blocking_move_to_z(Z_MAX_POS+_z);
  11973          
  11974                stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
  11975                stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
  11976          
  11977                do_blocking_move_to_z(Z_MAX_POS);
  11978                soft_endstops_enabled = true;
  11979          
  11980                SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
  11981                home_z_safely();
  11982              }
  11983            #endif
  11984          
  11985          #endif // HAS_TRINAMIC
  11986          
  11987          /**
  11988           * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
  11989           */

   \                                 In section .text, align 2
  11990          inline void gcode_M907() {
  11991            #if HAS_DIGIPOTSS
  11992          
  11993              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
  11994              if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
  11995              if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
  11996          
  11997            #elif HAS_MOTOR_CURRENT_PWM
  11998          
  11999              #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
  12000                if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
  12001              #endif
  12002              #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
  12003                if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
  12004              #endif
  12005              #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
  12006                if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
  12007              #endif
  12008          
  12009            #endif
  12010          
  12011            #if ENABLED(DIGIPOT_I2C)
  12012              // this one uses actual amps in floating point
  12013              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
  12014              // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
  12015              for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
  12016            #endif
  12017          
  12018            #if ENABLED(DAC_STEPPER_CURRENT)
  12019              if (parser.seen('S')) {
  12020                const float dac_percent = parser.value_float();
  12021                for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
  12022              }
  12023              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
  12024            #endif
  12025          }
   \                     _Z10gcode_M907v: (+1)
   \   00000000   0x4770             BX       LR               ;; return
  12026          
  12027          #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  12028          
  12029            /**
  12030             * M908: Control digital trimpot directly (M908 P<pin> S<current>)
  12031             */
  12032            inline void gcode_M908() {
  12033              #if HAS_DIGIPOTSS
  12034                stepper.digitalPotWrite(
  12035                  parser.intval('P'),
  12036                  parser.intval('S')
  12037                );
  12038              #endif
  12039              #ifdef DAC_STEPPER_CURRENT
  12040                dac_current_raw(
  12041                  parser.byteval('P', -1),
  12042                  parser.ushortval('S', 0)
  12043                );
  12044              #endif
  12045            }
  12046          
  12047            #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  12048          
  12049              inline void gcode_M909() { dac_print_values(); }
  12050          
  12051              inline void gcode_M910() { dac_commit_eeprom(); }
  12052          
  12053            #endif
  12054          
  12055          #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  12056          
  12057          #if HAS_MICROSTEPS
  12058          
  12059            // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  12060            inline void gcode_M350() {
  12061              if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
  12062              LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
  12063              if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
  12064              stepper.microstep_readings();
  12065            }
  12066          
  12067            /**
  12068             * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
  12069             *       S# determines MS1 or MS2, X# sets the pin high/low.
  12070             */
  12071            inline void gcode_M351() {
  12072              if (parser.seenval('S')) switch (parser.value_byte()) {
  12073                case 1:
  12074                  LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
  12075                  if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
  12076                  break;
  12077                case 2:
  12078                  LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
  12079                  if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
  12080                  break;
  12081              }
  12082              stepper.microstep_readings();
  12083            }
  12084          
  12085          #endif // HAS_MICROSTEPS
  12086          
  12087          #if HAS_CASE_LIGHT
  12088            #ifndef INVERT_CASE_LIGHT
  12089              #define INVERT_CASE_LIGHT false
  12090            #endif
  12091            uint8_t case_light_brightness;  // LCD routine wants INT
  12092            bool case_light_on;
  12093          
  12094            void update_case_light() {
  12095              pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
  12096              if (case_light_on) {
  12097                if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
  12098                  analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
  12099                else
  12100                  WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
  12101              }
  12102              else {
  12103                if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
  12104                  analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
  12105                else
  12106                  WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
  12107              }
  12108            }
  12109          #endif // HAS_CASE_LIGHT
  12110          
  12111          /**
  12112           * M355: Turn case light on/off and set brightness
  12113           *
  12114           *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
  12115           *
  12116           *   S<bool>  Set case light on/off
  12117           *
  12118           *   When S turns on the light on a PWM pin then the current brightness level is used/restored
  12119           *
  12120           *   M355 P200 S0 turns off the light & sets the brightness level
  12121           *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
  12122           */

   \                                 In section .text, align 4
  12123          inline void gcode_M355() {
   \                     _Z10gcode_M355v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12124            #if HAS_CASE_LIGHT
  12125              uint8_t args = 0;
  12126              if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
  12127              if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
  12128              if (args) update_case_light();
  12129          
  12130              // always report case light status
  12131              SERIAL_ECHO_START();
  12132              if (!case_light_on) {
  12133                SERIAL_ECHOLN("Case light: off");
  12134              }
  12135              else {
  12136                if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
  12137                else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
  12138              }
  12139          
  12140            #else
  12141              SERIAL_ERROR_START();
   \   00000002   0x4804             LDR.N    R0,??gcode_M355_0
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12142              SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
   \   00000008   0x4803             LDR.N    R0,??gcode_M355_0+0x4
   \   0000000A   0xE8BD 0x4002      POP      {R1,LR}
   \   0000000E   0x.... 0x....      B.W      _Z14serialprintPGMPKc
   \   00000012   0xBF00             Nop      
   \                     ??gcode_M355_0:
   \   00000014   0x........         DC32     errormagic
   \   00000018   0x........         DC32     _ZZ10gcode_M355vEs
  12143            #endif // HAS_CASE_LIGHT
  12144          }
  12145          
  12146          #if ENABLED(MIXING_EXTRUDER)
  12147          
  12148            /**
  12149             * M163: Set a single mix factor for a mixing extruder
  12150             *       This is called "weight" by some systems.
  12151             *
  12152             *   S[index]   The channel index to set
  12153             *   P[float]   The mix value
  12154             *
  12155             */
  12156            inline void gcode_M163() {
  12157              const int mix_index = parser.intval('S');
  12158              if (mix_index < MIXING_STEPPERS) {
  12159                float mix_value = parser.floatval('P');
  12160                NOLESS(mix_value, 0.0);
  12161                mixing_factor[mix_index] = RECIPROCAL(mix_value);
  12162              }
  12163            }
  12164          
  12165            #if MIXING_VIRTUAL_TOOLS > 1
  12166          
  12167              /**
  12168               * M164: Store the current mix factors as a virtual tool.
  12169               *
  12170               *   S[index]   The virtual tool to store
  12171               *
  12172               */
  12173              inline void gcode_M164() {
  12174                const int tool_index = parser.intval('S');
  12175                if (tool_index < MIXING_VIRTUAL_TOOLS) {
  12176                  normalize_mix();
  12177                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  12178                    mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
  12179                }
  12180              }
  12181          
  12182            #endif
  12183          
  12184            #if ENABLED(DIRECT_MIXING_IN_G1)
  12185              /**
  12186               * M165: Set multiple mix factors for a mixing extruder.
  12187               *       Factors that are left out will be set to 0.
  12188               *       All factors together must add up to 1.0.
  12189               *
  12190               *   A[factor] Mix factor for extruder stepper 1
  12191               *   B[factor] Mix factor for extruder stepper 2
  12192               *   C[factor] Mix factor for extruder stepper 3
  12193               *   D[factor] Mix factor for extruder stepper 4
  12194               *   H[factor] Mix factor for extruder stepper 5
  12195               *   I[factor] Mix factor for extruder stepper 6
  12196               *
  12197               */
  12198              inline void gcode_M165() { gcode_get_mix(); }
  12199            #endif
  12200          
  12201          #endif // MIXING_EXTRUDER
  12202          
  12203          /**
  12204           * M999: Restart after being stopped
  12205           *
  12206           * Default behaviour is to flush the serial buffer and request
  12207           * a resend to the host starting on the last N line received.
  12208           *
  12209           * Sending "M999 S1" will resume printing without flushing the
  12210           * existing command buffer.
  12211           *
  12212           */

   \                                 In section .text, align 4
  12213          inline void gcode_M999() {
   \                     _Z10gcode_M999v: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  12214            Running = true;
   \   00000002   0x2001             MOVS     R0,#+1
   \   00000004   0x4906             LDR.N    R1,??gcode_M999_0
   \   00000006   0x7108             STRB     R0,[R1, #+4]
  12215            lcd_reset_alert_level();
   \   00000008   0x.... 0x....      BL       _Z21lcd_reset_alert_levelv
  12216          
  12217            if (parser.boolval('S')) return;
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD103             BNE.N    ??gcode_M999_1
  12218          
  12219            // gcode_LastN = Stopped_gcode_LastN;
  12220            FlushSerialRequestResend();
   \   00000016   0xE8BD 0x4001      POP      {R0,LR}
   \   0000001A   0x.... 0x....      B.W      _Z24FlushSerialRequestResendv
   \                     ??gcode_M999_1: (+1)
   \   0000001E   0xBD01             POP      {R0,PC}          ;; return
   \                     ??gcode_M999_0:
   \   00000020   0x........         DC32     axis_relative_modes
  12221          }
  12222          
  12223          #if ENABLED(SWITCHING_EXTRUDER)
  12224            #if EXTRUDERS > 3
  12225              #define REQ_ANGLES 4
  12226              #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
  12227            #else
  12228              #define REQ_ANGLES 2
  12229              #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
  12230            #endif
  12231            inline void move_extruder_servo(const uint8_t e) {
  12232              constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
  12233              static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
  12234              stepper.synchronize();
  12235              #if EXTRUDERS & 1
  12236                if (e < EXTRUDERS - 1)
  12237              #endif
  12238              {
  12239                MOVE_SERVO(_SERVO_NR, angles[e]);
  12240                safe_delay(500);
  12241              }
  12242            }
  12243          #endif // SWITCHING_EXTRUDER
  12244          
  12245          #if ENABLED(SWITCHING_NOZZLE)
  12246            inline void move_nozzle_servo(const uint8_t e) {
  12247              const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
  12248              stepper.synchronize();
  12249              MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
  12250              safe_delay(500);
  12251            }
  12252          #endif
  12253          

   \                                 In section .text, align 4
  12254          inline void invalid_extruder_error(const uint8_t e) {
   \                     _Z22invalid_extruder_errorh: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  12255            SERIAL_ECHO_START();
   \   00000004   0x480D             LDR.N    R0,??invalid_extruder_error_0
   \   00000006   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12256            SERIAL_CHAR('T');
   \   0000000A   0x4D0D             LDR.N    R5,??invalid_extruder_error_0+0x4
   \   0000000C   0x2154             MOVS     R1,#+84
   \   0000000E   0x4628             MOV      R0,R5
   \   00000010   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  12257            SERIAL_ECHO_F(e, DEC);
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       _ZN5Print5printEhi
  12258            SERIAL_CHAR(' ');
   \   0000001E   0x2120             MOVS     R1,#+32
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  12259            SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
   \   00000026   0x4907             LDR.N    R1,??invalid_extruder_error_0+0x8
   \   00000028   0x4628             MOV      R0,R5
   \   0000002A   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   0000002E   0x210A             MOVS     R1,#+10
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000036   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \   0000003A   0xBF00             Nop      
   \                     ??invalid_extruder_error_0:
   \   0000003C   0x........         DC32     echomagic
   \   00000040   0x........         DC32     Serial3
   \   00000044   0x........         DC32     _ZZ22invalid_extruder_errorhEs
  12260          }
  12261          
  12262          #if ENABLED(PARKING_EXTRUDER)
  12263          
  12264            #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  12265              #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
  12266            #else
  12267              #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
  12268            #endif
  12269          
  12270            void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
  12271              switch (extruder_num) {
  12272                case 1: OUT_WRITE(SOL1_PIN, state); break;
  12273                default: OUT_WRITE(SOL0_PIN, state); break;
  12274              }
  12275              #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
  12276                dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
  12277              #endif
  12278            }
  12279          
  12280            inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
  12281            inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
  12282          
  12283          #endif // PARKING_EXTRUDER
  12284          
  12285          #if HAS_FANMUX
  12286          
  12287            void fanmux_switch(const uint8_t e) {
  12288              WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
  12289              #if PIN_EXISTS(FANMUX1)
  12290                WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
  12291                #if PIN_EXISTS(FANMUX2)
  12292                  WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
  12293                #endif
  12294              #endif
  12295            }
  12296          
  12297            FORCE_INLINE void fanmux_init(void) {
  12298              SET_OUTPUT(FANMUX0_PIN);
  12299              #if PIN_EXISTS(FANMUX1)
  12300                SET_OUTPUT(FANMUX1_PIN);
  12301                #if PIN_EXISTS(FANMUX2)
  12302                  SET_OUTPUT(FANMUX2_PIN);
  12303                #endif
  12304              #endif
  12305              fanmux_switch(0);
  12306            }
  12307          
  12308          #endif // HAS_FANMUX
  12309          
  12310          /**
  12311           * Perform a tool-change, which may result in moving the
  12312           * previous tool out of the way and the new tool into place.
  12313           */

   \                                 In section .text, align 2, keep-with-next
  12314          void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   \                     _Z11tool_changehfb: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB099             SUB      SP,SP,#+100
   \   00000006   0x4606             MOV      R6,R0
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x4615             MOV      R5,R2
  12315            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  12316          
  12317              if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
  12318                return invalid_extruder_error(tmp_extruder);
  12319          
  12320              // T0-Tnnn: Switch virtual tool by changing the mix
  12321              for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
  12322                mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
  12323          
  12324            #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  12325          
  12326              if (tmp_extruder >= EXTRUDERS)
   \   0000000C   0x46B2             MOV      R10,R6
   \   0000000E   0xF1BA 0x0F02      CMP      R10,#+2
   \   00000012   0xDB03             BLT.N    ??tool_change_0
  12327                return invalid_extruder_error(tmp_extruder);
   \   00000014   0x4630             MOV      R0,R6
   \   00000016   0x.... 0x....      BL       _Z22invalid_extruder_errorh
   \   0000001A   0xE0F2             B.N      ??tool_change_1
  12328          
  12329              #if HOTENDS > 1
  12330          
  12331                const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
   \                     ??tool_change_0: (+1)
   \   0000001C   0x.... 0x....      LDR.W    R4,??DataTable156_1
   \   00000020   0x2100             MOVS     R1,#+0
   \   00000022   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000026   0xD201             BCS.N    ??tool_change_2
   \   00000028   0x9006             STR      R0,[SP, #+24]
   \   0000002A   0xE001             B.N      ??tool_change_3
   \                     ??tool_change_2: (+1)
   \   0000002C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000002E   0x9106             STR      R1,[SP, #+24]
  12332          
  12333                feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
   \                     ??tool_change_3: (+1)
   \   00000030   0x2100             MOVS     R1,#+0
   \   00000032   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000036   0xD201             BCS.N    ??tool_change_4
   \   00000038   0x65E0             STR      R0,[R4, #+92]
   \   0000003A   0xE001             B.N      ??tool_change_5
   \                     ??tool_change_4: (+1)
   \   0000003C   0x6F60             LDR      R0,[R4, #+116]
   \   0000003E   0x65E0             STR      R0,[R4, #+92]
  12334          
  12335                if (tmp_extruder != active_extruder) {
   \                     ??tool_change_5: (+1)
   \   00000040   0x78E0             LDRB     R0,[R4, #+3]
   \   00000042   0x4286             CMP      R6,R0
   \   00000044   0xF000 0x80CC      BEQ.W    ??tool_change_6
  12336                  if (!no_move && axis_unhomed_error()) {
   \   00000048   0x2D00             CMP      R5,#+0
   \   0000004A   0xD107             BNE.N    ??tool_change_7
   \   0000004C   0x2201             MOVS     R2,#+1
   \   0000004E   0x4611             MOV      R1,R2
   \   00000050   0x4608             MOV      R0,R1
   \   00000052   0x.... 0x....      BL       _Z18axis_unhomed_errorbbb
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD000             BEQ.N    ??tool_change_7
  12337                    no_move = true;
   \   0000005A   0x2501             MOVS     R5,#+1
  12338                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12339                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
  12340                    #endif
  12341                  }
  12342          
  12343                  // Save current position to destination, for use later
  12344                  //if(gCfgItems.breakpoint_flg!=1)
  12345                      set_destination_from_current();
   \                     ??tool_change_7: (+1)
   \   0000005C   0x.... 0x....      BL       _Z28set_destination_from_currentv
  12346          
  12347                  #if ENABLED(DUAL_X_CARRIAGE)
  12348          
  12349                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12350                      if (DEBUGGING(LEVELING)) {
  12351                        SERIAL_ECHOPGM("Dual X Carriage Mode ");
  12352                        switch (dual_x_carriage_mode) {
  12353                          case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
  12354                          case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
  12355                          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
  12356                        }
  12357                      }
  12358                    #endif
  12359          
  12360                    const float xhome = x_home_pos(active_extruder);
  12361                    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
  12362                        && IsRunning()
  12363                        && (delayed_move_time || current_position[X_AXIS] != xhome)
  12364                    ) {
  12365                      float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
  12366                      //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
  12367                      if(mksCfg.max_software_endstops){
  12368                        NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
  12369                      }
  12370                      //#endif
  12371                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12372                        if (DEBUGGING(LEVELING)) {
  12373                          SERIAL_ECHOLNPAIR("Raise to ", raised_z);
  12374                          SERIAL_ECHOLNPAIR("MoveX to ", xhome);
  12375                          SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
  12376                        }
  12377                      #endif
  12378                      // Park old head: 1) raise 2) move to park position 3) lower
  12379                      for (uint8_t i = 0; i < 3; i++)
  12380                        planner.buffer_line(
  12381                          i == 0 ? current_position[X_AXIS] : xhome,
  12382                          current_position[Y_AXIS],
  12383                          i == 2 ? current_position[Z_AXIS] : raised_z,
  12384                          current_position[E_AXIS],
  12385                          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
  12386                          active_extruder
  12387                        );
  12388                      stepper.synchronize();
  12389                    }
  12390          
  12391                    // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
  12392                    current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
  12393                    current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  12394          
  12395                    // Activate the new extruder ahead of calling set_axis_is_at_home!
  12396                    active_extruder = tmp_extruder;
  12397          
  12398                    // This function resets the max/min values - the current position may be overwritten below.
  12399                    set_axis_is_at_home(X_AXIS);
  12400          
  12401                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12402                      if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
  12403                    #endif
  12404          
  12405                    // Only when auto-parking are carriages safe to move
  12406                    if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
  12407          
  12408                    switch (dual_x_carriage_mode) {
  12409                      case DXC_FULL_CONTROL_MODE:
  12410                        // New current position is the position of the activated extruder
  12411                        current_position[X_AXIS] = inactive_extruder_x_pos;
  12412                        // Save the inactive extruder's position (from the old current_position)
  12413                        inactive_extruder_x_pos = destination[X_AXIS];
  12414                        break;
  12415                      case DXC_AUTO_PARK_MODE:
  12416                        // record raised toolhead position for use by unpark
  12417                        COPY(raised_parked_position, current_position);
  12418                        raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
  12419                        //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
  12420                        if(mksCfg.max_software_endstops){
  12421                          NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
  12422                        }
  12423                        //#endif
  12424                        active_extruder_parked = true;
  12425                        delayed_move_time = 0;
  12426                        break;
  12427                      case DXC_DUPLICATION_MODE:
  12428                        // If the new extruder is the left one, set it "parked"
  12429                        // This triggers the second extruder to move into the duplication position
  12430                        active_extruder_parked = (active_extruder == 0);
  12431          
  12432                        if (active_extruder_parked)
  12433                          current_position[X_AXIS] = inactive_extruder_x_pos;
  12434                        else
  12435                          current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
  12436                        inactive_extruder_x_pos = destination[X_AXIS];
  12437                        extruder_duplication_enabled = false;
  12438                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12439                          if (DEBUGGING(LEVELING)) {
  12440                            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
  12441                            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
  12442                          }
  12443                        #endif
  12444                        break;
  12445                    }
  12446          
  12447                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12448                      if (DEBUGGING(LEVELING)) {
  12449                        SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
  12450                        DEBUG_POS("New extruder (parked)", current_position);
  12451                      }
  12452                    #endif
  12453          
  12454                    // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
  12455          
  12456                  #else // !DUAL_X_CARRIAGE
  12457          
  12458                    #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
  12459                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  12460                      float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
  12461                      if (!no_move) {
  12462          
  12463                        const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
  12464                                    midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
  12465                                    grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
  12466                                              + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
  12467                        /**
  12468                         *  Steps:
  12469                         *    1. Raise Z-Axis to give enough clearance
  12470                         *    2. Move to park position of old extruder
  12471                         *    3. Disengage magnetic field, wait for delay
  12472                         *    4. Move near new extruder
  12473                         *    5. Engage magnetic field for new extruder
  12474                         *    6. Move to parking incl. offset of new extruder
  12475                         *    7. Lower Z-Axis
  12476                         */
  12477          
  12478                        // STEP 1
  12479                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12480                          SERIAL_ECHOLNPGM("Starting Autopark");
  12481                          if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
  12482                        #endif
  12483                        current_position[Z_AXIS] += z_raise;
  12484                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12485                          SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
  12486                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
  12487                        #endif
  12488                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  12489                        stepper.synchronize();
  12490          
  12491                        // STEP 2
  12492                        current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
  12493                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12494                          SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
  12495                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
  12496                        #endif
  12497                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12498                        stepper.synchronize();
  12499          
  12500                        // STEP 3
  12501                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12502                          SERIAL_ECHOLNPGM("(3) Disengage magnet ");
  12503                        #endif
  12504                        pe_deactivate_magnet(active_extruder);
  12505          
  12506                        // STEP 4
  12507                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12508                          SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
  12509                        #endif
  12510                        current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
  12511          
  12512                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12513                          if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
  12514                        #endif
  12515                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12516                        stepper.synchronize();
  12517          
  12518                        // STEP 5
  12519                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12520                          SERIAL_ECHOLNPGM("(5) Engage magnetic field");
  12521                        #endif
  12522          
  12523                        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  12524                          pe_activate_magnet(active_extruder); //just save power for inverted magnets
  12525                        #endif
  12526                        pe_activate_magnet(tmp_extruder);
  12527          
  12528                        // STEP 6
  12529                        current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
  12530                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12531                        current_position[X_AXIS] = grabpos;
  12532                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12533                          SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
  12534                          if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
  12535                        #endif
  12536                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
  12537                        stepper.synchronize();
  12538          
  12539                        // Step 7
  12540                        current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
  12541                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12542                          SERIAL_ECHOLNPGM("(7) Move midway between hotends");
  12543                          if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
  12544                        #endif
  12545                        planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
  12546                        stepper.synchronize();
  12547                        #if ENABLED(DEBUG_LEVELING_FEATURE)
  12548                          SERIAL_ECHOLNPGM("Autopark done.");
  12549                        #endif
  12550                      }
  12551                      else { // nomove == true
  12552                        // Only engage magnetic field for new extruder
  12553                        pe_activate_magnet(tmp_extruder);
  12554                        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  12555                          pe_activate_magnet(active_extruder); // Just save power for inverted magnets
  12556                        #endif
  12557                      }
  12558                      current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
  12559          
  12560                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12561                        if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
  12562                      #endif
  12563          
  12564                    #endif // dualParking extruder
  12565          
  12566                    #if ENABLED(SWITCHING_NOZZLE)
  12567                      #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
  12568                      // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
  12569                      const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
  12570                                  z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
  12571          
  12572                      // Always raise by some amount (destination copied from current_position earlier)
  12573                      current_position[Z_AXIS] += z_raise;
  12574                      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
  12575                      move_nozzle_servo(tmp_extruder);
  12576                    #endif
  12577          
  12578                    /**
  12579                     * Set current_position to the position of the new nozzle.
  12580                     * Offsets are based on linear distance, so we need to get
  12581                     * the resulting position in coordinate space.
  12582                     *
  12583                     * - With grid or 3-point leveling, offset XYZ by a tilted vector
  12584                     * - With mesh leveling, update Z for the new position
  12585                     * - Otherwise, just use the raw linear distance
  12586                     *
  12587                     * Software endstops are altered here too. Consider a case where:
  12588                     *   E0 at X=0 ... E1 at X=10
  12589                     * When we switch to E1 now X=10, but E1 can't move left.
  12590                     * To express this we apply the change in XY to the software endstops.
  12591                     * E1 can move farther right than E0, so the right limit is extended.
  12592                     *
  12593                     * Note that we don't adjust the Z software endstops. Why not?
  12594                     * Consider a case where Z=0 (here) and switching to E1 makes Z=1
  12595                     * because the bed is 1mm lower at the new position. As long as
  12596                     * the first nozzle is out of the way, the carriage should be
  12597                     * allowed to move 1mm lower. This technically "breaks" the
  12598                     * Z software endstop. But this is technically correct (and
  12599                     * there is no viable alternative).
  12600                     */
  12601                    //#if ABL_PLANAR
  12602                    float xydiff[2]={0};
   \   00000060   0xF04F 0x0800      MOV      R8,#+0
   \   00000064   0x46C1             MOV      R9,R8
   \   00000066   0x.... 0x....      LDR.W    R7,??DataTable160_1
   \   0000006A   0x.... 0x....      LDR.W    R0,??DataTable158
   \   0000006E   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000072   0x2106             MOVS     R1,#+6
   \   00000074   0x4208             TST      R0,R1
   \   00000076   0xD045             BEQ.N    ??tool_change_8
  12603          		  if(BED_LEVELING_METHOD&ABL_PLANAR)
  12604          		  	{
  12605                      // Offset extruder, make sure to apply the bed level rotation matrix
  12606                      vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
  12607                                                         hotend_offset[Y_AXIS][tmp_extruder],
  12608                                                         0),
   \   00000078   0x.... 0x....      LDR.W    R9,??DataTable160_2
   \   0000007C   0x4643             MOV      R3,R8
   \   0000007E   0xEB09 0x008A      ADD      R0,R9,R10, LSL #+2
   \   00000082   0x6882             LDR      R2,[R0, #+8]
   \   00000084   0xF859 0x102A      LDR      R1,[R9, R10, LSL #+2]
   \   00000088   0xA80D             ADD      R0,SP,#+52
   \   0000008A   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   0000008E   0x78E0             LDRB     R0,[R4, #+3]
   \   00000090   0x4643             MOV      R3,R8
   \   00000092   0xEB09 0x0180      ADD      R1,R9,R0, LSL #+2
   \   00000096   0x688A             LDR      R2,[R1, #+8]
   \   00000098   0xF859 0x1020      LDR      R1,[R9, R0, LSL #+2]
   \   0000009C   0xA80A             ADD      R0,SP,#+40
  12609                               act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
  12610                                                         hotend_offset[Y_AXIS][active_extruder],
  12611                                                         0),
   \   0000009E   0x.... 0x....      BL       _ZN8vector_3C1Efff
   \   000000A2   0xA80A             ADD      R0,SP,#+40
   \   000000A4   0xB082             SUB      SP,SP,#+8
   \   000000A6   0x4669             MOV      R1,SP
   \   000000A8   0xC80C             LDM      R0!,{R2,R3}
   \   000000AA   0xC10C             STM      R1!,{R2,R3}
   \   000000AC   0x6802             LDR      R2,[R0, #0]
   \   000000AE   0x600A             STR      R2,[R1, #+0]
   \   000000B0   0xBC0C             POP      {R2,R3}
   \   000000B2   0xA90D             ADD      R1,SP,#+52
   \   000000B4   0xA801             ADD      R0,SP,#+4
   \   000000B6   0x.... 0x....      BL       _ZN8vector_3miES_
  12612                               offset_vec = tmp_offset_vec - act_offset_vec;
   \   000000BA   0xA807             ADD      R0,SP,#+28
   \   000000BC   0xA901             ADD      R1,SP,#+4
   \   000000BE   0xE8B1 0x100C      LDM      R1!,{R2,R3,R12}
   \   000000C2   0xE8A0 0x100C      STM      R0!,{R2,R3,R12}
  12613          
  12614                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12615                        if (DEBUGGING(LEVELING)) {
  12616                          tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
  12617                          act_offset_vec.debug(PSTR("act_offset_vec"));
  12618                          offset_vec.debug(PSTR("offset_vec (BEFORE)"));
  12619                        }
  12620                      #endif
  12621          
  12622                      offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
   \   000000C6   0x.... 0x....      LDR.W    R1,??DataTable160_3
   \   000000CA   0xB083             SUB      SP,SP,#+12
   \   000000CC   0x4668             MOV      R0,SP
   \   000000CE   0x2224             MOVS     R2,#+36
   \   000000D0   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000D4   0xBC0E             POP      {R1-R3}
   \   000000D6   0xA810             ADD      R0,SP,#+64
   \   000000D8   0x.... 0x....      BL       _ZN10matrix_3x39transposeES_
   \   000000DC   0xA910             ADD      R1,SP,#+64
   \   000000DE   0xB083             SUB      SP,SP,#+12
   \   000000E0   0x4668             MOV      R0,SP
   \   000000E2   0x2224             MOVS     R2,#+36
   \   000000E4   0x.... 0x....      BL       __aeabi_memcpy4
   \   000000E8   0xBC0E             POP      {R1-R3}
   \   000000EA   0xA807             ADD      R0,SP,#+28
   \   000000EC   0x.... 0x....      BL       _ZN8vector_314apply_rotationE10matrix_3x3
  12623          
  12624                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  12625                        if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
  12626                      #endif
  12627          
  12628                      // Adjustments to the current position
  12629                      //const float xydiff[2] = { offset_vec.x, offset_vec.y };
  12630          			xydiff[0] = offset_vec.x;
   \   000000F0   0xF8DD 0x801C      LDR      R8,[SP, #+28]
  12631          			xydiff[1] = offset_vec.y;
   \   000000F4   0xF8DD 0x9020      LDR      R9,[SP, #+32]
  12632                      current_position[Z_AXIS] += offset_vec.z;
   \   000000F8   0x6921             LDR      R1,[R4, #+16]
   \   000000FA   0x9809             LDR      R0,[SP, #+36]
   \   000000FC   0x.... 0x....      BL       __aeabi_fadd
   \   00000100   0x6120             STR      R0,[R4, #+16]
   \   00000102   0xE043             B.N      ??tool_change_9
  12633          		  }
  12634                    //#else // !ABL_PLANAR
  12635          			else
  12636          			{
  12637          				/*
  12638                      		const float xydiff[2] = {
  12639                        			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
  12640                       	 		hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
  12641                      		};*/
  12642                      if(gCfgItems.breakpoint_flg!=1)
   \                     ??tool_change_8: (+1)
   \   00000104   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   00000108   0x2801             CMP      R0,#+1
   \   0000010A   0xD013             BEQ.N    ??tool_change_10
   \   0000010C   0xF894 0xB003      LDRB     R11,[R4, #+3]
   \   00000110   0x.... 0x....      LDR.W    R9,??DataTable160_2
   \   00000114   0xF859 0x002A      LDR      R0,[R9, R10, LSL #+2]
   \   00000118   0xF859 0x102B      LDR      R1,[R9, R11, LSL #+2]
   \   0000011C   0x.... 0x....      BL       __aeabi_fsub
   \   00000120   0x4680             MOV      R8,R0
  12643                      {
  12644          			    xydiff[0] = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
  12645          			    xydiff[1] = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
   \   00000122   0xEB09 0x008A      ADD      R0,R9,R10, LSL #+2
   \   00000126   0x6880             LDR      R0,[R0, #+8]
   \   00000128   0xEB09 0x018B      ADD      R1,R9,R11, LSL #+2
   \   0000012C   0x6889             LDR      R1,[R1, #+8]
   \   0000012E   0x.... 0x....      BL       __aeabi_fsub
   \   00000132   0x4681             MOV      R9,R0
  12646                      }
  12647          				
  12648                      //#if ENABLED(MESH_BED_LEVELING)
  12649          			if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??tool_change_10: (+1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable158
   \   00000138   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   0000013C   0x2820             CMP      R0,#+32
   \   0000013E   0xD125             BNE.N    ??tool_change_9
  12650          			{
  12651                        if (planner.leveling_active) {
   \   00000140   0x.... 0x....      LDR.W    R0,??DataTable160_4
   \   00000144   0x7800             LDRB     R0,[R0, #+0]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD020             BEQ.N    ??tool_change_9
  12652                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  12653                            if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
  12654                          #endif
  12655                          float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
   \   0000014A   0x68A0             LDR      R0,[R4, #+8]
   \   0000014C   0x4641             MOV      R1,R8
   \   0000014E   0x.... 0x....      BL       __aeabi_fadd
   \   00000152   0x9003             STR      R0,[SP, #+12]
  12656                                y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
   \   00000154   0x68E0             LDR      R0,[R4, #+12]
   \   00000156   0x4649             MOV      R1,R9
   \   00000158   0x.... 0x....      BL       __aeabi_fadd
   \   0000015C   0x9002             STR      R0,[SP, #+8]
  12657                                z1 = current_position[Z_AXIS], z2 = z1;
   \   0000015E   0x6920             LDR      R0,[R4, #+16]
   \   00000160   0x9000             STR      R0,[SP, #+0]
   \   00000162   0x9001             STR      R0,[SP, #+4]
  12658                          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
   \   00000164   0xAA00             ADD      R2,SP,#+0
   \   00000166   0xF104 0x010C      ADD      R1,R4,#+12
   \   0000016A   0xF104 0x0008      ADD      R0,R4,#+8
   \   0000016E   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
  12659                          planner.apply_leveling(x2, y2, z2);
   \   00000172   0xAA01             ADD      R2,SP,#+4
   \   00000174   0xA902             ADD      R1,SP,#+8
   \   00000176   0xA803             ADD      R0,SP,#+12
   \   00000178   0x.... 0x....      BL       _ZN7Planner14apply_levelingERfS0_S0_
  12660                          current_position[Z_AXIS] += z2 - z1;
   \   0000017C   0x9801             LDR      R0,[SP, #+4]
   \   0000017E   0x9900             LDR      R1,[SP, #+0]
   \   00000180   0x.... 0x....      BL       __aeabi_fsub
   \   00000184   0x6921             LDR      R1,[R4, #+16]
   \   00000186   0x.... 0x....      BL       __aeabi_fadd
   \   0000018A   0x6120             STR      R0,[R4, #+16]
  12661                          #if ENABLED(DEBUG_LEVELING_FEATURE)
  12662                            if (DEBUGGING(LEVELING))
  12663                              SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
  12664                          #endif
  12665                        }
  12666          			}
  12667                      //#endif // MESH_BED_LEVELING
  12668          				}
  12669                    //#endif // !HAS_ABL
  12670          
  12671                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12672                      if (DEBUGGING(LEVELING)) {
  12673                        SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
  12674                        SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
  12675                        SERIAL_ECHOLNPGM(" }");
  12676                      }
  12677                    #endif
  12678          
  12679                    // The newly-selected extruder XY is actually at...
  12680                    if(gCfgItems.breakpoint_flg!=1)
   \                     ??tool_change_9: (+1)
   \   0000018C   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   00000190   0x2801             CMP      R0,#+1
   \   00000192   0xD009             BEQ.N    ??tool_change_11
  12681                    {
  12682                      current_position[X_AXIS] += xydiff[X_AXIS];
   \   00000194   0x68A0             LDR      R0,[R4, #+8]
   \   00000196   0x4641             MOV      R1,R8
   \   00000198   0x.... 0x....      BL       __aeabi_fadd
   \   0000019C   0x60A0             STR      R0,[R4, #+8]
  12683                      current_position[Y_AXIS] += xydiff[Y_AXIS];
   \   0000019E   0x68E0             LDR      R0,[R4, #+12]
   \   000001A0   0x4649             MOV      R1,R9
   \   000001A2   0x.... 0x....      BL       __aeabi_fadd
   \   000001A6   0x60E0             STR      R0,[R4, #+12]
  12684                    }
  12685                    // Set the new active extruder
  12686                    active_extruder = tmp_extruder;
   \                     ??tool_change_11: (+1)
   \   000001A8   0x70E6             STRB     R6,[R4, #+3]
  12687          
  12688                  #endif // !DUAL_X_CARRIAGE
  12689          
  12690                  #if ENABLED(DEBUG_LEVELING_FEATURE)
  12691                    if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
  12692                  #endif
  12693          
  12694                  // Tell the planner the new "current position"
  12695                  if(gCfgItems.breakpoint_flg!=1)
   \   000001AA   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   000001AE   0x2801             CMP      R0,#+1
   \   000001B0   0xD001             BEQ.N    ??tool_change_12
  12696                      SYNC_PLAN_POSITION_KINEMATIC();
   \   000001B2   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
  12697          
  12698                  // Move to the "old position" (move the extruder into place)
  12699                  #if ENABLED(SWITCHING_NOZZLE)
  12700                    destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
  12701                  #endif
  12702                  if (!no_move && IsRunning()) {
   \                     ??tool_change_12: (+1)
   \   000001B6   0x2D00             CMP      R5,#+0
   \   000001B8   0xD112             BNE.N    ??tool_change_6
   \   000001BA   0x.... 0x....      BL       _Z9IsRunningv
   \   000001BE   0x2800             CMP      R0,#+0
   \   000001C0   0xD00E             BEQ.N    ??tool_change_6
  12703                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  12704                      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
  12705                    #endif
  12706                    // Move back to the original (or tweaked) position
  12707                    if(gCfgItems.breakpoint_flg!=1)
   \   000001C2   0xF897 0x0155      LDRB     R0,[R7, #+341]
   \   000001C6   0x2801             CMP      R0,#+1
   \   000001C8   0xD00A             BEQ.N    ??tool_change_6
  12708                      do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
   \   000001CA   0x2000             MOVS     R0,#+0
   \   000001CC   0x9000             STR      R0,[SP, #+0]
   \   000001CE   0xAB00             ADD      R3,SP,#+0
   \   000001D0   0xF104 0x0220      ADD      R2,R4,#+32
   \   000001D4   0xF104 0x011C      ADD      R1,R4,#+28
   \   000001D8   0xF104 0x0018      ADD      R0,R4,#+24
   \   000001DC   0x.... 0x....      BL       _Z19do_blocking_move_toRKfS0_S0_S0_
  12709                  }
  12710                  #if ENABLED(SWITCHING_NOZZLE)
  12711                    else {
  12712                      // Move back down. (Including when the new tool is higher.)
  12713                      do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
  12714                    }
  12715                  #endif
  12716                } // (tmp_extruder != active_extruder)
  12717          
  12718                stepper.synchronize();
   \                     ??tool_change_6: (+1)
   \   000001E0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
  12719          
  12720                #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
  12721                  disable_all_solenoids();
  12722                  enable_solenoid_on_active_extruder();
  12723                #endif // EXT_SOLENOID
  12724          
  12725                feedrate_mm_s = old_feedrate_mm_s;
   \   000001E4   0x9806             LDR      R0,[SP, #+24]
   \   000001E6   0x65E0             STR      R0,[R4, #+92]
  12726          
  12727              #else // HOTENDS <= 1
  12728          
  12729                UNUSED(fr_mm_s);
  12730                UNUSED(no_move);
  12731          
  12732                #if ENABLED(MK2_MULTIPLEXER)
  12733                  if (tmp_extruder >= E_STEPPERS)
  12734                    return invalid_extruder_error(tmp_extruder);
  12735          
  12736                  select_multiplexed_stepper(tmp_extruder);
  12737                #endif
  12738          
  12739                // Set the new active extruder
  12740                active_extruder = tmp_extruder;
  12741          
  12742              #endif // HOTENDS <= 1
  12743          
  12744              #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
  12745                stepper.synchronize();
  12746                move_extruder_servo(active_extruder);
  12747              #endif
  12748          
  12749              #if HAS_FANMUX
  12750                fanmux_switch(active_extruder);
  12751              #endif
  12752          
  12753              SERIAL_ECHO_START();
   \   000001E8   0x....             LDR.N    R0,??DataTable155_8
   \   000001EA   0x.... 0x....      BL       _Z14serialprintPGMPKc
  12754              SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
   \   000001EE   0x78E1             LDRB     R1,[R4, #+3]
   \   000001F0   0x.... 0x....      ADR.W    R0,`?<Constant "Active Extruder: ">`
   \   000001F4   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   000001F8   0x210A             MOVS     R1,#+10
   \   000001FA   0x.... 0x....      LDR.W    R0,??DataTable161
   \   000001FE   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  12755          
  12756            #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
  12757          }
   \                     ??tool_change_1: (+1)
   \   00000202   0xB019             ADD      SP,SP,#+100
   \   00000204   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  12758          
  12759          /**
  12760           * T0-T3: Switch tool, usually switching extruders
  12761           *
  12762           *   F[units/min] Set the movement feedrate
  12763           *   S1           Don't move the tool in XY after change
  12764           */

   \                                 In section .text, align 4
  12765          inline void gcode_T(const uint8_t tmp_extruder) {
   \                     _Z7gcode_Th: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  12766          
  12767            #if ENABLED(DEBUG_LEVELING_FEATURE)
  12768              if (DEBUGGING(LEVELING)) {
  12769                SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
  12770                SERIAL_CHAR(')');
  12771                SERIAL_EOL();
  12772                DEBUG_POS("BEFORE", current_position);
  12773              }
  12774            #endif
  12775          
  12776            #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
  12777          
  12778              tool_change(tmp_extruder);
  12779          
  12780            #elif HOTENDS > 1
  12781          
  12782              tool_change(
  12783                tmp_extruder,
  12784                MMM_TO_MMS(parser.linearval('F')),
  12785                (tmp_extruder == active_extruder) || parser.boolval('S')
  12786              );
   \   00000004   0x480B             LDR.N    R0,??gcode_T_0
   \   00000006   0x78C0             LDRB     R0,[R0, #+3]
   \   00000008   0x4284             CMP      R4,R0
   \   0000000A   0xD004             BEQ.N    ??gcode_T_1
   \   0000000C   0x2053             MOVS     R0,#+83
   \   0000000E   0x.... 0x....      BL       _ZN11GCodeParser7boolvalEc
   \   00000012   0x4605             MOV      R5,R0
   \   00000014   0xE000             B.N      ??gcode_T_2
   \                     ??gcode_T_1: (+1)
   \   00000016   0x2501             MOVS     R5,#+1
   \                     ??gcode_T_2: (+1)
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x2046             MOVS     R0,#+70
   \   0000001C   0x.... 0x....      BL       _ZN11GCodeParser9linearvalEcf
   \   00000020   0x4905             LDR.N    R1,??gcode_T_0+0x4  ;; 0x42700000
   \   00000022   0x.... 0x....      BL       __aeabi_fdiv
   \   00000026   0x4601             MOV      R1,R0
   \   00000028   0x462A             MOV      R2,R5
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000030   0x.... 0x....      B.W      _Z11tool_changehfb
   \                     ??gcode_T_0:
   \   00000034   0x........         DC32     mks_heating_busy
   \   00000038   0x42700000         DC32     0x42700000
  12787          
  12788            #endif
  12789          
  12790            #if ENABLED(DEBUG_LEVELING_FEATURE)
  12791              if (DEBUGGING(LEVELING)) {
  12792                DEBUG_POS("AFTER", current_position);
  12793                SERIAL_ECHOLNPGM("<<< gcode_T");
  12794              }
  12795            #endif
  12796          }
  12797          
  12798          /**
  12799           * Process the parsed command and dispatch it to its handler
  12800           */

   \                                 In section .text, align 2, keep-with-next
  12801          void process_parsed_command() {
   \                     _Z22process_parsed_commandv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  12802            KEEPALIVE_STATE(IN_HANDLER);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable161_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x71A0             STRB     R0,[R4, #+6]
  12803          
  12804            // Handle a known G, M, or T
  12805            switch (parser.command_letter) {
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable160_5
   \   0000000E   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000012   0x2847             CMP      R0,#+71
   \   00000014   0xD006             BEQ.N    ??process_parsed_command_0
   \   00000016   0x284D             CMP      R0,#+77
   \   00000018   0xF000 0x80B3      BEQ.W    ??process_parsed_command_1
   \   0000001C   0x2854             CMP      R0,#+84
   \   0000001E   0xF000 0x8375      BEQ.W    ??process_parsed_command_2
   \   00000022   0xE37A             B.N      ??process_parsed_command_3
  12806              case 'G': switch (parser.codenum) {
   \                     ??process_parsed_command_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable161_2
   \   00000028   0x6800             LDR      R0,[R0, #+0]
   \   0000002A   0x0001             MOVS     R1,R0
   \   0000002C   0xD01D             BEQ.N    ??process_parsed_command_4
   \   0000002E   0x2901             CMP      R1,#+1
   \   00000030   0xD01B             BEQ.N    ??process_parsed_command_4
   \   00000032   0x2902             CMP      R1,#+2
   \   00000034   0xD029             BEQ.N    ??process_parsed_command_5
   \   00000036   0x2903             CMP      R1,#+3
   \   00000038   0xD027             BEQ.N    ??process_parsed_command_5
   \   0000003A   0x2904             CMP      R1,#+4
   \   0000003C   0xD02D             BEQ.N    ??process_parsed_command_6
   \   0000003E   0x291A             CMP      R1,#+26
   \   00000040   0xD02E             BEQ.N    ??process_parsed_command_7
   \   00000042   0x291C             CMP      R1,#+28
   \   00000044   0xD035             BEQ.N    ??process_parsed_command_8
   \   00000046   0x291D             CMP      R1,#+29
   \   00000048   0xD061             BEQ.N    ??process_parsed_command_9
   \   0000004A   0x291E             CMP      R1,#+30
   \   0000004C   0xF000 0x808A      BEQ.W    ??process_parsed_command_10
   \   00000050   0x292A             CMP      R1,#+42
   \   00000052   0xF000 0x8093      BEQ.W    ??process_parsed_command_11
   \   00000056   0x295A             CMP      R1,#+90
   \   00000058   0xF000 0x8087      BEQ.W    ??process_parsed_command_12
   \   0000005C   0x295B             CMP      R1,#+91
   \   0000005E   0xF000 0x8087      BEQ.W    ??process_parsed_command_13
   \   00000062   0x295C             CMP      R1,#+92
   \   00000064   0xF000 0x8087      BEQ.W    ??process_parsed_command_14
   \   00000068   0xE35B             B.N      ??process_parsed_command_15
  12807          
  12808                // G0, G1
  12809                case 0:
  12810                case 1:
  12811                  //#if IS_SCARA
  12812                  if(MACHINETPYE&IS_SCARA)
   \                     ??process_parsed_command_4: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R1,??DataTable161_3
   \   0000006E   0x8C89             LDRH     R1,[R1, #+36]
   \   00000070   0xF44F 0x7240      MOV      R2,#+768
   \   00000074   0x4211             TST      R1,R2
   \   00000076   0xD005             BEQ.N    ??process_parsed_command_16
  12813                    gcode_G0_G1_SCARA(parser.codenum == 0);
   \   00000078   0x1E40             SUBS     R0,R0,#+1
   \   0000007A   0x4180             SBCS     R0,R0,R0
   \   0000007C   0x0FC0             LSRS     R0,R0,#+31
   \   0000007E   0x.... 0x....      BL       _Z17gcode_G0_G1_SCARAb
   \   00000082   0xE34E             B.N      ??process_parsed_command_15
  12814                  //#else
  12815                  else
  12816                    gcode_G0_G1();
   \                     ??process_parsed_command_16: (+1)
   \   00000084   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000088   0xE34B             B.N      ??process_parsed_command_15
  12817                  //#endif
  12818                  break;
  12819          
  12820                // G2, G3
  12821                #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
  12822                  case 2: // G2: CW ARC
  12823                  case 3: // G3: CCW ARC
  12824                    gcode_G2_G3(parser.codenum == 2);
   \                     ??process_parsed_command_5: (+1)
   \   0000008A   0x2802             CMP      R0,#+2
   \   0000008C   0xD101             BNE.N    ??process_parsed_command_17
   \   0000008E   0x2001             MOVS     R0,#+1
   \   00000090   0xE000             B.N      ??process_parsed_command_18
   \                     ??process_parsed_command_17: (+1)
   \   00000092   0x2000             MOVS     R0,#+0
   \                     ??process_parsed_command_18: (+1)
   \   00000094   0x.... 0x....      BL       _Z11gcode_G2_G3b
  12825                    break;
   \   00000098   0xE343             B.N      ??process_parsed_command_15
  12826                #endif
  12827          
  12828                // G4 Dwell
  12829                case 4:
  12830                  gcode_G4();
   \                     ??process_parsed_command_6: (+1)
   \   0000009A   0x.... 0x....      BL       _Z8gcode_G4v
  12831                  break;
   \   0000009E   0xE340             B.N      ??process_parsed_command_15
  12832          
  12833                #if ENABLED(BEZIER_CURVE_SUPPORT)
  12834                  case 5: // G5: Cubic B_spline
  12835                    gcode_G5();
  12836                    break;
  12837                #endif // BEZIER_CURVE_SUPPORT
  12838          
  12839                #if ENABLED(FWRETRACT)
  12840                  case 10: // G10: retract
  12841                    gcode_G10();
  12842                    break;
  12843                  case 11: // G11: retract_recover
  12844                    gcode_G11();
  12845                    break;
  12846                #endif // FWRETRACT
  12847          
  12848                #if ENABLED(NOZZLE_CLEAN_FEATURE)
  12849                  case 12:
  12850                    gcode_G12(); // G12: Nozzle Clean
  12851                    break;
  12852                #endif // NOZZLE_CLEAN_FEATURE
  12853          
  12854                #if ENABLED(CNC_WORKSPACE_PLANES)
  12855                  case 17: // G17: Select Plane XY
  12856                    gcode_G17();
  12857                    break;
  12858                  case 18: // G18: Select Plane ZX
  12859                    gcode_G18();
  12860                    break;
  12861                  case 19: // G19: Select Plane YZ
  12862                    gcode_G19();
  12863                    break;
  12864                #endif // CNC_WORKSPACE_PLANES
  12865          
  12866                #if ENABLED(INCH_MODE_SUPPORT)
  12867                  case 20: // G20: Inch Mode
  12868                    gcode_G20();
  12869                    break;
  12870          
  12871                  case 21: // G21: MM Mode
  12872                    gcode_G21();
  12873                    break;
  12874                #endif // INCH_MODE_SUPPORT
  12875          
  12876                //#if ENABLED(G26_MESH_VALIDATION)
  12877                  case 26: // G26: Mesh Validation Pattern generation
  12878                  if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   \                     ??process_parsed_command_7: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   000000A4   0x7B00             LDRB     R0,[R0, #+12]
   \   000000A6   0x06C0             LSLS     R0,R0,#+27
   \   000000A8   0xF140 0x833B      BPL.W    ??process_parsed_command_15
  12879                    gcode_G26();
   \   000000AC   0x.... 0x....      BL       _Z9gcode_G26v
   \   000000B0   0xE337             B.N      ??process_parsed_command_15
  12880                    break;
  12881                //#endif // G26_MESH_VALIDATION
  12882          
  12883                #if ENABLED(NOZZLE_PARK_FEATURE)
  12884                  case 27: // G27: Nozzle Park
  12885                    gcode_G27();
  12886                    break;
  12887                #endif // NOZZLE_PARK_FEATURE
  12888          
  12889                case 28: // G28: Home all axes, one at a time
  12890                  #if 1
  12891                	if (gCfgItems.breakpoint_reprint_flg == 1) break;
   \                     ??process_parsed_command_8: (+1)
   \   000000B2   0x.... 0x....      LDR.W    R0,??DataTable160_1
   \   000000B6   0xF890 0x0148      LDRB     R0,[R0, #+328]
   \   000000BA   0x2801             CMP      R0,#+1
   \   000000BC   0xF000 0x8331      BEQ.W    ??process_parsed_command_15
  12892                  #endif
  12893                  gcode_G28(false);
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       _Z9gcode_G28b
  12894          		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
   \   000000C6   0x.... 0x....      LDR.W    R0,??DataTable158
   \   000000CA   0xF100 0x0534      ADD      R5,R0,#+52
   \   000000CE   0x7B28             LDRB     R0,[R5, #+12]
   \   000000D0   0x213E             MOVS     R1,#+62
   \   000000D2   0x4208             TST      R0,R1
   \   000000D4   0xF000 0x8325      BEQ.W    ??process_parsed_command_15
   \   000000D8   0x2810             CMP      R0,#+16
   \   000000DA   0xF000 0x8322      BEQ.W    ??process_parsed_command_15
  12895          		{
  12896          			 set_bed_leveling_enabled(true);
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
  12897          			#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
  12898          				if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
   \   000000E4   0xF9B5 0x0024      LDRSH    R0,[R5, #+36]
   \   000000E8   0x2802             CMP      R0,#+2
   \   000000EA   0xF000 0x831A      BEQ.W    ??process_parsed_command_15
   \   000000EE   0x7B28             LDRB     R0,[R5, #+12]
   \   000000F0   0x06C0             LSLS     R0,R0,#+27
   \   000000F2   0xF140 0x8316      BPL.W    ??process_parsed_command_15
  12899          				 { 
  12900          				 	if (parser.seenval('Z')) set_z_fade_height(parser.value_linear_units()/*code_value_linear_units()*/);
   \   000000F6   0x205A             MOVS     R0,#+90
   \   000000F8   0x.... 0x....      BL       _ZN11GCodeParser7seenvalEc
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xF000 0x8310      BEQ.W    ??process_parsed_command_15
   \   00000102   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   00000106   0x2101             MOVS     R1,#+1
   \   00000108   0x.... 0x....      BL       _Z17set_z_fade_heightfb
   \   0000010C   0xE309             B.N      ??process_parsed_command_15
  12901          				 }
  12902          			#endif
  12903                    }
  12904                  break;
  12905          
  12906                //#if HAS_LEVELING
  12907                  case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
  12908                           // or provides access to the UBL System if enabled.
  12909          		if(BED_LEVELING_METHOD&HAS_LEVELING)	 
   \                     ??process_parsed_command_9: (+1)
   \   0000010E   0x.... 0x....      LDR.W    R0,??DataTable158
   \   00000112   0xF100 0x0534      ADD      R5,R0,#+52
   \   00000116   0x7B28             LDRB     R0,[R5, #+12]
   \   00000118   0x213E             MOVS     R1,#+62
   \   0000011A   0x4208             TST      R0,R1
   \   0000011C   0xD016             BEQ.N    ??process_parsed_command_19
  12910          		{
  12911          			switch(BED_LEVELING_METHOD)	 /*--mks cfg-- MESH_BED_LEVELING */ 
   \   0000011E   0x2802             CMP      R0,#+2
   \   00000120   0xD00C             BEQ.N    ??process_parsed_command_20
   \   00000122   0x2804             CMP      R0,#+4
   \   00000124   0xD00A             BEQ.N    ??process_parsed_command_20
   \   00000126   0x2808             CMP      R0,#+8
   \   00000128   0xD008             BEQ.N    ??process_parsed_command_20
   \   0000012A   0x2810             CMP      R0,#+16
   \   0000012C   0xD00B             BEQ.N    ??process_parsed_command_21
   \   0000012E   0x2820             CMP      R0,#+32
   \   00000130   0xD10C             BNE.N    ??process_parsed_command_19
  12912          			{
  12913          				case MESH_BED_LEVELING:
  12914          					gcode_G29_MESH_BED_LEVELING();
   \   00000132   0x.... 0x....      BL       _Z27gcode_G29_MESH_BED_LEVELINGv
  12915          					(void)settings.save();
   \   00000136   0x.... 0x....      BL       _ZN14MarlinSettings4saveEv
  12916          				break;
   \   0000013A   0xE2F2             B.N      ??process_parsed_command_15
  12917          				case AUTO_BED_LEVELING_3POINT:
  12918          				case AUTO_BED_LEVELING_LINEAR:
  12919          				case AUTO_BED_LEVELING_BILINEAR:
  12920          					gcode_G29();
   \                     ??process_parsed_command_20: (+1)
   \   0000013C   0x.... 0x....      BL       _Z9gcode_G29v
  12921          					(void)settings.save();
   \   00000140   0x.... 0x....      BL       _ZN14MarlinSettings4saveEv
  12922          				break;
   \   00000144   0xE2ED             B.N      ??process_parsed_command_15
  12923          				case AUTO_BED_LEVELING_UBL:
  12924          					gcode_G29_UBL();
   \                     ??process_parsed_command_21: (+1)
   \   00000146   0x.... 0x....      BL       _Z13gcode_G29_UBLv
  12925          				break;
   \   0000014A   0xE2EA             B.N      ??process_parsed_command_15
  12926          				default:
  12927          					SERIAL_PROTOCOL("bed leveling hasn't defined!");
  12928          					SERIAL_EOL();
  12929          				break;
  12930          			}
  12931          		}
  12932          		else
  12933          		{
  12934          			SERIAL_PROTOCOL("bed leveling hasn't defined!");
   \                     ??process_parsed_command_19: (+1)
   \   0000014C   0x.... 0x....      LDR.W    R5,??DataTable161
   \   00000150   0x.... 0x....      LDR.W    R1,??DataTable161_4
   \   00000154   0x4628             MOV      R0,R5
   \   00000156   0x.... 0x....      BL       _ZN5Print5printEPKc
  12935          			SERIAL_EOL();
   \   0000015A   0x210A             MOVS     R1,#+10
   \   0000015C   0x4628             MOV      R0,R5
   \   0000015E   0x.... 0x....      BL       _ZN10USARTClass5writeEh
   \   00000162   0xE2DE             B.N      ??process_parsed_command_15
  12936          		}
  12937          
  12938                  break;
  12939                //#endif // HAS_LEVELING
  12940          
  12941                #if HAS_BED_PROBE
  12942          
  12943                  case 30: // G30 Single Z probe
  12944                    gcode_G30();
   \                     ??process_parsed_command_10: (+1)
   \   00000164   0x.... 0x....      BL       _Z9gcode_G30v
  12945                    break;
   \   00000168   0xE2DB             B.N      ??process_parsed_command_15
  12946          
  12947                  #if ENABLED(Z_PROBE_SLED)
  12948          
  12949                      case 31: // G31: dock the sled
  12950                        gcode_G31();
  12951                        break;
  12952          
  12953                      case 32: // G32: undock the sled
  12954                        gcode_G32();
  12955                        break;
  12956          
  12957                  #endif // Z_PROBE_SLED
  12958          
  12959                #endif // HAS_BED_PROBE
  12960          
  12961                #if ENABLED(DELTA_AUTO_CALIBRATION)
  12962          
  12963                  case 33: // G33: Delta Auto-Calibration
  12964                    gcode_G33();
  12965                    break;
  12966          
  12967                #endif // DELTA_AUTO_CALIBRATION
  12968          
  12969                #if ENABLED(G38_PROBE_TARGET)
  12970                  case 38: // G38.2 & G38.3
  12971                    if (parser.subcode == 2 || parser.subcode == 3)
  12972                      gcode_G38(parser.subcode == 2);
  12973                    break;
  12974                #endif
  12975          
  12976                case 90: // G90
  12977                  relative_mode = false;
   \                     ??process_parsed_command_12: (+1)
   \   0000016A   0x2000             MOVS     R0,#+0
   \   0000016C   0x7160             STRB     R0,[R4, #+5]
  12978                  break;
   \   0000016E   0xE2D8             B.N      ??process_parsed_command_15
  12979                case 91: // G91
  12980                  relative_mode = true;
   \                     ??process_parsed_command_13: (+1)
   \   00000170   0x2001             MOVS     R0,#+1
   \   00000172   0x7160             STRB     R0,[R4, #+5]
  12981                  break;
   \   00000174   0xE2D5             B.N      ??process_parsed_command_15
  12982          
  12983                case 92: // G92
  12984                  gcode_G92();
   \                     ??process_parsed_command_14: (+1)
   \   00000176   0x.... 0x....      BL       _Z9gcode_G92v
  12985                  break;
   \   0000017A   0xE2D2             B.N      ??process_parsed_command_15
  12986          
  12987                #if HAS_MESH
  12988                  case 42:
  12989                    gcode_G42();
   \                     ??process_parsed_command_11: (+1)
   \   0000017C   0x.... 0x....      BL       _Z9gcode_G42v
  12990                    break;
   \   00000180   0xE2CF             B.N      ??process_parsed_command_15
  12991                #endif
  12992          
  12993                #if ENABLED(DEBUG_GCODE_PARSER)
  12994                  case 800:
  12995                    parser.debug(); // GCode Parser Test for G
  12996                    break;
  12997                #endif
  12998              }
  12999              break;
  13000          
  13001              case 'M': switch (parser.codenum) {
   \                     ??process_parsed_command_1: (+1)
   \   00000182   0x.... 0x....      LDR.W    R0,??DataTable161_2
   \   00000186   0x6800             LDR      R0,[R0, #+0]
   \   00000188   0x3811             SUBS     R0,R0,#+17
   \   0000018A   0xF000 0x80FC      BEQ.W    ??process_parsed_command_22
   \   0000018E   0x1E40             SUBS     R0,R0,#+1
   \   00000190   0xF000 0x81BB      BEQ.W    ??process_parsed_command_23
   \   00000194   0x1E80             SUBS     R0,R0,#+2
   \   00000196   0xF000 0x80F9      BEQ.W    ??process_parsed_command_24
   \   0000019A   0x1E40             SUBS     R0,R0,#+1
   \   0000019C   0x2801             CMP      R0,#+1
   \   0000019E   0xF240 0x80F8      BLS.W    ??process_parsed_command_25
   \   000001A2   0x1E80             SUBS     R0,R0,#+2
   \   000001A4   0xF000 0x80F8      BEQ.W    ??process_parsed_command_26
   \   000001A8   0x1E40             SUBS     R0,R0,#+1
   \   000001AA   0xF000 0x80F8      BEQ.W    ??process_parsed_command_27
   \   000001AE   0x1E40             SUBS     R0,R0,#+1
   \   000001B0   0xF000 0x810D      BEQ.W    ??process_parsed_command_28
   \   000001B4   0x1E40             SUBS     R0,R0,#+1
   \   000001B6   0xF000 0x8132      BEQ.W    ??process_parsed_command_29
   \   000001BA   0x1E40             SUBS     R0,R0,#+1
   \   000001BC   0xF000 0x8132      BEQ.W    ??process_parsed_command_30
   \   000001C0   0x1E40             SUBS     R0,R0,#+1
   \   000001C2   0xF000 0x8132      BEQ.W    ??process_parsed_command_31
   \   000001C6   0x1E40             SUBS     R0,R0,#+1
   \   000001C8   0xF000 0x8132      BEQ.W    ??process_parsed_command_32
   \   000001CC   0x1E40             SUBS     R0,R0,#+1
   \   000001CE   0xF000 0x8132      BEQ.W    ??process_parsed_command_33
   \   000001D2   0x1E40             SUBS     R0,R0,#+1
   \   000001D4   0xF000 0x8138      BEQ.W    ??process_parsed_command_34
   \   000001D8   0x1E40             SUBS     R0,R0,#+1
   \   000001DA   0xF000 0x812F      BEQ.W    ??process_parsed_command_35
   \   000001DE   0x380A             SUBS     R0,R0,#+10
   \   000001E0   0xF000 0x8135      BEQ.W    ??process_parsed_command_36
   \   000001E4   0x1FC0             SUBS     R0,R0,#+7
   \   000001E6   0xF000 0x8135      BEQ.W    ??process_parsed_command_37
   \   000001EA   0x381A             SUBS     R0,R0,#+26
   \   000001EC   0xF000 0x813B      BEQ.W    ??process_parsed_command_38
   \   000001F0   0x1E40             SUBS     R0,R0,#+1
   \   000001F2   0xF000 0x813B      BEQ.W    ??process_parsed_command_39
   \   000001F6   0x1E40             SUBS     R0,R0,#+1
   \   000001F8   0xF000 0x813B      BEQ.W    ??process_parsed_command_40
   \   000001FC   0x1F00             SUBS     R0,R0,#+4
   \   000001FE   0xF000 0x817B      BEQ.W    ??process_parsed_command_41
   \   00000202   0x1E40             SUBS     R0,R0,#+1
   \   00000204   0xF000 0x817B      BEQ.W    ??process_parsed_command_42
   \   00000208   0x1E40             SUBS     R0,R0,#+1
   \   0000020A   0xF000 0x817B      BEQ.W    ??process_parsed_command_43
   \   0000020E   0x1E40             SUBS     R0,R0,#+1
   \   00000210   0xF000 0x817B      BEQ.W    ??process_parsed_command_23
   \   00000214   0x1E40             SUBS     R0,R0,#+1
   \   00000216   0xF000 0x817B      BEQ.W    ??process_parsed_command_44
   \   0000021A   0x1FC0             SUBS     R0,R0,#+7
   \   0000021C   0xF000 0x817B      BEQ.W    ??process_parsed_command_45
   \   00000220   0x380C             SUBS     R0,R0,#+12
   \   00000222   0xF000 0x8129      BEQ.W    ??process_parsed_command_46
   \   00000226   0x1E40             SUBS     R0,R0,#+1
   \   00000228   0xF000 0x8148      BEQ.W    ??process_parsed_command_47
   \   0000022C   0x1E40             SUBS     R0,R0,#+1
   \   0000022E   0xF000 0x815D      BEQ.W    ??process_parsed_command_48
   \   00000232   0x1E40             SUBS     R0,R0,#+1
   \   00000234   0xF000 0x815D      BEQ.W    ??process_parsed_command_49
   \   00000238   0x1E40             SUBS     R0,R0,#+1
   \   0000023A   0xF000 0x8126      BEQ.W    ??process_parsed_command_50
   \   0000023E   0x1E40             SUBS     R0,R0,#+1
   \   00000240   0xF000 0x8144      BEQ.W    ??process_parsed_command_51
   \   00000244   0x1E40             SUBS     R0,R0,#+1
   \   00000246   0xF000 0x811A      BEQ.W    ??process_parsed_command_52
   \   0000024A   0x1E40             SUBS     R0,R0,#+1
   \   0000024C   0xF000 0x811A      BEQ.W    ??process_parsed_command_53
   \   00000250   0x1E40             SUBS     R0,R0,#+1
   \   00000252   0xF000 0x811D      BEQ.W    ??process_parsed_command_54
   \   00000256   0x1E40             SUBS     R0,R0,#+1
   \   00000258   0xF000 0x8120      BEQ.W    ??process_parsed_command_55
   \   0000025C   0x1E40             SUBS     R0,R0,#+1
   \   0000025E   0xF000 0x815D      BEQ.W    ??process_parsed_command_56
   \   00000262   0x1E40             SUBS     R0,R0,#+1
   \   00000264   0xF000 0x815D      BEQ.W    ??process_parsed_command_57
   \   00000268   0x1E80             SUBS     R0,R0,#+2
   \   0000026A   0xF000 0x815D      BEQ.W    ??process_parsed_command_58
   \   0000026E   0x1E40             SUBS     R0,R0,#+1
   \   00000270   0xF000 0x815D      BEQ.W    ??process_parsed_command_59
   \   00000274   0x1E40             SUBS     R0,R0,#+1
   \   00000276   0xF000 0x815D      BEQ.W    ??process_parsed_command_60
   \   0000027A   0x1E40             SUBS     R0,R0,#+1
   \   0000027C   0xF000 0x815D      BEQ.W    ??process_parsed_command_61
   \   00000280   0x1E40             SUBS     R0,R0,#+1
   \   00000282   0xF000 0x815D      BEQ.W    ??process_parsed_command_62
   \   00000286   0x3813             SUBS     R0,R0,#+19
   \   00000288   0xF000 0x810B      BEQ.W    ??process_parsed_command_63
   \   0000028C   0x380F             SUBS     R0,R0,#+15
   \   0000028E   0xF000 0x811A      BEQ.W    ??process_parsed_command_64
   \   00000292   0x3823             SUBS     R0,R0,#+35
   \   00000294   0xF000 0x811D      BEQ.W    ??process_parsed_command_65
   \   00000298   0x380A             SUBS     R0,R0,#+10
   \   0000029A   0xF000 0x8154      BEQ.W    ??process_parsed_command_66
   \   0000029E   0x1E40             SUBS     R0,R0,#+1
   \   000002A0   0xF000 0x8154      BEQ.W    ??process_parsed_command_67
   \   000002A4   0x1E80             SUBS     R0,R0,#+2
   \   000002A6   0xF000 0x8154      BEQ.W    ??process_parsed_command_68
   \   000002AA   0x1E40             SUBS     R0,R0,#+1
   \   000002AC   0xF000 0x8154      BEQ.W    ??process_parsed_command_69
   \   000002B0   0x1E40             SUBS     R0,R0,#+1
   \   000002B2   0xF000 0x8154      BEQ.W    ??process_parsed_command_70
   \   000002B6   0x1E40             SUBS     R0,R0,#+1
   \   000002B8   0xF000 0x8154      BEQ.W    ??process_parsed_command_71
   \   000002BC   0x1F40             SUBS     R0,R0,#+5
   \   000002BE   0xF000 0x8177      BEQ.W    ??process_parsed_command_72
   \   000002C2   0x1FC0             SUBS     R0,R0,#+7
   \   000002C4   0xF000 0x8177      BEQ.W    ??process_parsed_command_73
   \   000002C8   0x1E80             SUBS     R0,R0,#+2
   \   000002CA   0xF000 0x8177      BEQ.W    ??process_parsed_command_74
   \   000002CE   0x1E40             SUBS     R0,R0,#+1
   \   000002D0   0xF000 0x8177      BEQ.W    ??process_parsed_command_75
   \   000002D4   0x1F40             SUBS     R0,R0,#+5
   \   000002D6   0xF000 0x8177      BEQ.W    ??process_parsed_command_76
   \   000002DA   0x3836             SUBS     R0,R0,#+54
   \   000002DC   0xF000 0x8177      BEQ.W    ??process_parsed_command_77
   \   000002E0   0x3815             SUBS     R0,R0,#+21
   \   000002E2   0xF000 0x8177      BEQ.W    ??process_parsed_command_78
   \   000002E6   0x1E40             SUBS     R0,R0,#+1
   \   000002E8   0xF000 0x8186      BEQ.W    ??process_parsed_command_79
   \   000002EC   0x1E40             SUBS     R0,R0,#+1
   \   000002EE   0xF000 0x8186      BEQ.W    ??process_parsed_command_80
   \   000002F2   0x1E40             SUBS     R0,R0,#+1
   \   000002F4   0xF000 0x8177      BEQ.W    ??process_parsed_command_81
   \   000002F8   0x3833             SUBS     R0,R0,#+51
   \   000002FA   0xF000 0x8201      BEQ.W    ??process_parsed_command_82
   \   000002FE   0x1F40             SUBS     R0,R0,#+5
   \   00000300   0xF000 0x8180      BEQ.W    ??process_parsed_command_83
   \   00000304   0x1E40             SUBS     R0,R0,#+1
   \   00000306   0xF000 0x818B      BEQ.W    ??process_parsed_command_84
   \   0000030A   0x1E40             SUBS     R0,R0,#+1
   \   0000030C   0xF000 0x8194      BEQ.W    ??process_parsed_command_85
   \   00000310   0x1E40             SUBS     R0,R0,#+1
   \   00000312   0xF000 0x819D      BEQ.W    ??process_parsed_command_86
   \   00000316   0x1E40             SUBS     R0,R0,#+1
   \   00000318   0xF000 0x81A6      BEQ.W    ??process_parsed_command_87
   \   0000031C   0x3824             SUBS     R0,R0,#+36
   \   0000031E   0xF000 0x81AF      BEQ.W    ??process_parsed_command_88
   \   00000322   0x1E40             SUBS     R0,R0,#+1
   \   00000324   0xF000 0x81AF      BEQ.W    ??process_parsed_command_89
   \   00000328   0x1E40             SUBS     R0,R0,#+1
   \   0000032A   0xF000 0x81AF      BEQ.W    ??process_parsed_command_90
   \   0000032E   0x3808             SUBS     R0,R0,#+8
   \   00000330   0xF000 0x80B1      BEQ.W    ??process_parsed_command_91
   \   00000334   0x380A             SUBS     R0,R0,#+10
   \   00000336   0xF000 0x81AC      BEQ.W    ??process_parsed_command_92
   \   0000033A   0x1E40             SUBS     R0,R0,#+1
   \   0000033C   0xF000 0x81B2      BEQ.W    ??process_parsed_command_93
   \   00000340   0x1FC0             SUBS     R0,R0,#+7
   \   00000342   0xF000 0x81C2      BEQ.W    ??process_parsed_command_94
   \   00000346   0x3848             SUBS     R0,R0,#+72
   \   00000348   0xF000 0x81C8      BEQ.W    ??process_parsed_command_95
   \   0000034C   0x1E40             SUBS     R0,R0,#+1
   \   0000034E   0xF000 0x81C8      BEQ.W    ??process_parsed_command_96
   \   00000352   0x1E40             SUBS     R0,R0,#+1
   \   00000354   0xF000 0x81C8      BEQ.W    ??process_parsed_command_97
   \   00000358   0x1E40             SUBS     R0,R0,#+1
   \   0000035A   0xF000 0x81C8      BEQ.W    ??process_parsed_command_98
   \   0000035E   0x38A2             SUBS     R0,R0,#+162
   \   00000360   0xF000 0x810A      BEQ.W    ??process_parsed_command_99
   \   00000364   0x1E40             SUBS     R0,R0,#+1
   \   00000366   0xF000 0x8111      BEQ.W    ??process_parsed_command_100
   \   0000036A   0x38B9             SUBS     R0,R0,#+185
   \   0000036C   0xF000 0x81C2      BEQ.W    ??process_parsed_command_101
   \   00000370   0x3838             SUBS     R0,R0,#+56
   \   00000372   0xF000 0x81C2      BEQ.W    ??process_parsed_command_102
   \   00000376   0x3815             SUBS     R0,R0,#+21
   \   00000378   0xD063             BEQ.N    ??process_parsed_command_103
   \   0000037A   0x3846             SUBS     R0,R0,#+70
   \   0000037C   0xD04C             BEQ.N    ??process_parsed_command_104
   \   0000037E   0x1E40             SUBS     R0,R0,#+1
   \   00000380   0xF000 0x81C1      BEQ.W    ??process_parsed_command_105
   \   00000384   0xE1CD             B.N      ??process_parsed_command_15
  13002                #if HAS_RESUME_CONTINUE
  13003                  case 0: // M0: Unconditional stop - Wait for user button press on LCD
  13004                  case 1: // M1: Conditional stop - Wait for user button press on LCD
  13005                    gcode_M0_M1();
  13006                    break;
  13007                #endif // ULTIPANEL
  13008          
  13009                #if ENABLED(SPINDLE_LASER_ENABLE)
  13010                  case 3:
  13011                    gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
  13012                    break;               // synchronizes with movement commands
  13013                  case 4:
  13014                    gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
  13015                    break;               // synchronizes with movement commands
  13016                  case 5:
  13017                    gcode_M5();     // M5 - turn spindle/laser off
  13018                    break;          // synchronizes with movement commands
  13019                #endif
  13020                case 17: // M17: Enable all stepper motors
  13021                  gcode_M17();
   \                     ??process_parsed_command_22: (+1)
   \   00000386   0x.... 0x....      BL       _Z9gcode_M17v
  13022                  break;
   \   0000038A   0xE1CA             B.N      ??process_parsed_command_15
  13023          
  13024                #if ENABLED(SDSUPPORT)
  13025                  case 20: // M20: list SD card
  13026                    gcode_M20(); break;
   \                     ??process_parsed_command_24: (+1)
   \   0000038C   0x.... 0x....      BL       _Z9gcode_M20v
   \   00000390   0xE1C7             B.N      ??process_parsed_command_15
  13027                  case 21: // M21: init SD card
  13028                    //gcode_M21(); break;
  13029                  case 22: // M22: release SD card
  13030                    gcode_M22(); break;
   \                     ??process_parsed_command_25: (+1)
   \   00000392   0x.... 0x....      BL       _Z9gcode_M22v
   \   00000396   0xE1C4             B.N      ??process_parsed_command_15
  13031                  case 23: // M23: Select file
  13032                    gcode_M23(); break;
   \                     ??process_parsed_command_26: (+1)
   \   00000398   0x.... 0x....      BL       _Z9gcode_M23v
   \   0000039C   0xE1C1             B.N      ??process_parsed_command_15
  13033                  case 24: // M24: Start SD print
  13034                    gcode_M24(); 
   \                     ??process_parsed_command_27: (+1)
   \   0000039E   0x.... 0x....      BL       _Z9gcode_M24v
  13035          
  13036                    if(mksReprint.mks_printer_state == MKS_WORKING)
   \   000003A2   0x.... 0x....      LDR.W    R0,??DataTable163
   \   000003A6   0xF890 0x0AA0      LDRB     R0,[R0, #+2720]
   \   000003AA   0x28A7             CMP      R0,#+167
   \   000003AC   0xF040 0x81B9      BNE.W    ??process_parsed_command_15
  13037                    {
  13038                      clear_cur_ui();
   \   000003B0   0x.... 0x....      BL       clear_cur_ui
  13039                      reset_file_info();
   \   000003B4   0x.... 0x....      BL       reset_file_info
  13040                      reset_print_time();
   \   000003B8   0x.... 0x....      BL       reset_print_time
  13041                      start_print_time();
   \   000003BC   0x.... 0x....      BL       start_print_time
  13042                      #if defined(TFT35)
  13043                      preview_gcode_prehandle(curFileName);
   \   000003C0   0x.... 0x....      LDR.W    R0,??DataTable163_1
   \   000003C4   0x.... 0x....      BL       preview_gcode_prehandle
  13044                      #endif
  13045                      draw_printing();            
   \   000003C8   0x.... 0x....      BL       draw_printing
   \   000003CC   0xE1A9             B.N      ??process_parsed_command_15
  13046                     }
  13047                    break;
  13048                  case 25: // M25: Pause SD print
  13049                      gcode_M25(); 
   \                     ??process_parsed_command_28: (+1)
   \   000003CE   0x.... 0x....      BL       _Z9gcode_M25v
  13050                      if(mksReprint.mks_printer_state == MKS_PAUSING)
   \   000003D2   0x.... 0x....      LDR.W    R5,??DataTable163
   \   000003D6   0xF895 0x0AA0      LDRB     R0,[R5, #+2720]
   \   000003DA   0x28A9             CMP      R0,#+169
   \   000003DC   0xF040 0x81A1      BNE.W    ??process_parsed_command_15
  13051                      {
  13052                      	stop_print_time();							
   \   000003E0   0x.... 0x....      BL       stop_print_time
  13053                      	clear_cur_ui();
   \   000003E4   0x.... 0x....      BL       clear_cur_ui
  13054                      
  13055                      	card.pauseSDPrint();
   \   000003E8   0x4628             MOV      R0,R5
   \   000003EA   0x.... 0x....      BL       _ZN10CardReader12pauseSDPrintEv
  13056                      	print_job_timer.pause();
   \   000003EE   0xF605 0x506C      ADDW     R0,R5,#+3436
   \   000003F2   0x.... 0x....      BL       _ZN9Stopwatch5pauseEv
  13057          		#if defined(TFT35)
  13058                      	if(from_flash_pic==1)
   \   000003F6   0x.... 0x....      LDR.W    R0,??DataTable163_2
   \   000003FA   0x7800             LDRB     R0,[R0, #+0]
   \   000003FC   0x2801             CMP      R0,#+1
   \   000003FE   0xD104             BNE.N    ??process_parsed_command_106
  13059                      		flash_preview_begin = 1;
   \   00000400   0x2001             MOVS     R0,#+1
   \   00000402   0x.... 0x....      LDR.W    R1,??DataTable163_3
   \   00000406   0x7008             STRB     R0,[R1, #+0]
   \   00000408   0xE003             B.N      ??process_parsed_command_107
  13060                      	else
  13061                      		default_preview_flg = 1;							
   \                     ??process_parsed_command_106: (+1)
   \   0000040A   0x2001             MOVS     R0,#+1
   \   0000040C   0x.... 0x....      LDR.W    R1,??DataTable163_4
   \   00000410   0x7008             STRB     R0,[R1, #+0]
  13062          
  13063                      	draw_printing();
   \                     ??process_parsed_command_107: (+1)
   \   00000412   0x.... 0x....      BL       draw_printing
   \   00000416   0xE184             B.N      ??process_parsed_command_15
  13064                         #else
  13065                         draw_pause();
  13066          		#endif
  13067                      }          
  13068                    break;
  13069                  case 998:	//M998: Stop SD print
  13070                    gcode_M998(); break;			  
   \                     ??process_parsed_command_104: (+1)
   \   00000418   0x.... 0x....      BL       _Z10gcode_M998v
   \   0000041C   0xE181             B.N      ??process_parsed_command_15
  13071                  case 26: // M26: Set SD index
  13072                    gcode_M26(); break;
   \                     ??process_parsed_command_29: (+1)
   \   0000041E   0x.... 0x....      BL       _Z9gcode_M26v
   \   00000422   0xE17E             B.N      ??process_parsed_command_15
  13073                  case 27: // M27: Get SD status
  13074                    gcode_M27(); break;
   \                     ??process_parsed_command_30: (+1)
   \   00000424   0x.... 0x....      BL       _Z9gcode_M27v
   \   00000428   0xE17B             B.N      ??process_parsed_command_15
  13075                  case 28: // M28: Start SD write
  13076                    gcode_M28(); break;
   \                     ??process_parsed_command_31: (+1)
   \   0000042A   0x.... 0x....      BL       _Z9gcode_M28v
   \   0000042E   0xE178             B.N      ??process_parsed_command_15
  13077                  case 29: // M29: Stop SD write
  13078                    gcode_M29(); break;
   \                     ??process_parsed_command_32: (+1)
   \   00000430   0x.... 0x....      BL       _Z9gcode_M29v
   \   00000434   0xE175             B.N      ??process_parsed_command_15
  13079                  case 30: // M30 <filename> Delete File
  13080                    gcode_M30(); break;
   \                     ??process_parsed_command_33: (+1)
   \   00000436   0x.... 0x....      BL       _Z9gcode_M30v
   \   0000043A   0xE172             B.N      ??process_parsed_command_15
  13081                  case 32: // M32: Select file and start SD print
  13082                    gcode_M32(); break;
   \                     ??process_parsed_command_35: (+1)
   \   0000043C   0x.... 0x....      BL       _Z9gcode_M32v
   \   00000440   0xE16F             B.N      ??process_parsed_command_15
  13083          
  13084                  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
  13085                    case 33: // M33: Get the long full path to a file or folder
  13086                      gcode_M33(); break;
  13087                  #endif
  13088          
  13089                  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
  13090                    case 34: // M34: Set SD card sorting options
  13091                      gcode_M34(); break;
  13092                  #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
  13093          
  13094                  case 928: // M928: Start SD write
  13095                    gcode_M928(); break;
   \                     ??process_parsed_command_103: (+1)
   \   00000442   0x.... 0x....      BL       _Z10gcode_M928v
   \   00000446   0xE16C             B.N      ??process_parsed_command_15
  13096                #endif // SDSUPPORT
  13097          
  13098                case 31: // M31: Report time since the start of SD print or last M109
  13099                  gcode_M31(); break;
   \                     ??process_parsed_command_34: (+1)
   \   00000448   0x.... 0x....      BL       _Z9gcode_M31v
   \   0000044C   0xE169             B.N      ??process_parsed_command_15
  13100          
  13101                case 42: // M42: Change pin state
  13102                  gcode_M42(); break;
   \                     ??process_parsed_command_36: (+1)
   \   0000044E   0x.... 0x....      BL       _Z9gcode_M42v
   \   00000452   0xE166             B.N      ??process_parsed_command_15
  13103          
  13104                #if ENABLED(PINS_DEBUGGING)
  13105                  case 43: // M43: Read pin state
  13106                    gcode_M43(); break;
  13107                #endif
  13108          
  13109          
  13110                #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
  13111                  case 48: // M48: Z probe repeatability test
  13112                    gcode_M48();
  13113                    break;
  13114                #endif // Z_MIN_PROBE_REPEATABILITY_TEST
  13115          
  13116                //#if ENABLED(G26_MESH_VALIDATION)
  13117                  case 49: // M49: Turn on or off G26 debug flag for verbose output
  13118                  if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
   \                     ??process_parsed_command_37: (+1)
   \   00000454   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000458   0x7B00             LDRB     R0,[R0, #+12]
   \   0000045A   0x06C0             LSLS     R0,R0,#+27
   \   0000045C   0xF140 0x8161      BPL.W    ??process_parsed_command_15
  13119                    gcode_M49();
   \   00000460   0x.... 0x....      BL       _Z9gcode_M49v
   \   00000464   0xE15D             B.N      ??process_parsed_command_15
  13120                    break;
  13121                //#endif // G26_MESH_VALIDATION
  13122          
  13123                #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
  13124                  case 73: // M73: Set print progress percentage
  13125                    gcode_M73(); break;
  13126                #endif
  13127          
  13128                case 75: // M75: Start print timer
  13129                  gcode_M75(); break;
   \                     ??process_parsed_command_38: (+1)
   \   00000466   0x.... 0x....      BL       _Z9gcode_M75v
   \   0000046A   0xE15A             B.N      ??process_parsed_command_15
  13130                case 76: // M76: Pause print timer
  13131                  gcode_M76(); break;
   \                     ??process_parsed_command_39: (+1)
   \   0000046C   0x.... 0x....      BL       _Z9gcode_M76v
   \   00000470   0xE157             B.N      ??process_parsed_command_15
  13132                case 77: // M77: Stop print timer
  13133                  gcode_M77(); break;
   \                     ??process_parsed_command_40: (+1)
   \   00000472   0x.... 0x....      BL       _Z9gcode_M77v
   \   00000476   0xE154             B.N      ??process_parsed_command_15
  13134          
  13135                #if ENABLED(PRINTCOUNTER)
  13136                  case 78: // M78: Show print statistics
  13137                    gcode_M78(); break;
  13138                #endif
  13139          
  13140                #if ENABLED(M100_FREE_MEMORY_WATCHER)
  13141                  case 100: // M100: Free Memory Report
  13142                    gcode_M100();
  13143                    break;
  13144                #endif
  13145          
  13146                case 104: // M104: Set hot end temperature
  13147                  gcode_M104();
   \                     ??process_parsed_command_46: (+1)
   \   00000478   0x.... 0x....      BL       _Z10gcode_M104v
  13148                  break;
   \   0000047C   0xE151             B.N      ??process_parsed_command_15
  13149          
  13150                case 110: // M110: Set Current Line Number
  13151                  gcode_M110();
   \                     ??process_parsed_command_52: (+1)
   \   0000047E   0x.... 0x....      BL       _Z10gcode_M110v
  13152                  break;
   \   00000482   0xE14E             B.N      ??process_parsed_command_15
  13153          
  13154                case 111: // M111: Set debug level
  13155                  gcode_M111();
   \                     ??process_parsed_command_53: (+1)
   \   00000484   0x.... 0x....      BL       _Z10gcode_M111v
  13156                  break;
   \   00000488   0xE14B             B.N      ??process_parsed_command_15
  13157          
  13158                #if DISABLED(EMERGENCY_PARSER)
  13159          
  13160                  case 108: // M108: Cancel Waiting
  13161                    gcode_M108();
   \                     ??process_parsed_command_50: (+1)
   \   0000048A   0x.... 0x....      BL       _Z10gcode_M108v
  13162                    break;
   \   0000048E   0xE148             B.N      ??process_parsed_command_15
  13163          
  13164                  case 112: // M112: Emergency Stop
  13165                    gcode_M112();
   \                     ??process_parsed_command_54: (+1)
   \   00000490   0x.... 0x....      BL       _Z10gcode_M112v
  13166                    break;
   \   00000494   0xE145             B.N      ??process_parsed_command_15
  13167          
  13168                  case 410: // M410 quickstop - Abort all the planned moves.
  13169                    gcode_M410();
   \                     ??process_parsed_command_91: (+1)
   \   00000496   0x.... 0x....      BL       _Z10gcode_M410v
  13170                    break;
   \   0000049A   0xE142             B.N      ??process_parsed_command_15
  13171          
  13172                #endif
  13173          
  13174                #if ENABLED(HOST_KEEPALIVE_FEATURE)
  13175                  case 113: // M113: Set Host Keepalive interval
  13176                    gcode_M113();
   \                     ??process_parsed_command_55: (+1)
   \   0000049C   0x.... 0x....      BL       _Z10gcode_M113v
  13177                    break;
   \   000004A0   0xE13F             B.N      ??process_parsed_command_15
  13178                #endif
  13179          
  13180                case 140: // M140: Set bed temperature
  13181                if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
   \                     ??process_parsed_command_63: (+1)
   \   000004A2   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   000004A6   0x7880             LDRB     R0,[R0, #+2]
   \   000004A8   0x2800             CMP      R0,#+0
   \   000004AA   0xD002             BEQ.N    ??process_parsed_command_108
  13182                  gcode_M140();
   \   000004AC   0x.... 0x....      BL       _Z10gcode_M140v
   \   000004B0   0xE137             B.N      ??process_parsed_command_15
  13183                  else
  13184                    SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 	  
   \                     ??process_parsed_command_108: (+1)
   \   000004B2   0x.... 0x....      ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
   \   000004B6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000004BA   0xE132             B.N      ??process_parsed_command_15
  13185                  break;
  13186          
  13187                case 105: // M105: Report current temperature
  13188                  gcode_M105();
   \                     ??process_parsed_command_47: (+1)
   \   000004BC   0x.... 0x....      BL       _Z10gcode_M105v
  13189                  KEEPALIVE_STATE(NOT_BUSY);
   \   000004C0   0x2000             MOVS     R0,#+0
   \   000004C2   0x71A0             STRB     R0,[R4, #+6]
  13190                  return; // "ok" already printed
   \   000004C4   0xBD31             POP      {R0,R4,R5,PC}
  13191          
  13192               // #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  13193               #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
  13194                  case 155: // M155: Set temperature auto-report interval
  13195                    gcode_M155();
   \                     ??process_parsed_command_64: (+1)
   \   000004C6   0x.... 0x....      BL       _Z10gcode_M155v
  13196                    break;
   \   000004CA   0xE12A             B.N      ??process_parsed_command_15
  13197                #endif
  13198          
  13199                case 109: // M109: Wait for hotend temperature to reach target
  13200                  gcode_M109();
   \                     ??process_parsed_command_51: (+1)
   \   000004CC   0x.... 0x....      BL       _Z10gcode_M109v
  13201                  break;
   \   000004D0   0xE127             B.N      ??process_parsed_command_15
  13202          
  13203                //#if HAS_TEMP_BED
  13204                  case 190: // M190: Wait for bed temperature to reach target
  13205                  if(HAS_TEMP_BED) 
   \                     ??process_parsed_command_65: (+1)
   \   000004D2   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   000004D6   0x7880             LDRB     R0,[R0, #+2]
   \   000004D8   0x2800             CMP      R0,#+0
   \   000004DA   0xD002             BEQ.N    ??process_parsed_command_109
  13206                    gcode_M190();
   \   000004DC   0x.... 0x....      BL       _Z10gcode_M190v
   \   000004E0   0xE11F             B.N      ??process_parsed_command_15
  13207          		else
  13208                    SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
   \                     ??process_parsed_command_109: (+1)
   \   000004E2   0x.... 0x....      ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
   \   000004E6   0x.... 0x....      BL       _Z14serialprintPGMPKc
   \   000004EA   0xE11A             B.N      ??process_parsed_command_15
  13209                    break;
  13210                //#endif // HAS_TEMP_BED
  13211          
  13212                #if FAN_COUNT > 0
  13213                  case 106: // M106: Fan On
  13214                    gcode_M106();
   \                     ??process_parsed_command_48: (+1)
   \   000004EC   0x.... 0x....      BL       _Z10gcode_M106v
  13215                    break;
   \   000004F0   0xE117             B.N      ??process_parsed_command_15
  13216                  case 107: // M107: Fan Off
  13217                    gcode_M107();
   \                     ??process_parsed_command_49: (+1)
   \   000004F2   0x.... 0x....      BL       _Z10gcode_M107v
  13218                    break;
   \   000004F6   0xE114             B.N      ??process_parsed_command_15
  13219                #endif // FAN_COUNT > 0
  13220          
  13221                #if ENABLED(PARK_HEAD_ON_PAUSE)
  13222                  case 125: // M125: Store current position and move to filament change position
  13223                    gcode_M125(); break;
  13224                #endif
  13225          
  13226                #if ENABLED(BARICUDA)
  13227                  // PWM for HEATER_1_PIN
  13228                  #if HAS_HEATER_1
  13229                    case 126: // M126: valve open
  13230                      gcode_M126();
  13231                      break;
  13232                    case 127: // M127: valve closed
  13233                      gcode_M127();
  13234                      break;
  13235                  #endif // HAS_HEATER_1
  13236          
  13237                  // PWM for HEATER_2_PIN
  13238                  #if HAS_HEATER_2
  13239                    case 128: // M128: valve open
  13240                      gcode_M128();
  13241                      break;
  13242                    case 129: // M129: valve closed
  13243                      gcode_M129();
  13244                      break;
  13245                  #endif // HAS_HEATER_2
  13246                #endif // BARICUDA
  13247          
  13248                #if HAS_POWER_SWITCH
  13249          
  13250                  case 80: // M80: Turn on Power Supply
  13251                    gcode_M80();
  13252                    break;
  13253          
  13254                #endif // HAS_POWER_SWITCH
  13255          
  13256                case 81: // M81: Turn off Power, including Power Supply, if possible
  13257                  gcode_M81();
   \                     ??process_parsed_command_41: (+1)
   \   000004F8   0x.... 0x....      BL       _Z9gcode_M81v
  13258                  break;
   \   000004FC   0xE111             B.N      ??process_parsed_command_15
  13259          
  13260                case 82: // M82: Set E axis normal mode (same as other axes)
  13261                  gcode_M82();
   \                     ??process_parsed_command_42: (+1)
   \   000004FE   0x.... 0x....      BL       _Z9gcode_M82v
  13262                  break;
   \   00000502   0xE10E             B.N      ??process_parsed_command_15
  13263                case 83: // M83: Set E axis relative mode
  13264                  gcode_M83();
   \                     ??process_parsed_command_43: (+1)
   \   00000504   0x.... 0x....      BL       _Z9gcode_M83v
  13265                  break;
   \   00000508   0xE10B             B.N      ??process_parsed_command_15
  13266                case 18: // M18 => M84
  13267                case 84: // M84: Disable all steppers or set timeout
  13268                  gcode_M18_M84();
   \                     ??process_parsed_command_23: (+1)
   \   0000050A   0x.... 0x....      BL       _Z13gcode_M18_M84v
  13269                  break;
   \   0000050E   0xE108             B.N      ??process_parsed_command_15
  13270                case 85: // M85: Set inactivity stepper shutdown timeout
  13271                  gcode_M85();
   \                     ??process_parsed_command_44: (+1)
   \   00000510   0x.... 0x....      BL       _Z9gcode_M85v
  13272                  break;
   \   00000514   0xE105             B.N      ??process_parsed_command_15
  13273                case 92: // M92: Set the steps-per-unit for one or more axes
  13274                  gcode_M92();
   \                     ??process_parsed_command_45: (+1)
   \   00000516   0x.... 0x....      BL       _Z9gcode_M92v
  13275                  break;
   \   0000051A   0xE102             B.N      ??process_parsed_command_15
  13276                case 114: // M114: Report current position
  13277                  gcode_M114();
   \                     ??process_parsed_command_56: (+1)
   \   0000051C   0x.... 0x....      BL       _Z10gcode_M114v
  13278                  break;
   \   00000520   0xE0FF             B.N      ??process_parsed_command_15
  13279                case 115: // M115: Report capabilities
  13280                  gcode_M115();
   \                     ??process_parsed_command_57: (+1)
   \   00000522   0x.... 0x....      BL       _Z10gcode_M115v
  13281                  break;
   \   00000526   0xE0FC             B.N      ??process_parsed_command_15
  13282                case 117: // M117: Set LCD message text, if possible
  13283                  gcode_M117();
   \                     ??process_parsed_command_58: (+1)
   \   00000528   0x.... 0x....      BL       _Z10gcode_M117v
  13284                  break;
   \   0000052C   0xE0F9             B.N      ??process_parsed_command_15
  13285                case 118: // M118: Display a message in the host console
  13286                  gcode_M118();
   \                     ??process_parsed_command_59: (+1)
   \   0000052E   0x.... 0x....      BL       _Z10gcode_M118v
  13287                  break;
   \   00000532   0xE0F6             B.N      ??process_parsed_command_15
  13288                case 119: // M119: Report endstop states
  13289                  gcode_M119();
   \                     ??process_parsed_command_60: (+1)
   \   00000534   0x.... 0x....      BL       _Z10gcode_M119v
  13290                  break;
   \   00000538   0xE0F3             B.N      ??process_parsed_command_15
  13291                case 120: // M120: Enable endstops
  13292                  gcode_M120();
   \                     ??process_parsed_command_61: (+1)
   \   0000053A   0x.... 0x....      BL       _Z10gcode_M120v
  13293                  break;
   \   0000053E   0xE0F0             B.N      ??process_parsed_command_15
  13294                case 121: // M121: Disable endstops
  13295                  gcode_M121();
   \                     ??process_parsed_command_62: (+1)
   \   00000540   0x.... 0x....      BL       _Z10gcode_M121v
  13296                  break;
   \   00000544   0xE0ED             B.N      ??process_parsed_command_15
  13297          
  13298                #if ENABLED(ULTIPANEL)
  13299          
  13300                  case 145: // M145: Set material heatup parameters
  13301                    gcode_M145();
  13302                    break;
  13303          
  13304                #endif
  13305          
  13306                #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
  13307                  case 149: // M149: Set temperature units
  13308                    gcode_M149();
  13309                    break;
  13310                #endif
  13311          
  13312                #if HAS_COLOR_LEDS
  13313          
  13314                  case 150: // M150: Set Status LED Color
  13315                    gcode_M150();
  13316                    break;
  13317          
  13318                #endif // HAS_COLOR_LEDS
  13319          
  13320                #if ENABLED(MIXING_EXTRUDER)
  13321                  case 163: // M163: Set a component weight for mixing extruder
  13322                    gcode_M163();
  13323                    break;
  13324                  #if MIXING_VIRTUAL_TOOLS > 1
  13325                    case 164: // M164: Save current mix as a virtual extruder
  13326                      gcode_M164();
  13327                      break;
  13328                  #endif
  13329                  #if ENABLED(DIRECT_MIXING_IN_G1)
  13330                    case 165: // M165: Set multiple mix weights
  13331                      gcode_M165();
  13332                      break;
  13333                  #endif
  13334                #endif
  13335          
  13336                #if DISABLED(NO_VOLUMETRICS)
  13337                  case 200: // M200: Set filament diameter, E to cubic units
  13338                    gcode_M200();
   \                     ??process_parsed_command_66: (+1)
   \   00000546   0x.... 0x....      BL       _Z10gcode_M200v
  13339                    break;
   \   0000054A   0xE0EA             B.N      ??process_parsed_command_15
  13340                #endif
  13341          
  13342                case 201: // M201: Set max acceleration for print moves (units/s^2)
  13343                  gcode_M201();
   \                     ??process_parsed_command_67: (+1)
   \   0000054C   0x.... 0x....      BL       _Z10gcode_M201v
  13344                  break;
   \   00000550   0xE0E7             B.N      ??process_parsed_command_15
  13345                #if 0 // Not used for Sprinter/grbl gen6
  13346                  case 202: // M202
  13347                    gcode_M202();
  13348                    break;
  13349                #endif
  13350                case 203: // M203: Set max feedrate (units/sec)
  13351                  gcode_M203();
   \                     ??process_parsed_command_68: (+1)
   \   00000552   0x.... 0x....      BL       _Z10gcode_M203v
  13352                  break;
   \   00000556   0xE0E4             B.N      ??process_parsed_command_15
  13353                case 204: // M204: Set acceleration
  13354                  gcode_M204();
   \                     ??process_parsed_command_69: (+1)
   \   00000558   0x.... 0x....      BL       _Z10gcode_M204v
  13355                  break;
   \   0000055C   0xE0E1             B.N      ??process_parsed_command_15
  13356                case 205: // M205: Set advanced settings
  13357                  gcode_M205();
   \                     ??process_parsed_command_70: (+1)
   \   0000055E   0x.... 0x....      BL       _Z10gcode_M205v
  13358                  break;
   \   00000562   0xE0DE             B.N      ??process_parsed_command_15
  13359          
  13360                //#if HAS_M206_COMMAND
  13361                  case 206: // M206: Set home offsets
  13362                  if(MACHINETPYE != DELTA)
   \                     ??process_parsed_command_71: (+1)
   \   00000564   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000568   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   0000056C   0x2802             CMP      R0,#+2
   \   0000056E   0xF000 0x80D8      BEQ.W    ??process_parsed_command_15
  13363                    gcode_M206();
   \   00000572   0x.... 0x....      BL       _Z10gcode_M206v
   \   00000576   0xE0D4             B.N      ??process_parsed_command_15
  13364                    break;
  13365                //#endif
  13366          
  13367                //#if ENABLED(DELTA)
  13368                  case 665: // M665: Set delta configurations
  13369                  if(MACHINETPYE == DELTA)
   \                     ??process_parsed_command_99: (+1)
   \   00000578   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   0000057C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000580   0x2802             CMP      R0,#+2
   \   00000582   0xF040 0x80CE      BNE.W    ??process_parsed_command_15
  13370                    gcode_M665();
   \   00000586   0x.... 0x....      BL       _Z10gcode_M665v
   \   0000058A   0xE0CA             B.N      ??process_parsed_command_15
  13371                    break;
  13372                //#endif
  13373          
  13374                //#if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
  13375                  case 666: // M666: Set delta or dual endstop adjustment
  13376                  if(MACHINETPYE == DELTA)
   \                     ??process_parsed_command_100: (+1)
   \   0000058C   0x....             LDR.N    R0,??DataTable158
   \   0000058E   0xF100 0x0134      ADD      R1,R0,#+52
   \   00000592   0xF9B1 0x1024      LDRSH    R1,[R1, #+36]
   \   00000596   0x2902             CMP      R1,#+2
   \   00000598   0xD102             BNE.N    ??process_parsed_command_110
  13377                    gcode_M666();
   \   0000059A   0x.... 0x....      BL       _Z10gcode_M666v
   \   0000059E   0xE0C0             B.N      ??process_parsed_command_15
  13378                  else if(Z_DUAL_ENDSTOPS==1)
   \                     ??process_parsed_command_110: (+1)
   \   000005A0   0xF890 0x0102      LDRB     R0,[R0, #+258]
   \   000005A4   0x2801             CMP      R0,#+1
   \   000005A6   0xF040 0x80BC      BNE.W    ??process_parsed_command_15
  13379                  {
  13380                    gcode_M666_dual();  
   \   000005AA   0x.... 0x....      BL       _Z15gcode_M666_dualv
   \   000005AE   0xE0B8             B.N      ??process_parsed_command_15
  13381                  }
  13382                    break;
  13383                //#endif
  13384          
  13385                #if ENABLED(FWRETRACT)
  13386                  case 207: // M207: Set Retract Length, Feedrate, and Z lift
  13387                    gcode_M207();
  13388                    break;
  13389                  case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
  13390                    gcode_M208();
  13391                    break;
  13392                  case 209: // M209: Turn Automatic Retract Detection on/off
  13393                    if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
  13394                    break;
  13395                #endif // FWRETRACT
  13396          
  13397                case 211: // M211: Enable, Disable, and/or Report software endstops
  13398                  gcode_M211();
   \                     ??process_parsed_command_72: (+1)
   \   000005B0   0x.... 0x....      BL       _Z10gcode_M211v
  13399                  break;
   \   000005B4   0xE0B5             B.N      ??process_parsed_command_15
  13400          
  13401                #if HOTENDS > 1
  13402                  case 218: // M218: Set a tool offset
  13403                    gcode_M218();
   \                     ??process_parsed_command_73: (+1)
   \   000005B6   0x.... 0x....      BL       _Z10gcode_M218v
  13404                    break;
   \   000005BA   0xE0B2             B.N      ??process_parsed_command_15
  13405                #endif // HOTENDS > 1
  13406          
  13407                case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
  13408                  gcode_M220();
   \                     ??process_parsed_command_74: (+1)
   \   000005BC   0x.... 0x....      BL       _Z10gcode_M220v
  13409                  break;
   \   000005C0   0xE0AF             B.N      ??process_parsed_command_15
  13410          
  13411                case 221: // M221: Set Flow Percentage
  13412                  gcode_M221();
   \                     ??process_parsed_command_75: (+1)
   \   000005C2   0x.... 0x....      BL       _Z10gcode_M221v
  13413                  break;
   \   000005C6   0xE0AC             B.N      ??process_parsed_command_15
  13414          
  13415                case 226: // M226: Wait until a pin reaches a state
  13416                  gcode_M226();
   \                     ??process_parsed_command_76: (+1)
   \   000005C8   0x.... 0x....      BL       _Z10gcode_M226v
  13417                  break;
   \   000005CC   0xE0A9             B.N      ??process_parsed_command_15
  13418          
  13419                //#if HAS_SERVOS
  13420                  case 280: // M280: Set servo position absolute
  13421                    gcode_M280();
   \                     ??process_parsed_command_77: (+1)
   \   000005CE   0x.... 0x....      BL       _Z10gcode_M280v
  13422                    break;
   \   000005D2   0xE0A6             B.N      ??process_parsed_command_15
  13423                //#endif // HAS_SERVOS
  13424          
  13425                #if ENABLED(BABYSTEPPING)
  13426                  case 290: // M290: Babystepping
  13427                    gcode_M290();
  13428                    break;
  13429                #endif // BABYSTEPPING
  13430          
  13431                #if HAS_BUZZER
  13432                  case 300: // M300: Play beep tone
  13433                    gcode_M300();
  13434                    break;
  13435                #endif // HAS_BUZZER
  13436          
  13437                //#if ENABLED(PIDTEMP)
  13438                  case 301: // M301: Set hotend PID parameters
  13439                  if(PIDTEMP) 
   \                     ??process_parsed_command_78: (+1)
   \   000005D4   0x....             LDR.N    R0,??DataTable158
   \   000005D6   0xF890 0x0034      LDRB     R0,[R0, #+52]
   \   000005DA   0x2800             CMP      R0,#+0
   \   000005DC   0xF000 0x80A1      BEQ.W    ??process_parsed_command_15
  13440                    gcode_M301();
   \   000005E0   0x.... 0x....      BL       _Z10gcode_M301v
   \   000005E4   0xE09D             B.N      ??process_parsed_command_15
  13441                    break;
  13442                //#endif // PIDTEMP
  13443          
  13444                //#if ENABLED(PIDTEMPBED)
  13445                  case 304: // M304: Set bed PID parameters
  13446                  if(PIDTEMPBED) 
   \                     ??process_parsed_command_81: (+1)
   \   000005E6   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   000005EA   0x7840             LDRB     R0,[R0, #+1]
   \   000005EC   0x2800             CMP      R0,#+0
   \   000005EE   0xF000 0x8098      BEQ.W    ??process_parsed_command_15
  13447                    gcode_M304();
   \   000005F2   0x.... 0x....      BL       _Z10gcode_M304v
   \   000005F6   0xE094             B.N      ??process_parsed_command_15
  13448                    break;
  13449                //#endif // PIDTEMPBED
  13450          
  13451                #if defined(CHDK) || HAS_PHOTOGRAPH
  13452                  case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
  13453                    gcode_M240();
  13454                    break;
  13455                #endif // CHDK || PHOTOGRAPH_PIN
  13456          
  13457                #if HAS_LCD_CONTRAST
  13458                  case 250: // M250: Set LCD contrast
  13459                    gcode_M250();
  13460                    break;
  13461                #endif // HAS_LCD_CONTRAST
  13462          
  13463                #if ENABLED(EXPERIMENTAL_I2CBUS)
  13464          
  13465                  case 260: // M260: Send data to an i2c slave
  13466                    gcode_M260();
  13467                    break;
  13468          
  13469                  case 261: // M261: Request data from an i2c slave
  13470                    gcode_M261();
  13471                    break;
  13472          
  13473                #endif // EXPERIMENTAL_I2CBUS
  13474          
  13475                #if ENABLED(PREVENT_COLD_EXTRUSION)
  13476                  case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
  13477                    gcode_M302();
   \                     ??process_parsed_command_79: (+1)
   \   000005F8   0x.... 0x....      BL       _Z10gcode_M302v
  13478                    break;
   \   000005FC   0xE091             B.N      ??process_parsed_command_15
  13479                #endif // PREVENT_COLD_EXTRUSION
  13480          
  13481                case 303: // M303: PID autotune
  13482                  gcode_M303();
   \                     ??process_parsed_command_80: (+1)
   \   000005FE   0x.... 0x....      BL       _Z10gcode_M303v
  13483                  break;
   \   00000602   0xE08E             B.N      ??process_parsed_command_15
  13484          
  13485                //#if ENABLED(MORGAN_SCARA)
  13486                  case 360:  // M360: SCARA Theta pos1
  13487                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_83: (+1)
   \   00000604   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000608   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   0000060C   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000610   0xF040 0x8087      BNE.W    ??process_parsed_command_15
  13488                    if (gcode_M360()) return;
   \   00000614   0x.... 0x....      BL       _Z10gcode_M360v
   \   00000618   0x2800             CMP      R0,#+0
   \   0000061A   0xF000 0x8082      BEQ.W    ??process_parsed_command_15
   \   0000061E   0xBD31             POP      {R0,R4,R5,PC}
  13489                    break;
  13490                  case 361:  // M361: SCARA Theta pos2
  13491                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_84: (+1)
   \   00000620   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000624   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000628   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000062C   0xD179             BNE.N    ??process_parsed_command_15
  13492                    if (gcode_M361()) return;
   \   0000062E   0x.... 0x....      BL       _Z10gcode_M361v
   \   00000632   0x2800             CMP      R0,#+0
   \   00000634   0xD075             BEQ.N    ??process_parsed_command_15
   \   00000636   0xBD31             POP      {R0,R4,R5,PC}
  13493                    break;
  13494                  case 362:  // M362: SCARA Psi pos1
  13495                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_85: (+1)
   \   00000638   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   0000063C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000640   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000644   0xD16D             BNE.N    ??process_parsed_command_15
  13496                    if (gcode_M362()) return;
   \   00000646   0x.... 0x....      BL       _Z10gcode_M362v
   \   0000064A   0x2800             CMP      R0,#+0
   \   0000064C   0xD069             BEQ.N    ??process_parsed_command_15
   \   0000064E   0xBD31             POP      {R0,R4,R5,PC}
  13497                    break;
  13498                  case 363:  // M363: SCARA Psi pos2
  13499                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_86: (+1)
   \   00000650   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000654   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000658   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000065C   0xD161             BNE.N    ??process_parsed_command_15
  13500                    if (gcode_M363()) return;
   \   0000065E   0x.... 0x....      BL       _Z10gcode_M363v
   \   00000662   0x2800             CMP      R0,#+0
   \   00000664   0xD05D             BEQ.N    ??process_parsed_command_15
   \   00000666   0xBD31             POP      {R0,R4,R5,PC}
  13501                    break;
  13502                  case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
  13503                  if(MACHINETPYE == MORGAN_SCARA)
   \                     ??process_parsed_command_87: (+1)
   \   00000668   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   0000066C   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   00000670   0xF5B0 0x7F80      CMP      R0,#+256
   \   00000674   0xD155             BNE.N    ??process_parsed_command_15
  13504                    if (gcode_M364()) return;
   \   00000676   0x.... 0x....      BL       _Z10gcode_M364v
   \   0000067A   0x2800             CMP      R0,#+0
   \   0000067C   0xD051             BEQ.N    ??process_parsed_command_15
   \   0000067E   0xBD31             POP      {R0,R4,R5,PC}
  13505                    break;
  13506                //#endif // SCARA
  13507          
  13508                case 400: // M400: Finish all moves
  13509                  gcode_M400();
   \                     ??process_parsed_command_88: (+1)
   \   00000680   0x.... 0x....      BL       _Z10gcode_M400v
  13510                  break;
   \   00000684   0xE04D             B.N      ??process_parsed_command_15
  13511          
  13512                #if HAS_BED_PROBE
  13513                  case 401: // M401: Deploy probe
  13514                    gcode_M401();
   \                     ??process_parsed_command_89: (+1)
   \   00000686   0x.... 0x....      BL       _Z10gcode_M401v
  13515                    break;
   \   0000068A   0xE04A             B.N      ??process_parsed_command_15
  13516                  case 402: // M402: Stow probe
  13517                    gcode_M402();
   \                     ??process_parsed_command_90: (+1)
   \   0000068C   0x.... 0x....      BL       _Z10gcode_M402v
  13518                    break;
   \   00000690   0xE047             B.N      ??process_parsed_command_15
  13519                #endif // HAS_BED_PROBE
  13520          
  13521                #if ENABLED(FILAMENT_WIDTH_SENSOR)
  13522                  case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
  13523                    gcode_M404();
  13524                    break;
  13525                  case 405:  // M405: Turn on filament sensor for control
  13526                    gcode_M405();
  13527                    break;
  13528                  case 406:  // M406: Turn off filament sensor for control
  13529                    gcode_M406();
  13530                    break;
  13531                  case 407:   // M407: Display measured filament diameter
  13532                    gcode_M407();
  13533                    break;
  13534                #endif // FILAMENT_WIDTH_SENSOR
  13535          
  13536                //#if HAS_LEVELING
  13537                  case 420: // M420: Enable/Disable Bed Leveling
  13538                  if(BED_LEVELING_METHOD&HAS_LEVELING)
   \                     ??process_parsed_command_92: (+1)
   \   00000692   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   00000696   0x7B00             LDRB     R0,[R0, #+12]
   \   00000698   0x213E             MOVS     R1,#+62
   \   0000069A   0x4208             TST      R0,R1
   \   0000069C   0xD041             BEQ.N    ??process_parsed_command_15
  13539                    gcode_M420();
   \   0000069E   0x.... 0x....      BL       _Z10gcode_M420v
   \   000006A2   0xE03E             B.N      ??process_parsed_command_15
  13540                    break;
  13541                //#endif
  13542          
  13543                //#if HAS_MESH
  13544                  case 421: // M421: Set a Mesh Bed Leveling Z coordinate
  13545                    if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
   \                     ??process_parsed_command_93: (+1)
   \   000006A4   0x....             LDR.N    R0,??DataTable158
   \   000006A6   0xF100 0x0534      ADD      R5,R0,#+52
   \   000006AA   0x7B28             LDRB     R0,[R5, #+12]
   \   000006AC   0x0681             LSLS     R1,R0,#+26
   \   000006AE   0xD502             BPL.N    ??process_parsed_command_111
  13546                    	gcode_M421_MESH_BED_LEVELING();
   \   000006B0   0x.... 0x....      BL       _Z28gcode_M421_MESH_BED_LEVELINGv
   \   000006B4   0xE035             B.N      ??process_parsed_command_15
  13547          		  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
   \                     ??process_parsed_command_111: (+1)
   \   000006B6   0x0701             LSLS     R1,R0,#+28
   \   000006B8   0xD502             BPL.N    ??process_parsed_command_112
  13548                    	gcode_M421_AUTO_BED_LEVELING_BILINEAR();
   \   000006BA   0x.... 0x....      BL       _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
   \   000006BE   0xE030             B.N      ??process_parsed_command_15
  13549                    else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
   \                     ??process_parsed_command_112: (+1)
   \   000006C0   0x06C0             LSLS     R0,R0,#+27
   \   000006C2   0xD52E             BPL.N    ??process_parsed_command_15
  13550                      gcode_M421_AUTO_BED_LEVELING_UBL();
   \   000006C4   0x.... 0x....      BL       _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
   \   000006C8   0xE02B             B.N      ??process_parsed_command_15
  13551                    break;
  13552                //#endif
  13553          
  13554                //#if HAS_M206_COMMAND
  13555                  case 428: // M428: Apply current_position to home_offset
  13556                  if(MACHINETPYE != DELTA)
   \                     ??process_parsed_command_94: (+1)
   \   000006CA   0x.... 0x....      LDR.W    R0,??DataTable161_3
   \   000006CE   0xF9B0 0x0024      LDRSH    R0,[R0, #+36]
   \   000006D2   0x2802             CMP      R0,#+2
   \   000006D4   0xD025             BEQ.N    ??process_parsed_command_15
  13557                    gcode_M428();
   \   000006D6   0x.... 0x....      BL       _Z10gcode_M428v
   \   000006DA   0xE022             B.N      ??process_parsed_command_15
  13558                    break;
  13559                //#endif
  13560          
  13561                case 500: // M500: Store settings in EEPROM
  13562                  gcode_M500();
   \                     ??process_parsed_command_95: (+1)
   \   000006DC   0x.... 0x....      BL       _Z10gcode_M500v
  13563                  break;
   \   000006E0   0xE01F             B.N      ??process_parsed_command_15
  13564                case 501: // M501: Read settings from EEPROM
  13565                  gcode_M501();
   \                     ??process_parsed_command_96: (+1)
   \   000006E2   0x.... 0x....      BL       _Z10gcode_M501v
  13566                  break;
   \   000006E6   0xE01C             B.N      ??process_parsed_command_15
  13567                case 502: // M502: Revert to default settings
  13568                  gcode_M502();
   \                     ??process_parsed_command_97: (+1)
   \   000006E8   0x.... 0x....      BL       _Z10gcode_M502v
  13569                  break;
   \   000006EC   0xE019             B.N      ??process_parsed_command_15
  13570          
  13571                #if DISABLED(DISABLE_M503)
  13572                  case 503: // M503: print settings currently in memory
  13573                    gcode_M503();
   \                     ??process_parsed_command_98: (+1)
   \   000006EE   0x.... 0x....      BL       _Z10gcode_M503v
  13574                    break;
   \   000006F2   0xE016             B.N      ??process_parsed_command_15
  13575                #endif
  13576          
  13577                #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
  13578                  case 540: // M540: Set abort on endstop hit for SD printing
  13579                    gcode_M540();
  13580                    break;
  13581                #endif
  13582          
  13583                #if HAS_BED_PROBE
  13584                  case 851: // M851: Set Z Probe Z Offset
  13585                    gcode_M851();
   \                     ??process_parsed_command_101: (+1)
   \   000006F4   0x.... 0x....      BL       _Z10gcode_M851v
  13586                    break;
   \   000006F8   0xE013             B.N      ??process_parsed_command_15
  13587                #endif // HAS_BED_PROBE
  13588          
  13589                #if ENABLED(SKEW_CORRECTION_GCODE)
  13590                  case 852: // M852: Set Skew factors
  13591                    gcode_M852();
  13592                    break;
  13593                #endif
  13594          
  13595                #if ENABLED(ADVANCED_PAUSE_FEATURE)
  13596                  case 600: // M600: Pause for filament change
  13597                    gcode_M600();
  13598                    break;
  13599                #endif // ADVANCED_PAUSE_FEATURE
  13600          
  13601                #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
  13602                  case 605: // M605: Set Dual X Carriage movement mode
  13603                    gcode_M605();
  13604                    break;
  13605                #endif // DUAL_X_CARRIAGE
  13606          
  13607                #if ENABLED(MK2_MULTIPLEXER)
  13608                  case 702: // M702: Unload all extruders
  13609                    gcode_M702();
  13610                    break;
  13611                #endif
  13612          
  13613                #if ENABLED(LIN_ADVANCE)
  13614                  case 900: // M900: Set advance K factor.
  13615                    gcode_M900();
  13616                    break;
  13617                #endif
  13618          
  13619                case 907: // M907: Set digital trimpot motor current using axis codes.
  13620                  gcode_M907();
   \                     ??process_parsed_command_102: (+1)
   \   000006FA   0x.... 0x....      BL       _Z10gcode_M907v
  13621                  break;
   \   000006FE   0xE010             B.N      ??process_parsed_command_15
  13622          
  13623                #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
  13624          
  13625                  case 908: // M908: Control digital trimpot directly.
  13626                    gcode_M908();
  13627                    break;
  13628          
  13629                  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
  13630          
  13631                    case 909: // M909: Print digipot/DAC current value
  13632                      gcode_M909();
  13633                      break;
  13634          
  13635                    case 910: // M910: Commit digipot/DAC value to external EEPROM
  13636                      gcode_M910();
  13637                      break;
  13638          
  13639                  #endif
  13640          
  13641                #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
  13642          
  13643                #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
  13644                  case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
  13645                    gcode_M906();
  13646                    break;
  13647          
  13648                  case 911: // M911: Report TMC prewarn triggered flags
  13649                    gcode_M911();
  13650                    break;
  13651          
  13652                  case 912: // M911: Clear TMC prewarn triggered flags
  13653                    gcode_M912();
  13654                    break;
  13655          
  13656                  #if ENABLED(TMC_DEBUG)
  13657                    case 122:  // Debug TMC steppers
  13658                      gcode_M122();
  13659                      break;
  13660                  #endif
  13661          
  13662                  #if ENABLED(HYBRID_THRESHOLD)
  13663                    case 913: // M913: Set HYBRID_THRESHOLD speed.
  13664                      gcode_M913();
  13665                      break;
  13666                  #endif
  13667          
  13668                  #if ENABLED(SENSORLESS_HOMING)
  13669                    case 914: // M914: Set SENSORLESS_HOMING sensitivity.
  13670                      gcode_M914();
  13671                      break;
  13672                  #endif
  13673          
  13674                  #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
  13675                    case 915: // M915: TMC Z axis calibration routine
  13676                      gcode_M915();
  13677                      break;
  13678                  #endif
  13679                #endif
  13680          
  13681                #if HAS_MICROSTEPS
  13682          
  13683                  case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
  13684                    gcode_M350();
  13685                    break;
  13686          
  13687                  case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
  13688                    gcode_M351();
  13689                    break;
  13690          
  13691                #endif // HAS_MICROSTEPS
  13692          
  13693                case 355: // M355 set case light brightness
  13694                  gcode_M355();
   \                     ??process_parsed_command_82: (+1)
   \   00000700   0x.... 0x....      BL       _Z10gcode_M355v
  13695                  break;
   \   00000704   0xE00D             B.N      ??process_parsed_command_15
  13696          
  13697                #if ENABLED(DEBUG_GCODE_PARSER)
  13698                  case 800:
  13699                    parser.debug(); // GCode Parser Test for M
  13700                    break;
  13701                #endif
  13702          
  13703                #if ENABLED(I2C_POSITION_ENCODERS)
  13704          
  13705                  case 860: // M860 Report encoder module position
  13706                    gcode_M860();
  13707                    break;
  13708          
  13709                  case 861: // M861 Report encoder module status
  13710                    gcode_M861();
  13711                    break;
  13712          
  13713                  case 862: // M862 Perform axis test
  13714                    gcode_M862();
  13715                    break;
  13716          
  13717                  case 863: // M863 Calibrate steps/mm
  13718                    gcode_M863();
  13719                    break;
  13720          
  13721                  case 864: // M864 Change module address
  13722                    gcode_M864();
  13723                    break;
  13724          
  13725                  case 865: // M865 Check module firmware version
  13726                    gcode_M865();
  13727                    break;
  13728          
  13729                  case 866: // M866 Report axis error count
  13730                    gcode_M866();
  13731                    break;
  13732          
  13733                  case 867: // M867 Toggle error correction
  13734                    gcode_M867();
  13735                    break;
  13736          
  13737                  case 868: // M868 Set error correction threshold
  13738                    gcode_M868();
  13739                    break;
  13740          
  13741                  case 869: // M869 Report axis error
  13742                    gcode_M869();
  13743                    break;
  13744          
  13745                #endif // I2C_POSITION_ENCODERS
  13746          
  13747                case 999: // M999: Restart after being Stopped
  13748                  gcode_M999();
   \                     ??process_parsed_command_105: (+1)
   \   00000706   0x.... 0x....      BL       _Z10gcode_M999v
  13749                  break;
   \   0000070A   0xE00A             B.N      ??process_parsed_command_15
  13750              }
  13751              break;
  13752          
  13753              case 'T':
  13754                gcode_T(parser.codenum);
   \                     ??process_parsed_command_2: (+1)
   \   0000070C   0x.... 0x....      LDR.W    R0,??DataTable161_2
   \   00000710   0x6800             LDR      R0,[R0, #+0]
   \   00000712   0xB2C0             UXTB     R0,R0
   \   00000714   0x.... 0x....      BL       _Z7gcode_Th
  13755                break;
   \   00000718   0xE003             B.N      ??process_parsed_command_15
  13756          
  13757              default: parser.unknown_command_error();
   \                     ??process_parsed_command_3: (+1)
   \   0000071A   0x.... 0x....      LDR.W    R0,??DataTable166
   \   0000071E   0x.... 0x....      BL       _ZN11GCodeParser21unknown_command_errorEv
  13758            }
  13759          
  13760            KEEPALIVE_STATE(NOT_BUSY);
   \                     ??process_parsed_command_15: (+1)
   \   00000722   0x2000             MOVS     R0,#+0
   \   00000724   0x71A0             STRB     R0,[R4, #+6]
  13761          
  13762            ok_to_send();
   \   00000726   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000072A   0x....             B.N      _Z10ok_to_sendv
  13763          }
  13764          

   \                                 In section .text, align 2, keep-with-next
  13765          void process_next_command() 
  13766          {
   \                     _Z20process_next_commandv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  13767            char * const current_command = command_queue[cmd_queue_index_r];
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable166_1
   \   00000006   0x79C0             LDRB     R0,[R0, #+7]
   \   00000008   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable166_2
   \   00000010   0xEB00 0x1441      ADD      R4,R0,R1, LSL #+5
  13768          
  13769            if (DEBUGGING(ECHO)) {
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable166_3
   \   00000018   0x7840             LDRB     R0,[R0, #+1]
   \   0000001A   0x07C0             LSLS     R0,R0,#+31
   \   0000001C   0xD50D             BPL.N    ??process_next_command_0
  13770              SERIAL_ECHO_START();
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable160_6
   \   00000022   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13771              SERIAL_ECHOLN(current_command);
   \   00000026   0x.... 0x....      LDR.W    R5,??DataTable161
   \   0000002A   0x4621             MOV      R1,R4
   \   0000002C   0x4628             MOV      R0,R5
   \   0000002E   0x.... 0x....      BL       _ZN5Print5printEPKc
   \   00000032   0x210A             MOVS     R1,#+10
   \   00000034   0x4628             MOV      R0,R5
   \   00000036   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  13772              #if ENABLED(M100_FREE_MEMORY_WATCHER)
  13773                SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
  13774                M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
  13775              #endif
  13776            }
  13777          
  13778            // Parse the next command in the queue
  13779            parser.parse(current_command);
   \                     ??process_next_command_0: (+1)
   \   0000003A   0x4620             MOV      R0,R4
   \   0000003C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
  13780            process_parsed_command();
   \   00000040   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000044   0x....             B.N      _Z22process_parsed_commandv
  13781          }
  13782          
  13783          /**
  13784           * Send a "Resend: nnn" message to the host to
  13785           * indicate that a command needs to be re-sent.
  13786           */

   \                                 In section .text, align 2, keep-with-next
  13787          void FlushSerialRequestResend() {
   \                     _Z24FlushSerialRequestResendv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  13788            //char command_queue[cmd_queue_index_r][100]="Resend:";
  13789            MYSERIAL.flush();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable161
   \   00000006   0x4620             MOV      R0,R4
   \   00000008   0x.... 0x....      BL       _ZN10USARTClass5flushEv
  13790            SERIAL_PROTOCOLPGM(MSG_RESEND);
   \   0000000C   0x.... 0x....      ADR.W    R0,`?<Constant "Resend: ">`
   \   00000010   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13791            SERIAL_PROTOCOLLN(gcode_LastN + 1);
   \   00000014   0x220A             MOVS     R2,#+10
   \   00000016   0x.... 0x....      LDR.W    R0,??DataTable161_1
   \   0000001A   0x6AC0             LDR      R0,[R0, #+44]
   \   0000001C   0x1C41             ADDS     R1,R0,#+1
   \   0000001E   0x4620             MOV      R0,R4
   \   00000020   0x.... 0x....      BL       _ZN5Print5printEli
   \   00000024   0x210A             MOVS     R1,#+10
   \   00000026   0x4620             MOV      R0,R4
   \   00000028   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  13792            ok_to_send();
   \   0000002C   0xE8BD 0x4010      POP      {R4,LR}
   \   00000030                      REQUIRE _Z10ok_to_sendv
   \   00000030                      ;; // Fall through to label ok_to_send()
  13793          }
  13794          
  13795          /**
  13796           * Send an "ok" message to the host, indicating
  13797           * that a command was successfully processed.
  13798           *
  13799           * If ADVANCED_OK is enabled also include:
  13800           *   N<int>  Line number of the command, if any
  13801           *   P<int>  Planner space remaining
  13802           *   B<int>  Block queue space remaining
  13803           */

   \                                 In section .text, align 2, keep-with-next
  13804          void ok_to_send() {
   \                     _Z10ok_to_sendv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  13805            refresh_cmd_timeout();
   \   00000002   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  13806            if (!send_ok[cmd_queue_index_r]) return;
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable166_1
   \   0000000A   0x79C1             LDRB     R1,[R0, #+7]
   \   0000000C   0x1808             ADDS     R0,R1,R0
   \   0000000E   0x7E00             LDRB     R0,[R0, #+24]
   \   00000010   0x2800             CMP      R0,#+0
   \   00000012   0xD009             BEQ.N    ??ok_to_send_0
  13807            SERIAL_PROTOCOLPGM(MSG_OK);
   \   00000014   0x....             ADR.N    R0,??DataTable160  ;; 0x6F, 0x6B, 0x00, 0x00
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
  13808            #if ENABLED(ADVANCED_OK)
  13809              char* p = command_queue[cmd_queue_index_r];
  13810              if (*p == 'N') {
  13811                SERIAL_PROTOCOL(' ');
  13812                SERIAL_ECHO(*p++);
  13813                while (NUMERIC_SIGNED(*p))
  13814                  SERIAL_ECHO(*p++);
  13815              }
  13816              SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
  13817              SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
  13818            #endif
  13819            SERIAL_EOL();
   \   0000001A   0x210A             MOVS     R1,#+10
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable161
   \   00000020   0xE8BD 0x4004      POP      {R2,LR}
   \   00000024   0x.... 0x....      B.W      _ZN10USARTClass5writeEh
   \                     ??ok_to_send_0: (+1)
   \   00000028   0xBD01             POP      {R0,PC}          ;; return
  13820          }
  13821          
  13822          #if HAS_SOFTWARE_ENDSTOPS
  13823          
  13824            /**
  13825             * Constrain the given coordinates to the software endstops.
  13826             *
  13827             * For DELTA/SCARA the XY constraint is based on the smallest
  13828             * radius within the set software endstops.
  13829             */

   \                                 In section .text, align 2, keep-with-next
  13830            void clamp_to_software_endstops(float target[XYZ]) {
   \                     _Z26clamp_to_software_endstopsPf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4604             MOV      R4,R0
  13831              if (!soft_endstops_enabled) return;
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable166_4
   \   0000000A   0x7A28             LDRB     R0,[R5, #+8]
   \   0000000C   0x2800             CMP      R0,#+0
   \   0000000E   0xF000 0x8088      BEQ.W    ??clamp_to_software_endstops_0
  13832              //#if IS_KINEMATIC
  13833              if(MACHINETPYE & IS_KINEMATIC )
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable166_5
   \   00000016   0xF106 0x0720      ADD      R7,R6,#+32
   \   0000001A   0x8F38             LDRH     R0,[R7, #+56]
   \   0000001C   0xF240 0x3102      MOVW     R1,#+770
   \   00000020   0x4208             TST      R0,R1
   \   00000022   0xD048             BEQ.N    ??clamp_to_software_endstops_1
  13834              {
  13835                const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
   \   00000024   0xF8D4 0xA000      LDR      R10,[R4, #+0]
   \   00000028   0xF04F 0x0902      MOV      R9,#+2
   \   0000002C   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   00000030   0x46D8             MOV      R8,R11
   \   00000032   0xE004             B.N      ??clamp_to_software_endstops_2
   \                     ??clamp_to_software_endstops_3: (+1)
   \   00000034   0x4650             MOV      R0,R10
   \   00000036   0x4651             MOV      R1,R10
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x4682             MOV      R10,R0
   \                     ??clamp_to_software_endstops_2: (+1)
   \   0000003E   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000042   0xD504             BPL.N    ??clamp_to_software_endstops_4
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x4651             MOV      R1,R10
   \   00000048   0x.... 0x....      BL       __aeabi_fmul
   \   0000004C   0x4680             MOV      R8,R0
   \                     ??clamp_to_software_endstops_4: (+1)
   \   0000004E   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000052   0xD1EF             BNE.N    ??clamp_to_software_endstops_3
   \   00000054   0xF8D4 0x9004      LDR      R9,[R4, #+4]
   \   00000058   0xF04F 0x0A02      MOV      R10,#+2
   \   0000005C   0xE004             B.N      ??clamp_to_software_endstops_5
   \                     ??clamp_to_software_endstops_6: (+1)
   \   0000005E   0x4648             MOV      R0,R9
   \   00000060   0x4649             MOV      R1,R9
   \   00000062   0x.... 0x....      BL       __aeabi_fmul
   \   00000066   0x4681             MOV      R9,R0
   \                     ??clamp_to_software_endstops_5: (+1)
   \   00000068   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000006C   0xD504             BPL.N    ??clamp_to_software_endstops_7
   \   0000006E   0x4658             MOV      R0,R11
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0x.... 0x....      BL       __aeabi_fmul
   \   00000076   0x4683             MOV      R11,R0
   \                     ??clamp_to_software_endstops_7: (+1)
   \   00000078   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000007C   0xD1EF             BNE.N    ??clamp_to_software_endstops_6
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x4659             MOV      R1,R11
   \   00000082   0x.... 0x....      BL       __aeabi_fadd
   \   00000086   0x4601             MOV      R1,R0
  13836                if (dist_2 > soft_endstop_radius_2) {
   \   00000088   0x6DA8             LDR      R0,[R5, #+88]
   \   0000008A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000008E   0xD233             BCS.N    ??clamp_to_software_endstops_8
  13837                  const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
   \   00000090   0x4608             MOV      R0,R1
   \   00000092   0x.... 0x....      BL       sqrtf
   \   00000096   0x4601             MOV      R1,R0
   \   00000098   0x6D68             LDR      R0,[R5, #+84]
   \   0000009A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000009E   0x4680             MOV      R8,R0
  13838                  target[X_AXIS] *= ratio;
   \   000000A0   0x6820             LDR      R0,[R4, #+0]
   \   000000A2   0x4641             MOV      R1,R8
   \   000000A4   0x.... 0x....      BL       __aeabi_fmul
   \   000000A8   0x6020             STR      R0,[R4, #+0]
  13839                  target[Y_AXIS] *= ratio;
   \   000000AA   0x6860             LDR      R0,[R4, #+4]
   \   000000AC   0x4641             MOV      R1,R8
   \   000000AE   0x.... 0x....      BL       __aeabi_fmul
   \   000000B2   0x6060             STR      R0,[R4, #+4]
   \   000000B4   0xE020             B.N      ??clamp_to_software_endstops_8
  13840                }
  13841              }
  13842              //#else
  13843              else
  13844              {
  13845          		if(mksCfg.min_software_endstops)
   \                     ??clamp_to_software_endstops_1: (+1)
   \   000000B6   0xF896 0x0020      LDRB     R0,[R6, #+32]
   \   000000BA   0x2800             CMP      R0,#+0
   \   000000BC   0xD00D             BEQ.N    ??clamp_to_software_endstops_9
  13846          		{
  13847                		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
  13848                 	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
   \   000000BE   0x.... 0x....      LDR.W    R2,??DataTable166_3
   \   000000C2   0x6C51             LDR      R1,[R2, #+68]
   \   000000C4   0x6820             LDR      R0,[R4, #+0]
   \   000000C6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000CA   0xD200             BCS.N    ??clamp_to_software_endstops_10
   \   000000CC   0x6021             STR      R1,[R4, #+0]
  13849                		//#endif
  13850                		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
  13851                  	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
   \                     ??clamp_to_software_endstops_10: (+1)
   \   000000CE   0x6C91             LDR      R1,[R2, #+72]
   \   000000D0   0x6860             LDR      R0,[R4, #+4]
   \   000000D2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000D6   0xD200             BCS.N    ??clamp_to_software_endstops_9
   \   000000D8   0x6061             STR      R1,[R4, #+4]
  13852                		//#endif
  13853          		}
  13854          		if(mksCfg.max_software_endstops)
   \                     ??clamp_to_software_endstops_9: (+1)
   \   000000DA   0x7878             LDRB     R0,[R7, #+1]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD00B             BEQ.N    ??clamp_to_software_endstops_8
  13855          		{	
  13856                		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
  13857                  	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
   \   000000E0   0x6A68             LDR      R0,[R5, #+36]
   \   000000E2   0x6821             LDR      R1,[R4, #+0]
   \   000000E4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E8   0xD200             BCS.N    ??clamp_to_software_endstops_11
   \   000000EA   0x6020             STR      R0,[R4, #+0]
  13858                		//#endif
  13859                		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
  13860                  	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
   \                     ??clamp_to_software_endstops_11: (+1)
   \   000000EC   0x6AA8             LDR      R0,[R5, #+40]
   \   000000EE   0x6861             LDR      R1,[R4, #+4]
   \   000000F0   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000F4   0xD200             BCS.N    ??clamp_to_software_endstops_8
   \   000000F6   0x6060             STR      R0,[R4, #+4]
  13861                		//#endif
  13862          		}
  13863              }
  13864              //#endif
  13865          	if(mksCfg.min_software_endstops)
   \                     ??clamp_to_software_endstops_8: (+1)
   \   000000F8   0xF896 0x0020      LDRB     R0,[R6, #+32]
   \   000000FC   0x2800             CMP      R0,#+0
   \   000000FE   0xD007             BEQ.N    ??clamp_to_software_endstops_12
  13866          	{
  13867              //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
  13868                NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
   \   00000100   0x.... 0x....      LDR.W    R2,??DataTable166_3
   \   00000104   0x6CD1             LDR      R1,[R2, #+76]
   \   00000106   0x68A0             LDR      R0,[R4, #+8]
   \   00000108   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010C   0xD200             BCS.N    ??clamp_to_software_endstops_12
   \   0000010E   0x60A1             STR      R1,[R4, #+8]
  13869              //#endif
  13870          	}
  13871          	if(mksCfg.max_software_endstops)
   \                     ??clamp_to_software_endstops_12: (+1)
   \   00000110   0x7878             LDRB     R0,[R7, #+1]
   \   00000112   0x2800             CMP      R0,#+0
   \   00000114   0xD005             BEQ.N    ??clamp_to_software_endstops_0
  13872          	{
  13873              //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
  13874                NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
   \   00000116   0x6AE8             LDR      R0,[R5, #+44]
   \   00000118   0x68A1             LDR      R1,[R4, #+8]
   \   0000011A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000011E   0xD200             BCS.N    ??clamp_to_software_endstops_0
   \   00000120   0x60A0             STR      R0,[R4, #+8]
  13875              //#endif
  13876          	}
  13877            }
   \                     ??clamp_to_software_endstops_0: (+1)
   \   00000122   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  13878          
  13879          #endif
  13880          
  13881          #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
  13882          
  13883            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
  13884              #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
  13885              #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
  13886              #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
  13887              #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
  13888              #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
  13889            #else
  13890              #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
  13891              #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
  13892              #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
  13893              #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
  13894              #define ABL_BG_GRID(X,Y)  z_values[X][Y]
  13895            #endif
  13896          
  13897            // Get the Z adjustment for non-linear bed leveling

   \                                 In section .text, align 2, keep-with-next
  13898            float bilinear_z_offset(const float raw[XYZ]) {
   \                     _Z17bilinear_z_offsetPKf: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4605             MOV      R5,R0
  13899          
  13900              static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
  13901                           last_x = -999.999, last_y = -999.999;
  13902          
  13903              // Whole units for the grid line indices. Constrained within bounds.
  13904              static int8_t gridx, gridy, nextx, nexty,
  13905                            last_gridx = -99, last_gridy = -99;
  13906          
  13907              // XY relative to the probed area
  13908              const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable161_1
   \   0000000A   0x69A0             LDR      R0,[R4, #+24]
   \   0000000C   0x.... 0x....      BL       __aeabi_i2f
   \   00000010   0x4601             MOV      R1,R0
   \   00000012   0x6828             LDR      R0,[R5, #+0]
   \   00000014   0x.... 0x....      BL       __aeabi_fsub
   \   00000018   0x4606             MOV      R6,R0
  13909                          ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
   \   0000001A   0x69E0             LDR      R0,[R4, #+28]
   \   0000001C   0x.... 0x....      BL       __aeabi_i2f
   \   00000020   0x4601             MOV      R1,R0
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x.... 0x....      BL       __aeabi_fsub
   \   00000028   0x4605             MOV      R5,R0
  13910          
  13911              #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
  13912                // Keep using the last grid box
  13913                #define FAR_EDGE_OR_BOX 2
  13914              #else
  13915                // Just use the grid far edge
  13916                #define FAR_EDGE_OR_BOX 1
  13917              #endif
  13918          
  13919              if (last_x != rx) {
   \   0000002A   0x6E20             LDR      R0,[R4, #+96]
   \   0000002C   0x4631             MOV      R1,R6
   \   0000002E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000032   0xD03B             BEQ.N    ??bilinear_z_offset_0
  13920                last_x = rx;
   \   00000034   0x6626             STR      R6,[R4, #+96]
  13921                ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
   \   00000036   0x6A20             LDR      R0,[R4, #+32]
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x4607             MOV      R7,R0
   \   0000003E   0x65A7             STR      R7,[R4, #+88]
  13922                const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
   \   00000040   0x.... 0x....      LDR.W    R6,??DataTable166_5
   \   00000044   0x.... 0x....      BL       floorf
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000004E   0xD201             BCS.N    ??bilinear_z_offset_1
   \   00000050   0x4688             MOV      R8,R1
   \   00000052   0xE011             B.N      ??bilinear_z_offset_2
   \                     ??bilinear_z_offset_1: (+1)
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       floorf
   \   0000005A   0x4681             MOV      R9,R0
   \   0000005C   0xF896 0x0060      LDRB     R0,[R6, #+96]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x.... 0x....      BL       __aeabi_i2f
   \   00000066   0x4680             MOV      R8,R0
   \   00000068   0x4649             MOV      R1,R9
   \   0000006A   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000006E   0xD303             BCC.N    ??bilinear_z_offset_2
   \   00000070   0x4638             MOV      R0,R7
   \   00000072   0x.... 0x....      BL       floorf
   \   00000076   0x4680             MOV      R8,R0
  13923                ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
   \                     ??bilinear_z_offset_2: (+1)
   \   00000078   0x4638             MOV      R0,R7
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x.... 0x....      BL       __aeabi_fsub
   \   00000080   0x65A0             STR      R0,[R4, #+88]
  13924          
  13925                #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  13926                  // Beyond the grid maintain height at grid edges
  13927                  NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
   \   00000082   0x2100             MOVS     R1,#+0
   \   00000084   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000088   0xD201             BCS.N    ??bilinear_z_offset_3
   \   0000008A   0x4608             MOV      R0,R1
   \   0000008C   0x65A0             STR      R0,[R4, #+88]
  13928                #endif
  13929          
  13930                gridx = gx;
                             ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??bilinear_z_offset_3: (+1)
   \   0000008E   0x4640             MOV      R0,R8
   \   00000090   0x.... 0x....      BL       __aeabi_f2iz
   \   00000094   0x72A0             STRB     R0,[R4, #+10]
  13931                nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
   \   00000096   0xF896 0x1060      LDRB     R1,[R6, #+96]
   \   0000009A   0xB240             SXTB     R0,R0
   \   0000009C   0x1C42             ADDS     R2,R0,#+1
   \   0000009E   0x1E4B             SUBS     R3,R1,#+1
   \   000000A0   0x429A             CMP      R2,R3
   \   000000A2   0xDA01             BGE.N    ??bilinear_z_offset_4
   \   000000A4   0x1C40             ADDS     R0,R0,#+1
   \   000000A6   0xE000             B.N      ??bilinear_z_offset_5
   \                     ??bilinear_z_offset_4: (+1)
   \   000000A8   0x1E48             SUBS     R0,R1,#+1
   \                     ??bilinear_z_offset_5: (+1)
   \   000000AA   0x7320             STRB     R0,[R4, #+12]
  13932              }
  13933          
  13934              if (last_y != ry || last_gridx != gridx) {
   \                     ??bilinear_z_offset_0: (+1)
   \   000000AC   0x6E62             LDR      R2,[R4, #+100]
   \   000000AE   0x4610             MOV      R0,R2
   \   000000B0   0x4629             MOV      R1,R5
   \   000000B2   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000B6   0xD106             BNE.N    ??bilinear_z_offset_6
   \   000000B8   0xF994 0x000E      LDRSB    R0,[R4, #+14]
   \   000000BC   0xF994 0x100A      LDRSB    R1,[R4, #+10]
   \   000000C0   0x4288             CMP      R0,R1
   \   000000C2   0xF000 0x8083      BEQ.W    ??bilinear_z_offset_7
  13935          
  13936                if (last_y != ry) {
   \                     ??bilinear_z_offset_6: (+1)
   \   000000C6   0x4610             MOV      R0,R2
   \   000000C8   0x4629             MOV      R1,R5
   \   000000CA   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   000000CE   0xD03F             BEQ.N    ??bilinear_z_offset_8
  13937                  last_y = ry;
   \   000000D0   0x6665             STR      R5,[R4, #+100]
  13938                  ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
   \   000000D2   0x6A60             LDR      R0,[R4, #+36]
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x4605             MOV      R5,R0
   \   000000DA   0x65E5             STR      R5,[R4, #+92]
  13939                  const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
   \   000000DC   0x.... 0x....      BL       floorf
   \   000000E0   0x2100             MOVS     R1,#+0
   \   000000E2   0x.... 0x....      BL       __aeabi_cfcmple
   \   000000E6   0xD201             BCS.N    ??bilinear_z_offset_9
   \   000000E8   0x460E             MOV      R6,R1
   \   000000EA   0xE014             B.N      ??bilinear_z_offset_10
   \                     ??bilinear_z_offset_9: (+1)
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x.... 0x....      BL       floorf
   \   000000F2   0x4607             MOV      R7,R0
   \   000000F4   0x.... 0x....      LDR.W    R6,??DataTable166_5
   \   000000F8   0xF106 0x0160      ADD      R1,R6,#+96
   \   000000FC   0x7848             LDRB     R0,[R1, #+1]
   \   000000FE   0x1E40             SUBS     R0,R0,#+1
   \   00000100   0x.... 0x....      BL       __aeabi_i2f
   \   00000104   0x4606             MOV      R6,R0
   \   00000106   0x4639             MOV      R1,R7
   \   00000108   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000010C   0xD303             BCC.N    ??bilinear_z_offset_10
   \   0000010E   0x4628             MOV      R0,R5
   \   00000110   0x.... 0x....      BL       floorf
   \   00000114   0x4606             MOV      R6,R0
  13940                  ratio_y -= gy;
   \                     ??bilinear_z_offset_10: (+1)
   \   00000116   0x4628             MOV      R0,R5
   \   00000118   0x4631             MOV      R1,R6
   \   0000011A   0x.... 0x....      BL       __aeabi_fsub
   \   0000011E   0x65E0             STR      R0,[R4, #+92]
  13941          
  13942                  #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
  13943                    // Beyond the grid maintain height at grid edges
  13944                    NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000126   0xD201             BCS.N    ??bilinear_z_offset_11
   \   00000128   0x4608             MOV      R0,R1
   \   0000012A   0x65E0             STR      R0,[R4, #+92]
  13945                  #endif
  13946          
  13947                  gridy = gy;
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??bilinear_z_offset_11: (+1)
   \   0000012C   0x4630             MOV      R0,R6
   \   0000012E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000132   0x72E0             STRB     R0,[R4, #+11]
  13948                  nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
   \   00000134   0x.... 0x....      LDR.W    R6,??DataTable166_5
   \   00000138   0xF106 0x0160      ADD      R1,R6,#+96
   \   0000013C   0x7849             LDRB     R1,[R1, #+1]
   \   0000013E   0xB240             SXTB     R0,R0
   \   00000140   0x1C42             ADDS     R2,R0,#+1
   \   00000142   0x1E4B             SUBS     R3,R1,#+1
   \   00000144   0x429A             CMP      R2,R3
   \   00000146   0xDA01             BGE.N    ??bilinear_z_offset_12
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   \   0000014A   0xE000             B.N      ??bilinear_z_offset_13
   \                     ??bilinear_z_offset_12: (+1)
   \   0000014C   0x1E48             SUBS     R0,R1,#+1
   \                     ??bilinear_z_offset_13: (+1)
   \   0000014E   0x7360             STRB     R0,[R4, #+13]
  13949                }
  13950          
  13951                if (last_gridx != gridx || last_gridy != gridy) {
   \                     ??bilinear_z_offset_8: (+1)
   \   00000150   0xF994 0x500B      LDRSB    R5,[R4, #+11]
   \   00000154   0xF994 0x000A      LDRSB    R0,[R4, #+10]
   \   00000158   0xF994 0x100E      LDRSB    R1,[R4, #+14]
   \   0000015C   0x4281             CMP      R1,R0
   \   0000015E   0xD103             BNE.N    ??bilinear_z_offset_14
   \   00000160   0xF994 0x100F      LDRSB    R1,[R4, #+15]
   \   00000164   0x42A9             CMP      R1,R5
   \   00000166   0xD01C             BEQ.N    ??bilinear_z_offset_15
  13952                  last_gridx = gridx;
   \                     ??bilinear_z_offset_14: (+1)
   \   00000168   0x73A0             STRB     R0,[R4, #+14]
  13953                  last_gridy = gridy;
   \   0000016A   0x73E5             STRB     R5,[R4, #+15]
  13954                  // Z at the box corners
  13955                  z1 = ABL_BG_GRID(gridx, gridy);       // left-front
   \   0000016C   0x2730             MOVS     R7,#+48
   \   0000016E   0x.... 0x....      LDR.W    R8,??DataTable168
   \   00000172   0xFB07 0x8000      MLA      R0,R7,R0,R8
   \   00000176   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \   0000017A   0x6421             STR      R1,[R4, #+64]
   \   0000017C   0xF994 0x600D      LDRSB    R6,[R4, #+13]
   \   00000180   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   00000184   0x.... 0x....      BL       __aeabi_fsub
   \   00000188   0x6460             STR      R0,[R4, #+68]
  13956                  d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
  13957                  z3 = ABL_BG_GRID(nextx, gridy);       // right-front
   \   0000018A   0xF994 0x000C      LDRSB    R0,[R4, #+12]
   \   0000018E   0xFB07 0x8000      MLA      R0,R7,R0,R8
   \   00000192   0xF850 0x1025      LDR      R1,[R0, R5, LSL #+2]
   \   00000196   0x64A1             STR      R1,[R4, #+72]
  13958                  d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
   \   00000198   0xF850 0x0026      LDR      R0,[R0, R6, LSL #+2]
   \   0000019C   0x.... 0x....      BL       __aeabi_fsub
   \   000001A0   0x64E0             STR      R0,[R4, #+76]
  13959                }
  13960          
  13961                // Bilinear interpolate. Needed since ry or gridx has changed.
  13962                            L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
   \                     ??bilinear_z_offset_15: (+1)
   \   000001A2   0x6DE5             LDR      R5,[R4, #+92]
   \   000001A4   0x6C60             LDR      R0,[R4, #+68]
   \   000001A6   0x4629             MOV      R1,R5
   \   000001A8   0x.... 0x....      BL       __aeabi_fmul
   \   000001AC   0x6C21             LDR      R1,[R4, #+64]
   \   000001AE   0x.... 0x....      BL       __aeabi_fadd
   \   000001B2   0x4606             MOV      R6,R0
   \   000001B4   0x6526             STR      R6,[R4, #+80]
  13963                const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
  13964          
  13965                D = R - L;
   \   000001B6   0x6CE0             LDR      R0,[R4, #+76]
   \   000001B8   0x4629             MOV      R1,R5
   \   000001BA   0x.... 0x....      BL       __aeabi_fmul
   \   000001BE   0x6CA1             LDR      R1,[R4, #+72]
   \   000001C0   0x.... 0x....      BL       __aeabi_fadd
   \   000001C4   0x4631             MOV      R1,R6
   \   000001C6   0x.... 0x....      BL       __aeabi_fsub
   \   000001CA   0x6560             STR      R0,[R4, #+84]
  13966              }
  13967          
  13968              const float offset = L + ratio_x * D;   // the offset almost always changes
  13969          
  13970              /*
  13971              static float last_offset = 0;
  13972              if (FABS(last_offset - offset) > 0.2) {
  13973                SERIAL_ECHOPGM("Sudden Shift at ");
  13974                SERIAL_ECHOPAIR("x=", rx);
  13975                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
  13976                SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
  13977                SERIAL_ECHOPAIR(" y=", ry);
  13978                SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
  13979                SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
  13980                SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
  13981                SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
  13982                SERIAL_ECHOPAIR(" z1=", z1);
  13983                SERIAL_ECHOPAIR(" z2=", z2);
  13984                SERIAL_ECHOPAIR(" z3=", z3);
  13985                SERIAL_ECHOLNPAIR(" z4=", z4);
  13986                SERIAL_ECHOPAIR(" L=", L);
  13987                SERIAL_ECHOPAIR(" R=", R);
  13988                SERIAL_ECHOLNPAIR(" offset=", offset);
  13989              }
  13990              last_offset = offset;
  13991              //*/
                      ^
Warning[Pe009]: nested comment is not allowed
  13992          
  13993              return offset;
   \                     ??bilinear_z_offset_7: (+1)
   \   000001CC   0x6DA1             LDR      R1,[R4, #+88]
   \   000001CE   0x6D60             LDR      R0,[R4, #+84]
   \   000001D0   0x.... 0x....      BL       __aeabi_fmul
   \   000001D4   0x6D21             LDR      R1,[R4, #+80]
   \   000001D6   0xE8BD 0x43F4      POP      {R2,R4-R9,LR}
   \   000001DA   0x.... 0x....      B.W      __aeabi_fadd
  13994            }

   \                                 In section .data, align 4
   \                     axis_relative_modes:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     Running:
   \   00000004   0x01               DC8 1
   \   00000005   0x00               DC8 0
   \                     busy_state:
   \   00000006   0x00               DC8 0
   \                     host_keepalive_interval:
   \   00000007   0x02               DC8 2
   \                     serial_wait_tick:
   \   00000008   0x00               DC8 0
   \                     from_wifi_flag:
   \   00000009   0x00               DC8 0
   \   0000000A   0x00               DC8 0
   \   0000000B   0x00               DC8 0
   \   0000000C   0x00               DC8 0
   \   0000000D   0x00               DC8 0
   \   0000000E   0x9D               DC8 -99
   \   0000000F   0x9D               DC8 -99
   \                     bilinear_grid_spacing:
   \   00000010   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     bilinear_start:
   \   00000018   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     bilinear_grid_factor:
   \   00000020   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000030   0x00000000         DC32 0
   \   00000034   0x00000000         DC32 0
   \   00000038   0x00000000         DC32 0
   \   0000003C   0x00000000         DC32 0
   \   00000040   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000044   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000048   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000050   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000005C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   00000060   0xC479FFF0         DC32 0C479FFF0H
   \   00000064   0xC479FFF0         DC32 0C479FFF0H

   \                                 In section .data, align 4
   \                     axis_homed:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     axis_known_position:
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     soft_endstops_enabled:
   \   00000008   0x01               DC8 1
   \                     lcd_wait_for_move:
   \   00000009   0x00               DC8 0
   \   0000000A   0x00 0x00          DC8 0, 0
   \                     delta_tower:
   \   0000000C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000001C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_max:
   \   00000024   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta_tower_angle_trim:
   \   00000030   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     delta_diagonal_rod_2_tower:
   \   0000003C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     cartes:
   \   00000048   0x00000000         DC32 0H
   \   0000004C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \                     soft_endstop_radius:
   \   00000054   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     soft_endstop_radius_2:
   \   00000058   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     previous_cmd_ms:
   \   0000005C   0x00000000         DC32 0
   \   00000060   0x00000000         DC32 0
   \   00000064   0x0001D4C0         DC32 120000
   \                     delta_radius:
   \   00000068   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_diagonal_rod:
   \   0000006C   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_calibration_radius:
   \   00000070   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \                     delta_segments_per_second:
   \   00000074   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    

   \                                 In section .data, align 4
   \                     home_bump_mm_P:
   \   00000000   0x40A00000         DC32 40A00000H, 40A00000H, 40A00000H
   \              0x40A00000   
   \              0x40A00000   

   \                                 In section .data, align 4
   \                     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
   \   00000000   0xFFFFFFFF         DC32 -1
  13995          
  13996          #endif // AUTO_BED_LEVELING_BILINEAR
  13997          
  13998          #if 1//ENABLED(DELTA)
  13999          
  14000            /**
  14001             * Recalculate factors used for delta kinematics whenever
  14002             * settings have been changed (e.g., by M665).
  14003             */

   \                                 In section .text, align 2, keep-with-next
  14004            void recalc_delta_settings() {
   \                     _Z21recalc_delta_settingsv: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
  14005              const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
  14006                          drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
  14007              delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
   \   00000004   0x.... 0x....      LDR.W    R8,??DataTable168_1  ;; 0x54442d18
   \   00000008   0x.... 0x....      LDR.W    R9,??DataTable168_2  ;; 0x400921fb
   \   0000000C   0x.... 0x....      LDR.W    R7,??DataTable168_3  ;; 0x43520000
   \   00000010   0x.... 0x....      LDR.W    R6,??DataTable166_4
   \   00000014   0x6B30             LDR      R0,[R6, #+48]
   \   00000016   0x4639             MOV      R1,R7
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x.... 0x....      BL       __aeabi_f2d
   \   00000020   0x4642             MOV      R2,R8
   \   00000022   0x464B             MOV      R3,R9
   \   00000024   0x.... 0x....      BL       __aeabi_dmul
   \   00000028   0x2200             MOVS     R2,#+0
   \   0000002A   0x.... 0x....      LDR.W    R3,??DataTable168_4  ;; 0x40668000
   \   0000002E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000032   0x.... 0x....      BL       cos
   \   00000036   0x4604             MOV      R4,R0
   \   00000038   0x460D             MOV      R5,R1
   \   0000003A   0x6EB1             LDR      R1,[R6, #+104]
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x.... 0x....      BL       __aeabi_fadd
   \   00000042   0x.... 0x....      BL       __aeabi_f2d
   \   00000046   0x4622             MOV      R2,R4
   \   00000048   0x462B             MOV      R3,R5
   \   0000004A   0x.... 0x....      BL       __aeabi_dmul
   \   0000004E   0x.... 0x....      BL       __aeabi_d2f
   \   00000052   0x60F0             STR      R0,[R6, #+12]
  14008              delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
   \   00000054   0x6B30             LDR      R0,[R6, #+48]
   \   00000056   0x4639             MOV      R1,R7
   \   00000058   0x.... 0x....      BL       __aeabi_fadd
   \   0000005C   0x.... 0x....      BL       __aeabi_f2d
   \   00000060   0x4642             MOV      R2,R8
   \   00000062   0x464B             MOV      R3,R9
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x2200             MOVS     R2,#+0
   \   0000006A   0x.... 0x....      LDR.W    R3,??DataTable168_4  ;; 0x40668000
   \   0000006E   0x.... 0x....      BL       __aeabi_ddiv
   \   00000072   0x.... 0x....      BL       sin
   \   00000076   0x4604             MOV      R4,R0
   \   00000078   0x460D             MOV      R5,R1
   \   0000007A   0x6EB1             LDR      R1,[R6, #+104]
   \   0000007C   0x2000             MOVS     R0,#+0
   \   0000007E   0x.... 0x....      BL       __aeabi_fadd
   \   00000082   0x.... 0x....      BL       __aeabi_f2d
   \   00000086   0x4622             MOV      R2,R4
   \   00000088   0x462B             MOV      R3,R5
   \   0000008A   0x.... 0x....      BL       __aeabi_dmul
   \   0000008E   0x.... 0x....      BL       __aeabi_d2f
   \   00000092   0x6130             STR      R0,[R6, #+16]
  14009              delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
   \   00000094   0x.... 0x....      LDR.W    R7,??DataTable168_5  ;; 0x43a50000
   \   00000098   0x6B70             LDR      R0,[R6, #+52]
   \   0000009A   0x4639             MOV      R1,R7
   \   0000009C   0x.... 0x....      BL       __aeabi_fadd
   \   000000A0   0x.... 0x....      BL       __aeabi_f2d
   \   000000A4   0x4642             MOV      R2,R8
   \   000000A6   0x464B             MOV      R3,R9
   \   000000A8   0x.... 0x....      BL       __aeabi_dmul
   \   000000AC   0x2200             MOVS     R2,#+0
   \   000000AE   0x.... 0x....      LDR.W    R3,??DataTable168_4  ;; 0x40668000
   \   000000B2   0x.... 0x....      BL       __aeabi_ddiv
   \   000000B6   0x.... 0x....      BL       cos
   \   000000BA   0x4604             MOV      R4,R0
   \   000000BC   0x460D             MOV      R5,R1
   \   000000BE   0x6EB1             LDR      R1,[R6, #+104]
   \   000000C0   0x2000             MOVS     R0,#+0
   \   000000C2   0x.... 0x....      BL       __aeabi_fadd
   \   000000C6   0x.... 0x....      BL       __aeabi_f2d
   \   000000CA   0x4622             MOV      R2,R4
   \   000000CC   0x462B             MOV      R3,R5
   \   000000CE   0x.... 0x....      BL       __aeabi_dmul
   \   000000D2   0x.... 0x....      BL       __aeabi_d2f
   \   000000D6   0x6170             STR      R0,[R6, #+20]
  14010              delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
   \   000000D8   0x6B70             LDR      R0,[R6, #+52]
   \   000000DA   0x4639             MOV      R1,R7
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x.... 0x....      BL       __aeabi_f2d
   \   000000E4   0x4642             MOV      R2,R8
   \   000000E6   0x464B             MOV      R3,R9
   \   000000E8   0x.... 0x....      BL       __aeabi_dmul
   \   000000EC   0x2200             MOVS     R2,#+0
   \   000000EE   0x.... 0x....      LDR.W    R3,??DataTable168_4  ;; 0x40668000
   \   000000F2   0x.... 0x....      BL       __aeabi_ddiv
   \   000000F6   0x.... 0x....      BL       sin
   \   000000FA   0x4604             MOV      R4,R0
   \   000000FC   0x460D             MOV      R5,R1
   \   000000FE   0x6EB1             LDR      R1,[R6, #+104]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x.... 0x....      BL       __aeabi_fadd
   \   00000106   0x.... 0x....      BL       __aeabi_f2d
   \   0000010A   0x4622             MOV      R2,R4
   \   0000010C   0x462B             MOV      R3,R5
   \   0000010E   0x.... 0x....      BL       __aeabi_dmul
   \   00000112   0x.... 0x....      BL       __aeabi_d2f
   \   00000116   0x61B0             STR      R0,[R6, #+24]
  14011              delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
   \   00000118   0x.... 0x....      LDR.W    R7,??DataTable169  ;; 0x42b40000
   \   0000011C   0x6BB0             LDR      R0,[R6, #+56]
   \   0000011E   0x4639             MOV      R1,R7
   \   00000120   0x.... 0x....      BL       __aeabi_fadd
   \   00000124   0x.... 0x....      BL       __aeabi_f2d
   \   00000128   0x4642             MOV      R2,R8
   \   0000012A   0x464B             MOV      R3,R9
   \   0000012C   0x.... 0x....      BL       __aeabi_dmul
   \   00000130   0x2200             MOVS     R2,#+0
   \   00000132   0x.... 0x....      LDR.W    R3,??DataTable168_4  ;; 0x40668000
   \   00000136   0x.... 0x....      BL       __aeabi_ddiv
   \   0000013A   0x.... 0x....      BL       cos
   \   0000013E   0x4604             MOV      R4,R0
   \   00000140   0x460D             MOV      R5,R1
   \   00000142   0x6EB1             LDR      R1,[R6, #+104]
   \   00000144   0x2000             MOVS     R0,#+0
   \   00000146   0x.... 0x....      BL       __aeabi_fadd
   \   0000014A   0x.... 0x....      BL       __aeabi_f2d
   \   0000014E   0x4622             MOV      R2,R4
   \   00000150   0x462B             MOV      R3,R5
   \   00000152   0x.... 0x....      BL       __aeabi_dmul
   \   00000156   0x.... 0x....      BL       __aeabi_d2f
   \   0000015A   0x61F0             STR      R0,[R6, #+28]
  14012              delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
   \   0000015C   0x6BB0             LDR      R0,[R6, #+56]
   \   0000015E   0x4639             MOV      R1,R7
   \   00000160   0x.... 0x....      BL       __aeabi_fadd
   \   00000164   0x.... 0x....      BL       __aeabi_f2d
   \   00000168   0x4642             MOV      R2,R8
   \   0000016A   0x464B             MOV      R3,R9
   \   0000016C   0x.... 0x....      BL       __aeabi_dmul
   \   00000170   0x2200             MOVS     R2,#+0
   \   00000172   0x.... 0x....      LDR.W    R3,??DataTable168_4  ;; 0x40668000
   \   00000176   0x.... 0x....      BL       __aeabi_ddiv
   \   0000017A   0x.... 0x....      BL       sin
   \   0000017E   0x4604             MOV      R4,R0
   \   00000180   0x460D             MOV      R5,R1
   \   00000182   0x6EB1             LDR      R1,[R6, #+104]
   \   00000184   0x2000             MOVS     R0,#+0
   \   00000186   0x.... 0x....      BL       __aeabi_fadd
   \   0000018A   0x.... 0x....      BL       __aeabi_f2d
   \   0000018E   0x4622             MOV      R2,R4
   \   00000190   0x462B             MOV      R3,R5
   \   00000192   0x.... 0x....      BL       __aeabi_dmul
   \   00000196   0x.... 0x....      BL       __aeabi_d2f
   \   0000019A   0x6230             STR      R0,[R6, #+32]
  14013              delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
   \   0000019C   0x6EF1             LDR      R1,[R6, #+108]
   \   0000019E   0x2000             MOVS     R0,#+0
   \   000001A0   0x.... 0x....      BL       __aeabi_fadd
   \   000001A4   0x4604             MOV      R4,R0
   \   000001A6   0x4627             MOV      R7,R4
   \   000001A8   0xF04F 0x0802      MOV      R8,#+2
   \   000001AC   0xF04F 0x557E      MOV      R5,#+1065353216
   \   000001B0   0x46A9             MOV      R9,R5
   \   000001B2   0xE004             B.N      ??recalc_delta_settings_0
   \                     ??recalc_delta_settings_1: (+1)
   \   000001B4   0x4638             MOV      R0,R7
   \   000001B6   0x4639             MOV      R1,R7
   \   000001B8   0x.... 0x....      BL       __aeabi_fmul
   \   000001BC   0x4607             MOV      R7,R0
   \                     ??recalc_delta_settings_0: (+1)
   \   000001BE   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000001C2   0xD504             BPL.N    ??recalc_delta_settings_2
   \   000001C4   0x4648             MOV      R0,R9
   \   000001C6   0x4639             MOV      R1,R7
   \   000001C8   0x.... 0x....      BL       __aeabi_fmul
   \   000001CC   0x4681             MOV      R9,R0
   \                     ??recalc_delta_settings_2: (+1)
   \   000001CE   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   000001D2   0xD1EF             BNE.N    ??recalc_delta_settings_1
   \   000001D4   0xF8C6 0x903C      STR      R9,[R6, #+60]
  14014              delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
   \   000001D8   0x4627             MOV      R7,R4
   \   000001DA   0xF04F 0x0802      MOV      R8,#+2
   \   000001DE   0x46A9             MOV      R9,R5
   \   000001E0   0xE004             B.N      ??recalc_delta_settings_3
   \                     ??recalc_delta_settings_4: (+1)
   \   000001E2   0x4638             MOV      R0,R7
   \   000001E4   0x4639             MOV      R1,R7
   \   000001E6   0x.... 0x....      BL       __aeabi_fmul
   \   000001EA   0x4607             MOV      R7,R0
   \                     ??recalc_delta_settings_3: (+1)
   \   000001EC   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000001F0   0xD504             BPL.N    ??recalc_delta_settings_5
   \   000001F2   0x4648             MOV      R0,R9
   \   000001F4   0x4639             MOV      R1,R7
   \   000001F6   0x.... 0x....      BL       __aeabi_fmul
   \   000001FA   0x4681             MOV      R9,R0
   \                     ??recalc_delta_settings_5: (+1)
   \   000001FC   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000200   0xD1EF             BNE.N    ??recalc_delta_settings_4
   \   00000202   0xF8C6 0x9040      STR      R9,[R6, #+64]
  14015              delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
   \   00000206   0x2702             MOVS     R7,#+2
   \   00000208   0xE004             B.N      ??recalc_delta_settings_6
   \                     ??recalc_delta_settings_7: (+1)
   \   0000020A   0x4620             MOV      R0,R4
   \   0000020C   0x4621             MOV      R1,R4
   \   0000020E   0x.... 0x....      BL       __aeabi_fmul
   \   00000212   0x4604             MOV      R4,R0
   \                     ??recalc_delta_settings_6: (+1)
   \   00000214   0x07F8             LSLS     R0,R7,#+31
   \   00000216   0xD504             BPL.N    ??recalc_delta_settings_8
   \   00000218   0x4628             MOV      R0,R5
   \   0000021A   0x4621             MOV      R1,R4
   \   0000021C   0x.... 0x....      BL       __aeabi_fmul
   \   00000220   0x4605             MOV      R5,R0
   \                     ??recalc_delta_settings_8: (+1)
   \   00000222   0x087F             LSRS     R7,R7,#+1
   \   00000224   0xD1F1             BNE.N    ??recalc_delta_settings_7
   \   00000226   0x6475             STR      R5,[R6, #+68]
  14016              update_software_endstops(Z_AXIS);
   \   00000228   0x2002             MOVS     R0,#+2
   \   0000022A   0x.... 0x....      BL       _Z24update_software_endstops8AxisEnum
  14017              axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
   \   0000022E   0x2000             MOVS     R0,#+0
   \   00000230   0x70B0             STRB     R0,[R6, #+2]
   \   00000232   0x8030             STRH     R0,[R6, #+0]
  14018            }
   \   00000234   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return
  14019          
  14020            #if ENABLED(DELTA_FAST_SQRT)
  14021              /**
  14022               * Fast inverse sqrt from Quake III Arena
  14023               * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
  14024               */
  14025              float Q_rsqrt(const float number) {
  14026                long i;
  14027                float x2, y;
  14028                const float threehalfs = 1.5f;
  14029                x2 = number * 0.5f;
  14030                y  = number;
  14031                i  = * ( long * ) &y;                       // evil floating point bit level hacking
  14032                i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
  14033                y  = * ( float * ) &i;
  14034                y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
  14035                // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
  14036                return y;
  14037              }
  14038          
  14039            #endif
  14040          
  14041            /**
  14042             * Delta Inverse Kinematics
  14043             *
  14044             * Calculate the tower positions for a given machine
  14045             * position, storing the result in the delta[] array.
  14046             *
  14047             * This is an expensive calculation, requiring 3 square
  14048             * roots per segmented linear move, and strains the limits
  14049             * of a Mega2560 with a Graphical Display.
  14050             *
  14051             * Suggested optimizations include:
  14052             *
  14053             * - Disable the home_offset (M206) and/or position_shift (G92)
  14054             *   features to remove up to 12 float additions.
  14055             *
  14056             * - Use a fast-inverse-sqrt function and add the reciprocal.
  14057             *   (see above)
  14058             */
  14059          
  14060            #define DELTA_DEBUG() do { \
  14061                SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \
  14062                SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \
  14063                SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \
  14064                SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \
  14065                SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \
  14066                SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \
  14067              }while(0)
  14068          

   \                                 In section .text, align 2, keep-with-next
  14069            void inverse_kinematics(const float raw[XYZ]) {
   \                     _Z18inverse_kinematicsPKf: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4605             MOV      R5,R0
  14070              DELTA_IK(raw);
   \   00000006   0x.... 0x....      LDR.W    R6,??DataTable166_4
   \   0000000A   0x68F0             LDR      R0,[R6, #+12]
   \   0000000C   0x6829             LDR      R1,[R5, #+0]
   \   0000000E   0x.... 0x....      BL       __aeabi_fsub
   \   00000012   0x4680             MOV      R8,R0
   \   00000014   0xF04F 0x0902      MOV      R9,#+2
   \   00000018   0xF04F 0x547E      MOV      R4,#+1065353216
   \   0000001C   0x4627             MOV      R7,R4
   \   0000001E   0xE004             B.N      ??inverse_kinematics_0
   \                     ??inverse_kinematics_1: (+1)
   \   00000020   0x4640             MOV      R0,R8
   \   00000022   0x4641             MOV      R1,R8
   \   00000024   0x.... 0x....      BL       __aeabi_fmul
   \   00000028   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_0: (+1)
   \   0000002A   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000002E   0xD504             BPL.N    ??inverse_kinematics_2
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x4641             MOV      R1,R8
   \   00000034   0x.... 0x....      BL       __aeabi_fmul
   \   00000038   0x4607             MOV      R7,R0
   \                     ??inverse_kinematics_2: (+1)
   \   0000003A   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000003E   0xD1EF             BNE.N    ??inverse_kinematics_1
   \   00000040   0x6930             LDR      R0,[R6, #+16]
   \   00000042   0x6869             LDR      R1,[R5, #+4]
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0x4680             MOV      R8,R0
   \   0000004A   0xF04F 0x0902      MOV      R9,#+2
   \   0000004E   0x46A2             MOV      R10,R4
   \   00000050   0xE004             B.N      ??inverse_kinematics_3
   \                     ??inverse_kinematics_4: (+1)
   \   00000052   0x4640             MOV      R0,R8
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_3: (+1)
   \   0000005C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000060   0xD504             BPL.N    ??inverse_kinematics_5
   \   00000062   0x4650             MOV      R0,R10
   \   00000064   0x4641             MOV      R1,R8
   \   00000066   0x.... 0x....      BL       __aeabi_fmul
   \   0000006A   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_5: (+1)
   \   0000006C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000070   0xD1EF             BNE.N    ??inverse_kinematics_4
   \   00000072   0x4638             MOV      R0,R7
   \   00000074   0x4651             MOV      R1,R10
   \   00000076   0x.... 0x....      BL       __aeabi_fadd
   \   0000007A   0x4601             MOV      R1,R0
   \   0000007C   0x6BF0             LDR      R0,[R6, #+60]
   \   0000007E   0x.... 0x....      BL       __aeabi_fsub
   \   00000082   0x.... 0x....      BL       sqrtf
   \   00000086   0x.... 0x....      LDR.W    R7,??DataTable166_3
   \   0000008A   0x68A9             LDR      R1,[R5, #+8]
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x6538             STR      R0,[R7, #+80]
   \   00000092   0x6970             LDR      R0,[R6, #+20]
   \   00000094   0x6829             LDR      R1,[R5, #+0]
   \   00000096   0x.... 0x....      BL       __aeabi_fsub
   \   0000009A   0x4681             MOV      R9,R0
   \   0000009C   0xF04F 0x0A02      MOV      R10,#+2
   \   000000A0   0x46A0             MOV      R8,R4
   \   000000A2   0xE004             B.N      ??inverse_kinematics_6
   \                     ??inverse_kinematics_7: (+1)
   \   000000A4   0x4648             MOV      R0,R9
   \   000000A6   0x4649             MOV      R1,R9
   \   000000A8   0x.... 0x....      BL       __aeabi_fmul
   \   000000AC   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_6: (+1)
   \   000000AE   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000000B2   0xD504             BPL.N    ??inverse_kinematics_8
   \   000000B4   0x4640             MOV      R0,R8
   \   000000B6   0x4649             MOV      R1,R9
   \   000000B8   0x.... 0x....      BL       __aeabi_fmul
   \   000000BC   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_8: (+1)
   \   000000BE   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000000C2   0xD1EF             BNE.N    ??inverse_kinematics_7
   \   000000C4   0x69B0             LDR      R0,[R6, #+24]
   \   000000C6   0x6869             LDR      R1,[R5, #+4]
   \   000000C8   0x.... 0x....      BL       __aeabi_fsub
   \   000000CC   0x4683             MOV      R11,R0
   \   000000CE   0xF04F 0x0902      MOV      R9,#+2
   \   000000D2   0x46A2             MOV      R10,R4
   \   000000D4   0xE004             B.N      ??inverse_kinematics_9
   \                     ??inverse_kinematics_10: (+1)
   \   000000D6   0x4658             MOV      R0,R11
   \   000000D8   0x4659             MOV      R1,R11
   \   000000DA   0x.... 0x....      BL       __aeabi_fmul
   \   000000DE   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_9: (+1)
   \   000000E0   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000E4   0xD504             BPL.N    ??inverse_kinematics_11
   \   000000E6   0x4650             MOV      R0,R10
   \   000000E8   0x4659             MOV      R1,R11
   \   000000EA   0x.... 0x....      BL       __aeabi_fmul
   \   000000EE   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_11: (+1)
   \   000000F0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000F4   0xD1EF             BNE.N    ??inverse_kinematics_10
   \   000000F6   0x4640             MOV      R0,R8
   \   000000F8   0x4651             MOV      R1,R10
   \   000000FA   0x.... 0x....      BL       __aeabi_fadd
   \   000000FE   0x4601             MOV      R1,R0
   \   00000100   0x6C30             LDR      R0,[R6, #+64]
   \   00000102   0x.... 0x....      BL       __aeabi_fsub
   \   00000106   0x.... 0x....      BL       sqrtf
   \   0000010A   0x4601             MOV      R1,R0
   \   0000010C   0x68A8             LDR      R0,[R5, #+8]
   \   0000010E   0x.... 0x....      BL       __aeabi_fadd
   \   00000112   0x6578             STR      R0,[R7, #+84]
   \   00000114   0x69F0             LDR      R0,[R6, #+28]
   \   00000116   0x6829             LDR      R1,[R5, #+0]
   \   00000118   0x.... 0x....      BL       __aeabi_fsub
   \   0000011C   0x4681             MOV      R9,R0
   \   0000011E   0xF04F 0x0A02      MOV      R10,#+2
   \   00000122   0x46A0             MOV      R8,R4
   \   00000124   0xE004             B.N      ??inverse_kinematics_12
   \                     ??inverse_kinematics_13: (+1)
   \   00000126   0x4648             MOV      R0,R9
   \   00000128   0x4649             MOV      R1,R9
   \   0000012A   0x.... 0x....      BL       __aeabi_fmul
   \   0000012E   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_12: (+1)
   \   00000130   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000134   0xD504             BPL.N    ??inverse_kinematics_14
   \   00000136   0x4640             MOV      R0,R8
   \   00000138   0x4649             MOV      R1,R9
   \   0000013A   0x.... 0x....      BL       __aeabi_fmul
   \   0000013E   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_14: (+1)
   \   00000140   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000144   0xD1EF             BNE.N    ??inverse_kinematics_13
   \   00000146   0x6A30             LDR      R0,[R6, #+32]
   \   00000148   0x6869             LDR      R1,[R5, #+4]
   \   0000014A   0x.... 0x....      BL       __aeabi_fsub
   \   0000014E   0x4682             MOV      R10,R0
   \   00000150   0xF04F 0x0902      MOV      R9,#+2
   \   00000154   0xE004             B.N      ??inverse_kinematics_15
   \                     ??inverse_kinematics_16: (+1)
   \   00000156   0x4650             MOV      R0,R10
   \   00000158   0x4651             MOV      R1,R10
   \   0000015A   0x.... 0x....      BL       __aeabi_fmul
   \   0000015E   0x4682             MOV      R10,R0
   \                     ??inverse_kinematics_15: (+1)
   \   00000160   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000164   0xD504             BPL.N    ??inverse_kinematics_17
   \   00000166   0x4620             MOV      R0,R4
   \   00000168   0x4651             MOV      R1,R10
   \   0000016A   0x.... 0x....      BL       __aeabi_fmul
   \   0000016E   0x4604             MOV      R4,R0
   \                     ??inverse_kinematics_17: (+1)
   \   00000170   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000174   0xD1EF             BNE.N    ??inverse_kinematics_16
   \   00000176   0x4640             MOV      R0,R8
   \   00000178   0x4621             MOV      R1,R4
   \   0000017A   0x.... 0x....      BL       __aeabi_fadd
   \   0000017E   0x4601             MOV      R1,R0
   \   00000180   0x6C70             LDR      R0,[R6, #+68]
   \   00000182   0x.... 0x....      BL       __aeabi_fsub
   \   00000186   0x.... 0x....      BL       sqrtf
   \   0000018A   0x4601             MOV      R1,R0
   \   0000018C   0x68A8             LDR      R0,[R5, #+8]
   \   0000018E   0x.... 0x....      BL       __aeabi_fadd
   \   00000192   0x65B8             STR      R0,[R7, #+88]
  14071              // DELTA_DEBUG();
  14072            }
   \   00000194   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  14073          
  14074            /**
  14075             * Calculate the highest Z position where the
  14076             * effector has the full range of XY motion.
  14077             */

   \                                 In section .text, align 2, keep-with-next
  14078            float delta_safe_distance_from_top() {
   \                     _Z28delta_safe_distance_from_topv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
  14079              float cartesian[XYZ] = { 0, 0, 0 };
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x2100             MOVS     R1,#+0
   \   00000008   0x460A             MOV      R2,R1
   \   0000000A   0x460B             MOV      R3,R1
   \   0000000C   0xC00E             STM      R0!,{R1-R3}
  14080          	if(MACHINETPYE == MORGAN_SCARA)
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable166_5
   \   00000012   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000016   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0xD102             BNE.N    ??delta_safe_distance_from_top_0
  14081          		inverse_kinematics_MORGAN_SCARA(cartesian);
   \   0000001E   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   00000022   0xE001             B.N      ??delta_safe_distance_from_top_1
  14082          	else
  14083              	inverse_kinematics(cartesian);
   \                     ??delta_safe_distance_from_top_0: (+1)
   \   00000024   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  14084          	
  14085              float distance = delta[A_AXIS];
   \                     ??delta_safe_distance_from_top_1: (+1)
   \   00000028   0x.... 0x....      LDR.W    R5,??DataTable166_3
   \   0000002C   0x6D2E             LDR      R6,[R5, #+80]
  14086              cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
   \   0000002E   0x6D60             LDR      R0,[R4, #+84]
   \   00000030   0x9001             STR      R0,[SP, #+4]
  14087          	if(MACHINETPYE == MORGAN_SCARA)
   \   00000032   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000036   0xF5B0 0x7F80      CMP      R0,#+256
   \   0000003A   0xA800             ADD      R0,SP,#+0
   \   0000003C   0xD102             BNE.N    ??delta_safe_distance_from_top_2
  14088          		inverse_kinematics_MORGAN_SCARA(cartesian);
   \   0000003E   0x.... 0x....      BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
   \   00000042   0xE001             B.N      ??delta_safe_distance_from_top_3
  14089          	else
  14090              	inverse_kinematics(cartesian);
   \                     ??delta_safe_distance_from_top_2: (+1)
   \   00000044   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
  14091              return FABS(distance - delta[A_AXIS]);
   \                     ??delta_safe_distance_from_top_3: (+1)
   \   00000048   0x4630             MOV      R0,R6
   \   0000004A   0x6D29             LDR      R1,[R5, #+80]
   \   0000004C   0x.... 0x....      BL       __aeabi_fsub
   \   00000050   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000054   0xB004             ADD      SP,SP,#+16
   \   00000056   0xBD70             POP      {R4-R6,PC}       ;; return
  14092            }
  14093          
  14094            /**
  14095             * Delta Forward Kinematics
  14096             *
  14097             * See the Wikipedia article "Trilateration"
  14098             * https://en.wikipedia.org/wiki/Trilateration
  14099             *
  14100             * Establish a new coordinate system in the plane of the
  14101             * three carriage points. This system has its origin at
  14102             * tower1, with tower2 on the X axis. Tower3 is in the X-Y
  14103             * plane with a Z component of zero.
  14104             * We will define unit vectors in this coordinate system
  14105             * in our original coordinate system. Then when we calculate
  14106             * the Xnew, Ynew and Znew values, we can translate back into
  14107             * the original system by moving along those unit vectors
  14108             * by the corresponding values.
  14109             *
  14110             * Variable names matched to Marlin, c-version, and avoid the
  14111             * use of any vector library.
  14112             *
  14113             * by Andreas Hardtung 2016-06-07
  14114             * based on a Java function from "Delta Robot Kinematics V3"
  14115             * by Steve Graves
  14116             *
  14117             * The result is stored in the cartes[] array.
  14118             */

   \                                 In section .text, align 2, keep-with-next
  14119            void forward_kinematics_DELTA(float z1, float z2, float z3) {
   \                     _Z24forward_kinematics_DELTAfff: (+1)
   \   00000000   0xE92D 0x4FF5      PUSH     {R0,R2,R4-R11,LR}
   \   00000004   0xB089             SUB      SP,SP,#+36
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable166_4
   \   0000000C   0x6940             LDR      R0,[R0, #+20]
   \   0000000E   0x.... 0x....      LDR.W    R1,??DataTable166_4
   \   00000012   0x68C9             LDR      R1,[R1, #+12]
   \   00000014   0x.... 0x....      BL       __aeabi_fsub
   \   00000018   0x4606             MOV      R6,R0
  14120              // Create a vector in old coordinates along x axis of new coordinate
  14121              const float p12[] = {
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable166_4
   \   0000001E   0x6980             LDR      R0,[R0, #+24]
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable166_4
   \   00000024   0x6909             LDR      R1,[R1, #+16]
   \   00000026   0x.... 0x....      BL       __aeabi_fsub
   \   0000002A   0x4605             MOV      R5,R0
   \   0000002C   0x4620             MOV      R0,R4
   \   0000002E   0x9909             LDR      R1,[SP, #+36]
   \   00000030   0x.... 0x....      BL       __aeabi_fsub
   \   00000034   0x4604             MOV      R4,R0
  14122                delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
  14123                delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
  14124                z2 - z1
  14125              },
  14126          
  14127              // Get the Magnitude of vector.
  14128              d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
   \   00000036   0x46B0             MOV      R8,R6
   \   00000038   0xF04F 0x0902      MOV      R9,#+2
   \   0000003C   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000040   0xE004             B.N      ??forward_kinematics_DELTA_0
   \                     ??forward_kinematics_DELTA_1: (+1)
   \   00000042   0x4640             MOV      R0,R8
   \   00000044   0x4641             MOV      R1,R8
   \   00000046   0x.... 0x....      BL       __aeabi_fmul
   \   0000004A   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_0: (+1)
   \   0000004C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000050   0xD504             BPL.N    ??forward_kinematics_DELTA_2
   \   00000052   0x4638             MOV      R0,R7
   \   00000054   0x4641             MOV      R1,R8
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x4607             MOV      R7,R0
   \                     ??forward_kinematics_DELTA_2: (+1)
   \   0000005C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000060   0xD1EF             BNE.N    ??forward_kinematics_DELTA_1
   \   00000062   0x46A9             MOV      R9,R5
   \   00000064   0xF04F 0x0A02      MOV      R10,#+2
   \   00000068   0xF04F 0x587E      MOV      R8,#+1065353216
   \   0000006C   0xE004             B.N      ??forward_kinematics_DELTA_3
   \                     ??forward_kinematics_DELTA_4: (+1)
   \   0000006E   0x4648             MOV      R0,R9
   \   00000070   0x4649             MOV      R1,R9
   \   00000072   0x.... 0x....      BL       __aeabi_fmul
   \   00000076   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_3: (+1)
   \   00000078   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000007C   0xD504             BPL.N    ??forward_kinematics_DELTA_5
   \   0000007E   0x4640             MOV      R0,R8
   \   00000080   0x4649             MOV      R1,R9
   \   00000082   0x.... 0x....      BL       __aeabi_fmul
   \   00000086   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_5: (+1)
   \   00000088   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000008C   0xD1EF             BNE.N    ??forward_kinematics_DELTA_4
   \   0000008E   0x46A3             MOV      R11,R4
   \   00000090   0xF04F 0x0902      MOV      R9,#+2
   \   00000094   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000098   0xE004             B.N      ??forward_kinematics_DELTA_6
   \                     ??forward_kinematics_DELTA_7: (+1)
   \   0000009A   0x4658             MOV      R0,R11
   \   0000009C   0x4659             MOV      R1,R11
   \   0000009E   0x.... 0x....      BL       __aeabi_fmul
   \   000000A2   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_6: (+1)
   \   000000A4   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000000A8   0xD504             BPL.N    ??forward_kinematics_DELTA_8
   \   000000AA   0x4650             MOV      R0,R10
   \   000000AC   0x4659             MOV      R1,R11
   \   000000AE   0x.... 0x....      BL       __aeabi_fmul
   \   000000B2   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_8: (+1)
   \   000000B4   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000000B8   0xD1EF             BNE.N    ??forward_kinematics_DELTA_7
   \   000000BA   0x4638             MOV      R0,R7
   \   000000BC   0x4641             MOV      R1,R8
   \   000000BE   0x.... 0x....      BL       __aeabi_fadd
   \   000000C2   0x4651             MOV      R1,R10
   \   000000C4   0x.... 0x....      BL       __aeabi_fadd
   \   000000C8   0x.... 0x....      BL       sqrtf
   \   000000CC   0x9005             STR      R0,[SP, #+20]
  14129          
  14130              // Create unit vector by dividing by magnitude.
  14131              ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
   \   000000CE   0x4630             MOV      R0,R6
   \   000000D0   0x9905             LDR      R1,[SP, #+20]
   \   000000D2   0x.... 0x....      BL       __aeabi_fdiv
   \   000000D6   0x9004             STR      R0,[SP, #+16]
   \   000000D8   0x4628             MOV      R0,R5
   \   000000DA   0x9905             LDR      R1,[SP, #+20]
   \   000000DC   0x.... 0x....      BL       __aeabi_fdiv
   \   000000E0   0x9003             STR      R0,[SP, #+12]
   \   000000E2   0x4620             MOV      R0,R4
   \   000000E4   0x9905             LDR      R1,[SP, #+20]
   \   000000E6   0x.... 0x....      BL       __aeabi_fdiv
   \   000000EA   0x9002             STR      R0,[SP, #+8]
  14132          
  14133              // Get the vector from the origin of the new system to the third point.
  14134              p13[3] = {
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable166_4
   \   000000F0   0x69C0             LDR      R0,[R0, #+28]
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable166_4
   \   000000F6   0x68C9             LDR      R1,[R1, #+12]
   \   000000F8   0x.... 0x....      BL       __aeabi_fsub
   \   000000FC   0x4605             MOV      R5,R0
   \   000000FE   0x.... 0x....      LDR.W    R0,??DataTable166_4
   \   00000102   0x6A00             LDR      R0,[R0, #+32]
   \   00000104   0x.... 0x....      LDR.W    R1,??DataTable166_4
   \   00000108   0x6909             LDR      R1,[R1, #+16]
   \   0000010A   0x.... 0x....      BL       __aeabi_fsub
   \   0000010E   0x4606             MOV      R6,R0
   \   00000110   0x980A             LDR      R0,[SP, #+40]
   \   00000112   0x9909             LDR      R1,[SP, #+36]
   \   00000114   0x.... 0x....      BL       __aeabi_fsub
   \   00000118   0x4607             MOV      R7,R0
  14135                delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
  14136                delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
  14137                z3 - z1
  14138              },
  14139          
  14140              // Use the dot product to find the component of this vector on the X axis.
  14141              i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
   \   0000011A   0x9804             LDR      R0,[SP, #+16]
   \   0000011C   0x4629             MOV      R1,R5
   \   0000011E   0x.... 0x....      BL       __aeabi_fmul
   \   00000122   0x4604             MOV      R4,R0
   \   00000124   0x9803             LDR      R0,[SP, #+12]
   \   00000126   0x4631             MOV      R1,R6
   \   00000128   0x.... 0x....      BL       __aeabi_fmul
   \   0000012C   0x4621             MOV      R1,R4
   \   0000012E   0x.... 0x....      BL       __aeabi_fadd
   \   00000132   0x4604             MOV      R4,R0
   \   00000134   0x9802             LDR      R0,[SP, #+8]
   \   00000136   0x4639             MOV      R1,R7
   \   00000138   0x.... 0x....      BL       __aeabi_fmul
   \   0000013C   0x4621             MOV      R1,R4
   \   0000013E   0x.... 0x....      BL       __aeabi_fadd
   \   00000142   0x4604             MOV      R4,R0
  14142          
  14143              // Create a vector along the x axis that represents the x component of p13.
  14144              iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
  14145          
  14146              // Subtract the X component from the original vector leaving only Y. We use the
  14147              // variable that will be the unit vector after we scale it.
  14148              float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
   \   00000144   0x9804             LDR      R0,[SP, #+16]
   \   00000146   0x4621             MOV      R1,R4
   \   00000148   0x.... 0x....      BL       __aeabi_fmul
   \   0000014C   0x4601             MOV      R1,R0
   \   0000014E   0x4628             MOV      R0,R5
   \   00000150   0x.... 0x....      BL       __aeabi_fsub
   \   00000154   0x4605             MOV      R5,R0
   \   00000156   0x9803             LDR      R0,[SP, #+12]
   \   00000158   0x4621             MOV      R1,R4
   \   0000015A   0x.... 0x....      BL       __aeabi_fmul
   \   0000015E   0x4601             MOV      R1,R0
   \   00000160   0x4630             MOV      R0,R6
   \   00000162   0x.... 0x....      BL       __aeabi_fsub
   \   00000166   0x4606             MOV      R6,R0
   \   00000168   0x9802             LDR      R0,[SP, #+8]
   \   0000016A   0x4621             MOV      R1,R4
   \   0000016C   0x.... 0x....      BL       __aeabi_fmul
   \   00000170   0x4601             MOV      R1,R0
   \   00000172   0x4638             MOV      R0,R7
   \   00000174   0x.... 0x....      BL       __aeabi_fsub
   \   00000178   0x9006             STR      R0,[SP, #+24]
  14149          
  14150              // The magnitude of Y component
  14151              const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
   \   0000017A   0x46A8             MOV      R8,R5
   \   0000017C   0xF04F 0x0902      MOV      R9,#+2
   \   00000180   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000184   0xE004             B.N      ??forward_kinematics_DELTA_9
   \                     ??forward_kinematics_DELTA_10: (+1)
   \   00000186   0x4640             MOV      R0,R8
   \   00000188   0x4641             MOV      R1,R8
   \   0000018A   0x.... 0x....      BL       __aeabi_fmul
   \   0000018E   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_9: (+1)
   \   00000190   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000194   0xD504             BPL.N    ??forward_kinematics_DELTA_11
   \   00000196   0x4638             MOV      R0,R7
   \   00000198   0x4641             MOV      R1,R8
   \   0000019A   0x.... 0x....      BL       __aeabi_fmul
   \   0000019E   0x4607             MOV      R7,R0
   \                     ??forward_kinematics_DELTA_11: (+1)
   \   000001A0   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000001A4   0xD1EF             BNE.N    ??forward_kinematics_DELTA_10
   \   000001A6   0x46B1             MOV      R9,R6
   \   000001A8   0xF04F 0x0A02      MOV      R10,#+2
   \   000001AC   0xF04F 0x587E      MOV      R8,#+1065353216
   \   000001B0   0xE004             B.N      ??forward_kinematics_DELTA_12
   \                     ??forward_kinematics_DELTA_13: (+1)
   \   000001B2   0x4648             MOV      R0,R9
   \   000001B4   0x4649             MOV      R1,R9
   \   000001B6   0x.... 0x....      BL       __aeabi_fmul
   \   000001BA   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_12: (+1)
   \   000001BC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000001C0   0xD504             BPL.N    ??forward_kinematics_DELTA_14
   \   000001C2   0x4640             MOV      R0,R8
   \   000001C4   0x4649             MOV      R1,R9
   \   000001C6   0x.... 0x....      BL       __aeabi_fmul
   \   000001CA   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_14: (+1)
   \   000001CC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000001D0   0xD1EF             BNE.N    ??forward_kinematics_DELTA_13
   \   000001D2   0xF8DD 0xB018      LDR      R11,[SP, #+24]
   \   000001D6   0xF04F 0x0902      MOV      R9,#+2
   \   000001DA   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000001DE   0xE004             B.N      ??forward_kinematics_DELTA_15
   \                     ??forward_kinematics_DELTA_16: (+1)
   \   000001E0   0x4658             MOV      R0,R11
   \   000001E2   0x4659             MOV      R1,R11
   \   000001E4   0x.... 0x....      BL       __aeabi_fmul
   \   000001E8   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_15: (+1)
   \   000001EA   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000001EE   0xD504             BPL.N    ??forward_kinematics_DELTA_17
   \   000001F0   0x4650             MOV      R0,R10
   \   000001F2   0x4659             MOV      R1,R11
   \   000001F4   0x.... 0x....      BL       __aeabi_fmul
   \   000001F8   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_17: (+1)
   \   000001FA   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000001FE   0xD1EF             BNE.N    ??forward_kinematics_DELTA_16
   \   00000200   0x4638             MOV      R0,R7
   \   00000202   0x4641             MOV      R1,R8
   \   00000204   0x.... 0x....      BL       __aeabi_fadd
   \   00000208   0x4651             MOV      R1,R10
   \   0000020A   0x.... 0x....      BL       __aeabi_fadd
   \   0000020E   0x.... 0x....      BL       sqrtf
   \   00000212   0x9001             STR      R0,[SP, #+4]
  14152          
  14153              // Convert to a unit vector
  14154              ey[0] /= j; ey[1] /= j;  ey[2] /= j;
   \   00000214   0x4628             MOV      R0,R5
   \   00000216   0x9901             LDR      R1,[SP, #+4]
   \   00000218   0x.... 0x....      BL       __aeabi_fdiv
   \   0000021C   0x4605             MOV      R5,R0
   \   0000021E   0x4630             MOV      R0,R6
   \   00000220   0x9901             LDR      R1,[SP, #+4]
   \   00000222   0x.... 0x....      BL       __aeabi_fdiv
   \   00000226   0x4606             MOV      R6,R0
   \   00000228   0x9806             LDR      R0,[SP, #+24]
   \   0000022A   0x9901             LDR      R1,[SP, #+4]
   \   0000022C   0x.... 0x....      BL       __aeabi_fdiv
   \   00000230   0x4607             MOV      R7,R0
  14155          
  14156              // The cross product of the unit x and y is the unit z
  14157              // float[] ez = vectorCrossProd(ex, ey);
  14158              const float ez[3] = {
   \   00000232   0x9803             LDR      R0,[SP, #+12]
   \   00000234   0x4639             MOV      R1,R7
   \   00000236   0x.... 0x....      BL       __aeabi_fmul
   \   0000023A   0x4680             MOV      R8,R0
   \   0000023C   0x9802             LDR      R0,[SP, #+8]
   \   0000023E   0x4631             MOV      R1,R6
   \   00000240   0x.... 0x....      BL       __aeabi_fmul
   \   00000244   0x4601             MOV      R1,R0
   \   00000246   0x4640             MOV      R0,R8
   \   00000248   0x.... 0x....      BL       __aeabi_fsub
   \   0000024C   0x9006             STR      R0,[SP, #+24]
   \   0000024E   0x9802             LDR      R0,[SP, #+8]
   \   00000250   0x4629             MOV      R1,R5
   \   00000252   0x.... 0x....      BL       __aeabi_fmul
   \   00000256   0x4680             MOV      R8,R0
   \   00000258   0x9804             LDR      R0,[SP, #+16]
   \   0000025A   0x4639             MOV      R1,R7
   \   0000025C   0x.... 0x....      BL       __aeabi_fmul
   \   00000260   0x4601             MOV      R1,R0
   \   00000262   0x4640             MOV      R0,R8
   \   00000264   0x.... 0x....      BL       __aeabi_fsub
   \   00000268   0x9008             STR      R0,[SP, #+32]
   \   0000026A   0x9804             LDR      R0,[SP, #+16]
   \   0000026C   0x4631             MOV      R1,R6
   \   0000026E   0x.... 0x....      BL       __aeabi_fmul
   \   00000272   0x4680             MOV      R8,R0
   \   00000274   0x9803             LDR      R0,[SP, #+12]
   \   00000276   0x4629             MOV      R1,R5
   \   00000278   0x.... 0x....      BL       __aeabi_fmul
   \   0000027C   0x4601             MOV      R1,R0
   \   0000027E   0x4640             MOV      R0,R8
   \   00000280   0x.... 0x....      BL       __aeabi_fsub
   \   00000284   0x9007             STR      R0,[SP, #+28]
  14159                ex[1] * ey[2] - ex[2] * ey[1],
  14160                ex[2] * ey[0] - ex[0] * ey[2],
  14161                ex[0] * ey[1] - ex[1] * ey[0]
  14162              },
  14163              // We now have the d, i and j values defined in Wikipedia.
  14164              // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
  14165              Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
   \   00000286   0xF8DD 0x9014      LDR      R9,[SP, #+20]
   \   0000028A   0xF04F 0x0A02      MOV      R10,#+2
   \   0000028E   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000292   0xE004             B.N      ??forward_kinematics_DELTA_18
   \                     ??forward_kinematics_DELTA_19: (+1)
   \   00000294   0x4648             MOV      R0,R9
   \   00000296   0x4649             MOV      R1,R9
   \   00000298   0x.... 0x....      BL       __aeabi_fmul
   \   0000029C   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_18: (+1)
   \   0000029E   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000002A2   0xD504             BPL.N    ??forward_kinematics_DELTA_20
   \   000002A4   0x4640             MOV      R0,R8
   \   000002A6   0x4649             MOV      R1,R9
   \   000002A8   0x.... 0x....      BL       __aeabi_fmul
   \   000002AC   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_20: (+1)
   \   000002AE   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000002B2   0xD1EF             BNE.N    ??forward_kinematics_DELTA_19
   \   000002B4   0x....             LDR.N    R0,??DataTable166_4
   \   000002B6   0x6BC0             LDR      R0,[R0, #+60]
   \   000002B8   0x....             LDR.N    R1,??DataTable166_4
   \   000002BA   0x6C09             LDR      R1,[R1, #+64]
   \   000002BC   0x.... 0x....      BL       __aeabi_fsub
   \   000002C0   0x4641             MOV      R1,R8
   \   000002C2   0x.... 0x....      BL       __aeabi_fadd
   \   000002C6   0x4680             MOV      R8,R0
   \   000002C8   0x9905             LDR      R1,[SP, #+20]
   \   000002CA   0xF04F 0x4080      MOV      R0,#+1073741824
   \   000002CE   0x.... 0x....      BL       __aeabi_fmul
   \   000002D2   0x4601             MOV      R1,R0
   \   000002D4   0x4640             MOV      R0,R8
   \   000002D6   0x.... 0x....      BL       __aeabi_fdiv
   \   000002DA   0x9000             STR      R0,[SP, #+0]
  14166              Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
   \   000002DC   0x46A1             MOV      R9,R4
   \   000002DE   0xF04F 0x0A02      MOV      R10,#+2
   \   000002E2   0xF04F 0x587E      MOV      R8,#+1065353216
   \   000002E6   0xE004             B.N      ??forward_kinematics_DELTA_21
   \                     ??forward_kinematics_DELTA_22: (+1)
   \   000002E8   0x4648             MOV      R0,R9
   \   000002EA   0x4649             MOV      R1,R9
   \   000002EC   0x.... 0x....      BL       __aeabi_fmul
   \   000002F0   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_21: (+1)
   \   000002F2   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000002F6   0xD504             BPL.N    ??forward_kinematics_DELTA_23
   \   000002F8   0x4640             MOV      R0,R8
   \   000002FA   0x4649             MOV      R1,R9
   \   000002FC   0x.... 0x....      BL       __aeabi_fmul
   \   00000300   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_23: (+1)
   \   00000302   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000306   0xD1EF             BNE.N    ??forward_kinematics_DELTA_22
   \   00000308   0xF8DD 0xB004      LDR      R11,[SP, #+4]
   \   0000030C   0xF04F 0x0902      MOV      R9,#+2
   \   00000310   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000314   0xE004             B.N      ??forward_kinematics_DELTA_24
   \                     ??forward_kinematics_DELTA_25: (+1)
   \   00000316   0x4658             MOV      R0,R11
   \   00000318   0x4659             MOV      R1,R11
   \   0000031A   0x.... 0x....      BL       __aeabi_fmul
   \   0000031E   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_24: (+1)
   \   00000320   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000324   0xD504             BPL.N    ??forward_kinematics_DELTA_26
   \   00000326   0x4650             MOV      R0,R10
   \   00000328   0x4659             MOV      R1,R11
   \   0000032A   0x.... 0x....      BL       __aeabi_fmul
   \   0000032E   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_26: (+1)
   \   00000330   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000334   0xD1EF             BNE.N    ??forward_kinematics_DELTA_25
   \   00000336   0x....             LDR.N    R0,??DataTable166_4
   \   00000338   0x6BC0             LDR      R0,[R0, #+60]
   \   0000033A   0x....             LDR.N    R1,??DataTable166_4
   \   0000033C   0x6C49             LDR      R1,[R1, #+68]
   \   0000033E   0x.... 0x....      BL       __aeabi_fsub
   \   00000342   0x4681             MOV      R9,R0
   \   00000344   0x4640             MOV      R0,R8
   \   00000346   0x4651             MOV      R1,R10
   \   00000348   0x.... 0x....      BL       __aeabi_fadd
   \   0000034C   0x4649             MOV      R1,R9
   \   0000034E   0x.... 0x....      BL       __aeabi_fadd
   \   00000352   0xF04F 0x517C      MOV      R1,#+1056964608
   \   00000356   0x.... 0x....      BL       __aeabi_fmul
   \   0000035A   0x4680             MOV      R8,R0
   \   0000035C   0x9800             LDR      R0,[SP, #+0]
   \   0000035E   0x4621             MOV      R1,R4
   \   00000360   0x.... 0x....      BL       __aeabi_fmul
   \   00000364   0x4601             MOV      R1,R0
   \   00000366   0x4640             MOV      R0,R8
   \   00000368   0x.... 0x....      BL       __aeabi_fsub
   \   0000036C   0x9901             LDR      R1,[SP, #+4]
   \   0000036E   0x.... 0x....      BL       __aeabi_fdiv
   \   00000372   0x4604             MOV      R4,R0
  14167              Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
   \   00000374   0xF8DD 0x9000      LDR      R9,[SP, #+0]
   \   00000378   0xF04F 0x0A02      MOV      R10,#+2
   \   0000037C   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000380   0xE004             B.N      ??forward_kinematics_DELTA_27
   \                     ??forward_kinematics_DELTA_28: (+1)
   \   00000382   0x4648             MOV      R0,R9
   \   00000384   0x4649             MOV      R1,R9
   \   00000386   0x.... 0x....      BL       __aeabi_fmul
   \   0000038A   0x4681             MOV      R9,R0
   \                     ??forward_kinematics_DELTA_27: (+1)
   \   0000038C   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000390   0xD504             BPL.N    ??forward_kinematics_DELTA_29
   \   00000392   0x4640             MOV      R0,R8
   \   00000394   0x4649             MOV      R1,R9
   \   00000396   0x.... 0x....      BL       __aeabi_fmul
   \   0000039A   0x4680             MOV      R8,R0
   \                     ??forward_kinematics_DELTA_29: (+1)
   \   0000039C   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000003A0   0xD1EF             BNE.N    ??forward_kinematics_DELTA_28
   \   000003A2   0x46A3             MOV      R11,R4
   \   000003A4   0xF04F 0x0902      MOV      R9,#+2
   \   000003A8   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000003AC   0xE004             B.N      ??forward_kinematics_DELTA_30
   \                     ??forward_kinematics_DELTA_31: (+1)
   \   000003AE   0x4658             MOV      R0,R11
   \   000003B0   0x4659             MOV      R1,R11
   \   000003B2   0x.... 0x....      BL       __aeabi_fmul
   \   000003B6   0x4683             MOV      R11,R0
   \                     ??forward_kinematics_DELTA_30: (+1)
   \   000003B8   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000003BC   0xD504             BPL.N    ??forward_kinematics_DELTA_32
   \   000003BE   0x4650             MOV      R0,R10
   \   000003C0   0x4659             MOV      R1,R11
   \   000003C2   0x.... 0x....      BL       __aeabi_fmul
   \   000003C6   0x4682             MOV      R10,R0
   \                     ??forward_kinematics_DELTA_32: (+1)
   \   000003C8   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000003CC   0xD1EF             BNE.N    ??forward_kinematics_DELTA_31
   \   000003CE   0x4640             MOV      R0,R8
   \   000003D0   0x4651             MOV      R1,R10
   \   000003D2   0x.... 0x....      BL       __aeabi_fadd
   \   000003D6   0x4601             MOV      R1,R0
   \   000003D8   0x....             LDR.N    R0,??DataTable166_4
   \   000003DA   0x6BC0             LDR      R0,[R0, #+60]
   \   000003DC   0x.... 0x....      BL       __aeabi_fsub
   \   000003E0   0x.... 0x....      BL       sqrtf
   \   000003E4   0x4680             MOV      R8,R0
  14168          
  14169              // Start from the origin of the old coordinates and add vectors in the
  14170              // old coords that represent the Xnew, Ynew and Znew to find the point
  14171              // in the old system.
  14172              cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
   \   000003E6   0x9904             LDR      R1,[SP, #+16]
   \   000003E8   0x9800             LDR      R0,[SP, #+0]
   \   000003EA   0x.... 0x....      BL       __aeabi_fmul
   \   000003EE   0x....             LDR.N    R1,??DataTable166_4
   \   000003F0   0x68C9             LDR      R1,[R1, #+12]
   \   000003F2   0x.... 0x....      BL       __aeabi_fadd
   \   000003F6   0x4681             MOV      R9,R0
   \   000003F8   0x4628             MOV      R0,R5
   \   000003FA   0x4621             MOV      R1,R4
   \   000003FC   0x.... 0x....      BL       __aeabi_fmul
   \   00000400   0x4649             MOV      R1,R9
   \   00000402   0x.... 0x....      BL       __aeabi_fadd
   \   00000406   0x4605             MOV      R5,R0
   \   00000408   0x9806             LDR      R0,[SP, #+24]
   \   0000040A   0x4641             MOV      R1,R8
   \   0000040C   0x.... 0x....      BL       __aeabi_fmul
   \   00000410   0x4601             MOV      R1,R0
   \   00000412   0x4628             MOV      R0,R5
   \   00000414   0x.... 0x....      BL       __aeabi_fsub
   \   00000418   0x....             LDR.N    R1,??DataTable166_4
   \   0000041A   0x6488             STR      R0,[R1, #+72]
  14173              cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
   \   0000041C   0x9903             LDR      R1,[SP, #+12]
   \   0000041E   0x9800             LDR      R0,[SP, #+0]
   \   00000420   0x.... 0x....      BL       __aeabi_fmul
   \   00000424   0x....             LDR.N    R1,??DataTable166_4
   \   00000426   0x6909             LDR      R1,[R1, #+16]
   \   00000428   0x.... 0x....      BL       __aeabi_fadd
   \   0000042C   0x4605             MOV      R5,R0
   \   0000042E   0x4630             MOV      R0,R6
   \   00000430   0x4621             MOV      R1,R4
   \   00000432   0x.... 0x....      BL       __aeabi_fmul
   \   00000436   0x4629             MOV      R1,R5
   \   00000438   0x.... 0x....      BL       __aeabi_fadd
   \   0000043C   0x4605             MOV      R5,R0
   \   0000043E   0x9808             LDR      R0,[SP, #+32]
   \   00000440   0x4641             MOV      R1,R8
   \   00000442   0x.... 0x....      BL       __aeabi_fmul
   \   00000446   0x4601             MOV      R1,R0
   \   00000448   0x4628             MOV      R0,R5
   \   0000044A   0x.... 0x....      BL       __aeabi_fsub
   \   0000044E   0x....             LDR.N    R1,??DataTable166_4
   \   00000450   0x64C8             STR      R0,[R1, #+76]
  14174              cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
   \   00000452   0x9902             LDR      R1,[SP, #+8]
   \   00000454   0x9800             LDR      R0,[SP, #+0]
   \   00000456   0x.... 0x....      BL       __aeabi_fmul
   \   0000045A   0x9909             LDR      R1,[SP, #+36]
   \   0000045C   0x.... 0x....      BL       __aeabi_fadd
   \   00000460   0x4605             MOV      R5,R0
   \   00000462   0x4638             MOV      R0,R7
   \   00000464   0x4621             MOV      R1,R4
   \   00000466   0x.... 0x....      BL       __aeabi_fmul
   \   0000046A   0x4629             MOV      R1,R5
   \   0000046C   0x.... 0x....      BL       __aeabi_fadd
   \   00000470   0x4604             MOV      R4,R0
   \   00000472   0x9807             LDR      R0,[SP, #+28]
   \   00000474   0x4641             MOV      R1,R8
   \   00000476   0x.... 0x....      BL       __aeabi_fmul
   \   0000047A   0x4601             MOV      R1,R0
   \   0000047C   0x4620             MOV      R0,R4
   \   0000047E   0x.... 0x....      BL       __aeabi_fsub
   \   00000482   0x....             LDR.N    R1,??DataTable166_4
   \   00000484   0x6508             STR      R0,[R1, #+80]
  14175            }
   \   00000486   0xB00B             ADD      SP,SP,#+44
   \   00000488   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  14176          

   \                                 In section .text, align 2, keep-with-next
  14177            void forward_kinematics_DELTA(float point[ABC]) {
  14178              forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
   \                     _Z24forward_kinematics_DELTAPf: (+1)
   \   00000000   0x6882             LDR      R2,[R0, #+8]
   \   00000002   0x6841             LDR      R1,[R0, #+4]
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x....             B.N      _Z24forward_kinematics_DELTAfff
  14179            }
  14180          
  14181          #endif // DELTA
  14182          
  14183          /**
  14184           * Get the stepper positions in the cartes[] array.
  14185           * Forward kinematics are applied for DELTA and SCARA.
  14186           *
  14187           * The result is in the current coordinate space with
  14188           * leveling applied. The coordinates need to be run through
  14189           * unapply_leveling to obtain machine coordinates suitable
  14190           * for current_position, etc.
  14191           */

   \                                 In section .text, align 2, keep-with-next
  14192          void get_cartesian_from_steppers() {
   \                     _Z27get_cartesian_from_steppersv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB083             SUB      SP,SP,#+12
   \   00000004   0x....             LDR.N    R0,??DataTable166_5
   \   00000006   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   0000000A   0x2802             CMP      R0,#+2
   \   0000000C   0xD10F             BNE.N    ??get_cartesian_from_steppers_0
  14193            //#if ENABLED(DELTA)
  14194            if(MACHINETPYE == DELTA)  {
  14195              forward_kinematics_DELTA(
  14196                stepper.get_axis_position_mm(A_AXIS),
  14197                stepper.get_axis_position_mm(B_AXIS),
  14198                stepper.get_axis_position_mm(C_AXIS)
  14199              );
   \   0000000E   0x2002             MOVS     R0,#+2
   \   00000010   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000014   0x4604             MOV      R4,R0
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   0000001C   0x4605             MOV      R5,R0
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000024   0x4622             MOV      R2,R4
   \   00000026   0x4629             MOV      R1,R5
   \   00000028   0x.... 0x....      BL       _Z24forward_kinematics_DELTAfff
   \   0000002C   0xBD37             POP      {R0-R2,R4,R5,PC}
  14200            	}
  14201            //#else
  14202            else
  14203            {
  14204              //#if IS_SCARA
  14205          	if(MACHINETPYE&IS_SCARA) {
   \                     ??get_cartesian_from_steppers_0: (+1)
   \   0000002E   0x....             LDR.N    R4,??DataTable166_4
   \   00000030   0xF44F 0x7140      MOV      R1,#+768
   \   00000034   0x4208             TST      R0,R1
   \   00000036   0xD00C             BEQ.N    ??get_cartesian_from_steppers_1
  14206                forward_kinematics_SCARA(
  14207                  stepper.get_axis_position_degrees(A_AXIS),
  14208                  stepper.get_axis_position_degrees(B_AXIS)
  14209                );
   \   00000038   0x2000             MOVS     R0,#+0
   \   0000003A   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   0000003E   0x9000             STR      R0,[SP, #+0]
   \   00000040   0x2001             MOVS     R0,#+1
   \   00000042   0x.... 0x....      BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
   \   00000046   0x9001             STR      R0,[SP, #+4]
   \   00000048   0xA901             ADD      R1,SP,#+4
   \   0000004A   0xA800             ADD      R0,SP,#+0
   \   0000004C   0x.... 0x....      BL       _Z24forward_kinematics_SCARARKfS0_
   \   00000050   0xE007             B.N      ??get_cartesian_from_steppers_2
  14210          	}
  14211              //#else
  14212              else
  14213              {
  14214                cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
   \                     ??get_cartesian_from_steppers_1: (+1)
   \   00000052   0x2000             MOVS     R0,#+0
   \   00000054   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000058   0x64A0             STR      R0,[R4, #+72]
  14215                cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000060   0x64E0             STR      R0,[R4, #+76]
  14216              }
  14217              //#endif
  14218              cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
   \                     ??get_cartesian_from_steppers_2: (+1)
   \   00000062   0x2002             MOVS     R0,#+2
   \   00000064   0x.... 0x....      BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
   \   00000068   0x6520             STR      R0,[R4, #+80]
  14219            }
  14220            //#endif
  14221          }
   \   0000006A   0xBD37             POP      {R0-R2,R4,R5,PC}  ;; return
  14222          
  14223          /**
  14224           * Set the current_position for an axis based on
  14225           * the stepper positions, removing any leveling that
  14226           * may have been applied.
  14227           *
  14228           * To prevent small shifts in axis position always call
  14229           * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
  14230           *
  14231           * To keep hosts in sync, always call report_current_position
  14232           * after updating the current_position.
  14233           */

   \                                 In section .text, align 2, keep-with-next
  14234          void set_current_from_steppers_for_axis(const AxisEnum axis) {
   \                     _Z34set_current_from_steppers_for_axis8AxisEnum: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
  14235            get_cartesian_from_steppers();
   \   00000004   0x.... 0x....      BL       _Z27get_cartesian_from_steppersv
  14236            //#if PLANNER_LEVELING
  14237            if(BED_LEVELING_METHOD&PLANNER_LEVELING)
   \   00000008   0x....             LDR.N    R5,??DataTable166_4
   \   0000000A   0x....             LDR.N    R0,??DataTable166_5
   \   0000000C   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000010   0x212E             MOVS     R1,#+46
   \   00000012   0x4208             TST      R0,R1
   \   00000014   0xD003             BEQ.N    ??set_current_from_steppers_for_axis_0
  14238              planner.unapply_leveling(cartes);
   \   00000016   0xF105 0x0048      ADD      R0,R5,#+72
   \   0000001A   0x.... 0x....      BL       _ZN7Planner16unapply_levelingEPf
  14239            //#endif
  14240            if (axis == ALL_AXES)
   \                     ??set_current_from_steppers_for_axis_0: (+1)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable175
   \   00000022   0x2C64             CMP      R4,#+100
   \   00000024   0xD107             BNE.N    ??set_current_from_steppers_for_axis_1
  14241              COPY(current_position, cartes);
   \   00000026   0x220C             MOVS     R2,#+12
   \   00000028   0xF105 0x0148      ADD      R1,R5,#+72
   \   0000002C   0x3008             ADDS     R0,R0,#+8
   \   0000002E   0xE8BD 0x4038      POP      {R3-R5,LR}
   \   00000032   0x.... 0x....      B.W      memcpy
  14242            else
  14243              current_position[axis] = cartes[axis];
   \                     ??set_current_from_steppers_for_axis_1: (+1)
   \   00000036   0xEB05 0x0184      ADD      R1,R5,R4, LSL #+2
   \   0000003A   0x6C89             LDR      R1,[R1, #+72]
   \   0000003C   0xEB00 0x0084      ADD      R0,R0,R4, LSL #+2
   \   00000040   0x6081             STR      R1,[R0, #+8]
  14244          }
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  14245          
  14246          #if 1//IS_CARTESIAN
  14247          #if 1//ENABLED(SEGMENT_LEVELED_MOVES)
  14248          
  14249            /**
  14250             * Prepare a segmented move on a CARTESIAN setup.
  14251             *
  14252             * This calls planner.buffer_line several times, adding
  14253             * small incremental moves. This allows the planner to
  14254             * apply more detailed bed leveling to the full move.
  14255             */
  14256            inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
  14257          
  14258              const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
  14259                          ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
  14260          
  14261              // If the move is only in Z/E don't split up the move
  14262              if (!xdiff && !ydiff) {
  14263                planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
  14264                return;
  14265              }
  14266          
  14267              // Remaining cartesian distances
  14268              const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
  14269                          ediff = destination[E_AXIS] - current_position[E_AXIS];
  14270          
  14271              // Get the linear distance in XYZ
  14272              // If the move is very short, check the E move distance
  14273              // No E move either? Game over.
  14274              float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
  14275              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
  14276              if (UNEAR_ZERO(cartesian_mm)) return;
  14277          
  14278              // The length divided by the segment size
  14279              // At least one segment is required
  14280              uint16_t segments = cartesian_mm / segment_size;
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
  14281              NOLESS(segments, 1);
  14282          
  14283              // The approximate length of each segment
  14284              const float inv_segments = 1.0 / float(segments),
  14285                          segment_distance[XYZE] = {
  14286                            xdiff * inv_segments,
  14287                            ydiff * inv_segments,
  14288                            zdiff * inv_segments,
  14289                            ediff * inv_segments
  14290                          };
  14291          
  14292              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  14293              // SERIAL_ECHOLNPAIR(" segments=", segments);
  14294          
  14295              // Get the raw current position as starting point
  14296              float raw[XYZE];
  14297              COPY(raw, current_position);
  14298          
  14299              // Calculate and execute the segments
  14300              while (--segments) {
  14301                static millis_t next_idle_ms = millis() + 200UL;
  14302                thermalManager.manage_heater();  // This returns immediately if not really needed.
  14303                if (ELAPSED(millis(), next_idle_ms)) {
  14304                  next_idle_ms = millis() + 200UL;
  14305                  idle();
  14306                }
  14307                LOOP_XYZE(i) raw[i] += segment_distance[i];
  14308                planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
  14309              }
  14310          
  14311              // Since segment_distance is only approximate,
  14312              // the final move must be to the exact destination.
  14313              planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
  14314            }
  14315          #endif
  14316          //#elif ENABLED(MESH_BED_LEVELING)
  14317          #if 1
  14318            /**
  14319             * Prepare a mesh-leveled linear move in a Cartesian setup,
  14320             * splitting the move where it crosses mesh borders.
  14321             */

   \                                 In section .text, align 2, keep-with-next
  14322            void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
   \                     _Z24mesh_line_to_destinationfhh: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB084             SUB      SP,SP,#+16
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x4615             MOV      R5,R2
  14323              // Get current and destination cells for this line
  14324              int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable175
   \   0000000E   0xF106 0x0008      ADD      R0,R6,#+8
   \   00000012   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \   00000016   0x4607             MOV      R7,R0
  14325                  cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
   \   00000018   0xF106 0x000C      ADD      R0,R6,#+12
   \   0000001C   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
   \   00000020   0x4680             MOV      R8,R0
  14326                  cx2 = mbl.cell_index_x(destination[X_AXIS]),
   \   00000022   0xF106 0x0018      ADD      R0,R6,#+24
   \   00000026   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_xERKf
   \   0000002A   0x4681             MOV      R9,R0
  14327                  cy2 = mbl.cell_index_y(destination[Y_AXIS]);
   \   0000002C   0xF106 0x001C      ADD      R0,R6,#+28
   \   00000030   0x.... 0x....      BL       _ZN17mesh_bed_leveling12cell_index_yERKf
  14328              NOMORE(cx1, GRID_MAX_POINTS_X - 2);
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable175_1
   \   00000038   0xF891 0x2060      LDRB     R2,[R1, #+96]
   \   0000003C   0x1E92             SUBS     R2,R2,#+2
   \   0000003E   0x42BA             CMP      R2,R7
   \   00000040   0xDA00             BGE.N    ??mesh_line_to_destination_0
   \   00000042   0x4617             MOV      R7,R2
   \                     ??mesh_line_to_destination_0: (+1)
   \   00000044   0x3160             ADDS     R1,R1,#+96
   \   00000046   0x7849             LDRB     R1,[R1, #+1]
   \   00000048   0x1E89             SUBS     R1,R1,#+2
   \   0000004A   0x4541             CMP      R1,R8
   \   0000004C   0xDA00             BGE.N    ??mesh_line_to_destination_1
  14329              NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
   \   0000004E   0x4688             MOV      R8,R1
  14330              NOMORE(cx2, GRID_MAX_POINTS_X - 2);
   \                     ??mesh_line_to_destination_1: (+1)
   \   00000050   0x454A             CMP      R2,R9
   \   00000052   0xDA00             BGE.N    ??mesh_line_to_destination_2
   \   00000054   0x4691             MOV      R9,R2
  14331              NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
   \                     ??mesh_line_to_destination_2: (+1)
   \   00000056   0x4281             CMP      R1,R0
   \   00000058   0xDA00             BGE.N    ??mesh_line_to_destination_3
   \   0000005A   0x4608             MOV      R0,R1
  14332          
  14333              // Start and end in the same cell? No split needed.
  14334              if (cx1 == cx2 && cy1 == cy2) {
   \                     ??mesh_line_to_destination_3: (+1)
   \   0000005C   0x454F             CMP      R7,R9
   \   0000005E   0xD102             BNE.N    ??mesh_line_to_destination_4
   \   00000060   0x4580             CMP      R8,R0
   \   00000062   0xF000 0x8098      BEQ.W    ??mesh_line_to_destination_5
  14335                buffer_line_to_destination(fr_mm_s);
  14336                set_current_from_destination();
  14337                return;
  14338              }
  14339          
  14340              #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  14341          
  14342              float normalized_dist, end[XYZE];
  14343              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   \                     ??mesh_line_to_destination_4: (+1)
   \   00000066   0x46CA             MOV      R10,R9
   \   00000068   0x45B9             CMP      R9,R7
   \   0000006A   0xDA00             BGE.N    ??mesh_line_to_destination_6
   \   0000006C   0x46BA             MOV      R10,R7
   \                     ??mesh_line_to_destination_6: (+1)
   \   0000006E   0x4683             MOV      R11,R0
   \   00000070   0x4540             CMP      R0,R8
   \   00000072   0xDA00             BGE.N    ??mesh_line_to_destination_7
   \   00000074   0x46C3             MOV      R11,R8
  14344          
  14345              // Crosses on the X and not already split on this X?
  14346              // The x_splits flags are insurance against rounding errors.
  14347              if (cx2 != cx1 && TEST(x_splits, gcx)) {
   \                     ??mesh_line_to_destination_7: (+1)
   \   00000076   0x45B9             CMP      R9,R7
   \   00000078   0xD05B             BEQ.N    ??mesh_line_to_destination_8
   \   0000007A   0x2101             MOVS     R1,#+1
   \   0000007C   0xFA01 0xF20A      LSL      R2,R1,R10
   \   00000080   0x4621             MOV      R1,R4
   \   00000082   0x4211             TST      R1,R2
   \   00000084   0xD055             BEQ.N    ??mesh_line_to_destination_8
  14348                // Split on the X grid line
  14349                CBI(x_splits, gcx);
   \   00000086   0x4394             BICS     R4,R4,R2
  14350                COPY(end, destination);
   \   00000088   0x2210             MOVS     R2,#+16
   \   0000008A   0xF106 0x0118      ADD      R1,R6,#+24
   \   0000008E   0xA800             ADD      R0,SP,#+0
   \   00000090   0x.... 0x....      BL       memcpy
  14351                destination[X_AXIS] = mbl.index_to_xpos[gcx];
   \   00000094   0xFA4F 0xFA8A      SXTB     R10,R10
   \   00000098   0x.... 0x....      LDR.W    R0,??DataTable176
   \   0000009C   0xF850 0x002A      LDR      R0,[R0, R10, LSL #+2]
   \   000000A0   0x61B0             STR      R0,[R6, #+24]
  14352                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
   \   000000A2   0x68B7             LDR      R7,[R6, #+8]
   \   000000A4   0x4639             MOV      R1,R7
   \   000000A6   0x.... 0x....      BL       __aeabi_fsub
   \   000000AA   0x4680             MOV      R8,R0
   \   000000AC   0x9800             LDR      R0,[SP, #+0]
   \   000000AE   0x4639             MOV      R1,R7
   \   000000B0   0x.... 0x....      BL       __aeabi_fsub
   \   000000B4   0x4601             MOV      R1,R0
   \   000000B6   0x4640             MOV      R0,R8
   \   000000B8   0x.... 0x....      BL       __aeabi_fdiv
   \   000000BC   0x4607             MOV      R7,R0
  14353                destination[Y_AXIS] = MBL_SEGMENT_END(Y);
   \   000000BE   0xF8D6 0x800C      LDR      R8,[R6, #+12]
   \   000000C2   0x69F0             LDR      R0,[R6, #+28]
   \   000000C4   0x4641             MOV      R1,R8
   \   000000C6   0x.... 0x....      BL       __aeabi_fsub
   \   000000CA   0x4639             MOV      R1,R7
   \   000000CC   0x.... 0x....      BL       __aeabi_fmul
   \   000000D0   0x4641             MOV      R1,R8
   \   000000D2   0x.... 0x....      BL       __aeabi_fadd
   \   000000D6   0x61F0             STR      R0,[R6, #+28]
  14354              }
  14355              // Crosses on the Y and not already split on this Y?
  14356              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  14357                // Split on the Y grid line
  14358                CBI(y_splits, gcy);
  14359                COPY(end, destination);
  14360                destination[Y_AXIS] = mbl.index_to_ypos[gcy];
  14361                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  14362                destination[X_AXIS] = MBL_SEGMENT_END(X);
  14363              }
  14364              else {
  14365                // Must already have been split on these border(s)
  14366                buffer_line_to_destination(fr_mm_s);
  14367                set_current_from_destination();
  14368                return;
  14369              }
  14370          
  14371              destination[Z_AXIS] = MBL_SEGMENT_END(Z);
   \                     ??mesh_line_to_destination_9: (+1)
   \   000000D8   0xF8D6 0x8010      LDR      R8,[R6, #+16]
   \   000000DC   0x6A30             LDR      R0,[R6, #+32]
   \   000000DE   0x4641             MOV      R1,R8
   \   000000E0   0x.... 0x....      BL       __aeabi_fsub
   \   000000E4   0x4639             MOV      R1,R7
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4641             MOV      R1,R8
   \   000000EC   0x.... 0x....      BL       __aeabi_fadd
   \   000000F0   0x6230             STR      R0,[R6, #+32]
  14372              destination[E_AXIS] = MBL_SEGMENT_END(E);
   \   000000F2   0xF8D6 0x8014      LDR      R8,[R6, #+20]
   \   000000F6   0x6A70             LDR      R0,[R6, #+36]
   \   000000F8   0x4641             MOV      R1,R8
   \   000000FA   0x.... 0x....      BL       __aeabi_fsub
   \   000000FE   0x4639             MOV      R1,R7
   \   00000100   0x.... 0x....      BL       __aeabi_fmul
   \   00000104   0x4641             MOV      R1,R8
   \   00000106   0x.... 0x....      BL       __aeabi_fadd
   \   0000010A   0x6270             STR      R0,[R6, #+36]
  14373          
  14374              // Do the split and look for more borders
  14375              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   0000010C   0x462A             MOV      R2,R5
   \   0000010E   0x4621             MOV      R1,R4
   \   00000110   0x9804             LDR      R0,[SP, #+16]
   \   00000112   0xF7FF 0xFF75      BL       _Z24mesh_line_to_destinationfhh
  14376          
  14377              // Restore destination from stack
  14378              COPY(destination, end);
   \   00000116   0x2210             MOVS     R2,#+16
   \   00000118   0xA900             ADD      R1,SP,#+0
   \   0000011A   0xF106 0x0018      ADD      R0,R6,#+24
   \   0000011E   0x.... 0x....      BL       memcpy
  14379              mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   00000122   0x462A             MOV      R2,R5
   \   00000124   0x4621             MOV      R1,R4
   \   00000126   0x9804             LDR      R0,[SP, #+16]
   \   00000128   0xF7FF 0xFF6A      BL       _Z24mesh_line_to_destinationfhh
  14380            }
   \                     ??mesh_line_to_destination_10: (+1)
   \   0000012C   0xB005             ADD      SP,SP,#+20
   \   0000012E   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??mesh_line_to_destination_8: (+1)
   \   00000132   0x4540             CMP      R0,R8
   \   00000134   0xD02F             BEQ.N    ??mesh_line_to_destination_5
   \   00000136   0x2101             MOVS     R1,#+1
   \   00000138   0xFA01 0xF00B      LSL      R0,R1,R11
   \   0000013C   0x4629             MOV      R1,R5
   \   0000013E   0x4201             TST      R1,R0
   \   00000140   0xD029             BEQ.N    ??mesh_line_to_destination_5
   \   00000142   0x4385             BICS     R5,R5,R0
   \   00000144   0x2210             MOVS     R2,#+16
   \   00000146   0xF106 0x0118      ADD      R1,R6,#+24
   \   0000014A   0xA800             ADD      R0,SP,#+0
   \   0000014C   0x.... 0x....      BL       memcpy
   \   00000150   0xFA4F 0xFB8B      SXTB     R11,R11
   \   00000154   0x.... 0x....      LDR.W    R0,??DataTable182
   \   00000158   0xF850 0x002B      LDR      R0,[R0, R11, LSL #+2]
   \   0000015C   0x61F0             STR      R0,[R6, #+28]
   \   0000015E   0x68F7             LDR      R7,[R6, #+12]
   \   00000160   0x4639             MOV      R1,R7
   \   00000162   0x.... 0x....      BL       __aeabi_fsub
   \   00000166   0x4680             MOV      R8,R0
   \   00000168   0x9801             LDR      R0,[SP, #+4]
   \   0000016A   0x4639             MOV      R1,R7
   \   0000016C   0x.... 0x....      BL       __aeabi_fsub
   \   00000170   0x4601             MOV      R1,R0
   \   00000172   0x4640             MOV      R0,R8
   \   00000174   0x.... 0x....      BL       __aeabi_fdiv
   \   00000178   0x4607             MOV      R7,R0
   \   0000017A   0xF8D6 0x8008      LDR      R8,[R6, #+8]
   \   0000017E   0x69B0             LDR      R0,[R6, #+24]
   \   00000180   0x4641             MOV      R1,R8
   \   00000182   0x.... 0x....      BL       __aeabi_fsub
   \   00000186   0x4639             MOV      R1,R7
   \   00000188   0x.... 0x....      BL       __aeabi_fmul
   \   0000018C   0x4641             MOV      R1,R8
   \   0000018E   0x.... 0x....      BL       __aeabi_fadd
   \   00000192   0x61B0             STR      R0,[R6, #+24]
   \   00000194   0xE7A0             B.N      ??mesh_line_to_destination_9
   \                     ??mesh_line_to_destination_5: (+1)
   \   00000196   0x9804             LDR      R0,[SP, #+16]
   \   00000198   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
   \   0000019C   0x.... 0x....      BL       _Z28set_current_from_destinationv
   \   000001A0   0xE7C4             B.N      ??mesh_line_to_destination_10
  14381          #endif
  14382          //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  14383          #if 1
  14384            #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
  14385          
  14386            /**
  14387             * Prepare a bilinear-leveled linear move on Cartesian,
  14388             * splitting the move where it crosses grid borders.
  14389             */

   \                                 In section .text, align 2, keep-with-next
  14390            void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
   \                     _Z28bilinear_line_to_destinationftt: (+1)
   \   00000000   0xE92D 0x4FF0      PUSH     {R4-R11,LR}
   \   00000004   0xB087             SUB      SP,SP,#+28
   \   00000006   0x4604             MOV      R4,R0
   \   00000008   0x460D             MOV      R5,R1
   \   0000000A   0x4616             MOV      R6,R2
  14391              // Get current and destination cells for this line
  14392              int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   0000000C   0x.... 0x....      LDR.W    R8,??DataTable178
   \   00000010   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   00000014   0x.... 0x....      BL       __aeabi_i2f
   \   00000018   0x4683             MOV      R11,R0
   \   0000001A   0x.... 0x....      LDR.W    R7,??DataTable175
   \   0000001E   0x68B8             LDR      R0,[R7, #+8]
   \   00000020   0x4659             MOV      R1,R11
   \   00000022   0x.... 0x....      BL       __aeabi_fsub
   \   00000026   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \   0000002A   0x.... 0x....      BL       __aeabi_fmul
   \   0000002E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000032   0x4681             MOV      R9,R0
   \   00000034   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   00000038   0x.... 0x....      BL       __aeabi_i2f
   \   0000003C   0x4601             MOV      R1,R0
   \   0000003E   0x68F8             LDR      R0,[R7, #+12]
   \   00000040   0x.... 0x....      BL       __aeabi_fsub
   \   00000044   0xF8D8 0x1024      LDR      R1,[R8, #+36]
   \   00000048   0x.... 0x....      BL       __aeabi_fmul
   \   0000004C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000050   0x4682             MOV      R10,R0
  14393                  cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
  14394                  cx2 = CELL_INDEX(X, destination[X_AXIS]),
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000052   0x69B8             LDR      R0,[R7, #+24]
   \   00000054   0x4659             MOV      R1,R11
   \   00000056   0x.... 0x....      BL       __aeabi_fsub
   \   0000005A   0xF8D8 0x1020      LDR      R1,[R8, #+32]
   \   0000005E   0x.... 0x....      BL       __aeabi_fmul
   \   00000062   0x.... 0x....      BL       __aeabi_f2iz
   \   00000066   0x4683             MOV      R11,R0
  14395                  cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
                               ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000068   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   0000006C   0x.... 0x....      BL       __aeabi_i2f
   \   00000070   0x4601             MOV      R1,R0
   \   00000072   0x69F8             LDR      R0,[R7, #+28]
   \   00000074   0x.... 0x....      BL       __aeabi_fsub
   \   00000078   0xF8D8 0x1024      LDR      R1,[R8, #+36]
   \   0000007C   0x.... 0x....      BL       __aeabi_fmul
   \   00000080   0x.... 0x....      BL       __aeabi_f2iz
  14396              cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable175_1
   \   00000088   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000008C   0xD502             BPL.N    ??bilinear_line_to_destination_0
   \   0000008E   0xF04F 0x0900      MOV      R9,#+0
   \   00000092   0xE005             B.N      ??bilinear_line_to_destination_1
   \                     ??bilinear_line_to_destination_0: (+1)
   \   00000094   0xF891 0x2060      LDRB     R2,[R1, #+96]
   \   00000098   0x1E92             SUBS     R2,R2,#+2
   \   0000009A   0x454A             CMP      R2,R9
   \   0000009C   0xDA00             BGE.N    ??bilinear_line_to_destination_1
   \   0000009E   0x4691             MOV      R9,R2
  14397              cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
   \                     ??bilinear_line_to_destination_1: (+1)
   \   000000A0   0xF1BA 0x0F00      CMP      R10,#+0
   \   000000A4   0xD502             BPL.N    ??bilinear_line_to_destination_2
   \   000000A6   0xF04F 0x0A00      MOV      R10,#+0
   \   000000AA   0xE006             B.N      ??bilinear_line_to_destination_3
   \                     ??bilinear_line_to_destination_2: (+1)
   \   000000AC   0xF101 0x0260      ADD      R2,R1,#+96
   \   000000B0   0x7852             LDRB     R2,[R2, #+1]
   \   000000B2   0x1E92             SUBS     R2,R2,#+2
   \   000000B4   0x4552             CMP      R2,R10
   \   000000B6   0xDA00             BGE.N    ??bilinear_line_to_destination_3
   \   000000B8   0x4692             MOV      R10,R2
  14398              cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
   \                     ??bilinear_line_to_destination_3: (+1)
   \   000000BA   0xF1BB 0x0F00      CMP      R11,#+0
   \   000000BE   0xD502             BPL.N    ??bilinear_line_to_destination_4
   \   000000C0   0xF04F 0x0B00      MOV      R11,#+0
   \   000000C4   0xE005             B.N      ??bilinear_line_to_destination_5
   \                     ??bilinear_line_to_destination_4: (+1)
   \   000000C6   0xF891 0x2060      LDRB     R2,[R1, #+96]
   \   000000CA   0x1E92             SUBS     R2,R2,#+2
   \   000000CC   0x455A             CMP      R2,R11
   \   000000CE   0xDA00             BGE.N    ??bilinear_line_to_destination_5
   \   000000D0   0x4693             MOV      R11,R2
  14399              cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
   \                     ??bilinear_line_to_destination_5: (+1)
   \   000000D2   0x2800             CMP      R0,#+0
   \   000000D4   0xD501             BPL.N    ??bilinear_line_to_destination_6
   \   000000D6   0x2000             MOVS     R0,#+0
   \   000000D8   0xE006             B.N      ??bilinear_line_to_destination_7
   \                     ??bilinear_line_to_destination_6: (+1)
   \   000000DA   0xF101 0x0260      ADD      R2,R1,#+96
   \   000000DE   0x7851             LDRB     R1,[R2, #+1]
   \   000000E0   0x1E8A             SUBS     R2,R1,#+2
   \   000000E2   0x4282             CMP      R2,R0
   \   000000E4   0xDA00             BGE.N    ??bilinear_line_to_destination_7
   \   000000E6   0x4610             MOV      R0,R2
  14400          
  14401              // Start and end in the same cell? No split needed.
  14402              if (cx1 == cx2 && cy1 == cy2) {
   \                     ??bilinear_line_to_destination_7: (+1)
   \   000000E8   0x45D9             CMP      R9,R11
   \   000000EA   0xD102             BNE.N    ??bilinear_line_to_destination_8
   \   000000EC   0x4582             CMP      R10,R0
   \   000000EE   0xF000 0x80A8      BEQ.W    ??bilinear_line_to_destination_9
  14403                buffer_line_to_destination(fr_mm_s);
  14404                set_current_from_destination();
  14405                return;
  14406              }
  14407          
  14408              #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
  14409          
  14410              float normalized_dist, end[XYZE];
  14411              const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
   \                     ??bilinear_line_to_destination_8: (+1)
   \   000000F2   0x4659             MOV      R1,R11
   \   000000F4   0x45CB             CMP      R11,R9
   \   000000F6   0xDA00             BGE.N    ??bilinear_line_to_destination_10
   \   000000F8   0x4649             MOV      R1,R9
   \                     ??bilinear_line_to_destination_10: (+1)
   \   000000FA   0x9101             STR      R1,[SP, #+4]
   \   000000FC   0x4601             MOV      R1,R0
   \   000000FE   0x4550             CMP      R0,R10
   \   00000100   0xDA00             BGE.N    ??bilinear_line_to_destination_11
   \   00000102   0x4651             MOV      R1,R10
   \                     ??bilinear_line_to_destination_11: (+1)
   \   00000104   0x9100             STR      R1,[SP, #+0]
  14412          
  14413              // Crosses on the X and not already split on this X?
  14414              // The x_splits flags are insurance against rounding errors.
  14415              if (cx2 != cx1 && TEST(x_splits, gcx)) {
   \   00000106   0x45CB             CMP      R11,R9
   \   00000108   0xD062             BEQ.N    ??bilinear_line_to_destination_12
   \   0000010A   0x2101             MOVS     R1,#+1
   \   0000010C   0x9A01             LDR      R2,[SP, #+4]
   \   0000010E   0xFA01 0xF202      LSL      R2,R1,R2
   \   00000112   0x4629             MOV      R1,R5
   \   00000114   0x4211             TST      R1,R2
   \   00000116   0xD05B             BEQ.N    ??bilinear_line_to_destination_12
  14416                // Split on the X grid line
  14417                CBI(x_splits, gcx);
   \   00000118   0x4395             BICS     R5,R5,R2
  14418                COPY(end, destination);
   \   0000011A   0x2210             MOVS     R2,#+16
   \   0000011C   0xF107 0x0118      ADD      R1,R7,#+24
   \   00000120   0xA802             ADD      R0,SP,#+8
   \   00000122   0x.... 0x....      BL       memcpy
  14419                destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
   \   00000126   0xF8D8 0x0018      LDR      R0,[R8, #+24]
   \   0000012A   0xF8D8 0x1010      LDR      R1,[R8, #+16]
   \   0000012E   0xAA01             ADD      R2,SP,#+4
   \   00000130   0xF992 0x2000      LDRSB    R2,[R2, #+0]
   \   00000134   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000138   0x.... 0x....      BL       __aeabi_i2f
   \   0000013C   0x61B8             STR      R0,[R7, #+24]
  14420                normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
   \   0000013E   0xF8D7 0x8008      LDR      R8,[R7, #+8]
   \   00000142   0x4641             MOV      R1,R8
   \   00000144   0x.... 0x....      BL       __aeabi_fsub
   \   00000148   0x4681             MOV      R9,R0
   \   0000014A   0x9802             LDR      R0,[SP, #+8]
   \   0000014C   0x4641             MOV      R1,R8
   \   0000014E   0x.... 0x....      BL       __aeabi_fsub
   \   00000152   0x4601             MOV      R1,R0
   \   00000154   0x4648             MOV      R0,R9
   \   00000156   0x.... 0x....      BL       __aeabi_fdiv
   \   0000015A   0x4680             MOV      R8,R0
  14421                destination[Y_AXIS] = LINE_SEGMENT_END(Y);
   \   0000015C   0xF8D7 0x900C      LDR      R9,[R7, #+12]
   \   00000160   0x69F8             LDR      R0,[R7, #+28]
   \   00000162   0x4649             MOV      R1,R9
   \   00000164   0x.... 0x....      BL       __aeabi_fsub
   \   00000168   0x4641             MOV      R1,R8
   \   0000016A   0x.... 0x....      BL       __aeabi_fmul
   \   0000016E   0x4649             MOV      R1,R9
   \   00000170   0x.... 0x....      BL       __aeabi_fadd
   \   00000174   0x61F8             STR      R0,[R7, #+28]
  14422              }
  14423              // Crosses on the Y and not already split on this Y?
  14424              else if (cy2 != cy1 && TEST(y_splits, gcy)) {
  14425                // Split on the Y grid line
  14426                CBI(y_splits, gcy);
  14427                COPY(end, destination);
  14428                destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
  14429                normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
  14430                destination[X_AXIS] = LINE_SEGMENT_END(X);
  14431              }
  14432              else {
  14433                // Must already have been split on these border(s)
  14434                buffer_line_to_destination(fr_mm_s);
  14435                set_current_from_destination();
  14436                return;
  14437              }
  14438          
  14439              destination[Z_AXIS] = LINE_SEGMENT_END(Z);
   \                     ??bilinear_line_to_destination_13: (+1)
   \   00000176   0xF8D7 0x9010      LDR      R9,[R7, #+16]
   \   0000017A   0x6A38             LDR      R0,[R7, #+32]
   \   0000017C   0x4649             MOV      R1,R9
   \   0000017E   0x.... 0x....      BL       __aeabi_fsub
   \   00000182   0x4641             MOV      R1,R8
   \   00000184   0x.... 0x....      BL       __aeabi_fmul
   \   00000188   0x4649             MOV      R1,R9
   \   0000018A   0x.... 0x....      BL       __aeabi_fadd
   \   0000018E   0x6238             STR      R0,[R7, #+32]
  14440              destination[E_AXIS] = LINE_SEGMENT_END(E);
   \   00000190   0xF8D7 0x9014      LDR      R9,[R7, #+20]
   \   00000194   0x6A78             LDR      R0,[R7, #+36]
   \   00000196   0x4649             MOV      R1,R9
   \   00000198   0x.... 0x....      BL       __aeabi_fsub
   \   0000019C   0x4641             MOV      R1,R8
   \   0000019E   0x.... 0x....      BL       __aeabi_fmul
   \   000001A2   0x4649             MOV      R1,R9
   \   000001A4   0x.... 0x....      BL       __aeabi_fadd
   \   000001A8   0x6278             STR      R0,[R7, #+36]
  14441          
  14442              // Do the split and look for more borders
  14443              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   000001AA   0x4632             MOV      R2,R6
   \   000001AC   0x4629             MOV      R1,R5
   \   000001AE   0x4620             MOV      R0,R4
   \   000001B0   0xF7FF 0xFF26      BL       _Z28bilinear_line_to_destinationftt
  14444          
  14445              // Restore destination from stack
  14446              COPY(destination, end);
   \   000001B4   0x2210             MOVS     R2,#+16
   \   000001B6   0xA902             ADD      R1,SP,#+8
   \   000001B8   0xF107 0x0018      ADD      R0,R7,#+24
   \   000001BC   0x.... 0x....      BL       memcpy
  14447              bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
   \   000001C0   0x4632             MOV      R2,R6
   \   000001C2   0x4629             MOV      R1,R5
   \   000001C4   0x4620             MOV      R0,R4
   \   000001C6   0xF7FF 0xFF1B      BL       _Z28bilinear_line_to_destinationftt
  14448            }
   \                     ??bilinear_line_to_destination_14: (+1)
   \   000001CA   0xB007             ADD      SP,SP,#+28
   \   000001CC   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \                     ??bilinear_line_to_destination_12: (+1)
   \   000001D0   0x4550             CMP      R0,R10
   \   000001D2   0xD036             BEQ.N    ??bilinear_line_to_destination_9
   \   000001D4   0x2101             MOVS     R1,#+1
   \   000001D6   0x9800             LDR      R0,[SP, #+0]
   \   000001D8   0xFA01 0xF000      LSL      R0,R1,R0
   \   000001DC   0x4631             MOV      R1,R6
   \   000001DE   0x4201             TST      R1,R0
   \   000001E0   0xD02F             BEQ.N    ??bilinear_line_to_destination_9
   \   000001E2   0x4386             BICS     R6,R6,R0
   \   000001E4   0x2210             MOVS     R2,#+16
   \   000001E6   0xF107 0x0118      ADD      R1,R7,#+24
   \   000001EA   0xA802             ADD      R0,SP,#+8
   \   000001EC   0x.... 0x....      BL       memcpy
   \   000001F0   0xF8D8 0x001C      LDR      R0,[R8, #+28]
   \   000001F4   0xF8D8 0x1014      LDR      R1,[R8, #+20]
   \   000001F8   0xAA00             ADD      R2,SP,#+0
   \   000001FA   0xF992 0x2000      LDRSB    R2,[R2, #+0]
   \   000001FE   0xFB02 0x0001      MLA      R0,R2,R1,R0
   \   00000202   0x.... 0x....      BL       __aeabi_i2f
   \   00000206   0x61F8             STR      R0,[R7, #+28]
   \   00000208   0xF8D7 0x800C      LDR      R8,[R7, #+12]
   \   0000020C   0x4641             MOV      R1,R8
   \   0000020E   0x.... 0x....      BL       __aeabi_fsub
   \   00000212   0x4681             MOV      R9,R0
   \   00000214   0x9803             LDR      R0,[SP, #+12]
   \   00000216   0x4641             MOV      R1,R8
   \   00000218   0x.... 0x....      BL       __aeabi_fsub
   \   0000021C   0x4601             MOV      R1,R0
   \   0000021E   0x4648             MOV      R0,R9
   \   00000220   0x.... 0x....      BL       __aeabi_fdiv
   \   00000224   0x4680             MOV      R8,R0
   \   00000226   0xF8D7 0x9008      LDR      R9,[R7, #+8]
   \   0000022A   0x69B8             LDR      R0,[R7, #+24]
   \   0000022C   0x4649             MOV      R1,R9
   \   0000022E   0x.... 0x....      BL       __aeabi_fsub
   \   00000232   0x4641             MOV      R1,R8
   \   00000234   0x.... 0x....      BL       __aeabi_fmul
   \   00000238   0x4649             MOV      R1,R9
   \   0000023A   0x.... 0x....      BL       __aeabi_fadd
   \   0000023E   0x61B8             STR      R0,[R7, #+24]
   \   00000240   0xE799             B.N      ??bilinear_line_to_destination_13
   \                     ??bilinear_line_to_destination_9: (+1)
   \   00000242   0x4620             MOV      R0,R4
   \   00000244   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
   \   00000248   0x.... 0x....      BL       _Z28set_current_from_destinationv
   \   0000024C   0xE7BD             B.N      ??bilinear_line_to_destination_14
  14449          
  14450          #endif // AUTO_BED_LEVELING_BILINEAR
  14451          #endif // IS_CARTESIAN
  14452          
  14453          #if 1//!UBL_SEGMENTED
  14454          #if 1//IS_KINEMATIC
  14455          
  14456            /**
  14457             * Prepare a linear move in a DELTA or SCARA setup.
  14458             *
  14459             * This calls planner.buffer_line several times, adding
  14460             * small incremental moves for DELTA or SCARA.
  14461             *
  14462             * For Unified Bed Leveling (Delta or Segmented Cartesian)
  14463             * the ubl.prepare_segmented_line_to method replaces this.
  14464             */

   \                                 In section .text, align 4
  14465            inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
   \                     _Z25prepare_kinematic_move_toRA4_Kf: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
   \   00000004   0xB08C             SUB      SP,SP,#+48
  14466          
  14467              // Get the top feedrate of the move in the XY plane
  14468              const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
   \   00000006   0xF8DF 0x4448      LDR.W    R4,??prepare_kinematic_move_to_0
   \   0000000A   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   0000000E   0x.... 0x....      BL       __aeabi_i2f
   \   00000012   0x6DE1             LDR      R1,[R4, #+92]
   \   00000014   0x.... 0x....      BL       __aeabi_fmul
   \   00000018   0x.... 0x....      BL       __aeabi_f2d
   \   0000001C   0xF8DF 0x2434      LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
   \   00000020   0xF8DF 0x3434      LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
   \   00000024   0x.... 0x....      BL       __aeabi_dmul
   \   00000028   0x.... 0x....      BL       __aeabi_d2f
   \   0000002C   0x9002             STR      R0,[SP, #+8]
  14469          
  14470              const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
   \   0000002E   0x980C             LDR      R0,[SP, #+48]
   \   00000030   0x6800             LDR      R0,[R0, #+0]
   \   00000032   0x68A1             LDR      R1,[R4, #+8]
   \   00000034   0x.... 0x....      BL       __aeabi_fsub
   \   00000038   0x4681             MOV      R9,R0
  14471                          ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
   \   0000003A   0x980C             LDR      R0,[SP, #+48]
   \   0000003C   0x6840             LDR      R0,[R0, #+4]
   \   0000003E   0x68E1             LDR      R1,[R4, #+12]
   \   00000040   0x.... 0x....      BL       __aeabi_fsub
   \   00000044   0x4607             MOV      R7,R0
  14472          
  14473              // If the move is only in Z/E don't split up the move
  14474              if (!xdiff && !ydiff) {
   \   00000046   0x4648             MOV      R0,R9
   \   00000048   0x2100             MOVS     R1,#+0
   \   0000004A   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000004E   0xD104             BNE.N    ??prepare_kinematic_move_to_1
   \   00000050   0x4638             MOV      R0,R7
   \   00000052   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000056   0xF000 0x81F1      BEQ.W    ??prepare_kinematic_move_to_2
   \                     ??prepare_kinematic_move_to_1: (+1)
   \   0000005A   0xF8DF 0x0400      LDR.W    R0,??prepare_kinematic_move_to_0+0xC
   \   0000005E   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000062   0xF240 0x3102      MOVW     R1,#+770
   \   00000066   0x4208             TST      R0,R1
   \   00000068   0x980C             LDR      R0,[SP, #+48]
   \   0000006A   0xD005             BEQ.N    ??prepare_kinematic_move_to_3
  14475                planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
  14476                return false; // caller will update current_position
  14477              }
  14478          
  14479              // Fail if attempting move outside printable radius
  14480              if(MACHINETPYE & IS_KINEMATIC)
  14481              {
  14482                  if (!position_is_reachable_IS_KINEMATIC(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
   \   0000006C   0x1D01             ADDS     R1,R0,#+4
   \   0000006E   0x.... 0x....      BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD105             BNE.N    ??prepare_kinematic_move_to_4
   \   00000076   0xE068             B.N      ??prepare_kinematic_move_to_5
  14483              }
  14484              else
  14485              {
  14486                  if (!position_is_reachable_IS_CARTESIAN(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
   \                     ??prepare_kinematic_move_to_3: (+1)
   \   00000078   0x1D01             ADDS     R1,R0,#+4
   \   0000007A   0x.... 0x....      BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD063             BEQ.N    ??prepare_kinematic_move_to_5
  14487              }
  14488              // Remaining cartesian distances
  14489              const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
   \                     ??prepare_kinematic_move_to_4: (+1)
   \   00000082   0x980C             LDR      R0,[SP, #+48]
   \   00000084   0x6880             LDR      R0,[R0, #+8]
   \   00000086   0x6921             LDR      R1,[R4, #+16]
   \   00000088   0x.... 0x....      BL       __aeabi_fsub
   \   0000008C   0x9001             STR      R0,[SP, #+4]
  14490                          ediff = rtarget[E_AXIS] - current_position[E_AXIS];
   \   0000008E   0x980C             LDR      R0,[SP, #+48]
   \   00000090   0x68C0             LDR      R0,[R0, #+12]
   \   00000092   0x6961             LDR      R1,[R4, #+20]
   \   00000094   0x.... 0x....      BL       __aeabi_fsub
   \   00000098   0x9000             STR      R0,[SP, #+0]
  14491          
  14492              // Get the linear distance in XYZ
  14493              // If the move is very short, check the E move distance
  14494              // No E move either? Game over.
  14495              float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
   \   0000009A   0x464E             MOV      R6,R9
   \   0000009C   0xF04F 0x0802      MOV      R8,#+2
   \   000000A0   0xF04F 0x557E      MOV      R5,#+1065353216
   \   000000A4   0xE004             B.N      ??prepare_kinematic_move_to_6
   \                     ??prepare_kinematic_move_to_7: (+1)
   \   000000A6   0x4630             MOV      R0,R6
   \   000000A8   0x4631             MOV      R1,R6
   \   000000AA   0x.... 0x....      BL       __aeabi_fmul
   \   000000AE   0x4606             MOV      R6,R0
   \                     ??prepare_kinematic_move_to_6: (+1)
   \   000000B0   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000000B4   0xD504             BPL.N    ??prepare_kinematic_move_to_8
   \   000000B6   0x4628             MOV      R0,R5
   \   000000B8   0x4631             MOV      R1,R6
   \   000000BA   0x.... 0x....      BL       __aeabi_fmul
   \   000000BE   0x4605             MOV      R5,R0
   \                     ??prepare_kinematic_move_to_8: (+1)
   \   000000C0   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   000000C4   0xD1EF             BNE.N    ??prepare_kinematic_move_to_7
   \   000000C6   0x46B8             MOV      R8,R7
   \   000000C8   0xF04F 0x0A02      MOV      R10,#+2
   \   000000CC   0xF04F 0x567E      MOV      R6,#+1065353216
   \   000000D0   0xE004             B.N      ??prepare_kinematic_move_to_9
   \                     ??prepare_kinematic_move_to_10: (+1)
   \   000000D2   0x4640             MOV      R0,R8
   \   000000D4   0x4641             MOV      R1,R8
   \   000000D6   0x.... 0x....      BL       __aeabi_fmul
   \   000000DA   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_9: (+1)
   \   000000DC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000000E0   0xD504             BPL.N    ??prepare_kinematic_move_to_11
   \   000000E2   0x4630             MOV      R0,R6
   \   000000E4   0x4641             MOV      R1,R8
   \   000000E6   0x.... 0x....      BL       __aeabi_fmul
   \   000000EA   0x4606             MOV      R6,R0
   \                     ??prepare_kinematic_move_to_11: (+1)
   \   000000EC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000000F0   0xD1EF             BNE.N    ??prepare_kinematic_move_to_10
   \   000000F2   0xF8DD 0xB004      LDR      R11,[SP, #+4]
   \   000000F6   0xF04F 0x0802      MOV      R8,#+2
   \   000000FA   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000000FE   0xE004             B.N      ??prepare_kinematic_move_to_12
   \                     ??prepare_kinematic_move_to_13: (+1)
   \   00000100   0x4658             MOV      R0,R11
   \   00000102   0x4659             MOV      R1,R11
   \   00000104   0x.... 0x....      BL       __aeabi_fmul
   \   00000108   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_12: (+1)
   \   0000010A   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000010E   0xD504             BPL.N    ??prepare_kinematic_move_to_14
   \   00000110   0x4650             MOV      R0,R10
   \   00000112   0x4659             MOV      R1,R11
   \   00000114   0x.... 0x....      BL       __aeabi_fmul
   \   00000118   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_14: (+1)
   \   0000011A   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   0000011E   0xD1EF             BNE.N    ??prepare_kinematic_move_to_13
   \   00000120   0x4628             MOV      R0,R5
   \   00000122   0x4631             MOV      R1,R6
   \   00000124   0x.... 0x....      BL       __aeabi_fadd
   \   00000128   0x4651             MOV      R1,R10
   \   0000012A   0x.... 0x....      BL       __aeabi_fadd
   \   0000012E   0x.... 0x....      BL       sqrtf
   \   00000132   0x4680             MOV      R8,R0
  14496              if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
   \   00000134   0x49CA             LDR.N    R1,??prepare_kinematic_move_to_0+0x10  ;; 0x358637be
   \   00000136   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000013A   0xD202             BCS.N    ??prepare_kinematic_move_to_15
   \   0000013C   0x9800             LDR      R0,[SP, #+0]
   \   0000013E   0xF020 0x4800      BIC      R8,R0,#0x80000000
  14497              if (UNEAR_ZERO(cartesian_mm)) return true;
   \                     ??prepare_kinematic_move_to_15: (+1)
   \   00000142   0x4640             MOV      R0,R8
   \   00000144   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000148   0xD201             BCS.N    ??prepare_kinematic_move_to_16
   \                     ??prepare_kinematic_move_to_5: (+1)
   \   0000014A   0x2001             MOVS     R0,#+1
   \   0000014C   0xE17C             B.N      ??prepare_kinematic_move_to_17
  14498          
  14499              // Minimum number of seconds to move the given distance
  14500              const float seconds = cartesian_mm / _feedrate_mm_s;
  14501          
  14502              // The number of segments-per-second times the duration
  14503              // gives the number of segments
  14504              uint16_t segments = delta_segments_per_second * seconds;
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \                     ??prepare_kinematic_move_to_16: (+1)
   \   0000014E   0x4DC5             LDR.N    R5,??prepare_kinematic_move_to_0+0x14
   \   00000150   0x9902             LDR      R1,[SP, #+8]
   \   00000152   0x.... 0x....      BL       __aeabi_fdiv
   \   00000156   0x6F69             LDR      R1,[R5, #+116]
   \   00000158   0x.... 0x....      BL       __aeabi_fmul
   \   0000015C   0x.... 0x....      BL       __aeabi_f2iz
   \   00000160   0x4606             MOV      R6,R0
  14505          
  14506              // For SCARA minimum segment size is 0.25mm
  14507              //#if IS_SCARA
  14508          	if(MACHINETPYE&IS_SCARA)
   \   00000162   0x48BE             LDR.N    R0,??prepare_kinematic_move_to_0+0xC
   \   00000164   0xF8B0 0x0058      LDRH     R0,[R0, #+88]
   \   00000168   0xF44F 0x7140      MOV      R1,#+768
   \   0000016C   0x4208             TST      R0,R1
   \   0000016E   0xD011             BEQ.N    ??prepare_kinematic_move_to_18
  14509                NOMORE(segments, cartesian_mm * 4);
                       ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   00000170   0xF04F 0x4081      MOV      R0,#+1082130432
   \   00000174   0x4641             MOV      R1,R8
   \   00000176   0x.... 0x....      BL       __aeabi_fmul
   \   0000017A   0x4680             MOV      R8,R0
   \   0000017C   0xB2B6             UXTH     R6,R6
   \   0000017E   0x4630             MOV      R0,R6
   \   00000180   0x.... 0x....      BL       __aeabi_ui2f
   \   00000184   0x4601             MOV      R1,R0
   \   00000186   0x4640             MOV      R0,R8
   \   00000188   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000018C   0xD202             BCS.N    ??prepare_kinematic_move_to_18
   \   0000018E   0x.... 0x....      BL       __aeabi_f2iz
   \   00000192   0x4606             MOV      R6,R0
  14510              //#endif
  14511          
  14512              // At least one segment is required
  14513              NOLESS(segments, 1);
   \                     ??prepare_kinematic_move_to_18: (+1)
   \   00000194   0xB2B6             UXTH     R6,R6
   \   00000196   0x2E00             CMP      R6,#+0
   \   00000198   0xD100             BNE.N    ??prepare_kinematic_move_to_19
   \   0000019A   0x2601             MOVS     R6,#+1
  14514          
  14515              // The approximate length of each segment
  14516              const float inv_segments = 1.0 / float(segments),
   \                     ??prepare_kinematic_move_to_19: (+1)
   \   0000019C   0x4630             MOV      R0,R6
   \   0000019E   0x.... 0x....      BL       __aeabi_ui2f
   \   000001A2   0x4601             MOV      R1,R0
   \   000001A4   0xF04F 0x507E      MOV      R0,#+1065353216
   \   000001A8   0x.... 0x....      BL       __aeabi_fdiv
   \   000001AC   0x4680             MOV      R8,R0
  14517                          segment_distance[XYZE] = {
   \   000001AE   0x4648             MOV      R0,R9
   \   000001B0   0x4641             MOV      R1,R8
   \   000001B2   0x.... 0x....      BL       __aeabi_fmul
   \   000001B6   0x9007             STR      R0,[SP, #+28]
   \   000001B8   0x4638             MOV      R0,R7
   \   000001BA   0x4641             MOV      R1,R8
   \   000001BC   0x.... 0x....      BL       __aeabi_fmul
   \   000001C0   0x9008             STR      R0,[SP, #+32]
   \   000001C2   0x9801             LDR      R0,[SP, #+4]
   \   000001C4   0x4641             MOV      R1,R8
   \   000001C6   0x.... 0x....      BL       __aeabi_fmul
   \   000001CA   0x9009             STR      R0,[SP, #+36]
   \   000001CC   0x9800             LDR      R0,[SP, #+0]
   \   000001CE   0x4641             MOV      R1,R8
   \   000001D0   0x.... 0x....      BL       __aeabi_fmul
   \   000001D4   0x900A             STR      R0,[SP, #+40]
  14518                            xdiff * inv_segments,
  14519                            ydiff * inv_segments,
  14520                            zdiff * inv_segments,
  14521                            ediff * inv_segments
  14522                          };
  14523          
  14524              // SERIAL_ECHOPAIR("mm=", cartesian_mm);
  14525              // SERIAL_ECHOPAIR(" seconds=", seconds);
  14526              // SERIAL_ECHOLNPAIR(" segments=", segments);
  14527          
  14528              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14529                // SCARA needs to scale the feed rate from mm/s to degrees/s
  14530                // i.e., Complete the angular vector in the given time.
  14531                const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
  14532                            inverse_secs = inv_segment_length * _feedrate_mm_s;
  14533                float oldA = stepper.get_axis_position_degrees(A_AXIS),
  14534                      oldB = stepper.get_axis_position_degrees(B_AXIS);
  14535              #endif
  14536          
  14537              // Get the current position as starting point
  14538              float raw[XYZE];
  14539              COPY(raw, current_position);
   \   000001D6   0x2210             MOVS     R2,#+16
   \   000001D8   0xF104 0x0108      ADD      R1,R4,#+8
   \   000001DC   0xA803             ADD      R0,SP,#+12
   \   000001DE   0x.... 0x....      BL       memcpy
   \   000001E2   0xE009             B.N      ??prepare_kinematic_move_to_20
  14540          
  14541          
  14542              // Calculate and execute the segments
  14543              while (--segments) {
  14544          
  14545                static millis_t next_idle_ms = millis() + 200UL;
  14546                thermalManager.manage_heater();  // This returns immediately if not really needed.
  14547                if (ELAPSED(millis(), next_idle_ms)) {
  14548                  next_idle_ms = millis() + 200UL;
  14549                  idle();
  14550                }
  14551          
  14552                LOOP_XYZE(i) raw[i] += segment_distance[i];
  14553                //#if ENABLED(DELTA)
  14554                if(MACHINETPYE&DELTA)
  14555                  DELTA_IK(raw); // Delta can inline its kinematics
  14556                //#else
  14557                else
  14558                  inverse_kinematics(raw);
  14559                //#endif
  14560          
  14561                ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
  14562          
  14563                #if ENABLED(SCARA_FEEDRATE_SCALING)
  14564                  // For SCARA scale the feed rate from mm/s to degrees/s
  14565                  // i.e., Complete the angular vector in the given time.
  14566                  planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14567                  oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
  14568                #else
  14569                    if (gCfgItems.breakpoint_reprint_flg == 1) 
  14570                    {
  14571                        if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
  14572                        {
  14573                            //current_position[Z_AXIS] = rtarget[Z_AXIS];
  14574                            //current_position[E_AXIS] = destination[E_AXIS];
  14575          
  14576                            gCfgItems.had_breakpoint=1;
  14577                            gCfgItems.breakpoint_e_position=LROUND(raw[E_AXIS] * planner.axis_steps_per_mm[E_AXIS]);
  14578                                              
  14579                            return false;
  14580                        }
  14581                    }
  14582                  //gCfgItems.breakpoint_reprint_flg = 0;
  14583                  planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
   \                     ??prepare_kinematic_move_to_21: (+1)
   \   000001E4   0x78E0             LDRB     R0,[R4, #+3]
   \   000001E6   0x9001             STR      R0,[SP, #+4]
   \   000001E8   0xA802             ADD      R0,SP,#+8
   \   000001EA   0x9000             STR      R0,[SP, #+0]
   \   000001EC   0xAB06             ADD      R3,SP,#+24
   \   000001EE   0x6DA2             LDR      R2,[R4, #+88]
   \   000001F0   0x6D61             LDR      R1,[R4, #+84]
   \   000001F2   0x6D20             LDR      R0,[R4, #+80]
   \   000001F4   0x.... 0x....      BL       _ZN7Planner11buffer_lineEfffRKfS1_h
   \                     ??prepare_kinematic_move_to_20: (+1)
   \   000001F8   0x1E76             SUBS     R6,R6,#+1
   \   000001FA   0xB2B6             UXTH     R6,R6
   \   000001FC   0x2E00             CMP      R6,#+0
   \   000001FE   0xF000 0x811D      BEQ.W    ??prepare_kinematic_move_to_2
   \   00000202   0x4F99             LDR.N    R7,??prepare_kinematic_move_to_0+0x18
   \   00000204   0x4899             LDR.N    R0,??prepare_kinematic_move_to_0+0x1C
   \   00000206   0x7801             LDRB     R1,[R0, #+0]
   \   00000208   0x2900             CMP      R1,#+0
   \   0000020A   0xD105             BNE.N    ??prepare_kinematic_move_to_22
   \   0000020C   0x2101             MOVS     R1,#+1
   \   0000020E   0x7001             STRB     R1,[R0, #+0]
   \   00000210   0x.... 0x....      BL       HAL_GetTick
   \   00000214   0x30C8             ADDS     R0,R0,#+200
   \   00000216   0x6038             STR      R0,[R7, #+0]
   \                     ??prepare_kinematic_move_to_22: (+1)
   \   00000218   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   \   0000021C   0x.... 0x....      BL       HAL_GetTick
   \   00000220   0x6839             LDR      R1,[R7, #+0]
   \   00000222   0x1A40             SUBS     R0,R0,R1
   \   00000224   0xD405             BMI.N    ??prepare_kinematic_move_to_23
   \   00000226   0x.... 0x....      BL       HAL_GetTick
   \   0000022A   0x30C8             ADDS     R0,R0,#+200
   \   0000022C   0x6038             STR      R0,[R7, #+0]
   \   0000022E   0x.... 0x....      BL       _Z4idlev
   \                     ??prepare_kinematic_move_to_23: (+1)
   \   00000232   0xF04F 0x0800      MOV      R8,#+0
   \   00000236   0xAF03             ADD      R7,SP,#+12
   \   00000238   0xE00A             B.N      ??prepare_kinematic_move_to_24
   \                     ??prepare_kinematic_move_to_25: (+1)
   \   0000023A   0xF857 0x0028      LDR      R0,[R7, R8, LSL #+2]
   \   0000023E   0xA907             ADD      R1,SP,#+28
   \   00000240   0xF851 0x1028      LDR      R1,[R1, R8, LSL #+2]
   \   00000244   0x.... 0x....      BL       __aeabi_fadd
   \   00000248   0xF847 0x0028      STR      R0,[R7, R8, LSL #+2]
   \   0000024C   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??prepare_kinematic_move_to_24: (+1)
   \   00000250   0xF1B8 0x0F04      CMP      R8,#+4
   \   00000254   0xDBF1             BLT.N    ??prepare_kinematic_move_to_25
   \   00000256   0x4881             LDR.N    R0,??prepare_kinematic_move_to_0+0xC
   \   00000258   0xF890 0x0058      LDRB     R0,[R0, #+88]
   \   0000025C   0x0780             LSLS     R0,R0,#+30
   \   0000025E   0xF140 0x80CB      BPL.W    ??prepare_kinematic_move_to_26
   \   00000262   0x68E8             LDR      R0,[R5, #+12]
   \   00000264   0x9903             LDR      R1,[SP, #+12]
   \   00000266   0x.... 0x....      BL       __aeabi_fsub
   \   0000026A   0x4607             MOV      R7,R0
   \   0000026C   0xF04F 0x0902      MOV      R9,#+2
   \   00000270   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000274   0xE004             B.N      ??prepare_kinematic_move_to_27
   \                     ??prepare_kinematic_move_to_28: (+1)
   \   00000276   0x4638             MOV      R0,R7
   \   00000278   0x4639             MOV      R1,R7
   \   0000027A   0x.... 0x....      BL       __aeabi_fmul
   \   0000027E   0x4607             MOV      R7,R0
   \                     ??prepare_kinematic_move_to_27: (+1)
   \   00000280   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000284   0xD504             BPL.N    ??prepare_kinematic_move_to_29
   \   00000286   0x4640             MOV      R0,R8
   \   00000288   0x4639             MOV      R1,R7
   \   0000028A   0x.... 0x....      BL       __aeabi_fmul
   \   0000028E   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_29: (+1)
   \   00000290   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000294   0xD1EF             BNE.N    ??prepare_kinematic_move_to_28
   \   00000296   0xAF03             ADD      R7,SP,#+12
   \   00000298   0x6928             LDR      R0,[R5, #+16]
   \   0000029A   0x6879             LDR      R1,[R7, #+4]
   \   0000029C   0x.... 0x....      BL       __aeabi_fsub
   \   000002A0   0x4683             MOV      R11,R0
   \   000002A2   0xF04F 0x0902      MOV      R9,#+2
   \   000002A6   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000002AA   0xE004             B.N      ??prepare_kinematic_move_to_30
   \                     ??prepare_kinematic_move_to_31: (+1)
   \   000002AC   0x4658             MOV      R0,R11
   \   000002AE   0x4659             MOV      R1,R11
   \   000002B0   0x.... 0x....      BL       __aeabi_fmul
   \   000002B4   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_30: (+1)
   \   000002B6   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000002BA   0xD504             BPL.N    ??prepare_kinematic_move_to_32
   \   000002BC   0x4650             MOV      R0,R10
   \   000002BE   0x4659             MOV      R1,R11
   \   000002C0   0x.... 0x....      BL       __aeabi_fmul
   \   000002C4   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_32: (+1)
   \   000002C6   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000002CA   0xD1EF             BNE.N    ??prepare_kinematic_move_to_31
   \   000002CC   0x4640             MOV      R0,R8
   \   000002CE   0x4651             MOV      R1,R10
   \   000002D0   0x.... 0x....      BL       __aeabi_fadd
   \   000002D4   0x4601             MOV      R1,R0
   \   000002D6   0x6BE8             LDR      R0,[R5, #+60]
   \   000002D8   0x.... 0x....      BL       __aeabi_fsub
   \   000002DC   0x.... 0x....      BL       sqrtf
   \   000002E0   0x4601             MOV      R1,R0
   \   000002E2   0x68B8             LDR      R0,[R7, #+8]
   \   000002E4   0x.... 0x....      BL       __aeabi_fadd
   \   000002E8   0x6520             STR      R0,[R4, #+80]
   \   000002EA   0x6968             LDR      R0,[R5, #+20]
   \   000002EC   0x9903             LDR      R1,[SP, #+12]
   \   000002EE   0x.... 0x....      BL       __aeabi_fsub
   \   000002F2   0x4681             MOV      R9,R0
   \   000002F4   0xF04F 0x0A02      MOV      R10,#+2
   \   000002F8   0xF04F 0x587E      MOV      R8,#+1065353216
   \   000002FC   0xE004             B.N      ??prepare_kinematic_move_to_33
   \                     ??prepare_kinematic_move_to_34: (+1)
   \   000002FE   0x4648             MOV      R0,R9
   \   00000300   0x4649             MOV      R1,R9
   \   00000302   0x.... 0x....      BL       __aeabi_fmul
   \   00000306   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_33: (+1)
   \   00000308   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   0000030C   0xD504             BPL.N    ??prepare_kinematic_move_to_35
   \   0000030E   0x4640             MOV      R0,R8
   \   00000310   0x4649             MOV      R1,R9
   \   00000312   0x.... 0x....      BL       __aeabi_fmul
   \   00000316   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_35: (+1)
   \   00000318   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   0000031C   0xD1EF             BNE.N    ??prepare_kinematic_move_to_34
   \   0000031E   0x69A8             LDR      R0,[R5, #+24]
   \   00000320   0x6879             LDR      R1,[R7, #+4]
   \   00000322   0x.... 0x....      BL       __aeabi_fsub
   \   00000326   0x4683             MOV      R11,R0
   \   00000328   0xF04F 0x0902      MOV      R9,#+2
   \   0000032C   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   00000330   0xE004             B.N      ??prepare_kinematic_move_to_36
   \                     ??prepare_kinematic_move_to_37: (+1)
   \   00000332   0x4658             MOV      R0,R11
   \   00000334   0x4659             MOV      R1,R11
   \   00000336   0x.... 0x....      BL       __aeabi_fmul
   \   0000033A   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_36: (+1)
   \   0000033C   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000340   0xD504             BPL.N    ??prepare_kinematic_move_to_38
   \   00000342   0x4650             MOV      R0,R10
   \   00000344   0x4659             MOV      R1,R11
   \   00000346   0x.... 0x....      BL       __aeabi_fmul
   \   0000034A   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_38: (+1)
   \   0000034C   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000350   0xD1EF             BNE.N    ??prepare_kinematic_move_to_37
   \   00000352   0x4640             MOV      R0,R8
   \   00000354   0x4651             MOV      R1,R10
   \   00000356   0x.... 0x....      BL       __aeabi_fadd
   \   0000035A   0x4601             MOV      R1,R0
   \   0000035C   0x6C28             LDR      R0,[R5, #+64]
   \   0000035E   0x.... 0x....      BL       __aeabi_fsub
   \   00000362   0x.... 0x....      BL       sqrtf
   \   00000366   0x4601             MOV      R1,R0
   \   00000368   0x68B8             LDR      R0,[R7, #+8]
   \   0000036A   0x.... 0x....      BL       __aeabi_fadd
   \   0000036E   0x6560             STR      R0,[R4, #+84]
   \   00000370   0x69E8             LDR      R0,[R5, #+28]
   \   00000372   0x9903             LDR      R1,[SP, #+12]
   \   00000374   0x.... 0x....      BL       __aeabi_fsub
   \   00000378   0x4681             MOV      R9,R0
   \   0000037A   0xF04F 0x0A02      MOV      R10,#+2
   \   0000037E   0xF04F 0x587E      MOV      R8,#+1065353216
   \   00000382   0xE004             B.N      ??prepare_kinematic_move_to_39
   \                     ??prepare_kinematic_move_to_40: (+1)
   \   00000384   0x4648             MOV      R0,R9
   \   00000386   0x4649             MOV      R1,R9
   \   00000388   0x.... 0x....      BL       __aeabi_fmul
   \   0000038C   0x4681             MOV      R9,R0
   \                     ??prepare_kinematic_move_to_39: (+1)
   \   0000038E   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000392   0xD504             BPL.N    ??prepare_kinematic_move_to_41
   \   00000394   0x4640             MOV      R0,R8
   \   00000396   0x4649             MOV      R1,R9
   \   00000398   0x.... 0x....      BL       __aeabi_fmul
   \   0000039C   0x4680             MOV      R8,R0
   \                     ??prepare_kinematic_move_to_41: (+1)
   \   0000039E   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000003A2   0xD1EF             BNE.N    ??prepare_kinematic_move_to_40
   \   000003A4   0x6A28             LDR      R0,[R5, #+32]
   \   000003A6   0x6879             LDR      R1,[R7, #+4]
   \   000003A8   0x.... 0x....      BL       __aeabi_fsub
   \   000003AC   0x4683             MOV      R11,R0
   \   000003AE   0xF04F 0x0902      MOV      R9,#+2
   \   000003B2   0xF04F 0x5A7E      MOV      R10,#+1065353216
   \   000003B6   0xE004             B.N      ??prepare_kinematic_move_to_42
   \                     ??prepare_kinematic_move_to_43: (+1)
   \   000003B8   0x4658             MOV      R0,R11
   \   000003BA   0x4659             MOV      R1,R11
   \   000003BC   0x.... 0x....      BL       __aeabi_fmul
   \   000003C0   0x4683             MOV      R11,R0
   \                     ??prepare_kinematic_move_to_42: (+1)
   \   000003C2   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   000003C6   0xD504             BPL.N    ??prepare_kinematic_move_to_44
   \   000003C8   0x4650             MOV      R0,R10
   \   000003CA   0x4659             MOV      R1,R11
   \   000003CC   0x.... 0x....      BL       __aeabi_fmul
   \   000003D0   0x4682             MOV      R10,R0
   \                     ??prepare_kinematic_move_to_44: (+1)
   \   000003D2   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   000003D6   0xD1EF             BNE.N    ??prepare_kinematic_move_to_43
   \   000003D8   0x4640             MOV      R0,R8
   \   000003DA   0x4651             MOV      R1,R10
   \   000003DC   0x.... 0x....      BL       __aeabi_fadd
   \   000003E0   0x4601             MOV      R1,R0
   \   000003E2   0x6C68             LDR      R0,[R5, #+68]
   \   000003E4   0x.... 0x....      BL       __aeabi_fsub
   \   000003E8   0x.... 0x....      BL       sqrtf
   \   000003EC   0x4601             MOV      R1,R0
   \   000003EE   0x68B8             LDR      R0,[R7, #+8]
   \   000003F0   0x.... 0x....      BL       __aeabi_fadd
   \   000003F4   0x65A0             STR      R0,[R4, #+88]
   \   000003F6   0xE002             B.N      ??prepare_kinematic_move_to_45
   \                     ??prepare_kinematic_move_to_26: (+1)
   \   000003F8   0xA803             ADD      R0,SP,#+12
   \   000003FA   0x.... 0x....      BL       _Z18inverse_kinematicsPKf
   \                     ??prepare_kinematic_move_to_45: (+1)
   \   000003FE   0xA803             ADD      R0,SP,#+12
   \   00000400   0x.... 0x....      BL       _Z12ADJUST_DELTAPKf
   \   00000404   0x4A1A             LDR.N    R2,??prepare_kinematic_move_to_0+0x20
   \   00000406   0xF892 0x0148      LDRB     R0,[R2, #+328]
   \   0000040A   0x2801             CMP      R0,#+1
   \   0000040C   0xF47F 0xAEEA      BNE.W    ??prepare_kinematic_move_to_21
   \   00000410   0x980C             LDR      R0,[SP, #+48]
   \   00000412   0x6880             LDR      R0,[R0, #+8]
   \   00000414   0xF8D2 0x1298      LDR      R1,[R2, #+664]
   \   00000418   0x.... 0x....      BL       __aeabi_cfcmple
   \   0000041C   0xF4BF 0xAEE2      BCS.W    ??prepare_kinematic_move_to_21
   \   00000420   0xF502 0x74A4      ADD      R4,R2,#+328
   \   00000424   0x2001             MOVS     R0,#+1
   \   00000426   0x7320             STRB     R0,[R4, #+12]
   \   00000428   0x9906             LDR      R1,[SP, #+24]
   \   0000042A   0x4812             LDR.N    R0,??prepare_kinematic_move_to_0+0x24
   \   0000042C   0x68C0             LDR      R0,[R0, #+12]
   \   0000042E   0x.... 0x....      BL       __aeabi_fmul
   \   00000432   0x.... 0x....      BL       lroundf
   \   00000436   0x60A0             STR      R0,[R4, #+8]
   \   00000438   0x2000             MOVS     R0,#+0
   \   0000043A   0xE005             B.N      ??prepare_kinematic_move_to_17
  14584                #endif
  14585              }
  14586          
  14587              // Ensure last segment arrives at target location.
  14588              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14589                inverse_kinematics(rtarget);
  14590                ADJUST_DELTA(rtarget);
  14591                planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14592              #else
  14593                planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
   \                     ??prepare_kinematic_move_to_2: (+1)
   \   0000043C   0x78E2             LDRB     R2,[R4, #+3]
   \   0000043E   0xA902             ADD      R1,SP,#+8
   \   00000440   0x980C             LDR      R0,[SP, #+48]
   \   00000442   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
  14594              #endif
  14595          
  14596              return false; // caller will update current_position
   \   00000446   0x2000             MOVS     R0,#+0
   \                     ??prepare_kinematic_move_to_17: (+1)
   \   00000448   0xB00D             ADD      SP,SP,#+52
   \   0000044A   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
   \   0000044E   0xBF00             Nop      
   \                     ??prepare_kinematic_move_to_0:
   \   00000450   0x........         DC32     mks_heating_busy
   \   00000454   0x47AE147B         DC32     0x47ae147b
   \   00000458   0x3F847AE1         DC32     0x3f847ae1
   \   0000045C   0x........         DC32     mksCfg
   \   00000460   0x358637BE         DC32     0x358637be
   \   00000464   0x........         DC32     axis_homed
   \   00000468   0x........         DC32     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
   \   0000046C   0x........         DC32     _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
   \   00000470   0x........         DC32     gCfgItems
   \   00000474   0x........         DC32     _ZN7Planner17axis_steps_per_mmE
  14597            }
  14598          #endif
  14599          //#else // !IS_KINEMATIC
  14600          #if 1
  14601            /**
  14602             * Prepare a linear move in a Cartesian setup.
  14603             *
  14604             * When a mesh-based leveling system is active, moves are segmented
  14605             * according to the configuration of the leveling system.
  14606             *
  14607             * Returns true if current_position[] was set to destination[]
  14608             */

   \                                 In section .text, align 4
  14609            inline bool prepare_move_to_destination_cartesian() {
   \                     _Z37prepare_move_to_destination_cartesianv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
  14610              #if 1//HAS_MESH
  14611                if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
   \   00000004   0x4C3B             LDR.N    R4,??prepare_move_to_destination_cartesian_0
   \   00000006   0x483C             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x4
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD05F             BEQ.N    ??prepare_move_to_destination_cartesian_1
   \   0000000E   0xF104 0x0020      ADD      R0,R4,#+32
   \   00000012   0x.... 0x....      BL       _ZN7Planner20leveling_active_at_zERKf
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD059             BEQ.N    ??prepare_move_to_destination_cartesian_1
   \   0000001A   0x4838             LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x8
   \   0000001C   0xF890 0x2040      LDRB     R2,[R0, #+64]
   \   00000020   0x2A10             CMP      R2,#+16
   \   00000022   0xD115             BNE.N    ??prepare_move_to_destination_cartesian_2
  14612                  //#if ENABLED(AUTO_BED_LEVELING_UBL)
  14613                  if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
  14614                  {
  14615                    ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
   \   00000024   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000028   0x.... 0x....      BL       __aeabi_i2f
   \   0000002C   0x6DE1             LDR      R1,[R4, #+92]
   \   0000002E   0x.... 0x....      BL       __aeabi_fmul
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4A32             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   00000038   0x4B32             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   0000003A   0x.... 0x....      BL       __aeabi_dmul
   \   0000003E   0x.... 0x....      BL       __aeabi_d2f
   \   00000042   0x9000             STR      R0,[SP, #+0]
   \   00000044   0x78E1             LDRB     R1,[R4, #+3]
   \   00000046   0xA800             ADD      R0,SP,#+0
   \   00000048   0x.... 0x....      BL       _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
  14616                    return true;     
   \   0000004C   0x2001             MOVS     R0,#+1
   \   0000004E   0xBD76             POP      {R1,R2,R4-R6,PC}
  14617          		 }// all moves, including Z-only moves.
  14618                  //#elif ENABLED(SEGMENT_LEVELED_MOVES)
  14619          		//{
  14620                  //  segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
  14621                  //  return false; // caller will update current_position
  14622          		//}
  14623                  //#else
  14624                  else
  14625                  {
  14626                    #if ENABLED(SEGMENT_LEVELED_MOVES)
  14627                      segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
  14628                      return false; // caller will update current_position
  14629                    #else
  14630                    /**
  14631                     * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
  14632                     * Otherwise fall through to do a direct single move.
  14633                     */
  14634                    if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
   \                     ??prepare_move_to_destination_cartesian_2: (+1)
   \   00000050   0x68A0             LDR      R0,[R4, #+8]
   \   00000052   0x69A1             LDR      R1,[R4, #+24]
   \   00000054   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000058   0xD104             BNE.N    ??prepare_move_to_destination_cartesian_3
   \   0000005A   0x68E0             LDR      R0,[R4, #+12]
   \   0000005C   0x69E1             LDR      R1,[R4, #+28]
   \   0000005E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000062   0xD034             BEQ.N    ??prepare_move_to_destination_cartesian_1
  14635                      //#if ENABLED(MESH_BED_LEVELING)
  14636                      if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
   \                     ??prepare_move_to_destination_cartesian_3: (+1)
   \   00000064   0x2A20             CMP      R2,#+32
   \   00000066   0xD117             BNE.N    ??prepare_move_to_destination_cartesian_4
  14637                        mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \   00000068   0x22FF             MOVS     R2,#+255
   \   0000006A   0x4611             MOV      R1,R2
   \   0000006C   0x460D             MOV      R5,R1
   \   0000006E   0x4616             MOV      R6,R2
   \   00000070   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000074   0x.... 0x....      BL       __aeabi_i2f
   \   00000078   0x6DE1             LDR      R1,[R4, #+92]
   \   0000007A   0x.... 0x....      BL       __aeabi_fmul
   \   0000007E   0x.... 0x....      BL       __aeabi_f2d
   \   00000082   0x4A1F             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   00000084   0x4B1F             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   00000086   0x.... 0x....      BL       __aeabi_dmul
   \   0000008A   0x.... 0x....      BL       __aeabi_d2f
   \   0000008E   0x4632             MOV      R2,R6
   \   00000090   0x4629             MOV      R1,R5
   \   00000092   0x.... 0x....      BL       _Z24mesh_line_to_destinationfhh
   \   00000096   0xE018             B.N      ??prepare_move_to_destination_cartesian_5
  14638                      //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
  14639                      else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
   \                     ??prepare_move_to_destination_cartesian_4: (+1)
   \   00000098   0x2A08             CMP      R2,#+8
   \   0000009A   0xD116             BNE.N    ??prepare_move_to_destination_cartesian_5
  14640                        bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \   0000009C   0xF64F 0x71FF      MOVW     R1,#+65535
   \   000000A0   0x460A             MOV      R2,R1
   \   000000A2   0x4615             MOV      R5,R2
   \   000000A4   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   000000A8   0x.... 0x....      BL       __aeabi_i2f
   \   000000AC   0x6DE1             LDR      R1,[R4, #+92]
   \   000000AE   0x.... 0x....      BL       __aeabi_fmul
   \   000000B2   0x.... 0x....      BL       __aeabi_f2d
   \   000000B6   0x4A12             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   000000B8   0x4B12             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   000000BA   0x.... 0x....      BL       __aeabi_dmul
   \   000000BE   0x.... 0x....      BL       __aeabi_d2f
   \   000000C2   0x462A             MOV      R2,R5
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0x.... 0x....      BL       _Z28bilinear_line_to_destinationftt
  14641                      //#endif
  14642                      return true;
   \                     ??prepare_move_to_destination_cartesian_5: (+1)
   \   000000CA   0x2001             MOVS     R0,#+1
   \   000000CC   0xBD76             POP      {R1,R2,R4-R6,PC}
  14643                    }
  14644                    #endif
  14645                  }
  14646                  //#endif
  14647                }
  14648              #endif // HAS_MESH
  14649          
  14650              buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
   \                     ??prepare_move_to_destination_cartesian_1: (+1)
   \   000000CE   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   000000D2   0x.... 0x....      BL       __aeabi_i2f
   \   000000D6   0x6DE1             LDR      R1,[R4, #+92]
   \   000000D8   0x.... 0x....      BL       __aeabi_fmul
   \   000000DC   0x.... 0x....      BL       __aeabi_f2d
   \   000000E0   0x4A07             LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
   \   000000E2   0x4B08             LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
   \   000000E4   0x.... 0x....      BL       __aeabi_dmul
   \   000000E8   0x.... 0x....      BL       __aeabi_d2f
   \   000000EC   0x.... 0x....      BL       _Z26buffer_line_to_destinationf
  14651              return false; // caller will update current_position
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
   \                     ??prepare_move_to_destination_cartesian_0:
   \   000000F4   0x........         DC32     mks_heating_busy
   \   000000F8   0x........         DC32     _ZN7Planner15leveling_activeE
   \   000000FC   0x........         DC32     mksCfg
   \   00000100   0x47AE147B         DC32     0x47ae147b
   \   00000104   0x3F847AE1         DC32     0x3f847ae1
  14652            }
  14653          
  14654          #endif // !IS_KINEMATIC
  14655          #endif // !UBL_SEGMENTED
  14656          
  14657          #if ENABLED(DUAL_X_CARRIAGE)
  14658          
  14659            /**
  14660             * Unpark the carriage, if needed
  14661             */
  14662            inline bool dual_x_carriage_unpark() {
  14663              if (active_extruder_parked)
  14664                switch (dual_x_carriage_mode) {
  14665          
  14666                  case DXC_FULL_CONTROL_MODE: break;
  14667          
  14668                  case DXC_AUTO_PARK_MODE:
  14669                    if (current_position[E_AXIS] == destination[E_AXIS]) {
  14670                      // This is a travel move (with no extrusion)
  14671                      // Skip it, but keep track of the current position
  14672                      // (so it can be used as the start of the next non-travel move)
  14673                      if (delayed_move_time != 0xFFFFFFFFUL) {
  14674                        set_current_from_destination();
  14675                        NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
  14676                        delayed_move_time = millis();
  14677                        return true;
  14678                      }
  14679                    }
  14680                    // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
  14681                    for (uint8_t i = 0; i < 3; i++)
  14682                      planner.buffer_line(
  14683                        i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
  14684                        i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
  14685                        i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
  14686                        current_position[E_AXIS],
  14687                        i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
  14688                        active_extruder
  14689                      );
  14690                    delayed_move_time = 0;
  14691                    active_extruder_parked = false;
  14692                    #if ENABLED(DEBUG_LEVELING_FEATURE)
  14693                      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
  14694                    #endif
  14695                    break;
  14696          
  14697                  case DXC_DUPLICATION_MODE:
  14698                    if (active_extruder == 0) {
  14699                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  14700                        if (DEBUGGING(LEVELING)) {
  14701                          SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
  14702                          SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
  14703                        }
  14704                      #endif
  14705                      // move duplicate extruder into correct duplication position.
  14706                      planner.set_position_mm(
  14707                        inactive_extruder_x_pos,
  14708                        current_position[Y_AXIS],
  14709                        current_position[Z_AXIS],
  14710                        current_position[E_AXIS]
  14711                      );
  14712                      planner.buffer_line(
  14713                        current_position[X_AXIS] + duplicate_extruder_x_offset,
  14714                        current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
  14715                        planner.max_feedrate_mm_s[X_AXIS], 1
  14716                      );
  14717                      SYNC_PLAN_POSITION_KINEMATIC();
  14718                      stepper.synchronize();
  14719                      extruder_duplication_enabled = true;
  14720                      active_extruder_parked = false;
  14721                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  14722                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
  14723                      #endif
  14724                    }
  14725                    else {
  14726                      #if ENABLED(DEBUG_LEVELING_FEATURE)
  14727                        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
  14728                      #endif
  14729                    }
  14730                    break;
  14731                }
  14732              return false;
  14733            }
  14734          
  14735          #endif // DUAL_X_CARRIAGE
  14736          
  14737          /**
  14738           * Prepare a single move and get ready for the next one
  14739           *
  14740           * This may result in several calls to planner.buffer_line to
  14741           * do smaller moves for DELTA, SCARA, mesh moves, etc.
  14742           *
  14743           * Make sure current_position[E] and destination[E] are good
  14744           * before calling or cold/lengthy extrusion may get missed.
  14745           */

   \                                 In section .text, align 2, keep-with-next
  14746          void prepare_move_to_destination() {
   \                     _Z27prepare_move_to_destinationv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  14747            clamp_to_software_endstops(destination);
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable175
   \   00000006   0xF104 0x0018      ADD      R0,R4,#+24
   \   0000000A   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  14748            refresh_cmd_timeout();
   \   0000000E   0x.... 0x....      BL       _Z19refresh_cmd_timeoutv
  14749          
  14750            #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
  14751          
  14752              if (!DEBUGGING(DRYRUN)) {
   \   00000012   0x7860             LDRB     R0,[R4, #+1]
   \   00000014   0x0700             LSLS     R0,R0,#+28
   \   00000016   0xD42F             BMI.N    ??prepare_move_to_destination_0
  14753                if (destination[E_AXIS] != current_position[E_AXIS]) {
   \   00000018   0x6A65             LDR      R5,[R4, #+36]
   \   0000001A   0x4628             MOV      R0,R5
   \   0000001C   0x6961             LDR      R1,[R4, #+20]
   \   0000001E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000022   0xD029             BEQ.N    ??prepare_move_to_destination_0
  14754                  #if ENABLED(PREVENT_COLD_EXTRUSION)
  14755                    if (thermalManager.tooColdToExtrude(active_extruder)) {
   \   00000024   0x78E0             LDRB     R0,[R4, #+3]
   \   00000026   0x.... 0x....      BL       _ZN11Temperature16tooColdToExtrudeEh
   \   0000002A   0x2800             CMP      R0,#+0
   \   0000002C   0xD008             BEQ.N    ??prepare_move_to_destination_1
  14756                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   0000002E   0x6165             STR      R5,[R4, #+20]
  14757                      SERIAL_ECHO_START();
   \   00000030   0x.... 0x....      LDR.W    R0,??DataTable183
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14758                      SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   \   00000038   0x.... 0x....      ADR.W    R0,`?<Constant " cold extrusion preve...">`
   \   0000003C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14759                    }
  14760                  #endif // PREVENT_COLD_EXTRUSION
  14761                  #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
  14762                    if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
   \                     ??prepare_move_to_destination_1: (+1)
   \   00000040   0x6A60             LDR      R0,[R4, #+36]
   \   00000042   0x6961             LDR      R1,[R4, #+20]
   \   00000044   0x.... 0x....      BL       __aeabi_fsub
   \   00000048   0xF020 0x4100      BIC      R1,R0,#0x80000000
   \   0000004C   0x78E0             LDRB     R0,[R4, #+3]
   \   0000004E   0x.... 0x....      LDR.W    R2,??DataTable183_1
   \   00000052   0xF852 0x0020      LDR      R0,[R2, R0, LSL #+2]
   \   00000056   0x.... 0x....      BL       __aeabi_fmul
   \   0000005A   0x.... 0x....      LDR.W    R1,??DataTable183_2  ;; 0x447a0001
   \   0000005E   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000062   0xD809             BHI.N    ??prepare_move_to_destination_0
  14763                      current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
   \   00000064   0x6A60             LDR      R0,[R4, #+36]
   \   00000066   0x6160             STR      R0,[R4, #+20]
  14764                      SERIAL_ECHO_START();
   \   00000068   0x.... 0x....      LDR.W    R0,??DataTable183
   \   0000006C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14765                      SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   \   00000070   0x.... 0x....      ADR.W    R0,`?<Constant " too long extrusion p...">`
   \   00000074   0x.... 0x....      BL       _Z14serialprintPGMPKc
  14766                    }
  14767                  #endif // PREVENT_LENGTHY_EXTRUDE
  14768                }
  14769              }
  14770          
  14771            #endif
  14772          
  14773            #if ENABLED(DUAL_X_CARRIAGE)
  14774              if (dual_x_carriage_unpark()) return;
  14775            #endif
  14776            
  14777          #if 0
  14778            if (
  14779              #if UBL_SEGMENTED
  14780                ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
  14781              #elif IS_KINEMATIC
  14782                prepare_kinematic_move_to(destination)
  14783              #else
  14784                prepare_move_to_destination_cartesian()
  14785              #endif
  14786            ) return;
  14787          #endif
  14788          
  14789            if((BED_LEVELING_METHOD &AUTO_BED_LEVELING_UBL) && (MACHINETPYE == DELTA /*|| ENABLED(SEGMENT_LEVELED_MOVES)*/))
   \                     ??prepare_move_to_destination_0: (+1)
   \   00000078   0x.... 0x....      LDR.W    R0,??DataTable175_1
   \   0000007C   0xF100 0x0140      ADD      R1,R0,#+64
   \   00000080   0xF9B1 0x1018      LDRSH    R1,[R1, #+24]
   \   00000084   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000088   0x06C0             LSLS     R0,R0,#+27
   \   0000008A   0xD51B             BPL.N    ??prepare_move_to_destination_2
   \   0000008C   0x2902             CMP      R1,#+2
   \   0000008E   0xD119             BNE.N    ??prepare_move_to_destination_2
  14790            {
  14791              if(ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)))return;
   \   00000090   0xF9B4 0x0006      LDRSH    R0,[R4, #+6]
   \   00000094   0x.... 0x....      BL       __aeabi_i2f
   \   00000098   0x6DE1             LDR      R1,[R4, #+92]
   \   0000009A   0x.... 0x....      BL       __aeabi_fmul
   \   0000009E   0x.... 0x....      BL       __aeabi_f2d
   \   000000A2   0x.... 0x....      LDR.W    R2,??DataTable184  ;; 0x47ae147b
   \   000000A6   0x.... 0x....      LDR.W    R3,??DataTable185  ;; 0x3f847ae1
   \   000000AA   0x.... 0x....      BL       __aeabi_dmul
   \   000000AE   0x.... 0x....      BL       __aeabi_d2f
   \   000000B2   0x9000             STR      R0,[SP, #+0]
   \   000000B4   0xA900             ADD      R1,SP,#+0
   \   000000B6   0xF104 0x0018      ADD      R0,R4,#+24
   \   000000BA   0x.... 0x....      BL       _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD00F             BEQ.N    ??prepare_move_to_destination_3
   \   000000C2   0xBD31             POP      {R0,R4,R5,PC}
  14792            } 
  14793            else if(MACHINETPYE & IS_KINEMATIC)
   \                     ??prepare_move_to_destination_2: (+1)
   \   000000C4   0xF240 0x3002      MOVW     R0,#+770
   \   000000C8   0x4201             TST      R1,R0
   \   000000CA   0xD006             BEQ.N    ??prepare_move_to_destination_4
  14794            {
  14795              if(prepare_kinematic_move_to(destination))return;
   \   000000CC   0xF104 0x0018      ADD      R0,R4,#+24
   \   000000D0   0x.... 0x....      BL       _Z25prepare_kinematic_move_toRA4_Kf
   \   000000D4   0x2800             CMP      R0,#+0
   \   000000D6   0xD004             BEQ.N    ??prepare_move_to_destination_3
   \   000000D8   0xBD31             POP      {R0,R4,R5,PC}
  14796            }  
  14797            else//if(MACHINETPYE & IS_CARTESIAN)
  14798            {
  14799              if(prepare_move_to_destination_cartesian())return;
   \                     ??prepare_move_to_destination_4: (+1)
   \   000000DA   0x.... 0x....      BL       _Z37prepare_move_to_destination_cartesianv
   \   000000DE   0x2800             CMP      R0,#+0
   \   000000E0   0xD101             BNE.N    ??prepare_move_to_destination_5
  14800            }
  14801          
  14802            set_current_from_destination();
   \                     ??prepare_move_to_destination_3: (+1)
   \   000000E2   0x.... 0x....      BL       _Z28set_current_from_destinationv
  14803          }
   \                     ??prepare_move_to_destination_5: (+1)
   \   000000E6   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  14804          
  14805          #if ENABLED(ARC_SUPPORT)
  14806          
  14807            #if N_ARC_CORRECTION < 1
  14808              #undef N_ARC_CORRECTION
  14809              #define N_ARC_CORRECTION 1
  14810            #endif
  14811          
  14812            /**
  14813             * Plan an arc in 2 dimensions
  14814             *
  14815             * The arc is approximated by generating many small linear segments.
  14816             * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
  14817             * Arcs should only be made relatively large (over 5mm), as larger arcs with
  14818             * larger segments will tend to be more efficient. Your slicer should have
  14819             * options for G2/G3 arc generation. In future these options may be GCode tunable.
  14820             */

   \                                 In section .text, align 2, keep-with-next
  14821            void plan_arc(
  14822              const float (&cart)[XYZE], // Destination position
  14823              const float (&offset)[2], // Center of rotation relative to current_position
  14824              const bool clockwise      // Clockwise?
  14825            ) {
   \                     _Z8plan_arcRA4_KfRA2_S_b: (+1)
   \   00000000   0xE92D 0x4FF3      PUSH     {R0,R1,R4-R11,LR}
   \   00000004   0xB08D             SUB      SP,SP,#+52
   \   00000006   0x4614             MOV      R4,R2
  14826              #if ENABLED(CNC_WORKSPACE_PLANES)
  14827                AxisEnum p_axis, q_axis, l_axis;
  14828                switch (workspace_plane) {
  14829                  default:
  14830                  case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
  14831                  case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
  14832                  case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
  14833                }
  14834              #else
  14835                constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
  14836              #endif
  14837          
  14838              // Radius vector from center to current location
  14839              float r_P = -offset[0], r_Q = -offset[1];
   \   00000008   0x4608             MOV      R0,R1
   \   0000000A   0x6805             LDR      R5,[R0, #+0]
   \   0000000C   0xF085 0x4500      EOR      R5,R5,#0x80000000
   \   00000010   0x6846             LDR      R6,[R0, #+4]
   \   00000012   0xF086 0x4600      EOR      R6,R6,#0x80000000
  14840          
  14841              const float radius = HYPOT(r_P, r_Q),
   \   00000016   0x46A9             MOV      R9,R5
   \   00000018   0xF04F 0x0A02      MOV      R10,#+2
   \   0000001C   0xF04F 0x577E      MOV      R7,#+1065353216
   \   00000020   0x46B8             MOV      R8,R7
   \   00000022   0xE004             B.N      ??plan_arc_0
   \                     ??plan_arc_1: (+1)
   \   00000024   0x4648             MOV      R0,R9
   \   00000026   0x4649             MOV      R1,R9
   \   00000028   0x.... 0x....      BL       __aeabi_fmul
   \   0000002C   0x4681             MOV      R9,R0
   \                     ??plan_arc_0: (+1)
   \   0000002E   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000032   0xD504             BPL.N    ??plan_arc_2
   \   00000034   0x4640             MOV      R0,R8
   \   00000036   0x4649             MOV      R1,R9
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x4680             MOV      R8,R0
   \                     ??plan_arc_2: (+1)
   \   0000003E   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   00000042   0xD1EF             BNE.N    ??plan_arc_1
   \   00000044   0x46B3             MOV      R11,R6
   \   00000046   0xF04F 0x0902      MOV      R9,#+2
   \   0000004A   0x46BA             MOV      R10,R7
   \   0000004C   0xE004             B.N      ??plan_arc_3
   \                     ??plan_arc_4: (+1)
   \   0000004E   0x4658             MOV      R0,R11
   \   00000050   0x4659             MOV      R1,R11
   \   00000052   0x.... 0x....      BL       __aeabi_fmul
   \   00000056   0x4683             MOV      R11,R0
   \                     ??plan_arc_3: (+1)
   \   00000058   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   0000005C   0xD504             BPL.N    ??plan_arc_5
   \   0000005E   0x4650             MOV      R0,R10
   \   00000060   0x4659             MOV      R1,R11
   \   00000062   0x.... 0x....      BL       __aeabi_fmul
   \   00000066   0x4682             MOV      R10,R0
   \                     ??plan_arc_5: (+1)
   \   00000068   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   0000006C   0xD1EF             BNE.N    ??plan_arc_4
   \   0000006E   0x4640             MOV      R0,R8
   \   00000070   0x4651             MOV      R1,R10
   \   00000072   0x.... 0x....      BL       __aeabi_fadd
   \   00000076   0x.... 0x....      BL       sqrtf
   \   0000007A   0x4680             MOV      R8,R0
   \   0000007C   0x.... 0x....      LDR.W    R0,??DataTable175
   \   00000080   0x6880             LDR      R0,[R0, #+8]
   \   00000082   0x4629             MOV      R1,R5
   \   00000084   0x.... 0x....      BL       __aeabi_fsub
   \   00000088   0x9006             STR      R0,[SP, #+24]
  14842                          center_P = current_position[p_axis] - r_P,
  14843                          center_Q = current_position[q_axis] - r_Q,
   \   0000008A   0x.... 0x....      LDR.W    R0,??DataTable175
   \   0000008E   0x68C0             LDR      R0,[R0, #+12]
   \   00000090   0x4631             MOV      R1,R6
   \   00000092   0x.... 0x....      BL       __aeabi_fsub
   \   00000096   0x9005             STR      R0,[SP, #+20]
  14844                          rt_X = cart[p_axis] - center_P,
   \   00000098   0x980D             LDR      R0,[SP, #+52]
   \   0000009A   0x6800             LDR      R0,[R0, #+0]
   \   0000009C   0x9906             LDR      R1,[SP, #+24]
   \   0000009E   0x.... 0x....      BL       __aeabi_fsub
   \   000000A2   0x4681             MOV      R9,R0
  14845                          rt_Y = cart[q_axis] - center_Q,
   \   000000A4   0x980D             LDR      R0,[SP, #+52]
   \   000000A6   0x6840             LDR      R0,[R0, #+4]
   \   000000A8   0x9905             LDR      R1,[SP, #+20]
   \   000000AA   0x.... 0x....      BL       __aeabi_fsub
   \   000000AE   0x4682             MOV      R10,R0
  14846                          linear_travel = cart[l_axis] - current_position[l_axis],
   \   000000B0   0x980D             LDR      R0,[SP, #+52]
   \   000000B2   0x6880             LDR      R0,[R0, #+8]
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable175
   \   000000B8   0x6909             LDR      R1,[R1, #+16]
   \   000000BA   0x.... 0x....      BL       __aeabi_fsub
   \   000000BE   0x9000             STR      R0,[SP, #+0]
  14847                          extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
   \   000000C0   0x980D             LDR      R0,[SP, #+52]
   \   000000C2   0x68C0             LDR      R0,[R0, #+12]
   \   000000C4   0x.... 0x....      LDR.W    R1,??DataTable175
   \   000000C8   0x6949             LDR      R1,[R1, #+20]
   \   000000CA   0x.... 0x....      BL       __aeabi_fsub
   \   000000CE   0x9001             STR      R0,[SP, #+4]
  14848          
  14849              // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
  14850              float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
   \   000000D0   0x4628             MOV      R0,R5
   \   000000D2   0x4649             MOV      R1,R9
   \   000000D4   0x.... 0x....      BL       __aeabi_fmul
   \   000000D8   0x4683             MOV      R11,R0
   \   000000DA   0x4630             MOV      R0,R6
   \   000000DC   0x4651             MOV      R1,R10
   \   000000DE   0x.... 0x....      BL       __aeabi_fmul
   \   000000E2   0x4659             MOV      R1,R11
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x4601             MOV      R1,R0
   \   000000EA   0x468B             MOV      R11,R1
   \   000000EC   0x4628             MOV      R0,R5
   \   000000EE   0x4651             MOV      R1,R10
   \   000000F0   0x.... 0x....      BL       __aeabi_fmul
   \   000000F4   0x4682             MOV      R10,R0
   \   000000F6   0x4630             MOV      R0,R6
   \   000000F8   0x4649             MOV      R1,R9
   \   000000FA   0x.... 0x....      BL       __aeabi_fmul
   \   000000FE   0x4601             MOV      R1,R0
   \   00000100   0x4650             MOV      R0,R10
   \   00000102   0x.... 0x....      BL       __aeabi_fsub
   \   00000106   0x4659             MOV      R1,R11
   \   00000108   0x.... 0x....      BL       atan2f
   \   0000010C   0x4681             MOV      R9,R0
  14851              if (angular_travel < 0) angular_travel += RADIANS(360);
   \   0000010E   0x2100             MOVS     R1,#+0
   \   00000110   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000114   0xD20A             BCS.N    ??plan_arc_6
   \   00000116   0x.... 0x....      BL       __aeabi_f2d
   \   0000011A   0x.... 0x....      LDR.W    R2,??DataTable186  ;; 0x54442d18
   \   0000011E   0x.... 0x....      LDR.W    R3,??DataTable185_1  ;; 0x401921fb
   \   00000122   0x.... 0x....      BL       __aeabi_dadd
   \   00000126   0x.... 0x....      BL       __aeabi_d2f
   \   0000012A   0x4681             MOV      R9,R0
  14852              if (clockwise) angular_travel -= RADIANS(360);
   \                     ??plan_arc_6: (+1)
   \   0000012C   0x2C00             CMP      R4,#+0
   \   0000012E   0xD00B             BEQ.N    ??plan_arc_7
   \   00000130   0x4648             MOV      R0,R9
   \   00000132   0x.... 0x....      BL       __aeabi_f2d
   \   00000136   0x.... 0x....      LDR.W    R2,??DataTable186  ;; 0x54442d18
   \   0000013A   0x.... 0x....      LDR.W    R3,??DataTable186_1  ;; 0xc01921fb
   \   0000013E   0x.... 0x....      BL       __aeabi_dadd
   \   00000142   0x.... 0x....      BL       __aeabi_d2f
   \   00000146   0x4681             MOV      R9,R0
  14853          
  14854              // Make a circle if the angular rotation is 0 and the target is current position
  14855              if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
   \                     ??plan_arc_7: (+1)
   \   00000148   0x4648             MOV      R0,R9
   \   0000014A   0x2100             MOVS     R1,#+0
   \   0000014C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000150   0xD111             BNE.N    ??plan_arc_8
   \   00000152   0x.... 0x....      LDR.W    R0,??DataTable175
   \   00000156   0x6880             LDR      R0,[R0, #+8]
   \   00000158   0x990D             LDR      R1,[SP, #+52]
   \   0000015A   0x6809             LDR      R1,[R1, #+0]
   \   0000015C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000160   0xD109             BNE.N    ??plan_arc_8
   \   00000162   0x.... 0x....      LDR.W    R0,??DataTable175
   \   00000166   0x68C0             LDR      R0,[R0, #+12]
   \   00000168   0x990D             LDR      R1,[SP, #+52]
   \   0000016A   0x6849             LDR      R1,[R1, #+4]
   \   0000016C   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000170   0xD101             BNE.N    ??plan_arc_8
  14856                angular_travel = RADIANS(360);
   \   00000172   0x.... 0x....      LDR.W    R9,??DataTable186_2  ;; 0x40c90fdb
  14857          
  14858              const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
   \                     ??plan_arc_8: (+1)
   \   00000176   0x4648             MOV      R0,R9
   \   00000178   0x4641             MOV      R1,R8
   \   0000017A   0x.... 0x....      BL       __aeabi_fmul
   \   0000017E   0x4680             MOV      R8,R0
   \   00000180   0xF04F 0x0A02      MOV      R10,#+2
   \   00000184   0x463C             MOV      R4,R7
   \   00000186   0xE004             B.N      ??plan_arc_9
   \                     ??plan_arc_10: (+1)
   \   00000188   0x4640             MOV      R0,R8
   \   0000018A   0x4641             MOV      R1,R8
   \   0000018C   0x.... 0x....      BL       __aeabi_fmul
   \   00000190   0x4680             MOV      R8,R0
   \                     ??plan_arc_9: (+1)
   \   00000192   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   00000196   0xD504             BPL.N    ??plan_arc_11
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x4641             MOV      R1,R8
   \   0000019C   0x.... 0x....      BL       __aeabi_fmul
   \   000001A0   0x4604             MOV      R4,R0
   \                     ??plan_arc_11: (+1)
   \   000001A2   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000001A6   0xD1EF             BNE.N    ??plan_arc_10
   \   000001A8   0x9800             LDR      R0,[SP, #+0]
   \   000001AA   0xF020 0x4B00      BIC      R11,R0,#0x80000000
   \   000001AE   0xF04F 0x0802      MOV      R8,#+2
   \   000001B2   0x46BA             MOV      R10,R7
   \   000001B4   0xE004             B.N      ??plan_arc_12
   \                     ??plan_arc_13: (+1)
   \   000001B6   0x4658             MOV      R0,R11
   \   000001B8   0x4659             MOV      R1,R11
   \   000001BA   0x.... 0x....      BL       __aeabi_fmul
   \   000001BE   0x4683             MOV      R11,R0
   \                     ??plan_arc_12: (+1)
   \   000001C0   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   000001C4   0xD504             BPL.N    ??plan_arc_14
   \   000001C6   0x4650             MOV      R0,R10
   \   000001C8   0x4659             MOV      R1,R11
   \   000001CA   0x.... 0x....      BL       __aeabi_fmul
   \   000001CE   0x4682             MOV      R10,R0
   \                     ??plan_arc_14: (+1)
   \   000001D0   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   000001D4   0xD1EF             BNE.N    ??plan_arc_13
   \   000001D6   0x4620             MOV      R0,R4
   \   000001D8   0x4651             MOV      R1,R10
   \   000001DA   0x.... 0x....      BL       __aeabi_fadd
   \   000001DE   0x.... 0x....      BL       sqrtf
  14859              if (mm_of_travel < 0.001) return;
   \   000001E2   0x.... 0x....      LDR.W    R1,??DataTable186_3  ;; 0x3a83126f
   \   000001E6   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001EA   0xF0C0 0x80FD      BCC.W    ??plan_arc_15
  14860          
  14861              uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
                                         ^
Warning[Pa093]: implicit conversion from floating point to integer
   \   000001EE   0x.... 0x....      BL       floorf
   \   000001F2   0x.... 0x....      BL       __aeabi_f2iz
   \   000001F6   0xB280             UXTH     R0,R0
   \   000001F8   0x9003             STR      R0,[SP, #+12]
  14862              NOLESS(segments, 1);
   \   000001FA   0x2800             CMP      R0,#+0
   \   000001FC   0xD101             BNE.N    ??plan_arc_16
   \   000001FE   0x2001             MOVS     R0,#+1
   \   00000200   0x9003             STR      R0,[SP, #+12]
  14863          
  14864              /**
  14865               * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
  14866               * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
  14867               *     r_T = [cos(phi) -sin(phi);
  14868               *            sin(phi)  cos(phi)] * r ;
  14869               *
  14870               * For arc generation, the center of the circle is the axis of rotation and the radius vector is
  14871               * defined from the circle center to the initial position. Each line segment is formed by successive
  14872               * vector rotations. This requires only two cos() and sin() computations to form the rotation
  14873               * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
  14874               * all double numbers are single precision on the Arduino. (True double precision will not have
  14875               * round off issues for CNC applications.) Single precision error can accumulate to be greater than
  14876               * tool precision in some cases. Therefore, arc path correction is implemented.
  14877               *
  14878               * Small angle approximation may be used to reduce computation overhead further. This approximation
  14879               * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
  14880               * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
  14881               * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
  14882               * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
  14883               * issue for CNC machines with the single precision Arduino calculations.
  14884               *
  14885               * This approximation also allows plan_arc to immediately insert a line segment into the planner
  14886               * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
  14887               * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
  14888               * This is important when there are successive arc motions.
  14889               */
  14890              // Vector rotation matrix values
  14891              float raw[XYZE];
  14892              const float theta_per_segment = angular_travel / segments,
   \                     ??plan_arc_16: (+1)
   \   00000202   0xA803             ADD      R0,SP,#+12
   \   00000204   0x8800             LDRH     R0,[R0, #+0]
   \   00000206   0x.... 0x....      BL       __aeabi_ui2f
   \   0000020A   0x4604             MOV      R4,R0
   \   0000020C   0x4648             MOV      R0,R9
   \   0000020E   0x4621             MOV      R1,R4
   \   00000210   0x.... 0x....      BL       __aeabi_fdiv
   \   00000214   0x9002             STR      R0,[SP, #+8]
  14893                          linear_per_segment = linear_travel / segments,
   \   00000216   0x9800             LDR      R0,[SP, #+0]
   \   00000218   0x4621             MOV      R1,R4
   \   0000021A   0x.... 0x....      BL       __aeabi_fdiv
   \   0000021E   0x9008             STR      R0,[SP, #+32]
  14894                          extruder_per_segment = extruder_travel / segments,
   \   00000220   0x9801             LDR      R0,[SP, #+4]
   \   00000222   0x4621             MOV      R1,R4
   \   00000224   0x.... 0x....      BL       __aeabi_fdiv
   \   00000228   0x9007             STR      R0,[SP, #+28]
  14895                          sin_T = theta_per_segment,
  14896                          cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
   \   0000022A   0x9C02             LDR      R4,[SP, #+8]
   \   0000022C   0xF04F 0x0802      MOV      R8,#+2
   \   00000230   0xE004             B.N      ??plan_arc_17
   \                     ??plan_arc_18: (+1)
   \   00000232   0x4620             MOV      R0,R4
   \   00000234   0x4621             MOV      R1,R4
   \   00000236   0x.... 0x....      BL       __aeabi_fmul
   \   0000023A   0x4604             MOV      R4,R0
   \                     ??plan_arc_17: (+1)
   \   0000023C   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   00000240   0xD504             BPL.N    ??plan_arc_19
   \   00000242   0x4638             MOV      R0,R7
   \   00000244   0x4621             MOV      R1,R4
   \   00000246   0x.... 0x....      BL       __aeabi_fmul
   \   0000024A   0x4607             MOV      R7,R0
   \                     ??plan_arc_19: (+1)
   \   0000024C   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   00000250   0xD1EF             BNE.N    ??plan_arc_18
   \   00000252   0x4638             MOV      R0,R7
   \   00000254   0x.... 0x....      BL       __aeabi_f2d
   \   00000258   0x2200             MOVS     R2,#+0
   \   0000025A   0x.... 0x....      LDR.W    R3,??DataTable186_5  ;; 0x3fe00000
   \   0000025E   0x.... 0x....      BL       __aeabi_dmul
   \   00000262   0x4602             MOV      R2,R0
   \   00000264   0x460B             MOV      R3,R1
   \   00000266   0x2000             MOVS     R0,#+0
   \   00000268   0x.... 0x....      LDR.W    R1,??DataTable186_6  ;; 0x3ff00000
   \   0000026C   0x.... 0x....      BL       __aeabi_dsub
   \   00000270   0x.... 0x....      BL       __aeabi_d2f
   \   00000274   0x9001             STR      R0,[SP, #+4]
  14897          
  14898              // Initialize the linear axis
  14899              raw[l_axis] = current_position[l_axis];
   \   00000276   0xAC09             ADD      R4,SP,#+36
   \   00000278   0x.... 0x....      LDR.W    R0,??DataTable175
   \   0000027C   0x6900             LDR      R0,[R0, #+16]
   \   0000027E   0x60A0             STR      R0,[R4, #+8]
  14900          
  14901              // Initialize the extruder axis
  14902              raw[E_AXIS] = current_position[E_AXIS];
   \   00000280   0x.... 0x....      LDR.W    R0,??DataTable175
   \   00000284   0x6940             LDR      R0,[R0, #+20]
   \   00000286   0x60E0             STR      R0,[R4, #+12]
  14903          
  14904              const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
   \   00000288   0x.... 0x....      LDR.W    R0,??DataTable175
   \   0000028C   0xF9B0 0x0006      LDRSH    R0,[R0, #+6]
   \   00000290   0x.... 0x....      BL       __aeabi_i2f
   \   00000294   0x.... 0x....      LDR.W    R1,??DataTable175
   \   00000298   0x6DC9             LDR      R1,[R1, #+92]
   \   0000029A   0x.... 0x....      BL       __aeabi_fmul
   \   0000029E   0x.... 0x....      BL       __aeabi_f2d
   \   000002A2   0x.... 0x....      LDR.W    R2,??DataTable184  ;; 0x47ae147b
   \   000002A6   0x.... 0x....      LDR.W    R3,??DataTable185  ;; 0x3f847ae1
   \   000002AA   0x.... 0x....      BL       __aeabi_dmul
   \   000002AE   0x.... 0x....      BL       __aeabi_d2f
   \   000002B2   0x9004             STR      R0,[SP, #+16]
  14905          
  14906              millis_t next_idle_ms = millis() + 200UL;
   \   000002B4   0x.... 0x....      BL       HAL_GetTick
   \   000002B8   0xF100 0x07C8      ADD      R7,R0,#+200
  14907          
  14908              #if N_ARC_CORRECTION > 1
  14909                int8_t arc_recalc_count = N_ARC_CORRECTION;
   \   000002BC   0xF04F 0x0919      MOV      R9,#+25
  14910              #endif
  14911          
  14912              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14913                // SCARA needs to scale the feed rate from mm/s to degrees/s
  14914                const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
  14915                            inverse_secs = inv_segment_length * fr_mm_s;
  14916                float oldA = stepper.get_axis_position_degrees(A_AXIS),
  14917                      oldB = stepper.get_axis_position_degrees(B_AXIS);
  14918              #endif
  14919          
  14920              for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
   \   000002C0   0xF04F 0x0801      MOV      R8,#+1
   \   000002C4   0xE055             B.N      ??plan_arc_20
  14921          
  14922                thermalManager.manage_heater();
  14923                if (ELAPSED(millis(), next_idle_ms)) {
  14924                  next_idle_ms = millis() + 200UL;
  14925                  idle();
  14926                }
  14927          
  14928                #if N_ARC_CORRECTION > 1
  14929                  if (--arc_recalc_count) {
  14930                    // Apply vector rotation matrix to previous r_P / 1
  14931                    const float r_new_Y = r_P * sin_T + r_Q * cos_T;
  14932                    r_P = r_P * cos_T - r_Q * sin_T;
  14933                    r_Q = r_new_Y;
  14934                  }
  14935                  else
  14936                #endif
  14937                {
  14938                  #if N_ARC_CORRECTION > 1
  14939                    arc_recalc_count = N_ARC_CORRECTION;
   \                     ??plan_arc_21: (+1)
   \   000002C6   0xF04F 0x0919      MOV      R9,#+25
  14940                  #endif
  14941          
  14942                  // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
  14943                  // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
  14944                  // To reduce stuttering, the sin and cos could be computed at different times.
  14945                  // For now, compute both at the same time.
  14946                  const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
   \   000002CA   0x4640             MOV      R0,R8
   \   000002CC   0x.... 0x....      BL       __aeabi_ui2f
   \   000002D0   0x9902             LDR      R1,[SP, #+8]
   \   000002D2   0x.... 0x....      BL       __aeabi_fmul
   \   000002D6   0x4605             MOV      R5,R0
   \   000002D8   0x.... 0x....      BL       cosf
   \   000002DC   0x4606             MOV      R6,R0
   \   000002DE   0x4628             MOV      R0,R5
   \   000002E0   0x.... 0x....      BL       sinf
   \   000002E4   0x4682             MOV      R10,R0
  14947                  r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
   \   000002E6   0x980E             LDR      R0,[SP, #+56]
   \   000002E8   0x6840             LDR      R0,[R0, #+4]
   \   000002EA   0x9000             STR      R0,[SP, #+0]
   \   000002EC   0x980E             LDR      R0,[SP, #+56]
   \   000002EE   0xF8D0 0xB000      LDR      R11,[R0, #+0]
   \   000002F2   0x9800             LDR      R0,[SP, #+0]
   \   000002F4   0x4651             MOV      R1,R10
   \   000002F6   0x.... 0x....      BL       __aeabi_fmul
   \   000002FA   0x4605             MOV      R5,R0
   \   000002FC   0x4658             MOV      R0,R11
   \   000002FE   0x4631             MOV      R1,R6
   \   00000300   0x.... 0x....      BL       __aeabi_fmul
   \   00000304   0x4601             MOV      R1,R0
   \   00000306   0x4628             MOV      R0,R5
   \   00000308   0x.... 0x....      BL       __aeabi_fsub
   \   0000030C   0x4605             MOV      R5,R0
  14948                  r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
   \   0000030E   0x4658             MOV      R0,R11
   \   00000310   0x4651             MOV      R1,R10
   \   00000312   0x.... 0x....      BL       __aeabi_fmul
   \   00000316   0xF080 0x4000      EOR      R0,R0,#0x80000000
   \   0000031A   0x4682             MOV      R10,R0
   \   0000031C   0x9800             LDR      R0,[SP, #+0]
   \   0000031E   0x4631             MOV      R1,R6
   \   00000320   0x.... 0x....      BL       __aeabi_fmul
   \   00000324   0x4601             MOV      R1,R0
   \   00000326   0x4650             MOV      R0,R10
   \   00000328   0x.... 0x....      BL       __aeabi_fsub
   \   0000032C   0x4606             MOV      R6,R0
  14949                }
  14950          
  14951                // Update raw location
  14952                raw[p_axis] = center_P + r_P;
   \                     ??plan_arc_22: (+1)
   \   0000032E   0x9806             LDR      R0,[SP, #+24]
   \   00000330   0x4629             MOV      R1,R5
   \   00000332   0x.... 0x....      BL       __aeabi_fadd
   \   00000336   0x9009             STR      R0,[SP, #+36]
  14953                raw[q_axis] = center_Q + r_Q;
   \   00000338   0x9805             LDR      R0,[SP, #+20]
   \   0000033A   0x4631             MOV      R1,R6
   \   0000033C   0x.... 0x....      BL       __aeabi_fadd
   \   00000340   0x6060             STR      R0,[R4, #+4]
  14954                raw[l_axis] += linear_per_segment;
   \   00000342   0x68A0             LDR      R0,[R4, #+8]
   \   00000344   0x9908             LDR      R1,[SP, #+32]
   \   00000346   0x.... 0x....      BL       __aeabi_fadd
   \   0000034A   0x60A0             STR      R0,[R4, #+8]
  14955                raw[E_AXIS] += extruder_per_segment;
   \   0000034C   0x68E0             LDR      R0,[R4, #+12]
   \   0000034E   0x9907             LDR      R1,[SP, #+28]
   \   00000350   0x.... 0x....      BL       __aeabi_fadd
   \   00000354   0x60E0             STR      R0,[R4, #+12]
  14956          
  14957                clamp_to_software_endstops(raw);
   \   00000356   0xA809             ADD      R0,SP,#+36
   \   00000358   0x.... 0x....      BL       _Z26clamp_to_software_endstopsPf
  14958          
  14959                #if ENABLED(SCARA_FEEDRATE_SCALING)
  14960                  // For SCARA scale the feed rate from mm/s to degrees/s
  14961                  // i.e., Complete the angular vector in the given time.
  14962                  inverse_kinematics(raw);
  14963                  ADJUST_DELTA(raw);
  14964                  planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14965                  oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
  14966                #else
  14967                  planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
   \   0000035C   0x.... 0x....      LDR.W    R0,??DataTable175
   \   00000360   0x78C2             LDRB     R2,[R0, #+3]
   \   00000362   0xA904             ADD      R1,SP,#+16
   \   00000364   0xA809             ADD      R0,SP,#+36
   \   00000366   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
   \   0000036A   0xF108 0x0801      ADD      R8,R8,#+1
   \   0000036E   0xFA1F 0xF888      UXTH     R8,R8
   \                     ??plan_arc_20: (+1)
   \   00000372   0x9803             LDR      R0,[SP, #+12]
   \   00000374   0x4580             CMP      R8,R0
   \   00000376   0xDA2F             BGE.N    ??plan_arc_23
   \   00000378   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
   \   0000037C   0x.... 0x....      BL       HAL_GetTick
   \   00000380   0x1BC0             SUBS     R0,R0,R7
   \   00000382   0xD405             BMI.N    ??plan_arc_24
   \   00000384   0x.... 0x....      BL       HAL_GetTick
   \   00000388   0xF100 0x07C8      ADD      R7,R0,#+200
   \   0000038C   0x.... 0x....      BL       _Z4idlev
   \                     ??plan_arc_24: (+1)
   \   00000390   0xF1A9 0x0901      SUB      R9,R9,#+1
   \   00000394   0xFA4F 0xF989      SXTB     R9,R9
   \   00000398   0xF1B9 0x0F00      CMP      R9,#+0
   \   0000039C   0xD093             BEQ.N    ??plan_arc_21
   \   0000039E   0x9802             LDR      R0,[SP, #+8]
   \   000003A0   0x4629             MOV      R1,R5
   \   000003A2   0x.... 0x....      BL       __aeabi_fmul
   \   000003A6   0x4682             MOV      R10,R0
   \   000003A8   0x9801             LDR      R0,[SP, #+4]
   \   000003AA   0x4631             MOV      R1,R6
   \   000003AC   0x.... 0x....      BL       __aeabi_fmul
   \   000003B0   0x4651             MOV      R1,R10
   \   000003B2   0x.... 0x....      BL       __aeabi_fadd
   \   000003B6   0x4682             MOV      R10,R0
   \   000003B8   0x9801             LDR      R0,[SP, #+4]
   \   000003BA   0x4629             MOV      R1,R5
   \   000003BC   0x.... 0x....      BL       __aeabi_fmul
   \   000003C0   0x4605             MOV      R5,R0
   \   000003C2   0x9802             LDR      R0,[SP, #+8]
   \   000003C4   0x4631             MOV      R1,R6
   \   000003C6   0x.... 0x....      BL       __aeabi_fmul
   \   000003CA   0x4601             MOV      R1,R0
   \   000003CC   0x4628             MOV      R0,R5
   \   000003CE   0x.... 0x....      BL       __aeabi_fsub
   \   000003D2   0x4605             MOV      R5,R0
   \   000003D4   0x4656             MOV      R6,R10
   \   000003D6   0xE7AA             B.N      ??plan_arc_22
  14968                #endif
  14969              }
  14970          
  14971              // Ensure last segment arrives at target location.
  14972              #if ENABLED(SCARA_FEEDRATE_SCALING)
  14973                inverse_kinematics(cart);
  14974                ADJUST_DELTA(cart);
  14975                planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
  14976              #else
  14977                planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
   \                     ??plan_arc_23: (+1)
   \   000003D8   0x....             LDR.N    R0,??DataTable175
   \   000003DA   0x78C2             LDRB     R2,[R0, #+3]
   \   000003DC   0xA904             ADD      R1,SP,#+16
   \   000003DE   0x980D             LDR      R0,[SP, #+52]
   \   000003E0   0x.... 0x....      BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
  14978              #endif
  14979          
  14980              // As far as the parser is concerned, the position is now == target. In reality the
  14981              // motion control system might still be processing the action and the real tool position
  14982              // in any intermediate location.
  14983              set_current_from_destination();
   \   000003E4   0x.... 0x....      BL       _Z28set_current_from_destinationv
  14984            } // plan_arc
   \                     ??plan_arc_15: (+1)
   \   000003E8   0xB00F             ADD      SP,SP,#+60
   \   000003EA   0xE8BD 0x8FF0      POP      {R4-R11,PC}      ;; return
  14985          
  14986          #endif // ARC_SUPPORT
  14987          
  14988          #if ENABLED(BEZIER_CURVE_SUPPORT)
  14989          
  14990            void plan_cubic_move(const float (&offset)[4]) {
  14991              cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
  14992          
  14993              // As far as the parser is concerned, the position is now == destination. In reality the
  14994              // motion control system might still be processing the action and the real tool position
  14995              // in any intermediate location.
  14996              set_current_from_destination();
  14997            }
  14998          
  14999          #endif // BEZIER_CURVE_SUPPORT
  15000          
  15001          #if ENABLED(USE_CONTROLLER_FAN)
  15002          
  15003            void controllerFan() {
  15004              static millis_t lastMotorOn = 0, // Last time a motor was turned on
  15005                              nextMotorCheck = 0; // Last time the state was checked
  15006              const millis_t ms = millis();
  15007              if (ELAPSED(ms, nextMotorCheck)) {
  15008                nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
  15009                if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
  15010                    || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
  15011                    #if E_STEPPERS > 1
  15012                      || E1_ENABLE_READ == E_ENABLE_ON
  15013                      #if HAS_X2_ENABLE
  15014                        || X2_ENABLE_READ == X_ENABLE_ON
  15015                      #endif
  15016                      #if E_STEPPERS > 2
  15017                        || E2_ENABLE_READ == E_ENABLE_ON
  15018                        #if E_STEPPERS > 3
  15019                          || E3_ENABLE_READ == E_ENABLE_ON
  15020                          #if E_STEPPERS > 4
  15021                            || E4_ENABLE_READ == E_ENABLE_ON
  15022                          #endif // E_STEPPERS > 4
  15023                        #endif // E_STEPPERS > 3
  15024                      #endif // E_STEPPERS > 2
  15025                    #endif // E_STEPPERS > 1
  15026                ) {
  15027                  lastMotorOn = ms; //... set time to NOW so the fan will turn on
  15028                }
  15029          
  15030                // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
  15031                uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
  15032          
  15033                // allows digital or PWM fan output to be used (see M42 handling)
  15034                WRITE(CONTROLLER_FAN_PIN, speed);
  15035                analogWrite(CONTROLLER_FAN_PIN, speed);
  15036              }
  15037            }
  15038          
  15039          #endif // USE_CONTROLLER_FAN
  15040          
  15041          #if 1//ENABLED(MORGAN_SCARA)
  15042          
  15043            /**
  15044             * Morgan SCARA Forward Kinematics. Results in cartes[].
  15045             * Maths and first version by QHARLEY.
  15046             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  15047             */

   \                                 In section .text, align 2, keep-with-next
  15048            void forward_kinematics_SCARA(const float &a, const float &b) {
   \                     _Z24forward_kinematics_SCARARKfS0_: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x4680             MOV      R8,R0
   \   00000006   0x468A             MOV      R10,R1
  15049          
  15050              float a_sin = sin(RADIANS(a)) * L1,
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x.... 0x....      LDR.W    R7,??DataTable186_7  ;; 0x4062c000
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable186  ;; 0x54442d18
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable186_8  ;; 0x400921fb
   \   00000016   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   0000001A   0x.... 0x....      BL       __aeabi_f2d
   \   0000001E   0x4622             MOV      R2,R4
   \   00000020   0x462B             MOV      R3,R5
   \   00000022   0x.... 0x....      BL       __aeabi_dmul
   \   00000026   0x4632             MOV      R2,R6
   \   00000028   0x.... 0x....      LDR.W    R3,??DataTable186_9  ;; 0x40668000
   \   0000002C   0x.... 0x....      BL       __aeabi_ddiv
   \   00000030   0x.... 0x....      BL       sin
   \   00000034   0x4632             MOV      R2,R6
   \   00000036   0x463B             MOV      R3,R7
   \   00000038   0x.... 0x....      BL       __aeabi_dmul
   \   0000003C   0x.... 0x....      BL       __aeabi_d2f
   \   00000040   0x4681             MOV      R9,R0
  15051                    a_cos = cos(RADIANS(a)) * L1,
   \   00000042   0xF8D8 0x0000      LDR      R0,[R8, #+0]
   \   00000046   0x.... 0x....      BL       __aeabi_f2d
   \   0000004A   0x4622             MOV      R2,R4
   \   0000004C   0x462B             MOV      R3,R5
   \   0000004E   0x.... 0x....      BL       __aeabi_dmul
   \   00000052   0x4632             MOV      R2,R6
   \   00000054   0x.... 0x....      LDR.W    R3,??DataTable186_9  ;; 0x40668000
   \   00000058   0x.... 0x....      BL       __aeabi_ddiv
   \   0000005C   0x.... 0x....      BL       cos
   \   00000060   0x4632             MOV      R2,R6
   \   00000062   0x463B             MOV      R3,R7
   \   00000064   0x.... 0x....      BL       __aeabi_dmul
   \   00000068   0x.... 0x....      BL       __aeabi_d2f
   \   0000006C   0x4680             MOV      R8,R0
  15052                    b_sin = sin(RADIANS(b)) * L2,
   \   0000006E   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   00000072   0x.... 0x....      BL       __aeabi_f2d
   \   00000076   0x4622             MOV      R2,R4
   \   00000078   0x462B             MOV      R3,R5
   \   0000007A   0x.... 0x....      BL       __aeabi_dmul
   \   0000007E   0x4632             MOV      R2,R6
   \   00000080   0x.... 0x....      LDR.W    R3,??DataTable186_9  ;; 0x40668000
   \   00000084   0x.... 0x....      BL       __aeabi_ddiv
   \   00000088   0x.... 0x....      BL       sin
   \   0000008C   0x4632             MOV      R2,R6
   \   0000008E   0x463B             MOV      R3,R7
   \   00000090   0x.... 0x....      BL       __aeabi_dmul
   \   00000094   0x.... 0x....      BL       __aeabi_d2f
   \   00000098   0x4683             MOV      R11,R0
  15053                    b_cos = cos(RADIANS(b)) * L2;
   \   0000009A   0xF8DA 0x0000      LDR      R0,[R10, #+0]
   \   0000009E   0x.... 0x....      BL       __aeabi_f2d
   \   000000A2   0x4622             MOV      R2,R4
   \   000000A4   0x462B             MOV      R3,R5
   \   000000A6   0x.... 0x....      BL       __aeabi_dmul
   \   000000AA   0x4632             MOV      R2,R6
   \   000000AC   0x.... 0x....      LDR.W    R3,??DataTable186_9  ;; 0x40668000
   \   000000B0   0x.... 0x....      BL       __aeabi_ddiv
   \   000000B4   0x.... 0x....      BL       cos
   \   000000B8   0x4632             MOV      R2,R6
   \   000000BA   0x463B             MOV      R3,R7
   \   000000BC   0x.... 0x....      BL       __aeabi_dmul
   \   000000C0   0x.... 0x....      BL       __aeabi_d2f
  15054          
  15055              cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
   \   000000C4   0x.... 0x....      LDR.W    R4,??DataTable186_10
   \   000000C8   0x4641             MOV      R1,R8
   \   000000CA   0x.... 0x....      BL       __aeabi_fadd
   \   000000CE   0x.... 0x....      LDR.W    R1,??DataTable186_11  ;; 0x42c80000
   \   000000D2   0x.... 0x....      BL       __aeabi_fadd
   \   000000D6   0x64A0             STR      R0,[R4, #+72]
  15056              cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
   \   000000D8   0x4648             MOV      R0,R9
   \   000000DA   0x4659             MOV      R1,R11
   \   000000DC   0x.... 0x....      BL       __aeabi_fadd
   \   000000E0   0x.... 0x....      LDR.W    R1,??DataTable187  ;; 0xc2600000
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x64E0             STR      R0,[R4, #+76]
  15057          
  15058              /*
  15059                SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
  15060                SERIAL_ECHOPAIR(" b=", b);
  15061                SERIAL_ECHOPAIR(" a_sin=", a_sin);
  15062                SERIAL_ECHOPAIR(" a_cos=", a_cos);
  15063                SERIAL_ECHOPAIR(" b_sin=", b_sin);
  15064                SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
  15065                SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
  15066                SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
  15067              //
  15068              */
  15069            }
   \   000000EA   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  15070          
  15071            /**
  15072             * Morgan SCARA Inverse Kinematics. Results in delta[].
  15073             *
  15074             * See http://forums.reprap.org/read.php?185,283327
  15075             *
  15076             * Maths and first version by QHARLEY.
  15077             * Integrated into Marlin and slightly restructured by Joachim Cerny.
  15078             */

   \                                 In section .text, align 2, keep-with-next
  15079            void inverse_kinematics_MORGAN_SCARA(const float raw[XYZ]) {
   \                     _Z31inverse_kinematics_MORGAN_SCARAPKf: (+1)
   \   00000000   0xE92D 0x4FF1      PUSH     {R0,R4-R11,LR}
  15080          
  15081              static float C2, S2, SK1, SK2, THETA, PSI;
  15082          
  15083              float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable186_12  ;; 0xc2c80000
   \   0000000A   0x.... 0x....      BL       __aeabi_fadd
   \   0000000E   0x4605             MOV      R5,R0
  15084                    sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
   \   00000010   0x9800             LDR      R0,[SP, #+0]
   \   00000012   0x6841             LDR      R1,[R0, #+4]
   \   00000014   0x.... 0x....      LDR.W    R0,??DataTable186_13  ;; 0x42600000
   \   00000018   0x.... 0x....      BL       __aeabi_fadd
   \   0000001C   0x4606             MOV      R6,R0
  15085          
  15086              if (L1 == L2)
  15087                C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
   \   0000001E   0x462F             MOV      R7,R5
   \   00000020   0xF04F 0x0802      MOV      R8,#+2
   \   00000024   0xF04F 0x5B7E      MOV      R11,#+1065353216
   \   00000028   0x465C             MOV      R4,R11
   \   0000002A   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_0
   \                     ??inverse_kinematics_MORGAN_SCARA_1: (+1)
   \   0000002C   0x4638             MOV      R0,R7
   \   0000002E   0x4639             MOV      R1,R7
   \   00000030   0x.... 0x....      BL       __aeabi_fmul
   \   00000034   0x4607             MOV      R7,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_0: (+1)
   \   00000036   0xEA5F 0x70C8      LSLS     R0,R8,#+31
   \   0000003A   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x4639             MOV      R1,R7
   \   00000040   0x.... 0x....      BL       __aeabi_fmul
   \   00000044   0x4604             MOV      R4,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_2: (+1)
   \   00000046   0xEA5F 0x0858      LSRS     R8,R8,#+1
   \   0000004A   0xD1EF             BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
   \   0000004C   0x4637             MOV      R7,R6
   \   0000004E   0xF04F 0x0902      MOV      R9,#+2
   \   00000052   0x46D8             MOV      R8,R11
   \   00000054   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_3
   \                     ??inverse_kinematics_MORGAN_SCARA_4: (+1)
   \   00000056   0x4638             MOV      R0,R7
   \   00000058   0x4639             MOV      R1,R7
   \   0000005A   0x.... 0x....      BL       __aeabi_fmul
   \   0000005E   0x4607             MOV      R7,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_3: (+1)
   \   00000060   0xEA5F 0x70C9      LSLS     R0,R9,#+31
   \   00000064   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
   \   00000066   0x4640             MOV      R0,R8
   \   00000068   0x4639             MOV      R1,R7
   \   0000006A   0x.... 0x....      BL       __aeabi_fmul
   \   0000006E   0x4680             MOV      R8,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_5: (+1)
   \   00000070   0xEA5F 0x0959      LSRS     R9,R9,#+1
   \   00000074   0xD1EF             BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
   \   00000076   0x....             LDR.N    R7,??DataTable175
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x4641             MOV      R1,R8
   \   0000007C   0x.... 0x....      BL       __aeabi_fadd
   \   00000080   0xF8D7 0x1080      LDR      R1,[R7, #+128]
   \   00000084   0x.... 0x....      BL       __aeabi_fdiv
   \   00000088   0x.... 0x....      LDR.W    R1,??DataTable187_1  ;; 0xbf800000
   \   0000008C   0x.... 0x....      BL       __aeabi_fadd
   \   00000090   0x4680             MOV      R8,R0
   \   00000092   0x.... 0x....      LDR.W    R4,??DataTable187_2
   \   00000096   0xF8C4 0x8000      STR      R8,[R4, #+0]
  15088              else
  15089                C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
  15090          
  15091              S2 = SQRT(1 - sq(C2));
   \   0000009A   0x46C1             MOV      R9,R8
   \   0000009C   0xF04F 0x0A02      MOV      R10,#+2
   \   000000A0   0xE004             B.N      ??inverse_kinematics_MORGAN_SCARA_6
   \                     ??inverse_kinematics_MORGAN_SCARA_7: (+1)
   \   000000A2   0x4648             MOV      R0,R9
   \   000000A4   0x4649             MOV      R1,R9
   \   000000A6   0x.... 0x....      BL       __aeabi_fmul
   \   000000AA   0x4681             MOV      R9,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_6: (+1)
   \   000000AC   0xEA5F 0x70CA      LSLS     R0,R10,#+31
   \   000000B0   0xD504             BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
   \   000000B2   0x4658             MOV      R0,R11
   \   000000B4   0x4649             MOV      R1,R9
   \   000000B6   0x.... 0x....      BL       __aeabi_fmul
   \   000000BA   0x4683             MOV      R11,R0
   \                     ??inverse_kinematics_MORGAN_SCARA_8: (+1)
   \   000000BC   0xEA5F 0x0A5A      LSRS     R10,R10,#+1
   \   000000C0   0xD1EF             BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
   \   000000C2   0xF04F 0x507E      MOV      R0,#+1065353216
   \   000000C6   0x4659             MOV      R1,R11
   \   000000C8   0x.... 0x....      BL       __aeabi_fsub
   \   000000CC   0x.... 0x....      BL       sqrtf
   \   000000D0   0x4681             MOV      R9,R0
   \   000000D2   0xF8C4 0x9004      STR      R9,[R4, #+4]
  15092          
  15093              // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
  15094              SK1 = L1 + L2 * C2;
   \   000000D6   0x.... 0x....      LDR.W    R10,??DataTable187_3  ;; 0x43160000
   \   000000DA   0x4640             MOV      R0,R8
   \   000000DC   0x4651             MOV      R1,R10
   \   000000DE   0x.... 0x....      BL       __aeabi_fmul
   \   000000E2   0x4651             MOV      R1,R10
   \   000000E4   0x.... 0x....      BL       __aeabi_fadd
   \   000000E8   0x4683             MOV      R11,R0
   \   000000EA   0xF8C4 0xB008      STR      R11,[R4, #+8]
  15095          
  15096              // Rotated Arm2 gives the distance from Arm1 to Arm2
  15097              SK2 = L2 * S2;
   \   000000EE   0x4648             MOV      R0,R9
   \   000000F0   0x4651             MOV      R1,R10
   \   000000F2   0x.... 0x....      BL       __aeabi_fmul
   \   000000F6   0x60E0             STR      R0,[R4, #+12]
  15098          
  15099              // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
  15100              THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
   \   000000F8   0x4601             MOV      R1,R0
   \   000000FA   0x4658             MOV      R0,R11
   \   000000FC   0x.... 0x....      BL       atan2f
   \   00000100   0x4682             MOV      R10,R0
   \   00000102   0x4631             MOV      R1,R6
   \   00000104   0x4628             MOV      R0,R5
   \   00000106   0x.... 0x....      BL       atan2f
   \   0000010A   0x4601             MOV      R1,R0
   \   0000010C   0x4650             MOV      R0,R10
   \   0000010E   0x.... 0x....      BL       __aeabi_fsub
   \   00000112   0x6120             STR      R0,[R4, #+16]
  15101          
  15102              // Angle of Arm2
  15103              PSI = ATAN2(S2, C2);
   \   00000114   0x4641             MOV      R1,R8
   \   00000116   0x4648             MOV      R0,R9
   \   00000118   0x.... 0x....      BL       atan2f
   \   0000011C   0x4606             MOV      R6,R0
   \   0000011E   0x6166             STR      R6,[R4, #+20]
  15104          
  15105              delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
   \   00000120   0xF8D4 0x8010      LDR      R8,[R4, #+16]
   \   00000124   0x2400             MOVS     R4,#+0
   \   00000126   0x.... 0x....      LDR.W    R5,??DataTable186_9  ;; 0x40668000
   \   0000012A   0x4640             MOV      R0,R8
   \   0000012C   0x.... 0x....      BL       __aeabi_f2d
   \   00000130   0x4622             MOV      R2,R4
   \   00000132   0x462B             MOV      R3,R5
   \   00000134   0x.... 0x....      BL       __aeabi_dmul
   \   00000138   0x.... 0x....      LDR.W    R2,??DataTable186  ;; 0x54442d18
   \   0000013C   0x.... 0x....      LDR.W    R3,??DataTable186_8  ;; 0x400921fb
   \   00000140   0x.... 0x....      BL       __aeabi_ddiv
   \   00000144   0x.... 0x....      BL       __aeabi_d2f
   \   00000148   0x6538             STR      R0,[R7, #+80]
  15106              delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
   \   0000014A   0x4640             MOV      R0,R8
   \   0000014C   0x4631             MOV      R1,R6
   \   0000014E   0x.... 0x....      BL       __aeabi_fadd
   \   00000152   0x.... 0x....      BL       __aeabi_f2d
   \   00000156   0x4622             MOV      R2,R4
   \   00000158   0x462B             MOV      R3,R5
   \   0000015A   0x.... 0x....      BL       __aeabi_dmul
   \   0000015E   0x.... 0x....      LDR.W    R2,??DataTable186  ;; 0x54442d18
   \   00000162   0x.... 0x....      LDR.W    R3,??DataTable186_8  ;; 0x400921fb
   \   00000166   0x.... 0x....      BL       __aeabi_ddiv
   \   0000016A   0x.... 0x....      BL       __aeabi_d2f
   \   0000016E   0x6578             STR      R0,[R7, #+84]
  15107              delta[C_AXIS] = raw[Z_AXIS];
   \   00000170   0x9800             LDR      R0,[SP, #+0]
   \   00000172   0x6880             LDR      R0,[R0, #+8]
   \   00000174   0x65B8             STR      R0,[R7, #+88]
  15108          
  15109              /*
  15110                DEBUG_POS("SCARA IK", raw);
  15111                DEBUG_POS("SCARA IK", delta);
  15112                SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
  15113                SERIAL_ECHOPAIR(",", sy);
  15114                SERIAL_ECHOPAIR(" C2=", C2);
  15115                SERIAL_ECHOPAIR(" S2=", S2);
  15116                SERIAL_ECHOPAIR(" Theta=", THETA);
  15117                SERIAL_ECHOLNPAIR(" Phi=", PHI);
  15118              //
  15119              */
  15120            }
   \   00000176   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  15121          
  15122          #endif // MORGAN_SCARA
  15123          
  15124          #if ENABLED(TEMP_STAT_LEDS)
  15125          
  15126            static bool red_led = false;
  15127            static millis_t next_status_led_update_ms = 0;
  15128          
  15129            void handle_status_leds(void) {
  15130              if (ELAPSED(millis(), next_status_led_update_ms)) {
  15131                next_status_led_update_ms += 500; // Update every 0.5s
  15132                float max_temp = 0.0;
  15133                //#if HAS_TEMP_BED
  15134                if(HAS_TEMP_BED)
  15135                  max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
  15136                //#endif
  15137                HOTEND_LOOP()
  15138                  max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
  15139                const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
  15140                if (new_led != red_led) {
  15141                  red_led = new_led;
  15142                  #if PIN_EXISTS(STAT_LED_RED)
  15143                    WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
  15144                    #if PIN_EXISTS(STAT_LED_BLUE)
  15145                      WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
  15146                    #endif
  15147                  #else
  15148                    WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
  15149                  #endif
  15150                }
  15151              }
  15152            }
  15153          
  15154          #endif
  15155          
  15156          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15157          
  15158            void handle_filament_runout() {
  15159              if (!filament_ran_out) {
  15160                filament_ran_out = true;
  15161                enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
  15162                stepper.synchronize();
  15163              }
  15164            }
  15165          
  15166          #endif // FILAMENT_RUNOUT_SENSOR
  15167          
  15168          #if ENABLED(FAST_PWM_FAN)
  15169          
  15170            void setPwmFrequency(uint8_t pin, int val) {
  15171              val &= 0x07;
  15172              switch (digitalPinToTimer(pin)) {
  15173                #ifdef TCCR0A
  15174                  #if !AVR_AT90USB1286_FAMILY
  15175                    case TIMER0A:
  15176                  #endif
  15177                  case TIMER0B:                           //_SET_CS(0, val);
  15178                                                            break;
  15179                #endif
  15180                #ifdef TCCR1A
  15181                  case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
  15182                                                            break;
  15183                #endif
  15184                #if defined(TCCR2) || defined(TCCR2A)
  15185                  #ifdef TCCR2
  15186                    case TIMER2:
  15187                  #endif
  15188                  #ifdef TCCR2A
  15189                    case TIMER2A: case TIMER2B:
  15190                  #endif
  15191                                                            _SET_CS(2, val); break;
  15192                #endif
  15193                #ifdef TCCR3A
  15194                  case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
  15195                #endif
  15196                #ifdef TCCR4A
  15197                  case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
  15198                #endif
  15199                #ifdef TCCR5A
  15200                  case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
  15201                #endif
  15202              }
  15203            }
  15204          
  15205          #endif // FAST_PWM_FAN
  15206          

   \                                 In section .text, align 2, keep-with-next
  15207          void enable_all_steppers() {
   \                     _Z19enable_all_steppersv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  15208            enable_X();
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable187_4
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable187_5
   \   0000000A   0x.... 0x....      LDR.W    R6,??DataTable184_1
   \   0000000E   0xF996 0x2104      LDRSB    R2,[R6, #+260]
   \   00000012   0x88A9             LDRH     R1,[R5, #+4]
   \   00000014   0x68A0             LDR      R0,[R4, #+8]
   \   00000016   0x.... 0x....      BL       HAL_GPIO_WritePin
  15209            enable_Y();
   \   0000001A   0xF506 0x7682      ADD      R6,R6,#+260
   \   0000001E   0xF996 0x2001      LDRSB    R2,[R6, #+1]
   \   00000022   0x89E9             LDRH     R1,[R5, #+14]
   \   00000024   0x69E0             LDR      R0,[R4, #+28]
   \   00000026   0x.... 0x....      BL       HAL_GPIO_WritePin
  15210            enable_Z();
   \   0000002A   0xF996 0x2002      LDRSB    R2,[R6, #+2]
   \   0000002E   0x8B29             LDRH     R1,[R5, #+24]
   \   00000030   0x6B20             LDR      R0,[R4, #+48]
   \   00000032   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000036   0xF996 0x2002      LDRSB    R2,[R6, #+2]
   \   0000003A   0x8D29             LDRH     R1,[R5, #+40]
   \   0000003C   0x6D20             LDR      R0,[R4, #+80]
   \   0000003E   0x.... 0x....      BL       HAL_GPIO_WritePin
  15211            enable_E0();
   \   00000042   0xF996 0x2003      LDRSB    R2,[R6, #+3]
   \   00000046   0x8C69             LDRH     R1,[R5, #+34]
   \   00000048   0x6C60             LDR      R0,[R4, #+68]
   \   0000004A   0x.... 0x....      BL       HAL_GPIO_WritePin
  15212            enable_E1();
   \   0000004E   0xF996 0x2003      LDRSB    R2,[R6, #+3]
   \   00000052   0x8D29             LDRH     R1,[R5, #+40]
   \   00000054   0x6D20             LDR      R0,[R4, #+80]
   \   00000056   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   0000005A   0x.... 0x....      B.W      HAL_GPIO_WritePin
  15213            enable_E2();
  15214            enable_E3();
  15215            enable_E4();
  15216          }
  15217          

   \                                 In section .text, align 2, keep-with-next
  15218          void disable_e_steppers() {
   \                     _Z18disable_e_steppersv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
  15219            disable_E0();
   \   00000002   0x....             LDR.N    R4,??DataTable175_1
   \   00000004   0xF894 0x0107      LDRB     R0,[R4, #+263]
   \   00000008   0x1E42             SUBS     R2,R0,#+1
   \   0000000A   0x4192             SBCS     R2,R2,R2
   \   0000000C   0x0FD2             LSRS     R2,R2,#+31
   \   0000000E   0x.... 0x....      LDR.W    R5,??DataTable187_4
   \   00000012   0x.... 0x....      LDR.W    R6,??DataTable187_5
   \   00000016   0xB252             SXTB     R2,R2
   \   00000018   0x8C71             LDRH     R1,[R6, #+34]
   \   0000001A   0x6C68             LDR      R0,[R5, #+68]
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
  15220            disable_E1();
   \   00000020   0xF894 0x0107      LDRB     R0,[R4, #+263]
   \   00000024   0x1E42             SUBS     R2,R0,#+1
   \   00000026   0x4192             SBCS     R2,R2,R2
   \   00000028   0x0FD2             LSRS     R2,R2,#+31
   \   0000002A   0xB252             SXTB     R2,R2
   \   0000002C   0x8D31             LDRH     R1,[R6, #+40]
   \   0000002E   0x6D28             LDR      R0,[R5, #+80]
   \   00000030   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000034   0x.... 0x....      B.W      HAL_GPIO_WritePin
  15221            disable_E2();
  15222            disable_E3();
  15223            disable_E4();
  15224          }
  15225          

   \                                 In section .text, align 2, keep-with-next
  15226          void disable_all_steppers() {
   \                     _Z20disable_all_steppersv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  15227            disable_X();
   \   00000002   0x....             LDR.N    R7,??DataTable175_1
   \   00000004   0xF897 0x0104      LDRB     R0,[R7, #+260]
   \   00000008   0x1E42             SUBS     R2,R0,#+1
   \   0000000A   0x4192             SBCS     R2,R2,R2
   \   0000000C   0x0FD2             LSRS     R2,R2,#+31
   \   0000000E   0x.... 0x....      LDR.W    R4,??DataTable187_4
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable187_5
   \   00000016   0xB252             SXTB     R2,R2
   \   00000018   0x88A9             LDRH     R1,[R5, #+4]
   \   0000001A   0x68A0             LDR      R0,[R4, #+8]
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable186_10
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x7130             STRB     R0,[R6, #+4]
  15228            disable_Y();
   \   00000028   0xF507 0x7782      ADD      R7,R7,#+260
   \   0000002C   0x7878             LDRB     R0,[R7, #+1]
   \   0000002E   0x1E42             SUBS     R2,R0,#+1
   \   00000030   0x4192             SBCS     R2,R2,R2
   \   00000032   0x0FD2             LSRS     R2,R2,#+31
   \   00000034   0xB252             SXTB     R2,R2
   \   00000036   0x89E9             LDRH     R1,[R5, #+14]
   \   00000038   0x69E0             LDR      R0,[R4, #+28]
   \   0000003A   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000003E   0x2000             MOVS     R0,#+0
   \   00000040   0x7170             STRB     R0,[R6, #+5]
  15229            disable_Z();
   \   00000042   0x78B8             LDRB     R0,[R7, #+2]
   \   00000044   0x1E42             SUBS     R2,R0,#+1
   \   00000046   0x4192             SBCS     R2,R2,R2
   \   00000048   0x0FD2             LSRS     R2,R2,#+31
   \   0000004A   0xB252             SXTB     R2,R2
   \   0000004C   0x8B29             LDRH     R1,[R5, #+24]
   \   0000004E   0x6B20             LDR      R0,[R4, #+48]
   \   00000050   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000054   0x78B8             LDRB     R0,[R7, #+2]
   \   00000056   0x1E42             SUBS     R2,R0,#+1
   \   00000058   0x4192             SBCS     R2,R2,R2
   \   0000005A   0x0FD2             LSRS     R2,R2,#+31
   \   0000005C   0xB252             SXTB     R2,R2
   \   0000005E   0x8D29             LDRH     R1,[R5, #+40]
   \   00000060   0x6D20             LDR      R0,[R4, #+80]
   \   00000062   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x71B0             STRB     R0,[R6, #+6]
  15230            disable_e_steppers();
   \   0000006A   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   0000006E   0x....             B.N      _Z18disable_e_steppersv
  15231          }
  15232          
  15233          #if ENABLED(MONITOR_DRIVER_STATUS)
  15234            /*
  15235             * Check for over temperature or short to ground error flags.
  15236             * Report and log warning of overtemperature condition.
  15237             * Reduce driver current in a persistent otpw condition.
  15238             * Keep track of otpw counter so we don't reduce current on a single instance,
  15239             * and so we don't repeatedly report warning before the condition is cleared.
  15240             */
  15241          
  15242            struct TMC_driver_data {
  15243              uint32_t drv_status;
  15244              bool is_otpw;
  15245              bool is_ot;
  15246              bool is_error;
  15247            };
  15248            #if ENABLED(HAVE_TMC2130)
  15249              static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
  15250              static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
  15251              static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
  15252                constexpr uint32_t OTPW_bm = 0x4000000UL;
  15253                constexpr uint8_t OTPW_bp = 26;
  15254                constexpr uint32_t OT_bm = 0x2000000UL;
  15255                constexpr uint8_t OT_bp = 25;
  15256                constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
  15257                constexpr uint8_t DRIVER_ERROR_bp = 1;
  15258                TMC_driver_data data;
  15259                data.drv_status = st.DRV_STATUS();
  15260                data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
  15261                data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
  15262                data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
  15263                return data;
  15264              }
  15265            #endif
  15266            #if ENABLED(HAVE_TMC2208)
  15267              static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
  15268              static uint8_t get_status_response(TMC2208Stepper &st) {
  15269                uint32_t drv_status = st.DRV_STATUS();
  15270                uint8_t gstat = st.GSTAT();
  15271                uint8_t response = 0;
  15272                response |= (drv_status >> (31-3)) & 0b1000;
  15273                response |= gstat & 0b11;
  15274                return response;
  15275              }
  15276              static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
  15277                constexpr uint32_t OTPW_bm = 0b1ul;
  15278                constexpr uint8_t OTPW_bp = 0;
  15279                constexpr uint32_t OT_bm = 0b10ul;
  15280                constexpr uint8_t OT_bp = 1;
  15281                TMC_driver_data data;
  15282                data.drv_status = st.DRV_STATUS();
  15283                data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
  15284                data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
  15285                data.is_error = st.drv_err();
  15286                return data;
  15287              }
  15288            #endif
  15289          
  15290            template<typename TMC>
  15291            uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
  15292              TMC_driver_data data = get_driver_data(st);
  15293          
  15294              #if ENABLED(STOP_ON_ERROR)
  15295                if (data.is_error) {
  15296                  SERIAL_EOL();
  15297                  SERIAL_ECHO(axisID);
  15298                  SERIAL_ECHO(" driver error detected:");
  15299                  if (data.is_ot) SERIAL_ECHO("\novertemperature");
  15300                  if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
  15301                  if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
  15302                  SERIAL_EOL();
  15303                  #if ENABLED(TMC_DEBUG)
  15304                    gcode_M122();
  15305                  #endif
  15306                  kill(PSTR("Driver error"));
  15307                }
  15308              #endif
  15309          
  15310              // Report if a warning was triggered
  15311              if (data.is_otpw && otpw_cnt==0) {
  15312                char timestamp[10];
  15313                duration_t elapsed = print_job_timer.duration();
  15314                const bool has_days = (elapsed.value > 60*60*24L);
  15315                (void)elapsed.toDigital(timestamp, has_days);
  15316                SERIAL_EOL();
  15317                SERIAL_ECHO(timestamp);
  15318                SERIAL_ECHOPGM(": ");
  15319                SERIAL_ECHO(axisID);
  15320                SERIAL_ECHOPGM(" driver overtemperature warning! (");
  15321                SERIAL_ECHO(st.getCurrent());
  15322                SERIAL_ECHOLN("mA)");
  15323              }
  15324              #if CURRENT_STEP_DOWN > 0
  15325                // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
  15326                if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
  15327                  st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
  15328                  #if ENABLED(REPORT_CURRENT_CHANGE)
  15329                    SERIAL_ECHO(axisID);
  15330                    SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
  15331                  #endif
  15332                }
  15333              #endif
  15334          
  15335              if (data.is_otpw) {
  15336                otpw_cnt++;
  15337                st.flag_otpw = true;
  15338              }
  15339              else if (otpw_cnt>0) otpw_cnt--;
  15340          
  15341              if (report_tmc_status) {
  15342                const uint32_t pwm_scale = get_pwm_scale(st);
  15343                SERIAL_ECHO(axisID);
  15344                SERIAL_ECHOPAIR(":", pwm_scale);
  15345                SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
  15346                SERIAL_ECHO("| ");
  15347                if (data.is_error) SERIAL_ECHO('E');
  15348                else if (data.is_ot) SERIAL_ECHO('O');
  15349                else if (data.is_otpw) SERIAL_ECHO('W');
  15350                else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
  15351                else if (st.flag_otpw) SERIAL_ECHO('F');
  15352                SERIAL_ECHO("\t");
  15353              }
  15354          
  15355              return otpw_cnt;
  15356            }
  15357          
  15358            void monitor_tmc_driver() {
  15359              static millis_t next_cOT = 0;
  15360              if (ELAPSED(millis(), next_cOT)) {
  15361                next_cOT = millis() + 500;
  15362                #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15363                  static uint8_t x_otpw_cnt = 0;
  15364                  x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
  15365                #endif
  15366                #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15367                  static uint8_t y_otpw_cnt = 0;
  15368                  y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
  15369                #endif
  15370                #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15371                  static uint8_t z_otpw_cnt = 0;
  15372                  z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
  15373                #endif
  15374                #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
  15375                  static uint8_t x2_otpw_cnt = 0;
  15376                  x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
  15377                #endif
  15378                #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
  15379                  static uint8_t y2_otpw_cnt = 0;
  15380                  y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
  15381                #endif
  15382                #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
  15383                  static uint8_t z2_otpw_cnt = 0;
  15384                  z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
  15385                #endif
  15386                #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
  15387                  static uint8_t e0_otpw_cnt = 0;
  15388                  e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
  15389                #endif
  15390                #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
  15391                  static uint8_t e1_otpw_cnt = 0;
  15392                  e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
  15393                #endif
  15394                #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
  15395                  static uint8_t e2_otpw_cnt = 0;
  15396                  e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
  15397                #endif
  15398                #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
  15399                  static uint8_t e3_otpw_cnt = 0;
  15400                  e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
  15401                #endif
  15402                #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
  15403                  static uint8_t e4_otpw_cnt = 0;
  15404                  e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
  15405                #endif
  15406          
  15407                if (report_tmc_status) SERIAL_EOL();
  15408              }
  15409            }
  15410          
  15411          #endif // MONITOR_DRIVER_STATUS
  15412          
  15413          /**
  15414           * Manage several activities:
  15415           *  - Check for Filament Runout
  15416           *  - Keep the command buffer full
  15417           *  - Check for maximum inactive time between commands
  15418           *  - Check for maximum inactive time between stepper commands
  15419           *  - Check if pin CHDK needs to go LOW
  15420           *  - Check for KILL button held down
  15421           *  - Check for HOME button held down
  15422           *  - Check if cooling fan needs to be switched on
  15423           *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  15424           */

   \                                 In section .text, align 2, keep-with-next
  15425          void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   \                     _Z17manage_inactivityb: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4605             MOV      R5,R0
  15426          
  15427            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15428              if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
  15429                handle_filament_runout();
  15430            #endif
  15431          
  15432            if (commands_in_queue < BUFSIZE) get_available_commands();
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable184_2
   \   00000008   0x7880             LDRB     R0,[R0, #+2]
   \   0000000A   0x2804             CMP      R0,#+4
   \   0000000C   0xDA01             BGE.N    ??manage_inactivity_0
   \   0000000E   0x.... 0x....      BL       _Z22get_available_commandsv
  15433          
  15434            const millis_t ms = millis();
   \                     ??manage_inactivity_0: (+1)
   \   00000012   0x.... 0x....      BL       HAL_GetTick
   \   00000016   0x4606             MOV      R6,R0
  15435          
  15436            if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable186_10
   \   0000001C   0x6E20             LDR      R0,[R4, #+96]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD017             BEQ.N    ??manage_inactivity_1
   \   00000022   0x6DE1             LDR      R1,[R4, #+92]
   \   00000024   0x1A71             SUBS     R1,R6,R1
   \   00000026   0x1A08             SUBS     R0,R1,R0
   \   00000028   0xD413             BMI.N    ??manage_inactivity_1
  15437              SERIAL_ERROR_START();
   \   0000002A   0x.... 0x....      LDR.W    R0,??DataTable184_3
   \   0000002E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15438              SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable184_4
   \   00000036   0x6801             LDR      R1,[R0, #+0]
   \   00000038   0x.... 0x....      ADR.W    R0,`?<Constant "KILL caused by too mu...">`
   \   0000003C   0x.... 0x....      BL       _Z17serial_echopair_PPKcS0_
   \   00000040   0x210A             MOVS     R1,#+10
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable184_5
   \   00000046   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15439              kill(PSTR(MSG_KILLED));
   \   0000004A   0x.... 0x....      ADR.W    R0,`?<Constant "KILLED. ">`
   \   0000004E   0x.... 0x....      BL       _Z4killPKc
  15440            }
  15441          
  15442            // Prevent steppers timing-out in the middle of M600
  15443            #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
  15444              #define MOVE_AWAY_TEST !move_away_flag
  15445            #else
  15446              #define MOVE_AWAY_TEST true
  15447            #endif
  15448          
  15449            if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
  15450                && !ignore_stepper_queue && !planner.blocks_queued()) {
   \                     ??manage_inactivity_1: (+1)
   \   00000052   0x6E60             LDR      R0,[R4, #+100]
   \   00000054   0x2800             CMP      R0,#+0
   \   00000056   0xD03E             BEQ.N    ??manage_inactivity_2
   \   00000058   0x6DE1             LDR      R1,[R4, #+92]
   \   0000005A   0x1A71             SUBS     R1,R6,R1
   \   0000005C   0x1A08             SUBS     R0,R1,R0
   \   0000005E   0xD43A             BMI.N    ??manage_inactivity_2
   \   00000060   0x2D00             CMP      R5,#+0
   \   00000062   0xD138             BNE.N    ??manage_inactivity_2
   \   00000064   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   00000068   0x2800             CMP      R0,#+0
   \   0000006A   0xD134             BNE.N    ??manage_inactivity_2
  15451              #if ENABLED(DISABLE_INACTIVE_X)
  15452                disable_X();
   \   0000006C   0x.... 0x....      LDR.W    R7,??DataTable184_1
   \   00000070   0xF897 0x0104      LDRB     R0,[R7, #+260]
   \   00000074   0x1E42             SUBS     R2,R0,#+1
   \   00000076   0x4192             SBCS     R2,R2,R2
   \   00000078   0x0FD2             LSRS     R2,R2,#+31
   \   0000007A   0x.... 0x....      LDR.W    R5,??DataTable187_4
   \   0000007E   0x.... 0x....      LDR.W    R6,??DataTable187_5
   \   00000082   0xB252             SXTB     R2,R2
   \   00000084   0x88B1             LDRH     R1,[R6, #+4]
   \   00000086   0x68A8             LDR      R0,[R5, #+8]
   \   00000088   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0x7120             STRB     R0,[R4, #+4]
  15453              #endif
  15454              #if ENABLED(DISABLE_INACTIVE_Y)
  15455                disable_Y();
   \   00000090   0xF507 0x7782      ADD      R7,R7,#+260
   \   00000094   0x7878             LDRB     R0,[R7, #+1]
   \   00000096   0x1E42             SUBS     R2,R0,#+1
   \   00000098   0x4192             SBCS     R2,R2,R2
   \   0000009A   0x0FD2             LSRS     R2,R2,#+31
   \   0000009C   0xB252             SXTB     R2,R2
   \   0000009E   0x89F1             LDRH     R1,[R6, #+14]
   \   000000A0   0x69E8             LDR      R0,[R5, #+28]
   \   000000A2   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0x7160             STRB     R0,[R4, #+5]
  15456              #endif
  15457              #if ENABLED(DISABLE_INACTIVE_Z)
  15458                disable_Z();
   \   000000AA   0x78B8             LDRB     R0,[R7, #+2]
   \   000000AC   0x1E42             SUBS     R2,R0,#+1
   \   000000AE   0x4192             SBCS     R2,R2,R2
   \   000000B0   0x0FD2             LSRS     R2,R2,#+31
   \   000000B2   0xB252             SXTB     R2,R2
   \   000000B4   0x8B31             LDRH     R1,[R6, #+24]
   \   000000B6   0x6B28             LDR      R0,[R5, #+48]
   \   000000B8   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000BC   0x78B8             LDRB     R0,[R7, #+2]
   \   000000BE   0x1E42             SUBS     R2,R0,#+1
   \   000000C0   0x4192             SBCS     R2,R2,R2
   \   000000C2   0x0FD2             LSRS     R2,R2,#+31
   \   000000C4   0xB252             SXTB     R2,R2
   \   000000C6   0x8D31             LDRH     R1,[R6, #+40]
   \   000000C8   0x6D28             LDR      R0,[R5, #+80]
   \   000000CA   0x.... 0x....      BL       HAL_GPIO_WritePin
   \   000000CE   0x2000             MOVS     R0,#+0
   \   000000D0   0x71A0             STRB     R0,[R4, #+6]
  15459              #endif
  15460              #if ENABLED(DISABLE_INACTIVE_E)
  15461                disable_e_steppers();
   \   000000D2   0x.... 0x....      BL       _Z18disable_e_steppersv
  15462              #endif
  15463              #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
  15464                ubl.lcd_map_control = defer_return_to_status = false;
  15465              #endif
  15466            }
  15467          
  15468            #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
  15469              if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
  15470                chdkActive = false;
  15471                WRITE(CHDK, LOW);
  15472              }
  15473            #endif
  15474          
  15475            #if HAS_KILL
  15476          
  15477              // Check if the kill button was pressed and wait just in case it was an accidental
  15478              // key kill key press
  15479              // -------------------------------------------------------------------------------
  15480              static int killCount = 0;   // make the inactivity button a bit less responsive
  15481              const int KILL_DELAY = 750;
  15482              if (!READ(KILL_PIN))
  15483                killCount++;
  15484              else if (killCount > 0)
  15485                killCount--;
  15486          
  15487              // Exceeded threshold and we can confirm that it was not accidental
  15488              // KILL the machine
  15489              // ----------------------------------------------------------------
  15490              if (killCount >= KILL_DELAY) {
  15491                SERIAL_ERROR_START();
  15492                SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
  15493                kill(PSTR(MSG_KILLED));
  15494              }
  15495            #endif
  15496          
  15497            #if HAS_HOME
  15498              // Check to see if we have to home, use poor man's debouncer
  15499              // ---------------------------------------------------------
  15500              static int homeDebounceCount = 0;   // poor man's debouncing count
  15501              const int HOME_DEBOUNCE_DELAY = 2500;
  15502              if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
  15503                if (!homeDebounceCount) {
  15504                  enqueue_and_echo_commands_P(PSTR("G28"));
  15505                  LCD_MESSAGEPGM(MSG_AUTO_HOME);
  15506                }
  15507                if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
  15508                  homeDebounceCount++;
  15509                else
  15510                  homeDebounceCount = 0;
  15511              }
  15512            #endif
  15513          
  15514            #if ENABLED(USE_CONTROLLER_FAN)
  15515              controllerFan(); // Check if fan should be turned on to cool stepper drivers down
  15516            #endif
  15517          
  15518            #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
  15519              if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
  15520                && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
  15521                #if ENABLED(SWITCHING_EXTRUDER)
  15522                  const bool oldstatus = E0_ENABLE_READ;
  15523                  enable_E0();
  15524                #else // !SWITCHING_EXTRUDER
  15525                  bool oldstatus;
  15526                  switch (active_extruder) {
  15527                    default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
  15528                    #if E_STEPPERS > 1
  15529                      case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
  15530                      #if E_STEPPERS > 2
  15531                        case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
  15532                        #if E_STEPPERS > 3
  15533                          case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
  15534                          #if E_STEPPERS > 4
  15535                            case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
  15536                          #endif // E_STEPPERS > 4
  15537                        #endif // E_STEPPERS > 3
  15538                      #endif // E_STEPPERS > 2
  15539                    #endif // E_STEPPERS > 1
  15540                  }
  15541                #endif // !SWITCHING_EXTRUDER
  15542          
  15543                previous_cmd_ms = ms; // refresh_cmd_timeout()
  15544          
  15545                const float olde = current_position[E_AXIS];
  15546                current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
  15547                planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
  15548                current_position[E_AXIS] = olde;
  15549                planner.set_e_position_mm(olde);
  15550                stepper.synchronize();
  15551                #if ENABLED(SWITCHING_EXTRUDER)
  15552                  E0_ENABLE_WRITE(oldstatus);
  15553                #else
  15554                  switch (active_extruder) {
  15555                    case 0: E0_ENABLE_WRITE(oldstatus); break;
  15556                    #if E_STEPPERS > 1
  15557                      case 1: E1_ENABLE_WRITE(oldstatus); break;
  15558                      #if E_STEPPERS > 2
  15559                        case 2: E2_ENABLE_WRITE(oldstatus); break;
  15560                        #if E_STEPPERS > 3
  15561                          case 3: E3_ENABLE_WRITE(oldstatus); break;
  15562                          #if E_STEPPERS > 4
  15563                            case 4: E4_ENABLE_WRITE(oldstatus); break;
  15564                          #endif // E_STEPPERS > 4
  15565                        #endif // E_STEPPERS > 3
  15566                      #endif // E_STEPPERS > 2
  15567                    #endif // E_STEPPERS > 1
  15568                  }
  15569                #endif // !SWITCHING_EXTRUDER
  15570              }
  15571            #endif // EXTRUDER_RUNOUT_PREVENT
  15572          
  15573            #if ENABLED(DUAL_X_CARRIAGE)
  15574              // handle delayed move timeout
  15575              if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
  15576                // travel moves have been received so enact them
  15577                delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
  15578                set_destination_from_current();
  15579                prepare_move_to_destination();
  15580              }
  15581            #endif
  15582          
  15583            #if ENABLED(TEMP_STAT_LEDS)
  15584              handle_status_leds();
  15585            #endif
  15586          
  15587            #if ENABLED(MONITOR_DRIVER_STATUS)
  15588              monitor_tmc_driver();
  15589            #endif
  15590          
  15591            planner.check_axes_activity();
   \                     ??manage_inactivity_2: (+1)
   \   000000D6   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   000000DA   0x.... 0x....      B.W      _ZN7Planner19check_axes_activityEv
  15592          }
  15593          
  15594          /**
  15595           * Standard idle routine keeps the machine alive
  15596           */
  15597          //extern uint8_t display_hold;
  15598          //extern uint32_t display_hold_cnt;
  15599          //extern uint8_t display_hold_release;
  15600          
  15601          uint8_t display_hold=0;
  15602          uint32_t display_hold_cnt=0;
  15603          uint8_t display_hold_release=0;
  15604          uint8_t button_disp_pause_state=0;
  15605          

   \                                 In section .text, align 2, keep-with-next
  15606          void lcd_reInit()
  15607          {
   \                     _Z10lcd_reInitv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  15608             GUI_Init();
   \   00000002   0x.... 0x....      BL       GUI_Init
  15609             GUI_UC_SetEncodeUTF8();
   \   00000006   0x.... 0x....      BL       GUI_UC_SetEncodeUTF8
  15610             gui_view_init(); 
   \   0000000A   0x.... 0x....      BL       gui_view_init
  15611             clear_cur_ui();
   \   0000000E   0x.... 0x....      BL       clear_cur_ui
  15612             disp_state_stack._disp_index += 1;
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable184_6
   \   00000016   0xF890 0x1064      LDRB     R1,[R0, #+100]
   \   0000001A   0x1C49             ADDS     R1,R1,#+1
   \   0000001C   0xF880 0x1064      STRB     R1,[R0, #+100]
  15613             if(mksReprint.mks_printer_state == MKS_REPRINTED)
   \   00000020   0x....             LDR.N    R4,??DataTable184_7
   \   00000022   0x....             LDR.N    R0,??DataTable184_8
   \   00000024   0xF890 0x0AA0      LDRB     R0,[R0, #+2720]
   \   00000028   0x28AC             CMP      R0,#+172
   \   0000002A   0xD101             BNE.N    ??lcd_reInit_0
  15614             {
  15615             	button_disp_pause_state=1;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0x7020             STRB     R0,[R4, #+0]
  15616             }
  15617             draw_return_ui();
   \                     ??lcd_reInit_0: (+1)
   \   00000030   0x.... 0x....      BL       draw_return_ui
  15618             button_disp_pause_state=0;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7020             STRB     R0,[R4, #+0]
  15619             Lcd_Light_ON;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x....             LDR.N    R1,??DataTable184_9  ;; 0x422281b4
   \   0000003C   0x6008             STR      R0,[R1, #+0]
  15620          }
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
  15621          

   \                                 In section .text, align 2, keep-with-next
  15622          void idle(
  15623            #if ENABLED(ADVANCED_PAUSE_FEATURE)
  15624              bool no_stepper_sleep/*=false*/
  15625            #endif
  15626          ) {
   \                     _Z4idlev: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15627            #if ENABLED(MAX7219_DEBUG)
  15628              Max7219_idle_tasks();
  15629            #endif  // MAX7219_DEBUG
  15630          
  15631             if(gCfgItems.standby_mode==1)
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable188
   \   00000006   0xF890 0x12A4      LDRB     R1,[R0, #+676]
   \   0000000A   0x2901             CMP      R1,#+1
   \   0000000C   0xD116             BNE.N    ??idle_0
  15632              {
  15633                  if(display_hold_cnt>=gCfgItems.standby_time)
   \   0000000E   0x....             LDR.N    R1,??DataTable184_10
   \   00000010   0x6BCA             LDR      R2,[R1, #+60]
   \   00000012   0xF500 0x7029      ADD      R0,R0,#+676
   \   00000016   0x6843             LDR      R3,[R0, #+4]
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD307             BCC.N    ??idle_1
  15634                  {
  15635                      display_hold_cnt -= gCfgItems.standby_time;
   \   0000001C   0x6840             LDR      R0,[R0, #+4]
   \   0000001E   0x1A10             SUBS     R0,R2,R0
   \   00000020   0x63C8             STR      R0,[R1, #+60]
  15636                      display_hold=1;
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x72C8             STRB     R0,[R1, #+11]
  15637                      Lcd_Light_OFF;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x....             LDR.N    R2,??DataTable184_9  ;; 0x422281b4
   \   0000002A   0x6010             STR      R0,[R2, #+0]
  15638                  }
  15639                  if(display_hold_release==1)
   \                     ??idle_1: (+1)
   \   0000002C   0x7B08             LDRB     R0,[R1, #+12]
   \   0000002E   0x2801             CMP      R0,#+1
   \   00000030   0xD104             BNE.N    ??idle_0
  15640                  {
  15641                      display_hold=0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x72C8             STRB     R0,[R1, #+11]
  15642                      display_hold_release=0;
   \   00000036   0x7308             STRB     R0,[R1, #+12]
  15643                      lcd_reInit();
   \   00000038   0x.... 0x....      BL       _Z10lcd_reInitv
  15644                  }
  15645              }
  15646          
  15647            lcd_update();
   \                     ??idle_0: (+1)
   \   0000003C   0x.... 0x....      BL       _Z10lcd_updatev
  15648          
  15649            host_keepalive();
   \   00000040   0x.... 0x....      BL       _Z14host_keepalivev
  15650          
  15651            //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
  15652             #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
  15653              thermalManager.auto_report_temperatures();
   \   00000044   0x.... 0x....      BL       _ZN11Temperature24auto_report_temperaturesEv
  15654            #endif
  15655          
  15656            manage_inactivity(
  15657              #if ENABLED(ADVANCED_PAUSE_FEATURE)
  15658                no_stepper_sleep
  15659              #endif
  15660            );
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0x.... 0x....      BL       _Z17manage_inactivityb
  15661          
  15662            thermalManager.manage_heater();
   \   0000004E   0x.... 0x....      BL       _ZN11Temperature13manage_heaterEv
  15663          
  15664            #if ENABLED(PRINTCOUNTER)
  15665              print_job_timer.tick();
  15666            #endif
  15667          
  15668            #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
  15669              buzzer.tick();
  15670            #endif
  15671            #if 1
  15672            display_temper_error();
   \   00000052   0x.... 0x....      BL       _Z20display_temper_errorv
  15673            
  15674            wifi_looping();
   \   00000056   0x.... 0x....      BL       _Z12wifi_loopingv
  15675            
  15676            if(wifi_link_state != WIFI_TRANS_FILE)
   \   0000005A   0x....             LDR.N    R0,??DataTable184_11
   \   0000005C   0xF990 0x0000      LDRSB    R0,[R0, #+0]
   \   00000060   0x2810             CMP      R0,#+16
   \   00000062   0xD001             BEQ.N    ??idle_2
  15677            {
  15678          	  GUI_RefreshPage();
   \   00000064   0x.... 0x....      BL       GUI_RefreshPage
  15679            }
  15680            #if defined(TFT70)
  15681            disp_pre_gcode(3,40);
  15682            #elif defined(TFT35)
  15683            //#if defined(MKS_ROBIN2)
  15684            if(preview_no_display != 1)
   \                     ??idle_2: (+1)
   \   00000068   0x....             LDR.N    R0,??DataTable184_10
   \   0000006A   0x7940             LDRB     R0,[R0, #+5]
   \   0000006C   0x2801             CMP      R0,#+1
   \   0000006E   0xD003             BEQ.N    ??idle_3
  15685            {
  15686          	  disp_pre_gcode(2,36);
   \   00000070   0x2124             MOVS     R1,#+36
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0x.... 0x....      BL       disp_pre_gcode
  15687            }
  15688            //#endif
  15689            #endif
  15690            
  15691            GUI_TOUCH_Exec(); 	  
   \                     ??idle_3: (+1)
   \   00000078   0x.... 0x....      BL       GUI_TOUCH_Exec
  15692            GUI_Exec(); 
   \   0000007C   0xE8BD 0x4001      POP      {R0,LR}
   \   00000080   0x.... 0x....      B.W      GUI_Exec
  15693          
  15694          #endif
  15695            #if ENABLED(I2C_POSITION_ENCODERS)
  15696              if (planner.blocks_queued() &&
  15697                  ( (blockBufferIndexRef != planner.block_buffer_head) ||
  15698                    ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
  15699                blockBufferIndexRef = planner.block_buffer_head;
  15700                I2CPEM.update();
  15701                lastUpdateMillis = millis();
  15702              }
  15703            #endif
  15704          }
  15705          
  15706          extern "C" void kill_c(const char* lcd_msg);

   \                                 In section .text, align 4, keep-with-next
  15707          void kill_c(const char* lcd_msg) {
   \                     kill_c: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15708            SERIAL_ERROR_START();
   \   00000002   0x....             LDR.N    R0,??DataTable184_3
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15709            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   00000008   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15710          
  15711            thermalManager.disable_all_heaters();
   \   00000010   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15712            disable_all_steppers();
   \   00000014   0x.... 0x....      BL       _Z20disable_all_steppersv
  15713          
  15714            #if ENABLED(ULTRA_LCD)
  15715              kill_screen(lcd_msg);
  15716            #else
  15717              UNUSED(lcd_msg);
  15718            #endif
  15719          
  15720            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \   00000018   0xF44F 0x7016      MOV      R0,#+600
   \   0000001C   0x.... 0x....      BL       HAL_Delay
  15721            cli(); // Stop interrupts
   \   00000020   0xB672             cpsid i
  15722          
  15723            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \   00000022   0x20FA             MOVS     R0,#+250
   \   00000024   0x.... 0x....      BL       HAL_Delay
  15724            thermalManager.disable_all_heaters(); //turn off heaters again
   \   00000028   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15725          
  15726            #if HAS_POWER_SWITCH
  15727              SET_INPUT(PS_ON_PIN);
  15728            #endif
  15729          
  15730            suicide();
   \   0000002C   0x.... 0x....      BL       _Z7suicidev
  15731            while (1) {
   \                     ??kill_c_0: (+1)
   \   00000030   0xE7FE             B.N      ??kill_c_0
  15732              #if ENABLED(USE_WATCHDOG)
  15733                watchdog_reset();
  15734              #endif
  15735            } // Wait for reset
  15736          }
  15737          #if 1

   \                                 In section .text, align 2, keep-with-next
  15738          void temper_error_kill()
  15739          {
   \                     _Z17temper_error_killv: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15740            SERIAL_ERROR_START();
   \   00000002   0x....             LDR.N    R0,??DataTable184_3
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15741            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   00000008   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15742          
  15743            thermalManager.disable_all_heaters();
   \   00000010   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15744            disable_all_steppers();	
   \   00000014   0x.... 0x....      BL       _Z20disable_all_steppersv
  15745          
  15746            _delay_ms(600);
   \   00000018   0xF44F 0x7016      MOV      R0,#+600
   \   0000001C   0x.... 0x....      BL       HAL_Delay
  15747          
  15748            temper_error_flg = 1;
   \   00000020   0x2001             MOVS     R0,#+1
   \   00000022   0x....             LDR.N    R1,??DataTable184_12
   \   00000024   0x7008             STRB     R0,[R1, #+0]
  15749          }
   \   00000026   0xBD01             POP      {R0,PC}          ;; return
  15750          

   \                                 In section .text, align 2, keep-with-next
  15751          void display_temper_error()
  15752          {
   \                     _Z20display_temper_errorv: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
  15753              char buf_err[30]={0};
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x2120             MOVS     R1,#+32
   \   00000008   0x.... 0x....      BL       __aeabi_memclr4
  15754              
  15755          	if(temper_error_flg == 1)
   \   0000000C   0x....             LDR.N    R4,??DataTable184_12
   \   0000000E   0x7820             LDRB     R0,[R4, #+0]
   \   00000010   0x2801             CMP      R0,#+1
   \   00000012   0xD11F             BNE.N    ??display_temper_error_0
  15756          	{
  15757          		card.sdprinting = false;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x....             LDR.N    R1,??DataTable184_8
   \   00000018   0xF881 0x09B8      STRB     R0,[R1, #+2488]
  15758          		wait_for_heatup = false;
   \   0000001C   0x....             LDR.N    R1,??DataTable184_2
   \   0000001E   0x7108             STRB     R0,[R1, #+4]
  15759          
  15760          		GUI_SetBkColor(gCfgItems.background_color);
   \   00000020   0x.... 0x....      LDR.W    R5,??DataTable188
   \   00000024   0x6868             LDR      R0,[R5, #+4]
   \   00000026   0x.... 0x....      BL       GUI_SetBkColor
  15761          		GUI_SetColor(0X0000ff);//	oìé?×?ì?
   \   0000002A   0x20FF             MOVS     R0,#+255
   \   0000002C   0x.... 0x....      BL       GUI_SetColor
  15762                  sprintf(buf_err,"Err%d",temper_error_type);
   \   00000030   0x7862             LDRB     R2,[R4, #+1]
   \   00000032   0x.... 0x....      ADR.W    R1,`?<Constant "Err%d">`
   \   00000036   0xA800             ADD      R0,SP,#+0
   \   00000038   0x.... 0x....      BL       sprintf
  15763          		GUI_DispStringAt(buf_err,380, TITLE_YPOS);
   \   0000003C   0x2205             MOVS     R2,#+5
   \   0000003E   0xF44F 0x71BE      MOV      R1,#+380
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       GUI_DispStringAt
  15764          		GUI_SetBkColor(gCfgItems.background_color);
   \   00000048   0x6868             LDR      R0,[R5, #+4]
   \   0000004A   0x.... 0x....      BL       GUI_SetBkColor
  15765          		GUI_SetColor(gCfgItems.title_color);			
   \   0000004E   0x68A8             LDR      R0,[R5, #+8]
   \   00000050   0x.... 0x....      BL       GUI_SetColor
  15766          	}
  15767          }
   \                     ??display_temper_error_0: (+1)
   \   00000054   0xB009             ADD      SP,SP,#+36
   \   00000056   0xBD30             POP      {R4,R5,PC}       ;; return
  15768          
  15769          #endif
  15770          
  15771          /**
  15772           * Kill all activity and lock the machine.
  15773           * After this the machine will need to be reset.
  15774           */

   \                                 In section .text, align 4, keep-with-next
  15775          void kill(const char* lcd_msg) {
   \                     _Z4killPKc: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
  15776            SERIAL_ERROR_START();
   \   00000002   0x....             LDR.N    R0,??DataTable184_3
   \   00000004   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15777            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   \   00000008   0x.... 0x....      ADR.W    R0,`?<Constant "Printer halted. kill(...">`
   \   0000000C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15778          
  15779            thermalManager.disable_all_heaters();
   \   00000010   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15780            disable_all_steppers();
   \   00000014   0x.... 0x....      BL       _Z20disable_all_steppersv
  15781          
  15782            #if ENABLED(ULTRA_LCD)
  15783              kill_screen(lcd_msg);
  15784            #else
  15785              UNUSED(lcd_msg);
  15786            #endif
  15787          
  15788            _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   \   00000018   0xF44F 0x7016      MOV      R0,#+600
   \   0000001C   0x.... 0x....      BL       HAL_Delay
  15789           
  15790          
  15791            _delay_ms(250); //Wait to ensure all interrupts routines stopped
   \   00000020   0x20FA             MOVS     R0,#+250
   \   00000022   0x.... 0x....      BL       HAL_Delay
  15792             cli(); // Stop interrupts
   \   00000026   0xB672             cpsid i
  15793            thermalManager.disable_all_heaters(); //turn off heaters again
   \   00000028   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15794          
  15795            #ifdef ACTION_ON_KILL
  15796              SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
  15797            #endif
  15798          
  15799            #if HAS_POWER_SWITCH
  15800              SET_INPUT(PS_ON_PIN);
  15801            #endif
  15802          
  15803            suicide();
   \   0000002C   0x.... 0x....      BL       _Z7suicidev
  15804            while (1) {
   \                     ??kill_0: (+1)
   \   00000030   0xE7FE             B.N      ??kill_0
  15805              #if ENABLED(USE_WATCHDOG)
  15806                watchdog_reset();
  15807              #endif
  15808            } // Wait for reset
  15809          }
  15810          
  15811          /**
  15812           * Turn off heaters and stop the print in progress
  15813           * After a stop the machine may be resumed with M999
  15814           */

   \                                 In section .text, align 2, keep-with-next
  15815          void stop() {
   \                     _Z4stopv: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
  15816            thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   \   00000002   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
  15817          
  15818            #if ENABLED(PROBING_FANS_OFF)
  15819              if (fans_paused) fans_pause(false); // put things back the way they were
  15820            #endif
  15821          
  15822            if (IsRunning()) {
   \   00000006   0x.... 0x....      BL       _Z9IsRunningv
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD014             BEQ.N    ??stop_0
  15823              Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
   \   0000000E   0x....             LDR.N    R4,??DataTable184_13
   \   00000010   0x6AE0             LDR      R0,[R4, #+44]
   \   00000012   0x6320             STR      R0,[R4, #+48]
  15824              SERIAL_ERROR_START();
   \   00000014   0x....             LDR.N    R0,??DataTable184_3
   \   00000016   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15825              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   \   0000001A   0x.... 0x....      ADR.W    R0,`?<Constant "Printer stopped due t...">`
   \   0000001E   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15826              LCD_MESSAGEPGM(MSG_STOPPED);
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0x.... 0x....      ADR.W    R0,`?<Constant "STOPPED. ">`
   \   00000028   0x.... 0x....      BL       _Z16lcd_setstatusPGMPKca
  15827              safe_delay(350);       // allow enough time for messages to get out before stopping
   \   0000002C   0xF44F 0x70AF      MOV      R0,#+350
   \   00000030   0x.... 0x....      BL       _Z10safe_delaym
  15828              Running = false;
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x7120             STRB     R0,[R4, #+4]
  15829            }
  15830          }
   \                     ??stop_0: (+1)
   \   00000038   0xBD10             POP      {R4,PC}          ;; return
  15831          
  15832          /**
  15833           * Marlin entry-point: Set up before the program loop
  15834           *  - Set up the kill pin, filament runout, power hold
  15835           *  - Start the serial port
  15836           *  - Print startup messages and diagnostics
  15837           *  - Get EEPROM or default settings
  15838           *  - Initialize managers for:
  15839           *     temperature
  15840           *     planner
  15841           *     watchdog
  15842           *     stepper
  15843           *     photo pin
  15844           *     servos
  15845           *     LCD controller
  15846           *     Digipot I2C
  15847           *     Z probe sled
  15848           *     status LEDs
  15849           */

   \                                 In section .text, align 2, keep-with-next
  15850          void setup() {
   \                     setup: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
  15851          
  15852            #if ENABLED(MAX7219_DEBUG)
  15853              Max7219_init();
  15854            #endif
  15855          /*
  15856            #if ENABLED(DISABLE_JTAG)
  15857              // Disable JTAG on AT90USB chips to free up pins for IO
  15858              MCUCR = 0x80;
  15859              MCUCR = 0x80;
  15860            #endif
  15861            */
  15862          
  15863            #if ENABLED(FILAMENT_RUNOUT_SENSOR)
  15864              setup_filrunoutpin();
  15865            #endif
  15866          
  15867            setup_killpin();
   \   00000002   0x.... 0x....      BL       _Z13setup_killpinv
  15868          
  15869            //setup_powerhold();
  15870          
  15871            #if HAS_STEPPER_RESET
  15872              disableStepperDrivers();
  15873            #endif
  15874          
  15875            //MYSERIAL.begin(BAUDRATE);
  15876            //SERIAL_PROTOCOLLNPGM("start");
  15877            //SERIAL_ECHO_START();
  15878          
  15879            #if ENABLED(HAVE_TMC2208)
  15880              tmc2208_serial_begin();
  15881            #endif
  15882          
  15883            // Check startup - does nothing if bootloader sets MCUSR to 0
  15884            byte mcu = MCUSR;
  15885            if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
  15886            if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
  15887            if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
  15888            if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
  15889            if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
  15890            //MCUSR = 0;
  15891          
  15892            SERIAL_ECHOPGM(MSG_MARLIN);
   \   00000006   0x.... 0x....      ADR.W    R0,`?<Constant "MKS Robin Nano">`
   \   0000000A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15893            SERIAL_CHAR(' ');
   \   0000000E   0x....             LDR.N    R4,??DataTable184_5
   \   00000010   0x2120             MOVS     R1,#+32
   \   00000012   0x4620             MOV      R0,R4
   \   00000014   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15894            SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   \   00000018   0x.... 0x....      ADR.W    R0,`?<Constant "1.0.0\\n">`
   \   0000001C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15895            SERIAL_EOL();
   \   00000020   0x210A             MOVS     R1,#+10
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15896          
  15897            #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
  15898              SERIAL_ECHO_START();
   \   00000028   0x....             LDR.N    R5,??DataTable184_14
   \   0000002A   0x4628             MOV      R0,R5
   \   0000002C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15899              SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
   \   00000030   0x.... 0x....      ADR.W    R0,`?<Constant " Last Updated: ">`
   \   00000034   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15900              SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
   \   00000038   0x.... 0x....      ADR.W    R0,`?<Constant "2017-12-25 12:00">`
   \   0000003C   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15901              SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
   \   00000040   0x.... 0x....      ADR.W    R0,`?<Constant " | Author: (none, def...">`
   \   00000044   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15902              SERIAL_ECHO_START();
   \   00000048   0x4628             MOV      R0,R5
   \   0000004A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15903              SERIAL_ECHOLNPGM("Compiled: " __DATE__);
   \   0000004E   0x.... 0x....      ADR.W    R0,`?<Constant "Compiled: Feb 14 2020\\n">`
   \   00000052   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15904            #endif
  15905          
  15906            SERIAL_ECHO_START();
   \   00000056   0x4628             MOV      R0,R5
   \   00000058   0x.... 0x....      BL       _Z14serialprintPGMPKc
  15907            SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   \   0000005C   0x.... 0x....      BL       _Z10freeMemoryv
   \   00000060   0x4601             MOV      R1,R0
   \   00000062   0x.... 0x....      ADR.W    R0,`?<Constant " Free Memory: ">`
   \   00000066   0x.... 0x....      BL       _Z17serial_echopair_PPKci
  15908            SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
   \   0000006A   0xF44F 0x61A8      MOV      R1,#+1344
   \   0000006E   0x.... 0x....      ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
   \   00000072   0x.... 0x....      BL       _Z17serial_echopair_PPKci
   \   00000076   0x210A             MOVS     R1,#+10
   \   00000078   0x4620             MOV      R0,R4
   \   0000007A   0x.... 0x....      BL       _ZN10USARTClass5writeEh
  15909          
  15910            // Send "ok" after commands by default
  15911            for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
   \   0000007E   0x2000             MOVS     R0,#+0
   \   00000080   0x2201             MOVS     R2,#+1
   \   00000082   0x....             LDR.N    R4,??DataTable184_10
   \   00000084   0xE002             B.N      ??setup_0
   \                     ??setup_1: (+1)
   \   00000086   0x1909             ADDS     R1,R1,R4
   \   00000088   0x760A             STRB     R2,[R1, #+24]
   \   0000008A   0x1C40             ADDS     R0,R0,#+1
   \                     ??setup_0: (+1)
   \   0000008C   0xB240             SXTB     R0,R0
   \   0000008E   0x4601             MOV      R1,R0
   \   00000090   0x2904             CMP      R1,#+4
   \   00000092   0xDBF8             BLT.N    ??setup_1
  15912          
  15913            // Load data from EEPROM if available (or use defaults)
  15914            // This also updates variables in the planner, elsewhere
  15915            (void)settings.load();
   \   00000094   0x.... 0x....      BL       _ZN14MarlinSettings4loadEv
  15916          
  15917            //#if HAS_M206_COMMAND
  15918              // Initialize current position based on home_offset
  15919              if(MACHINETPYE != DELTA)
   \   00000098   0x....             LDR.N    R0,??DataTable184_2
   \   0000009A   0x....             LDR.N    R5,??DataTable184_1
   \   0000009C   0xF9B5 0x1058      LDRSH    R1,[R5, #+88]
   \   000000A0   0x2902             CMP      R1,#+2
   \   000000A2   0xD006             BEQ.N    ??setup_2
  15920              	COPY(current_position, home_offset);
   \   000000A4   0x220C             MOVS     R2,#+12
   \   000000A6   0xF104 0x0130      ADD      R1,R4,#+48
   \   000000AA   0x3008             ADDS     R0,R0,#+8
   \   000000AC   0x.... 0x....      BL       memcpy
   \   000000B0   0xE004             B.N      ??setup_3
  15921          	else
  15922            //#else
  15923              	ZERO(current_position);
   \                     ??setup_2: (+1)
   \   000000B2   0x2210             MOVS     R2,#+16
   \   000000B4   0x2100             MOVS     R1,#+0
   \   000000B6   0x3008             ADDS     R0,R0,#+8
   \   000000B8   0x.... 0x....      BL       memset
  15924            //#endif
  15925          
  15926            // Vital to init stepper/planner equivalent for current_position
  15927            SYNC_PLAN_POSITION_KINEMATIC();
   \                     ??setup_3: (+1)
   \   000000BC   0x.... 0x....      BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
  15928          
  15929            thermalManager.init();    // Initialize temperature loop
   \   000000C0   0x.... 0x....      LDR.W    R0,??DataTable191
   \   000000C4   0x.... 0x....      BL       _ZN11Temperature4initEv
  15930          
  15931            #if ENABLED(USE_WATCHDOG)
  15932              watchdog_init();
  15933            #endif
  15934            //tan add
  15935            soft_endstop_min_init();
   \   000000C8   0x.... 0x....      BL       _Z21soft_endstop_min_initv
  15936          
  15937            stepper.init();    // Initialize stepper, this enables interrupts!
   \   000000CC   0x.... 0x....      BL       _ZN7Stepper4initEv
  15938            servo_init();
   \   000000D0   0x.... 0x....      BL       _Z10servo_initv
  15939          
  15940            #if HAS_PHOTOGRAPH
  15941              OUT_WRITE(PHOTOGRAPH_PIN, LOW);
  15942            #endif
  15943          
  15944            #if HAS_CASE_LIGHT
  15945              case_light_on = CASE_LIGHT_DEFAULT_ON;
  15946              case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
  15947              update_case_light();
  15948            #endif
  15949          
  15950            #if ENABLED(SPINDLE_LASER_ENABLE)
  15951              OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
  15952              #if SPINDLE_DIR_CHANGE
  15953                OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
  15954              #endif
  15955              #if ENABLED(SPINDLE_LASER_PWM)
  15956                SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
  15957                analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
  15958              #endif
  15959            #endif
  15960          
  15961            #if HAS_BED_PROBE
  15962              endstops.enable_z_probe(false);
   \   000000D4   0x2000             MOVS     R0,#+0
   \   000000D6   0x.... 0x....      BL       _ZN8Endstops14enable_z_probeEb
  15963            #endif
  15964          
  15965            #if ENABLED(USE_CONTROLLER_FAN)
  15966              SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
  15967            #endif
  15968          
  15969            #if HAS_STEPPER_RESET
  15970              enableStepperDrivers();
  15971            #endif
  15972          
  15973            #if ENABLED(DIGIPOT_I2C)
  15974              digipot_i2c_init();
  15975            #endif
  15976          
  15977            #if ENABLED(DAC_STEPPER_CURRENT)
  15978              dac_init();
  15979            #endif
  15980          
  15981            #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
  15982              OUT_WRITE(SOL1_PIN, LOW); // turn it off
  15983            #endif
  15984          
  15985            #if HAS_HOME
  15986              SET_INPUT_PULLUP(HOME_PIN);
  15987            #endif
  15988          
  15989            #if PIN_EXISTS(STAT_LED_RED)
  15990              OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
  15991            #endif
  15992          
  15993            #if PIN_EXISTS(STAT_LED_BLUE)
  15994              OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
  15995            #endif
  15996          
  15997            #if HAS_COLOR_LEDS
  15998              leds.setup();
  15999            #endif
  16000          
  16001            #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
  16002              SET_OUTPUT(RGB_LED_R_PIN);
  16003              SET_OUTPUT(RGB_LED_G_PIN);
  16004              SET_OUTPUT(RGB_LED_B_PIN);
  16005              #if ENABLED(RGBW_LED)
  16006                SET_OUTPUT(RGB_LED_W_PIN);
  16007              #endif
  16008            #endif
  16009          
  16010            #if ENABLED(MK2_MULTIPLEXER)
  16011              SET_OUTPUT(E_MUX0_PIN);
  16012              SET_OUTPUT(E_MUX1_PIN);
  16013              SET_OUTPUT(E_MUX2_PIN);
  16014            #endif
  16015          
  16016            #if HAS_FANMUX
  16017              fanmux_init();
  16018            #endif
  16019          
  16020            lcd_init();
   \   000000DA   0x.... 0x....      BL       _Z8lcd_initv
  16021          
  16022            #if ENABLED(SHOW_BOOTSCREEN)
  16023              lcd_bootscreen();
  16024            #endif
  16025          
  16026            #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  16027              // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
  16028              for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
  16029                for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  16030                  mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
  16031          
  16032              // Remaining virtual tools are 100% filament 1
  16033              #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
  16034                for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
  16035                  for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  16036                    mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
  16037              #endif
  16038          
  16039              // Initialize mixing to tool 0 color
  16040              for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
  16041                mixing_factor[i] = mixing_virtual_tool_mix[0][i];
  16042            #endif
  16043          
  16044            //#if ENABLED(BLTOUCH)
  16045            mksCfg.mkstouch=1;
   \   000000DE   0x2001             MOVS     R0,#+1
   \   000000E0   0xF885 0x0100      STRB     R0,[R5, #+256]
  16046            if(MKSTOUCH == 1)
  16047            {
  16048              // Make sure any BLTouch error condition is cleared
  16049              bltouch_command(BLTOUCH_RESET);
   \   000000E4   0x20A0             MOVS     R0,#+160
   \   000000E6   0x.... 0x....      BL       _Z15bltouch_commandi
  16050              set_bltouch_deployed(true);
   \   000000EA   0x2001             MOVS     R0,#+1
   \   000000EC   0x.... 0x....      BL       _Z20set_bltouch_deployedb
  16051              set_bltouch_deployed(false);
   \   000000F0   0x2000             MOVS     R0,#+0
   \   000000F2   0x.... 0x....      BL       _Z20set_bltouch_deployedb
  16052            }
  16053            //#endif
  16054          
  16055            #if ENABLED(I2C_POSITION_ENCODERS)
  16056              I2CPEM.init();
  16057            #endif
  16058          
  16059            #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
  16060              i2c.onReceive(i2c_on_receive);
  16061              i2c.onRequest(i2c_on_request);
  16062            #endif
  16063          
  16064            #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
  16065              setup_endstop_interrupts();
  16066            #endif
  16067          
  16068            #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
  16069              move_extruder_servo(0);  // Initialize extruder servo
  16070            #endif
  16071          
  16072            #if ENABLED(SWITCHING_NOZZLE)
  16073              move_nozzle_servo(0);  // Initialize nozzle servo
  16074            #endif
  16075          
  16076            #if ENABLED(PARKING_EXTRUDER)
  16077              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
  16078                pe_activate_magnet(0);
  16079                pe_activate_magnet(1);
  16080              #else
  16081                pe_deactivate_magnet(0);
  16082                pe_deactivate_magnet(1);
  16083              #endif
  16084            #endif
  16085            #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
  16086              SET_OUTPUT(LCD_PINS_DC);
  16087              OUT_WRITE(LCD_PINS_RS, LOW);
  16088              delay(1000);
  16089              WRITE(LCD_PINS_RS, HIGH);
  16090            #endif
  16091              display_hold=0;
   \   000000F6   0x2000             MOVS     R0,#+0
   \   000000F8   0x72E0             STRB     R0,[R4, #+11]
  16092              display_hold_cnt=0;
   \   000000FA   0x63E0             STR      R0,[R4, #+60]
  16093          }
   \   000000FC   0xBD31             POP      {R0,R4,R5,PC}    ;; return
  16094          
  16095          /**
  16096           * The main Marlin program loop
  16097           *
  16098           *  - Save or log commands to SD
  16099           *  - Process available commands (if not saving)
  16100           *  - Call heater manager
  16101           *  - Call inactivity manager
  16102           *  - Call endstop manager
  16103           *  - Call LCD update
  16104           */

   \                                 In section .text, align 2, keep-with-next
  16105          void loop() {
   \                     loop: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
  16106          #if 1
  16107              //display_sd_error();
  16108          
  16109          	display_temper_error();
   \   00000002   0x.... 0x....      BL       _Z20display_temper_errorv
  16110          	
  16111          	PowerOff_Filament_Check();
   \   00000006   0x.... 0x....      BL       _Z23PowerOff_Filament_Checkv
  16112          	
  16113          	MYSERIAL.MoremenuCmd();
   \   0000000A   0x.... 0x....      LDR.W    R0,??DataTable192
   \   0000000E   0x.... 0x....      BL       _ZN10USARTClass11MoremenuCmdEv
  16114          
  16115          #endif
  16116            if (commands_in_queue < BUFSIZE) get_available_commands();
   \   00000012   0x.... 0x....      LDR.W    R4,??DataTable192_1
   \   00000016   0x78A0             LDRB     R0,[R4, #+2]
   \   00000018   0x2804             CMP      R0,#+4
   \   0000001A   0xDA01             BGE.N    ??loop_0
   \   0000001C   0x.... 0x....      BL       _Z22get_available_commandsv
  16117          
  16118            #if 0//ENABLED(SDSUPPORT)
  16119              card.checkautostart(false);
  16120            #endif
  16121            card.checkFilesys(gCfgItems.fileSysType);
   \                     ??loop_0: (+1)
   \   00000020   0x.... 0x....      LDR.W    R6,??DataTable192_2
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable188
   \   00000028   0xF890 0x10BA      LDRB     R1,[R0, #+186]
   \   0000002C   0x4630             MOV      R0,R6
   \   0000002E   0x.... 0x....      BL       _ZN10CardReader12checkFilesysEh
  16122          
  16123            if (commands_in_queue) {
   \   00000032   0x.... 0x....      LDR.W    R5,??DataTable191_1
   \   00000036   0x78A0             LDRB     R0,[R4, #+2]
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD038             BEQ.N    ??loop_1
  16124          
  16125              #if ENABLED(SDSUPPORT)
  16126          
  16127                if (card.saving) {
   \   0000003C   0xF896 0x09B9      LDRB     R0,[R6, #+2489]
   \   00000040   0x2800             CMP      R0,#+0
   \   00000042   0xD025             BEQ.N    ??loop_2
  16128                  char* command = command_queue[cmd_queue_index_r];
   \   00000044   0x79E8             LDRB     R0,[R5, #+7]
   \   00000046   0xEB00 0x0140      ADD      R1,R0,R0, LSL #+1
   \   0000004A   0x.... 0x....      LDR.W    R0,??DataTable191_2
   \   0000004E   0xEB00 0x1741      ADD      R7,R0,R1, LSL #+5
  16129                  if (strstr_P(command, PSTR("M29"))) {
   \   00000052   0x....             ADR.N    R1,??DataTable186_4  ;; "M29"
   \   00000054   0x4638             MOV      R0,R7
   \   00000056   0x.... 0x....      BL       _Z6strstrPcPKc
   \   0000005A   0x2800             CMP      R0,#+0
   \   0000005C   0xD00A             BEQ.N    ??loop_3
  16130                    // M29 closes the file
  16131                    card.closefile();
   \   0000005E   0x2100             MOVS     R1,#+0
   \   00000060   0x4630             MOV      R0,R6
   \   00000062   0x.... 0x....      BL       _ZN10CardReader9closefileEb
  16132                    SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
   \   00000066   0x.... 0x....      ADR.W    R0,`?<Constant "Done saving file.\\n">`
   \   0000006A   0x.... 0x....      BL       _Z14serialprintPGMPKc
  16133          
  16134                    #if ENABLED(SERIAL_STATS_DROPPED_RX)
  16135                      SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
  16136                    #endif
  16137          
  16138                    #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
  16139                      SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
  16140                    #endif
  16141          
  16142                    ok_to_send();
   \   0000006E   0x.... 0x....      BL       _Z10ok_to_sendv
   \   00000072   0xE00F             B.N      ??loop_4
  16143                  }
  16144                  else {
  16145                    // Write the string from the read buffer to SD
  16146                    card.write_command(command);
   \                     ??loop_3: (+1)
   \   00000074   0x4639             MOV      R1,R7
   \   00000076   0x4630             MOV      R0,R6
   \   00000078   0x.... 0x....      BL       _ZN10CardReader13write_commandEPc
  16147                    if (card.logging)
   \   0000007C   0xF896 0x09BA      LDRB     R0,[R6, #+2490]
   \   00000080   0x2800             CMP      R0,#+0
   \   00000082   0xD002             BEQ.N    ??loop_5
  16148                      process_next_command(); // The card is saving because it's logging
   \   00000084   0x.... 0x....      BL       _Z20process_next_commandv
   \   00000088   0xE004             B.N      ??loop_4
  16149                    else
  16150                      ok_to_send();
   \                     ??loop_5: (+1)
   \   0000008A   0x.... 0x....      BL       _Z10ok_to_sendv
   \   0000008E   0xE001             B.N      ??loop_4
  16151                  }
  16152                }
  16153                else
  16154                  process_next_command();
   \                     ??loop_2: (+1)
   \   00000090   0x.... 0x....      BL       _Z20process_next_commandv
  16155          
  16156              #else
  16157          
  16158                process_next_command();
  16159          
  16160              #endif // SDSUPPORT
  16161          
  16162              // The queue may be reset by a command handler or by code invoked by idle() within a handler
  16163              if (commands_in_queue) {
   \                     ??loop_4: (+1)
   \   00000094   0x78A0             LDRB     R0,[R4, #+2]
   \   00000096   0x2800             CMP      R0,#+0
   \   00000098   0xD009             BEQ.N    ??loop_1
  16164                --commands_in_queue;
   \   0000009A   0x1E40             SUBS     R0,R0,#+1
   \   0000009C   0x70A0             STRB     R0,[R4, #+2]
  16165                if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
   \   0000009E   0x79E8             LDRB     R0,[R5, #+7]
   \   000000A0   0x1C40             ADDS     R0,R0,#+1
   \   000000A2   0x71E8             STRB     R0,[R5, #+7]
   \   000000A4   0xB2C0             UXTB     R0,R0
   \   000000A6   0x2804             CMP      R0,#+4
   \   000000A8   0xDB01             BLT.N    ??loop_1
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x71E8             STRB     R0,[R5, #+7]
  16166              }
  16167            }
  16168            endstops.report_state();
   \                     ??loop_1: (+1)
   \   000000AE   0x.... 0x....      BL       _ZN8Endstops12report_stateEv
  16169            idle();
   \   000000B2   0x.... 0x....      BL       _Z4idlev
  16170            loop_start=1;
   \   000000B6   0x2001             MOVS     R0,#+1
   \   000000B8   0x71A8             STRB     R0,[R5, #+6]
  16171            
  16172            mks_PrintStatePolling();
   \   000000BA   0xE8BD 0x40F1      POP      {R0,R4-R7,LR}
   \   000000BE   0x.... 0x....      B.W      mks_PrintStatePolling
  16173          }
  16174          #if 1
  16175          uint16_t z_high_count;
  16176          
  16177          extern uint8_t poweroff_det_flg;
  16178          extern uint32_t poweroff_det_cnt;
  16179          extern uint8_t poweroff_det_low_flg;
  16180          extern uint32_t poweroff_det_low_cnt;
  16181          extern uint8_t poweroff_det_high_flg;
  16182          extern uint32_t poweroff_det_high_cnt;
  16183          
  16184          extern uint8_t filament_det1_flg;
  16185          extern uint32_t filament_det1_cnt;
  16186          extern uint8_t filament_det1_low_flg;
  16187          extern uint32_t filament_det1_low_cnt;
  16188          extern uint8_t filament_det1_high_flg;
  16189          extern uint32_t filament_det1_high_cnt;
  16190          extern uint8_t filament_det1_check;
  16191          
  16192          extern uint8_t filament_det2_flg;
  16193          extern uint32_t filament_det2_cnt;
  16194          extern uint8_t filament_det2_low_flg;
  16195          extern uint32_t filament_det2_low_cnt;
  16196          extern uint8_t filament_det2_high_flg;
  16197          extern uint32_t filament_det2_high_cnt;
  16198          extern uint8_t filament_det2_check;
  16199          

   \                                 In section .data, align 4
  16200          uint32_t wifi_loop_cycle = 500;
   \                     wifi_loop_cycle:
   \   00000000   0x000001F4         DC32 500
  16201          extern char wifi_check_time;
  16202          uint8_t wifi_init_flg = 0;
  16203          uint8_t wifi_init_state = 0;
  16204          uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
  16205          uint8_t waiting_wifi_time = 0;
  16206          
  16207          uint8_t beep_flg = 0;
  16208          uint32_t beep_cnt = 0;
  16209          
  16210          extern volatile uint8_t has_adjust_speed;
  16211          extern volatile uint16_t resume_printed_time;
  16212          
  16213          extern uint8_t print_finish_start_timer;
  16214          extern uint32_t print_finish_timer_count;
  16215          extern uint8_t print_finish_close_machine;
  16216          
  16217          #if 0
  16218          uint8_t btn_flg = 0;
  16219          uint32_t btn_beep_cnt = 0;
  16220          #endif
  16221          extern void mksBeeperAlarm(void);
  16222          

   \                                 In section .text, align 2, keep-with-next
  16223          void Beeper(uint32_t cnt)
  16224          {
  16225              beep_flg = 1;
   \                     _Z6Beeperj: (+1)
   \   00000000   0x.... 0x....      LDR.W    R1,??DataTable191_1
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0x744A             STRB     R2,[R1, #+17]
  16226              beep_cnt = cnt;
   \   00000008   0x6408             STR      R0,[R1, #+64]
  16227              BEEPER_OP = 1;
   \   0000000A   0x4610             MOV      R0,R2
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable192_3  ;; 0x42220194
   \   00000010   0x6008             STR      R0,[R1, #+0]
  16228          }
   \   00000012   0x4770             BX       LR               ;; return
  16229          

   \                                 In section .text, align 2, keep-with-next
  16230          void SysTick_Handler_User()
  16231          {
   \                     _Z20SysTick_Handler_Userv: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
  16232          		TimeIncrease++;
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable191_1
   \   00000008   0x6AE0             LDR      R0,[R4, #+44]
   \   0000000A   0x1C40             ADDS     R0,R0,#+1
   \   0000000C   0x62E0             STR      R0,[R4, #+44]
  16233          
  16234          
  16235          		if(filament_loading_time_flg == 1)
   \   0000000E   0xF44F 0x757A      MOV      R5,#+1000
   \   00000012   0x7820             LDRB     R0,[R4, #+0]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD131             BNE.N    ??SysTick_Handler_User_0
  16236          		{
  16237          			filament_loading_time_cnt++;
   \   00000018   0x6A60             LDR      R0,[R4, #+36]
   \   0000001A   0x1C46             ADDS     R6,R0,#+1
   \   0000001C   0x6266             STR      R6,[R4, #+36]
  16238          			filament_rate = (uint32_t)(((filament_loading_time_cnt/(gCfgItems.filament_loading_time*1000.0))*100.0)+0.5);
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable191_3
   \   00000022   0xF8D0 0x70F4      LDR      R7,[R0, #+244]
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       __aeabi_ui2d
   \   0000002C   0x4680             MOV      R8,R0
   \   0000002E   0x4689             MOV      R9,R1
   \   00000030   0x4638             MOV      R0,R7
   \   00000032   0x.... 0x....      BL       __aeabi_ui2d
   \   00000036   0x2200             MOVS     R2,#+0
   \   00000038   0x.... 0x....      LDR.W    R3,??DataTable192_4  ;; 0x408f4000
   \   0000003C   0x.... 0x....      BL       __aeabi_dmul
   \   00000040   0x4602             MOV      R2,R0
   \   00000042   0x460B             MOV      R3,R1
   \   00000044   0x4640             MOV      R0,R8
   \   00000046   0x4649             MOV      R1,R9
   \   00000048   0x.... 0x....      BL       __aeabi_ddiv
   \   0000004C   0x2200             MOVS     R2,#+0
   \   0000004E   0x.... 0x....      LDR.W    R3,??DataTable192_5  ;; 0x40590000
   \   00000052   0x.... 0x....      BL       __aeabi_dmul
   \   00000056   0x2200             MOVS     R2,#+0
   \   00000058   0x.... 0x....      LDR.W    R3,??DataTable192_6  ;; 0x3fe00000
   \   0000005C   0x.... 0x....      BL       __aeabi_dadd
   \   00000060   0x.... 0x....      BL       __aeabi_d2uiz
   \   00000064   0x.... 0x....      LDR.W    R1,??DataTable192_7
   \   00000068   0x6008             STR      R0,[R1, #+0]
  16239          			if(filament_loading_time_cnt >= (gCfgItems.filament_loading_time*1000))
   \   0000006A   0xFB05 0xF007      MUL      R0,R5,R7
   \   0000006E   0x4286             CMP      R6,R0
   \   00000070   0xD304             BCC.N    ??SysTick_Handler_User_0
  16240          			{
  16241          				filament_loading_time_cnt = 0;
   \   00000072   0x2000             MOVS     R0,#+0
   \   00000074   0x6260             STR      R0,[R4, #+36]
  16242          				filament_loading_time_flg = 0;
   \   00000076   0x7020             STRB     R0,[R4, #+0]
  16243          				filament_loading_completed = 1;
   \   00000078   0x2001             MOVS     R0,#+1
   \   0000007A   0x7060             STRB     R0,[R4, #+1]
  16244          			}
  16245          		}
  16246          		if(filament_unloading_time_flg == 1)
   \                     ??SysTick_Handler_User_0: (+1)
   \   0000007C   0x78A0             LDRB     R0,[R4, #+2]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD134             BNE.N    ??SysTick_Handler_User_1
  16247          		{
  16248          			filament_unloading_time_cnt++;
   \   00000082   0x6AA0             LDR      R0,[R4, #+40]
   \   00000084   0x1C46             ADDS     R6,R0,#+1
   \   00000086   0x62A6             STR      R6,[R4, #+40]
  16249          			filament_rate = (uint32_t)(((filament_unloading_time_cnt/(gCfgItems.filament_unloading_time*1000.0))*100.0)+0.5);
   \   00000088   0x.... 0x....      LDR.W    R0,??DataTable191_3
   \   0000008C   0x30F4             ADDS     R0,R0,#+244
   \   0000008E   0xF8D0 0x8004      LDR      R8,[R0, #+4]
   \   00000092   0x.... 0x....      LDR.W    R7,??DataTable192_7
   \   00000096   0x4630             MOV      R0,R6
   \   00000098   0x.... 0x....      BL       __aeabi_ui2d
   \   0000009C   0x4682             MOV      R10,R0
   \   0000009E   0x468B             MOV      R11,R1
   \   000000A0   0x4640             MOV      R0,R8
   \   000000A2   0x.... 0x....      BL       __aeabi_ui2d
   \   000000A6   0x2200             MOVS     R2,#+0
   \   000000A8   0x.... 0x....      LDR.W    R3,??DataTable192_4  ;; 0x408f4000
   \   000000AC   0x.... 0x....      BL       __aeabi_dmul
   \   000000B0   0x4602             MOV      R2,R0
   \   000000B2   0x460B             MOV      R3,R1
   \   000000B4   0x4650             MOV      R0,R10
   \   000000B6   0x4659             MOV      R1,R11
   \   000000B8   0x.... 0x....      BL       __aeabi_ddiv
   \   000000BC   0x2200             MOVS     R2,#+0
   \   000000BE   0x.... 0x....      LDR.W    R3,??DataTable192_5  ;; 0x40590000
   \   000000C2   0x.... 0x....      BL       __aeabi_dmul
   \   000000C6   0x2200             MOVS     R2,#+0
   \   000000C8   0x.... 0x....      LDR.W    R3,??DataTable192_6  ;; 0x3fe00000
   \   000000CC   0x.... 0x....      BL       __aeabi_dadd
   \   000000D0   0x.... 0x....      BL       __aeabi_d2uiz
   \   000000D4   0x6038             STR      R0,[R7, #+0]
  16250          			if(filament_unloading_time_cnt >= (gCfgItems.filament_unloading_time*1000))
   \   000000D6   0xFB05 0xF008      MUL      R0,R5,R8
   \   000000DA   0x4286             CMP      R6,R0
   \   000000DC   0xD306             BCC.N    ??SysTick_Handler_User_1
  16251          			{
  16252          				filament_unloading_time_cnt = 0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x62A0             STR      R0,[R4, #+40]
  16253          				filament_unloading_time_flg = 0;
   \   000000E2   0x70A0             STRB     R0,[R4, #+2]
  16254          				filament_unloading_completed = 1;
   \   000000E4   0x2001             MOVS     R0,#+1
   \   000000E6   0x70E0             STRB     R0,[R4, #+3]
  16255          				filament_rate = 100;
   \   000000E8   0x2064             MOVS     R0,#+100
   \   000000EA   0x6038             STR      R0,[R7, #+0]
  16256          			}
  16257          		}	
  16258          	
  16259          		temperature_change_frequency_cnt++;
   \                     ??SysTick_Handler_User_1: (+1)
   \   000000EC   0x6A20             LDR      R0,[R4, #+32]
   \   000000EE   0x1C40             ADDS     R0,R0,#+1
   \   000000F0   0x6220             STR      R0,[R4, #+32]
  16260          		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
   \   000000F2   0xF5B0 0x6FFA      CMP      R0,#+2000
   \   000000F6   0xD308             BCC.N    ??SysTick_Handler_User_2
   \   000000F8   0x.... 0x....      LDR.W    R0,??DataTable192_8
   \   000000FC   0x7801             LDRB     R1,[R0, #+0]
   \   000000FE   0x2901             CMP      R1,#+1
   \   00000100   0xD003             BEQ.N    ??SysTick_Handler_User_2
  16261          		{
  16262          			temperature_change_frequency_cnt = 0;
   \   00000102   0x2100             MOVS     R1,#+0
   \   00000104   0x6221             STR      R1,[R4, #+32]
  16263          			temperature_change_frequency = 1;
   \   00000106   0x2101             MOVS     R1,#+1
   \   00000108   0x7001             STRB     R1,[R0, #+0]
  16264          		}
  16265          		
  16266          		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
   \                     ??SysTick_Handler_User_2: (+1)
   \   0000010A   0x6AE0             LDR      R0,[R4, #+44]
   \   0000010C   0xF640 0x31B8      MOVW     R1,#+3000
   \   00000110   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000114   0xF640 0x32B8      MOVW     R2,#+3000
   \   00000118   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   0000011C   0x2800             CMP      R0,#+0
   \   0000011E   0xD101             BNE.N    ??SysTick_Handler_User_3
  16267          		{		
  16268          			printing_rate_update_flag = 1;
   \   00000120   0x2001             MOVS     R0,#+1
   \   00000122   0x7120             STRB     R0,[R4, #+4]
  16269          		}	
  16270          
  16271          		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
   \                     ??SysTick_Handler_User_3: (+1)
   \   00000124   0x6AE0             LDR      R0,[R4, #+44]
   \   00000126   0x4629             MOV      R1,R5
   \   00000128   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000012C   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   00000130   0x2800             CMP      R0,#+0
   \   00000132   0xD10B             BNE.N    ??SysTick_Handler_User_4
  16272          		{		
  16273          			if(print_time.start == 1)
   \   00000134   0x.... 0x....      LDR.W    R0,??DataTable192_9
   \   00000138   0xF990 0x1007      LDRSB    R1,[R0, #+7]
   \   0000013C   0x2901             CMP      R1,#+1
   \   0000013E   0xD102             BNE.N    ??SysTick_Handler_User_5
  16274          			{
  16275          				print_time.seconds++;
   \   00000140   0x7941             LDRB     R1,[R0, #+5]
   \   00000142   0x1C49             ADDS     R1,R1,#+1
   \   00000144   0x7141             STRB     R1,[R0, #+5]
  16276          			}
  16277          			display_hold_cnt++;
   \                     ??SysTick_Handler_User_5: (+1)
   \   00000146   0x6BE0             LDR      R0,[R4, #+60]
   \   00000148   0x1C40             ADDS     R0,R0,#+1
   \   0000014A   0x63E0             STR      R0,[R4, #+60]
  16278          		}
  16279          		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
   \                     ??SysTick_Handler_User_4: (+1)
   \   0000014C   0x6AE0             LDR      R0,[R4, #+44]
   \   0000014E   0x4629             MOV      R1,R5
   \   00000150   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   00000154   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   00000158   0x2800             CMP      R0,#+0
   \   0000015A   0xD101             BNE.N    ??SysTick_Handler_User_6
  16280          		{
  16281          			z_high_count=1;
   \   0000015C   0x2001             MOVS     R0,#+1
   \   0000015E   0x83A0             STRH     R0,[R4, #+28]
  16282          		}
  16283          
  16284          	if(poweroff_det_flg==1)
   \                     ??SysTick_Handler_User_6: (+1)
   \   00000160   0x.... 0x....      LDR.W    R0,??DataTable192_10
   \   00000164   0x7800             LDRB     R0,[R0, #+0]
   \   00000166   0x2801             CMP      R0,#+1
   \   00000168   0xD104             BNE.N    ??SysTick_Handler_User_7
  16285          	{
  16286          		poweroff_det_cnt++;
   \   0000016A   0x.... 0x....      LDR.W    R0,??DataTable193
   \   0000016E   0x6801             LDR      R1,[R0, #+0]
   \   00000170   0x1C49             ADDS     R1,R1,#+1
   \   00000172   0x6001             STR      R1,[R0, #+0]
  16287          	}
  16288          		
  16289          	if(filament_det1_flg==1)
   \                     ??SysTick_Handler_User_7: (+1)
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable193_1
   \   00000178   0x7800             LDRB     R0,[R0, #+0]
   \   0000017A   0x2801             CMP      R0,#+1
   \   0000017C   0xD104             BNE.N    ??SysTick_Handler_User_8
  16290          	{
  16291          		filament_det1_cnt++;
   \   0000017E   0x.... 0x....      LDR.W    R0,??DataTable193_2
   \   00000182   0x6801             LDR      R1,[R0, #+0]
   \   00000184   0x1C49             ADDS     R1,R1,#+1
   \   00000186   0x6001             STR      R1,[R0, #+0]
  16292          	}
  16293          
  16294          	if(filament_det1_low_flg==1)
   \                     ??SysTick_Handler_User_8: (+1)
   \   00000188   0x.... 0x....      LDR.W    R0,??DataTable193_3
   \   0000018C   0x7800             LDRB     R0,[R0, #+0]
   \   0000018E   0x2801             CMP      R0,#+1
   \   00000190   0xD104             BNE.N    ??SysTick_Handler_User_9
  16295          	{
  16296          		filament_det1_low_cnt++;
   \   00000192   0x.... 0x....      LDR.W    R0,??DataTable193_4
   \   00000196   0x6801             LDR      R1,[R0, #+0]
   \   00000198   0x1C49             ADDS     R1,R1,#+1
   \   0000019A   0x6001             STR      R1,[R0, #+0]
  16297          	}
  16298          
  16299          	if(filament_det1_high_flg==1)
   \                     ??SysTick_Handler_User_9: (+1)
   \   0000019C   0x.... 0x....      LDR.W    R0,??DataTable194
   \   000001A0   0x7800             LDRB     R0,[R0, #+0]
   \   000001A2   0x2801             CMP      R0,#+1
   \   000001A4   0xD104             BNE.N    ??SysTick_Handler_User_10
  16300          	{
  16301          		filament_det1_high_cnt++;
   \   000001A6   0x.... 0x....      LDR.W    R0,??DataTable194_1
   \   000001AA   0x6801             LDR      R1,[R0, #+0]
   \   000001AC   0x1C49             ADDS     R1,R1,#+1
   \   000001AE   0x6001             STR      R1,[R0, #+0]
  16302          	}
  16303          	if(filament_det2_flg==1)
   \                     ??SysTick_Handler_User_10: (+1)
   \   000001B0   0x.... 0x....      LDR.W    R0,??DataTable194_2
   \   000001B4   0x7800             LDRB     R0,[R0, #+0]
   \   000001B6   0x2801             CMP      R0,#+1
   \   000001B8   0xD104             BNE.N    ??SysTick_Handler_User_11
  16304          	{
  16305          		filament_det2_cnt++;
   \   000001BA   0x.... 0x....      LDR.W    R0,??DataTable194_3
   \   000001BE   0x6801             LDR      R1,[R0, #+0]
   \   000001C0   0x1C49             ADDS     R1,R1,#+1
   \   000001C2   0x6001             STR      R1,[R0, #+0]
  16306          	}
  16307          
  16308          	if(filament_det2_low_flg==1)
   \                     ??SysTick_Handler_User_11: (+1)
   \   000001C4   0x.... 0x....      LDR.W    R0,??DataTable194_4
   \   000001C8   0x7800             LDRB     R0,[R0, #+0]
   \   000001CA   0x2801             CMP      R0,#+1
   \   000001CC   0xD104             BNE.N    ??SysTick_Handler_User_12
  16309          	{
  16310          		filament_det2_low_cnt++;
   \   000001CE   0x.... 0x....      LDR.W    R0,??DataTable194_5
   \   000001D2   0x6801             LDR      R1,[R0, #+0]
   \   000001D4   0x1C49             ADDS     R1,R1,#+1
   \   000001D6   0x6001             STR      R1,[R0, #+0]
  16311          	}
  16312          
  16313          	if(filament_det2_high_flg==1)
   \                     ??SysTick_Handler_User_12: (+1)
   \   000001D8   0x.... 0x....      LDR.W    R0,??DataTable194_6
   \   000001DC   0x7800             LDRB     R0,[R0, #+0]
   \   000001DE   0x2801             CMP      R0,#+1
   \   000001E0   0xD104             BNE.N    ??SysTick_Handler_User_13
  16314          	{
  16315          		filament_det2_high_cnt++;
   \   000001E2   0x.... 0x....      LDR.W    R0,??DataTable194_7
   \   000001E6   0x6801             LDR      R1,[R0, #+0]
   \   000001E8   0x1C49             ADDS     R1,R1,#+1
   \   000001EA   0x6001             STR      R1,[R0, #+0]
  16316          	}
  16317          
  16318          	if(poweroff_det_low_flg==1)
   \                     ??SysTick_Handler_User_13: (+1)
   \   000001EC   0x.... 0x....      LDR.W    R0,??DataTable194_8
   \   000001F0   0x7800             LDRB     R0,[R0, #+0]
   \   000001F2   0x2801             CMP      R0,#+1
   \   000001F4   0xD104             BNE.N    ??SysTick_Handler_User_14
  16319          	{
  16320          		poweroff_det_low_cnt++;
   \   000001F6   0x.... 0x....      LDR.W    R0,??DataTable195
   \   000001FA   0x6801             LDR      R1,[R0, #+0]
   \   000001FC   0x1C49             ADDS     R1,R1,#+1
   \   000001FE   0x6001             STR      R1,[R0, #+0]
  16321          	}
  16322          	
  16323          	if(poweroff_det_high_flg==1)
   \                     ??SysTick_Handler_User_14: (+1)
   \   00000200   0x.... 0x....      LDR.W    R0,??DataTable195_1
   \   00000204   0x7800             LDRB     R0,[R0, #+0]
   \   00000206   0x2801             CMP      R0,#+1
   \   00000208   0xD104             BNE.N    ??SysTick_Handler_User_15
  16324          	{
  16325          		poweroff_det_high_cnt++;
   \   0000020A   0x.... 0x....      LDR.W    R0,??DataTable195_2
   \   0000020E   0x6801             LDR      R1,[R0, #+0]
   \   00000210   0x1C49             ADDS     R1,R1,#+1
   \   00000212   0x6001             STR      R1,[R0, #+0]
  16326          	}		
  16327          
  16328          	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
   \                     ??SysTick_Handler_User_15: (+1)
   \   00000214   0x6AE0             LDR      R0,[R4, #+44]
   \   00000216   0xF241 0x3188      MOVW     R1,#+5000
   \   0000021A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000021E   0xF241 0x3288      MOVW     R2,#+5000
   \   00000222   0xFB02 0x0011      MLS      R0,R2,R1,R0
   \   00000226   0x2800             CMP      R0,#+0
   \   00000228   0xD11E             BNE.N    ??SysTick_Handler_User_16
  16329          	{
  16330          		wifi_check_time = 1;
   \   0000022A   0x2001             MOVS     R0,#+1
   \   0000022C   0x.... 0x....      LDR.W    R1,??DataTable195_3
   \   00000230   0x7008             STRB     R0,[R1, #+0]
  16331          		waiting_wifi_time ++;
   \   00000232   0x7C20             LDRB     R0,[R4, #+16]
   \   00000234   0x1C40             ADDS     R0,R0,#+1
   \   00000236   0x7420             STRB     R0,[R4, #+16]
  16332          		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
   \   00000238   0xB2C0             UXTB     R0,R0
   \   0000023A   0x2808             CMP      R0,#+8
   \   0000023C   0xD005             BEQ.N    ??SysTick_Handler_User_17
   \   0000023E   0x.... 0x....      LDR.W    R0,??DataTable191_3
   \   00000242   0xF890 0x022C      LDRB     R0,[R0, #+556]
   \   00000246   0x2802             CMP      R0,#+2
   \   00000248   0xD104             BNE.N    ??SysTick_Handler_User_18
  16333          		{
  16334          			if(wifi_init_flg == 0)
   \                     ??SysTick_Handler_User_17: (+1)
   \   0000024A   0x7B60             LDRB     R0,[R4, #+13]
   \   0000024C   0x2800             CMP      R0,#+0
   \   0000024E   0xD101             BNE.N    ??SysTick_Handler_User_18
  16335          			{
  16336          				wifi_init_flg = 1;
   \   00000250   0x2001             MOVS     R0,#+1
   \   00000252   0x7360             STRB     R0,[R4, #+13]
  16337          			}
  16338          			
  16339          		}
  16340          		if(wifi_refresh_flg == 0)
   \                     ??SysTick_Handler_User_18: (+1)
   \   00000254   0x7BA0             LDRB     R0,[R4, #+14]
   \   00000256   0x2800             CMP      R0,#+0
   \   00000258   0xD101             BNE.N    ??SysTick_Handler_User_19
  16341          			wifi_refresh_flg = 1;
   \   0000025A   0x2001             MOVS     R0,#+1
   \   0000025C   0x73A0             STRB     R0,[R4, #+14]
  16342          		
  16343          		if(cloud_refresh_flg == 0)
   \                     ??SysTick_Handler_User_19: (+1)
   \   0000025E   0x7BE0             LDRB     R0,[R4, #+15]
   \   00000260   0x2800             CMP      R0,#+0
   \   00000262   0xD101             BNE.N    ??SysTick_Handler_User_16
  16344          			cloud_refresh_flg = 1;
   \   00000264   0x2001             MOVS     R0,#+1
   \   00000266   0x73E0             STRB     R0,[R4, #+15]
  16345          
  16346          	}
  16347          	
  16348          
  16349          	mksBeeperAlarm();
   \                     ??SysTick_Handler_User_16: (+1)
   \   00000268   0x.... 0x....      BL       _Z14mksBeeperAlarmv
  16350          
  16351              if(beep_flg == 1)
   \   0000026C   0x7C60             LDRB     R0,[R4, #+17]
   \   0000026E   0x2801             CMP      R0,#+1
   \   00000270   0xD108             BNE.N    ??SysTick_Handler_User_20
  16352              {
  16353                  beep_cnt--;
   \   00000272   0x6C20             LDR      R0,[R4, #+64]
   \   00000274   0x1E40             SUBS     R0,R0,#+1
   \   00000276   0x6420             STR      R0,[R4, #+64]
  16354                  if(beep_cnt<=0)
   \   00000278   0xD104             BNE.N    ??SysTick_Handler_User_20
  16355                  {
  16356                     beep_flg = 0;
   \   0000027A   0x2000             MOVS     R0,#+0
   \   0000027C   0x7460             STRB     R0,[R4, #+17]
  16357                     BEEPER_OP = 0; 
   \   0000027E   0x.... 0x....      LDR.W    R1,??DataTable192_3  ;; 0x42220194
   \   00000282   0x6008             STR      R0,[R1, #+0]
  16358                  }
  16359              }  
  16360          	if(key_value_calc.timer == TIMER_START)
   \                     ??SysTick_Handler_User_20: (+1)
   \   00000284   0x.... 0x....      LDR.W    R0,??DataTable195_4
   \   00000288   0xF890 0x1025      LDRB     R1,[R0, #+37]
   \   0000028C   0x2901             CMP      R1,#+1
   \   0000028E   0xD102             BNE.N    ??SysTick_Handler_User_21
  16361          	{
  16362          		key_value_calc.timer_count++;
   \   00000290   0x6A81             LDR      R1,[R0, #+40]
   \   00000292   0x1C49             ADDS     R1,R1,#+1
   \   00000294   0x6281             STR      R1,[R0, #+40]
  16363          	}
  16364          	if(((TimeIncrease * TICK_CYCLE % 1000) == 0) )
   \                     ??SysTick_Handler_User_21: (+1)
   \   00000296   0x6AE0             LDR      R0,[R4, #+44]
   \   00000298   0x4629             MOV      R1,R5
   \   0000029A   0xFBB0 0xF1F1      UDIV     R1,R0,R1
   \   0000029E   0xFB05 0x0011      MLS      R0,R5,R1,R0
   \   000002A2   0x2800             CMP      R0,#+0
   \   000002A4   0xD107             BNE.N    ??SysTick_Handler_User_22
  16365          	{		
  16366          		if(tips_disp.timer == TIPS_TIMER_START)
   \   000002A6   0x.... 0x....      LDR.W    R0,??DataTable195_5
   \   000002AA   0x7801             LDRB     R1,[R0, #+0]
   \   000002AC   0x2901             CMP      R1,#+1
   \   000002AE   0xD102             BNE.N    ??SysTick_Handler_User_22
  16367          		{
  16368          			tips_disp.timer_count++;
   \   000002B0   0x7841             LDRB     R1,[R0, #+1]
   \   000002B2   0x1C49             ADDS     R1,R1,#+1
   \   000002B4   0x7041             STRB     R1,[R0, #+1]
  16369          		}
  16370          	}
  16371          #if 0
  16372              if(btn_flg == 1)
  16373              {
  16374                  btn_beep_cnt--;
  16375                  if(btn_beep_cnt<=0)
  16376                  {
  16377                     btn_flg = 0;
  16378                     BEEPER_OP = 0; 
  16379                  }
  16380              }
  16381              #endif
  16382          	if(has_adjust_speed==1)resume_printed_time++;
   \                     ??SysTick_Handler_User_22: (+1)
   \   000002B6   0x7CA0             LDRB     R0,[R4, #+18]
   \   000002B8   0x2801             CMP      R0,#+1
   \   000002BA   0xD102             BNE.N    ??SysTick_Handler_User_23
   \   000002BC   0x8BE0             LDRH     R0,[R4, #+30]
   \   000002BE   0x1C40             ADDS     R0,R0,#+1
   \   000002C0   0x83E0             STRH     R0,[R4, #+30]
  16383          
  16384          	if(print_finish_start_timer==TIMER_START)
   \                     ??SysTick_Handler_User_23: (+1)
   \   000002C2   0x7CE0             LDRB     R0,[R4, #+19]
   \   000002C4   0x2801             CMP      R0,#+1
   \   000002C6   0xD10E             BNE.N    ??SysTick_Handler_User_24
  16385          	{
  16386          		print_finish_timer_count++;
   \   000002C8   0x6C60             LDR      R0,[R4, #+68]
   \   000002CA   0x1C40             ADDS     R0,R0,#+1
   \   000002CC   0x6460             STR      R0,[R4, #+68]
  16387          		if(print_finish_timer_count>=(gCfgItems.print_finish_count*1000))
   \   000002CE   0x.... 0x....      LDR.W    R1,??DataTable191_3
   \   000002D2   0xF8B1 0x12AE      LDRH     R1,[R1, #+686]
   \   000002D6   0x4369             MULS     R1,R5,R1
   \   000002D8   0x4288             CMP      R0,R1
   \   000002DA   0xD304             BCC.N    ??SysTick_Handler_User_24
  16388          		{
  16389          			print_finish_start_timer=TIMER_STOP;
   \   000002DC   0x2000             MOVS     R0,#+0
   \   000002DE   0x74E0             STRB     R0,[R4, #+19]
  16390          			print_finish_timer_count=0;
   \   000002E0   0x6460             STR      R0,[R4, #+68]
  16391          			print_finish_close_machine=true;
   \   000002E2   0x2001             MOVS     R0,#+1
   \   000002E4   0x7520             STRB     R0,[R4, #+20]
  16392          		}
  16393          	}
  16394          }
   \                     ??SysTick_Handler_User_24: (+1)
   \   000002E6   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return
  16395          #endif
  16396          
  16397          #include "mks_reprint.cpp"

   \                                 In section .data, align 4
   \   __absolute char *mks_pft_name
   \                     mks_pft_name:
   \   00000000   0x........         DC32 `?<Constant "mks_pft.sys">`

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_load()
   \                     mkstft_ui_load: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable191_3
   \   00000006   0x2204             MOVS     R2,#+4
   \   00000008   0x1D21             ADDS     R1,R4,#+4
   \   0000000A   0xF240 0x609E      MOVW     R0,#+1694
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF104 0x0108      ADD      R1,R4,#+8
   \   00000018   0xF240 0x60A2      MOVW     R0,#+1698
   \   0000001C   0x.... 0x....      BL       epr_read_data
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF104 0x010C      ADD      R1,R4,#+12
   \   00000026   0xF240 0x60A6      MOVW     R0,#+1702
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF104 0x0110      ADD      R1,R4,#+16
   \   00000034   0xF240 0x60AA      MOVW     R0,#+1706
   \   00000038   0x.... 0x....      BL       epr_read_data
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xF104 0x0118      ADD      R1,R4,#+24
   \   00000042   0xF240 0x60AE      MOVW     R0,#+1710
   \   00000046   0x.... 0x....      BL       epr_read_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF104 0x0114      ADD      R1,R4,#+20
   \   00000050   0xF240 0x60B2      MOVW     R0,#+1714
   \   00000054   0x.... 0x....      BL       epr_read_data
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xF104 0x0124      ADD      R1,R4,#+36
   \   0000005E   0xF240 0x60B6      MOVW     R0,#+1718
   \   00000062   0x.... 0x....      BL       epr_read_data
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xF104 0x0128      ADD      R1,R4,#+40
   \   0000006C   0xF240 0x60BA      MOVW     R0,#+1722
   \   00000070   0x.... 0x....      BL       epr_read_data
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xF104 0x012C      ADD      R1,R4,#+44
   \   0000007A   0xF240 0x60BE      MOVW     R0,#+1726
   \   0000007E   0x.... 0x....      BL       epr_read_data
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF104 0x0130      ADD      R1,R4,#+48
   \   00000088   0xF240 0x60C2      MOVW     R0,#+1730
   \   0000008C   0x.... 0x....      BL       epr_read_data
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF104 0x013C      ADD      R1,R4,#+60
   \   00000096   0xF240 0x60C6      MOVW     R0,#+1734
   \   0000009A   0x.... 0x....      BL       epr_read_data
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xF104 0x0140      ADD      R1,R4,#+64
   \   000000A4   0xF240 0x60CA      MOVW     R0,#+1738
   \   000000A8   0x.... 0x....      BL       epr_read_data
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF104 0x0134      ADD      R1,R4,#+52
   \   000000B2   0xF240 0x60CE      MOVW     R0,#+1742
   \   000000B6   0x.... 0x....      BL       epr_read_data
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xF104 0x0138      ADD      R1,R4,#+56
   \   000000C0   0xF240 0x60D2      MOVW     R0,#+1746
   \   000000C4   0x.... 0x....      BL       epr_read_data
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xF104 0x0154      ADD      R1,R4,#+84
   \   000000CE   0xF240 0x60D6      MOVW     R0,#+1750
   \   000000D2   0x.... 0x....      BL       epr_read_data
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF104 0x0158      ADD      R1,R4,#+88
   \   000000DC   0xF240 0x60DA      MOVW     R0,#+1754
   \   000000E0   0x.... 0x....      BL       epr_read_data
   \   000000E4   0x2201             MOVS     R2,#+1
   \   000000E6   0xF204 0x11BF      ADDW     R1,R4,#+447
   \   000000EA   0xF240 0x60DE      MOVW     R0,#+1758
   \   000000EE   0x.... 0x....      BL       epr_read_data
   \   000000F2   0x2201             MOVS     R2,#+1
   \   000000F4   0xF104 0x01B8      ADD      R1,R4,#+184
   \   000000F8   0xF240 0x60DF      MOVW     R0,#+1759
   \   000000FC   0x.... 0x....      BL       epr_read_data
   \   00000100   0x2201             MOVS     R2,#+1
   \   00000102   0xF104 0x01D4      ADD      R1,R4,#+212
   \   00000106   0xF240 0x7002      MOVW     R0,#+1794
   \   0000010A   0x.... 0x....      BL       epr_read_data
   \   0000010E   0x2204             MOVS     R2,#+4
   \   00000110   0xF104 0x01E4      ADD      R1,R4,#+228
   \   00000114   0xF44F 0x60DD      MOV      R0,#+1768
   \   00000118   0x.... 0x....      BL       epr_read_data
   \   0000011C   0x2204             MOVS     R2,#+4
   \   0000011E   0xF104 0x01DC      ADD      R1,R4,#+220
   \   00000122   0xF240 0x60EC      MOVW     R0,#+1772
   \   00000126   0x.... 0x....      BL       epr_read_data
   \   0000012A   0x2204             MOVS     R2,#+4
   \   0000012C   0xF104 0x01EC      ADD      R1,R4,#+236
   \   00000130   0xF44F 0x60DE      MOV      R0,#+1776
   \   00000134   0x.... 0x....      BL       epr_read_data
   \   00000138   0x2204             MOVS     R2,#+4
   \   0000013A   0xF104 0x01E8      ADD      R1,R4,#+232
   \   0000013E   0xF240 0x60F4      MOVW     R0,#+1780
   \   00000142   0x.... 0x....      BL       epr_read_data
   \   00000146   0x2204             MOVS     R2,#+4
   \   00000148   0xF104 0x01E0      ADD      R1,R4,#+224
   \   0000014C   0xF44F 0x60DF      MOV      R0,#+1784
   \   00000150   0x.... 0x....      BL       epr_read_data
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0xF104 0x01F0      ADD      R1,R4,#+240
   \   0000015A   0xF240 0x60FC      MOVW     R0,#+1788
   \   0000015E   0x.... 0x....      BL       epr_read_data
   \   00000162   0x2201             MOVS     R2,#+1
   \   00000164   0xF104 0x01D5      ADD      R1,R4,#+213
   \   00000168   0xF240 0x7001      MOVW     R0,#+1793
   \   0000016C   0x.... 0x....      BL       epr_read_data
   \   00000170   0x2201             MOVS     R2,#+1
   \   00000172   0xF204 0x2195      ADDW     R1,R4,#+661
   \   00000176   0xF240 0x7005      MOVW     R0,#+1797
   \   0000017A   0x.... 0x....      BL       epr_read_data
   \   0000017E   0x2201             MOVS     R2,#+1
   \   00000180   0xF504 0x71DE      ADD      R1,R4,#+444
   \   00000184   0xF240 0x7007      MOVW     R0,#+1799
   \   00000188   0x.... 0x....      BL       epr_read_data
   \   0000018C   0x2201             MOVS     R2,#+1
   \   0000018E   0xF104 0x01CD      ADD      R1,R4,#+205
   \   00000192   0xF44F 0x60E1      MOV      R0,#+1800
   \   00000196   0x.... 0x....      BL       epr_read_data
   \   0000019A   0x2201             MOVS     R2,#+1
   \   0000019C   0xF204 0x11BD      ADDW     R1,R4,#+445
   \   000001A0   0xF240 0x7009      MOVW     R0,#+1801
   \   000001A4   0x.... 0x....      BL       epr_read_data
   \   000001A8   0x2201             MOVS     R2,#+1
   \   000001AA   0xF504 0x71DF      ADD      R1,R4,#+446
   \   000001AE   0xF240 0x700A      MOVW     R0,#+1802
   \   000001B2   0x.... 0x....      BL       epr_read_data
   \   000001B6   0x2201             MOVS     R2,#+1
   \   000001B8   0xF504 0x71E5      ADD      R1,R4,#+458
   \   000001BC   0xF240 0x700B      MOVW     R0,#+1803
   \   000001C0   0x.... 0x....      BL       epr_read_data
   \   000001C4   0x2201             MOVS     R2,#+1
   \   000001C6   0xF104 0x01FC      ADD      R1,R4,#+252
   \   000001CA   0xF240 0x700C      MOVW     R0,#+1804
   \   000001CE   0x.... 0x....      BL       epr_read_data
   \   000001D2   0x2201             MOVS     R2,#+1
   \   000001D4   0xF104 0x01FD      ADD      R1,R4,#+253
   \   000001D8   0xF240 0x700D      MOVW     R0,#+1805
   \   000001DC   0x.... 0x....      BL       epr_read_data
   \   000001E0   0x2202             MOVS     R2,#+2
   \   000001E2   0xF104 0x01FE      ADD      R1,R4,#+254
   \   000001E6   0xF240 0x700E      MOVW     R0,#+1806
   \   000001EA   0x.... 0x....      BL       epr_read_data
   \   000001EE   0x2202             MOVS     R2,#+2
   \   000001F0   0xF504 0x7180      ADD      R1,R4,#+256
   \   000001F4   0xF44F 0x60E2      MOV      R0,#+1808
   \   000001F8   0x.... 0x....      BL       epr_read_data
   \   000001FC   0x2202             MOVS     R2,#+2
   \   000001FE   0xF504 0x7181      ADD      R1,R4,#+258
   \   00000202   0xF240 0x7012      MOVW     R0,#+1810
   \   00000206   0x.... 0x....      BL       epr_read_data
   \   0000020A   0x2202             MOVS     R2,#+2
   \   0000020C   0xF504 0x7182      ADD      R1,R4,#+260
   \   00000210   0xF240 0x7014      MOVW     R0,#+1812
   \   00000214   0x.... 0x....      BL       epr_read_data
   \   00000218   0x2202             MOVS     R2,#+2
   \   0000021A   0xF504 0x7183      ADD      R1,R4,#+262
   \   0000021E   0xF240 0x7016      MOVW     R0,#+1814
   \   00000222   0x.... 0x....      BL       epr_read_data
   \   00000226   0x2202             MOVS     R2,#+2
   \   00000228   0xF504 0x7184      ADD      R1,R4,#+264
   \   0000022C   0xF44F 0x60E3      MOV      R0,#+1816
   \   00000230   0x.... 0x....      BL       epr_read_data
   \   00000234   0x2202             MOVS     R2,#+2
   \   00000236   0xF504 0x7185      ADD      R1,R4,#+266
   \   0000023A   0xF240 0x701A      MOVW     R0,#+1818
   \   0000023E   0x.... 0x....      BL       epr_read_data
   \   00000242   0x2202             MOVS     R2,#+2
   \   00000244   0xF504 0x7186      ADD      R1,R4,#+268
   \   00000248   0xF240 0x701C      MOVW     R0,#+1820
   \   0000024C   0x.... 0x....      BL       epr_read_data
   \   00000250   0x2202             MOVS     R2,#+2
   \   00000252   0xF504 0x7187      ADD      R1,R4,#+270
   \   00000256   0xF240 0x701E      MOVW     R0,#+1822
   \   0000025A   0x.... 0x....      BL       epr_read_data
   \   0000025E   0x2202             MOVS     R2,#+2
   \   00000260   0xF504 0x7188      ADD      R1,R4,#+272
   \   00000264   0xF44F 0x60E4      MOV      R0,#+1824
   \   00000268   0x.... 0x....      BL       epr_read_data
   \   0000026C   0x2201             MOVS     R2,#+1
   \   0000026E   0xF104 0x01D9      ADD      R1,R4,#+217
   \   00000272   0xF240 0x7022      MOVW     R0,#+1826
   \   00000276   0x.... 0x....      BL       epr_read_data
   \   0000027A   0x2201             MOVS     R2,#+1
   \   0000027C   0xF204 0x212D      ADDW     R1,R4,#+557
   \   00000280   0xF240 0x7023      MOVW     R0,#+1827
   \   00000284   0x.... 0x....      BL       epr_read_data
   \   00000288   0x2201             MOVS     R2,#+1
   \   0000028A   0xF504 0x7127      ADD      R1,R4,#+668
   \   0000028E   0xF240 0x7031      MOVW     R0,#+1841
   \   00000292   0x.... 0x....      BL       epr_read_data
   \   00000296   0x2201             MOVS     R2,#+1
   \   00000298   0xF204 0x219D      ADDW     R1,R4,#+669
   \   0000029C   0xF240 0x702C      MOVW     R0,#+1836
   \   000002A0   0x.... 0x....      BL       epr_read_data
   \   000002A4   0x2201             MOVS     R2,#+1
   \   000002A6   0xF204 0x219E      ADDW     R1,R4,#+670
   \   000002AA   0xF240 0x702D      MOVW     R0,#+1837
   \   000002AE   0x.... 0x....      BL       epr_read_data
   \   000002B2   0x2201             MOVS     R2,#+1
   \   000002B4   0xF204 0x219F      ADDW     R1,R4,#+671
   \   000002B8   0xF240 0x702E      MOVW     R0,#+1838
   \   000002BC   0x.... 0x....      BL       epr_read_data
   \   000002C0   0x2202             MOVS     R2,#+2
   \   000002C2   0xF504 0x7128      ADD      R1,R4,#+672
   \   000002C6   0xF240 0x702F      MOVW     R0,#+1839
   \   000002CA   0x.... 0x....      BL       epr_read_data
   \   000002CE   0x2201             MOVS     R2,#+1
   \   000002D0   0xF204 0x21A2      ADDW     R1,R4,#+674
   \   000002D4   0xF240 0x7032      MOVW     R0,#+1842
   \   000002D8   0x.... 0x....      BL       epr_read_data
   \   000002DC   0x2201             MOVS     R2,#+1
   \   000002DE   0xF504 0x7129      ADD      R1,R4,#+676
   \   000002E2   0xF240 0x7033      MOVW     R0,#+1843
   \   000002E6   0x.... 0x....      BL       epr_read_data
   \   000002EA   0x2204             MOVS     R2,#+4
   \   000002EC   0xF504 0x712A      ADD      R1,R4,#+680
   \   000002F0   0xF240 0x7034      MOVW     R0,#+1844
   \   000002F4   0x.... 0x....      BL       epr_read_data
   \   000002F8   0x2202             MOVS     R2,#+2
   \   000002FA   0xF504 0x712B      ADD      R1,R4,#+684
   \   000002FE   0xF44F 0x60E7      MOV      R0,#+1848
   \   00000302   0x.... 0x....      BL       epr_read_data
   \   00000306   0x2202             MOVS     R2,#+2
   \   00000308   0xF204 0x21AE      ADDW     R1,R4,#+686
   \   0000030C   0xF240 0x703A      MOVW     R0,#+1850
   \   00000310   0xE8BD 0x4010      POP      {R4,LR}
   \   00000314   0x.... 0x....      B.W      epr_read_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_set_epr()
   \                     _Z17mkstft_ui_set_eprv: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0xF240 0x54AA      MOVW     R4,#+1450
   \   00000008   0x2204             MOVS     R2,#+4
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0x4620             MOV      R0,R4
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x.... 0x....      LDR.W    R5,??DataTable196  ;; 0x76313030
   \   00000016   0x9800             LDR      R0,[SP, #+0]
   \   00000018   0x42A8             CMP      R0,R5
   \   0000001A   0xF000 0x818F      BEQ.W    ??mkstft_ui_set_epr_0
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable191_3
   \   00000022   0x2204             MOVS     R2,#+4
   \   00000024   0x1D31             ADDS     R1,R6,#+4
   \   00000026   0xF240 0x609E      MOVW     R0,#+1694
   \   0000002A   0x.... 0x....      BL       epr_write_data
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0xF106 0x0108      ADD      R1,R6,#+8
   \   00000034   0xF240 0x60A2      MOVW     R0,#+1698
   \   00000038   0x.... 0x....      BL       epr_write_data
   \   0000003C   0x2204             MOVS     R2,#+4
   \   0000003E   0xF106 0x010C      ADD      R1,R6,#+12
   \   00000042   0xF240 0x60A6      MOVW     R0,#+1702
   \   00000046   0x.... 0x....      BL       epr_write_data
   \   0000004A   0x2204             MOVS     R2,#+4
   \   0000004C   0xF106 0x0110      ADD      R1,R6,#+16
   \   00000050   0xF240 0x60AA      MOVW     R0,#+1706
   \   00000054   0x.... 0x....      BL       epr_write_data
   \   00000058   0x2204             MOVS     R2,#+4
   \   0000005A   0xF106 0x0118      ADD      R1,R6,#+24
   \   0000005E   0xF240 0x60AE      MOVW     R0,#+1710
   \   00000062   0x.... 0x....      BL       epr_write_data
   \   00000066   0x2204             MOVS     R2,#+4
   \   00000068   0xF106 0x0114      ADD      R1,R6,#+20
   \   0000006C   0xF240 0x60B2      MOVW     R0,#+1714
   \   00000070   0x.... 0x....      BL       epr_write_data
   \   00000074   0x2204             MOVS     R2,#+4
   \   00000076   0xF106 0x0124      ADD      R1,R6,#+36
   \   0000007A   0xF240 0x60B6      MOVW     R0,#+1718
   \   0000007E   0x.... 0x....      BL       epr_write_data
   \   00000082   0x2204             MOVS     R2,#+4
   \   00000084   0xF106 0x0128      ADD      R1,R6,#+40
   \   00000088   0xF240 0x60BA      MOVW     R0,#+1722
   \   0000008C   0x.... 0x....      BL       epr_write_data
   \   00000090   0x2204             MOVS     R2,#+4
   \   00000092   0xF106 0x012C      ADD      R1,R6,#+44
   \   00000096   0xF240 0x60BE      MOVW     R0,#+1726
   \   0000009A   0x.... 0x....      BL       epr_write_data
   \   0000009E   0x2204             MOVS     R2,#+4
   \   000000A0   0xF106 0x0130      ADD      R1,R6,#+48
   \   000000A4   0xF240 0x60C2      MOVW     R0,#+1730
   \   000000A8   0x.... 0x....      BL       epr_write_data
   \   000000AC   0x2204             MOVS     R2,#+4
   \   000000AE   0xF106 0x013C      ADD      R1,R6,#+60
   \   000000B2   0xF240 0x60C6      MOVW     R0,#+1734
   \   000000B6   0x.... 0x....      BL       epr_write_data
   \   000000BA   0x2204             MOVS     R2,#+4
   \   000000BC   0xF106 0x0140      ADD      R1,R6,#+64
   \   000000C0   0xF240 0x60CA      MOVW     R0,#+1738
   \   000000C4   0x.... 0x....      BL       epr_write_data
   \   000000C8   0x2204             MOVS     R2,#+4
   \   000000CA   0xF106 0x0134      ADD      R1,R6,#+52
   \   000000CE   0xF240 0x60CE      MOVW     R0,#+1742
   \   000000D2   0x.... 0x....      BL       epr_write_data
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF106 0x0138      ADD      R1,R6,#+56
   \   000000DC   0xF240 0x60D2      MOVW     R0,#+1746
   \   000000E0   0x.... 0x....      BL       epr_write_data
   \   000000E4   0x2204             MOVS     R2,#+4
   \   000000E6   0xF106 0x0154      ADD      R1,R6,#+84
   \   000000EA   0xF240 0x60D6      MOVW     R0,#+1750
   \   000000EE   0x.... 0x....      BL       epr_write_data
   \   000000F2   0x2204             MOVS     R2,#+4
   \   000000F4   0xF106 0x0158      ADD      R1,R6,#+88
   \   000000F8   0xF240 0x60DA      MOVW     R0,#+1754
   \   000000FC   0x.... 0x....      BL       epr_write_data
   \   00000100   0x2201             MOVS     R2,#+1
   \   00000102   0xF206 0x11BF      ADDW     R1,R6,#+447
   \   00000106   0xF240 0x60DE      MOVW     R0,#+1758
   \   0000010A   0x.... 0x....      BL       epr_write_data
   \   0000010E   0x2201             MOVS     R2,#+1
   \   00000110   0xF106 0x01B8      ADD      R1,R6,#+184
   \   00000114   0xF240 0x60DF      MOVW     R0,#+1759
   \   00000118   0x.... 0x....      BL       epr_write_data
   \   0000011C   0x2201             MOVS     R2,#+1
   \   0000011E   0xF106 0x01D4      ADD      R1,R6,#+212
   \   00000122   0xF240 0x7002      MOVW     R0,#+1794
   \   00000126   0x.... 0x....      BL       epr_write_data
   \   0000012A   0x2204             MOVS     R2,#+4
   \   0000012C   0xF106 0x01E4      ADD      R1,R6,#+228
   \   00000130   0xF44F 0x60DD      MOV      R0,#+1768
   \   00000134   0x.... 0x....      BL       epr_write_data
   \   00000138   0x2204             MOVS     R2,#+4
   \   0000013A   0xF106 0x01DC      ADD      R1,R6,#+220
   \   0000013E   0xF240 0x60EC      MOVW     R0,#+1772
   \   00000142   0x.... 0x....      BL       epr_write_data
   \   00000146   0x2204             MOVS     R2,#+4
   \   00000148   0xF106 0x01EC      ADD      R1,R6,#+236
   \   0000014C   0xF44F 0x60DE      MOV      R0,#+1776
   \   00000150   0x.... 0x....      BL       epr_write_data
   \   00000154   0x2204             MOVS     R2,#+4
   \   00000156   0xF106 0x01E8      ADD      R1,R6,#+232
   \   0000015A   0xF240 0x60F4      MOVW     R0,#+1780
   \   0000015E   0x.... 0x....      BL       epr_write_data
   \   00000162   0x2204             MOVS     R2,#+4
   \   00000164   0xF106 0x01E0      ADD      R1,R6,#+224
   \   00000168   0xF44F 0x60DF      MOV      R0,#+1784
   \   0000016C   0x.... 0x....      BL       epr_write_data
   \   00000170   0x2204             MOVS     R2,#+4
   \   00000172   0xF106 0x01F0      ADD      R1,R6,#+240
   \   00000176   0xF240 0x60FC      MOVW     R0,#+1788
   \   0000017A   0x.... 0x....      BL       epr_write_data
   \   0000017E   0x2201             MOVS     R2,#+1
   \   00000180   0xF106 0x01D5      ADD      R1,R6,#+213
   \   00000184   0xF240 0x7001      MOVW     R0,#+1793
   \   00000188   0x.... 0x....      BL       epr_write_data
   \   0000018C   0x2201             MOVS     R2,#+1
   \   0000018E   0xF206 0x2195      ADDW     R1,R6,#+661
   \   00000192   0xF240 0x7005      MOVW     R0,#+1797
   \   00000196   0x.... 0x....      BL       epr_write_data
   \   0000019A   0x2201             MOVS     R2,#+1
   \   0000019C   0xF506 0x71DE      ADD      R1,R6,#+444
   \   000001A0   0xF240 0x7007      MOVW     R0,#+1799
   \   000001A4   0x.... 0x....      BL       epr_write_data
   \   000001A8   0x2201             MOVS     R2,#+1
   \   000001AA   0xF106 0x01CD      ADD      R1,R6,#+205
   \   000001AE   0xF44F 0x60E1      MOV      R0,#+1800
   \   000001B2   0x.... 0x....      BL       epr_write_data
   \   000001B6   0x2201             MOVS     R2,#+1
   \   000001B8   0xF206 0x11BD      ADDW     R1,R6,#+445
   \   000001BC   0xF240 0x7009      MOVW     R0,#+1801
   \   000001C0   0x.... 0x....      BL       epr_write_data
   \   000001C4   0x2201             MOVS     R2,#+1
   \   000001C6   0xF506 0x71DF      ADD      R1,R6,#+446
   \   000001CA   0xF240 0x700A      MOVW     R0,#+1802
   \   000001CE   0x.... 0x....      BL       epr_write_data
   \   000001D2   0x2201             MOVS     R2,#+1
   \   000001D4   0xF506 0x71E5      ADD      R1,R6,#+458
   \   000001D8   0xF240 0x700B      MOVW     R0,#+1803
   \   000001DC   0x.... 0x....      BL       epr_write_data
   \   000001E0   0x2201             MOVS     R2,#+1
   \   000001E2   0xF106 0x01FC      ADD      R1,R6,#+252
   \   000001E6   0xF240 0x700C      MOVW     R0,#+1804
   \   000001EA   0x.... 0x....      BL       epr_write_data
   \   000001EE   0x2201             MOVS     R2,#+1
   \   000001F0   0xF106 0x01FD      ADD      R1,R6,#+253
   \   000001F4   0xF240 0x700D      MOVW     R0,#+1805
   \   000001F8   0x.... 0x....      BL       epr_write_data
   \   000001FC   0x2202             MOVS     R2,#+2
   \   000001FE   0xF106 0x01FE      ADD      R1,R6,#+254
   \   00000202   0xF240 0x700E      MOVW     R0,#+1806
   \   00000206   0x.... 0x....      BL       epr_write_data
   \   0000020A   0x2202             MOVS     R2,#+2
   \   0000020C   0xF506 0x7180      ADD      R1,R6,#+256
   \   00000210   0xF44F 0x60E2      MOV      R0,#+1808
   \   00000214   0x.... 0x....      BL       epr_write_data
   \   00000218   0x2202             MOVS     R2,#+2
   \   0000021A   0xF506 0x7181      ADD      R1,R6,#+258
   \   0000021E   0xF240 0x7012      MOVW     R0,#+1810
   \   00000222   0x.... 0x....      BL       epr_write_data
   \   00000226   0x2202             MOVS     R2,#+2
   \   00000228   0xF506 0x7182      ADD      R1,R6,#+260
   \   0000022C   0xF240 0x7014      MOVW     R0,#+1812
   \   00000230   0x.... 0x....      BL       epr_write_data
   \   00000234   0x2202             MOVS     R2,#+2
   \   00000236   0xF506 0x7183      ADD      R1,R6,#+262
   \   0000023A   0xF240 0x7016      MOVW     R0,#+1814
   \   0000023E   0x.... 0x....      BL       epr_write_data
   \   00000242   0x2202             MOVS     R2,#+2
   \   00000244   0xF506 0x7184      ADD      R1,R6,#+264
   \   00000248   0xF44F 0x60E3      MOV      R0,#+1816
   \   0000024C   0x.... 0x....      BL       epr_write_data
   \   00000250   0x2202             MOVS     R2,#+2
   \   00000252   0xF506 0x7185      ADD      R1,R6,#+266
   \   00000256   0xF240 0x701A      MOVW     R0,#+1818
   \   0000025A   0x.... 0x....      BL       epr_write_data
   \   0000025E   0x2202             MOVS     R2,#+2
   \   00000260   0xF506 0x7186      ADD      R1,R6,#+268
   \   00000264   0xF240 0x701C      MOVW     R0,#+1820
   \   00000268   0x.... 0x....      BL       epr_write_data
   \   0000026C   0x2202             MOVS     R2,#+2
   \   0000026E   0xF506 0x7187      ADD      R1,R6,#+270
   \   00000272   0xF240 0x701E      MOVW     R0,#+1822
   \   00000276   0x.... 0x....      BL       epr_write_data
   \   0000027A   0x2202             MOVS     R2,#+2
   \   0000027C   0xF506 0x7188      ADD      R1,R6,#+272
   \   00000280   0xF44F 0x60E4      MOV      R0,#+1824
   \   00000284   0x.... 0x....      BL       epr_write_data
   \   00000288   0x2201             MOVS     R2,#+1
   \   0000028A   0xF106 0x01D9      ADD      R1,R6,#+217
   \   0000028E   0xF240 0x7022      MOVW     R0,#+1826
   \   00000292   0x.... 0x....      BL       epr_write_data
   \   00000296   0x2201             MOVS     R2,#+1
   \   00000298   0xF206 0x212D      ADDW     R1,R6,#+557
   \   0000029C   0xF240 0x7023      MOVW     R0,#+1827
   \   000002A0   0x.... 0x....      BL       epr_write_data
   \   000002A4   0x2201             MOVS     R2,#+1
   \   000002A6   0xF506 0x7127      ADD      R1,R6,#+668
   \   000002AA   0xF240 0x7031      MOVW     R0,#+1841
   \   000002AE   0x.... 0x....      BL       epr_write_data
   \   000002B2   0x2201             MOVS     R2,#+1
   \   000002B4   0xF206 0x219D      ADDW     R1,R6,#+669
   \   000002B8   0xF240 0x702C      MOVW     R0,#+1836
   \   000002BC   0x.... 0x....      BL       epr_write_data
   \   000002C0   0x2201             MOVS     R2,#+1
   \   000002C2   0xF206 0x219E      ADDW     R1,R6,#+670
   \   000002C6   0xF240 0x702D      MOVW     R0,#+1837
   \   000002CA   0x.... 0x....      BL       epr_write_data
   \   000002CE   0x2201             MOVS     R2,#+1
   \   000002D0   0xF206 0x219F      ADDW     R1,R6,#+671
   \   000002D4   0xF240 0x702E      MOVW     R0,#+1838
   \   000002D8   0x.... 0x....      BL       epr_write_data
   \   000002DC   0x2202             MOVS     R2,#+2
   \   000002DE   0xF506 0x7128      ADD      R1,R6,#+672
   \   000002E2   0xF240 0x702F      MOVW     R0,#+1839
   \   000002E6   0x.... 0x....      BL       epr_write_data
   \   000002EA   0x2201             MOVS     R2,#+1
   \   000002EC   0xF206 0x21A2      ADDW     R1,R6,#+674
   \   000002F0   0xF240 0x7032      MOVW     R0,#+1842
   \   000002F4   0x.... 0x....      BL       epr_write_data
   \   000002F8   0x2201             MOVS     R2,#+1
   \   000002FA   0xF506 0x7129      ADD      R1,R6,#+676
   \   000002FE   0xF240 0x7033      MOVW     R0,#+1843
   \   00000302   0x.... 0x....      BL       epr_write_data
   \   00000306   0x2204             MOVS     R2,#+4
   \   00000308   0xF506 0x712A      ADD      R1,R6,#+680
   \   0000030C   0xF240 0x7034      MOVW     R0,#+1844
   \   00000310   0x.... 0x....      BL       epr_write_data
   \   00000314   0x2202             MOVS     R2,#+2
   \   00000316   0xF506 0x712B      ADD      R1,R6,#+684
   \   0000031A   0xF44F 0x60E7      MOV      R0,#+1848
   \   0000031E   0x.... 0x....      BL       epr_write_data
   \   00000322   0x2202             MOVS     R2,#+2
   \   00000324   0xF206 0x21AE      ADDW     R1,R6,#+686
   \   00000328   0xF240 0x703A      MOVW     R0,#+1850
   \   0000032C   0x.... 0x....      BL       epr_write_data
   \   00000330   0x9500             STR      R5,[SP, #+0]
   \   00000332   0x2204             MOVS     R2,#+4
   \   00000334   0xA900             ADD      R1,SP,#+0
   \   00000336   0x4620             MOV      R0,R4
   \   00000338   0x.... 0x....      BL       epr_write_data
   \                     ??mkstft_ui_set_epr_0: (+1)
   \   0000033C   0xBD73             POP      {R0,R1,R4-R6,PC}  ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mkstft_ui_init()
   \                     mkstft_ui_init: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x....             LDR.N    R4,??DataTable191_3
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable202_1  ;; 0x494949
   \   0000000A   0x6060             STR      R0,[R4, #+4]
   \   0000000C   0x1D21             ADDS     R1,R4,#+4
   \   0000000E   0xF06F 0x427F      MVN      R2,#-16777216
   \   00000012   0x604A             STR      R2,[R1, #+4]
   \   00000014   0x6088             STR      R0,[R1, #+8]
   \   00000016   0x60CA             STR      R2,[R1, #+12]
   \   00000018   0x6208             STR      R0,[R1, #+32]
   \   0000001A   0x624A             STR      R2,[R1, #+36]
   \   0000001C   0x6288             STR      R0,[R1, #+40]
   \   0000001E   0x62CA             STR      R2,[R1, #+44]
   \   00000020   0x6308             STR      R0,[R1, #+48]
   \   00000022   0x634A             STR      R2,[R1, #+52]
   \   00000024   0x6388             STR      R0,[R1, #+56]
   \   00000026   0x63CA             STR      R2,[R1, #+60]
   \   00000028   0xF44F 0x407F      MOV      R0,#+65280
   \   0000002C   0x6408             STR      R0,[R1, #+64]
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable202_2  ;; 0xaaaaaa
   \   00000032   0x6448             STR      R0,[R1, #+68]
   \   00000034   0x2000             MOVS     R0,#+0
   \   00000036   0x6488             STR      R0,[R1, #+72]
   \   00000038   0x64C8             STR      R0,[R1, #+76]
   \   0000003A   0xF44F 0x007F      MOV      R0,#+16711680
   \   0000003E   0x6508             STR      R0,[R1, #+80]
   \   00000040   0x654A             STR      R2,[R1, #+84]
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0x6588             STR      R0,[R1, #+88]
   \   00000046   0x65CA             STR      R2,[R1, #+92]
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0xF884 0x01BF      STRB     R0,[R4, #+447]
   \   0000004E   0xF104 0x019C      ADD      R1,R4,#+156
   \   00000052   0x2003             MOVS     R0,#+3
   \   00000054   0x7708             STRB     R0,[R1, #+28]
   \   00000056   0x2001             MOVS     R0,#+1
   \   00000058   0x7788             STRB     R0,[R1, #+30]
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0x70C8             STRB     R0,[R1, #+3]
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x009C      STRB     R0,[R4, #+156]
   \   00000064   0xF04F 0x507E      MOV      R0,#+1065353216
   \   00000068   0x6188             STR      R0,[R1, #+24]
   \   0000006A   0xF640 0x30B8      MOVW     R0,#+3000
   \   0000006E   0x8248             STRH     R0,[R1, #+18]
   \   00000070   0x2201             MOVS     R2,#+1
   \   00000072   0x740A             STRB     R2,[R1, #+16]
   \   00000074   0x2205             MOVS     R2,#+5
   \   00000076   0x73CA             STRB     R2,[R1, #+15]
   \   00000078   0x738A             STRB     R2,[R1, #+14]
   \   0000007A   0x2264             MOVS     R2,#+100
   \   0000007C   0x810A             STRH     R2,[R1, #+8]
   \   0000007E   0x814A             STRH     R2,[R1, #+10]
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xF884 0x10FC      STRB     R1,[R4, #+252]
   \   00000086   0xF104 0x01FC      ADD      R1,R4,#+252
   \   0000008A   0x2204             MOVS     R2,#+4
   \   0000008C   0x704A             STRB     R2,[R1, #+1]
   \   0000008E   0x2232             MOVS     R2,#+50
   \   00000090   0x804A             STRH     R2,[R1, #+2]
   \   00000092   0x808A             STRH     R2,[R1, #+4]
   \   00000094   0x22B4             MOVS     R2,#+180
   \   00000096   0x80CA             STRH     R2,[R1, #+6]
   \   00000098   0x2232             MOVS     R2,#+50
   \   0000009A   0x810A             STRH     R2,[R1, #+8]
   \   0000009C   0x22B4             MOVS     R2,#+180
   \   0000009E   0x814A             STRH     R2,[R1, #+10]
   \   000000A0   0x818A             STRH     R2,[R1, #+12]
   \   000000A2   0x2232             MOVS     R2,#+50
   \   000000A4   0x81CA             STRH     R2,[R1, #+14]
   \   000000A6   0x22B4             MOVS     R2,#+180
   \   000000A8   0x820A             STRH     R2,[R1, #+16]
   \   000000AA   0x61C8             STR      R0,[R1, #+28]
   \   000000AC   0xF240 0x50DC      MOVW     R0,#+1500
   \   000000B0   0x6188             STR      R0,[R1, #+24]
   \   000000B2   0xF204 0x109F      ADDW     R0,R4,#+415
   \   000000B6   0x2100             MOVS     R1,#+0
   \   000000B8   0x7741             STRB     R1,[R0, #+29]
   \   000000BA   0xF884 0x10CD      STRB     R1,[R4, #+205]
   \   000000BE   0x7781             STRB     R1,[R0, #+30]
   \   000000C0   0x77C1             STRB     R1,[R0, #+31]
   \   000000C2   0x4608             MOV      R0,R1
   \   000000C4   0xF884 0x01CA      STRB     R0,[R4, #+458]
   \   000000C8   0xF204 0x06CD      ADDW     R6,R4,#+205
   \   000000CC   0x7330             STRB     R0,[R6, #+12]
   \   000000CE   0x2206             MOVS     R2,#+6
   \   000000D0   0x.... 0x....      ADR.W    R1,`?<Constant "0.000">`
   \   000000D4   0xF504 0x70B0      ADD      R0,R4,#+352
   \   000000D8   0x.... 0x....      BL       __aeabi_memcpy
   \   000000DC   0x2001             MOVS     R0,#+1
   \   000000DE   0xF884 0x0129      STRB     R0,[R4, #+297]
   \   000000E2   0xF104 0x00DC      ADD      R0,R4,#+220
   \   000000E6   0x21C8             MOVS     R1,#+200
   \   000000E8   0x6101             STR      R1,[R0, #+16]
   \   000000EA   0xF44F 0x757A      MOV      R5,#+1000
   \   000000EE   0xF8C4 0x50DC      STR      R5,[R4, #+220]
   \   000000F2   0x2164             MOVS     R1,#+100
   \   000000F4   0x6081             STR      R1,[R0, #+8]
   \   000000F6   0x21C8             MOVS     R1,#+200
   \   000000F8   0x6141             STR      R1,[R0, #+20]
   \   000000FA   0x6045             STR      R5,[R0, #+4]
   \   000000FC   0x2164             MOVS     R1,#+100
   \   000000FE   0x60C1             STR      R1,[R0, #+12]
   \   00000100   0x2000             MOVS     R0,#+0
   \   00000102   0x71F0             STRB     R0,[R6, #+7]
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0x7230             STRB     R0,[R6, #+8]
   \   00000108   0xF884 0x022B      STRB     R0,[R4, #+555]
   \   0000010C   0x.... 0x....      LDR.W    R8,??DataTable204_1
   \   00000110   0x226C             MOVS     R2,#+108
   \   00000112   0x2100             MOVS     R1,#+0
   \   00000114   0x4640             MOV      R0,R8
   \   00000116   0x.... 0x....      BL       memset
   \   0000011A   0x.... 0x....      LDR.W    R6,??DataTable204_2
   \   0000011E   0x22A2             MOVS     R2,#+162
   \   00000120   0x2100             MOVS     R1,#+0
   \   00000122   0x4630             MOV      R0,R6
   \   00000124   0x.... 0x....      BL       memset
   \   00000128   0x270C             MOVS     R7,#+12
   \   0000012A   0x463A             MOV      R2,R7
   \   0000012C   0x.... 0x....      ADR.W    R1,`?<Constant "TP-LINK_MKS">`
   \   00000130   0x4640             MOV      R0,R8
   \   00000132   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000136   0x220A             MOVS     R2,#+10
   \   00000138   0x.... 0x....      ADR.W    R1,`?<Constant "makerbase">`
   \   0000013C   0xF108 0x0020      ADD      R0,R8,#+32
   \   00000140   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000144   0x.... 0x....      ADR.W    R8,`?<Constant "192.168.3.100">`
   \   00000148   0xF04F 0x090E      MOV      R9,#+14
   \   0000014C   0x464A             MOV      R2,R9
   \   0000014E   0x4641             MOV      R1,R8
   \   00000150   0x1C70             ADDS     R0,R6,#+1
   \   00000152   0x.... 0x....      BL       __aeabi_memcpy
   \   00000156   0x.... 0x....      ADR.W    R10,`?<Constant "255.255.255.0">`
   \   0000015A   0x464A             MOV      R2,R9
   \   0000015C   0x4651             MOV      R1,R10
   \   0000015E   0xF106 0x0011      ADD      R0,R6,#+17
   \   00000162   0x.... 0x....      BL       __aeabi_memcpy
   \   00000166   0x.... 0x....      ADR.W    R11,`?<Constant "192.168.3.1">`
   \   0000016A   0x463A             MOV      R2,R7
   \   0000016C   0x4659             MOV      R1,R11
   \   0000016E   0xF106 0x0021      ADD      R0,R6,#+33
   \   00000172   0x.... 0x....      BL       __aeabi_memcpy
   \   00000176   0x463A             MOV      R2,R7
   \   00000178   0x4659             MOV      R1,R11
   \   0000017A   0xF106 0x0031      ADD      R0,R6,#+49
   \   0000017E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000182   0x2001             MOVS     R0,#+1
   \   00000184   0x7030             STRB     R0,[R6, #+0]
   \   00000186   0x464A             MOV      R2,R9
   \   00000188   0x4641             MOV      R1,R8
   \   0000018A   0xF106 0x0042      ADD      R0,R6,#+66
   \   0000018E   0x.... 0x....      BL       __aeabi_memcpy
   \   00000192   0x464A             MOV      R2,R9
   \   00000194   0x4651             MOV      R1,R10
   \   00000196   0xF106 0x0052      ADD      R0,R6,#+82
   \   0000019A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000019E   0x463A             MOV      R2,R7
   \   000001A0   0x4659             MOV      R1,R11
   \   000001A2   0xF106 0x0062      ADD      R0,R6,#+98
   \   000001A6   0x.... 0x....      BL       __aeabi_memcpy
   \   000001AA   0x463A             MOV      R2,R7
   \   000001AC   0x4659             MOV      R1,R11
   \   000001AE   0xF106 0x0072      ADD      R0,R6,#+114
   \   000001B2   0x.... 0x....      BL       __aeabi_memcpy
   \   000001B6   0x463A             MOV      R2,R7
   \   000001B8   0x4659             MOV      R1,R11
   \   000001BA   0xF106 0x0082      ADD      R0,R6,#+130
   \   000001BE   0x.... 0x....      BL       __aeabi_memcpy
   \   000001C2   0x464A             MOV      R2,R9
   \   000001C4   0x.... 0x....      ADR.W    R1,`?<Constant "192.168.3.255">`
   \   000001C8   0xF106 0x0092      ADD      R0,R6,#+146
   \   000001CC   0x.... 0x....      BL       __aeabi_memcpy
   \   000001D0   0x2001             MOVS     R0,#+1
   \   000001D2   0xF886 0x0041      STRB     R0,[R6, #+65]
   \   000001D6   0xF204 0x262B      ADDW     R6,R4,#+555
   \   000001DA   0x2002             MOVS     R0,#+2
   \   000001DC   0x7070             STRB     R0,[R6, #+1]
   \   000001DE   0x220F             MOVS     R2,#+15
   \   000001E0   0x.... 0x....      ADR.W    R1,`?<Constant "baizhongyun.cn">`
   \   000001E4   0xF204 0x202E      ADDW     R0,R4,#+558
   \   000001E8   0x.... 0x....      BL       __aeabi_memcpy
   \   000001EC   0xF242 0x7066      MOVW     R0,#+10086
   \   000001F0   0xF8C4 0x0290      STR      R0,[R4, #+656]
   \   000001F4   0x2001             MOVS     R0,#+1
   \   000001F6   0x70B0             STRB     R0,[R6, #+2]
   \   000001F8   0xF504 0x7024      ADD      R0,R4,#+656
   \   000001FC   0x2117             MOVS     R1,#+23
   \   000001FE   0x7101             STRB     R1,[R0, #+4]
   \   00000200   0x2100             MOVS     R1,#+0
   \   00000202   0x7141             STRB     R1,[R0, #+5]
   \   00000204   0xF884 0x119F      STRB     R1,[R4, #+415]
   \   00000208   0xF884 0x1148      STRB     R1,[R4, #+328]
   \   0000020C   0xF884 0x1155      STRB     R1,[R4, #+341]
   \   00000210   0x7301             STRB     R1,[R0, #+12]
   \   00000212   0x7341             STRB     R1,[R0, #+13]
   \   00000214   0x7381             STRB     R1,[R0, #+14]
   \   00000216   0x73C1             STRB     R1,[R0, #+15]
   \   00000218   0x8205             STRH     R5,[R0, #+16]
   \   0000021A   0x7481             STRB     R1,[R0, #+18]
   \   0000021C   0x74C1             STRB     R1,[R0, #+19]
   \   0000021E   0x7501             STRB     R1,[R0, #+20]
   \   00000220   0x6181             STR      R1,[R0, #+24]
   \   00000222   0x2105             MOVS     R1,#+5
   \   00000224   0x8381             STRH     R1,[R0, #+28]
   \   00000226   0x21B4             MOVS     R1,#+180
   \   00000228   0x83C1             STRH     R1,[R0, #+30]
   \   0000022A   0x.... 0x....      BL       _Z17mkstft_ui_set_eprv
   \   0000022E   0x2000             MOVS     R0,#+0
   \   00000230   0x.... 0x....      LDR.W    R1,??DataTable206
   \   00000234   0x7008             STRB     R0,[R1, #+0]
   \   00000236   0x.... 0x....      LDR.W    R1,??DataTable208_1
   \   0000023A   0x7008             STRB     R0,[R1, #+0]
   \   0000023C   0xE8BD 0x8FF1      POP      {R0,R4-R11,PC}   ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_initPrint()
   \                     mks_initPrint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable192_2
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable207
   \   00000008   0xF8D0 0x10D4      LDR      R1,[R0, #+212]
   \   0000000C   0xF8C4 0x1A6C      STR      R1,[R4, #+2668]
   \   00000010   0xF604 0x216C      ADDW     R1,R4,#+2668
   \   00000014   0x30D4             ADDS     R0,R0,#+212
   \   00000016   0x6842             LDR      R2,[R0, #+4]
   \   00000018   0x604A             STR      R2,[R1, #+4]
   \   0000001A   0x6880             LDR      R0,[R0, #+8]
   \   0000001C   0x6088             STR      R0,[R1, #+8]
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable209  ;; 0x40a00000
   \   00000022   0x60C8             STR      R0,[R1, #+12]
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x6108             STR      R0,[R1, #+16]
   \   00000028   0x20A6             MOVS     R0,#+166
   \   0000002A   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   0000002E   0xF604 0x25A0      ADDW     R5,R4,#+2720
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x6068             STR      R0,[R5, #+4]
   \   00000036   0x2214             MOVS     R2,#+20
   \   00000038   0x4601             MOV      R1,R0
   \   0000003A   0xF504 0x601C      ADD      R0,R4,#+2496
   \   0000003E   0x.... 0x....      BL       memset
   \   00000042   0x2296             MOVS     R2,#+150
   \   00000044   0x2100             MOVS     R1,#+0
   \   00000046   0xF604 0x10D4      ADDW     R0,R4,#+2516
   \   0000004A   0x.... 0x....      BL       memset
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x86A8             STRH     R0,[R5, #+52]
   \   00000052   0x82E8             STRH     R0,[R5, #+22]
   \   00000054   0x8368             STRH     R0,[R5, #+26]
   \   00000056   0xF884 0x0D68      STRB     R0,[R4, #+3432]
   \   0000005A   0x7528             STRB     R0,[R5, #+20]
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr()
   \                     _Z14mks_WriteToEprv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable192_2
   \   00000004   0x4620             MOV      R0,R4
   \   00000006   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   0000000A   0xF8C4 0x0AA4      STR      R0,[R4, #+2724]
   \   0000000E   0xF604 0x25A4      ADDW     R5,R4,#+2724
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0x4629             MOV      R1,R5
   \   00000016   0xF240 0x40B1      MOVW     R0,#+1201
   \   0000001A   0x.... 0x....      BL       epr_write_data
   \   0000001E   0x.... 0x....      LDR.W    R6,??DataTable208_2
   \   00000022   0x6830             LDR      R0,[R6, #+0]
   \   00000024   0x8268             STRH     R0,[R5, #+18]
   \   00000026   0x2202             MOVS     R2,#+2
   \   00000028   0xF604 0x21B6      ADDW     R1,R4,#+2742
   \   0000002C   0xF240 0x40B5      MOVW     R0,#+1205
   \   00000030   0x.... 0x....      BL       epr_write_data
   \   00000034   0x.... 0x....      LDR.W    R7,??DataTable207
   \   00000038   0xF897 0x00F7      LDRB     R0,[R7, #+247]
   \   0000003C   0x2802             CMP      R0,#+2
   \   0000003E   0xD108             BNE.N    ??mks_WriteToEpr_0
   \   00000040   0x6870             LDR      R0,[R6, #+4]
   \   00000042   0x82A8             STRH     R0,[R5, #+20]
   \   00000044   0x2202             MOVS     R2,#+2
   \   00000046   0xF604 0x21B8      ADDW     R1,R4,#+2744
   \   0000004A   0xF240 0x40B7      MOVW     R0,#+1207
   \   0000004E   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_0: (+1)
   \   00000052   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD00A             BEQ.N    ??mks_WriteToEpr_1
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable208_3
   \   0000005E   0x8800             LDRH     R0,[R0, #+0]
   \   00000060   0x82E8             STRH     R0,[R5, #+22]
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0xF604 0x21BA      ADDW     R1,R4,#+2746
   \   00000068   0xF240 0x40B9      MOVW     R0,#+1209
   \   0000006C   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_1: (+1)
   \   00000070   0x2204             MOVS     R2,#+4
   \   00000072   0xF504 0x6128      ADD      R1,R4,#+2688
   \   00000076   0xF240 0x40BB      MOVW     R0,#+1211
   \   0000007A   0x.... 0x....      BL       epr_write_data
   \   0000007E   0x2204             MOVS     R2,#+4
   \   00000080   0xF604 0x2184      ADDW     R1,R4,#+2692
   \   00000084   0xF240 0x40BF      MOVW     R0,#+1215
   \   00000088   0x.... 0x....      BL       epr_write_data
   \   0000008C   0x2204             MOVS     R2,#+4
   \   0000008E   0xF604 0x2188      ADDW     R1,R4,#+2696
   \   00000092   0xF240 0x40C3      MOVW     R0,#+1219
   \   00000096   0x.... 0x....      BL       epr_write_data
   \   0000009A   0x2204             MOVS     R2,#+4
   \   0000009C   0xF604 0x218C      ADDW     R1,R4,#+2700
   \   000000A0   0xF240 0x40C7      MOVW     R0,#+1223
   \   000000A4   0x.... 0x....      BL       epr_write_data
   \   000000A8   0x2204             MOVS     R2,#+4
   \   000000AA   0xF504 0x6129      ADD      R1,R4,#+2704
   \   000000AE   0xF240 0x40CB      MOVW     R0,#+1227
   \   000000B2   0x.... 0x....      BL       epr_write_data
   \   000000B6   0x2204             MOVS     R2,#+4
   \   000000B8   0xF604 0x2194      ADDW     R1,R4,#+2708
   \   000000BC   0xF240 0x40CF      MOVW     R0,#+1231
   \   000000C0   0x.... 0x....      BL       epr_write_data
   \   000000C4   0x2204             MOVS     R2,#+4
   \   000000C6   0xF604 0x2198      ADDW     R1,R4,#+2712
   \   000000CA   0xF240 0x40D3      MOVW     R0,#+1235
   \   000000CE   0x.... 0x....      BL       epr_write_data
   \   000000D2   0x2204             MOVS     R2,#+4
   \   000000D4   0xF604 0x219C      ADDW     R1,R4,#+2716
   \   000000D8   0xF240 0x40D7      MOVW     R0,#+1239
   \   000000DC   0x.... 0x....      BL       epr_write_data
   \   000000E0   0x....             LDR.N    R5,??DataTable192_9
   \   000000E2   0x2202             MOVS     R2,#+2
   \   000000E4   0x1CA9             ADDS     R1,R5,#+2
   \   000000E6   0xF44F 0x609E      MOV      R0,#+1264
   \   000000EA   0x.... 0x....      BL       epr_write_data
   \   000000EE   0x2201             MOVS     R2,#+1
   \   000000F0   0x1D29             ADDS     R1,R5,#+4
   \   000000F2   0xF240 0x40F2      MOVW     R0,#+1266
   \   000000F6   0x.... 0x....      BL       epr_write_data
   \   000000FA   0x2201             MOVS     R2,#+1
   \   000000FC   0x1D69             ADDS     R1,R5,#+5
   \   000000FE   0xF240 0x40F3      MOVW     R0,#+1267
   \   00000102   0x.... 0x....      BL       epr_write_data
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0xF504 0x612C      ADD      R1,R4,#+2752
   \   0000010C   0xF240 0x40DF      MOVW     R0,#+1247
   \   00000110   0x.... 0x....      BL       epr_write_data
   \   00000114   0x2204             MOVS     R2,#+4
   \   00000116   0xF604 0x21BC      ADDW     R1,R4,#+2748
   \   0000011A   0xF240 0x40DB      MOVW     R0,#+1243
   \   0000011E   0x.... 0x....      BL       epr_write_data
   \   00000122   0x2201             MOVS     R2,#+1
   \   00000124   0x.... 0x....      LDR.W    R1,??DataTable211
   \   00000128   0xF240 0x40F4      MOVW     R0,#+1268
   \   0000012C   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   00000130   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr()
   \                     mks_ReadFromEpr: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x.... 0x....      LDR.W    R5,??DataTable207_1
   \   00000006   0x2296             MOVS     R2,#+150
   \   00000008   0xF605 0x11D4      ADDW     R1,R5,#+2516
   \   0000000C   0xF240 0x40FD      MOVW     R0,#+1277
   \   00000010   0x.... 0x....      BL       epr_read_data
   \   00000014   0xF240 0x40B1      MOVW     R0,#+1201
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable210
   \   0000001C   0xF894 0x119F      LDRB     R1,[R4, #+415]
   \   00000020   0x2901             CMP      R1,#+1
   \   00000022   0xD005             BEQ.N    ??mks_ReadFromEpr_0
   \   00000024   0x2204             MOVS     R2,#+4
   \   00000026   0xF605 0x21A4      ADDW     R1,R5,#+2724
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0xE00B             B.N      ??mks_ReadFromEpr_1
   \                     ??mks_ReadFromEpr_0: (+1)
   \   00000030   0x2204             MOVS     R2,#+4
   \   00000032   0xF605 0x21AC      ADDW     R1,R5,#+2732
   \   00000036   0x.... 0x....      BL       epr_read_data
   \   0000003A   0x2204             MOVS     R2,#+4
   \   0000003C   0xF605 0x21A8      ADDW     R1,R5,#+2728
   \   00000040   0xF240 0x40F5      MOVW     R0,#+1269
   \   00000044   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_1: (+1)
   \   00000048   0x2202             MOVS     R2,#+2
   \   0000004A   0xF605 0x21B6      ADDW     R1,R5,#+2742
   \   0000004E   0xF240 0x40B5      MOVW     R0,#+1205
   \   00000052   0x.... 0x....      BL       epr_read_data
   \   00000056   0x.... 0x....      LDR.W    R6,??DataTable207
   \   0000005A   0xF896 0x00F7      LDRB     R0,[R6, #+247]
   \   0000005E   0x2802             CMP      R0,#+2
   \   00000060   0xD106             BNE.N    ??mks_ReadFromEpr_2
   \   00000062   0x2202             MOVS     R2,#+2
   \   00000064   0xF605 0x21B8      ADDW     R1,R5,#+2744
   \   00000068   0xF240 0x40B7      MOVW     R0,#+1207
   \   0000006C   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_2: (+1)
   \   00000070   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000074   0x2800             CMP      R0,#+0
   \   00000076   0xD006             BEQ.N    ??mks_ReadFromEpr_3
   \   00000078   0x2202             MOVS     R2,#+2
   \   0000007A   0xF605 0x21BA      ADDW     R1,R5,#+2746
   \   0000007E   0xF240 0x40B9      MOVW     R0,#+1209
   \   00000082   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_3: (+1)
   \   00000086   0x2204             MOVS     R2,#+4
   \   00000088   0xF505 0x6128      ADD      R1,R5,#+2688
   \   0000008C   0xF240 0x40BB      MOVW     R0,#+1211
   \   00000090   0x.... 0x....      BL       epr_read_data
   \   00000094   0x2204             MOVS     R2,#+4
   \   00000096   0xF605 0x2184      ADDW     R1,R5,#+2692
   \   0000009A   0xF240 0x40BF      MOVW     R0,#+1215
   \   0000009E   0x.... 0x....      BL       epr_read_data
   \   000000A2   0x2204             MOVS     R2,#+4
   \   000000A4   0xF605 0x2188      ADDW     R1,R5,#+2696
   \   000000A8   0xF240 0x40C3      MOVW     R0,#+1219
   \   000000AC   0x.... 0x....      BL       epr_read_data
   \   000000B0   0x2204             MOVS     R2,#+4
   \   000000B2   0xF605 0x218C      ADDW     R1,R5,#+2700
   \   000000B6   0xF240 0x40C7      MOVW     R0,#+1223
   \   000000BA   0x.... 0x....      BL       epr_read_data
   \   000000BE   0x2204             MOVS     R2,#+4
   \   000000C0   0xF505 0x6129      ADD      R1,R5,#+2704
   \   000000C4   0xF240 0x40CB      MOVW     R0,#+1227
   \   000000C8   0x.... 0x....      BL       epr_read_data
   \   000000CC   0x2204             MOVS     R2,#+4
   \   000000CE   0xF605 0x2194      ADDW     R1,R5,#+2708
   \   000000D2   0xF240 0x40CF      MOVW     R0,#+1231
   \   000000D6   0x.... 0x....      BL       epr_read_data
   \   000000DA   0x2204             MOVS     R2,#+4
   \   000000DC   0xF605 0x2198      ADDW     R1,R5,#+2712
   \   000000E0   0xF240 0x40D3      MOVW     R0,#+1235
   \   000000E4   0x.... 0x....      BL       epr_read_data
   \   000000E8   0x2204             MOVS     R2,#+4
   \   000000EA   0xF605 0x219C      ADDW     R1,R5,#+2716
   \   000000EE   0xF240 0x40D7      MOVW     R0,#+1239
   \   000000F2   0x.... 0x....      BL       epr_read_data
   \   000000F6   0x.... 0x....      LDR.W    R6,??DataTable211_2
   \   000000FA   0x2202             MOVS     R2,#+2
   \   000000FC   0x1CB1             ADDS     R1,R6,#+2
   \   000000FE   0xF44F 0x609E      MOV      R0,#+1264
   \   00000102   0x.... 0x....      BL       epr_read_data
   \   00000106   0x2201             MOVS     R2,#+1
   \   00000108   0x1D31             ADDS     R1,R6,#+4
   \   0000010A   0xF240 0x40F2      MOVW     R0,#+1266
   \   0000010E   0x.... 0x....      BL       epr_read_data
   \   00000112   0x2201             MOVS     R2,#+1
   \   00000114   0x1D71             ADDS     R1,R6,#+5
   \   00000116   0xF240 0x40F3      MOVW     R0,#+1267
   \   0000011A   0x.... 0x....      BL       epr_read_data
   \   0000011E   0x2201             MOVS     R2,#+1
   \   00000120   0xF505 0x612C      ADD      R1,R5,#+2752
   \   00000124   0xF240 0x40DF      MOVW     R0,#+1247
   \   00000128   0x.... 0x....      BL       epr_read_data
   \   0000012C   0x2204             MOVS     R2,#+4
   \   0000012E   0xF605 0x21BC      ADDW     R1,R5,#+2748
   \   00000132   0xF240 0x40DB      MOVW     R0,#+1243
   \   00000136   0x.... 0x....      BL       epr_read_data
   \   0000013A   0x.... 0x....      LDR.W    R5,??DataTable211_3
   \   0000013E   0x2201             MOVS     R2,#+1
   \   00000140   0x1CE9             ADDS     R1,R5,#+3
   \   00000142   0xF240 0x40F4      MOVW     R0,#+1268
   \   00000146   0x.... 0x....      BL       epr_read_data
   \   0000014A   0xF995 0x0003      LDRSB    R0,[R5, #+3]
   \   0000014E   0xF884 0x009C      STRB     R0,[R4, #+156]
   \   00000152   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_resumePrint()
   \                     mks_resumePrint: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable207_1
   \   00000006   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000000A   0x28AA             CMP      R0,#+170
   \   0000000C   0xD114             BNE.N    ??mks_resumePrint_0
   \   0000000E   0x20A7             MOVS     R0,#+167
   \   00000010   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   00000014   0xF8D4 0x0A78      LDR      R0,[R4, #+2680]
   \   00000018   0x.... 0x....      BL       mks_preExtrude
   \   0000001C   0xF604 0x2078      ADDW     R0,R4,#+2680
   \   00000020   0x69C1             LDR      R1,[R0, #+28]
   \   00000022   0x6980             LDR      R0,[R0, #+24]
   \   00000024   0x.... 0x....      BL       mks_moveXY
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0x.... 0x....      BL       mks_moveZ
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xF604 0x10D4      ADDW     R0,R4,#+2516
   \   00000034   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \                     ??mks_resumePrint_0: (+1)
   \   00000038   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000003C   0x28AB             CMP      R0,#+171
   \   0000003E   0xD102             BNE.N    ??mks_resumePrint_1
   \   00000040   0x20AC             MOVS     R0,#+172
   \   00000042   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \                     ??mks_resumePrint_1: (+1)
   \   00000046   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_pausePrint()
   \                     mks_pausePrint: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable207_1
   \   0000000A   0xF605 0x246C      ADDW     R4,R5,#+2668
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable211_3
   \   00000012   0x6881             LDR      R1,[R0, #+8]
   \   00000014   0x6161             STR      R1,[R4, #+20]
   \   00000016   0x68C1             LDR      R1,[R0, #+12]
   \   00000018   0x61A1             STR      R1,[R4, #+24]
   \   0000001A   0x6901             LDR      R1,[R0, #+16]
   \   0000001C   0x61E1             STR      R1,[R4, #+28]
   \   0000001E   0x6941             LDR      R1,[R0, #+20]
   \   00000020   0x6221             STR      R1,[R4, #+32]
   \   00000022   0x6981             LDR      R1,[R0, #+24]
   \   00000024   0x6261             STR      R1,[R4, #+36]
   \   00000026   0x69C1             LDR      R1,[R0, #+28]
   \   00000028   0x62A1             STR      R1,[R4, #+40]
   \   0000002A   0x6A01             LDR      R1,[R0, #+32]
   \   0000002C   0x62E1             STR      R1,[R4, #+44]
   \   0000002E   0x6A41             LDR      R1,[R0, #+36]
   \   00000030   0x6321             STR      R1,[R4, #+48]
   \   00000032   0x6EC1             LDR      R1,[R0, #+108]
   \   00000034   0xF885 0x1AC0      STRB     R1,[R5, #+2752]
   \   00000038   0x6DC0             LDR      R0,[R0, #+92]
   \   0000003A   0x6520             STR      R0,[R4, #+80]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable210
   \   00000040   0xF990 0x029E      LDRSB    R0,[R0, #+670]
   \   00000044   0x.... 0x....      BL       __aeabi_i2f
   \   00000048   0x.... 0x....      BL       mks_preExtrude
   \   0000004C   0x68A0             LDR      R0,[R4, #+8]
   \   0000004E   0x.... 0x....      BL       mks_moveZ
   \   00000052   0xF8D5 0x2A6C      LDR      R2,[R5, #+2668]
   \   00000056   0x.... 0x....      LDR.W    R3,??DataTable212  ;; 0xbf800000
   \   0000005A   0x4610             MOV      R0,R2
   \   0000005C   0x4619             MOV      R1,R3
   \   0000005E   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   00000062   0xD008             BEQ.N    ??mks_pausePrint_0
   \   00000064   0x6864             LDR      R4,[R4, #+4]
   \   00000066   0x4620             MOV      R0,R4
   \   00000068   0x.... 0x....      BL       __aeabi_cfcmpeq
   \   0000006C   0xD003             BEQ.N    ??mks_pausePrint_0
   \   0000006E   0x4621             MOV      R1,R4
   \   00000070   0x4610             MOV      R0,R2
   \   00000072   0x.... 0x....      BL       mks_moveXY
   \                     ??mks_pausePrint_0: (+1)
   \   00000076   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   0000007A   0x....             B.N      _Z14mks_WriteToEprv

   \                                 In section .bss, align 4
   \                     filament_loading_time_flg:
   \   00000000                      DS8 1
   \                     filament_loading_completed:
   \   00000001                      DS8 1
   \                     filament_unloading_time_flg:
   \   00000002                      DS8 1
   \                     filament_unloading_completed:
   \   00000003                      DS8 1
   \                     printing_rate_update_flag:
   \   00000004                      DS8 1
   \                     preview_no_display:
   \   00000005                      DS8 1
   \                     loop_start:
   \   00000006                      DS8 1
   \   00000007                      DS8 1
   \   00000008                      DS8 1
   \                     sd_read_error_flg:
   \   00000009                      DS8 1
   \                     sd_read_cnt:
   \   0000000A                      DS8 1
   \                     display_hold:
   \   0000000B                      DS8 1
   \                     display_hold_release:
   \   0000000C                      DS8 1
   \                     wifi_init_flg:
   \   0000000D                      DS8 1
   \                     wifi_refresh_flg:
   \   0000000E                      DS8 1
   \                     cloud_refresh_flg:
   \   0000000F                      DS8 1
   \                     waiting_wifi_time:
   \   00000010                      DS8 1
   \                     beep_flg:
   \   00000011                      DS8 1
   \   __absolute uint8_t volatile has_adjust_speed
   \                     has_adjust_speed:
   \   00000012                      DS8 1
   \   __absolute uint8_t print_finish_start_timer
   \                     print_finish_start_timer:
   \   00000013                      DS8 1
   \   __absolute uint8_t print_finish_close_machine
   \                     print_finish_close_machine:
   \   00000014                      DS8 1
   \   00000015                      DS8 3
   \   00000018                      DS8 4
   \                     z_high_count:
   \   0000001C                      DS8 2
   \   __absolute uint16_t volatile resume_printed_time
   \                     resume_printed_time:
   \   0000001E                      DS8 2
   \   00000020                      DS8 4
   \                     filament_loading_time_cnt:
   \   00000024                      DS8 4
   \                     filament_unloading_time_cnt:
   \   00000028                      DS8 4
   \                     TimeIncrease:
   \   0000002C                      DS8 4
   \                     home_offset:
   \   00000030                      DS8 12
   \                     display_hold_cnt:
   \   0000003C                      DS8 4
   \                     beep_cnt:
   \   00000040                      DS8 4
   \   __absolute uint32_t print_finish_timer_count
   \                     print_finish_timer_count:
   \   00000044                      DS8 4

   \                                 In section .bss, align 1
   \                     filament_heat_completed_load:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     filament_heat_completed_unload:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     g26_debug_flag:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     card:
   \   00000000                      DS8 2496
   \   __absolute DATA_REPRINT_ITMES mksReprint
   \                     mksReprint:
   \   000009C0                      DS8 940
   \                     print_job_timer:
   \   00000D6C                      DS8 16

   \                                 In section .bss, align 4
   \                     command_queue:
   \   00000000                      DS8 384

   \                                 In section .bss, align 4
   \                     injected_commands_P:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     saved_feedrate_percentage:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4

   \                                 In section .bss, align 4
   \                     z_endstop_adj:
   \   00000000                      DS8 4
   \                     delta_endstop_adj:
   \   00000004                      DS8 12

   \                                 In section .bss, align 4
   \                     hotend_offset:
   \   00000000                      DS8 24

   \                                 In section .bss, align 4
   \                     z_values:
   \   00000000                      DS8 576

   \                                 In section .bss, align 4
   \                     home_dir_P:
   \   00000000                      DS8 4
   \                     base_min_pos_P:
   \   00000004                      DS8 12
   \                     base_max_pos_P:
   \   00000010                      DS8 12
   \                     base_home_pos_P:
   \   0000001C                      DS8 12
   \                     max_length_P:
   \   00000028                      DS8 12
   \   00000034                      DS8 4
   \   00000038                      DS8 4

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE18serial_line_buffer:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ19get_serial_commandsvE19serial_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ19get_serial_commandsvE14last_wait_time:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
   \                     _ZZ19get_sdcard_commandsvE14stop_buffering:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     _ZZ19get_sdcard_commandsvE15sd_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ17get_wifi_commandsvE16wifi_line_buffer:
   \   00000000                      DS8 96

   \                                 In section .bss, align 1
   \                     _ZZ17get_wifi_commandsvE17wifi_comment_mode:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \                     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     ??C2:
   \   00000000                      DS8 4
   \   00000004                      DS8 4
   \   00000008                      DS8 4
   \   0000000C                      DS8 4
   \   00000010                      DS8 4
   \   00000014                      DS8 4

   \                                 In section .bss, align 1
   \                     button_disp_pause_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \                     wifi_init_state:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
   \   __absolute uint8_t continue_print_error_flg
   \                     continue_print_error_flg:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
   \   __absolute uint32_t t1
   \                     t1:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute uint32_t t2
   \                     t2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \   __absolute char t12[10]
   \                     t12:
   \   00000000                      DS8 12

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_PrintStatePolling()
   \                     mks_PrintStatePolling: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable207_1
   \   00000008   0xF604 0x2674      ADDW     R6,R4,#+2676
   \   0000000C   0xF604 0x25A0      ADDW     R5,R4,#+2720
   \   00000010   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000014   0x28A9             CMP      R0,#+169
   \   00000016   0xD122             BNE.N    ??mks_PrintStatePolling_0
   \   00000018   0x.... 0x....      BL       _ZN7Planner13blocks_queuedEv
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD107             BNE.N    ??mks_PrintStatePolling_1
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000026   0x2865             CMP      R0,#+101
   \   00000028   0xD302             BCC.N    ??mks_PrintStatePolling_1
   \   0000002A   0x68B0             LDR      R0,[R6, #+8]
   \   0000002C   0x1C40             ADDS     R0,R0,#+1
   \   0000002E   0x60B0             STR      R0,[R6, #+8]
   \                     ??mks_PrintStatePolling_1: (+1)
   \   00000030   0x68B0             LDR      R0,[R6, #+8]
   \   00000032   0x2815             CMP      R0,#+21
   \   00000034   0xDB15             BLT.N    ??mks_PrintStatePolling_2
   \   00000036   0x20AA             MOVS     R0,#+170
   \   00000038   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable210
   \   00000040   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD005             BEQ.N    ??mks_PrintStatePolling_3
   \   00000048   0x2201             MOVS     R2,#+1
   \   0000004A   0x4629             MOV      R1,R5
   \   0000004C   0xF44F 0x6096      MOV      R0,#+1200
   \   00000050   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_3: (+1)
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x60B0             STR      R0,[R6, #+8]
   \   00000058   0x.... 0x....      BL       mks_pausePrint
   \   0000005C   0xE001             B.N      ??mks_PrintStatePolling_2
   \                     ??mks_PrintStatePolling_0: (+1)
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x60B0             STR      R0,[R6, #+8]
   \                     ??mks_PrintStatePolling_2: (+1)
   \   00000062   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000066   0x28AA             CMP      R0,#+170
   \   00000068   0xD13C             BNE.N    ??mks_PrintStatePolling_4
   \   0000006A   0x.... 0x....      LDR.W    R8,??DataTable211_4  ;; 0x38d1b718
   \   0000006E   0x.... 0x....      LDR.W    R7,??DataTable211_3
   \   00000072   0x68F0             LDR      R0,[R6, #+12]
   \   00000074   0x68B9             LDR      R1,[R7, #+8]
   \   00000076   0x.... 0x....      BL       __aeabi_fsub
   \   0000007A   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   0000007E   0x4641             MOV      R1,R8
   \   00000080   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000084   0xD808             BHI.N    ??mks_PrintStatePolling_5
   \   00000086   0x68B8             LDR      R0,[R7, #+8]
   \   00000088   0x60F0             STR      R0,[R6, #+12]
   \   0000008A   0x2204             MOVS     R2,#+4
   \   0000008C   0xF504 0x6128      ADD      R1,R4,#+2688
   \   00000090   0xF240 0x40BB      MOVW     R0,#+1211
   \   00000094   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_5: (+1)
   \   00000098   0x6930             LDR      R0,[R6, #+16]
   \   0000009A   0x68F9             LDR      R1,[R7, #+12]
   \   0000009C   0x.... 0x....      BL       __aeabi_fsub
   \   000000A0   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000000A4   0x4641             MOV      R1,R8
   \   000000A6   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000AA   0xD808             BHI.N    ??mks_PrintStatePolling_6
   \   000000AC   0x68F8             LDR      R0,[R7, #+12]
   \   000000AE   0x6130             STR      R0,[R6, #+16]
   \   000000B0   0x2204             MOVS     R2,#+4
   \   000000B2   0xF604 0x2184      ADDW     R1,R4,#+2692
   \   000000B6   0xF240 0x40BF      MOVW     R0,#+1215
   \   000000BA   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_6: (+1)
   \   000000BE   0x6970             LDR      R0,[R6, #+20]
   \   000000C0   0x6939             LDR      R1,[R7, #+16]
   \   000000C2   0x.... 0x....      BL       __aeabi_fsub
   \   000000C6   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000000CA   0x4641             MOV      R1,R8
   \   000000CC   0x.... 0x....      BL       __aeabi_cfrcmple
   \   000000D0   0xD808             BHI.N    ??mks_PrintStatePolling_4
   \   000000D2   0x6938             LDR      R0,[R7, #+16]
   \   000000D4   0x6170             STR      R0,[R6, #+20]
   \   000000D6   0x2204             MOVS     R2,#+4
   \   000000D8   0xF604 0x2188      ADDW     R1,R4,#+2696
   \   000000DC   0xF240 0x40C3      MOVW     R0,#+1219
   \   000000E0   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_4: (+1)
   \   000000E4   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   000000E8   0x28A8             CMP      R0,#+168
   \   000000EA   0xD126             BNE.N    ??mks_PrintStatePolling_7
   \   000000EC   0x.... 0x....      LDR.W    R0,??DataTable212_1
   \   000000F0   0x7801             LDRB     R1,[R0, #+0]
   \   000000F2   0x2901             CMP      R1,#+1
   \   000000F4   0xD121             BNE.N    ??mks_PrintStatePolling_7
   \   000000F6   0x2100             MOVS     R1,#+0
   \   000000F8   0x7001             STRB     R1,[R0, #+0]
   \   000000FA   0x.... 0x....      LDR.W    R0,??DataTable210
   \   000000FE   0xF990 0x029F      LDRSB    R0,[R0, #+671]
   \   00000102   0x.... 0x....      BL       __aeabi_i2f
   \   00000106   0x.... 0x....      BL       mks_preExtrude
   \   0000010A   0x6A31             LDR      R1,[R6, #+32]
   \   0000010C   0x69F0             LDR      R0,[R6, #+28]
   \   0000010E   0x.... 0x....      BL       mks_moveXY
   \   00000112   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000116   0x28AD             CMP      R0,#+173
   \   00000118   0xD103             BNE.N    ??mks_PrintStatePolling_8
   \   0000011A   0x2000             MOVS     R0,#+0
   \   0000011C   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000120   0xE0C4             B.N      ??mks_PrintStatePolling_9
   \                     ??mks_PrintStatePolling_8: (+1)
   \   00000122   0x2000             MOVS     R0,#+0
   \   00000124   0x.... 0x....      BL       mks_moveZ
   \   00000128   0x.... 0x....      BL       mks_adjust_extrude_speed
   \   0000012C   0x4620             MOV      R0,R4
   \   0000012E   0x.... 0x....      BL       _ZN10CardReader14startFileprintEv
   \   00000132   0xF604 0x506C      ADDW     R0,R4,#+3436
   \   00000136   0x.... 0x....      BL       _ZN9Stopwatch5startEv
   \                     ??mks_PrintStatePolling_7: (+1)
   \   0000013A   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000013E   0x28A7             CMP      R0,#+167
   \   00000140   0xD12C             BNE.N    ??mks_PrintStatePolling_10
   \   00000142   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   00000146   0x2800             CMP      R0,#+0
   \   00000148   0xD103             BNE.N    ??mks_PrintStatePolling_11
   \   0000014A   0x8EA8             LDRH     R0,[R5, #+52]
   \   0000014C   0x1C40             ADDS     R0,R0,#+1
   \   0000014E   0x86A8             STRH     R0,[R5, #+52]
   \   00000150   0xE001             B.N      ??mks_PrintStatePolling_12
   \                     ??mks_PrintStatePolling_11: (+1)
   \   00000152   0x2000             MOVS     R0,#+0
   \   00000154   0x86A8             STRH     R0,[R5, #+52]
   \                     ??mks_PrintStatePolling_12: (+1)
   \   00000156   0x8EA8             LDRH     R0,[R5, #+52]
   \   00000158   0x2815             CMP      R0,#+21
   \   0000015A   0xDB1F             BLT.N    ??mks_PrintStatePolling_10
   \   0000015C   0x2000             MOVS     R0,#+0
   \   0000015E   0x86A8             STRH     R0,[R5, #+52]
   \   00000160   0x20A6             MOVS     R0,#+166
   \   00000162   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   00000166   0x.... 0x....      LDR.W    R8,??DataTable210
   \   0000016A   0xF898 0x019F      LDRB     R0,[R8, #+415]
   \   0000016E   0x2801             CMP      R0,#+1
   \   00000170   0xD007             BEQ.N    ??mks_PrintStatePolling_13
   \   00000172   0x2201             MOVS     R2,#+1
   \   00000174   0x4629             MOV      R1,R5
   \   00000176   0xF44F 0x6096      MOV      R0,#+1200
   \   0000017A   0x.... 0x....      BL       epr_write_data
   \   0000017E   0x.... 0x....      BL       mks_clearFile
   \                     ??mks_PrintStatePolling_13: (+1)
   \   00000182   0xF898 0x00D9      LDRB     R0,[R8, #+217]
   \   00000186   0x2801             CMP      R0,#+1
   \   00000188   0xD108             BNE.N    ??mks_PrintStatePolling_10
   \   0000018A   0x.... 0x....      LDR.W    R0,??DataTable213
   \   0000018E   0x7800             LDRB     R0,[R0, #+0]
   \   00000190   0x2801             CMP      R0,#+1
   \   00000192   0xD103             BNE.N    ??mks_PrintStatePolling_10
   \   00000194   0x2001             MOVS     R0,#+1
   \   00000196   0x.... 0x....      LDR.W    R1,??DataTable214
   \   0000019A   0x74C8             STRB     R0,[R1, #+19]
   \                     ??mks_PrintStatePolling_10: (+1)
   \   0000019C   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   000001A0   0x28AD             CMP      R0,#+173
   \   000001A2   0xD136             BNE.N    ??mks_PrintStatePolling_14
   \   000001A4   0x20A6             MOVS     R0,#+166
   \   000001A6   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   000001AA   0x.... 0x....      LDR.W    R8,??DataTable210
   \   000001AE   0xF898 0x019F      LDRB     R0,[R8, #+415]
   \   000001B2   0x2801             CMP      R0,#+1
   \   000001B4   0xD005             BEQ.N    ??mks_PrintStatePolling_15
   \   000001B6   0x2201             MOVS     R2,#+1
   \   000001B8   0x4629             MOV      R1,R5
   \   000001BA   0xF44F 0x6096      MOV      R0,#+1200
   \   000001BE   0x.... 0x....      BL       epr_write_data
   \                     ??mks_PrintStatePolling_15: (+1)
   \   000001C2   0x.... 0x....      BL       _Z19clear_command_queuev
   \   000001C6   0x.... 0x....      BL       _Z17quickstop_stepperv
   \   000001CA   0x.... 0x....      LDR.W    R7,??DataTable211_3
   \   000001CE   0x6A38             LDR      R0,[R7, #+32]
   \   000001D0   0x6270             STR      R0,[R6, #+36]
   \   000001D2   0xF8D4 0x0A74      LDR      R0,[R4, #+2676]
   \   000001D6   0x.... 0x....      BL       mks_moveZ
   \   000001DA   0x.... 0x....      LDR.W    R0,??DataTable213_1
   \   000001DE   0x.... 0x....      BL       _Z7mks_G28Pc
   \   000001E2   0xF604 0x506C      ADDW     R0,R4,#+3436
   \   000001E6   0x.... 0x....      BL       _ZN9Stopwatch4stopEv
   \   000001EA   0x.... 0x....      BL       _ZN11Temperature19disable_all_heatersEv
   \   000001EE   0x2000             MOVS     R0,#+0
   \   000001F0   0x.... 0x....      LDR.W    R1,??DataTable215  ;; 0x40000440
   \   000001F4   0xE003             B.N      ??mks_PrintStatePolling_16
   \                     ??mks_PrintStatePolling_17: (+1)
   \   000001F6   0x2000             MOVS     R0,#+0
   \   000001F8   0x66F8             STR      R0,[R7, #+108]
   \   000001FA   0x6008             STR      R0,[R1, #+0]
   \   000001FC   0x2001             MOVS     R0,#+1
   \                     ??mks_PrintStatePolling_16: (+1)
   \   000001FE   0x2800             CMP      R0,#+0
   \   00000200   0xD0F9             BEQ.N    ??mks_PrintStatePolling_17
   \   00000202   0x2000             MOVS     R0,#+0
   \   00000204   0x7138             STRB     R0,[R7, #+4]
   \   00000206   0xF898 0x019F      LDRB     R0,[R8, #+415]
   \   0000020A   0x2801             CMP      R0,#+1
   \   0000020C   0xD001             BEQ.N    ??mks_PrintStatePolling_14
   \   0000020E   0x.... 0x....      BL       mks_clearFile
   \                     ??mks_PrintStatePolling_14: (+1)
   \   00000212   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000216   0x28AC             CMP      R0,#+172
   \   00000218   0xD119             BNE.N    ??mks_PrintStatePolling_18
   \   0000021A   0x.... 0x....      LDR.W    R0,??DataTable207
   \   0000021E   0xF9B0 0x0058      LDRSH    R0,[R0, #+88]
   \   00000222   0x2801             CMP      R0,#+1
   \   00000224   0xD005             BEQ.N    ??mks_PrintStatePolling_19
   \   00000226   0x2802             CMP      R0,#+2
   \   00000228   0xD00F             BEQ.N    ??mks_PrintStatePolling_20
   \   0000022A   0x2804             CMP      R0,#+4
   \   0000022C   0xD001             BEQ.N    ??mks_PrintStatePolling_19
   \   0000022E   0x2808             CMP      R0,#+8
   \   00000230   0xD10D             BNE.N    ??mks_PrintStatePolling_18
   \                     ??mks_PrintStatePolling_19: (+1)
   \   00000232   0xF994 0x0D68      LDRSB    R0,[R4, #+3432]
   \   00000236   0x2801             CMP      R0,#+1
   \   00000238   0xD102             BNE.N    ??mks_PrintStatePolling_21
   \   0000023A   0x.... 0x....      BL       mks_contiuePrintPause
   \   0000023E   0xE006             B.N      ??mks_PrintStatePolling_18
   \                     ??mks_PrintStatePolling_21: (+1)
   \   00000240   0x2802             CMP      R0,#+2
   \   00000242   0xD104             BNE.N    ??mks_PrintStatePolling_18
   \   00000244   0x.... 0x....      BL       mks_contiuePrintPwdwn
   \   00000248   0xE001             B.N      ??mks_PrintStatePolling_18
   \                     ??mks_PrintStatePolling_20: (+1)
   \   0000024A   0x.... 0x....      BL       mks_contiuePrintDelta
   \                     ??mks_PrintStatePolling_18: (+1)
   \   0000024E   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000252   0x28A7             CMP      R0,#+167
   \   00000254   0xD10D             BNE.N    ??mks_PrintStatePolling_22
   \   00000256   0xF894 0x09B8      LDRB     R0,[R4, #+2488]
   \   0000025A   0x7D29             LDRB     R1,[R5, #+20]
   \   0000025C   0x4208             TST      R0,R1
   \   0000025E   0xD008             BEQ.N    ??mks_PrintStatePolling_22
   \   00000260   0x4620             MOV      R0,R4
   \   00000262   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000266   0x2865             CMP      R0,#+101
   \   00000268   0xD301             BCC.N    ??mks_PrintStatePolling_23
   \   0000026A   0x.... 0x....      BL       mks_WriteToFile
   \                     ??mks_PrintStatePolling_23: (+1)
   \   0000026E   0x2000             MOVS     R0,#+0
   \   00000270   0x7528             STRB     R0,[R5, #+20]
   \                     ??mks_PrintStatePolling_22: (+1)
   \   00000272   0x.... 0x....      LDR.W    R5,??DataTable214
   \   00000276   0x7CA8             LDRB     R0,[R5, #+18]
   \   00000278   0x2801             CMP      R0,#+1
   \   0000027A   0xD108             BNE.N    ??mks_PrintStatePolling_24
   \   0000027C   0x8BE8             LDRH     R0,[R5, #+30]
   \   0000027E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000282   0x4288             CMP      R0,R1
   \   00000284   0xDB03             BLT.N    ??mks_PrintStatePolling_24
   \   00000286   0x2000             MOVS     R0,#+0
   \   00000288   0x83E8             STRH     R0,[R5, #+30]
   \   0000028A   0x.... 0x....      BL       mks_resume_extrude_speed

  	if(mksReprint.mks_printer_state == MKS_IDLE && print_finish_close_machine == true)
  	                                                                          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",823  Warning[Pa118]: 
          mixing boolean and non-boolean types in a comparison results in the
          boolean being promoted
   \                     ??mks_PrintStatePolling_24: (+1)
   \   0000028E   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000292   0x28A6             CMP      R0,#+166
   \   00000294   0xD10A             BNE.N    ??mks_PrintStatePolling_9
   \   00000296   0x7D28             LDRB     R0,[R5, #+20]
   \   00000298   0x2801             CMP      R0,#+1
   \   0000029A   0xD107             BNE.N    ??mks_PrintStatePolling_9
   \   0000029C   0x2000             MOVS     R0,#+0
   \   0000029E   0x7528             STRB     R0,[R5, #+20]
   \   000002A0   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   000002A4   0xE8BD 0x41F0      POP      {R4-R8,LR}
   \   000002A8   0x.... 0x....      B.W      _Z21Close_machine_displayv
   \                     ??mks_PrintStatePolling_9: (+1)
   \   000002AC   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setTemperature()
   \                     _Z18mks_setTemperaturev: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable207_1
   \   0000000A   0xF604 0x25B6      ADDW     R5,R4,#+2742
   \   0000000E   0x.... 0x....      LDR.W    R6,??DataTable207
   \   00000012   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD01E             BEQ.N    ??mks_setTemperature_0
   \   0000001A   0x88A8             LDRH     R0,[R5, #+4]
   \   0000001C   0x2800             CMP      R0,#+0
   \   0000001E   0xD01B             BEQ.N    ??mks_setTemperature_0
   \   00000020   0x2260             MOVS     R2,#+96
   \   00000022   0x2100             MOVS     R1,#+0
   \   00000024   0xF604 0x20D6      ADDW     R0,R4,#+2774
   \   00000028   0x.... 0x....      BL       memset
   \   0000002C   0xF604 0x27D6      ADDW     R7,R4,#+2774
   \   00000030   0x2207             MOVS     R2,#+7
   \   00000032   0x.... 0x....      ADR.W    R1,`?<Constant "M140 S">`
   \   00000036   0x4638             MOV      R0,R7
   \   00000038   0x.... 0x....      BL       __aeabi_memcpy
   \   0000003C   0x88AA             LDRH     R2,[R5, #+4]
   \   0000003E   0x....             ADR.N    R1,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
   \   00000040   0xA800             ADD      R0,SP,#+0
   \   00000042   0x.... 0x....      BL       sprintf
   \   00000046   0xA900             ADD      R1,SP,#+0
   \   00000048   0x4638             MOV      R0,R7
   \   0000004A   0x.... 0x....      BL       strcat
   \   0000004E   0x4638             MOV      R0,R7
   \   00000050   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000054   0x.... 0x....      BL       _Z10gcode_M140v
   \                     ??mks_setTemperature_0: (+1)
   \   00000058   0xF8B4 0x0AB6      LDRH     R0,[R4, #+2742]
   \   0000005C   0x2800             CMP      R0,#+0
   \   0000005E   0xD03E             BEQ.N    ??mks_setTemperature_1
   \   00000060   0xF604 0x27D6      ADDW     R7,R4,#+2774
   \   00000064   0xF604 0x28D6      ADDW     R8,R4,#+2774
   \   00000068   0xF04F 0x090A      MOV      R9,#+10
   \   0000006C   0x.... 0x....      ADR.W    R10,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
   \   00000070   0xF896 0x00F7      LDRB     R0,[R6, #+247]
   \   00000074   0x2802             CMP      R0,#+2
   \   00000076   0xD118             BNE.N    ??mks_setTemperature_2
   \   00000078   0x2260             MOVS     R2,#+96
   \   0000007A   0x2100             MOVS     R1,#+0
   \   0000007C   0x4640             MOV      R0,R8
   \   0000007E   0x.... 0x....      BL       memset
   \   00000082   0x464A             MOV      R2,R9
   \   00000084   0x.... 0x....      ADR.W    R1,`?<Constant "M104 T1 S">`
   \   00000088   0x4638             MOV      R0,R7
   \   0000008A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000008E   0x886A             LDRH     R2,[R5, #+2]
   \   00000090   0x4651             MOV      R1,R10
   \   00000092   0xA800             ADD      R0,SP,#+0
   \   00000094   0x.... 0x....      BL       sprintf
   \   00000098   0xA900             ADD      R1,SP,#+0
   \   0000009A   0x4638             MOV      R0,R7
   \   0000009C   0x.... 0x....      BL       strcat
   \   000000A0   0x4638             MOV      R0,R7
   \   000000A2   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000A6   0x.... 0x....      BL       _Z10gcode_M104v
   \                     ??mks_setTemperature_2: (+1)
   \   000000AA   0x2260             MOVS     R2,#+96
   \   000000AC   0x2100             MOVS     R1,#+0
   \   000000AE   0x4640             MOV      R0,R8
   \   000000B0   0x.... 0x....      BL       memset
   \   000000B4   0x464A             MOV      R2,R9
   \   000000B6   0x.... 0x....      ADR.W    R1,`?<Constant "M109 T0 S">`
   \   000000BA   0x4638             MOV      R0,R7
   \   000000BC   0x.... 0x....      BL       __aeabi_memcpy
   \   000000C0   0xF8B4 0x2AB6      LDRH     R2,[R4, #+2742]
   \   000000C4   0x4651             MOV      R1,R10
   \   000000C6   0xA800             ADD      R0,SP,#+0
   \   000000C8   0x.... 0x....      BL       sprintf
   \   000000CC   0xA900             ADD      R1,SP,#+0
   \   000000CE   0x4638             MOV      R0,R7
   \   000000D0   0x.... 0x....      BL       strcat
   \   000000D4   0x4638             MOV      R0,R7
   \   000000D6   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000DA   0x.... 0x....      BL       _Z10gcode_M109v
   \                     ??mks_setTemperature_1: (+1)
   \   000000DE   0xF896 0x00F7      LDRB     R0,[R6, #+247]
   \   000000E2   0x2802             CMP      R0,#+2
   \   000000E4   0xD11E             BNE.N    ??mks_setTemperature_3
   \   000000E6   0x8868             LDRH     R0,[R5, #+2]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD01B             BEQ.N    ??mks_setTemperature_3
   \   000000EC   0x2260             MOVS     R2,#+96
   \   000000EE   0x2100             MOVS     R1,#+0
   \   000000F0   0xF604 0x20D6      ADDW     R0,R4,#+2774
   \   000000F4   0x.... 0x....      BL       memset
   \   000000F8   0xF604 0x27D6      ADDW     R7,R4,#+2774
   \   000000FC   0x220A             MOVS     R2,#+10
   \   000000FE   0x.... 0x....      ADR.W    R1,`?<Constant "M109 T1 S">`
   \   00000102   0x4638             MOV      R0,R7
   \   00000104   0x.... 0x....      BL       __aeabi_memcpy
   \   00000108   0x886A             LDRH     R2,[R5, #+2]
   \   0000010A   0x....             ADR.N    R1,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
   \   0000010C   0xA800             ADD      R0,SP,#+0
   \   0000010E   0x.... 0x....      BL       sprintf
   \   00000112   0xA900             ADD      R1,SP,#+0
   \   00000114   0x4638             MOV      R0,R7
   \   00000116   0x.... 0x....      BL       strcat
   \   0000011A   0x4638             MOV      R0,R7
   \   0000011C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000120   0x.... 0x....      BL       _Z10gcode_M109v
   \                     ??mks_setTemperature_3: (+1)
   \   00000124   0xF896 0x0036      LDRB     R0,[R6, #+54]
   \   00000128   0x2800             CMP      R0,#+0
   \   0000012A   0xD01E             BEQ.N    ??mks_setTemperature_4
   \   0000012C   0x88A8             LDRH     R0,[R5, #+4]
   \   0000012E   0x2800             CMP      R0,#+0
   \   00000130   0xD01B             BEQ.N    ??mks_setTemperature_4
   \   00000132   0x2260             MOVS     R2,#+96
   \   00000134   0x2100             MOVS     R1,#+0
   \   00000136   0xF604 0x20D6      ADDW     R0,R4,#+2774
   \   0000013A   0x.... 0x....      BL       memset
   \   0000013E   0xF604 0x27D6      ADDW     R7,R4,#+2774
   \   00000142   0x2207             MOVS     R2,#+7
   \   00000144   0x.... 0x....      ADR.W    R1,`?<Constant "M190 S">`
   \   00000148   0x4638             MOV      R0,R7
   \   0000014A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000014E   0x88AA             LDRH     R2,[R5, #+4]
   \   00000150   0x....             ADR.N    R1,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
   \   00000152   0xA800             ADD      R0,SP,#+0
   \   00000154   0x.... 0x....      BL       sprintf
   \   00000158   0xA900             ADD      R1,SP,#+0
   \   0000015A   0x4638             MOV      R0,R7
   \   0000015C   0x.... 0x....      BL       strcat
   \   00000160   0x4638             MOV      R0,R7
   \   00000162   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000166   0x.... 0x....      BL       _Z10gcode_M190v
   \                     ??mks_setTemperature_4: (+1)
   \   0000016A   0xB006             ADD      SP,SP,#+24
   \   0000016C   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setPositionZ()
   \                     mks_setPositionZ: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable207_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF604 0x20D6      ADDW     R0,R4,#+2774
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF604 0x25D6      ADDW     R5,R4,#+2774
   \   00000018   0x2206             MOVS     R2,#+6
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G92 Z">`
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0xF8D4 0x0A88      LDR      R0,[R4, #+2696]
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4602             MOV      R2,R0
   \   00000038   0x460B             MOV      R3,R1
   \   0000003A   0x....             ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       sprintf
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       strcat
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000050   0x.... 0x....      BL       _Z9gcode_G92v
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable211_3
   \   0000005A   0x64C8             STR      R0,[R1, #+76]
   \   0000005C   0xB005             ADD      SP,SP,#+20
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ResetPositionZ(float)
   \                     _Z18mks_ResetPositionZf: (+1)
   \   00000000   0xB530             PUSH     {R4,R5,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x.... 0x....      LDR.W    R5,??DataTable207_1
   \   0000000A   0x2260             MOVS     R2,#+96
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF605 0x20D6      ADDW     R0,R5,#+2774
   \   00000012   0x.... 0x....      BL       memset
   \   00000016   0xF605 0x25D6      ADDW     R5,R5,#+2774
   \   0000001A   0x2206             MOVS     R2,#+6
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant "G92 Z">`
   \   00000020   0x4628             MOV      R0,R5
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       memset
   \   00000030   0x4620             MOV      R0,R4
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4602             MOV      R2,R0
   \   00000038   0x460B             MOV      R3,R1
   \   0000003A   0x....             ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003C   0xA800             ADD      R0,SP,#+0
   \   0000003E   0x.... 0x....      BL       sprintf
   \   00000042   0xA900             ADD      R1,SP,#+0
   \   00000044   0x4628             MOV      R0,R5
   \   00000046   0x.... 0x....      BL       strcat
   \   0000004A   0x4628             MOV      R0,R5
   \   0000004C   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000050   0x.... 0x....      BL       _Z9gcode_G92v
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      LDR.W    R1,??DataTable211_3
   \   0000005A   0x64C8             STR      R0,[R1, #+76]
   \   0000005C   0xB005             ADD      SP,SP,#+20
   \   0000005E   0xBD30             POP      {R4,R5,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_setFeedrate()
   \                     _Z15mks_setFeedratev: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable207_1
   \   00000002   0xF8D0 0x0ABC      LDR      R0,[R0, #+2748]
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable211_3
   \   0000000A   0x65C8             STR      R0,[R1, #+92]
   \   0000000C   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_preExtrude(float)
   \                     mks_preExtrude: (+1)
   \   00000000   0xE92D 0x43F0      PUSH     {R4-R9,LR}
   \   00000004   0xB085             SUB      SP,SP,#+20
   \   00000006   0x4681             MOV      R9,R0
   \   00000008   0x.... 0x....      LDR.W    R4,??DataTable215_2
   \   0000000C   0x2001             MOVS     R0,#+1
   \   0000000E   0x7160             STRB     R0,[R4, #+5]
   \   00000010   0x....             LDR.N    R5,??DataTable207_1
   \   00000012   0xF605 0x28D6      ADDW     R8,R5,#+2774
   \   00000016   0x2260             MOVS     R2,#+96
   \   00000018   0x2100             MOVS     R1,#+0
   \   0000001A   0x4640             MOV      R0,R8
   \   0000001C   0x.... 0x....      BL       memset
   \   00000020   0xF605 0x26D6      ADDW     R6,R5,#+2774
   \   00000024   0x2205             MOVS     R2,#+5
   \   00000026   0x.... 0x....      ADR.W    R1,`?<Constant "G1 E">`
   \   0000002A   0x4630             MOV      R0,R6
   \   0000002C   0x.... 0x....      BL       __aeabi_memcpy
   \   00000030   0x2214             MOVS     R2,#+20
   \   00000032   0x2100             MOVS     R1,#+0
   \   00000034   0xA800             ADD      R0,SP,#+0
   \   00000036   0x.... 0x....      BL       memset
   \   0000003A   0x....             ADR.N    R7,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
   \   0000003C   0x4648             MOV      R0,R9
   \   0000003E   0x.... 0x....      BL       __aeabi_f2d
   \   00000042   0x4602             MOV      R2,R0
   \   00000044   0x460B             MOV      R3,R1
   \   00000046   0x4639             MOV      R1,R7
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       sprintf
   \   0000004E   0xA900             ADD      R1,SP,#+0
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       strcat
   \   00000056   0x4630             MOV      R0,R6
   \   00000058   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000005C   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000060   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0x7160             STRB     R0,[R4, #+5]
   \   00000068   0x2260             MOVS     R2,#+96
   \   0000006A   0x4601             MOV      R1,R0
   \   0000006C   0x4640             MOV      R0,R8
   \   0000006E   0x.... 0x....      BL       memset
   \   00000072   0x2206             MOVS     R2,#+6
   \   00000074   0x.... 0x....      ADR.W    R1,`?<Constant "G92 E">`
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0x.... 0x....      BL       __aeabi_memcpy
   \   0000007E   0x2214             MOVS     R2,#+20
   \   00000080   0x2100             MOVS     R1,#+0
   \   00000082   0xA800             ADD      R0,SP,#+0
   \   00000084   0x.... 0x....      BL       memset
   \   00000088   0xF8D5 0x0A9C      LDR      R0,[R5, #+2716]
   \   0000008C   0x.... 0x....      BL       __aeabi_f2d
   \   00000090   0x4602             MOV      R2,R0
   \   00000092   0x460B             MOV      R3,R1
   \   00000094   0x4639             MOV      R1,R7
   \   00000096   0xA800             ADD      R0,SP,#+0
   \   00000098   0x.... 0x....      BL       sprintf
   \   0000009C   0xA900             ADD      R1,SP,#+0
   \   0000009E   0x4630             MOV      R0,R6
   \   000000A0   0x.... 0x....      BL       strcat
   \   000000A4   0x4630             MOV      R0,R6
   \   000000A6   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000AA   0x.... 0x....      BL       _Z9gcode_G92v
   \   000000AE   0xB005             ADD      SP,SP,#+20
   \   000000B0   0xE8BD 0x83F0      POP      {R4-R9,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveXY(float, float)
   \                     mks_moveXY: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x....             LDR.N    R6,??DataTable207_1
   \   0000000A   0x2260             MOVS     R2,#+96
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF606 0x20D6      ADDW     R0,R6,#+2774
   \   00000012   0x.... 0x....      BL       memset
   \   00000016   0xF606 0x26D6      ADDW     R6,R6,#+2774
   \   0000001A   0x2205             MOVS     R2,#+5
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant "G1 X">`
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA800             ADD      R0,SP,#+0
   \   0000002C   0x.... 0x....      BL       memset
   \   00000030   0x....             ADR.N    R7,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
   \   00000032   0x4628             MOV      R0,R5
   \   00000034   0x.... 0x....      BL       __aeabi_f2d
   \   00000038   0x4602             MOV      R2,R0
   \   0000003A   0x460B             MOV      R3,R1
   \   0000003C   0x4639             MOV      R1,R7
   \   0000003E   0xA800             ADD      R0,SP,#+0
   \   00000040   0x.... 0x....      BL       sprintf
   \   00000044   0xA900             ADD      R1,SP,#+0
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       strcat
   \   0000004C   0x....             ADR.N    R1,??DataTable208  ;; 0x20, 0x59, 0x00, 0x00
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       strcat
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      BL       memset
   \   0000005E   0x4620             MOV      R0,R4
   \   00000060   0x.... 0x....      BL       __aeabi_f2d
   \   00000064   0x4602             MOV      R2,R0
   \   00000066   0x460B             MOV      R3,R1
   \   00000068   0x4639             MOV      R1,R7
   \   0000006A   0xA800             ADD      R0,SP,#+0
   \   0000006C   0x.... 0x....      BL       sprintf
   \   00000070   0xA900             ADD      R1,SP,#+0
   \   00000072   0x4630             MOV      R0,R6
   \   00000074   0x.... 0x....      BL       strcat
   \   00000078   0x4630             MOV      R0,R6
   \   0000007A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000007E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000082   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000086   0xB005             ADD      SP,SP,#+20
   \   00000088   0xBDF0             POP      {R4-R7,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveZ(float)
   \                     mks_moveZ: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x....             LDR.N    R5,??DataTable207_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x20D6      ADDW     R0,R5,#+2774
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF605 0x26D6      ADDW     R6,R5,#+2774
   \   00000018   0x2205             MOVS     R2,#+5
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA800             ADD      R0,SP,#+0
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0xF8D5 0x0A98      LDR      R0,[R5, #+2712]
   \   00000032   0x4621             MOV      R1,R4
   \   00000034   0x.... 0x....      BL       __aeabi_fadd
   \   00000038   0x.... 0x....      BL       __aeabi_f2d
   \   0000003C   0x4602             MOV      R2,R0
   \   0000003E   0x460B             MOV      R3,R1
   \   00000040   0x....             ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       sprintf
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       strcat
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000056   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000005E   0xB006             ADD      SP,SP,#+24
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_moveZ_relative(float)
   \                     _Z18mks_moveZ_relativef: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB086             SUB      SP,SP,#+24
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x.... 0x....      LDR.W    R4,??DataTable215_2
   \   0000000A   0x2001             MOVS     R0,#+1
   \   0000000C   0x7160             STRB     R0,[R4, #+5]
   \   0000000E   0x....             LDR.N    R6,??DataTable207_1
   \   00000010   0x2260             MOVS     R2,#+96
   \   00000012   0x2100             MOVS     R1,#+0
   \   00000014   0xF606 0x20D6      ADDW     R0,R6,#+2774
   \   00000018   0x.... 0x....      BL       memset
   \   0000001C   0xF606 0x26D6      ADDW     R6,R6,#+2774
   \   00000020   0x2205             MOVS     R2,#+5
   \   00000022   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   00000026   0x4630             MOV      R0,R6
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy
   \   0000002C   0x2214             MOVS     R2,#+20
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0xA800             ADD      R0,SP,#+0
   \   00000032   0x.... 0x....      BL       memset
   \   00000036   0x4628             MOV      R0,R5
   \   00000038   0x.... 0x....      BL       __aeabi_f2d
   \   0000003C   0x4602             MOV      R2,R0
   \   0000003E   0x460B             MOV      R3,R1
   \   00000040   0x....             ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
   \   00000042   0xA800             ADD      R0,SP,#+0
   \   00000044   0x.... 0x....      BL       sprintf
   \   00000048   0xA900             ADD      R1,SP,#+0
   \   0000004A   0x4630             MOV      R0,R6
   \   0000004C   0x.... 0x....      BL       strcat
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000056   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   0000005A   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x7160             STRB     R0,[R4, #+5]
   \   00000062   0xB006             ADD      SP,SP,#+24
   \   00000064   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_G28(char *)
   \                     _Z7mks_G28Pc: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable207_1
   \   00000006   0x2260             MOVS     R2,#+96
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF605 0x20D6      ADDW     R0,R5,#+2774
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0xF605 0x25D6      ADDW     R5,R5,#+2774
   \   00000016   0x4621             MOV      R1,R4
   \   00000018   0x4628             MOV      R0,R5
   \   0000001A   0x.... 0x....      BL       strcpy
   \   0000001E   0x4628             MOV      R0,R5
   \   00000020   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0x.... 0x....      BL       _Z9gcode_G28b
   \   0000002A   0x....             LDR.N    R4,??DataTable207
   \   0000002C   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   00000030   0x213E             MOVS     R1,#+62
   \   00000032   0x4208             TST      R0,R1
   \   00000034   0xD018             BEQ.N    ??mks_G28_0
   \   00000036   0x2810             CMP      R0,#+16
   \   00000038   0xD016             BEQ.N    ??mks_G28_0
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x.... 0x....      BL       _Z24set_bed_leveling_enabledb
   \   00000040   0xF9B4 0x0058      LDRSH    R0,[R4, #+88]
   \   00000044   0x2802             CMP      R0,#+2
   \   00000046   0xD00F             BEQ.N    ??mks_G28_0
   \   00000048   0xF894 0x0040      LDRB     R0,[R4, #+64]
   \   0000004C   0x06C0             LSLS     R0,R0,#+27
   \   0000004E   0xD50B             BPL.N    ??mks_G28_0
   \   00000050   0x205A             MOVS     R0,#+90
   \   00000052   0x.... 0x....      BL       _ZN11GCodeParser4seenEc
   \   00000056   0x2800             CMP      R0,#+0
   \   00000058   0xD006             BEQ.N    ??mks_G28_0
   \   0000005A   0x.... 0x....      BL       _ZN11GCodeParser18value_linear_unitsEv
   \   0000005E   0x2101             MOVS     R1,#+1
   \   00000060   0xE8BD 0x4034      POP      {R2,R4,R5,LR}
   \   00000064   0x.... 0x....      B.W      _Z17set_z_fade_heightfb
   \                     ??mks_G28_0: (+1)
   \   00000068   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_leveling_moveZ(float)
   \                     _Z18mks_leveling_moveZf: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x....             LDR.N    R5,??DataTable207_1
   \   00000008   0x2260             MOVS     R2,#+96
   \   0000000A   0x2100             MOVS     R1,#+0
   \   0000000C   0xF605 0x20D6      ADDW     R0,R5,#+2774
   \   00000010   0x.... 0x....      BL       memset
   \   00000014   0xF605 0x26D6      ADDW     R6,R5,#+2774
   \   00000018   0x2205             MOVS     R2,#+5
   \   0000001A   0x.... 0x....      ADR.W    R1,`?<Constant "G1 Z">`
   \   0000001E   0x4630             MOV      R0,R6
   \   00000020   0x.... 0x....      BL       __aeabi_memcpy
   \   00000024   0x2214             MOVS     R2,#+20
   \   00000026   0x2100             MOVS     R1,#+0
   \   00000028   0xA802             ADD      R0,SP,#+8
   \   0000002A   0x.... 0x....      BL       memset
   \   0000002E   0x.... 0x....      LDR.W    R0,??DataTable219_1
   \   00000032   0x6881             LDR      R1,[R0, #+8]
   \   00000034   0x.... 0x....      LDR.W    R0,??DataTable221  ;; 0x42700000
   \   00000038   0x.... 0x....      BL       __aeabi_fmul
   \   0000003C   0x.... 0x....      BL       __aeabi_f2d
   \   00000040   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   00000044   0xF8D5 0x0A98      LDR      R0,[R5, #+2712]
   \   00000048   0x4621             MOV      R1,R4
   \   0000004A   0x.... 0x....      BL       __aeabi_fadd
   \   0000004E   0x.... 0x....      BL       __aeabi_f2d
   \   00000052   0x4602             MOV      R2,R0
   \   00000054   0x460B             MOV      R3,R1
   \   00000056   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f F%.3f">`
   \   0000005A   0xA802             ADD      R0,SP,#+8
   \   0000005C   0x.... 0x....      BL       sprintf
   \   00000060   0xA902             ADD      R1,SP,#+8
   \   00000062   0x4630             MOV      R0,R6
   \   00000064   0x.... 0x....      BL       strcat
   \   00000068   0x4630             MOV      R0,R6
   \   0000006A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000006E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000072   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000076   0xB008             ADD      SP,SP,#+32
   \   00000078   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_leveling_moveXY(float, float)
   \                     _Z19mks_leveling_moveXYff: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x4605             MOV      R5,R0
   \   00000006   0x460C             MOV      R4,R1
   \   00000008   0x....             LDR.N    R6,??DataTable207_1
   \   0000000A   0x2260             MOVS     R2,#+96
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0xF606 0x20D6      ADDW     R0,R6,#+2774
   \   00000012   0x.... 0x....      BL       memset
   \   00000016   0xF606 0x26D6      ADDW     R6,R6,#+2774
   \   0000001A   0x2205             MOVS     R2,#+5
   \   0000001C   0x.... 0x....      ADR.W    R1,`?<Constant "G1 X">`
   \   00000020   0x4630             MOV      R0,R6
   \   00000022   0x.... 0x....      BL       __aeabi_memcpy
   \   00000026   0x2214             MOVS     R2,#+20
   \   00000028   0x2100             MOVS     R1,#+0
   \   0000002A   0xA802             ADD      R0,SP,#+8
   \   0000002C   0x.... 0x....      BL       memset
   \   00000030   0x4628             MOV      R0,R5
   \   00000032   0x.... 0x....      BL       __aeabi_f2d
   \   00000036   0x4602             MOV      R2,R0
   \   00000038   0x460B             MOV      R3,R1
   \   0000003A   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f">`
   \   0000003E   0xA802             ADD      R0,SP,#+8
   \   00000040   0x.... 0x....      BL       sprintf
   \   00000044   0xA902             ADD      R1,SP,#+8
   \   00000046   0x4630             MOV      R0,R6
   \   00000048   0x.... 0x....      BL       strcat
   \   0000004C   0x....             ADR.N    R1,??DataTable208  ;; 0x20, 0x59, 0x00, 0x00
   \   0000004E   0x4630             MOV      R0,R6
   \   00000050   0x.... 0x....      BL       strcat
   \   00000054   0x2214             MOVS     R2,#+20
   \   00000056   0x2100             MOVS     R1,#+0
   \   00000058   0xA802             ADD      R0,SP,#+8
   \   0000005A   0x.... 0x....      BL       memset
   \   0000005E   0x.... 0x....      LDR.W    R0,??DataTable223
   \   00000062   0x6A40             LDR      R0,[R0, #+36]
   \   00000064   0x.... 0x....      BL       __aeabi_f2d
   \   00000068   0xE9CD 0x0100      STRD     R0,R1,[SP, #+0]
   \   0000006C   0x4620             MOV      R0,R4
   \   0000006E   0x.... 0x....      BL       __aeabi_f2d
   \   00000072   0x4602             MOV      R2,R0
   \   00000074   0x460B             MOV      R3,R1
   \   00000076   0x.... 0x....      ADR.W    R1,`?<Constant "%.3f F%.3f">`
   \   0000007A   0xA802             ADD      R0,SP,#+8
   \   0000007C   0x.... 0x....      BL       sprintf
   \   00000080   0xA902             ADD      R1,SP,#+8
   \   00000082   0x4630             MOV      R0,R6
   \   00000084   0x.... 0x....      BL       strcat
   \   00000088   0x4630             MOV      R0,R6
   \   0000008A   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   0000008E   0x.... 0x....      BL       _Z11gcode_G0_G1v
   \   00000092   0x.... 0x....      BL       _ZN7Stepper11synchronizeEv
   \   00000096   0xB008             ADD      SP,SP,#+32
   \   00000098   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
   \                     mks_manual_leveling: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1

      char string[20];
           ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1100  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000006   0x.... 0x....      LDR.W    R0,??DataTable219_2
   \   0000000A   0x7801             LDRB     R1,[R0, #+0]
   \   0000000C   0x2901             CMP      R1,#+1
   \   0000000E   0xD104             BNE.N    ??mks_manual_leveling_0
   \   00000010   0x2100             MOVS     R1,#+0
   \   00000012   0x7001             STRB     R1,[R0, #+0]
   \   00000014   0x....             ADR.N    R0,??DataTable211_1  ;; "G28"
   \   00000016   0x.... 0x....      BL       _Z7mks_G28Pc
   \                     ??mks_manual_leveling_0: (+1)
   \   0000001A   0x....             LDR.N    R0,??DataTable211_3
   \   0000001C   0x6900             LDR      R0,[R0, #+16]
   \   0000001E   0x.... 0x....      LDR.W    R1,??DataTable220_1
   \   00000022   0xF8C1 0x0A98      STR      R0,[R1, #+2712]
   \   00000026   0x.... 0x....      LDR.W    R0,??DataTable224  ;; 0x41200000
   \   0000002A   0x.... 0x....      BL       _Z18mks_leveling_moveZf
   \   0000002E   0x4628             MOV      R0,R5
   \   00000030   0x.... 0x....      BL       __aeabi_i2f
   \   00000034   0x4601             MOV      R1,R0
   \   00000036   0x460D             MOV      R5,R1
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       __aeabi_i2f
   \   0000003E   0x4629             MOV      R1,R5
   \   00000040   0x.... 0x....      BL       _Z19mks_leveling_moveXYff
   \   00000044   0x.... 0x....      ADR.W    R0,`?<Constant "G1 Z0">`
   \   00000048   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   0000004C   0x.... 0x....      B.W      _Z27enqueue_and_echo_commands_PPKc

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPause()
   \                     mks_contiuePrintPause: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}

  	char string[20];
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1116  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable220_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000000C   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \   00000010   0x.... 0x....      ADR.W    R0,`?<Constant "G28 X0 Y0">`
   \   00000014   0x.... 0x....      BL       _Z7mks_G28Pc
   \   00000018   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000001C   0x28AD             CMP      R0,#+173
   \   0000001E   0xD103             BNE.N    ??mks_contiuePrintPause_0
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000026   0xBD10             POP      {R4,PC}
   \                     ??mks_contiuePrintPause_0: (+1)
   \   00000028   0xF8D4 0x0A78      LDR      R0,[R4, #+2680]
   \   0000002C   0x.... 0x....      BL       mks_preExtrude
   \   00000030   0xF604 0x2078      ADDW     R0,R4,#+2680
   \   00000034   0x69C1             LDR      R1,[R0, #+28]
   \   00000036   0x6980             LDR      R0,[R0, #+24]
   \   00000038   0x.... 0x....      BL       mks_moveXY
   \   0000003C   0x.... 0x....      BL       mks_setPositionZ
   \   00000040   0x2000             MOVS     R0,#+0
   \   00000042   0x.... 0x....      BL       mks_moveZ
   \   00000046   0x.... 0x....      BL       _Z15mks_setFeedratev
   \   0000004A   0x.... 0x....      BL       mks_adjust_extrude_speed
   \   0000004E   0xF894 0x0AC0      LDRB     R0,[R4, #+2752]
   \   00000052   0x....             LDR.N    R1,??DataTable211_3
   \   00000054   0x66C8             STR      R0,[R1, #+108]
   \   00000056   0xF242 0x7110      MOVW     R1,#+10000
   \   0000005A   0x4348             MULS     R0,R1,R0
   \   0000005C   0x21FF             MOVS     R1,#+255
   \   0000005E   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   00000062   0x.... 0x....      LDR.W    R1,??DataTable215  ;; 0x40000440
   \   00000066   0x6008             STR      R0,[R1, #+0]
   \   00000068   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000006C   0x28AD             CMP      R0,#+173
   \   0000006E   0xD103             BNE.N    ??mks_contiuePrintPause_1
   \   00000070   0x2000             MOVS     R0,#+0
   \   00000072   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000076   0xBD10             POP      {R4,PC}
   \                     ??mks_contiuePrintPause_1: (+1)
   \   00000078   0x20A7             MOVS     R0,#+167
   \   0000007A   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   0000007E   0xE8BD 0x4010      POP      {R4,LR}
   \   00000082   0x.... 0x....      B.W      _Z9gcode_M24v

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintPwdwn()
   \                     mks_contiuePrintPwdwn: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	char string[20];
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1170  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable220_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000000C   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \   00000010   0x.... 0x....      BL       mks_setPositionZ
   \   00000014   0xF8D4 0x0A74      LDR      R0,[R4, #+2676]
   \   00000018   0x.... 0x....      BL       mks_moveZ
   \   0000001C   0x.... 0x....      ADR.W    R0,`?<Constant "G28 X0 Y0">`
   \   00000020   0x.... 0x....      BL       _Z7mks_G28Pc
   \   00000024   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000028   0x28AD             CMP      R0,#+173
   \   0000002A   0xD103             BNE.N    ??mks_contiuePrintPwdwn_0
   \   0000002C   0x2000             MOVS     R0,#+0
   \   0000002E   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000032   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??mks_contiuePrintPwdwn_0: (+1)
   \   00000034   0xF604 0x2574      ADDW     R5,R4,#+2676
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable223
   \   0000003C   0xF890 0x0040      LDRB     R0,[R0, #+64]
   \   00000040   0x2808             CMP      R0,#+8
   \   00000042   0xD106             BNE.N    ??mks_contiuePrintPwdwn_1
   \   00000044   0x6969             LDR      R1,[R5, #+20]
   \   00000046   0xF8D4 0x0A74      LDR      R0,[R4, #+2676]
   \   0000004A   0x.... 0x....      BL       __aeabi_fadd
   \   0000004E   0x.... 0x....      BL       _Z18mks_ResetPositionZf
   \                     ??mks_contiuePrintPwdwn_1: (+1)
   \   00000052   0xF640 0x30B8      MOVW     R0,#+3000
   \   00000056   0x.... 0x....      BL       HAL_Delay
   \   0000005A   0x6868             LDR      R0,[R5, #+4]
   \   0000005C   0x.... 0x....      BL       mks_preExtrude
   \   00000060   0x6A29             LDR      R1,[R5, #+32]
   \   00000062   0x69E8             LDR      R0,[R5, #+28]
   \   00000064   0x.... 0x....      BL       mks_moveXY
   \   00000068   0x2000             MOVS     R0,#+0
   \   0000006A   0x.... 0x....      BL       mks_moveZ
   \   0000006E   0x.... 0x....      BL       _Z15mks_setFeedratev
   \   00000072   0x.... 0x....      BL       mks_adjust_extrude_speed
   \   00000076   0xF894 0x0AC0      LDRB     R0,[R4, #+2752]
   \   0000007A   0x....             LDR.N    R1,??DataTable211_3
   \   0000007C   0x66C8             STR      R0,[R1, #+108]
   \   0000007E   0xF242 0x7110      MOVW     R1,#+10000
   \   00000082   0x4348             MULS     R0,R1,R0
   \   00000084   0x21FF             MOVS     R1,#+255
   \   00000086   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000008A   0x.... 0x....      LDR.W    R1,??DataTable215  ;; 0x40000440
   \   0000008E   0x6008             STR      R0,[R1, #+0]
   \   00000090   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   00000094   0x28AD             CMP      R0,#+173
   \   00000096   0xD103             BNE.N    ??mks_contiuePrintPwdwn_2
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000009E   0xBD31             POP      {R0,R4,R5,PC}
   \                     ??mks_contiuePrintPwdwn_2: (+1)
   \   000000A0   0x20A7             MOVS     R0,#+167
   \   000000A2   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   000000A6   0x.... 0x....      BL       _Z9gcode_M24v
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0xF884 0x0AB4      STRB     R0,[R4, #+2740]
   \   000000B0   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrintDelta()
   \                     mks_contiuePrintDelta: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	char string[20];
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1235  Warning[Pe177]: 
          variable "string" was declared but never referenced
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable220_1
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000000C   0x.... 0x....      BL       _Z18mks_setTemperaturev
   \   00000010   0x....             ADR.N    R0,??DataTable211_1  ;; "G28"
   \   00000012   0x.... 0x....      BL       _Z7mks_G28Pc
   \   00000016   0xF8D4 0x0A74      LDR      R0,[R4, #+2676]
   \   0000001A   0x.... 0x....      BL       mks_moveZ
   \   0000001E   0xF604 0x2574      ADDW     R5,R4,#+2676
   \   00000022   0x6868             LDR      R0,[R5, #+4]
   \   00000024   0x.... 0x....      BL       mks_preExtrude
   \   00000028   0x6A29             LDR      R1,[R5, #+32]
   \   0000002A   0x69E8             LDR      R0,[R5, #+28]
   \   0000002C   0x.... 0x....      BL       mks_moveXY
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       mks_moveZ
   \   00000036   0x.... 0x....      BL       _Z15mks_setFeedratev
   \   0000003A   0xF894 0x0AC0      LDRB     R0,[R4, #+2752]
   \   0000003E   0x....             LDR.N    R1,??DataTable211_3
   \   00000040   0x66C8             STR      R0,[R1, #+108]
   \   00000042   0xF242 0x7110      MOVW     R1,#+10000
   \   00000046   0x4348             MULS     R0,R1,R0
   \   00000048   0x21FF             MOVS     R1,#+255
   \   0000004A   0xFB90 0xF0F1      SDIV     R0,R0,R1
   \   0000004E   0x.... 0x....      LDR.W    R1,??DataTable215  ;; 0x40000440
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0x20A7             MOVS     R0,#+167
   \   00000056   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   0000005A   0x.... 0x....      BL       _Z9gcode_M24v
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0xF884 0x0AB4      STRB     R0,[R4, #+2740]
   \   00000064   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 1
   \   static __absolute uint8_t first_resu
   \                     first_resu:
   \   00000000   0x01               DC8 1

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_getPositionXYZE()
   \                     mks_getPositionXYZE: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x2000             MOVS     R0,#+0
   \   00000008   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000000C   0x.... 0x....      LDR.W    R0,??DataTable225
   \   00000010   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000014   0x2801             CMP      R0,#+1
   \   00000016   0xD077             BEQ.N    ??mks_getPositionXYZE_0
   \   00000018   0x.... 0x....      LDR.W    R4,??DataTable220_1
   \   0000001C   0xF604 0x2588      ADDW     R5,R4,#+2696
   \   00000020   0x69E9             LDR      R1,[R5, #+28]
   \   00000022   0x4620             MOV      R0,R4
   \   00000024   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000002E   0x.... 0x....      BL       _Z19get_sdcard_commandsv
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000038   0xF884 0x0AB4      STRB     R0,[R4, #+2740]
   \   0000003C   0x.... 0x....      LDR.W    R6,??DataTable225_1
   \   00000040   0x4602             MOV      R2,R0
   \   00000042   0xE004             B.N      ??mks_getPositionXYZE_1
   \                     ??mks_getPositionXYZE_2: (+1)
   \   00000044   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \   00000048   0x608A             STR      R2,[R1, #+8]
   \   0000004A   0x618A             STR      R2,[R1, #+24]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_1: (+1)
   \   0000004E   0x2804             CMP      R0,#+4
   \   00000050   0xDBF8             BLT.N    ??mks_getPositionXYZE_2
   \   00000052   0x4617             MOV      R7,R2
   \   00000054   0xE019             B.N      ??mks_getPositionXYZE_3
   \                     ??mks_getPositionXYZE_4: (+1)
   \   00000056   0xEB04 0x0283      ADD      R2,R4,R3, LSL #+2
   \   0000005A   0xF8D2 0x0A90      LDR      R0,[R2, #+2704]
   \   0000005E   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000062   0x.... 0x....      BL       __aeabi_cfcmple
   \   00000066   0xD20C             BCS.N    ??mks_getPositionXYZE_5
   \   00000068   0x.... 0x....      LDR.W    R6,??DataTable225_1
   \   0000006C   0xEB06 0x0683      ADD      R6,R6,R3, LSL #+2
   \   00000070   0x69B0             LDR      R0,[R6, #+24]
   \   00000072   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000076   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000007A   0xD802             BHI.N    ??mks_getPositionXYZE_5
   \   0000007C   0x69B0             LDR      R0,[R6, #+24]
   \   0000007E   0xF8C2 0x0A90      STR      R0,[R2, #+2704]
   \                     ??mks_getPositionXYZE_5: (+1)
   \   00000082   0x1C5B             ADDS     R3,R3,#+1
   \                     ??mks_getPositionXYZE_6: (+1)
   \   00000084   0x2B04             CMP      R3,#+4
   \   00000086   0xDBE6             BLT.N    ??mks_getPositionXYZE_4
   \   00000088   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mks_getPositionXYZE_3: (+1)
   \   0000008A   0x2F04             CMP      R7,#+4
   \   0000008C   0xDA36             BGE.N    ??mks_getPositionXYZE_7
   \   0000008E   0x2F00             CMP      R7,#+0
   \   00000090   0xD126             BNE.N    ??mks_getPositionXYZE_8
   \   00000092   0x.... 0x....      LDR.W    R0,??DataTable226
   \   00000096   0x7801             LDRB     R1,[R0, #+0]
   \   00000098   0x2901             CMP      R1,#+1
   \   0000009A   0xD121             BNE.N    ??mks_getPositionXYZE_8
   \   0000009C   0x2100             MOVS     R1,#+0
   \   0000009E   0x7001             STRB     R1,[R0, #+0]
   \   000000A0   0x215A             MOVS     R1,#+90
   \   000000A2   0x.... 0x....      LDR.W    R0,??DataTable226_1
   \   000000A6   0x.... 0x....      BL       _Z6strchrPci
   \   000000AA   0x2800             CMP      R0,#+0
   \   000000AC   0xAB01             ADD      R3,SP,#+4
   \   000000AE   0xD021             BEQ.N    ??mks_getPositionXYZE_9
   \                     ??mks_getPositionXYZE_10: (+1)
   \   000000B0   0xF910 0x1B01      LDRSB    R1,[R0], #+1
   \   000000B4   0x2900             CMP      R1,#+0
   \   000000B6   0xD00A             BEQ.N    ??mks_getPositionXYZE_11
   \   000000B8   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   000000BC   0x1C4A             ADDS     R2,R1,#+1
   \   000000BE   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   000000C2   0x7802             LDRB     R2,[R0, #+0]
   \   000000C4   0x54CA             STRB     R2,[R1, R3]
   \   000000C6   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   000000CA   0x2915             CMP      R1,#+21
   \   000000CC   0xDBF0             BLT.N    ??mks_getPositionXYZE_10
   \                     ??mks_getPositionXYZE_11: (+1)
   \   000000CE   0xA801             ADD      R0,SP,#+4
   \   000000D0   0x.... 0x....      BL       atof
   \   000000D4   0x.... 0x....      BL       __aeabi_d2f
   \   000000D8   0x.... 0x....      LDR.W    R1,??DataTable225_1
   \   000000DC   0x6208             STR      R0,[R1, #+32]
   \   000000DE   0xE009             B.N      ??mks_getPositionXYZE_9
   \                     ??mks_getPositionXYZE_8: (+1)
   \   000000E0   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000000E4   0x.... 0x....      LDR.W    R1,??DataTable226_1
   \   000000E8   0xEB01 0x1040      ADD      R0,R1,R0, LSL #+5
   \   000000EC   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000000F0   0x.... 0x....      BL       _Z21gcode_get_destinationv
   \                     ??mks_getPositionXYZE_9: (+1)
   \   000000F4   0x2300             MOVS     R3,#+0
   \   000000F6   0x.... 0x....      LDR.W    R1,??DataTable226_2  ;; 0x38d1b718
   \   000000FA   0xE7C3             B.N      ??mks_getPositionXYZE_6
   \                     ??mks_getPositionXYZE_7: (+1)
   \   000000FC   0x6928             LDR      R0,[R5, #+16]
   \   000000FE   0xF8C4 0x0A88      STR      R0,[R4, #+2696]
   \   00000102   0x6968             LDR      R0,[R5, #+20]
   \   00000104   0x6068             STR      R0,[R5, #+4]
   \   00000106   0xE096             B.N      ??mks_getPositionXYZE_12
   \                     ??mks_getPositionXYZE_0: (+1)
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x.... 0x....      LDR.W    R6,??DataTable225_1
   \   0000010E   0x4602             MOV      R2,R0
   \   00000110   0xE004             B.N      ??mks_getPositionXYZE_13
   \                     ??mks_getPositionXYZE_14: (+1)
   \   00000112   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \   00000116   0x608A             STR      R2,[R1, #+8]
   \   00000118   0x618A             STR      R2,[R1, #+24]
   \   0000011A   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_13: (+1)
   \   0000011C   0x2804             CMP      R0,#+4
   \   0000011E   0xDBF8             BLT.N    ??mks_getPositionXYZE_14
   \   00000120   0x.... 0x....      LDR.W    R4,??DataTable220_1
   \   00000124   0xF604 0x2588      ADDW     R5,R4,#+2696
   \   00000128   0x6A29             LDR      R1,[R5, #+32]
   \   0000012A   0x4620             MOV      R0,R4
   \   0000012C   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   00000130   0xE004             B.N      ??mks_getPositionXYZE_15
   \                     ??mks_getPositionXYZE_16: (+1)
   \   00000132   0x6928             LDR      R0,[R5, #+16]
   \   00000134   0xF8C4 0x0A88      STR      R0,[R4, #+2696]
   \   00000138   0x6968             LDR      R0,[R5, #+20]
   \   0000013A   0x6068             STR      R0,[R5, #+4]
   \                     ??mks_getPositionXYZE_15: (+1)
   \   0000013C   0x4620             MOV      R0,R4
   \   0000013E   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000142   0x6A69             LDR      R1,[R5, #+36]
   \   00000144   0x4288             CMP      R0,R1
   \   00000146   0xD271             BCS.N    ??mks_getPositionXYZE_17
   \   00000148   0x2000             MOVS     R0,#+0
   \   0000014A   0x70B0             STRB     R0,[R6, #+2]
   \   0000014C   0x2001             MOVS     R0,#+1
   \   0000014E   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000152   0x.... 0x....      BL       _Z19get_sdcard_commandsv
   \   00000156   0x2700             MOVS     R7,#+0
   \   00000158   0xE000             B.N      ??mks_getPositionXYZE_18
   \                     ??mks_getPositionXYZE_19: (+1)
   \   0000015A   0x1C7F             ADDS     R7,R7,#+1
   \                     ??mks_getPositionXYZE_18: (+1)
   \   0000015C   0x2F04             CMP      R7,#+4
   \   0000015E   0xDAE8             BGE.N    ??mks_getPositionXYZE_16
   \   00000160   0x2F00             CMP      R7,#+0
   \   00000162   0xD124             BNE.N    ??mks_getPositionXYZE_20
   \   00000164   0x.... 0x....      LDR.W    R0,??DataTable226
   \   00000168   0x7801             LDRB     R1,[R0, #+0]
   \   0000016A   0x2901             CMP      R1,#+1
   \   0000016C   0xD11F             BNE.N    ??mks_getPositionXYZE_20
   \   0000016E   0x2100             MOVS     R1,#+0
   \   00000170   0x7001             STRB     R1,[R0, #+0]
   \   00000172   0x215A             MOVS     R1,#+90
   \   00000174   0x.... 0x....      LDR.W    R0,??DataTable226_1
   \   00000178   0x.... 0x....      BL       _Z6strchrPci
   \   0000017C   0x2800             CMP      R0,#+0
   \   0000017E   0xAB01             ADD      R3,SP,#+4
   \   00000180   0xD01F             BEQ.N    ??mks_getPositionXYZE_21
   \                     ??mks_getPositionXYZE_22: (+1)
   \   00000182   0xF910 0x1B01      LDRSB    R1,[R0], #+1
   \   00000186   0x2900             CMP      R1,#+0
   \   00000188   0xD00A             BEQ.N    ??mks_getPositionXYZE_23
   \   0000018A   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   0000018E   0x1C4A             ADDS     R2,R1,#+1
   \   00000190   0xF88D 0x2000      STRB     R2,[SP, #+0]
   \   00000194   0x7802             LDRB     R2,[R0, #+0]
   \   00000196   0x54CA             STRB     R2,[R1, R3]
   \   00000198   0xF99D 0x1000      LDRSB    R1,[SP, #+0]
   \   0000019C   0x2915             CMP      R1,#+21
   \   0000019E   0xDBF0             BLT.N    ??mks_getPositionXYZE_22
   \                     ??mks_getPositionXYZE_23: (+1)
   \   000001A0   0xA801             ADD      R0,SP,#+4
   \   000001A2   0x.... 0x....      BL       atof
   \   000001A6   0x.... 0x....      BL       __aeabi_d2f
   \   000001AA   0x6230             STR      R0,[R6, #+32]
   \   000001AC   0xE009             B.N      ??mks_getPositionXYZE_21
   \                     ??mks_getPositionXYZE_20: (+1)
   \   000001AE   0xEB07 0x0047      ADD      R0,R7,R7, LSL #+1
   \   000001B2   0x.... 0x....      LDR.W    R1,??DataTable226_1
   \   000001B6   0xEB01 0x1040      ADD      R0,R1,R0, LSL #+5
   \   000001BA   0x.... 0x....      BL       _ZN11GCodeParser5parseEPc
   \   000001BE   0x.... 0x....      BL       _Z21gcode_get_destinationv
   \                     ??mks_getPositionXYZE_21: (+1)
   \   000001C2   0xF04F 0x0800      MOV      R8,#+0
   \   000001C6   0xE00A             B.N      ??mks_getPositionXYZE_24
   \                     ??mks_getPositionXYZE_25: (+1)
   \   000001C8   0x2000             MOVS     R0,#+0
   \                     ??mks_getPositionXYZE_26: (+1)
   \   000001CA   0x.... 0x....      BL       abs
   \   000001CE   0x2800             CMP      R0,#+0
   \   000001D0   0xD003             BEQ.N    ??mks_getPositionXYZE_27
   \   000001D2   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   000001D6   0xF8C9 0x0A90      STR      R0,[R9, #+2704]
   \                     ??mks_getPositionXYZE_27: (+1)
   \   000001DA   0xF108 0x0801      ADD      R8,R8,#+1
   \                     ??mks_getPositionXYZE_24: (+1)
   \   000001DE   0xF1B8 0x0F04      CMP      R8,#+4
   \   000001E2   0xDABA             BGE.N    ??mks_getPositionXYZE_19
   \   000001E4   0xEB04 0x0988      ADD      R9,R4,R8, LSL #+2
   \   000001E8   0x.... 0x....      LDR.W    R1,??DataTable226_2  ;; 0x38d1b718
   \   000001EC   0xF8D9 0x0A90      LDR      R0,[R9, #+2704]
   \   000001F0   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   000001F4   0x.... 0x....      BL       __aeabi_cfcmple
   \   000001F8   0xD20C             BCS.N    ??mks_getPositionXYZE_28
   \   000001FA   0xEB06 0x0A88      ADD      R10,R6,R8, LSL #+2
   \   000001FE   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000202   0xF020 0x4000      BIC      R0,R0,#0x80000000
   \   00000206   0x.... 0x....      BL       __aeabi_cfrcmple
   \   0000020A   0xD803             BHI.N    ??mks_getPositionXYZE_28
   \   0000020C   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000210   0xF8C9 0x0A90      STR      R0,[R9, #+2704]
   \                     ??mks_getPositionXYZE_28: (+1)
   \   00000214   0xF1B8 0x0F02      CMP      R8,#+2
   \   00000218   0xD0DF             BEQ.N    ??mks_getPositionXYZE_27
   \   0000021A   0xEB06 0x0A88      ADD      R10,R6,R8, LSL #+2
   \   0000021E   0xF8DA 0x0018      LDR      R0,[R10, #+24]
   \   00000222   0x.... 0x....      BL       __aeabi_cfrcmple
   \   00000226   0xD8CF             BHI.N    ??mks_getPositionXYZE_25
   \   00000228   0x2001             MOVS     R0,#+1
   \   0000022A   0xE7CE             B.N      ??mks_getPositionXYZE_26
   \                     ??mks_getPositionXYZE_17: (+1)
   \   0000022C   0x2000             MOVS     R0,#+0
   \   0000022E   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   00000232   0xF884 0x0AB4      STRB     R0,[R4, #+2740]
   \                     ??mks_getPositionXYZE_12: (+1)
   \   00000236   0x2000             MOVS     R0,#+0
   \   00000238   0x.... 0x....      LDR.W    R6,??DataTable225_1
   \   0000023C   0x4602             MOV      R2,R0
   \   0000023E   0xE004             B.N      ??mks_getPositionXYZE_29
   \                     ??mks_getPositionXYZE_30: (+1)
   \   00000240   0xEB06 0x0180      ADD      R1,R6,R0, LSL #+2
   \   00000244   0x608A             STR      R2,[R1, #+8]
   \   00000246   0x618A             STR      R2,[R1, #+24]
   \   00000248   0x1C40             ADDS     R0,R0,#+1
   \                     ??mks_getPositionXYZE_29: (+1)
   \   0000024A   0x2804             CMP      R0,#+4
   \   0000024C   0xDBF8             BLT.N    ??mks_getPositionXYZE_30
   \   0000024E   0x4614             MOV      R4,R2
   \   00000250   0xE00A             B.N      ??mks_getPositionXYZE_31
   \                     ??mks_getPositionXYZE_32: (+1)
   \   00000252   0x2260             MOVS     R2,#+96
   \   00000254   0x2100             MOVS     R1,#+0
   \   00000256   0xEB04 0x0044      ADD      R0,R4,R4, LSL #+1
   \   0000025A   0x.... 0x....      LDR.W    R3,??DataTable226_1
   \   0000025E   0xEB03 0x1040      ADD      R0,R3,R0, LSL #+5
   \   00000262   0x.... 0x....      BL       memset
   \   00000266   0x1C64             ADDS     R4,R4,#+1
   \                     ??mks_getPositionXYZE_31: (+1)
   \   00000268   0x2C04             CMP      R4,#+4
   \   0000026A   0xDBF2             BLT.N    ??mks_getPositionXYZE_32
   \   0000026C   0x.... 0x....      BL       _Z19clear_command_queuev
   \   00000270   0xB006             ADD      SP,SP,#+24
   \   00000272   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearDir()
   \                     mks_clearDir: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x.... 0x....      LDR.W    R4,??DataTable226_3
   \   00000008   0xE007             B.N      ??mks_clearDir_0
   \                     ??mks_clearDir_1: (+1)
   \   0000000A   0x1C41             ADDS     R1,R0,#+1
   \   0000000C   0xA800             ADD      R0,SP,#+0
   \   0000000E   0x.... 0x....      BL       strcpy
   \   00000012   0xA900             ADD      R1,SP,#+0
   \   00000014   0x4620             MOV      R0,R4
   \   00000016   0x.... 0x....      BL       strcpy
   \                     ??mks_clearDir_0: (+1)
   \   0000001A   0x....             ADR.N    R1,??DataTable215_1  ;; "/"
   \   0000001C   0x4620             MOV      R0,R4
   \   0000001E   0x.... 0x....      BL       _Z6strstrPcPKc
   \   00000022   0x2800             CMP      R0,#+0
   \   00000024   0xD1F1             BNE.N    ??mks_clearDir_1
   \   00000026   0xB008             ADD      SP,SP,#+32
   \   00000028   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_contiuePrint_UI()
   \                     mks_contiuePrint_UI: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x2100             MOVS     R1,#+0
   \   00000004   0x.... 0x....      ADR.W    R0,`?<Constant "Resume print?">`
   \   00000008   0x.... 0x....      BL       _Z13lcd_setstatusPKcb
   \   0000000C   0x.... 0x....      LDR.W    R4,??DataTable220_1
   \   00000010   0xF604 0x15D4      ADDW     R5,R4,#+2516
   \   00000014   0x2301             MOVS     R3,#+1
   \   00000016   0x461A             MOV      R2,R3
   \   00000018   0x4629             MOV      R1,R5
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       _ZN10CardReader8openFileEPcbb
   \   00000020   0x4629             MOV      R1,R5
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable226_4
   \   00000026   0x.... 0x....      BL       strcpy
   \   0000002A   0x4620             MOV      R0,R4
   \   0000002C   0x.... 0x....      BL       _ZN10CardReader10isFileOpenEv
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD108             BNE.N    ??mks_contiuePrint_UI_0
   \   00000034   0xF44F 0x6096      MOV      R0,#+1200
   \   00000038   0x.... 0x....      BL       _Z6Beeperj
   \   0000003C   0x2002             MOVS     R0,#+2
   \   0000003E   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000042   0x.... 0x....      B.W      draw_dialog
   \                     ??mks_contiuePrint_UI_0: (+1)
   \   00000046   0xF604 0x26A0      ADDW     R6,R4,#+2720
   \   0000004A   0x6870             LDR      R0,[R6, #+4]
   \   0000004C   0x2865             CMP      R0,#+101
   \   0000004E   0xD202             BCS.N    ??mks_contiuePrint_UI_1
   \   00000050   0x68F0             LDR      R0,[R6, #+12]
   \   00000052   0x2865             CMP      R0,#+101
   \   00000054   0xD359             BCC.N    ??mks_contiuePrint_UI_2
   \                     ??mks_contiuePrint_UI_1: (+1)
   \   00000056   0x2296             MOVS     R2,#+150
   \   00000058   0xF604 0x11D4      ADDW     R1,R4,#+2516
   \   0000005C   0xF240 0x40FD      MOVW     R0,#+1277
   \   00000060   0x.... 0x....      BL       epr_write_data
   \   00000064   0x2000             MOVS     R0,#+0
   \   00000066   0xF884 0x09B8      STRB     R0,[R4, #+2488]
   \   0000006A   0xF994 0x0D68      LDRSB    R0,[R4, #+3432]
   \   0000006E   0x2802             CMP      R0,#+2
   \   00000070   0xD101             BNE.N    ??mks_contiuePrint_UI_3
   \   00000072   0x.... 0x....      BL       mks_getPositionXYZE
   \                     ??mks_contiuePrint_UI_3: (+1)
   \   00000076   0x.... 0x....      LDR.W    R5,??DataTable225
   \   0000007A   0xF895 0x019F      LDRB     R0,[R5, #+415]
   \   0000007E   0x2801             CMP      R0,#+1
   \   00000080   0xD004             BEQ.N    ??mks_contiuePrint_UI_4
   \   00000082   0x6871             LDR      R1,[R6, #+4]
   \   00000084   0x4620             MOV      R0,R4
   \   00000086   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \   0000008A   0xE003             B.N      ??mks_contiuePrint_UI_5
   \                     ??mks_contiuePrint_UI_4: (+1)
   \   0000008C   0x68F1             LDR      R1,[R6, #+12]
   \   0000008E   0x4620             MOV      R0,R4
   \   00000090   0x.... 0x....      BL       _ZN10CardReader8setIndexEl
   \                     ??mks_contiuePrint_UI_5: (+1)
   \   00000094   0x.... 0x....      LDR.W    R0,??DataTable225_1
   \   00000098   0xF8D4 0x1A80      LDR      R1,[R4, #+2688]
   \   0000009C   0x6081             STR      R1,[R0, #+8]
   \   0000009E   0xF604 0x2180      ADDW     R1,R4,#+2688
   \   000000A2   0x684A             LDR      R2,[R1, #+4]
   \   000000A4   0x60C2             STR      R2,[R0, #+12]
   \   000000A6   0x6889             LDR      R1,[R1, #+8]
   \   000000A8   0x6101             STR      R1,[R0, #+16]
   \   000000AA   0xF895 0x019F      LDRB     R0,[R5, #+415]
   \   000000AE   0x2801             CMP      R0,#+1
   \   000000B0   0xD001             BEQ.N    ??mks_contiuePrint_UI_6
   \   000000B2   0x.... 0x....      BL       mks_clearDir
   \                     ??mks_contiuePrint_UI_6: (+1)
   \   000000B6   0x.... 0x....      BL       getTick
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable226_5
   \   000000BE   0x6008             STR      R0,[R1, #+0]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable226_6
   \   000000C4   0x6809             LDR      R1,[R1, #+0]
   \   000000C6   0x.... 0x....      BL       getTickDiff
   \   000000CA   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000CE   0x4288             CMP      R0,R1
   \   000000D0   0xD203             BCS.N    ??mks_contiuePrint_UI_7
   \   000000D2   0xF995 0x00BA      LDRSB    R0,[R5, #+186]
   \   000000D6   0x2800             CMP      R0,#+0
   \   000000D8   0xD1ED             BNE.N    ??mks_contiuePrint_UI_6
   \                     ??mks_contiuePrint_UI_7: (+1)
   \   000000DA   0x.... 0x....      LDR.W    R4,??DataTable226_7
   \   000000DE   0x2201             MOVS     R2,#+1
   \   000000E0   0x4621             MOV      R1,R4
   \   000000E2   0xF44F 0x60E0      MOV      R0,#+1792
   \   000000E6   0x.... 0x....      BL       AT24CXX_Read
   \   000000EA   0x7820             LDRB     R0,[R4, #+0]
   \   000000EC   0x2800             CMP      R0,#+0
   \   000000EE   0xD004             BEQ.N    ??mks_contiuePrint_UI_8
   \   000000F0   0x2001             MOVS     R0,#+1
   \   000000F2   0x.... 0x....      LDR.W    R1,??DataTable226_8
   \   000000F6   0x7008             STRB     R0,[R1, #+0]
   \   000000F8   0xE003             B.N      ??mks_contiuePrint_UI_9
   \                     ??mks_contiuePrint_UI_8: (+1)
   \   000000FA   0x2001             MOVS     R0,#+1
   \   000000FC   0x.... 0x....      LDR.W    R1,??DataTable226_9
   \   00000100   0x7008             STRB     R0,[R1, #+0]
   \                     ??mks_contiuePrint_UI_9: (+1)
   \   00000102   0xE8BD 0x4070      POP      {R4-R6,LR}
   \   00000106   0x.... 0x....      B.W      draw_printing
   \                     ??mks_contiuePrint_UI_2: (+1)
   \   0000010A   0x2000             MOVS     R0,#+0
   \   0000010C   0xF884 0x0D68      STRB     R0,[R4, #+3432]
   \   00000110   0x20A6             MOVS     R0,#+166
   \   00000112   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   00000116   0x.... 0x....      LDR.W    R0,??DataTable225
   \   0000011A   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   0000011E   0x2801             CMP      R0,#+1
   \   00000120   0xD005             BEQ.N    ??mks_contiuePrint_UI_10
   \   00000122   0x2201             MOVS     R2,#+1
   \   00000124   0x4631             MOV      R1,R6
   \   00000126   0xF44F 0x6096      MOV      R0,#+1200
   \   0000012A   0x.... 0x....      BL       epr_write_data
   \                     ??mks_contiuePrint_UI_10: (+1)
   \   0000012E   0x2001             MOVS     R0,#+1
   \   00000130   0x.... 0x....      LDR.W    R1,??DataTable226_10
   \   00000134   0x7008             STRB     R0,[R1, #+0]
   \   00000136   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_rePrintCheck()
   \                     mks_rePrintCheck: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}

  	bool pft_ok = false;
  	     ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1577  Warning[Pe550]: 
          variable "pft_ok" was set but never used
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable226_11
   \   00000006   0xF604 0x25A0      ADDW     R5,R4,#+2720
   \   0000000A   0x2201             MOVS     R2,#+1
   \   0000000C   0x4629             MOV      R1,R5
   \   0000000E   0xF44F 0x6096      MOV      R0,#+1200
   \   00000012   0x.... 0x....      BL       epr_read_data
   \   00000016   0xF894 0x0AA0      LDRB     R0,[R4, #+2720]
   \   0000001A   0x28AA             CMP      R0,#+170
   \   0000001C   0xD10A             BNE.N    ??mks_rePrintCheck_0
   \   0000001E   0x20AB             MOVS     R0,#+171
   \   00000020   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   00000024   0x.... 0x....      BL       mks_ReadFromEpr
   \   00000028   0x2001             MOVS     R0,#+1
   \   0000002A   0xF884 0x0D68      STRB     R0,[R4, #+3432]
   \   0000002E   0x.... 0x....      BL       mks_contiuePrint_UI
   \   00000032   0xE035             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_0: (+1)
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable226_12
   \   00000038   0x28A7             CMP      R0,#+167
   \   0000003A   0xD120             BNE.N    ??mks_rePrintCheck_2
   \   0000003C   0xF891 0x019F      LDRB     R0,[R1, #+415]
   \   00000040   0x2801             CMP      R0,#+1
   \   00000042   0xD10A             BNE.N    ??mks_rePrintCheck_3
   \   00000044   0x20AB             MOVS     R0,#+171
   \   00000046   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   0000004A   0x.... 0x....      BL       _Z22mks_ReadFromEpr_pwroffv
   \   0000004E   0x2002             MOVS     R0,#+2
   \   00000050   0xF884 0x0D68      STRB     R0,[R4, #+3432]
   \   00000054   0x.... 0x....      BL       mks_contiuePrint_UI
   \   00000058   0xE022             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_3: (+1)
   \   0000005A   0x20AB             MOVS     R0,#+171
   \   0000005C   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   00000060   0x2296             MOVS     R2,#+150
   \   00000062   0xF604 0x11D4      ADDW     R1,R4,#+2516
   \   00000066   0xF240 0x40FD      MOVW     R0,#+1277
   \   0000006A   0x.... 0x....      BL       epr_read_data
   \   0000006E   0x.... 0x....      BL       mks_ReadFromFile
   \   00000072   0x2002             MOVS     R0,#+2
   \   00000074   0xF884 0x0D68      STRB     R0,[R4, #+3432]
   \   00000078   0x.... 0x....      BL       mks_contiuePrint_UI
   \   0000007C   0xE010             B.N      ??mks_rePrintCheck_1
   \                     ??mks_rePrintCheck_2: (+1)
   \   0000007E   0x20A6             MOVS     R0,#+166
   \   00000080   0xF884 0x0AA0      STRB     R0,[R4, #+2720]
   \   00000084   0xF891 0x019F      LDRB     R0,[R1, #+415]
   \   00000088   0x2801             CMP      R0,#+1
   \   0000008A   0xD005             BEQ.N    ??mks_rePrintCheck_4
   \   0000008C   0x2201             MOVS     R2,#+1
   \   0000008E   0x4629             MOV      R1,R5
   \   00000090   0xF44F 0x6096      MOV      R0,#+1200
   \   00000094   0x.... 0x....      BL       epr_write_data
   \                     ??mks_rePrintCheck_4: (+1)
   \   00000098   0x2001             MOVS     R0,#+1
   \   0000009A   0x.... 0x....      LDR.W    R1,??DataTable226_10
   \   0000009E   0x7008             STRB     R0,[R1, #+0]
   \                     ??mks_rePrintCheck_1: (+1)
   \   000000A0   0x.... 0x....      LDR.W    R0,??DataTable226_10
   \   000000A4   0x7801             LDRB     R1,[R0, #+0]
   \   000000A6   0x2901             CMP      R1,#+1
   \   000000A8   0xD118             BNE.N    ??mks_rePrintCheck_5
   \   000000AA   0x2100             MOVS     R1,#+0
   \   000000AC   0x7001             STRB     R1,[R0, #+0]
   \                     ??mks_rePrintCheck_6: (+1)
   \   000000AE   0x.... 0x....      LDR.W    R0,??DataTable226_13
   \   000000B2   0x7CC0             LDRB     R0,[R0, #+19]
   \   000000B4   0x2801             CMP      R0,#+1
   \   000000B6   0xD011             BEQ.N    ??mks_rePrintCheck_5
   \   000000B8   0x.... 0x....      BL       getTick
   \   000000BC   0x.... 0x....      LDR.W    R1,??DataTable226_5
   \   000000C0   0x6008             STR      R0,[R1, #+0]
   \   000000C2   0x.... 0x....      LDR.W    R1,??DataTable226_6
   \   000000C6   0x6809             LDR      R1,[R1, #+0]
   \   000000C8   0x.... 0x....      BL       getTickDiff
   \   000000CC   0xF640 0x31B8      MOVW     R1,#+3000
   \   000000D0   0x4288             CMP      R0,R1
   \   000000D2   0xD3EC             BCC.N    ??mks_rePrintCheck_6
   \   000000D4   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   000000D8   0x.... 0x....      B.W      draw_ready_print
   \                     ??mks_rePrintCheck_5: (+1)
   \   000000DC   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToFile()
   \                     mks_WriteToFile: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB08E             SUB      SP,SP,#+56
   \   00000006   0xA805             ADD      R0,SP,#+20
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   \   0000000E   0x.... 0x....      LDR.W    R7,??DataTable220_1
   \   00000012   0xF897 0x09BB      LDRB     R0,[R7, #+2491]
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD004             BEQ.N    ??mks_WriteToFile_0
   \   0000001A   0x.... 0x....      LDR.W    R1,??DataTable226_14
   \   0000001E   0xA805             ADD      R0,SP,#+20
   \   00000020   0x.... 0x....      BL       strcat
   \                     ??mks_WriteToFile_0: (+1)
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable226_15
   \   00000028   0x6801             LDR      R1,[R0, #+0]
   \   0000002A   0xA805             ADD      R0,SP,#+20
   \   0000002C   0x.... 0x....      BL       strcat
   \   00000030   0xF607 0x3438      ADDW     R4,R7,#+2872
   \   00000034   0x2203             MOVS     R2,#+3
   \   00000036   0xA905             ADD      R1,SP,#+20
   \   00000038   0x4620             MOV      R0,R4
   \   0000003A   0x.... 0x....      BL       f_open
   \   0000003E   0x2800             CMP      R0,#+0
   \   00000040   0xF040 0x8111      BNE.W    ??mks_WriteToFile_1
   \   00000044   0x2214             MOVS     R2,#+20
   \   00000046   0x2100             MOVS     R1,#+0
   \   00000048   0xA800             ADD      R0,SP,#+0
   \   0000004A   0x.... 0x....      BL       memset
   \   0000004E   0x2207             MOVS     R2,#+7
   \   00000050   0x.... 0x....      ADR.W    R1,`?<Constant "start\\n">`
   \   00000054   0xA800             ADD      R0,SP,#+0
   \   00000056   0x.... 0x....      BL       __aeabi_memcpy4
   \   0000005A   0xA900             ADD      R1,SP,#+0
   \   0000005C   0x4620             MOV      R0,R4
   \   0000005E   0x.... 0x....      BL       f_printf
   \   00000062   0x2214             MOVS     R2,#+20
   \   00000064   0x2100             MOVS     R1,#+0
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0x.... 0x....      BL       memset
   \   0000006C   0x....             ADR.N    R5,??DataTable217  ;; 0x25, 0x64, 0x00, 0x00
   \   0000006E   0xF8D7 0x2AA4      LDR      R2,[R7, #+2724]
   \   00000072   0x4629             MOV      R1,R5
   \   00000074   0xA800             ADD      R0,SP,#+0
   \   00000076   0x.... 0x....      BL       sprintf
   \   0000007A   0x....             ADR.N    R6,??DataTable217_1  ;; "\n"
   \   0000007C   0x4631             MOV      R1,R6
   \   0000007E   0xA800             ADD      R0,SP,#+0
   \   00000080   0x.... 0x....      BL       strcat
   \   00000084   0xA900             ADD      R1,SP,#+0
   \   00000086   0x4620             MOV      R0,R4
   \   00000088   0x.... 0x....      BL       f_printf
   \   0000008C   0x2214             MOVS     R2,#+20
   \   0000008E   0x2100             MOVS     R1,#+0
   \   00000090   0xA800             ADD      R0,SP,#+0
   \   00000092   0x.... 0x....      BL       memset
   \   00000096   0x.... 0x....      LDR.W    R8,??DataTable226_16
   \   0000009A   0xF8D8 0x2000      LDR      R2,[R8, #+0]
   \   0000009E   0x4629             MOV      R1,R5
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       sprintf
   \   000000A6   0x4631             MOV      R1,R6
   \   000000A8   0xA800             ADD      R0,SP,#+0
   \   000000AA   0x.... 0x....      BL       strcat
   \   000000AE   0xA900             ADD      R1,SP,#+0
   \   000000B0   0x4620             MOV      R0,R4
   \   000000B2   0x.... 0x....      BL       f_printf
   \   000000B6   0x2214             MOVS     R2,#+20
   \   000000B8   0x2100             MOVS     R1,#+0
   \   000000BA   0xA800             ADD      R0,SP,#+0
   \   000000BC   0x.... 0x....      BL       memset
   \   000000C0   0xF8D8 0x2004      LDR      R2,[R8, #+4]
   \   000000C4   0x4629             MOV      R1,R5
   \   000000C6   0xA800             ADD      R0,SP,#+0
   \   000000C8   0x.... 0x....      BL       sprintf
   \   000000CC   0x4631             MOV      R1,R6
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      BL       strcat
   \   000000D4   0xA900             ADD      R1,SP,#+0
   \   000000D6   0x4620             MOV      R0,R4
   \   000000D8   0x.... 0x....      BL       f_printf
   \   000000DC   0x2214             MOVS     R2,#+20
   \   000000DE   0x2100             MOVS     R1,#+0
   \   000000E0   0xA800             ADD      R0,SP,#+0
   \   000000E2   0x.... 0x....      BL       memset
   \   000000E6   0x.... 0x....      LDR.W    R0,??DataTable226_17
   \   000000EA   0xF9B0 0x2000      LDRSH    R2,[R0, #+0]
   \   000000EE   0x4629             MOV      R1,R5
   \   000000F0   0xA800             ADD      R0,SP,#+0
   \   000000F2   0x.... 0x....      BL       sprintf
   \   000000F6   0x4631             MOV      R1,R6
   \   000000F8   0xA800             ADD      R0,SP,#+0
   \   000000FA   0x.... 0x....      BL       strcat
   \   000000FE   0xA900             ADD      R1,SP,#+0
   \   00000100   0x4620             MOV      R0,R4
   \   00000102   0x.... 0x....      BL       f_printf
   \   00000106   0xF607 0x23CC      ADDW     R3,R7,#+2764
   \   0000010A   0xF607 0x22C8      ADDW     R2,R7,#+2760
   \   0000010E   0xF607 0x21C4      ADDW     R1,R7,#+2756
   \   00000112   0xF607 0x506C      ADDW     R0,R7,#+3436
   \   00000116   0x.... 0x....      BL       _ZN9Stopwatch7getTimeEPmS0_S0_
   \   0000011A   0x.... 0x....      BL       HAL_GetTick
   \   0000011E   0xF607 0x27A4      ADDW     R7,R7,#+2724
   \   00000122   0x62F8             STR      R0,[R7, #+44]
   \   00000124   0x6AB9             LDR      R1,[R7, #+40]
   \   00000126   0x6A7A             LDR      R2,[R7, #+36]
   \   00000128   0x4291             CMP      R1,R2
   \   0000012A   0xD200             BCS.N    ??mks_WriteToFile_2
   \   0000012C   0x62B8             STR      R0,[R7, #+40]
   \                     ??mks_WriteToFile_2: (+1)
   \   0000012E   0x2214             MOVS     R2,#+20
   \   00000130   0x2100             MOVS     R1,#+0
   \   00000132   0xA800             ADD      R0,SP,#+0
   \   00000134   0x.... 0x....      BL       memset
   \   00000138   0x6A3A             LDR      R2,[R7, #+32]
   \   0000013A   0x4629             MOV      R1,R5
   \   0000013C   0xA800             ADD      R0,SP,#+0
   \   0000013E   0x.... 0x....      BL       sprintf
   \   00000142   0x4631             MOV      R1,R6
   \   00000144   0xA800             ADD      R0,SP,#+0
   \   00000146   0x.... 0x....      BL       strcat
   \   0000014A   0xA900             ADD      R1,SP,#+0
   \   0000014C   0x4620             MOV      R0,R4
   \   0000014E   0x.... 0x....      BL       f_printf
   \   00000152   0x2214             MOVS     R2,#+20
   \   00000154   0x2100             MOVS     R1,#+0
   \   00000156   0xA800             ADD      R0,SP,#+0
   \   00000158   0x.... 0x....      BL       memset
   \   0000015C   0x.... 0x....      LDR.W    R7,??DataTable226_18
   \   00000160   0x887A             LDRH     R2,[R7, #+2]
   \   00000162   0x4629             MOV      R1,R5
   \   00000164   0xA800             ADD      R0,SP,#+0
   \   00000166   0x.... 0x....      BL       sprintf
   \   0000016A   0x4631             MOV      R1,R6
   \   0000016C   0xA800             ADD      R0,SP,#+0
   \   0000016E   0x.... 0x....      BL       strcat
   \   00000172   0xA900             ADD      R1,SP,#+0
   \   00000174   0x4620             MOV      R0,R4
   \   00000176   0x.... 0x....      BL       f_printf
   \   0000017A   0x2214             MOVS     R2,#+20
   \   0000017C   0x2100             MOVS     R1,#+0
   \   0000017E   0xA800             ADD      R0,SP,#+0
   \   00000180   0x.... 0x....      BL       memset
   \   00000184   0x793A             LDRB     R2,[R7, #+4]
   \   00000186   0x4629             MOV      R1,R5
   \   00000188   0xA800             ADD      R0,SP,#+0
   \   0000018A   0x.... 0x....      BL       sprintf
   \   0000018E   0x4631             MOV      R1,R6
   \   00000190   0xA800             ADD      R0,SP,#+0
   \   00000192   0x.... 0x....      BL       strcat
   \   00000196   0xA900             ADD      R1,SP,#+0
   \   00000198   0x4620             MOV      R0,R4
   \   0000019A   0x.... 0x....      BL       f_printf
   \   0000019E   0x2214             MOVS     R2,#+20
   \   000001A0   0x2100             MOVS     R1,#+0
   \   000001A2   0xA800             ADD      R0,SP,#+0
   \   000001A4   0x.... 0x....      BL       memset
   \   000001A8   0xF997 0x2005      LDRSB    R2,[R7, #+5]
   \   000001AC   0x4629             MOV      R1,R5
   \   000001AE   0xA800             ADD      R0,SP,#+0
   \   000001B0   0x.... 0x....      BL       sprintf
   \   000001B4   0x4631             MOV      R1,R6
   \   000001B6   0xA800             ADD      R0,SP,#+0
   \   000001B8   0x.... 0x....      BL       strcat
   \   000001BC   0xA900             ADD      R1,SP,#+0
   \   000001BE   0x4620             MOV      R0,R4
   \   000001C0   0x.... 0x....      BL       f_printf
   \   000001C4   0x2214             MOVS     R2,#+20
   \   000001C6   0x2100             MOVS     R1,#+0
   \   000001C8   0xA800             ADD      R0,SP,#+0
   \   000001CA   0x.... 0x....      BL       memset
   \   000001CE   0x.... 0x....      LDR.W    R7,??DataTable225_1
   \   000001D2   0x6EFA             LDR      R2,[R7, #+108]
   \   000001D4   0x4629             MOV      R1,R5
   \   000001D6   0xA800             ADD      R0,SP,#+0
   \   000001D8   0x.... 0x....      BL       sprintf
   \   000001DC   0x4631             MOV      R1,R6
   \   000001DE   0xA800             ADD      R0,SP,#+0
   \   000001E0   0x.... 0x....      BL       strcat
   \   000001E4   0xA900             ADD      R1,SP,#+0
   \   000001E6   0x4620             MOV      R0,R4
   \   000001E8   0x.... 0x....      BL       f_printf
   \   000001EC   0x2214             MOVS     R2,#+20
   \   000001EE   0x2100             MOVS     R1,#+0
   \   000001F0   0xA800             ADD      R0,SP,#+0
   \   000001F2   0x.... 0x....      BL       memset
   \   000001F6   0x6DF8             LDR      R0,[R7, #+92]
   \   000001F8   0x.... 0x....      BL       __aeabi_f2d
   \   000001FC   0x4602             MOV      R2,R0
   \   000001FE   0x460B             MOV      R3,R1
   \   00000200   0x....             ADR.N    R1,??DataTable219  ;; 0x25, 0x66, 0x00, 0x00
   \   00000202   0xA800             ADD      R0,SP,#+0
   \   00000204   0x.... 0x....      BL       sprintf
   \   00000208   0x4631             MOV      R1,R6
   \   0000020A   0xA800             ADD      R0,SP,#+0
   \   0000020C   0x.... 0x....      BL       strcat
   \   00000210   0xA900             ADD      R1,SP,#+0
   \   00000212   0x4620             MOV      R0,R4
   \   00000214   0x.... 0x....      BL       f_printf
   \   00000218   0x2214             MOVS     R2,#+20
   \   0000021A   0x2100             MOVS     R1,#+0
   \   0000021C   0xA800             ADD      R0,SP,#+0
   \   0000021E   0x.... 0x....      BL       memset
   \   00000222   0x78FA             LDRB     R2,[R7, #+3]
   \   00000224   0x4629             MOV      R1,R5
   \   00000226   0xA800             ADD      R0,SP,#+0
   \   00000228   0x.... 0x....      BL       sprintf
   \   0000022C   0x4631             MOV      R1,R6
   \   0000022E   0xA800             ADD      R0,SP,#+0
   \   00000230   0x.... 0x....      BL       strcat
   \   00000234   0xA900             ADD      R1,SP,#+0
   \   00000236   0x4620             MOV      R0,R4
   \   00000238   0x.... 0x....      BL       f_printf
   \   0000023C   0x2214             MOVS     R2,#+20
   \   0000023E   0x2100             MOVS     R1,#+0
   \   00000240   0xA800             ADD      R0,SP,#+0
   \   00000242   0x.... 0x....      BL       memset
   \   00000246   0x2204             MOVS     R2,#+4
   \   00000248   0x....             ADR.N    R1,??DataTable220  ;; "end"
   \   0000024A   0xA800             ADD      R0,SP,#+0
   \   0000024C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000250   0x4631             MOV      R1,R6
   \   00000252   0xA800             ADD      R0,SP,#+0
   \   00000254   0x.... 0x....      BL       strcat
   \   00000258   0xA900             ADD      R1,SP,#+0
   \   0000025A   0x4620             MOV      R0,R4
   \   0000025C   0x.... 0x....      BL       f_printf
   \   00000260   0x4620             MOV      R0,R4
   \   00000262   0x.... 0x....      BL       f_close
   \                     ??mks_WriteToFile_1: (+1)
   \   00000266   0xB00E             ADD      SP,SP,#+56
   \   00000268   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_WriteToEpr_pwroff()
   \                     _Z21mks_WriteToEpr_pwroffv: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable220_1
   \   00000004   0x2201             MOVS     R2,#+1
   \   00000006   0xF504 0x612A      ADD      R1,R4,#+2720
   \   0000000A   0xF44F 0x6096      MOV      R0,#+1200
   \   0000000E   0x.... 0x....      BL       epr_write_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF604 0x21A8      ADDW     R1,R4,#+2728
   \   00000018   0xF240 0x40F5      MOVW     R0,#+1269
   \   0000001C   0x.... 0x....      BL       epr_write_data
   \   00000020   0x4620             MOV      R0,R4
   \   00000022   0x.... 0x....      BL       _ZN10CardReader8getsdposEv
   \   00000026   0xF8C4 0x0AA4      STR      R0,[R4, #+2724]
   \   0000002A   0xF604 0x25A4      ADDW     R5,R4,#+2724
   \   0000002E   0x2204             MOVS     R2,#+4
   \   00000030   0x4629             MOV      R1,R5
   \   00000032   0xF240 0x40B1      MOVW     R0,#+1201
   \   00000036   0x.... 0x....      BL       epr_write_data
   \   0000003A   0x.... 0x....      LDR.W    R6,??DataTable226_16
   \   0000003E   0x6830             LDR      R0,[R6, #+0]
   \   00000040   0x8268             STRH     R0,[R5, #+18]
   \   00000042   0x2202             MOVS     R2,#+2
   \   00000044   0xF604 0x21B6      ADDW     R1,R4,#+2742
   \   00000048   0xF240 0x40B5      MOVW     R0,#+1205
   \   0000004C   0x.... 0x....      BL       epr_write_data
   \   00000050   0x.... 0x....      LDR.W    R7,??DataTable223
   \   00000054   0xF897 0x00F7      LDRB     R0,[R7, #+247]
   \   00000058   0x2802             CMP      R0,#+2
   \   0000005A   0xD108             BNE.N    ??mks_WriteToEpr_pwroff_0
   \   0000005C   0x6870             LDR      R0,[R6, #+4]
   \   0000005E   0x82A8             STRH     R0,[R5, #+20]
   \   00000060   0x2202             MOVS     R2,#+2
   \   00000062   0xF604 0x21B8      ADDW     R1,R4,#+2744
   \   00000066   0xF240 0x40B7      MOVW     R0,#+1207
   \   0000006A   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_pwroff_0: (+1)
   \   0000006E   0xF897 0x0036      LDRB     R0,[R7, #+54]
   \   00000072   0x2800             CMP      R0,#+0
   \   00000074   0xD00A             BEQ.N    ??mks_WriteToEpr_pwroff_1
   \   00000076   0x.... 0x....      LDR.W    R0,??DataTable226_17
   \   0000007A   0x8800             LDRH     R0,[R0, #+0]
   \   0000007C   0x82E8             STRH     R0,[R5, #+22]
   \   0000007E   0x2202             MOVS     R2,#+2
   \   00000080   0xF604 0x21BA      ADDW     R1,R4,#+2746
   \   00000084   0xF240 0x40B9      MOVW     R0,#+1209
   \   00000088   0x.... 0x....      BL       epr_write_data
   \                     ??mks_WriteToEpr_pwroff_1: (+1)
   \   0000008C   0x.... 0x....      LDR.W    R6,??DataTable226_18
   \   00000090   0x2202             MOVS     R2,#+2
   \   00000092   0x1CB1             ADDS     R1,R6,#+2
   \   00000094   0xF44F 0x609E      MOV      R0,#+1264
   \   00000098   0x.... 0x....      BL       epr_write_data
   \   0000009C   0x2201             MOVS     R2,#+1
   \   0000009E   0x1D31             ADDS     R1,R6,#+4
   \   000000A0   0xF240 0x40F2      MOVW     R0,#+1266
   \   000000A4   0x.... 0x....      BL       epr_write_data
   \   000000A8   0x2201             MOVS     R2,#+1
   \   000000AA   0x1D71             ADDS     R1,R6,#+5
   \   000000AC   0xF240 0x40F3      MOVW     R0,#+1267
   \   000000B0   0x.... 0x....      BL       epr_write_data
   \   000000B4   0x.... 0x....      LDR.W    R6,??DataTable225_1
   \   000000B8   0x6EF0             LDR      R0,[R6, #+108]
   \   000000BA   0x7728             STRB     R0,[R5, #+28]
   \   000000BC   0x2201             MOVS     R2,#+1
   \   000000BE   0xF504 0x612C      ADD      R1,R4,#+2752
   \   000000C2   0xF240 0x40DF      MOVW     R0,#+1247
   \   000000C6   0x.... 0x....      BL       epr_write_data
   \   000000CA   0x6DF0             LDR      R0,[R6, #+92]
   \   000000CC   0x61A8             STR      R0,[R5, #+24]
   \   000000CE   0x2204             MOVS     R2,#+4
   \   000000D0   0xF604 0x21BC      ADDW     R1,R4,#+2748
   \   000000D4   0xF240 0x40DB      MOVW     R0,#+1243
   \   000000D8   0x.... 0x....      BL       epr_write_data
   \   000000DC   0x2201             MOVS     R2,#+1
   \   000000DE   0x1CF1             ADDS     R1,R6,#+3
   \   000000E0   0xF240 0x40F4      MOVW     R0,#+1268
   \   000000E4   0xE8BD 0x40F8      POP      {R3-R7,LR}
   \   000000E8   0x.... 0x....      B.W      epr_write_data

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_ReadFromEpr_pwroff()
   \                     _Z22mks_ReadFromEpr_pwroffv: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x....             LDR.N    R4,??DataTable220_1
   \   00000004   0x2296             MOVS     R2,#+150
   \   00000006   0xF604 0x11D4      ADDW     R1,R4,#+2516
   \   0000000A   0xF240 0x40FD      MOVW     R0,#+1277
   \   0000000E   0x.... 0x....      BL       epr_read_data
   \   00000012   0x2204             MOVS     R2,#+4
   \   00000014   0xF604 0x21AC      ADDW     R1,R4,#+2732
   \   00000018   0xF240 0x40B1      MOVW     R0,#+1201
   \   0000001C   0x.... 0x....      BL       epr_read_data
   \   00000020   0x2204             MOVS     R2,#+4
   \   00000022   0xF604 0x21A8      ADDW     R1,R4,#+2728
   \   00000026   0xF240 0x40F5      MOVW     R0,#+1269
   \   0000002A   0x.... 0x....      BL       epr_read_data
   \   0000002E   0x2202             MOVS     R2,#+2
   \   00000030   0xF604 0x21B6      ADDW     R1,R4,#+2742
   \   00000034   0xF240 0x40B5      MOVW     R0,#+1205
   \   00000038   0x.... 0x....      BL       epr_read_data
   \   0000003C   0x....             LDR.N    R5,??DataTable223
   \   0000003E   0xF895 0x00F7      LDRB     R0,[R5, #+247]
   \   00000042   0x2802             CMP      R0,#+2
   \   00000044   0xD106             BNE.N    ??mks_ReadFromEpr_pwroff_0
   \   00000046   0x2202             MOVS     R2,#+2
   \   00000048   0xF604 0x21B8      ADDW     R1,R4,#+2744
   \   0000004C   0xF240 0x40B7      MOVW     R0,#+1207
   \   00000050   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_pwroff_0: (+1)
   \   00000054   0xF895 0x0036      LDRB     R0,[R5, #+54]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD006             BEQ.N    ??mks_ReadFromEpr_pwroff_1
   \   0000005C   0x2202             MOVS     R2,#+2
   \   0000005E   0xF604 0x21BA      ADDW     R1,R4,#+2746
   \   00000062   0xF240 0x40B9      MOVW     R0,#+1209
   \   00000066   0x.... 0x....      BL       epr_read_data
   \                     ??mks_ReadFromEpr_pwroff_1: (+1)
   \   0000006A   0x.... 0x....      LDR.W    R5,??DataTable226_18
   \   0000006E   0x2202             MOVS     R2,#+2
   \   00000070   0x1CA9             ADDS     R1,R5,#+2
   \   00000072   0xF44F 0x609E      MOV      R0,#+1264
   \   00000076   0x.... 0x....      BL       epr_read_data
   \   0000007A   0x2201             MOVS     R2,#+1
   \   0000007C   0x1D29             ADDS     R1,R5,#+4
   \   0000007E   0xF240 0x40F2      MOVW     R0,#+1266
   \   00000082   0x.... 0x....      BL       epr_read_data
   \   00000086   0x2201             MOVS     R2,#+1
   \   00000088   0x1D69             ADDS     R1,R5,#+5
   \   0000008A   0xF240 0x40F3      MOVW     R0,#+1267
   \   0000008E   0x.... 0x....      BL       epr_read_data
   \   00000092   0x2201             MOVS     R2,#+1
   \   00000094   0xF504 0x612C      ADD      R1,R4,#+2752
   \   00000098   0xF240 0x40DF      MOVW     R0,#+1247
   \   0000009C   0x.... 0x....      BL       epr_read_data
   \   000000A0   0x2204             MOVS     R2,#+4
   \   000000A2   0xF604 0x21BC      ADDW     R1,R4,#+2748
   \   000000A6   0xF240 0x40DB      MOVW     R0,#+1243
   \   000000AA   0x.... 0x....      BL       epr_read_data
   \   000000AE   0x....             LDR.N    R4,??DataTable225_1
   \   000000B0   0x2201             MOVS     R2,#+1
   \   000000B2   0x1CE1             ADDS     R1,R4,#+3
   \   000000B4   0xF240 0x40F4      MOVW     R0,#+1268
   \   000000B8   0x.... 0x....      BL       epr_read_data
   \   000000BC   0xF994 0x0003      LDRSB    R0,[R4, #+3]
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable226_12
   \   000000C4   0xF881 0x009C      STRB     R0,[R1, #+156]
   \   000000C8   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp int16_t pft_get()
   \                     _Z7pft_getv: (+1)
   \   00000000   0xB51C             PUSH     {R2-R4,LR}
   \   00000002   0x.... 0x....      LDR.W    R4,??DataTable226_11
   \   00000006   0xAB01             ADD      R3,SP,#+4
   \   00000008   0x2201             MOVS     R2,#+1
   \   0000000A   0xA900             ADD      R1,SP,#+0
   \   0000000C   0xF604 0x3038      ADDW     R0,R4,#+2872
   \   00000010   0x.... 0x....      BL       f_read
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??pft_get_0
   \   00000018   0x20FF             MOVS     R0,#+255
   \   0000001A   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   0000001E   0xE005             B.N      ??pft_get_1
   \                     ??pft_get_0: (+1)
   \   00000020   0xF8D4 0x0AB0      LDR      R0,[R4, #+2736]
   \   00000024   0x9901             LDR      R1,[SP, #+4]
   \   00000026   0x1808             ADDS     R0,R1,R0
   \   00000028   0xF8C4 0x0AB0      STR      R0,[R4, #+2736]
   \                     ??pft_get_1: (+1)
   \   0000002C   0xF89D 0x0000      LDRB     R0,[SP, #+0]
   \   00000030   0xBD16             POP      {R1,R2,R4,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp bool mks_get_commands()
   \                     _Z16mks_get_commandsv: (+1)
   \   00000000   0xE92D 0x41F0      PUSH     {R4-R8,LR}
   \   00000004   0xB086             SUB      SP,SP,#+24
   \   00000006   0x2500             MOVS     R5,#+0
   \   00000008   0x46A8             MOV      R8,R5
   \   0000000A   0x462C             MOV      R4,R5
   \   0000000C   0x....             LDR.N    R7,??DataTable220_1
   \   0000000E   0xE00E             B.N      ??mks_get_commands_1

  				gCfgItems.curSprayerChoose = atof(string);
  				                           ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1999  Warning[Pa093]: 
          implicit conversion from floating point to integer
   \                     ??mks_get_commands_2: (+1)
   \   00000010   0x....             ADR.N    R1,??DataTable220  ;; "end"
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       strcmp
   \   00000018   0x2800             CMP      R0,#+0
   \   0000001A   0xD100             BNE.N    ??mks_get_commands_3
   \   0000001C   0x2401             MOVS     R4,#+1
   \                     ??mks_get_commands_3: (+1)
   \   0000001E   0xF04F 0x0800      MOV      R8,#+0
   \   00000022   0x2214             MOVS     R2,#+20
   \   00000024   0x4641             MOV      R1,R8
   \   00000026   0xA800             ADD      R0,SP,#+0
   \   00000028   0x.... 0x....      BL       memset
   \   0000002C   0x1C6D             ADDS     R5,R5,#+1
   \                     ??mks_get_commands_1: (+1)
   \   0000002E   0xF607 0x26A4      ADDW     R6,R7,#+2724
   \   00000032   0x68F0             LDR      R0,[R6, #+12]
   \   00000034   0xF8D7 0x1D64      LDR      R1,[R7, #+3428]
   \   00000038   0x4288             CMP      R0,R1
   \   0000003A   0xD26A             BCS.N    ??mks_get_commands_4
   \   0000003C   0x.... 0x....      BL       _Z7pft_getv
   \   00000040   0xF110 0x0F01      CMN      R0,#+1
   \   00000044   0xD065             BEQ.N    ??mks_get_commands_4
   \   00000046   0x4641             MOV      R1,R8
   \   00000048   0xB240             SXTB     R0,R0
   \   0000004A   0x280A             CMP      R0,#+10
   \   0000004C   0xD158             BNE.N    ??mks_get_commands_5
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0xAA00             ADD      R2,SP,#+0
   \   00000052   0x1889             ADDS     R1,R1,R2
   \   00000054   0xF801 0x0C01      STRB     R0,[R1, #-1]
   \   00000058   0xB26D             SXTB     R5,R5
   \   0000005A   0x4628             MOV      R0,R5
   \   0000005C   0x1E40             SUBS     R0,R0,#+1
   \   0000005E   0x280B             CMP      R0,#+11
   \   00000060   0xD8DD             BHI.N    ??mks_get_commands_3
   \   00000062   0xE8DF 0xF000      TBB      [PC, R0]
   \                     ??mks_get_commands_0:
   \   00000066   0x08 0x0E          DC8      0x8,0xE,0x13,0x18
   \              0x13 0x18    
   \   0000006A   0x1D 0x22          DC8      0x1D,0x22,0x28,0x2E
   \              0x28 0x2E    
   \   0000006E   0x34 0x39          DC8      0x34,0x39,0x40,0x6
   \              0x40 0x06    
   \                     ??mks_get_commands_6: (+1)
   \   00000072   0xE7CD             B.N      ??mks_get_commands_2
   \                     ??mks_get_commands_7: (+1)
   \   00000074   0xE7D3             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_8: (+1)
   \   00000076   0xA800             ADD      R0,SP,#+0
   \   00000078   0x.... 0x....      BL       atoi
   \   0000007C   0xF8C7 0x0AA4      STR      R0,[R7, #+2724]
   \   00000080   0xE7CD             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_9: (+1)
   \   00000082   0xA800             ADD      R0,SP,#+0
   \   00000084   0x.... 0x....      BL       atoi
   \   00000088   0x8270             STRH     R0,[R6, #+18]
   \   0000008A   0xE7C8             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_10: (+1)
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       atoi
   \   00000092   0x82B0             STRH     R0,[R6, #+20]
   \   00000094   0xE7C3             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_11: (+1)
   \   00000096   0xA800             ADD      R0,SP,#+0
   \   00000098   0x.... 0x....      BL       atoi
   \   0000009C   0x82F0             STRH     R0,[R6, #+22]
   \   0000009E   0xE7BE             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_12: (+1)
   \   000000A0   0xA800             ADD      R0,SP,#+0
   \   000000A2   0x.... 0x....      BL       atoi
   \   000000A6   0x6230             STR      R0,[R6, #+32]
   \   000000A8   0xE7B9             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_13: (+1)
   \   000000AA   0xA800             ADD      R0,SP,#+0
   \   000000AC   0x.... 0x....      BL       atoi
   \   000000B0   0x....             LDR.N    R1,??DataTable226_18
   \   000000B2   0x8048             STRH     R0,[R1, #+2]
   \   000000B4   0xE7B3             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_14: (+1)
   \   000000B6   0xA800             ADD      R0,SP,#+0
   \   000000B8   0x.... 0x....      BL       atoi
   \   000000BC   0x....             LDR.N    R1,??DataTable226_18
   \   000000BE   0x7108             STRB     R0,[R1, #+4]
   \   000000C0   0xE7AD             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_15: (+1)
   \   000000C2   0xA800             ADD      R0,SP,#+0
   \   000000C4   0x.... 0x....      BL       atoi
   \   000000C8   0x....             LDR.N    R1,??DataTable226_18
   \   000000CA   0x7148             STRB     R0,[R1, #+5]
   \   000000CC   0xE7A7             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_16: (+1)
   \   000000CE   0xA800             ADD      R0,SP,#+0
   \   000000D0   0x.... 0x....      BL       atoi
   \   000000D4   0x7730             STRB     R0,[R6, #+28]
   \   000000D6   0xE7A2             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_17: (+1)
   \   000000D8   0xA800             ADD      R0,SP,#+0
   \   000000DA   0x.... 0x....      BL       atof
   \   000000DE   0x.... 0x....      BL       __aeabi_d2f
   \   000000E2   0x61B0             STR      R0,[R6, #+24]
   \   000000E4   0xE79B             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_18: (+1)
   \   000000E6   0x....             LDR.N    R6,??DataTable225
   \   000000E8   0xA800             ADD      R0,SP,#+0
   \   000000EA   0x.... 0x....      BL       atof
   \   000000EE   0x.... 0x....      BL       __aeabi_d2iz
   \   000000F2   0xF886 0x009C      STRB     R0,[R6, #+156]
   \   000000F6   0xF896 0x009C      LDRB     R0,[R6, #+156]
   \   000000FA   0x....             LDR.N    R1,??DataTable225_1
   \   000000FC   0x70C8             STRB     R0,[R1, #+3]
   \   000000FE   0xE78E             B.N      ??mks_get_commands_3
   \                     ??mks_get_commands_5: (+1)
   \   00000100   0xAA00             ADD      R2,SP,#+0
   \   00000102   0x5488             STRB     R0,[R1, R2]
   \   00000104   0xF108 0x0801      ADD      R8,R8,#+1
   \   00000108   0xFA1F 0xF888      UXTH     R8,R8
   \   0000010C   0xF1B8 0x0F14      CMP      R8,#+20
   \   00000110   0xDB8D             BLT.N    ??mks_get_commands_1
   \                     ??mks_get_commands_4: (+1)
   \   00000112   0x4620             MOV      R0,R4
   \   00000114   0xB006             ADD      SP,SP,#+24
   \   00000116   0xE8BD 0x81F0      POP      {R4-R8,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp bool mks_ReadFromFile()
   \                     mks_ReadFromFile: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB088             SUB      SP,SP,#+32
   \   00000004   0x2400             MOVS     R4,#+0
   \   00000006   0xA800             ADD      R0,SP,#+0
   \   00000008   0x2120             MOVS     R1,#+32
   \   0000000A   0x.... 0x....      BL       __aeabi_memclr4
   \   0000000E   0x....             LDR.N    R5,??DataTable226_11
   \   00000010   0xF895 0x09BB      LDRB     R0,[R5, #+2491]
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD003             BEQ.N    ??mks_ReadFromFile_0
   \   00000018   0x....             LDR.N    R1,??DataTable226_14
   \   0000001A   0xA800             ADD      R0,SP,#+0
   \   0000001C   0x.... 0x....      BL       strcat
   \                     ??mks_ReadFromFile_0: (+1)
   \   00000020   0x....             LDR.N    R0,??DataTable226_15
   \   00000022   0x6801             LDR      R1,[R0, #+0]
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       strcat
   \   0000002A   0xF605 0x3638      ADDW     R6,R5,#+2872
   \   0000002E   0x2201             MOVS     R2,#+1
   \   00000030   0xA900             ADD      R1,SP,#+0
   \   00000032   0x4630             MOV      R0,R6
   \   00000034   0x.... 0x....      BL       f_open
   \   00000038   0x2800             CMP      R0,#+0
   \   0000003A   0xD10C             BNE.N    ??mks_ReadFromFile_1
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xF8C5 0x0AB0      STR      R0,[R5, #+2736]
   \   00000042   0xF8D5 0x0D44      LDR      R0,[R5, #+3396]
   \   00000046   0xF8C5 0x0D64      STR      R0,[R5, #+3428]
   \   0000004A   0x.... 0x....      BL       _Z16mks_get_commandsv
   \   0000004E   0x4604             MOV      R4,R0
   \   00000050   0x4630             MOV      R0,R6
   \   00000052   0x.... 0x....      BL       f_close
   \                     ??mks_ReadFromFile_1: (+1)
   \   00000056   0x4620             MOV      R0,R4
   \   00000058   0xB008             ADD      SP,SP,#+32
   \   0000005A   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_clearFile()
   \                     mks_clearFile: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB08E             SUB      SP,SP,#+56
   \   00000004   0xA808             ADD      R0,SP,#+32
   \   00000006   0x.... 0x....      ADR.W    R1,`?<Constant "clear">`
   \   0000000A   0x2214             MOVS     R2,#+20
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy4
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x2120             MOVS     R1,#+32
   \   00000014   0x.... 0x....      BL       __aeabi_memclr4
   \   00000018   0x....             LDR.N    R4,??DataTable226_11
   \   0000001A   0xF894 0x09BB      LDRB     R0,[R4, #+2491]
   \   0000001E   0x2800             CMP      R0,#+0
   \   00000020   0xD003             BEQ.N    ??mks_clearFile_0
   \   00000022   0x....             LDR.N    R1,??DataTable226_14
   \   00000024   0xA800             ADD      R0,SP,#+0
   \   00000026   0x.... 0x....      BL       strcat
   \                     ??mks_clearFile_0: (+1)
   \   0000002A   0x....             LDR.N    R0,??DataTable226_15
   \   0000002C   0x6801             LDR      R1,[R0, #+0]
   \   0000002E   0xA800             ADD      R0,SP,#+0
   \   00000030   0x.... 0x....      BL       strcat
   \   00000034   0xF604 0x3438      ADDW     R4,R4,#+2872
   \   00000038   0x220A             MOVS     R2,#+10
   \   0000003A   0xA900             ADD      R1,SP,#+0
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0x.... 0x....      BL       f_open
   \   00000042   0x2800             CMP      R0,#+0
   \   00000044   0xD106             BNE.N    ??mks_clearFile_1
   \   00000046   0xA908             ADD      R1,SP,#+32
   \   00000048   0x4620             MOV      R0,R4
   \   0000004A   0x.... 0x....      BL       f_printf
   \   0000004E   0x4620             MOV      R0,R4
   \   00000050   0x.... 0x....      BL       f_close
   \                     ??mks_clearFile_1: (+1)
   \   00000054   0xB00E             ADD      SP,SP,#+56
   \   00000056   0xBD10             POP      {R4,PC}          ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_saveFileName(char *)
   \                     mks_saveFileName: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x....             LDR.N    R5,??DataTable226_11
   \   00000006   0x2296             MOVS     R2,#+150
   \   00000008   0x2100             MOVS     R1,#+0
   \   0000000A   0xF605 0x10D4      ADDW     R0,R5,#+2516
   \   0000000E   0x.... 0x....      BL       memset
   \   00000012   0x4621             MOV      R1,R4
   \   00000014   0xF605 0x10D4      ADDW     R0,R5,#+2516
   \   00000018   0x.... 0x....      BL       strcpy
   \   0000001C   0x2296             MOVS     R2,#+150
   \   0000001E   0xF605 0x11D4      ADDW     R1,R5,#+2516
   \   00000022   0xF240 0x40FD      MOVW     R0,#+1277
   \   00000026   0x.... 0x....      BL       epr_write_data
   \   0000002A   0xF895 0x0AA0      LDRB     R0,[R5, #+2720]
   \   0000002E   0x28A6             CMP      R0,#+166
   \   00000030   0xD107             BNE.N    ??mks_saveFileName_0
   \   00000032   0x....             LDR.N    R0,??DataTable226_12
   \   00000034   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD002             BEQ.N    ??mks_saveFileName_0
   \   0000003C   0xE8BD 0x4031      POP      {R0,R4,R5,LR}
   \   00000040   0x....             B.N      mks_clearFile
   \                     ??mks_saveFileName_0: (+1)
   \   00000042   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_adjust_extrude_speed()
   \                     mks_adjust_extrude_speed: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable225
   \   00000002   0xF9B0 0x12A0      LDRSH    R1,[R0, #+672]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD100             BNE.N    ??mks_adjust_extrude_speed_0
   \   0000000A   0x4770             BX       LR
   \                     ??mks_adjust_extrude_speed_0: (+1)
   \   0000000C   0xB570             PUSH     {R4-R6,LR}
   \   0000000E   0x....             LDR.N    R4,??DataTable226_19
   \   00000010   0x7CA1             LDRB     R1,[R4, #+18]
   \   00000012   0x2901             CMP      R1,#+1
   \   00000014   0xD024             BEQ.N    ??mks_adjust_extrude_speed_1
   \   00000016   0x....             LDR.N    R5,??DataTable226_20
   \   00000018   0xF9B5 0x1000      LDRSH    R1,[R5, #+0]
   \   0000001C   0xF240 0x32E7      MOVW     R2,#+999
   \   00000020   0xF9B0 0x32A0      LDRSH    R3,[R0, #+672]
   \   00000024   0x1AD2             SUBS     R2,R2,R3
   \   00000026   0x4291             CMP      R1,R2
   \   00000028   0xDA04             BGE.N    ??mks_adjust_extrude_speed_2
   \   0000002A   0xF8B0 0x02A0      LDRH     R0,[R0, #+672]
   \   0000002E   0x1840             ADDS     R0,R0,R1
   \   00000030   0x8028             STRH     R0,[R5, #+0]
   \   00000032   0xE002             B.N      ??mks_adjust_extrude_speed_3
   \                     ??mks_adjust_extrude_speed_2: (+1)
   \   00000034   0xF240 0x30E7      MOVW     R0,#+999
   \   00000038   0x8028             STRH     R0,[R5, #+0]
   \                     ??mks_adjust_extrude_speed_3: (+1)
   \   0000003A   0xF9B5 0x6000      LDRSH    R6,[R5, #+0]
   \   0000003E   0x4630             MOV      R0,R6
   \   00000040   0x.... 0x....      BL       __aeabi_i2d
   \   00000044   0x....             LDR.N    R2,??DataTable226_21  ;; 0x47ae147b
   \   00000046   0x....             LDR.N    R3,??DataTable226_22  ;; 0x3f847ae1
   \   00000048   0x.... 0x....      BL       __aeabi_dmul
   \   0000004C   0x.... 0x....      BL       __aeabi_d2f
   \   00000050   0x....             LDR.N    R1,??DataTable226_23
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \   00000054   0x806E             STRH     R6,[R5, #+2]
   \   00000056   0x6048             STR      R0,[R1, #+4]
   \   00000058   0x2001             MOVS     R0,#+1
   \   0000005A   0x74A0             STRB     R0,[R4, #+18]
   \   0000005C   0x2000             MOVS     R0,#+0
   \   0000005E   0x83E0             STRH     R0,[R4, #+30]
   \                     ??mks_adjust_extrude_speed_1: (+1)
   \   00000060   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .text, align 2, keep-with-next
   \   __interwork __softfp void mks_resume_extrude_speed()
   \                     mks_resume_extrude_speed: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable225
   \   00000002   0xF9B0 0x12A0      LDRSH    R1,[R0, #+672]
   \   00000006   0x2900             CMP      R1,#+0
   \   00000008   0xD100             BNE.N    ??mks_resume_extrude_speed_0
   \   0000000A   0x4770             BX       LR
   \                     ??mks_resume_extrude_speed_0: (+1)
   \   0000000C   0xB538             PUSH     {R3-R5,LR}
   \   0000000E   0x....             LDR.N    R4,??DataTable226_20
   \   00000010   0x8821             LDRH     R1,[R4, #+0]
   \   00000012   0xF8B0 0x02A0      LDRH     R0,[R0, #+672]
   \   00000016   0x1A0D             SUBS     R5,R1,R0
   \   00000018   0x8025             STRH     R5,[R4, #+0]
   \   0000001A   0xB22D             SXTH     R5,R5
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0x.... 0x....      BL       __aeabi_i2d
   \   00000022   0x....             LDR.N    R2,??DataTable226_21  ;; 0x47ae147b
   \   00000024   0x....             LDR.N    R3,??DataTable226_22  ;; 0x3f847ae1
   \   00000026   0x.... 0x....      BL       __aeabi_dmul
   \   0000002A   0x.... 0x....      BL       __aeabi_d2f
   \   0000002E   0x....             LDR.N    R1,??DataTable226_23
   \   00000030   0x6008             STR      R0,[R1, #+0]
   \   00000032   0x8065             STRH     R5,[R4, #+2]
   \   00000034   0x6048             STR      R0,[R1, #+4]
   \   00000036   0x2000             MOVS     R0,#+0
   \   00000038   0x....             LDR.N    R1,??DataTable226_19
   \   0000003A   0x7488             STRB     R0,[R1, #+18]
   \   0000003C   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void EXTI9_5_IRQHandler()
   \                     EXTI9_5_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   \   00000002   0x2000             MOVS     R0,#+0
   \   00000004   0x....             LDR.N    R1,??DataTable226_24  ;; 0x422281b4
   \   00000006   0x6008             STR      R0,[R1, #+0]
   \   00000008   0x....             LDR.N    R0,??DataTable226_25  ;; 0x40010414
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0689             LSLS     R1,R1,#+26
   \   0000000E   0xD522             BPL.N    ??EXTI9_5_IRQHandler_0
   \   00000010   0x2120             MOVS     R1,#+32
   \   00000012   0x6001             STR      R1,[R0, #+0]
   \   00000014   0x....             LDR.N    R0,??DataTable226_11
   \   00000016   0xF890 0x0AA0      LDRB     R0,[R0, #+2720]
   \   0000001A   0x28A6             CMP      R0,#+166
   \   0000001C   0xD005             BEQ.N    ??EXTI9_5_IRQHandler_1

  		||(mksReprint.mks_printer_state == MKS_REPRINTING))
  		^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",2153  Warning[Pa134]: 
          left and right operands are identical

  static uint32_t After_finish_print_time = 0;
                  ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp",303  Warning[Pe177]: 
          variable "After_finish_print_time" was declared but never referenced

  static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
                                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp",456  Warning[Pe550]: 
          variable "Stopped_gcode_LastN" was set but never used

  static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp",828  Warning[Pe177]: 
          function "pgm_read_any(signed char const *)" was declared but never
          referenced

  static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
                      ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp",827  Warning[Pe177]: 
          function "pgm_read_any(float const *)" was declared but never
          referenced

      static bool blocks_queued() { return (block_buffer_head != block_buffer_tail); }
                                    ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\planner.h",549  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                            z_dest[k++]=*ZPOS_TEMP;
                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1329  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement

                            z_dest[k++]=*ZPOS_TEMP;
                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_reprint.cpp",1395  Warning[Pa082]: 
          undefined behavior: the order of volatile accesses is undefined in
          this statement
   \   0000001E   0x28AB             CMP      R0,#+171
   \   00000020   0xD003             BEQ.N    ??EXTI9_5_IRQHandler_1
   \   00000022   0x28A9             CMP      R0,#+169
   \   00000024   0xD001             BEQ.N    ??EXTI9_5_IRQHandler_1
   \   00000026   0x28AA             CMP      R0,#+170
   \   00000028   0xD103             BNE.N    ??EXTI9_5_IRQHandler_2
   \                     ??EXTI9_5_IRQHandler_1: (+1)
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x....             LDR.N    R1,??DataTable226_26  ;; 0x422381a8
   \   0000002E   0x6008             STR      R0,[R1, #+0]
   \   00000030   0xBD01             POP      {R0,PC}
   \                     ??EXTI9_5_IRQHandler_2: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable226_12
   \   00000034   0xF890 0x019F      LDRB     R0,[R0, #+415]
   \   00000038   0x2801             CMP      R0,#+1
   \   0000003A   0xD10C             BNE.N    ??EXTI9_5_IRQHandler_0
   \   0000003C   0x2000             MOVS     R0,#+0
   \   0000003E   0x....             LDR.N    R1,??DataTable226_27  ;; 0x42210180
   \   00000040   0x6008             STR      R0,[R1, #+0]
   \   00000042   0x.... 0x....      BL       _Z21mks_WriteToEpr_pwroffv
   \   00000046   0xF44F 0x707A      MOV      R0,#+1000
   \   0000004A   0x.... 0x....      BL       HAL_Delay
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x....             LDR.N    R1,??DataTable226_26  ;; 0x422381a8
   \   00000052   0x6008             STR      R0,[R1, #+0]
   \                     ??EXTI9_5_IRQHandler_3: (+1)
   \   00000054   0xE7FE             B.N      ??EXTI9_5_IRQHandler_3
   \                     ??EXTI9_5_IRQHandler_0: (+1)
   \   00000056   0xB662             cpsie i
   \   00000058   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "enqueueing \\"">`:
   \   00000000   0x65 0x6E          DC8 "enqueueing \""
   \              0x71 0x75    
   \              0x65 0x75    
   \              0x65 0x69    
   \              0x6E 0x67    
   \              0x20 0x22    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "sd:%d">`:
   \   00000000   0x73 0x64          DC8 "sd:%d"
   \              0x3A 0x25    
   \              0x64 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Invalid extruder ">`:
   \   00000000   0x20 0x49          DC8 " Invalid extruder "
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x65    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x20    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "*** Z HOMED TO ENDSTO...">`:
   \   00000000   0x2A 0x2A          DC8 "*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***\012"
   \              0x2A 0x20    
   \              0x5A 0x20    
   \              0x48 0x4F    
   \              0x4D 0x45    
   \              0x44 0x20    
   \              0x54 0x4F    
   \              0x20 0x45    
   \              0x4E 0x44    
   \              0x53 0x54    
   \              0x4F 0x50    
   \              0x20 0x28    
   \              0x5A 0x5F    
   \              0x4D 0x49    
   \              0x4E 0x5F    
   \              0x50 0x52    
   \              0x4F 0x42    
   \              0x45 0x5F    
   \              0x45 0x4E    
   \              0x44 0x53    
   \              0x54 0x4F    
   \              0x50 0x29    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Home ">`:
   \   00000000   0x48 0x6F          DC8 "Home "
   \              0x6D 0x65    
   \              0x20 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " first\\n">`:
   \   00000000   0x20 0x66          DC8 " first\012"
   \              0x69 0x72    
   \              0x73 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "STOP called because o...">`:
   \   00000000   0x53 0x54          DC8 53H, 54H, 4FH, 50H, 20H, 63H, 61H, 6CH
   \              0x4F 0x50    
   \              0x20 0x63    
   \              0x61 0x6C    
   \   00000008   0x6C 0x65          DC8 6CH, 65H, 64H, 20H, 62H, 65H, 63H, 61H
   \              0x64 0x20    
   \              0x62 0x65    
   \              0x63 0x61    
   \   00000010   0x75 0x73          DC8 75H, 73H, 65H, 20H, 6FH, 66H, 20H, 42H
   \              0x65 0x20    
   \              0x6F 0x66    
   \              0x20 0x42    
   \   00000018   0x4C 0x54          DC8 4CH, 54H, 6FH, 75H, 63H, 68H, 20H, 65H
   \              0x6F 0x75    
   \              0x63 0x68    
   \              0x20 0x65    
   \   00000020   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 20H, 2DH, 20H, 72H
   \              0x6F 0x72    
   \              0x20 0x2D    
   \              0x20 0x72    
   \   00000028   0x65 0x73          DC8 65H, 73H, 74H, 61H, 72H, 74H, 20H, 77H
   \              0x74 0x61    
   \              0x72 0x74    
   \              0x20 0x77    
   \   00000030   0x69 0x74          DC8 69H, 74H, 68H, 20H, 4DH, 39H, 39H, 39H
   \              0x68 0x20    
   \              0x4D 0x39    
   \              0x39 0x39    
   \   00000038   0x0A 0x00          DC8 0AH, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134:
   \   00000000   0x58 0x00          DC8      "X",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_1:
   \   00000000   0x59 0x00          DC8      "Y",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_2:
   \   00000000   0x5A 0x00          DC8      "Z",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_3:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_4:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_6:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_7:
   \   00000000   0x43160000         DC32     0x43160000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_8:
   \   00000000   0x........         DC32     home_dir_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable134_9:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable135:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Bed X: ">`:
   \   00000000   0x42 0x65          DC8 "Bed X: "
   \              0x64 0x20    
   \              0x58 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Y: ">`:
   \   00000000   0x20 0x59          DC8 " Y: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Z: ">`:
   \   00000000   0x20 0x5A          DC8 " Z: "
   \              0x3A 0x20    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Probing failed">`:
   \   00000000   0x50 0x72          DC8 "Probing failed"
   \              0x6F 0x62    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Probing failed\\n">`:
   \   00000000   0x50 0x72          DC8 "Probing failed\012"
   \              0x6F 0x62    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137:
   \   00000000   0x........         DC32     home_bump_mm_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137_1:
   \   00000000   0x........         DC32     injected_commands_P

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137_2:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137_3:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137_4:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable137_5:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant {(-9.9999990233E+3F), (-9.999999023`:
   \   00000000   0xC61C3FFF         DC32 0C61C3FFFH, 0C61C3FFFH, 0H
   \              0xC61C3FFF   
   \              0x00000000   

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable139_1:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable143:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Bilinear Leveling Grid:\\n">`:
   \   00000000   0x42 0x69          DC8 "Bilinear Leveling Grid:\012"
   \              0x6C 0x69    
   \              0x6E 0x65    
   \              0x61 0x72    
   \              0x20 0x4C    
   \              0x65 0x76    
   \              0x65 0x6C    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x47 0x72    
   \              0x69 0x64    
   \              0x3A 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable144:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145:
   \   00000000   0x........         DC32     mks_heating_busy+0x10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_1:
   \   00000000   0x........         DC32     saved_feedrate_percentage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_2:
   \   00000000   0x40012C34         DC32     0x40012c34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_3:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable145_4:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable146:
   \   00000000   0x........         DC32     _ZN8Endstops15z_probe_enabledE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable148:
   \   00000000   0x........         DC32     _ZN8Endstops16endstop_hit_bitsE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "busy: processing\\n">`:
   \   00000000   0x62 0x75          DC8 "busy: processing\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x72    
   \              0x6F 0x63    
   \              0x65 0x73    
   \              0x73 0x69    
   \              0x6E 0x67    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "busy: paused for user\\n">`:
   \   00000000   0x62 0x75          DC8 "busy: paused for user\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x61    
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x75    
   \              0x73 0x65    
   \              0x72 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "busy: paused for input\\n">`:
   \   00000000   0x62 0x75          DC8 "busy: paused for input\012"
   \              0x73 0x79    
   \              0x3A 0x20    
   \              0x70 0x61    
   \              0x75 0x73    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x6F 0x72    
   \              0x20 0x69    
   \              0x6E 0x70    
   \              0x75 0x74    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149:
   \   00000000   0xC1200000         DC32     0xc1200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable149_2:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable150:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "?Probe ">`:
   \   00000000   0x3F 0x50          DC8 "?Probe "
   \              0x72 0x6F    
   \              0x62 0x65    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " position out of range.\\n">`:
   \   00000000   0x20 0x70          DC8 " position out of range.\012"
   \              0x6F 0x73    
   \              0x69 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x6F 0x75    
   \              0x74 0x20    
   \              0x6F 0x66    
   \              0x20 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " not entered.\\n">`:
   \   00000000   0x20 0x6E          DC8 " not entered.\012"
   \              0x6F 0x74    
   \              0x20 0x65    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x65 0x64    
   \              0x2E 0x0A    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling8has_meshE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable151_1:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Num X,Y: ">`:
   \   00000000   0x4E 0x75          DC8 "Num X,Y: "
   \              0x6D 0x20    
   \              0x58 0x2C    
   \              0x59 0x3A    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Z offset: ">`:
   \   00000000   0x5A 0x20          DC8 "Z offset: "
   \              0x6F 0x66    
   \              0x66 0x73    
   \              0x65 0x74    
   \              0x3A 0x20    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "\\nMeasured points:\\n">`:
   \   00000000   0x0A 0x4D          DC8 "\012Measured points:\012"
   \              0x65 0x61    
   \              0x73 0x75    
   \              0x72 0x65    
   \              0x64 0x20    
   \              0x70 0x6F    
   \              0x69 0x6E    
   \              0x74 0x73    
   \              0x3A 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152:
   \   00000000   0x........         DC32     mks_heating_busy+0x8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable152_1:
   \   00000000   0x........         DC32     _ZN7Planner13z_fade_heightE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "SCARA Theta:">`:
   \   00000000   0x53 0x43          DC8 "SCARA Theta:"
   \              0x41 0x52    
   \              0x41 0x20    
   \              0x54 0x68    
   \              0x65 0x74    
   \              0x61 0x3A    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "   Psi+Theta:">`:
   \   00000000   0x20 0x20          DC8 "   Psi+Theta:"
   \              0x20 0x50    
   \              0x73 0x69    
   \              0x2B 0x54    
   \              0x68 0x65    
   \              0x74 0x61    
   \              0x3A 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Cap:">`:
   \   00000000   0x43 0x61          DC8 "Cap:"
   \              0x70 0x3A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154:
   \   00000000   0x........         DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_1:
   \   00000000   0x........         DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_2:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_3:
   \   00000000   0x58 0x3A          DC8      0x58, 0x3A, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_4:
   \   00000000   0x20 0x59          DC8      " Y:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_5:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling8z_valuesE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_6:
   \   00000000   0x20 0x5A          DC8      " Z:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable154_7:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155:
   \   00000000   0x20 0x45          DC8      " E:"
   \              0x3A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_1:
   \   00000000   0x3A 0x00          DC8      ":",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_2:
   \   00000000   0x40400000         DC32     0x40400000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_3:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_4:
   \   00000000   0x3FF80000         DC32     0x3ff80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_5:
   \   00000000   0x........         DC32     z_endstop_adj

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_6:
   \   00000000   0x9999999A         DC32     0x9999999a

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_7:
   \   00000000   0x3FB99999         DC32     0x3fb99999

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable155_8:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Active Extruder: ">`:
   \   00000000   0x41 0x63          DC8 "Active Extruder: "
   \              0x74 0x69    
   \              0x76 0x65    
   \              0x20 0x45    
   \              0x78 0x74    
   \              0x72 0x75    
   \              0x64 0x65    
   \              0x72 0x3A    
   \              0x20 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable156_1:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "HAS_NO_TEMP_BED!\\n">`:
   \   00000000   0x48 0x41          DC8 "HAS_NO_TEMP_BED!\012"
   \              0x53 0x5F    
   \              0x4E 0x4F    
   \              0x5F 0x54    
   \              0x45 0x4D    
   \              0x50 0x5F    
   \              0x42 0x45    
   \              0x44 0x21    
   \              0x0A 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable158:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Resend: ">`:
   \   00000000   0x52 0x65          DC8 "Resend: "
   \              0x73 0x65    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable159:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling8z_offsetE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160:
   \   00000000   0x6F 0x6B          DC8      0x6F, 0x6B, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160_1:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160_2:
   \   00000000   0x........         DC32     hotend_offset

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160_3:
   \   00000000   0x........         DC32     _ZN7Planner16bed_level_matrixE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160_4:
   \   00000000   0x........         DC32     _ZN7Planner15leveling_activeE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160_5:
   \   00000000   0x........         DC32     _ZN11GCodeParser14command_letterE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable160_6:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_1:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_2:
   \   00000000   0x........         DC32     _ZN11GCodeParser7codenumE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_3:
   \   00000000   0x........         DC32     mksCfg+0x34

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable161_4:
   \   00000000   0x........         DC32     `?<Constant "bed leveling hasn\\'t d...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_1:
   \   00000000   0x........         DC32     curFileName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_2:
   \   00000000   0x........         DC32     from_flash_pic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_3:
   \   00000000   0x........         DC32     flash_preview_begin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable163_4:
   \   00000000   0x........         DC32     default_preview_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166:
   \   00000000   0x........         DC32     parser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_1:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_2:
   \   00000000   0x........         DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_3:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_4:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable166_5:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168:
   \   00000000   0x........         DC32     z_values

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_1:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_2:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_3:
   \   00000000   0x43520000         DC32     0x43520000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_4:
   \   00000000   0x40668000         DC32     0x40668000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable168_5:
   \   00000000   0x43A50000         DC32     0x43a50000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable169:
   \   00000000   0x42B40000         DC32     0x42b40000

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " cold extrusion preve...">`:
   \   00000000   0x20 0x63          DC8 " cold extrusion prevented\012"
   \              0x6F 0x6C    
   \              0x64 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " too long extrusion p...">`:
   \   00000000   0x20 0x74          DC8 " too long extrusion prevented\012"
   \              0x6F 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x6E    
   \              0x67 0x20    
   \              0x65 0x78    
   \              0x74 0x72    
   \              0x75 0x73    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x70 0x72    
   \              0x65 0x76    
   \              0x65 0x6E    
   \              0x74 0x65    
   \              0x64 0x0A    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable175:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable175_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable176:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling13index_to_xposE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILL caused by too mu...">`:
   \   00000000   0x4B 0x49          DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
   \              0x4C 0x4C    
   \              0x20 0x63    
   \              0x61 0x75    
   \   00000008   0x73 0x65          DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
   \              0x64 0x20    
   \              0x62 0x79    
   \              0x20 0x74    
   \   00000010   0x6F 0x6F          DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
   \              0x20 0x6D    
   \              0x75 0x63    
   \              0x68 0x20    
   \   00000018   0x69 0x6E          DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
   \              0x61 0x63    
   \              0x74 0x69    
   \              0x76 0x65    
   \   00000020   0x20 0x74          DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x2D 0x20    
   \   00000028   0x63 0x75          DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x20    
   \   00000030   0x63 0x6F          DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x3A    
   \   00000038   0x20 0x00          DC8 20H, 0
   \   0000003A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "KILLED. ">`:
   \   00000000   0x4B 0x49          DC8 "KILLED. "
   \              0x4C 0x4C    
   \              0x45 0x44    
   \              0x2E 0x20    
   \              0x00         
   \   00000009   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable178:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Err%d">`:
   \   00000000   0x45 0x72          DC8 "Err%d"
   \              0x72 0x25    
   \              0x64 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable182:
   \   00000000   0x........         DC32     _ZN17mesh_bed_leveling13index_to_yposE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Printer halted. kill(...">`:
   \   00000000   0x50 0x72          DC8 "Printer halted. kill() called!\012"
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \              0x68 0x61    
   \              0x6C 0x74    
   \              0x65 0x64    
   \              0x2E 0x20    
   \              0x6B 0x69    
   \              0x6C 0x6C    
   \              0x28 0x29    
   \              0x20 0x63    
   \              0x61 0x6C    
   \              0x6C 0x65    
   \              0x64 0x21    
   \              0x0A 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable183:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable183_1:
   \   00000000   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable183_2:
   \   00000000   0x447A0001         DC32     0x447a0001

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Printer stopped due t...">`:
   \   00000000   0x50 0x72          DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
   \              0x69 0x6E    
   \              0x74 0x65    
   \              0x72 0x20    
   \   00000008   0x73 0x74          DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
   \              0x6F 0x70    
   \              0x70 0x65    
   \              0x64 0x20    
   \   00000010   0x64 0x75          DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
   \              0x65 0x20    
   \              0x74 0x6F    
   \              0x20 0x65    
   \   00000018   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
   \              0x6F 0x72    
   \              0x73 0x2E    
   \              0x20 0x46    
   \   00000020   0x69 0x78          DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
   \              0x20 0x74    
   \              0x68 0x65    
   \              0x20 0x65    
   \   00000028   0x72 0x72          DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
   \              0x6F 0x72    
   \              0x20 0x61    
   \              0x6E 0x64    
   \   00000030   0x20 0x75          DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
   \              0x73 0x65    
   \              0x20 0x4D    
   \              0x39 0x39    
   \   00000038   0x39 0x20          DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
   \              0x74 0x6F    
   \              0x20 0x72    
   \              0x65 0x73    
   \   00000040   0x74 0x61          DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
   \              0x72 0x74    
   \              0x2E 0x20    
   \              0x28 0x54    
   \   00000048   0x65 0x6D          DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
   \              0x70 0x65    
   \              0x72 0x61    
   \              0x74 0x75    
   \   00000050   0x72 0x65          DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x72 0x65    
   \   00000058   0x73 0x65          DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
   \              0x74 0x2E    
   \              0x20 0x53    
   \              0x65 0x74    
   \   00000060   0x20 0x69          DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
   \              0x74 0x20    
   \              0x61 0x66    
   \              0x74 0x65    
   \   00000068   0x72 0x20          DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
   \              0x72 0x65    
   \              0x73 0x74    
   \              0x61 0x72    
   \   00000070   0x74 0x69          DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
   \              0x6E 0x67    
   \              0x29 0x0A    
   \              0x00         
   \   00000077   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "STOPPED. ">`:
   \   00000000   0x53 0x54          DC8 "STOPPED. "
   \              0x4F 0x50    
   \              0x50 0x45    
   \              0x44 0x2E    
   \              0x20 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_1:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_2:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_3:
   \   00000000   0x........         DC32     errormagic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_4:
   \   00000000   0x........         DC32     _ZN11GCodeParser11command_ptrE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_5:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_6:
   \   00000000   0x........         DC32     disp_state_stack

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_7:
   \   00000000   0x........         DC32     button_disp_pause_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_8:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_9:
   \   00000000   0x422281B4         DC32     0x422281b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_10:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_11:
   \   00000000   0x........         DC32     wifi_link_state

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_12:
   \   00000000   0x........         DC32     temper_error_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_13:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable184_14:
   \   00000000   0x........         DC32     echomagic

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "MKS Robin Nano">`:
   \   00000000   0x4D 0x4B          DC8 "MKS Robin Nano"
   \              0x53 0x20    
   \              0x52 0x6F    
   \              0x62 0x69    
   \              0x6E 0x20    
   \              0x4E 0x61    
   \              0x6E 0x6F    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "1.0.0\\n">`:
   \   00000000   0x31 0x2E          DC8 "1.0.0\012"
   \              0x30 0x2E    
   \              0x30 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Last Updated: ">`:
   \   00000000   0x20 0x4C          DC8 " Last Updated: "
   \              0x61 0x73    
   \              0x74 0x20    
   \              0x55 0x70    
   \              0x64 0x61    
   \              0x74 0x65    
   \              0x64 0x3A    
   \              0x20 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "2017-12-25 12:00">`:
   \   00000000   0x32 0x30          DC8 "2017-12-25 12:00"
   \              0x31 0x37    
   \              0x2D 0x31    
   \              0x32 0x2D    
   \              0x32 0x35    
   \              0x20 0x31    
   \              0x32 0x3A    
   \              0x30 0x30    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " | Author: (none, def...">`:
   \   00000000   0x20 0x7C          DC8 " | Author: (none, default config)\012"
   \              0x20 0x41    
   \              0x75 0x74    
   \              0x68 0x6F    
   \              0x72 0x3A    
   \              0x20 0x28    
   \              0x6E 0x6F    
   \              0x6E 0x65    
   \              0x2C 0x20    
   \              0x64 0x65    
   \              0x66 0x61    
   \              0x75 0x6C    
   \              0x74 0x20    
   \              0x63 0x6F    
   \              0x6E 0x66    
   \              0x69 0x67    
   \              0x29 0x0A    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Compiled: Feb 14 2020\\n">`:
   \   00000000   0x43 0x6F          DC8 "Compiled: Feb 14 2020\012"
   \              0x6D 0x70    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x3A 0x20    
   \              0x46 0x65    
   \              0x62 0x20    
   \              0x31 0x34    
   \              0x20 0x32    
   \              0x30 0x32    
   \              0x30 0x0A    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant " Free Memory: ">`:
   \   00000000   0x20 0x46          DC8 " Free Memory: "
   \              0x72 0x65    
   \              0x65 0x20    
   \              0x4D 0x65    
   \              0x6D 0x6F    
   \              0x72 0x79    
   \              0x3A 0x20    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "  PlannerBufferBytes: ">`:
   \   00000000   0x20 0x20          DC8 "  PlannerBufferBytes: "
   \              0x50 0x6C    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x72 0x42    
   \              0x75 0x66    
   \              0x66 0x65    
   \              0x72 0x42    
   \              0x79 0x74    
   \              0x65 0x73    
   \              0x3A 0x20    
   \              0x00         
   \   00000017   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable185:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable185_1:
   \   00000000   0x401921FB         DC32     0x401921fb

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Done saving file.\\n">`:
   \   00000000   0x44 0x6F          DC8 "Done saving file.\012"
   \              0x6E 0x65    
   \              0x20 0x73    
   \              0x61 0x76    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x66 0x69    
   \              0x6C 0x65    
   \              0x2E 0x0A    
   \              0x00         
   \   00000013   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186:
   \   00000000   0x54442D18         DC32     0x54442d18

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_1:
   \   00000000   0xC01921FB         DC32     0xc01921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_2:
   \   00000000   0x40C90FDB         DC32     0x40c90fdb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_3:
   \   00000000   0x3A83126F         DC32     0x3a83126f

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_4:
   \   00000000   0x4D 0x32          DC8      "M29"
   \              0x39 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_5:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_6:
   \   00000000   0x3FF00000         DC32     0x3ff00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_7:
   \   00000000   0x4062C000         DC32     0x4062c000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_8:
   \   00000000   0x400921FB         DC32     0x400921fb

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_9:
   \   00000000   0x40668000         DC32     0x40668000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_10:
   \   00000000   0x........         DC32     axis_homed

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_11:
   \   00000000   0x42C80000         DC32     0x42c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_12:
   \   00000000   0xC2C80000         DC32     0xc2c80000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable186_13:
   \   00000000   0x42600000         DC32     0x42600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187:
   \   00000000   0xC2600000         DC32     0xc2600000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_1:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_2:
   \   00000000   0x........         DC32     ??C2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_3:
   \   00000000   0x43160000         DC32     0x43160000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_4:
   \   00000000   0x........         DC32     gArrayGpioPort

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable187_5:
   \   00000000   0x........         DC32     gArrayGpioPin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable188:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "0.000">`:
   \   00000000   0x30 0x2E          DC8 "0.000"
   \              0x30 0x30    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "TP-LINK_MKS">`:
   \   00000000   0x54 0x50          DC8 "TP-LINK_MKS"
   \              0x2D 0x4C    
   \              0x49 0x4E    
   \              0x4B 0x5F    
   \              0x4D 0x4B    
   \              0x53 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "makerbase">`:
   \   00000000   0x6D 0x61          DC8 "makerbase"
   \              0x6B 0x65    
   \              0x72 0x62    
   \              0x61 0x73    
   \              0x65 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.100">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.100"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x31 0x30    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "255.255.255.0">`:
   \   00000000   0x32 0x35          DC8 "255.255.255.0"
   \              0x35 0x2E    
   \              0x32 0x35    
   \              0x35 0x2E    
   \              0x32 0x35    
   \              0x35 0x2E    
   \              0x30 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.1">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.1"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x31 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "192.168.3.255">`:
   \   00000000   0x31 0x39          DC8 "192.168.3.255"
   \              0x32 0x2E    
   \              0x31 0x36    
   \              0x38 0x2E    
   \              0x33 0x2E    
   \              0x32 0x35    
   \              0x35 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "baizhongyun.cn">`:
   \   00000000   0x62 0x61          DC8 "baizhongyun.cn"
   \              0x69 0x7A    
   \              0x68 0x6F    
   \              0x6E 0x67    
   \              0x79 0x75    
   \              0x6E 0x2E    
   \              0x63 0x6E    
   \              0x00         
   \   0000000F   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191:
   \   00000000   0x........         DC32     thermalManager

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191_1:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191_2:
   \   00000000   0x........         DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable191_3:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192:
   \   00000000   0x........         DC32     Serial3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_1:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_2:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_3:
   \   00000000   0x42220194         DC32     0x42220194

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_4:
   \   00000000   0x408F4000         DC32     0x408f4000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_5:
   \   00000000   0x40590000         DC32     0x40590000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_6:
   \   00000000   0x3FE00000         DC32     0x3fe00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_7:
   \   00000000   0x........         DC32     filament_rate

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_8:
   \   00000000   0x........         DC32     temperature_change_frequency

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_9:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable192_10:
   \   00000000   0x........         DC32     poweroff_det_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193:
   \   00000000   0x........         DC32     poweroff_det_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_1:
   \   00000000   0x........         DC32     filament_det1_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_2:
   \   00000000   0x........         DC32     filament_det1_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_3:
   \   00000000   0x........         DC32     filament_det1_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable193_4:
   \   00000000   0x........         DC32     filament_det1_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194:
   \   00000000   0x........         DC32     filament_det1_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_1:
   \   00000000   0x........         DC32     filament_det1_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_2:
   \   00000000   0x........         DC32     filament_det2_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_3:
   \   00000000   0x........         DC32     filament_det2_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_4:
   \   00000000   0x........         DC32     filament_det2_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_5:
   \   00000000   0x........         DC32     filament_det2_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_6:
   \   00000000   0x........         DC32     filament_det2_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_7:
   \   00000000   0x........         DC32     filament_det2_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable194_8:
   \   00000000   0x........         DC32     poweroff_det_low_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195:
   \   00000000   0x........         DC32     poweroff_det_low_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_1:
   \   00000000   0x........         DC32     poweroff_det_high_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_2:
   \   00000000   0x........         DC32     poweroff_det_high_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_3:
   \   00000000   0x........         DC32     wifi_check_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_4:
   \   00000000   0x........         DC32     key_value_calc

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable195_5:
   \   00000000   0x........         DC32     tips_disp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable196:
   \   00000000   0x76313030         DC32     0x76313030

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M140 S">`:
   \   00000000   0x4D 0x31          DC8 "M140 S"
   \              0x34 0x30    
   \              0x20 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M104 T1 S">`:
   \   00000000   0x4D 0x31          DC8 "M104 T1 S"
   \              0x30 0x34    
   \              0x20 0x54    
   \              0x31 0x20    
   \              0x53 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M109 T0 S">`:
   \   00000000   0x4D 0x31          DC8 "M109 T0 S"
   \              0x30 0x39    
   \              0x20 0x54    
   \              0x30 0x20    
   \              0x53 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M109 T1 S">`:
   \   00000000   0x4D 0x31          DC8 "M109 T1 S"
   \              0x30 0x39    
   \              0x20 0x54    
   \              0x31 0x20    
   \              0x53 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "M190 S">`:
   \   00000000   0x4D 0x31          DC8 "M190 S"
   \              0x39 0x30    
   \              0x20 0x53    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G92 Z">`:
   \   00000000   0x47 0x39          DC8 "G92 Z"
   \              0x32 0x20    
   \              0x5A 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 E">`:
   \   00000000   0x47 0x31          DC8 "G1 E"
   \              0x20 0x45    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G92 E">`:
   \   00000000   0x47 0x39          DC8 "G92 E"
   \              0x32 0x20    
   \              0x45 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable202:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable202_1:
   \   00000000   0x00494949         DC32     0x494949

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable202_2:
   \   00000000   0x00AAAAAA         DC32     0xaaaaaa

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_1:
   \   00000000   0x........         DC32     wifiPara

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable204_2:
   \   00000000   0x........         DC32     ipPara

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable206:
   \   00000000   0x........         DC32     BMP_PIC_X

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 Z">`:
   \   00000000   0x47 0x31          DC8 "G1 Z"
   \              0x20 0x5A    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable207:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable207_1:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 X">`:
   \   00000000   0x47 0x31          DC8 "G1 X"
   \              0x20 0x58    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%.3f">`:
   \   00000000   0x25 0x2E          DC8 "%.3f"
   \              0x33 0x66    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "%.3f F%.3f">`:
   \   00000000   0x25 0x2E          DC8 "%.3f F%.3f"
   \              0x33 0x66    
   \              0x20 0x46    
   \              0x25 0x2E    
   \              0x33 0x66    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable208:
   \   00000000   0x20 0x59          DC8      0x20, 0x59, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable208_1:
   \   00000000   0x........         DC32     BMP_PIC_Y

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable208_2:
   \   00000000   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable208_3:
   \   00000000   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G1 Z0">`:
   \   00000000   0x47 0x31          DC8 "G1 Z0"
   \              0x20 0x5A    
   \              0x30 0x00    
   \   00000006   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable209:
   \   00000000   0x40A00000         DC32     0x40a00000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable210:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "G28 X0 Y0">`:
   \   00000000   0x47 0x32          DC8 "G28 X0 Y0"
   \              0x38 0x20    
   \              0x58 0x30    
   \              0x20 0x59    
   \              0x30 0x00    
   \   0000000A   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable211:
   \   00000000   0x........         DC32     mks_heating_busy+0x3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable211_1:
   \   00000000   0x47 0x32          DC8      "G28"
   \              0x38 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable211_2:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable211_3:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable211_4:
   \   00000000   0x38D1B718         DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable212:
   \   00000000   0xBF800000         DC32     0xbf800000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable212_1:
   \   00000000   0x........         DC32     pause_resum

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable213:
   \   00000000   0x........         DC32     IsChooseAutoShutdown

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable213_1:
   \   00000000   0x........         DC32     `?<Constant "G28 X0 Y0">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable214:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "Resume print?">`:
   \   00000000   0x52 0x65          DC8 "Resume print?"
   \              0x73 0x75    
   \              0x6D 0x65    
   \              0x20 0x70    
   \              0x72 0x69    
   \              0x6E 0x74    
   \              0x3F 0x00    
   \   0000000E   0x00 0x00          DC8 0, 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable215:
   \   00000000   0x40000440         DC32     0x40000440

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable215_1:
   \   00000000   0x2F 0x00          DC8      "/",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable215_2:
   \   00000000   0x........         DC32     axis_relative_modes

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "start\\n">`:
   \   00000000   0x73 0x74          DC8 "start\012"
   \              0x61 0x72    
   \              0x74 0x0A    
   \              0x00         
   \   00000007   0x00               DC8 0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217:
   \   00000000   0x25 0x64          DC8      0x25, 0x64, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable217_1:
   \   00000000   0x0A 0x00          DC8      "\n",0x0,0x0
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable219:
   \   00000000   0x25 0x66          DC8      0x25, 0x66, 0x00, 0x00
   \              0x00 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable219_1:
   \   00000000   0x........         DC32     _ZN7Planner17max_feedrate_mm_sE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable219_2:
   \   00000000   0x........         DC32     leveling_first_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable220:
   \   00000000   0x65 0x6E          DC8      "end"
   \              0x64 0x00    

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable220_1:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable221:
   \   00000000   0x42700000         DC32     0x42700000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable223:
   \   00000000   0x........         DC32     mksCfg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable224:
   \   00000000   0x41200000         DC32     0x41200000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable225:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable225_1:
   \   00000000   0x........         DC32     mks_heating_busy

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226:
   \   00000000   0x........         DC32     first_resu

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_1:
   \   00000000   0x........         DC32     command_queue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_2:
   \   00000000   0x38D1B718         DC32     0x38d1b718

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_3:
   \   00000000   0x........         DC32     card+0x9D4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_4:
   \   00000000   0x........         DC32     curFileName

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_5:
   \   00000000   0x........         DC32     logo_tick2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_6:
   \   00000000   0x........         DC32     logo_tick1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_7:
   \   00000000   0x........         DC32     from_flash_pic

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_8:
   \   00000000   0x........         DC32     flash_preview_begin

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_9:
   \   00000000   0x........         DC32     default_preview_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_10:
   \   00000000   0x........         DC32     continue_print_error_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_11:
   \   00000000   0x........         DC32     card

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_12:
   \   00000000   0x........         DC32     gCfgItems

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_13:
   \   00000000   0x........         DC32     mksTmp

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_14:
   \   00000000   0x........         DC32     SD_Path

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_15:
   \   00000000   0x........         DC32     mks_pft_name

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_16:
   \   00000000   0x........         DC32     _ZN11Temperature18target_temperatureE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_17:
   \   00000000   0x........         DC32     _ZN11Temperature22target_temperature_bedE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_18:
   \   00000000   0x........         DC32     print_time

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_19:
   \   00000000   0x........         DC32     filament_loading_time_flg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_20:
   \   00000000   0x........         DC32     _ZN7Planner15flow_percentageE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_21:
   \   00000000   0x47AE147B         DC32     0x47ae147b

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_22:
   \   00000000   0x3F847AE1         DC32     0x3f847ae1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_23:
   \   00000000   0x........         DC32     _ZN7Planner8e_factorE

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_24:
   \   00000000   0x422281B4         DC32     0x422281b4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_25:
   \   00000000   0x40010414         DC32     0x40010414

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_26:
   \   00000000   0x422381A8         DC32     0x422381a8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable226_27:
   \   00000000   0x42210180         DC32     0x42210180

   \                                 In section .text, align 4, keep-with-next
   \                     `?<Constant "clear">`:
   \   00000000   0x63 0x6C          DC8 "clear"
   \              0x65 0x61    
   \              0x72 0x00    
   \   00000006   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "mks_pft.sys">`:
   \   00000000   0x6D 0x6B          DC8 "mks_pft.sys"
   \              0x73 0x5F    
   \              0x70 0x66    
   \              0x74 0x2E    
   \              0x73 0x79    
   \              0x73 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "X">`:
   \   00000000   0x58 0x00          DC8 "X"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "Y">`:
   \   00000000   0x59 0x00          DC8 "Y"

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "Z">`:
   \   00000000   0x5A 0x00          DC8 "Z"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(0.0F), (0.0F)}>`:
   \   00000000   0x00000000         DC32 0H, 0H
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "X:">`:
   \   00000000   0x58 0x3A          DC8 "X:"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y:">`:
   \   00000000   0x20 0x59          DC8 " Y:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Z:">`:
   \   00000000   0x20 0x5A          DC8 " Z:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " E:">`:
   \   00000000   0x20 0x45          DC8 " E:"
   \              0x3A 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant ":">`:
   \   00000000   0x3A 0x00          DC8 ":"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "bed leveling hasn\\'t d...">`:
   \   00000000   0x62 0x65          DC8 "bed leveling hasn't defined!"
   \              0x64 0x20    
   \              0x6C 0x65    
   \              0x76 0x65    
   \              0x6C 0x69    
   \              0x6E 0x67    
   \              0x20 0x68    
   \              0x61 0x73    
   \              0x6E 0x27    
   \              0x74 0x20    
   \              0x64 0x65    
   \              0x66 0x69    
   \              0x6E 0x65    
   \              0x64 0x21    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "ok">`:
   \   00000000   0x6F 0x6B          DC8 "ok"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {(0.0F), (0.0F), (0.0F)}>`:
   \   00000000   0x00000000         DC32 0H, 0H, 0H
   \              0x00000000   
   \              0x00000000   

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_1`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "M29">`:
   \   00000000   0x4D 0x32          DC8 "M29"
   \              0x39 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%d">`:
   \   00000000   0x25 0x64          DC8 "%d"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "%f">`:
   \   00000000   0x25 0x66          DC8 "%f"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant " Y">`:
   \   00000000   0x20 0x59          DC8 " Y"
   \              0x00         
   \   00000003   0x00               DC8 0

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "G28">`:
   \   00000000   0x47 0x32          DC8 "G28"
   \              0x38 0x00    

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "/">`:
   \   00000000   0x2F 0x00          DC8 "/"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_2`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 2, keep-with-next
   \                     `?<Constant "\\n">`:
   \   00000000   0x0A 0x00          DC8 "\012"

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant "end">`:
   \   00000000   0x65 0x6E          DC8 "end"
   \              0x64 0x00    

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_3`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4, keep-with-next
   \                     `?<Constant {'\\000'}>_4`:
   \   00000000   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         
  16398          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADJUST_DELTA(float const *)
        16   -> __aeabi_fadd
        16   -> bilinear_z_offset(float const *)
       0   Beeper(uint32_t)
       0   CardReader::eof()
      16   CardReader::get()
        16   -> f_read
       0   CardReader::isFileOpen()
       0   CardReader::setIndex(long)
         0   -> f_lseek
       8   EXTI9_5_IRQHandler
         8   -> HAL_Delay
         8   -> mks_WriteToEpr_pwroff()
       0   Endstops::enable(bool)
       0   Endstops::enable_globally(bool)
       0   Endstops::enable_z_probe(bool)
       0   Endstops::hit_on_purpose()
       0   Endstops::not_homing()
       8   FlushSerialRequestResend()
         8   -> Print::print(long, int)
         8   -> USARTClass::flush()
         8   -> USARTClass::write(uint8_t)
         0   -> ok_to_send()
         8   -> serialprintPGM(char const *)
       8   GCodeParser::boolval(char)
         0   -> GCodeParser::seen(char)
         8   -> GCodeParser::seenval(char)
         0   -> GCodeParser::value_bool()
       8   GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
       8   GCodeParser::celsiusval(char, float)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_celsius()
       0   GCodeParser::has_value()
       8   GCodeParser::intval(char, int16_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
       8   GCodeParser::linearval(char, float)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_linear_units()
       0   GCodeParser::seen(char)
       8   GCodeParser::seenval(char)
         0   -> GCodeParser::has_value()
         8   -> GCodeParser::seen(char)
       8   GCodeParser::ushortval(char, uint16_t)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_ushort()
       0   GCodeParser::value_axis_units(AxisEnum)
         0   -> GCodeParser::value_float()
       8   GCodeParser::value_bool()
         8   -> GCodeParser::has_value()
         8   -> GCodeParser::value_byte()
       8   GCodeParser::value_byte()
         8   -> GCodeParser::value_long()
       0   GCodeParser::value_celsius()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_feedrate()
         0   -> GCodeParser::value_linear_units()
      16   GCodeParser::value_float()
         0   -> __aeabi_d2f
        16   -> __aeabi_d2f
        16   -> strtod
       8   GCodeParser::value_int()
         8   -> GCodeParser::value_long()
       0   GCodeParser::value_linear_units()
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_long()
         0   -> strtol
       0   GCodeParser::value_millis()
         0   -> GCodeParser::value_ulong()
       8   GCodeParser::value_millis_from_seconds()
         8   -> GCodeParser::value_float()
         0   -> __aeabi_f2uiz
         8   -> __aeabi_fmul
       0   GCodeParser::value_per_axis_unit(AxisEnum)
         0   -> GCodeParser::value_float()
       0   GCodeParser::value_ulong()
         0   -> strtoul
       8   GCodeParser::value_ushort()
         8   -> GCodeParser::value_long()
       0   IsRunning()
       0   IsStopped()
       0   Planner::apply_leveling(float (&)[3])
         0   -> Planner::apply_leveling(float &, float &, float &)
       0   Planner::blocks_queued()
      32   Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        32   -> Planner::apply_leveling(float &, float &, float &)
        32   -> Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
      40   Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        40   -> Planner::apply_leveling(float (&)[3])
        40   -> Planner::buffer_segment(float const &, float const &, float const &, float const &, float const &, uint8_t)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fmul
        40   -> inverse_kinematics(float const *)
        40   -> inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> lroundf
       0   Planner::force_fade_recalc()
       8   Planner::leveling_active_at_z(float const &)
         8   -> __aeabi_cfcmpeq
         8   -> __aeabi_cfcmple
      16   Planner::refresh_e_factor(uint8_t)
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_i2d
       0   Planner::set_e_position_mm(float const &)
         0   -> Planner::set_position_mm(AxisEnum, float const &)
       8   Planner::set_filament_size(uint8_t, float const &)
         8   -> __aeabi_cfcmpeq
      24   Planner::set_position_mm(float, float, float, float const &)
        24   -> Planner::_set_position_mm(float const &, float const &, float const &, float const &)
        24   -> Planner::apply_leveling(float &, float &, float &)
       8   Planner::set_z_fade_height(float const &)
         0   -> Planner::force_fade_recalc()
         8   -> __aeabi_cfcmple
         8   -> __aeabi_cfrcmple
         8   -> __aeabi_fdiv
      24   SCARA_move_to_cal(uint8_t, uint8_t)
        24   -> IsRunning()
        24   -> __aeabi_ui2f
        24   -> forward_kinematics_SCARA(float const &, float const &)
        24   -> prepare_move_to_destination()
       0   SYNC_PLAN_POSITION_KINEMATIC()
         0   -> sync_plan_position()
         0   -> sync_plan_position_kinematic()
       0   Stepper::get_axis_position_degrees(AxisEnum)
         0   -> Stepper::get_axis_position_mm(AxisEnum)
       0   Stepper::set_homing_flag_z(bool)
       0   Stepper::set_z2_lock(bool)
       0   Stepper::set_z_lock(bool)
      40   SysTick_Handler_User()
        40   -> __aeabi_d2uiz
        40   -> __aeabi_dadd
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_ui2d
        40   -> mksBeeperAlarm()
       0   Temperature::degBed()
       0   Temperature::degHotend(uint8_t)
       0   Temperature::degTargetBed()
         0   -> __aeabi_i2f
       0   Temperature::degTargetHotend(uint8_t)
         0   -> __aeabi_i2f
       8   Temperature::isCoolingBed()
         8   -> __aeabi_cfcmple
         8   -> __aeabi_i2f
       8   Temperature::isCoolingHotend(uint8_t)
         8   -> __aeabi_cfcmple
         8   -> __aeabi_i2f
      16   Temperature::setTargetBed(float)
         0   -> Temperature::start_watching_bed()
        16   -> __aeabi_cfcmple
        16   -> __aeabi_f2iz
        16   -> __aeabi_i2f
       8   Temperature::setTargetHotend(float, uint8_t)
         0   -> Temperature::start_watching_heater(uint8_t)
         8   -> __aeabi_f2iz
       8   Temperature::set_auto_report_interval(uint8_t)
         8   -> HAL_GetTick
      16   Temperature::tooColdToExtrude(uint8_t)
        16   -> Temperature::degHotend(uint8_t)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_i2f
       0   Temperature::updatePID()
      32   __sti__routine()
        32   -> CardReader::CardReader()
        32   -> Stopwatch::Stopwatch()
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> unified_bed_leveling::unified_bed_leveling()
       0   _commit_command(bool)
       8   _enqueuecommand(char const *, bool)
         8   -> _commit_command(bool)
         8   -> strcpy
      32   _manual_goto_xy(float const &, float const &)
        32   -> __aeabi_cfrcmple
        32   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        32   -> do_blocking_move_to_xy(float const &, float const &, float const &)
        32   -> do_blocking_move_to_z(float const &, float const &)
      16   axis_unhomed_error(bool, bool, bool)
        16   -> serialprintPGM(char const *)
       0   base_home_pos(AxisEnum)
       0   base_max_pos(AxisEnum)
       0   base_min_pos(AxisEnum)
      64   bilinear_line_to_destination(float, uint16_t, uint16_t)
        64   -> __aeabi_f2iz
        64   -> __aeabi_fadd
        64   -> __aeabi_fdiv
        64   -> __aeabi_fmul
        64   -> __aeabi_fsub
        64   -> __aeabi_i2f
        64   -> bilinear_line_to_destination(float, uint16_t, uint16_t)
        64   -> buffer_line_to_destination(float)
        64   -> memcpy
        64   -> set_current_from_destination()
      32   bilinear_z_offset(float const *)
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_cfcmple
        32   -> __aeabi_f2iz
         0   -> __aeabi_fadd
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
        32   -> floorf
       0   bltouch_command(int)
         0   -> safe_delay(millis_t)
      16   buffer_line_to_current_position()
        16   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      16   buffer_line_to_destination(float)
        16   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
      16   cap_line(char const *, bool)
        16   -> Print::print(int, int)
         0   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
      40   clamp_to_software_endstops(float *)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> sqrtf
       0   clean_up_after_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   clear_command_queue()
      32   delta_safe_distance_from_top()
        32   -> __aeabi_fsub
        32   -> inverse_kinematics(float const *)
        32   -> inverse_kinematics_MORGAN_SCARA(float const *)
      24   disable_all_steppers()
        24   -> HAL_GPIO_WritePin
         0   -> disable_e_steppers()
      16   disable_e_steppers()
         0   -> HAL_GPIO_WritePin
        16   -> HAL_GPIO_WritePin
      48   display_sd_error()
        48   -> GUI_DispStringAt
        48   -> GUI_SetBkColor
        48   -> GUI_SetColor
        48   -> __aeabi_memclr4
        48   -> sprintf
      48   display_temper_error()
        48   -> GUI_DispStringAt
        48   -> GUI_SetBkColor
        48   -> GUI_SetColor
        48   -> __aeabi_memclr4
        48   -> sprintf
      32   do_blocking_move_to(float const &, float const &, float const &, float const &)
        32   -> Stepper::synchronize()
        32   -> __aeabi_cfcmpeq
        32   -> __aeabi_cfcmple
        32   -> buffer_line_to_current_position()
        32   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
        32   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
        32   -> prepare_uninterpolated_move_to_destination(float)
        32   -> set_destination_from_current()
       8   do_blocking_move_to_x(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       0   do_blocking_move_to_xy(float const &, float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       8   do_blocking_move_to_z(float const &, float const &)
         0   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
      40   do_homing_move(AxisEnum, float, float)
        40   -> Endstops::hit_on_purpose()
        40   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> Stepper::synchronize()
        40   -> __aeabi_cfcmpeq
        40   -> __aeabi_cfcmple
        40   -> inverse_kinematics(float const *)
        40   -> inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> set_bltouch_deployed(bool)
        40   -> sync_plan_position()
      24   do_probe_move(float, float)
        24   -> Endstops::hit_on_purpose()
        24   -> SYNC_PLAN_POSITION_KINEMATIC()
        24   -> __aeabi_fdiv
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> set_bltouch_deployed(bool)
        24   -> set_current_from_steppers_for_axis(AxisEnum)
      16   do_probe_raise(float)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_fsub
        16   -> do_blocking_move_to_z(float const &, float const &)
      48   drain_injected_commands_P()
        48   -> enqueue_and_echo_command(char const *, bool)
        48   -> strncpy
       8   duration_t::day() const
         8   -> duration_t::hour() const
       0   duration_t::duration_t(uint32_t const &)
       8   duration_t::hour() const
         8   -> duration_t::minute() const
       8   duration_t::minute() const
         8   -> duration_t::second() const
       0   duration_t::second() const
      48   duration_t::toString(char *) const
        48   -> duration_t::day() const
        48   -> duration_t::hour() const
        48   -> duration_t::minute() const
        48   -> duration_t::second() const
        48   -> duration_t::year() const
         0   -> sprintf
        48   -> sprintf
       8   duration_t::year() const
         8   -> duration_t::day() const
       8   dwell(millis_t)
         8   -> HAL_GetTick
         8   -> idle()
         8   -> refresh_cmd_timeout()
       0   echo_not_entered()
         0   -> serialprintPGM(char const *)
      16   enable_all_steppers()
         0   -> HAL_GPIO_WritePin
        16   -> HAL_GPIO_WritePin
       8   enqueue_and_echo_command(char const *, bool)
         8   -> USARTClass::write(uint8_t)
         8   -> _enqueuecommand(char const *, bool)
         8   -> serial_echopair_P(char const *, char const *)
         8   -> serialprintPGM(char const *)
       0   enqueue_and_echo_commands_P(char const *)
         0   -> drain_injected_commands_P()
      40   extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __iar_FDtest
      56   extrapolate_unprobed_bed_level()
        56   -> extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
       0   forward_kinematics_DELTA(float *)
         0   -> forward_kinematics_DELTA(float, float, float)
      80   forward_kinematics_DELTA(float, float, float)
        80   -> __aeabi_fadd
        80   -> __aeabi_fdiv
        80   -> __aeabi_fmul
        80   -> __aeabi_fsub
        80   -> sqrtf
      40   forward_kinematics_SCARA(float const &, float const &)
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> cos
        40   -> sin
       0   freeMemory()
       8   gcode_G0_G1()
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
       8   gcode_G0_G1_SCARA(bool)
         8   -> IsRunning()
         8   -> gcode_get_destination()
         0   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
      48   gcode_G28(bool)
        48   -> Endstops::enable(bool)
        48   -> Endstops::not_homing()
        48   -> GCodeParser::seen(char)
        48   -> SYNC_PLAN_POSITION_KINEMATIC()
        48   -> Stepper::synchronize()
        48   -> __aeabi_cfcmple
        48   -> clean_up_after_endstop_or_probe_move()
        48   -> do_blocking_move_to_z(float const &, float const &)
        48   -> home_delta()
        48   -> homeaxis(AxisEnum)
        48   -> lcd_refresh()
        48   -> quick_home_xy()
        48   -> report_current_position()
        48   -> set_bed_leveling_enabled(bool)
        48   -> set_destination_from_current()
        48   -> setup_for_endstop_or_probe_move()
        48   -> tool_change(uint8_t, float, bool)
     864   gcode_G29()
       848   -> GCodeParser::boolval(char)
       848   -> GCodeParser::byteval(char, uint8_t)
       848   -> GCodeParser::intval(char, int16_t)
       848   -> GCodeParser::linearval(char, float)
       848   -> GCodeParser::seen(char)
       848   -> GCodeParser::seenval(char)
       848   -> GCodeParser::value_int()
       848   -> GCodeParser::value_linear_units()
       848   -> Planner::unapply_leveling(float *)
       848   -> Print::print(double, int)
       848   -> SYNC_PLAN_POSITION_KINEMATIC()
       848   -> Stepper::synchronize()
       848   -> USARTClass::write(uint8_t)
       848   -> __aeabi_cfcmpeq
       848   -> __aeabi_cfcmple
       848   -> __aeabi_cfrcmple
       848   -> __aeabi_d2f
       848   -> __aeabi_d2iz
       848   -> __aeabi_dadd
       848   -> __aeabi_ddiv
       848   -> __aeabi_f2d
       848   -> __aeabi_f2iz
       848   -> __aeabi_fadd
       848   -> __aeabi_fdiv
       848   -> __aeabi_fmul
       848   -> __aeabi_fsub
       848   -> __aeabi_i2f
       848   -> __aeabi_memcpy4
       864   -> __aeabi_memcpy4
       848   -> __aeabi_ui2f
       848   -> __iar_FDtest
       848   -> apply_rotation_xyz(matrix_3x3, float &, float &, float &)
       848   -> axis_unhomed_error(bool, bool, bool)
       848   -> bilinear_z_offset(float const *)
       848   -> clean_up_after_endstop_or_probe_move()
       848   -> extrapolate_unprobed_bed_level()
       848   -> finish_incremental_LSF(linear_fit_data *)
       848   -> floor
       848   -> free
       848   -> idle()
       848   -> incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
       848   -> incremental_LSF_reset(linear_fit_data *)
       848   -> kill(char const *)
       848   -> leveling_is_valid()
       848   -> malloc
       848   -> matrix_3x3::create_look_at(vector_3)
       848   -> matrix_3x3::debug(char const *)
       848   -> memcpy
       848   -> out_of_range_error(char const *)
       848   -> position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
       848   -> print_bilinear_leveling_grid()
       848   -> probe_pt(float const &, float const &, bool, uint8_t, bool)
       848   -> rand
       848   -> refresh_bed_level()
       848   -> report_current_position()
       848   -> reset_bed_level()
       848   -> serialprintPGM(char const *)
       848   -> set_bed_leveling_enabled(bool)
       848   -> set_probe_deployed(bool)
       848   -> setup_for_endstop_or_probe_move()
       848   -> vector_3::cross(vector_3, vector_3)
       848   -> vector_3::get_normal()
       848   -> vector_3::operator-(vector_3)
       848   -> vector_3::vector_3(float, float, float)
      32   gcode_G29_MESH_BED_LEVELING()
        32   -> GCodeParser::byteval(char, uint8_t)
        32   -> GCodeParser::seenval(char)
        32   -> GCodeParser::value_int()
        32   -> GCodeParser::value_linear_units()
        32   -> Stepper::synchronize()
        32   -> USARTClass::write(uint8_t)
        32   -> __aeabi_fadd
        32   -> _manual_goto_xy(float const &, float const &)
        32   -> buffer_line_to_current_position()
        32   -> echo_not_entered()
        32   -> enqueue_and_echo_commands_P(char const *)
        32   -> home_all_axes()
        32   -> leveling_is_valid()
        32   -> mbl_mesh_report()
        32   -> mesh_bed_leveling::reset()
        32   -> mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
        32   -> mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
        32   -> report_current_position()
        32   -> reset_bed_level()
        32   -> serial_echopair_P(char const *, char const *)
        32   -> serial_echopair_P(char const *, int)
        32   -> serialprintPGM(char const *)
        32   -> set_bed_leveling_enabled(bool)
       0   gcode_G29_UBL()
         0   -> unified_bed_leveling::gcode_G29_UBL()
      72   gcode_G2_G3(bool)
        72   -> GCodeParser::seenval(char)
        72   -> GCodeParser::value_linear_units()
        72   -> IsRunning()
        72   -> __aeabi_cfcmpeq
        72   -> __aeabi_cfcmple
        72   -> __aeabi_d2f
        72   -> __aeabi_dmul
        72   -> __aeabi_dsub
        72   -> __aeabi_f2d
        72   -> __aeabi_fadd
        72   -> __aeabi_fdiv
        72   -> __aeabi_fmul
        72   -> __aeabi_fsub
        72   -> gcode_get_destination()
        72   -> plan_arc(float const (&)[4], float const (&)[2], bool)
        72   -> refresh_cmd_timeout()
        72   -> serialprintPGM(char const *)
        72   -> sqrt
        72   -> sqrtf
      32   gcode_G30()
        32   -> GCodeParser::boolval(char)
        32   -> GCodeParser::linearval(char, float)
        32   -> USARTClass::write(uint8_t)
        32   -> __aeabi_dadd
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __iar_FDtest
        32   -> clean_up_after_endstop_or_probe_move()
        32   -> position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
        32   -> position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
        32   -> probe_pt(float const &, float const &, bool, uint8_t, bool)
        32   -> report_current_position()
        32   -> serial_echopair_P(char const *, double)
        32   -> set_bed_leveling_enabled(bool)
        32   -> setup_for_endstop_or_probe_move()
       8   gcode_G4()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_millis()
         8   -> GCodeParser::value_millis_from_seconds()
         8   -> Stepper::synchronize()
         0   -> dwell(millis_t)
         8   -> lcd_hasstatus()
         8   -> lcd_setstatusPGM(char const *, int8_t)
      32   gcode_G42()
        32   -> GCodeParser::boolval(char)
        32   -> GCodeParser::linearval(char, float)
        32   -> GCodeParser::seenval(char)
        32   -> GCodeParser::value_int()
        32   -> IsRunning()
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fdiv
        32   -> __aeabi_fsub
        32   -> __aeabi_i2f
         0   -> prepare_move_to_destination()
         0   -> prepare_uninterpolated_move_to_destination(float)
         0   -> serialprintPGM(char const *)
        32   -> set_destination_from_current()
        32   -> unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        32   -> unified_bed_leveling::mesh_index_to_ypos(uint8_t)
      24   gcode_G92()
        24   -> GCodeParser::seen(char)
        24   -> GCodeParser::seenval(char)
        24   -> GCodeParser::value_axis_units(AxisEnum)
        24   -> SYNC_PLAN_POSITION_KINEMATIC()
        24   -> Stepper::synchronize()
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
         0   -> report_current_position()
        24   -> sync_plan_position_e()
        24   -> update_software_endstops(AxisEnum)
      16   gcode_M104()
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_celsius()
         0   -> Planner::autotemp_M104_M109()
        16   -> Stopwatch::stop()
        16   -> Temperature::degHotend(uint8_t)
        16   -> Temperature::setTargetHotend(float, uint8_t)
        16   -> __aeabi_cfcmple
        16   -> __aeabi_cfrcmple
        16   -> __aeabi_f2iz
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
        16   -> get_target_extruder_from_command(uint16_t)
        16   -> lcd_setstatusPGM(char const *, int8_t)
       8   gcode_M105()
         8   -> Temperature::print_heaterstates()
         0   -> USARTClass::write(uint8_t)
         8   -> get_target_extruder_from_command(uint16_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M106()
         8   -> GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::ushortval(char, uint16_t)
       8   gcode_M107()
         8   -> GCodeParser::ushortval(char, uint16_t)
       0   gcode_M108()
      48   gcode_M109()
        48   -> GCodeParser::seenval(char)
        48   -> GCodeParser::value_celsius()
        48   -> HAL_GetTick
        48   -> Planner::autotemp_M104_M109()
        48   -> Print::print(long, int)
        48   -> Stopwatch::start()
        48   -> Stopwatch::stop()
        48   -> Temperature::degHotend(uint8_t)
        48   -> Temperature::degTargetHotend(uint8_t)
        48   -> Temperature::isCoolingHotend(uint8_t)
        48   -> Temperature::print_heaterstates()
        48   -> Temperature::setTargetHotend(float, uint8_t)
        48   -> Temperature::start_watching_heater(uint8_t)
        48   -> USARTClass::write(uint8_t)
        48   -> __aeabi_cfcmpeq
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_f2iz
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> get_target_extruder_from_command(uint16_t)
        48   -> idle()
         0   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
       8   gcode_M110()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_long()
      16   gcode_M111()
        16   -> GCodeParser::byteval(char, uint8_t)
        16   -> GCodeParser::seen(char)
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       0   gcode_M112()
         0   -> kill(char const *)
       8   gcode_M113()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
         0   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, unsigned long)
         8   -> serialprintPGM(char const *)
       8   gcode_M114()
         8   -> Stepper::synchronize()
         0   -> report_current_position()
       8   gcode_M115()
         0   -> cap_line(char const *, bool)
         8   -> cap_line(char const *, bool)
         8   -> serialprintPGM(char const *)
       0   gcode_M117()
         0   -> lcd_setstatus(char const *, bool)
       8   gcode_M118()
         8   -> GCodeParser::boolval(char)
         8   -> Print::print(char const *)
         0   -> USARTClass::write(uint8_t)
         8   -> serialprintPGM(char const *)
       0   gcode_M119()
         0   -> Endstops::M119()
       0   gcode_M120()
         0   -> Endstops::enable_globally(bool)
       0   gcode_M121()
         0   -> Endstops::enable_globally(bool)
       8   gcode_M140()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_celsius()
         0   -> Temperature::setTargetBed(float)
       8   gcode_M155()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_byte()
         0   -> Temperature::set_auto_report_interval(uint8_t)
       8   gcode_M17()
         0   -> enable_all_steppers()
         8   -> lcd_setstatusPGM(char const *, int8_t)
      16   gcode_M18_M84()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_millis_from_seconds()
        16   -> HAL_GPIO_WritePin
         0   -> Stepper::finish_and_disable()
        16   -> Stepper::synchronize()
         0   -> disable_e_steppers()
      48   gcode_M190()
        48   -> GCodeParser::seenval(char)
        48   -> GCodeParser::value_celsius()
        48   -> HAL_GetTick
        48   -> Print::print(long, int)
        48   -> Stopwatch::start()
        48   -> Temperature::degBed()
        48   -> Temperature::degTargetBed()
        48   -> Temperature::isCoolingBed()
        48   -> Temperature::print_heaterstates()
        48   -> Temperature::setTargetBed(float)
        48   -> USARTClass::write(uint8_t)
        48   -> __aeabi_cfcmpeq
        48   -> __aeabi_cfcmple
        48   -> __aeabi_cfrcmple
        48   -> __aeabi_fsub
        48   -> idle()
         0   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> lcd_setstatusPGM(char const *, int8_t)
        48   -> refresh_cmd_timeout()
        48   -> serialprintPGM(char const *)
       8   gcode_M20()
         8   -> CardReader::ls()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
      16   gcode_M200()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> Planner::calculate_volumetric_multipliers()
        16   -> Planner::set_filament_size(uint8_t, float const &)
        16   -> __aeabi_cfcmpeq
        16   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M201()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
         0   -> Planner::reset_acceleration_rates()
        16   -> __aeabi_f2uiz
        16   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M203()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
        16   -> get_target_extruder_from_command(uint16_t)
       8   gcode_M204()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
       8   gcode_M205()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         8   -> GCodeParser::value_ulong()
      16   gcode_M206()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_float()
        16   -> GCodeParser::value_linear_units()
         0   -> report_current_position()
        16   -> set_home_offset(AxisEnum, float)
      24   gcode_M211()
        24   -> GCodeParser::seen(char)
        24   -> GCodeParser::value_bool()
         0   -> USARTClass::write(uint8_t)
        24   -> __aeabi_fadd
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
      24   gcode_M218()
        24   -> GCodeParser::seenval(char)
        24   -> GCodeParser::value_linear_units()
        24   -> Print::print(double, int)
         0   -> USARTClass::write(uint8_t)
        24   -> USARTClass::write(uint8_t)
        24   -> __aeabi_f2d
        24   -> get_target_extruder_from_command(uint16_t)
        24   -> serialprintPGM(char const *)
       0   gcode_M22()
         0   -> CardReader::release()
       8   gcode_M220()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
       8   gcode_M221()
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_int()
         0   -> Planner::refresh_e_factor(uint8_t)
         8   -> get_target_extruder_from_command(uint16_t)
      16   gcode_M226()
        16   -> GCodeParser::intval(char, int16_t)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_int()
        16   -> HAL_GPIO_ReadPin
        16   -> Stepper::synchronize()
        16   -> idle()
        16   -> pin_is_protected(int8_t)
       8   gcode_M23()
         8   -> CardReader::openFile(char *, bool, bool)
         0   -> strcpy
       8   gcode_M24()
         8   -> CardReader::startFileprint()
         0   -> Stopwatch::start()
         8   -> mks_resumePrint
       8   gcode_M25()
         8   -> CardReader::pauseSDPrint()
         8   -> Stopwatch::pause()
       8   gcode_M26()
         0   -> CardReader::setIndex(long)
         8   -> GCodeParser::seenval(char)
         8   -> GCodeParser::value_long()
       0   gcode_M27()
         0   -> CardReader::getStatus()
       0   gcode_M28()
         0   -> CardReader::openFile(char *, bool, bool)
       8   gcode_M280()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_int()
         8   -> serial_echopair_P(char const *, int)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M29()
       8   gcode_M30()
         8   -> CardReader::closefile(bool)
         0   -> CardReader::removeFile(char *)
       8   gcode_M301()
         8   -> GCodeParser::byteval(char, uint8_t)
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         8   -> Print::print(char const *)
         8   -> Temperature::updatePID()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      16   gcode_M302()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_bool()
        16   -> GCodeParser::value_celsius()
        16   -> __aeabi_f2iz
        16   -> serial_echopair_P(char const *, char const *)
        16   -> serial_echopair_P(char const *, int)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      16   gcode_M303()
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::celsiusval(char, float)
        16   -> GCodeParser::intval(char, int16_t)
         0   -> Temperature::PID_autotune(float, int8_t, int8_t, bool)
        16   -> __aeabi_f2iz
        16   -> __aeabi_i2f
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
       8   gcode_M304()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_dmul
         8   -> __aeabi_f2d
         8   -> serial_echopair_P(char const *, double)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
      40   gcode_M31()
        40   -> Stopwatch::duration()
        40   -> USARTClass::write(uint8_t)
        40   -> duration_t::duration_t(uint32_t const &)
        40   -> duration_t::toString(char *) const
        40   -> lcd_setstatus(char const *, bool)
        40   -> serial_echopair_P(char const *, char const *)
        40   -> serialprintPGM(char const *)
      16   gcode_M32()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
        16   -> CardReader::startFileprint()
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_long()
        16   -> Stepper::synchronize()
         0   -> Stopwatch::start()
       8   gcode_M355()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       8   gcode_M360()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M361()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M362()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M363()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       8   gcode_M364()
         0   -> SCARA_move_to_cal(uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
       0   gcode_M400()
         0   -> Stepper::synchronize()
       0   gcode_M401()
         0   -> set_probe_deployed(bool)
       0   gcode_M402()
         0   -> set_probe_deployed(bool)
       0   gcode_M410()
         0   -> quickstop_stepper()
      16   gcode_M42()
        16   -> GCodeParser::intval(char, int16_t)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_byte()
        16   -> HAL_GPIO_WritePin
        16   -> pin_is_protected(int8_t)
         0   -> serialprintPGM(char const *)
        16   -> serialprintPGM(char const *)
      40   gcode_M420()
        40   -> GCodeParser::has_value()
        40   -> GCodeParser::seen(char)
        40   -> GCodeParser::value_bool()
        40   -> GCodeParser::value_int()
        40   -> GCodeParser::value_linear_units()
        40   -> MarlinSettings::calc_num_meshes()
        40   -> MarlinSettings::load_mesh(int8_t, void *)
        40   -> Print::print(double, int)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_f2d
        40   -> leveling_is_valid()
        40   -> matrix_3x3::debug(char const *)
        40   -> mbl_mesh_report()
        40   -> memcmp
        40   -> print_bilinear_leveling_grid()
        40   -> report_current_position()
        40   -> serial_echopair_P(char const *, bool)
        40   -> serial_echopair_P(char const *, char const *)
        40   -> serial_echopair_P(char const *, int)
        40   -> serialprintPGM(char const *)
        40   -> set_bed_leveling_enabled(bool)
        40   -> set_z_fade_height(float, bool)
        40   -> unified_bed_leveling::display_map(int)
        40   -> unified_bed_leveling::mesh_is_valid()
      32   gcode_M421_AUTO_BED_LEVELING_BILINEAR()
        32   -> GCodeParser::intval(char, int16_t)
        32   -> GCodeParser::seen(char)
        32   -> GCodeParser::value_linear_units()
        32   -> __aeabi_fadd
         0   -> serialprintPGM(char const *)
        32   -> serialprintPGM(char const *)
      48   gcode_M421_AUTO_BED_LEVELING_UBL()
        48   -> GCodeParser::intval(char, int16_t)
        48   -> GCodeParser::seen(char)
        48   -> GCodeParser::value_linear_units()
        48   -> __aeabi_fadd
         0   -> serialprintPGM(char const *)
        48   -> serialprintPGM(char const *)
        48   -> unified_bed_leveling::find_closest_mesh_point_of_type(MeshPointType, float const &, float const &, bool, unsigned int *)
      40   gcode_M421_MESH_BED_LEVELING()
        40   -> GCodeParser::seen(char)
        40   -> GCodeParser::value_int()
        40   -> GCodeParser::value_linear_units()
        40   -> __aeabi_fadd
        40   -> mesh_bed_leveling::probe_index_x(float const &)
        40   -> mesh_bed_leveling::probe_index_y(float const &)
        40   -> mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
        40   -> serialprintPGM(char const *)
      32   gcode_M428()
        32   -> __aeabi_cfcmple
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fsub
        32   -> axis_unhomed_error(bool, bool, bool)
        32   -> base_home_pos(AxisEnum)
        32   -> home_dir(AxisEnum)
        32   -> lcd_setalertstatusPGM(char const *)
        32   -> lcd_setstatusPGM(char const *, int8_t)
        32   -> report_current_position()
        32   -> serialprintPGM(char const *)
        32   -> set_home_offset(AxisEnum, float)
       8   gcode_M49()
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M500()
         0   -> MarlinSettings::save()
       0   gcode_M501()
         0   -> MarlinSettings::load()
       0   gcode_M502()
         0   -> MarlinSettings::reset()
       8   gcode_M503()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_bool()
         0   -> MarlinSettings::report(bool)
       8   gcode_M665()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_float()
         8   -> GCodeParser::value_linear_units()
         0   -> recalc_delta_settings()
      16   gcode_M666()
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> __aeabi_cfcmple
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
       8   gcode_M666_dual()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> serial_echopair_P(char const *, float)
         8   -> serialprintPGM(char const *)
       0   gcode_M75()
         0   -> Stopwatch::start()
       0   gcode_M76()
         0   -> Stopwatch::pause()
       0   gcode_M77()
         0   -> Stopwatch::stop()
       8   gcode_M81()
         8   -> Stepper::finish_and_disable()
         8   -> Temperature::disable_all_heaters()
         0   -> safe_delay(millis_t)
       0   gcode_M82()
       0   gcode_M83()
       8   gcode_M85()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_millis_from_seconds()
       8   gcode_M851()
         8   -> GCodeParser::seen(char)
         8   -> GCodeParser::value_linear_units()
         0   -> USARTClass::write(uint8_t)
         8   -> __aeabi_cfcmple
         8   -> __aeabi_cfrcmple
         8   -> serial_echopair_P(char const *, float)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
       0   gcode_M907()
      32   gcode_M92()
        32   -> GCodeParser::seen(char)
        32   -> GCodeParser::value_per_axis_unit(AxisEnum)
         0   -> Planner::refresh_positioning()
        32   -> __aeabi_cfcmple
        32   -> __aeabi_f2uiz
        32   -> __aeabi_fdiv
        32   -> __aeabi_fmul
        32   -> __aeabi_ui2f
        32   -> get_target_extruder_from_command(uint16_t)
       0   gcode_M928()
         0   -> CardReader::openLogFile(char *)
       8   gcode_M998()
         8   -> CardReader::stopSDPrint()
         8   -> Stopwatch::stop()
         8   -> Temperature::disable_all_heaters()
         8   -> clear_command_queue()
         8   -> epr_write_data
         8   -> quickstop_stepper()
       8   gcode_M999()
         0   -> FlushSerialRequestResend()
         8   -> GCodeParser::boolval(char)
         8   -> lcd_reset_alert_level()
      16   gcode_T(uint8_t)
        16   -> GCodeParser::boolval(char)
        16   -> GCodeParser::linearval(char, float)
        16   -> __aeabi_fdiv
         0   -> tool_change(uint8_t, float, bool)
      16   gcode_get_destination()
        16   -> GCodeParser::linearval(char, float)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_axis_units(AxisEnum)
        16   -> GCodeParser::value_feedrate()
        16   -> __aeabi_cfrcmple
        16   -> __aeabi_fadd
        16   -> __aeabi_fdiv
      16   gcode_line_error(char const *, bool)
        16   -> FlushSerialRequestResend()
        16   -> Print::print(long, int)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
       8   get_available_commands()
         8   -> drain_injected_commands_P()
         0   -> get_sdcard_commands()
         8   -> get_serial_commands()
         8   -> get_wifi_commands()
      24   get_cartesian_from_steppers()
        24   -> Stepper::get_axis_position_degrees(AxisEnum)
        24   -> Stepper::get_axis_position_mm(AxisEnum)
        24   -> forward_kinematics_DELTA(float, float, float)
        24   -> forward_kinematics_SCARA(float const &, float const &)
      32   get_homing_bump_feedrate(AxisEnum)
        32   -> __aeabi_fdiv
        32   -> __aeabi_ui2f
        32   -> serialprintPGM(char const *)
      32   get_sdcard_commands()
        32   -> CardReader::checkautostart(bool)
        32   -> CardReader::eof()
        32   -> CardReader::get()
        32   -> CardReader::getsdpos()
        32   -> CardReader::initsd()
        32   -> CardReader::printingHasFinished()
        32   -> CardReader::reopenfile(char *)
        32   -> CardReader::setIndex(long)
        32   -> GUI_Exec
        32   -> GUI_RefreshPage
        32   -> GUI_TOUCH_Exec
        32   -> SD_Init
        32   -> Temperature::manage_heater()
        32   -> _commit_command(bool)
        32   -> disp_pre_gcode
        32   -> display_temper_error()
        32   -> memset
        32   -> serialprintPGM(char const *)
      32   get_serial_commands()
        32   -> HAL_GetTick
        32   -> IsStopped()
        32   -> USARTClass::available()
        32   -> USARTClass::read()
        32   -> _enqueuecommand(char const *, bool)
         0   -> gcode_line_error(char const *, bool)
        32   -> kill(char const *)
        32   -> lcd_setstatusPGM(char const *, int8_t)
        32   -> quickstop_stepper()
        32   -> serialprintPGM(char const *)
        32   -> strchr(char *, int)
        32   -> strcmp
        32   -> strrchr(char *, int)
        32   -> strstr(char *, char const *)
        32   -> strtol
      16   get_target_extruder_from_command(uint16_t)
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::value_byte()
        16   -> Print::print(int, int)
        16   -> USARTClass::write(uint8_t)
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
      24   get_wifi_commands()
        24   -> IsStopped()
        24   -> _enqueuecommand(char const *, bool)
        24   -> kill(char const *)
        24   -> lcd_setstatusPGM(char const *, int8_t)
        24   -> quickstop_stepper()
        24   -> serialprintPGM(char const *)
        24   -> strchr(char *, int)
        24   -> strcmp
        24   -> strtol
       0   home_all_axes()
         0   -> gcode_G28(bool)
       0   home_bump_mm(AxisEnum)
       8   home_delta()
         8   -> Endstops::hit_on_purpose()
         8   -> SYNC_PLAN_POSITION_KINEMATIC()
         8   -> Stepper::synchronize()
         8   -> __aeabi_fadd
         8   -> buffer_line_to_current_position()
         8   -> homeaxis(AxisEnum)
         8   -> lcd_setstatusPGM(char const *, int8_t)
         8   -> memset
         8   -> serialprintPGM(char const *)
         8   -> set_axis_is_at_home(AxisEnum)
         8   -> sync_plan_position()
       0   home_dir(AxisEnum)
      40   homeaxis(AxisEnum)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> Stepper::set_homing_flag_z(bool)
        40   -> Stepper::set_z2_lock(bool)
        40   -> Stepper::set_z_lock(bool)
        40   -> __aeabi_cfcmpeq
        40   -> __aeabi_cfcmple
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_d2f
        40   -> __aeabi_dmul
        40   -> __aeabi_dsub
        40   -> __aeabi_f2d
        40   -> __aeabi_fmul
        40   -> __aeabi_i2d
        40   -> __aeabi_i2f
        40   -> do_homing_move(AxisEnum, float, float)
        40   -> get_homing_bump_feedrate(AxisEnum)
        40   -> home_bump_mm(AxisEnum)
        40   -> home_dir(AxisEnum)
        40   -> max_length(AxisEnum)
        40   -> set_axis_is_at_home(AxisEnum)
         0   -> set_probe_deployed(bool)
        40   -> set_probe_deployed(bool)
        40   -> sync_plan_position()
      16   host_keepalive()
        16   -> HAL_GetTick
        16   -> serialprintPGM(char const *)
       8   idle()
         0   -> GUI_Exec
         8   -> GUI_RefreshPage
         8   -> GUI_TOUCH_Exec
         8   -> Temperature::auto_report_temperatures()
         8   -> Temperature::manage_heater()
         8   -> disp_pre_gcode
         8   -> display_temper_error()
         8   -> host_keepalive()
         8   -> lcd_reInit()
         8   -> lcd_update()
         8   -> manage_inactivity(bool)
         8   -> wifi_looping()
      40   incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
       0   incremental_LSF_reset(linear_fit_data *)
         0   -> memset
      16   invalid_extruder_error(uint8_t)
        16   -> Print::print(char const *)
        16   -> Print::print(unsigned char, int)
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> serialprintPGM(char const *)
      40   inverse_kinematics(float const *)
        40   -> __aeabi_fadd
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> sqrtf
      40   inverse_kinematics_MORGAN_SCARA(float const *)
        40   -> __aeabi_d2f
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> atan2f
        40   -> sqrtf
       8   kill(char const *)
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       8   kill_c
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> suicide()
       0   lcd_hasstatus()
       0   lcd_init()
       8   lcd_reInit()
         8   -> GUI_Init
         8   -> GUI_UC_SetEncodeUTF8
         8   -> clear_cur_ui
         8   -> draw_return_ui
         8   -> gui_view_init
       0   lcd_refresh()
       0   lcd_reset_alert_level()
       0   lcd_setalertstatusPGM(char const *)
       0   lcd_setstatus(char const *, bool)
       0   lcd_setstatusPGM(char const *, int8_t)
       0   lcd_update()
       0   leveling_is_valid()
      24   loop
        24   -> CardReader::checkFilesys(unsigned char)
        24   -> CardReader::closefile(bool)
        24   -> CardReader::write_command(char *)
        24   -> Endstops::report_state()
        24   -> PowerOff_Filament_Check()
        24   -> USARTClass::MoremenuCmd()
        24   -> display_temper_error()
        24   -> get_available_commands()
        24   -> idle()
         0   -> mks_PrintStatePolling
        24   -> ok_to_send()
        24   -> process_next_command()
        24   -> serialprintPGM(char const *)
        24   -> strstr(char *, char const *)
      24   manage_inactivity(bool)
        24   -> HAL_GPIO_WritePin
        24   -> HAL_GetTick
        24   -> Planner::blocks_queued()
         0   -> Planner::check_axes_activity()
        24   -> USARTClass::write(uint8_t)
        24   -> disable_e_steppers()
        24   -> get_available_commands()
        24   -> kill(char const *)
        24   -> serial_echopair_P(char const *, char const *)
        24   -> serialprintPGM(char const *)
       0   max_length(AxisEnum)
      24   mbl_mesh_report()
        24   -> Print::print(double, int)
        24   -> Print::print(int, int)
        24   -> USARTClass::write(uint8_t)
        24   -> __aeabi_f2d
         0   -> print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
        24   -> serialprintPGM(char const *)
      40   mesh_bed_leveling::cell_index_x(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   mesh_bed_leveling::cell_index_y(float const &)
        40   -> __aeabi_cfcmple
        40   -> __aeabi_d2iz
        40   -> __aeabi_ddiv
        40   -> __aeabi_dmul
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      48   mesh_bed_leveling::probe_index_x(float const &)
        48   -> __aeabi_cfcmple
        48   -> __aeabi_d2iz
        48   -> __aeabi_dadd
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> __aeabi_ui2f
      48   mesh_bed_leveling::probe_index_y(float const &)
        48   -> __aeabi_cfcmple
        48   -> __aeabi_d2iz
        48   -> __aeabi_dadd
        48   -> __aeabi_ddiv
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> __aeabi_i2f
        48   -> __aeabi_ui2f
       0   mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
      16   mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
        16   -> mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
        16   -> mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
       8   mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
      56   mesh_line_to_destination(float, uint8_t, uint8_t)
        56   -> __aeabi_fadd
        56   -> __aeabi_fdiv
        56   -> __aeabi_fmul
        56   -> __aeabi_fsub
        56   -> buffer_line_to_destination(float)
        56   -> memcpy
        56   -> mesh_bed_leveling::cell_index_x(float const &)
        56   -> mesh_bed_leveling::cell_index_y(float const &)
        56   -> mesh_line_to_destination(float, uint8_t, uint8_t)
        56   -> set_current_from_destination()
      16   mks_G28(char *)
        16   -> GCodeParser::parse(char *)
        16   -> GCodeParser::seen(char)
        16   -> GCodeParser::value_linear_units()
        16   -> gcode_G28(bool)
        16   -> memset
        16   -> set_bed_leveling_enabled(bool)
         0   -> set_z_fade_height(float, bool)
        16   -> strcpy
      24   mks_PrintStatePolling
        24   -> CardReader::getsdpos()
        24   -> CardReader::startFileprint()
         0   -> Close_machine_display()
        24   -> Planner::blocks_queued()
        24   -> Stepper::synchronize()
        24   -> Stopwatch::start()
        24   -> Stopwatch::stop()
        24   -> Temperature::disable_all_heaters()
        24   -> __aeabi_cfrcmple
        24   -> __aeabi_fsub
        24   -> __aeabi_i2f
        24   -> clear_command_queue()
        24   -> epr_write_data
        24   -> mks_G28(char *)
        24   -> mks_WriteToFile
        24   -> mks_adjust_extrude_speed
        24   -> mks_clearFile
        24   -> mks_contiuePrintDelta
        24   -> mks_contiuePrintPause
        24   -> mks_contiuePrintPwdwn
        24   -> mks_moveXY
        24   -> mks_moveZ
        24   -> mks_pausePrint
        24   -> mks_preExtrude
        24   -> mks_resume_extrude_speed
        24   -> quickstop_stepper()
      16   mks_ReadFromEpr
        16   -> epr_read_data
      16   mks_ReadFromEpr_pwroff()
        16   -> epr_read_data
      48   mks_ReadFromFile
        48   -> __aeabi_memclr4
        48   -> f_close
        48   -> f_open
        48   -> mks_get_commands()
        48   -> strcat
      32   mks_ResetPositionZ(float)
        32   -> GCodeParser::parse(char *)
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy
        32   -> gcode_G92()
        32   -> memset
        32   -> sprintf
        32   -> strcat
      24   mks_WriteToEpr()
        24   -> CardReader::getsdpos()
         0   -> epr_write_data
        24   -> epr_write_data
      24   mks_WriteToEpr_pwroff()
        24   -> CardReader::getsdpos()
         0   -> epr_write_data
        24   -> epr_write_data
      80   mks_WriteToFile
        80   -> HAL_GetTick
        80   -> Stopwatch::getTime(millis_t *, millis_t *, millis_t *)
        80   -> __aeabi_f2d
        80   -> __aeabi_memclr4
        80   -> __aeabi_memcpy4
        80   -> f_close
        80   -> f_open
        80   -> f_printf
        80   -> memset
        80   -> sprintf
        80   -> strcat
      16   mks_adjust_extrude_speed
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_i2d
      40   mks_clearDir
        40   -> strcpy
        40   -> strstr(char *, char const *)
      64   mks_clearFile
        64   -> __aeabi_memclr4
        64   -> __aeabi_memcpy4
        64   -> f_close
        64   -> f_open
        64   -> f_printf
        64   -> strcat
      16   mks_contiuePrintDelta
        16   -> gcode_M24()
        16   -> mks_G28(char *)
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
        16   -> mks_setFeedrate()
        16   -> mks_setTemperature()
       8   mks_contiuePrintPause
         0   -> gcode_M24()
         8   -> mks_G28(char *)
         8   -> mks_adjust_extrude_speed
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
         8   -> mks_setFeedrate()
         8   -> mks_setPositionZ
         8   -> mks_setTemperature()
      16   mks_contiuePrintPwdwn
        16   -> HAL_Delay
        16   -> __aeabi_fadd
        16   -> gcode_M24()
        16   -> mks_G28(char *)
        16   -> mks_ResetPositionZ(float)
        16   -> mks_adjust_extrude_speed
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
        16   -> mks_setFeedrate()
        16   -> mks_setPositionZ
        16   -> mks_setTemperature()
      16   mks_contiuePrint_UI
        16   -> AT24CXX_Read
        16   -> Beeper(uint32_t)
        16   -> CardReader::isFileOpen()
        16   -> CardReader::openFile(char *, bool, bool)
        16   -> CardReader::setIndex(long)
         0   -> draw_dialog
         0   -> draw_printing
        16   -> epr_write_data
        16   -> getTick
        16   -> getTickDiff
        16   -> lcd_setstatus(char const *, bool)
        16   -> mks_clearDir
        16   -> mks_getPositionXYZE
        16   -> strcpy
      56   mks_getPositionXYZE
        56   -> CardReader::getsdpos()
        56   -> CardReader::setIndex(long)
        56   -> GCodeParser::parse(char *)
        56   -> __aeabi_cfcmple
        56   -> __aeabi_cfrcmple
        56   -> __aeabi_d2f
        56   -> abs
        56   -> atof
        56   -> clear_command_queue()
        56   -> gcode_get_destination()
        56   -> get_sdcard_commands()
        56   -> memset
        56   -> strchr(char *, int)
      48   mks_get_commands()
        48   -> __aeabi_d2f
        48   -> __aeabi_d2iz
        48   -> atof
        48   -> atoi
        48   -> memset
        48   -> pft_get()
        48   -> strcmp
      16   mks_initPrint
        16   -> memset
      48   mks_leveling_moveXY(float, float)
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      48   mks_leveling_moveZ(float)
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      16   mks_manual_leveling
        16   -> __aeabi_i2f
         0   -> enqueue_and_echo_commands_P(char const *)
        16   -> mks_G28(char *)
        16   -> mks_leveling_moveXY(float, float)
        16   -> mks_leveling_moveZ(float)
      40   mks_moveXY
        40   -> GCodeParser::parse(char *)
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_memcpy
        40   -> gcode_G0_G1()
        40   -> memset
        40   -> sprintf
        40   -> strcat
      40   mks_moveZ
        40   -> GCodeParser::parse(char *)
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_fadd
        40   -> __aeabi_memcpy
        40   -> gcode_G0_G1()
        40   -> memset
        40   -> sprintf
        40   -> strcat
      40   mks_moveZ_relative(float)
        40   -> GCodeParser::parse(char *)
        40   -> Stepper::synchronize()
        40   -> __aeabi_f2d
        40   -> __aeabi_memcpy
        40   -> gcode_G0_G1()
        40   -> memset
        40   -> sprintf
        40   -> strcat
      16   mks_pausePrint
        16   -> Stepper::synchronize()
        16   -> __aeabi_cfcmpeq
        16   -> __aeabi_i2f
         0   -> mks_WriteToEpr()
        16   -> mks_moveXY
        16   -> mks_moveZ
        16   -> mks_preExtrude
      48   mks_preExtrude
        48   -> GCodeParser::parse(char *)
        48   -> Stepper::synchronize()
        48   -> __aeabi_f2d
        48   -> __aeabi_memcpy
        48   -> gcode_G0_G1()
        48   -> gcode_G92()
        48   -> memset
        48   -> sprintf
        48   -> strcat
      16   mks_rePrintCheck
         0   -> draw_ready_print
        16   -> epr_read_data
        16   -> epr_write_data
        16   -> getTick
        16   -> getTickDiff
        16   -> mks_ReadFromEpr
        16   -> mks_ReadFromEpr_pwroff()
        16   -> mks_ReadFromFile
        16   -> mks_contiuePrint_UI
       8   mks_resumePrint
         8   -> lcd_setstatus(char const *, bool)
         8   -> mks_moveXY
         8   -> mks_moveZ
         8   -> mks_preExtrude
      16   mks_resume_extrude_speed
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_i2d
      16   mks_saveFileName
        16   -> epr_write_data
        16   -> memset
         0   -> mks_clearFile
        16   -> strcpy
       0   mks_setFeedrate()
      32   mks_setPositionZ
        32   -> GCodeParser::parse(char *)
        32   -> __aeabi_f2d
        32   -> __aeabi_memcpy
        32   -> gcode_G92()
        32   -> memset
        32   -> sprintf
        32   -> strcat
      56   mks_setTemperature()
        56   -> GCodeParser::parse(char *)
        56   -> __aeabi_memcpy
        56   -> gcode_M104()
        56   -> gcode_M109()
        56   -> gcode_M140()
        56   -> gcode_M190()
        56   -> memset
        56   -> sprintf
        56   -> strcat
      40   mkstft_ui_init
        40   -> __aeabi_memcpy
        40   -> __aeabi_memcpy4
        40   -> memset
        40   -> mkstft_ui_set_epr()
       8   mkstft_ui_load
         0   -> epr_read_data
         8   -> epr_read_data
      24   mkstft_ui_set_epr()
        24   -> epr_read_data
        24   -> epr_write_data
       8   ok_to_send()
         0   -> USARTClass::write(uint8_t)
         8   -> refresh_cmd_timeout()
         8   -> serialprintPGM(char const *)
       8   out_of_range_error(char const *)
         0   -> serialprintPGM(char const *)
         8   -> serialprintPGM(char const *)
      16   pft_get()
        16   -> f_read
       0   pin_is_protected(int8_t)
      96   plan_arc(float const (&)[4], float const (&)[2], bool)
        96   -> HAL_GetTick
        96   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        96   -> Temperature::manage_heater()
        96   -> __aeabi_cfcmpeq
        96   -> __aeabi_cfcmple
        96   -> __aeabi_d2f
        96   -> __aeabi_dadd
        96   -> __aeabi_dmul
        96   -> __aeabi_dsub
        96   -> __aeabi_f2d
        96   -> __aeabi_f2iz
        96   -> __aeabi_fadd
        96   -> __aeabi_fdiv
        96   -> __aeabi_fmul
        96   -> __aeabi_fsub
        96   -> __aeabi_i2f
        96   -> __aeabi_ui2f
        96   -> atan2f
        96   -> clamp_to_software_endstops(float *)
        96   -> cosf
        96   -> floorf
        96   -> idle()
        96   -> set_current_from_destination()
        96   -> sinf
        96   -> sqrtf
      40   position_is_reachable_IS_CARTESIAN(float const &, float const &)
        40   -> __aeabi_cdrcmple
        40   -> __aeabi_dadd
        40   -> __aeabi_f2d
      32   position_is_reachable_IS_KINEMATIC(float const &, float const &)
        32   -> __aeabi_cfrcmple
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
      40   position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
        40   -> __aeabi_cdrcmple
        40   -> __aeabi_dadd
        40   -> __aeabi_f2d
      24   position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
        24   -> __aeabi_fsub
        24   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
      88   prepare_kinematic_move_to(float const (&)[4])
        88   -> ADJUST_DELTA(float const *)
        88   -> HAL_GetTick
        88   -> Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
        88   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        88   -> Temperature::manage_heater()
        88   -> __aeabi_cfcmpeq
        88   -> __aeabi_cfcmple
        88   -> __aeabi_d2f
        88   -> __aeabi_dmul
        88   -> __aeabi_f2d
        88   -> __aeabi_f2iz
        88   -> __aeabi_fadd
        88   -> __aeabi_fdiv
        88   -> __aeabi_fmul
        88   -> __aeabi_fsub
        88   -> __aeabi_i2f
        88   -> __aeabi_ui2f
        88   -> idle()
        88   -> inverse_kinematics(float const *)
        88   -> lroundf
        88   -> memcpy
        88   -> position_is_reachable_IS_CARTESIAN(float const &, float const &)
        88   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
        88   -> sqrtf
      16   prepare_move_to_destination()
        16   -> Temperature::tooColdToExtrude(uint8_t)
        16   -> __aeabi_cfcmpeq
        16   -> __aeabi_cfrcmple
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_fmul
        16   -> __aeabi_fsub
        16   -> __aeabi_i2f
        16   -> clamp_to_software_endstops(float *)
        16   -> prepare_kinematic_move_to(float const (&)[4])
        16   -> prepare_move_to_destination_cartesian()
        16   -> refresh_cmd_timeout()
        16   -> serialprintPGM(char const *)
        16   -> set_current_from_destination()
        16   -> unified_bed_leveling::prepare_segmented_line_to(float const (&)[4], float const &)
      24   prepare_move_to_destination_cartesian()
        24   -> Planner::leveling_active_at_z(float const &)
        24   -> __aeabi_cfcmpeq
        24   -> __aeabi_d2f
        24   -> __aeabi_dmul
        24   -> __aeabi_f2d
        24   -> __aeabi_fmul
        24   -> __aeabi_i2f
        24   -> bilinear_line_to_destination(float, uint16_t, uint16_t)
        24   -> buffer_line_to_destination(float)
        24   -> mesh_line_to_destination(float, uint8_t, uint8_t)
        24   -> unified_bed_leveling::line_to_destination_cartesian(float const &, uint8_t)
      16   prepare_uninterpolated_move_to_destination(float)
        16   -> Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
        16   -> __aeabi_cfcmpeq
        16   -> __aeabi_d2f
        16   -> __aeabi_dmul
        16   -> __aeabi_f2d
        16   -> __aeabi_fmul
        16   -> __aeabi_i2f
        16   -> refresh_cmd_timeout()
        16   -> set_current_from_destination()
      40   print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
        40   -> Print::print(double, int)
        40   -> Print::print(int, int)
         0   -> USARTClass::write(uint8_t)
        40   -> USARTClass::write(uint8_t)
        40   -> __aeabi_cfrcmple
        40   -> __aeabi_f2d
        40   -> __iar_FDtest
       8   print_bilinear_leveling_grid()
         0   -> print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
         8   -> serialprintPGM(char const *)
      64   probe_pt(float const &, float const &, bool, uint8_t, bool)
        64   -> Print::print(double, int)
        64   -> USARTClass::write(uint8_t)
        64   -> __aeabi_cfcmple
        64   -> __aeabi_f2d
        64   -> __aeabi_fadd
        64   -> __aeabi_fdiv
        64   -> __aeabi_fsub
        64   -> __iar_FDtest
        64   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        64   -> do_blocking_move_to_z(float const &, float const &)
        64   -> lcd_setstatusPGM(char const *, int8_t)
        64   -> position_is_reachable_IS_CARTESIAN(float const &, float const &)
        64   -> position_is_reachable_IS_KINEMATIC(float const &, float const &)
        64   -> position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
        64   -> position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
        64   -> run_z_probe()
        64   -> serialprintPGM(char const *)
        64   -> set_probe_deployed(bool)
      16   process_next_command()
        16   -> GCodeParser::parse(char *)
        16   -> Print::print(char const *)
        16   -> USARTClass::write(uint8_t)
         0   -> process_parsed_command()
        16   -> serialprintPGM(char const *)
      16   process_parsed_command()
        16   -> CardReader::pauseSDPrint()
        16   -> GCodeParser::seenval(char)
        16   -> GCodeParser::unknown_command_error()
        16   -> GCodeParser::value_linear_units()
        16   -> MarlinSettings::save()
        16   -> Print::print(char const *)
        16   -> Stopwatch::pause()
        16   -> USARTClass::write(uint8_t)
        16   -> clear_cur_ui
        16   -> draw_printing
        16   -> gcode_G0_G1()
        16   -> gcode_G0_G1_SCARA(bool)
        16   -> gcode_G26()
        16   -> gcode_G28(bool)
        16   -> gcode_G29()
        16   -> gcode_G29_MESH_BED_LEVELING()
        16   -> gcode_G29_UBL()
        16   -> gcode_G2_G3(bool)
        16   -> gcode_G30()
        16   -> gcode_G4()
        16   -> gcode_G42()
        16   -> gcode_G92()
        16   -> gcode_M104()
        16   -> gcode_M105()
        16   -> gcode_M106()
        16   -> gcode_M107()
        16   -> gcode_M108()
        16   -> gcode_M109()
        16   -> gcode_M110()
        16   -> gcode_M111()
        16   -> gcode_M112()
        16   -> gcode_M113()
        16   -> gcode_M114()
        16   -> gcode_M115()
        16   -> gcode_M117()
        16   -> gcode_M118()
        16   -> gcode_M119()
        16   -> gcode_M120()
        16   -> gcode_M121()
        16   -> gcode_M140()
        16   -> gcode_M155()
        16   -> gcode_M17()
        16   -> gcode_M18_M84()
        16   -> gcode_M190()
        16   -> gcode_M20()
        16   -> gcode_M200()
        16   -> gcode_M201()
        16   -> gcode_M203()
        16   -> gcode_M204()
        16   -> gcode_M205()
        16   -> gcode_M206()
        16   -> gcode_M211()
        16   -> gcode_M218()
        16   -> gcode_M22()
        16   -> gcode_M220()
        16   -> gcode_M221()
        16   -> gcode_M226()
        16   -> gcode_M23()
        16   -> gcode_M24()
        16   -> gcode_M25()
        16   -> gcode_M26()
        16   -> gcode_M27()
        16   -> gcode_M28()
        16   -> gcode_M280()
        16   -> gcode_M29()
        16   -> gcode_M30()
        16   -> gcode_M301()
        16   -> gcode_M302()
        16   -> gcode_M303()
        16   -> gcode_M304()
        16   -> gcode_M31()
        16   -> gcode_M32()
        16   -> gcode_M355()
        16   -> gcode_M360()
        16   -> gcode_M361()
        16   -> gcode_M362()
        16   -> gcode_M363()
        16   -> gcode_M364()
        16   -> gcode_M400()
        16   -> gcode_M401()
        16   -> gcode_M402()
        16   -> gcode_M410()
        16   -> gcode_M42()
        16   -> gcode_M420()
        16   -> gcode_M421_AUTO_BED_LEVELING_BILINEAR()
        16   -> gcode_M421_AUTO_BED_LEVELING_UBL()
        16   -> gcode_M421_MESH_BED_LEVELING()
        16   -> gcode_M428()
        16   -> gcode_M49()
        16   -> gcode_M500()
        16   -> gcode_M501()
        16   -> gcode_M502()
        16   -> gcode_M503()
        16   -> gcode_M665()
        16   -> gcode_M666()
        16   -> gcode_M666_dual()
        16   -> gcode_M75()
        16   -> gcode_M76()
        16   -> gcode_M77()
        16   -> gcode_M81()
        16   -> gcode_M82()
        16   -> gcode_M83()
        16   -> gcode_M85()
        16   -> gcode_M851()
        16   -> gcode_M907()
        16   -> gcode_M92()
        16   -> gcode_M928()
        16   -> gcode_M998()
        16   -> gcode_M999()
        16   -> gcode_T(uint8_t)
         0   -> ok_to_send()
        16   -> preview_gcode_prehandle
        16   -> reset_file_info
        16   -> reset_print_time
        16   -> serialprintPGM(char const *)
        16   -> set_bed_leveling_enabled(bool)
        16   -> set_z_fade_height(float, bool)
        16   -> start_print_time
        16   -> stop_print_time
      48   quick_home_xy()
        48   -> Endstops::hit_on_purpose()
        48   -> __aeabi_cfcmple
        48   -> __aeabi_d2f
        48   -> __aeabi_dadd
        48   -> __aeabi_dmul
        48   -> __aeabi_f2d
        48   -> __aeabi_fdiv
        48   -> __aeabi_fmul
        48   -> __aeabi_i2d
        48   -> do_blocking_move_to_xy(float const &, float const &, float const &)
        48   -> home_dir(AxisEnum)
        48   -> max_length(AxisEnum)
        48   -> sqrt
        48   -> sync_plan_position()
       8   quickstop_stepper()
         0   -> SYNC_PLAN_POSITION_KINEMATIC()
         8   -> Stepper::quick_stop()
         8   -> Stepper::synchronize()
         8   -> set_current_from_steppers_for_axis(AxisEnum)
      32   recalc_delta_settings()
        32   -> __aeabi_d2f
        32   -> __aeabi_ddiv
        32   -> __aeabi_dmul
        32   -> __aeabi_f2d
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> cos
        32   -> sin
        32   -> update_software_endstops(AxisEnum)
       8   refresh_bed_level()
         8   -> __aeabi_d2f
         8   -> __aeabi_ddiv
         8   -> __aeabi_i2d
       8   refresh_cmd_timeout()
         8   -> HAL_GetTick
      16   report_current_position()
        16   -> Print::print(double, int)
        16   -> Stepper::get_axis_position_degrees(AxisEnum)
        16   -> Stepper::report_positions()
         0   -> USARTClass::write(uint8_t)
        16   -> USARTClass::write(uint8_t)
        16   -> __aeabi_f2d
        16   -> serial_echopair_P(char const *, float)
        16   -> serialprintPGM(char const *)
       8   reset_bed_level()
         8   -> leveling_is_valid()
         0   -> matrix_3x3::set_to_identity()
         8   -> mesh_bed_leveling::reset()
         8   -> set_bed_leveling_enabled(bool)
         0   -> unified_bed_leveling::reset()
      24   run_z_probe()
        24   -> __aeabi_cfcmple
        24   -> __aeabi_fadd
        24   -> __aeabi_fdiv
        24   -> __aeabi_fsub
        24   -> do_blocking_move_to_z(float const &, float const &)
        24   -> do_probe_move(float, float)
        24   -> refresh_cmd_timeout()
       0   serial_echopair_P(char const *, bool)
         0   -> serial_echopair_P(char const *, int)
       8   serialprintPGM(char const *)
         8   -> USARTClass::write(uint8_t)
       0   servo_init()
      48   set_axis_is_at_home(AxisEnum)
        48   -> __aeabi_fsub
        48   -> base_home_pos(AxisEnum)
        48   -> base_max_pos(AxisEnum)
        48   -> base_min_pos(AxisEnum)
        48   -> forward_kinematics_SCARA(float const &, float const &)
        48   -> inverse_kinematics_MORGAN_SCARA(float const *)
        48   -> serialprintPGM(char const *)
        48   -> update_software_endstops(AxisEnum)
      40   set_bed_leveling_enabled(bool)
        40   -> Planner::apply_leveling(float &, float &, float &)
        40   -> Planner::unapply_leveling(float *)
        40   -> SYNC_PLAN_POSITION_KINEMATIC()
        40   -> bilinear_z_offset(float const *)
        40   -> leveling_is_valid()
        40   -> set_current_from_steppers_for_axis(AxisEnum)
      24   set_bltouch_deployed(bool)
        24   -> HAL_GPIO_ReadPin
        24   -> bltouch_command(int)
        24   -> safe_delay(millis_t)
        24   -> serialprintPGM(char const *)
        24   -> stop()
       0   set_current_from_destination()
         0   -> memcpy
      16   set_current_from_steppers_for_axis(AxisEnum)
        16   -> Planner::unapply_leveling(float *)
        16   -> get_cartesian_from_steppers()
         0   -> memcpy
       0   set_destination_from_current()
         0   -> memcpy
       0   set_home_offset(AxisEnum, float)
         0   -> update_software_endstops(AxisEnum)
      24   set_probe_deployed(bool)
        24   -> Endstops::enable_z_probe(bool)
        24   -> __aeabi_cfcmple
        24   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
        24   -> do_probe_raise(float)
      32   set_z_fade_height(float, bool)
        32   -> Planner::set_z_fade_height(float const &)
        32   -> SYNC_PLAN_POSITION_KINEMATIC()
        32   -> __aeabi_cfcmpeq
        32   -> memcmp
        32   -> report_current_position()
        32   -> set_bed_leveling_enabled(bool)
        32   -> set_current_from_steppers_for_axis(AxisEnum)
      16   setup
        16   -> Endstops::enable_z_probe(bool)
        16   -> MarlinSettings::load()
        16   -> SYNC_PLAN_POSITION_KINEMATIC()
        16   -> Stepper::init()
        16   -> Temperature::init()
        16   -> USARTClass::write(uint8_t)
        16   -> bltouch_command(int)
        16   -> freeMemory()
        16   -> lcd_init()
        16   -> memcpy
        16   -> memset
        16   -> serial_echopair_P(char const *, int)
        16   -> serialprintPGM(char const *)
        16   -> servo_init()
        16   -> set_bltouch_deployed(bool)
        16   -> setup_killpin()
        16   -> soft_endstop_min_init()
       0   setup_for_endstop_or_probe_move()
         0   -> refresh_cmd_timeout()
       0   setup_killpin()
       0   setup_powerhold()
      24   soft_endstop_min_init()
        24   -> __aeabi_fmul
        24   -> __aeabi_fsub
       8   stop()
         8   -> IsRunning()
         8   -> Temperature::disable_all_heaters()
         8   -> lcd_setstatusPGM(char const *, int8_t)
         8   -> safe_delay(millis_t)
         8   -> serialprintPGM(char const *)
       0   strchr(char *, int)
         0   -> __iar_Strchr
       0   strrchr(char *, int)
         0   -> __iar_Strrchr
       0   strstr(char *, char const *)
         0   -> __iar_Strstr
       0   suicide()
       0   sync_plan_position()
         0   -> Planner::set_position_mm(float, float, float, float const &)
       0   sync_plan_position_e()
         0   -> Planner::set_e_position_mm(float const &)
       0   sync_plan_position_kinematic()
         0   -> Planner::set_position_mm_kinematic(float const (&)[4])
       8   temper_error_kill()
         8   -> HAL_Delay
         8   -> Temperature::disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
     148   tool_change(uint8_t, float, bool)
       136   -> IsRunning()
       136   -> Planner::apply_leveling(float &, float &, float &)
       136   -> SYNC_PLAN_POSITION_KINEMATIC()
       136   -> Stepper::synchronize()
       136   -> USARTClass::write(uint8_t)
       136   -> __aeabi_cfrcmple
       136   -> __aeabi_fadd
       136   -> __aeabi_fsub
       148   -> __aeabi_memcpy4
       136   -> axis_unhomed_error(bool, bool, bool)
       136   -> do_blocking_move_to(float const &, float const &, float const &, float const &)
       136   -> invalid_extruder_error(uint8_t)
       136   -> matrix_3x3::transpose(matrix_3x3)
       136   -> serial_echopair_P(char const *, int)
       136   -> serialprintPGM(char const *)
       136   -> set_destination_from_current()
       136   -> vector_3::apply_rotation(matrix_3x3)
       136   -> vector_3::operator-(vector_3)
       136   -> vector_3::vector_3(float, float, float)
      40   unified_bed_leveling::mesh_index_to_xpos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      40   unified_bed_leveling::mesh_index_to_ypos(uint8_t)
        40   -> __aeabi_cfcmple
         0   -> __aeabi_fadd
        40   -> __aeabi_fadd
        40   -> __aeabi_fdiv
        40   -> __aeabi_fmul
        40   -> __aeabi_fsub
        40   -> __aeabi_i2f
        40   -> __aeabi_ui2f
      16   unified_bed_leveling::mesh_is_valid()
        16   -> __aeabi_cfcmpeq
        16   -> __iar_FDtest
      32   update_software_endstops(AxisEnum)
        32   -> __aeabi_cfcmple
        32   -> __aeabi_fadd
        32   -> __aeabi_fmul
        32   -> __aeabi_fsub
        32   -> base_max_pos(AxisEnum)
        32   -> base_min_pos(AxisEnum)
        32   -> delta_safe_distance_from_top()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "   Psi+Theta:">
      24  ?<Constant "  PlannerBufferBytes: ">
       4  ?<Constant " E:">
      16  ?<Constant " Free Memory: ">
      20  ?<Constant " Invalid extruder ">
      16  ?<Constant " Last Updated: ">
       4  ?<Constant " Y">
       8  ?<Constant " Y: ">
       4  ?<Constant " Y:">
       8  ?<Constant " Z: ">
       4  ?<Constant " Z:">
      28  ?<Constant " cold extrusion preve...">
       8  ?<Constant " first\n">
      16  ?<Constant " not entered.\n">
      28  ?<Constant " position out of range.\n">
      32  ?<Constant " too long extrusion p...">
      36  ?<Constant " | Author: (none, def...">
      12  ?<Constant "%.3f F%.3f">
       8  ?<Constant "%.3f">
       4  ?<Constant "%d">
       4  ?<Constant "%f">
      52  ?<Constant "*** Z HOMED TO ENDSTO...">
       2  ?<Constant "/">
       8  ?<Constant "0.000">
       8  ?<Constant "1.0.0\n">
      12  ?<Constant "192.168.3.1">
      16  ?<Constant "192.168.3.100">
      16  ?<Constant "192.168.3.255">
      20  ?<Constant "2017-12-25 12:00">
      16  ?<Constant "255.255.255.0">
       2  ?<Constant ":">
       8  ?<Constant "?Probe ">
      20  ?<Constant "Active Extruder: ">
       8  ?<Constant "Bed X: ">
      28  ?<Constant "Bilinear Leveling Grid:\n">
       8  ?<Constant "Cap:">
      24  ?<Constant "Compiled: Feb 14 2020\n">
      20  ?<Constant "Done saving file.\n">
       8  ?<Constant "Err%d">
       8  ?<Constant "G1 E">
       8  ?<Constant "G1 X">
       8  ?<Constant "G1 Z">
       8  ?<Constant "G1 Z0">
      12  ?<Constant "G28 X0 Y0">
       4  ?<Constant "G28">
       8  ?<Constant "G92 E">
       8  ?<Constant "G92 Z">
      20  ?<Constant "HAS_NO_TEMP_BED!\n">
       8  ?<Constant "Home ">
      60  ?<Constant "KILL caused by too mu...">
      12  ?<Constant "KILLED. ">
      12  ?<Constant "M104 T1 S">
      12  ?<Constant "M109 T0 S">
      12  ?<Constant "M109 T1 S">
       8  ?<Constant "M140 S">
       8  ?<Constant "M190 S">
       4  ?<Constant "M29">
      16  ?<Constant "MKS Robin Nano">
      12  ?<Constant "Num X,Y: ">
      32  ?<Constant "Printer halted. kill(...">
     120  ?<Constant "Printer stopped due t...">
      16  ?<Constant "Probing failed">
      16  ?<Constant "Probing failed\n">
      12  ?<Constant "Resend: ">
      16  ?<Constant "Resume print?">
      16  ?<Constant "SCARA Theta:">
      60  ?<Constant "STOP called because o...">
      12  ?<Constant "STOPPED. ">
      12  ?<Constant "TP-LINK_MKS">
       2  ?<Constant "X">
       4  ?<Constant "X:">
       2  ?<Constant "Y">
      12  ?<Constant "Z offset: ">
       2  ?<Constant "Z">
       2  ?<Constant "\n">
      20  ?<Constant "\nMeasured points:\n">
      16  ?<Constant "baizhongyun.cn">
      32  ?<Constant "bed leveling hasn\'t d...">
      24  ?<Constant "busy: paused for input\n">
      24  ?<Constant "busy: paused for user\n">
      20  ?<Constant "busy: processing\n">
      20  ?<Constant "clear">
       4  ?<Constant "end">
      16  ?<Constant "enqueueing \"">
      12  ?<Constant "makerbase">
      12  ?<Constant "mks_pft.sys">
       4  ?<Constant "ok">
       8  ?<Constant "sd:%d">
       8  ?<Constant "start\n">
      32  ?<Constant {'\000'}>
      32  ?<Constant {'\000'}>_1
      32  ?<Constant {'\000'}>_2
      32  ?<Constant {'\000'}>_3
      32  ?<Constant {'\000'}>_4
      12  ?<Constant {(-9.9999990233E+3F), (-9.999999023
      12  ?<Constant {(0.0F), (0.0F), (0.0F)}>
       8  ?<Constant {(0.0F), (0.0F)}>
       4  ??DataTable134
       4  ??DataTable134_1
       4  ??DataTable134_2
       4  ??DataTable134_3
       4  ??DataTable134_4
       4  ??DataTable134_5
       4  ??DataTable134_6
       4  ??DataTable134_7
       4  ??DataTable134_8
       4  ??DataTable134_9
       4  ??DataTable135
       4  ??DataTable137
       4  ??DataTable137_1
       4  ??DataTable137_2
       4  ??DataTable137_3
       4  ??DataTable137_4
       4  ??DataTable137_5
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable143
       4  ??DataTable144
       4  ??DataTable145
       4  ??DataTable145_1
       4  ??DataTable145_2
       4  ??DataTable145_3
       4  ??DataTable145_4
       4  ??DataTable146
       4  ??DataTable148
       4  ??DataTable149
       4  ??DataTable149_1
       4  ??DataTable149_2
       4  ??DataTable150
       4  ??DataTable151
       4  ??DataTable151_1
       4  ??DataTable152
       4  ??DataTable152_1
       4  ??DataTable154
       4  ??DataTable154_1
       4  ??DataTable154_2
       4  ??DataTable154_3
       4  ??DataTable154_4
       4  ??DataTable154_5
       4  ??DataTable154_6
       4  ??DataTable154_7
       4  ??DataTable155
       4  ??DataTable155_1
       4  ??DataTable155_2
       4  ??DataTable155_3
       4  ??DataTable155_4
       4  ??DataTable155_5
       4  ??DataTable155_6
       4  ??DataTable155_7
       4  ??DataTable155_8
       4  ??DataTable156
       4  ??DataTable156_1
       4  ??DataTable158
       4  ??DataTable159
       4  ??DataTable160
       4  ??DataTable160_1
       4  ??DataTable160_2
       4  ??DataTable160_3
       4  ??DataTable160_4
       4  ??DataTable160_5
       4  ??DataTable160_6
       4  ??DataTable161
       4  ??DataTable161_1
       4  ??DataTable161_2
       4  ??DataTable161_3
       4  ??DataTable161_4
       4  ??DataTable163
       4  ??DataTable163_1
       4  ??DataTable163_2
       4  ??DataTable163_3
       4  ??DataTable163_4
       4  ??DataTable166
       4  ??DataTable166_1
       4  ??DataTable166_2
       4  ??DataTable166_3
       4  ??DataTable166_4
       4  ??DataTable166_5
       4  ??DataTable168
       4  ??DataTable168_1
       4  ??DataTable168_2
       4  ??DataTable168_3
       4  ??DataTable168_4
       4  ??DataTable168_5
       4  ??DataTable169
       4  ??DataTable175
       4  ??DataTable175_1
       4  ??DataTable176
       4  ??DataTable178
       4  ??DataTable182
       4  ??DataTable183
       4  ??DataTable183_1
       4  ??DataTable183_2
       4  ??DataTable184
       4  ??DataTable184_1
       4  ??DataTable184_10
       4  ??DataTable184_11
       4  ??DataTable184_12
       4  ??DataTable184_13
       4  ??DataTable184_14
       4  ??DataTable184_2
       4  ??DataTable184_3
       4  ??DataTable184_4
       4  ??DataTable184_5
       4  ??DataTable184_6
       4  ??DataTable184_7
       4  ??DataTable184_8
       4  ??DataTable184_9
       4  ??DataTable185
       4  ??DataTable185_1
       4  ??DataTable186
       4  ??DataTable186_1
       4  ??DataTable186_10
       4  ??DataTable186_11
       4  ??DataTable186_12
       4  ??DataTable186_13
       4  ??DataTable186_2
       4  ??DataTable186_3
       4  ??DataTable186_4
       4  ??DataTable186_5
       4  ??DataTable186_6
       4  ??DataTable186_7
       4  ??DataTable186_8
       4  ??DataTable186_9
       4  ??DataTable187
       4  ??DataTable187_1
       4  ??DataTable187_2
       4  ??DataTable187_3
       4  ??DataTable187_4
       4  ??DataTable187_5
       4  ??DataTable188
       4  ??DataTable191
       4  ??DataTable191_1
       4  ??DataTable191_2
       4  ??DataTable191_3
       4  ??DataTable192
       4  ??DataTable192_1
       4  ??DataTable192_10
       4  ??DataTable192_2
       4  ??DataTable192_3
       4  ??DataTable192_4
       4  ??DataTable192_5
       4  ??DataTable192_6
       4  ??DataTable192_7
       4  ??DataTable192_8
       4  ??DataTable192_9
       4  ??DataTable193
       4  ??DataTable193_1
       4  ??DataTable193_2
       4  ??DataTable193_3
       4  ??DataTable193_4
       4  ??DataTable194
       4  ??DataTable194_1
       4  ??DataTable194_2
       4  ??DataTable194_3
       4  ??DataTable194_4
       4  ??DataTable194_5
       4  ??DataTable194_6
       4  ??DataTable194_7
       4  ??DataTable194_8
       4  ??DataTable195
       4  ??DataTable195_1
       4  ??DataTable195_2
       4  ??DataTable195_3
       4  ??DataTable195_4
       4  ??DataTable195_5
       4  ??DataTable196
       4  ??DataTable202
       4  ??DataTable202_1
       4  ??DataTable202_2
       4  ??DataTable204
       4  ??DataTable204_1
       4  ??DataTable204_2
       4  ??DataTable206
       4  ??DataTable207
       4  ??DataTable207_1
       4  ??DataTable208
       4  ??DataTable208_1
       4  ??DataTable208_2
       4  ??DataTable208_3
       4  ??DataTable209
       4  ??DataTable210
       4  ??DataTable211
       4  ??DataTable211_1
       4  ??DataTable211_2
       4  ??DataTable211_3
       4  ??DataTable211_4
       4  ??DataTable212
       4  ??DataTable212_1
       4  ??DataTable213
       4  ??DataTable213_1
       4  ??DataTable214
       4  ??DataTable215
       4  ??DataTable215_1
       4  ??DataTable215_2
       4  ??DataTable217
       4  ??DataTable217_1
       4  ??DataTable219
       4  ??DataTable219_1
       4  ??DataTable219_2
       4  ??DataTable220
       4  ??DataTable220_1
       4  ??DataTable221
       4  ??DataTable223
       4  ??DataTable224
       4  ??DataTable225
       4  ??DataTable225_1
       4  ??DataTable226
       4  ??DataTable226_1
       4  ??DataTable226_10
       4  ??DataTable226_11
       4  ??DataTable226_12
       4  ??DataTable226_13
       4  ??DataTable226_14
       4  ??DataTable226_15
       4  ??DataTable226_16
       4  ??DataTable226_17
       4  ??DataTable226_18
       4  ??DataTable226_19
       4  ??DataTable226_2
       4  ??DataTable226_20
       4  ??DataTable226_21
       4  ??DataTable226_22
       4  ??DataTable226_23
       4  ??DataTable226_24
       4  ??DataTable226_25
       4  ??DataTable226_26
       4  ??DataTable226_27
       4  ??DataTable226_3
       4  ??DataTable226_4
       4  ??DataTable226_5
       4  ??DataTable226_6
       4  ??DataTable226_7
       4  ??DataTable226_8
       4  ??DataTable226_9
      88  ADJUST_DELTA(float const *)
      20  Beeper(uint32_t)
      24  C2
          S2
          SK1
          SK2
          THETA
          PSI
      18  CardReader::eof()
      46  CardReader::get()
      16  CardReader::isFileOpen()
       8  CardReader::setIndex(long)
      90  EXTI9_5_IRQHandler
      12  Endstops::enable(bool)
      20  Endstops::enable_globally(bool)
      12  Endstops::enable_z_probe(bool)
      12  Endstops::hit_on_purpose()
      20  Endstops::not_homing()
      48  FlushSerialRequestResend()
      30  GCodeParser::boolval(char)
      22  GCodeParser::byteval(char, uint8_t)
      22  GCodeParser::celsiusval(char, float)
      20  GCodeParser::has_value()
      22  GCodeParser::intval(char, int16_t)
      22  GCodeParser::linearval(char, float)
      76  GCodeParser::seen(char)
      22  GCodeParser::seenval(char)
      22  GCodeParser::ushortval(char, uint16_t)
       4  GCodeParser::value_axis_units(AxisEnum)
      28  GCodeParser::value_bool()
      34  GCodeParser::value_byte()
       4  GCodeParser::value_celsius()
       4  GCodeParser::value_feedrate()
      80  GCodeParser::value_float()
      10  GCodeParser::value_int()
       4  GCodeParser::value_linear_units()
      24  GCodeParser::value_long()
       4  GCodeParser::value_millis()
      24  GCodeParser::value_millis_from_seconds()
       4  GCodeParser::value_per_axis_unit(AxisEnum)
      24  GCodeParser::value_ulong()
      10  GCodeParser::value_ushort()
      12  IsRunning()
      16  IsStopped()
       4  L1
       4  L2
      10  Planner::apply_leveling(float (&)[3])
      28  Planner::blocks_queued()
      64  Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
     192  Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
      16  Planner::force_fade_recalc()
      40  Planner::leveling_active_at_z(float const &)
      76  Planner::refresh_e_factor(uint8_t)
       8  Planner::set_e_position_mm(float const &)
      48  Planner::set_filament_size(uint8_t, float const &)
      56  Planner::set_position_mm(float, float, float, float const &)
      88  Planner::set_z_fade_height(float const &)
      72  SCARA_move_to_cal(uint8_t, uint8_t)
      22  SYNC_PLAN_POSITION_KINEMATIC()
       4  Stepper::get_axis_position_degrees(AxisEnum)
      12  Stepper::set_homing_flag_z(bool)
      12  Stepper::set_z2_lock(bool)
      12  Stepper::set_z_lock(bool)
     746  SysTick_Handler_User()
      12  Temperature::degBed()
      12  Temperature::degHotend(uint8_t)
      16  Temperature::degTargetBed()
      16  Temperature::degTargetHotend(uint8_t)
      40  Temperature::isCoolingBed()
      44  Temperature::isCoolingHotend(uint8_t)
      52  Temperature::setTargetBed(float)
      28  Temperature::setTargetHotend(float, uint8_t)
      40  Temperature::set_auto_report_interval(uint8_t)
      60  Temperature::tooColdToExtrude(uint8_t)
       2  Temperature::updatePID()
     262  __sti__routine()
      40  _commit_command(bool)
      68  _enqueuecommand(char const *, bool)
     100  _manual_goto_xy(float const &, float const &)
       4  axis_codes
     120  axis_homed
          axis_known_position
          soft_endstops_enabled
          lcd_wait_for_move
          delta_tower
          soft_endstop_max
          delta_tower_angle_trim
          delta_diagonal_rod_2_tower
          cartes
          soft_endstop_radius
          soft_endstop_radius_2
          previous_cmd_ms
          max_inactive_time
          stepper_inactive_time
          delta_radius
          delta_diagonal_rod
          delta_calibration_radius
          delta_segments_per_second
     104  axis_relative_modes
          Running
          relative_mode
          busy_state
          host_keepalive_interval
          serial_wait_tick
          from_wifi_flag
          gridx
          gridy
          nextx
          nexty
          last_gridx
          last_gridy
          bilinear_grid_spacing
          bilinear_start
          bilinear_grid_factor
          gcode_N
          gcode_LastN
          Stopped_gcode_LastN
          serial_count
          wifi_read_count
          next_busy_signal_ms
          z1
          d2
          z3
          d4
          L
          D
          ratio_x
          ratio_y
          last_x
          last_y
     120  axis_unhomed_error(bool, bool, bool)
      12  base_home_pos(AxisEnum)
      12  base_max_pos(AxisEnum)
      12  base_min_pos(AxisEnum)
     590  bilinear_line_to_destination(float, uint16_t, uint16_t)
     478  bilinear_z_offset(float const *)
      60  bltouch_command(int)
      36  buffer_line_to_current_position()
      36  buffer_line_to_destination(float)
       1  button_disp_pause_state
      50  cap_line(char const *, bool)
    3452  card
          mksReprint
          print_job_timer
     294  clamp_to_software_endstops(float *)
      18  clean_up_after_endstop_or_probe_move()
      18  clear_command_queue()
     384  command_queue
       1  continue_print_error_flg
      20  debug_strings
      88  delta_safe_distance_from_top()
     112  disable_all_steppers()
      56  disable_e_steppers()
      78  display_sd_error()
      88  display_temper_error()
     366  do_blocking_move_to(float const &, float const &, float const &, float const &)
      20  do_blocking_move_to_x(float const &, float const &)
       8  do_blocking_move_to_xy(float const &, float const &, float const &)
      22  do_blocking_move_to_z(float const &, float const &)
     272  do_homing_move(AxisEnum, float, float)
     122  do_probe_move(float, float)
      56  do_probe_raise(float)
      88  drain_injected_commands_P()
      16  duration_t::day() const
       6  duration_t::duration_t(uint32_t const &)
      14  duration_t::hour() const
      14  duration_t::minute() const
       4  duration_t::second() const
     232  duration_t::toString(char *) const
      18  duration_t::year() const
      32  dwell(millis_t)
       8  echo_not_entered()
      94  enable_all_steppers()
       1  enable_soft_endstops
      58  enqueue_and_echo_command(char const *, bool)
       8  enqueue_and_echo_commands_P(char const *)
     264  extrapolate_one_point(uint8_t, uint8_t, int8_t, int8_t)
     178  extrapolate_unprobed_bed_level()
       1  filament_heat_completed_load
       1  filament_heat_completed_unload
      72  filament_loading_time_flg
          filament_loading_completed
          filament_unloading_time_flg
          filament_unloading_completed
          printing_rate_update_flag
          preview_no_display
          loop_start
          cmd_queue_index_r
          cmd_queue_index_w
          sd_read_error_flg
          sd_read_cnt
          display_hold
          display_hold_release
          wifi_init_flg
          wifi_refresh_flg
          cloud_refresh_flg
          waiting_wifi_time
          beep_flg
          has_adjust_speed
          print_finish_start_timer
          print_finish_close_machine
          send_ok
          z_high_count
          resume_printed_time
          temperature_change_frequency_cnt
          filament_loading_time_cnt
          filament_unloading_time_cnt
          TimeIncrease
          home_offset
          display_hold_cnt
          beep_cnt
          print_finish_timer_count
       1  first_resu
       8  forward_kinematics_DELTA(float *)
    1164  forward_kinematics_DELTA(float, float, float)
     238  forward_kinematics_SCARA(float const &, float const &)
       6  freeMemory()
       1  g26_debug_flag
      24  gcode_G0_G1()
      40  gcode_G0_G1_SCARA(bool)
     408  gcode_G28(bool)
    3488  gcode_G29()
     672  gcode_G29_MESH_BED_LEVELING()
       4  gcode_G29_UBL()
     600  gcode_G2_G3(bool)
     260  gcode_G30()
      72  gcode_G4()
     396  gcode_G42()
     160  gcode_G92()
     228  gcode_M104()
      44  gcode_M105()
      60  gcode_M106()
      36  gcode_M107()
      12  gcode_M108()
     584  gcode_M109()
      28  gcode_M110()
     136  gcode_M111()
      12  gcode_M112()
      76  gcode_M113()
      14  gcode_M114()
     184  gcode_M115()
      16  gcode_M117()
      76  gcode_M118()
       4  gcode_M119()
       6  gcode_M120()
       6  gcode_M121()
      40  gcode_M140()
      36  gcode_M155()
      24  gcode_M17()
     268  gcode_M18_M84()
     412  gcode_M190()
      36  gcode_M20()
      84  gcode_M200()
      92  gcode_M201()
      80  gcode_M203()
     180  gcode_M204()
     148  gcode_M205()
     120  gcode_M206()
     228  gcode_M211()
     204  gcode_M218()
      12  gcode_M22()
      28  gcode_M220()
      56  gcode_M221()
     148  gcode_M226()
      68  gcode_M23()
      44  gcode_M24()
      32  gcode_M25()
      44  gcode_M26()
      12  gcode_M27()
      24  gcode_M28()
     160  gcode_M280()
       2  gcode_M29()
      44  gcode_M30()
     260  gcode_M301()
     160  gcode_M302()
     148  gcode_M303()
     208  gcode_M304()
      76  gcode_M31()
     104  gcode_M32()
      28  gcode_M355()
      24  gcode_M360()
      24  gcode_M361()
      24  gcode_M362()
      24  gcode_M363()
      24  gcode_M364()
       4  gcode_M400()
       6  gcode_M401()
       6  gcode_M402()
       4  gcode_M410()
     124  gcode_M42()
     548  gcode_M420()
     204  gcode_M421_AUTO_BED_LEVELING_BILINEAR()
     264  gcode_M421_AUTO_BED_LEVELING_UBL()
     264  gcode_M421_MESH_BED_LEVELING()
     216  gcode_M428()
      64  gcode_M49()
       4  gcode_M500()
       4  gcode_M501()
       4  gcode_M502()
      36  gcode_M503()
     152  gcode_M665()
      80  gcode_M666()
      76  gcode_M666_dual()
      12  gcode_M75()
      12  gcode_M76()
      12  gcode_M77()
      44  gcode_M81()
      12  gcode_M82()
      12  gcode_M83()
      28  gcode_M85()
     112  gcode_M851()
       2  gcode_M907()
     200  gcode_M92()
      20  gcode_M928()
     112  gcode_M998()
      36  gcode_M999()
      60  gcode_T(uint8_t)
     102  gcode_get_destination()
      60  gcode_line_error(char const *, bool)
      28  get_available_commands()
     108  get_cartesian_from_steppers()
     100  get_homing_bump_feedrate(AxisEnum)
     512  get_sdcard_commands()
     552  get_serial_commands()
      98  get_target_extruder_from_command(uint16_t)
     284  get_wifi_commands()
       6  home_all_axes()
      10  home_bump_mm(AxisEnum)
      12  home_bump_mm_P
     156  home_delta()
       8  home_dir(AxisEnum)
      60  home_dir_P
          base_min_pos_P
          base_max_pos_P
          base_home_pos_P
          max_length_P
          L1_2
          L2_2
     644  homeaxis(AxisEnum)
     116  host_keepalive()
      24  hotend_offset
     132  idle()
     320  incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
       8  incremental_LSF_reset(linear_fit_data *)
       4  injected_commands_P
      72  invalid_extruder_error(uint8_t)
     408  inverse_kinematics(float const *)
     378  inverse_kinematics_MORGAN_SCARA(float const *)
      50  kill(char const *)
      50  kill_c
       4  last_wait_time
       4  lcd_hasstatus()
       2  lcd_init()
      64  lcd_reInit()
       2  lcd_refresh()
       2  lcd_reset_alert_level()
       2  lcd_setalertstatusPGM(char const *)
       2  lcd_setstatus(char const *, bool)
       2  lcd_setstatusPGM(char const *, int8_t)
       2  lcd_update()
      50  leveling_is_valid()
     194  loop
     222  manage_inactivity(bool)
      12  max_length(AxisEnum)
     120  mbl_mesh_report()
       4  mbl_probe_index
     360  mesh_bed_leveling::cell_index_x(float const &)
     356  mesh_bed_leveling::cell_index_y(float const &)
     448  mesh_bed_leveling::probe_index_x(float const &)
     444  mesh_bed_leveling::probe_index_y(float const &)
      24  mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
      32  mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
      56  mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
     418  mesh_line_to_destination(float, uint8_t, uint8_t)
     106  mks_G28(char *)
     688  mks_PrintStatePolling
     340  mks_ReadFromEpr
     202  mks_ReadFromEpr_pwroff()
      92  mks_ReadFromFile
      96  mks_ResetPositionZ(float)
     308  mks_WriteToEpr()
     236  mks_WriteToEpr_pwroff()
     620  mks_WriteToFile
      98  mks_adjust_extrude_speed
      42  mks_clearDir
      88  mks_clearFile
     102  mks_contiuePrintDelta
     134  mks_contiuePrintPause
     178  mks_contiuePrintPwdwn
     312  mks_contiuePrint_UI
     630  mks_getPositionXYZE
     282  mks_get_commands()
     136  mks_heating_busy
          marlin_debug_flags
          commands_in_queue
          active_extruder
          wait_for_heatup
          target_extruder
          feedrate_percentage
          current_position
          destination
          homing_feedrate_mm_s
          workspace_offset
          soft_endstop_min
          delta
          feedrate_mm_s
          position_shift
          fanSpeeds
          zprobe_zoffset
          xy_probe_feedrate_mm_s
          delta_height
          delta_clip_start_height
          L1_2_2
          ubl
      94  mks_initPrint
     154  mks_leveling_moveXY(float, float)
     122  mks_leveling_moveZ(float)
      80  mks_manual_leveling
     138  mks_moveXY
      98  mks_moveZ
     102  mks_moveZ_relative(float)
     124  mks_pausePrint
       4  mks_pft_name
     180  mks_preExtrude
     222  mks_rePrintCheck
      72  mks_resumePrint
      62  mks_resume_extrude_speed
      68  mks_saveFileName
      14  mks_setFeedrate()
      96  mks_setPositionZ
     368  mks_setTemperature()
     576  mkstft_ui_init
     792  mkstft_ui_load
     830  mkstft_ui_set_epr()
       4  next_idle_ms
      42  ok_to_send()
      30  out_of_range_error(char const *)
      50  pft_get()
      30  pin_is_protected(int8_t)
    1006  plan_arc(float const (&)[4], float const (&)[2], bool)
     184  position_is_reachable_IS_CARTESIAN(float const &, float const &)
     376  position_is_reachable_IS_KINEMATIC(float const &, float const &)
     184  position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
      56  position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
    1144  prepare_kinematic_move_to(float const (&)[4])
     232  prepare_move_to_destination()
     264  prepare_move_to_destination_cartesian()
     118  prepare_uninterpolated_move_to_destination(float)
     308  print_2d_array(uint8_t, uint8_t, uint8_t, uint8_t)
      32  print_bilinear_leveling_grid()
     422  probe_pt(float const &, float const &, bool, uint8_t, bool)
      70  process_next_command()
    1836  process_parsed_command()
     274  quick_home_xy()
      24  quickstop_stepper()
     568  recalc_delta_settings()
      80  refresh_bed_level()
      16  refresh_cmd_timeout()
     186  report_current_position()
     144  reset_bed_level()
     108  run_z_probe()
       8  saved_feedrate_percentage
          saved_feedrate_mm_s
       1  sd_comment_mode
      52  sensitive_pins
       1  serial_comment_mode
       4  serial_echopair_P(char const *, bool)
      96  serial_line_buffer
      28  serialprintPGM(char const *)
       2  servo_init()
     242  set_axis_is_at_home(AxisEnum)
     242  set_bed_leveling_enabled(bool)
     198  set_bltouch_deployed(bool)
      20  set_current_from_destination()
      68  set_current_from_steppers_for_axis(AxisEnum)
      20  set_destination_from_current()
      26  set_home_offset(AxisEnum, float)
      80  set_probe_deployed(bool)
     140  set_z_fade_height(float, bool)
     254  setup
      22  setup_for_endstop_or_probe_move()
       2  setup_killpin()
       2  setup_powerhold()
     164  soft_endstop_min_init()
      58  stop()
       1  stop_buffering
       8  str_debug_1
      16  str_debug_16
       8  str_debug_2
       8  str_debug_4
       8  str_debug_8
       4  strchr(char *, int)
       4  strrchr(char *, int)
       4  strstr(char *, char const *)
       2  suicide()
      18  sync_plan_position()
      12  sync_plan_position_e()
      12  sync_plan_position_kinematic()
       4  t1
      12  t12
       4  t2
       2  temper_error_flg
          temper_error_type
      40  temper_error_kill()
     520  tool_change(uint8_t, float, bool)
     316  unified_bed_leveling::mesh_index_to_xpos(uint8_t)
     312  unified_bed_leveling::mesh_index_to_ypos(uint8_t)
     124  unified_bed_leveling::mesh_is_valid()
     286  update_software_endstops(AxisEnum)
       1  wifi_comment_mode
       1  wifi_init_state
      96  wifi_line_buffer
       4  wifi_loop_cycle
      16  z_endstop_adj
          delta_endstop_adj
     576  z_values
    3464  -- Other

 
  4 854 bytes in section .bss
    385 bytes in section .data
      4 bytes in section .init_array
  3 815 bytes in section .rodata
 51 908 bytes in section .text
 
 28 640 bytes of CODE  memory (+ 23 272 bytes shared)
    288 bytes of CONST memory (+  3 527 bytes shared)
  5 029 bytes of DATA  memory (+    210 bytes shared)

Errors: none
Warnings: 164
