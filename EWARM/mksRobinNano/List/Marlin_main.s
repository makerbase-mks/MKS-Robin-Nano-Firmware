///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       14/Feb/2020  17:05:38
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    Command line =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
//        -lA
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
//        --diag_suppress Pa050 -o
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
//        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
//        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\INC\c\DLib_Config_Full.h" -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
//        -I
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
//        -Om --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\CMSIS\Include\"
//    List file    =  
//        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\Marlin_main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Language", "EC++"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__iar_require _Printf", "floats,int_specials,widths"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN AT24CXX_Read
        EXTERN BMP_PIC_X
        EXTERN BMP_PIC_Y
        EXTERN GUI_DispStringAt
        EXTERN GUI_Exec
        EXTERN GUI_Init
        EXTERN GUI_RefreshPage
        EXTERN GUI_SetBkColor
        EXTERN GUI_SetColor
        EXTERN GUI_TOUCH_Exec
        EXTERN GUI_UC_SetEncodeUTF8
        EXTERN HAL_Delay
        EXTERN HAL_GPIO_ReadPin
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_GetTick
        EXTERN IsChooseAutoShutdown
        EXTERN SD_Init
        EXTERN SD_Path
        EXTERN Serial3
        EXTERN _Z10safe_delaym
        EXTERN _Z12wifi_loopingv
        EXTERN _Z14mksBeeperAlarmv
        EXTERN _Z17serial_echopair_PPKcS0_
        EXTERN _Z17serial_echopair_PPKcd
        EXTERN _Z17serial_echopair_PPKcf
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _Z17serial_echopair_PPKcm
        EXTERN _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        EXTERN _Z21Close_machine_displayv
        EXTERN _Z22finish_incremental_LSFP15linear_fit_data
        EXTERN _Z23PowerOff_Filament_Checkv
        EXTERN _Z9gcode_G26v
        EXTERN _ZN10CardReader10removeFileEPc
        EXTERN _ZN10CardReader10reopenfileEPc
        EXTERN _ZN10CardReader11openLogFileEPc
        EXTERN _ZN10CardReader11stopSDPrintEv
        EXTERN _ZN10CardReader12checkFilesysEh
        EXTERN _ZN10CardReader12pauseSDPrintEv
        EXTERN _ZN10CardReader13write_commandEPc
        EXTERN _ZN10CardReader14checkautostartEb
        EXTERN _ZN10CardReader14startFileprintEv
        EXTERN _ZN10CardReader19printingHasFinishedEv
        EXTERN _ZN10CardReader2lsEv
        EXTERN _ZN10CardReader6initsdEv
        EXTERN _ZN10CardReader7releaseEv
        EXTERN _ZN10CardReader8getsdposEv
        EXTERN _ZN10CardReader8openFileEPcbb
        EXTERN _ZN10CardReader9closefileEb
        EXTERN _ZN10CardReader9getStatusEv
        EXTERN _ZN10CardReaderC1Ev
        EXTERN _ZN10USARTClass11MoremenuCmdEv
        EXTERN _ZN10USARTClass4readEv
        EXTERN _ZN10USARTClass5flushEv
        EXTERN _ZN10USARTClass5writeEh
        EXTERN _ZN10USARTClass9availableEv
        EXTERN _ZN10matrix_3x314create_look_atE8vector_3
        EXTERN _ZN10matrix_3x315set_to_identityEv
        EXTERN _ZN10matrix_3x35debugEPKc
        EXTERN _ZN10matrix_3x39transposeES_
        EXTERN _ZN11GCodeParser10string_argE
        EXTERN _ZN11GCodeParser11command_ptrE
        EXTERN _ZN11GCodeParser14command_letterE
        EXTERN _ZN11GCodeParser18volumetric_enabledE
        EXTERN _ZN11GCodeParser21unknown_command_errorEv
        EXTERN _ZN11GCodeParser5paramE
        EXTERN _ZN11GCodeParser5parseEPc
        EXTERN _ZN11GCodeParser7codenumE
        EXTERN _ZN11GCodeParser8codebitsE
        EXTERN _ZN11GCodeParser9value_ptrE
        EXTERN _ZN11Temperature12PID_autotuneEfaab
        EXTERN _ZN11Temperature13manage_heaterEv
        EXTERN _ZN11Temperature16extrude_min_tempE
        EXTERN _ZN11Temperature18allow_cold_extrudeE
        EXTERN _ZN11Temperature18print_heaterstatesEv
        EXTERN _ZN11Temperature18start_watching_bedEv
        EXTERN _ZN11Temperature18target_temperatureE
        EXTERN _ZN11Temperature19current_temperatureE
        EXTERN _ZN11Temperature19disable_all_heatersEv
        EXTERN _ZN11Temperature19next_temp_report_msE
        EXTERN _ZN11Temperature21start_watching_heaterEh
        EXTERN _ZN11Temperature22target_temperature_bedE
        EXTERN _ZN11Temperature23current_temperature_bedE
        EXTERN _ZN11Temperature24auto_report_temperaturesEv
        EXTERN _ZN11Temperature25auto_report_temp_intervalE
        EXTERN _ZN11Temperature2KdE
        EXTERN _ZN11Temperature2KiE
        EXTERN _ZN11Temperature2KpE
        EXTERN _ZN11Temperature4initEv
        EXTERN _ZN11Temperature5bedKdE
        EXTERN _ZN11Temperature5bedKiE
        EXTERN _ZN11Temperature5bedKpE
        EXTERN _ZN14MarlinSettings15calc_num_meshesEv
        EXTERN _ZN14MarlinSettings4loadEv
        EXTERN _ZN14MarlinSettings4saveEv
        EXTERN _ZN14MarlinSettings5resetEv
        EXTERN _ZN14MarlinSettings6reportEb
        EXTERN _ZN14MarlinSettings9load_meshEaPv
        EXTERN _ZN17mesh_bed_leveling13index_to_xposE
        EXTERN _ZN17mesh_bed_leveling13index_to_yposE
        EXTERN _ZN17mesh_bed_leveling5resetEv
        EXTERN _ZN17mesh_bed_leveling8has_meshE
        EXTERN _ZN17mesh_bed_leveling8z_offsetE
        EXTERN _ZN17mesh_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_leveling11display_mapEi
        EXTERN _ZN20unified_bed_leveling12storage_slotE
        EXTERN _ZN20unified_bed_leveling13gcode_G29_UBLEv
        EXTERN _ZN20unified_bed_leveling19_mesh_index_to_xposE
        EXTERN _ZN20unified_bed_leveling19_mesh_index_to_yposE
        EXTERN _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        EXTERN _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        EXTERN _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        EXTERN _ZN20unified_bed_leveling5resetEv
        EXTERN _ZN20unified_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_levelingC1Ev
        EXTERN _ZN5Print5printEPKc
        EXTERN _ZN5Print5printEdi
        EXTERN _ZN5Print5printEhi
        EXTERN _ZN5Print5printEii
        EXTERN _ZN5Print5printEli
        EXTERN _ZN7Planner11last_fade_zE
        EXTERN _ZN7Planner12accelerationE
        EXTERN _ZN7Planner13filament_sizeE
        EXTERN _ZN7Planner13z_fade_heightE
        EXTERN _ZN7Planner14apply_levelingERfS0_S0_
        EXTERN _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        EXTERN _ZN7Planner15flow_percentageE
        EXTERN _ZN7Planner15leveling_activeE
        EXTERN _ZN7Planner15set_position_mmE8AxisEnumRKf
        EXTERN _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        EXTERN _ZN7Planner16bed_level_matrixE
        EXTERN _ZN7Planner16unapply_levelingEPf
        EXTERN _ZN7Planner17axis_steps_per_mmE
        EXTERN _ZN7Planner17block_buffer_headE
        EXTERN _ZN7Planner17block_buffer_tailE
        EXTERN _ZN7Planner17max_feedrate_mm_sE
        EXTERN _ZN7Planner17min_feedrate_mm_sE
        EXTERN _ZN7Planner18autotemp_M104_M109Ev
        EXTERN _ZN7Planner19check_axes_activityEv
        EXTERN _ZN7Planner19min_segment_time_usE
        EXTERN _ZN7Planner19refresh_positioningEv
        EXTERN _ZN7Planner19travel_accelerationE
        EXTERN _ZN7Planner20retract_accelerationE
        EXTERN _ZN7Planner21inverse_z_fade_heightE
        EXTERN _ZN7Planner21volumetric_multiplierE
        EXTERN _ZN7Planner24min_travel_feedrate_mm_sE
        EXTERN _ZN7Planner24reset_acceleration_ratesEv
        EXTERN _ZN7Planner25set_position_mm_kinematicERA4_Kf
        EXTERN _ZN7Planner26max_acceleration_mm_per_s2E
        EXTERN _ZN7Planner29max_acceleration_steps_per_s2E
        EXTERN _ZN7Planner32calculate_volumetric_multipliersEv
        EXTERN _ZN7Planner8e_factorE
        EXTERN _ZN7Planner8max_jerkE
        EXTERN _ZN7Planner8positionE
        EXTERN _ZN7Stepper10quick_stopEv
        EXTERN _ZN7Stepper11synchronizeEv
        EXTERN _ZN7Stepper14locked_z_motorE
        EXTERN _ZN7Stepper15locked_z2_motorE
        EXTERN _ZN7Stepper16report_positionsEv
        EXTERN _ZN7Stepper17performing_homingE
        EXTERN _ZN7Stepper18finish_and_disableEv
        EXTERN _ZN7Stepper20get_axis_position_mmE8AxisEnum
        EXTERN _ZN7Stepper4initEv
        EXTERN _ZN8Endstops12report_stateEv
        EXTERN _ZN8Endstops15z_probe_enabledE
        EXTERN _ZN8Endstops16enabled_globallyE
        EXTERN _ZN8Endstops16endstop_hit_bitsE
        EXTERN _ZN8Endstops4M119Ev
        EXTERN _ZN8Endstops7enabledE
        EXTERN _ZN8vector_310get_normalEv
        EXTERN _ZN8vector_314apply_rotationE10matrix_3x3
        EXTERN _ZN8vector_35crossES_S_
        EXTERN _ZN8vector_3C1Efff
        EXTERN _ZN8vector_3miES_
        EXTERN _ZN9Stopwatch4stopEv
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN _ZN9Stopwatch5startEv
        EXTERN _ZN9Stopwatch7getTimeEPmS0_S0_
        EXTERN _ZN9Stopwatch8durationEv
        EXTERN _ZN9StopwatchC1Ev
        EXTERN __aeabi_cdrcmple
        EXTERN __aeabi_cfcmpeq
        EXTERN __aeabi_cfcmple
        EXTERN __aeabi_cfrcmple
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2iz
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_dsub
        EXTERN __aeabi_f2d
        EXTERN __aeabi_f2iz
        EXTERN __aeabi_f2uiz
        EXTERN __aeabi_fadd
        EXTERN __aeabi_fdiv
        EXTERN __aeabi_fmul
        EXTERN __aeabi_fsub
        EXTERN __aeabi_i2d
        EXTERN __aeabi_i2f
        EXTERN __aeabi_memclr4
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_ui2d
        EXTERN __aeabi_ui2f
        EXTERN __iar_FDtest
        EXTERN __iar_Strchr
        EXTERN __iar_Strrchr
        EXTERN __iar_Strstr
        EXTERN abs
        EXTERN atan2f
        EXTERN atof
        EXTERN atoi
        EXTERN clear_cur_ui
        EXTERN cos
        EXTERN cosf
        EXTERN curFileName
        EXTERN default_preview_flg
        EXTERN disp_pre_gcode
        EXTERN disp_state_stack
        EXTERN draw_dialog
        EXTERN draw_printing
        EXTERN draw_ready_print
        EXTERN draw_return_ui
        EXTERN echomagic
        EXTERN epr_read_data
        EXTERN epr_write_data
        EXTERN errormagic
        EXTERN espGcodeFifo
        EXTERN f_close
        EXTERN f_lseek
        EXTERN f_open
        EXTERN f_printf
        EXTERN f_read
        EXTERN filament_det1_cnt
        EXTERN filament_det1_flg
        EXTERN filament_det1_high_cnt
        EXTERN filament_det1_high_flg
        EXTERN filament_det1_low_cnt
        EXTERN filament_det1_low_flg
        EXTERN filament_det2_cnt
        EXTERN filament_det2_flg
        EXTERN filament_det2_high_cnt
        EXTERN filament_det2_high_flg
        EXTERN filament_det2_low_cnt
        EXTERN filament_det2_low_flg
        EXTERN filament_rate
        EXTERN flash_preview_begin
        EXTERN floor
        EXTERN floorf
        EXTERN free
        EXTERN from_flash_pic
        EXTERN gArrayGpioPin
        EXTERN gArrayGpioPort
        EXTERN gCfgItems
        EXTERN getTick
        EXTERN getTickDiff
        EXTERN gui_view_init
        EXTERN ipPara
        EXTERN key_value_calc
        EXTERN leveling_first_time
        EXTERN logo_tick1
        EXTERN logo_tick2
        EXTERN lroundf
        EXTERN malloc
        EXTERN memcmp
        EXTERN memcpy
        EXTERN memset
        EXTERN mksCfg
        EXTERN mksTmp
        EXTERN parser
        EXTERN pause_resum
        EXTERN poweroff_det_cnt
        EXTERN poweroff_det_flg
        EXTERN poweroff_det_high_cnt
        EXTERN poweroff_det_high_flg
        EXTERN poweroff_det_low_cnt
        EXTERN poweroff_det_low_flg
        EXTERN preview_gcode_prehandle
        EXTERN print_time
        EXTERN rand
        EXTERN reset_file_info
        EXTERN reset_print_time
        EXTERN sin
        EXTERN sinf
        EXTERN sprintf
        EXTERN sqrt
        EXTERN sqrtf
        EXTERN start_print_time
        EXTERN stop_print_time
        EXTERN strcat
        EXTERN strcmp
        EXTERN strcpy
        EXTERN strncpy
        EXTERN strtod
        EXTERN strtol
        EXTERN strtoul
        EXTERN temperature_change_frequency
        EXTERN thermalManager
        EXTERN tips_disp
        EXTERN wifiPara
        EXTERN wifi_check_time
        EXTERN wifi_link_state

        PUBLIC EXTI9_5_IRQHandler
        PUBLIC L1
        PUBLIC L2
        PUBLIC Running
        PUBLIC TimeIncrease
        PUBLIC _Z10freeMemoryv
        PUBLIC _Z10gcode_M104v
        PUBLIC _Z10gcode_M105v
        PUBLIC _Z10gcode_M106v
        PUBLIC _Z10gcode_M107v
        PUBLIC _Z10gcode_M108v
        PUBLIC _Z10gcode_M109v
        PUBLIC _Z10gcode_M110v
        PUBLIC _Z10gcode_M111v
        PUBLIC _Z10gcode_M112v
        PUBLIC _Z10gcode_M113v
        PUBLIC _Z10gcode_M114v
        PUBLIC _Z10gcode_M115v
        PUBLIC _Z10gcode_M117v
        PUBLIC _Z10gcode_M118v
        PUBLIC _Z10gcode_M119v
        PUBLIC _Z10gcode_M120v
        PUBLIC _Z10gcode_M121v
        PUBLIC _Z10gcode_M140v
        PUBLIC _Z10gcode_M155v
        PUBLIC _Z10gcode_M190v
        PUBLIC _Z10gcode_M200v
        PUBLIC _Z10gcode_M201v
        PUBLIC _Z10gcode_M203v
        PUBLIC _Z10gcode_M204v
        PUBLIC _Z10gcode_M205v
        PUBLIC _Z10gcode_M206v
        PUBLIC _Z10gcode_M211v
        PUBLIC _Z10gcode_M218v
        PUBLIC _Z10gcode_M220v
        PUBLIC _Z10gcode_M221v
        PUBLIC _Z10gcode_M226v
        PUBLIC _Z10gcode_M280v
        PUBLIC _Z10gcode_M301v
        PUBLIC _Z10gcode_M302v
        PUBLIC _Z10gcode_M303v
        PUBLIC _Z10gcode_M304v
        PUBLIC _Z10gcode_M355v
        PUBLIC _Z10gcode_M360v
        PUBLIC _Z10gcode_M361v
        PUBLIC _Z10gcode_M362v
        PUBLIC _Z10gcode_M363v
        PUBLIC _Z10gcode_M364v
        PUBLIC _Z10gcode_M400v
        PUBLIC _Z10gcode_M401v
        PUBLIC _Z10gcode_M402v
        PUBLIC _Z10gcode_M410v
        PUBLIC _Z10gcode_M420v
        PUBLIC _Z10gcode_M428v
        PUBLIC _Z10gcode_M500v
        PUBLIC _Z10gcode_M501v
        PUBLIC _Z10gcode_M502v
        PUBLIC _Z10gcode_M503v
        PUBLIC _Z10gcode_M665v
        PUBLIC _Z10gcode_M666v
        PUBLIC _Z10gcode_M851v
        PUBLIC _Z10gcode_M907v
        PUBLIC _Z10gcode_M928v
        PUBLIC _Z10gcode_M998v
        PUBLIC _Z10gcode_M999v
        PUBLIC _Z10home_deltav
        PUBLIC _Z10lcd_reInitv
        PUBLIC _Z10lcd_updatev
        PUBLIC _Z10ok_to_sendv
        PUBLIC _Z10servo_initv
        PUBLIC _Z11gcode_G0_G1v
        PUBLIC _Z11gcode_G2_G3b
        PUBLIC _Z11lcd_refreshv
        PUBLIC _Z11tool_changehfb
        PUBLIC _Z12ADJUST_DELTAPKf
        PUBLIC _Z13gcode_G29_UBLv
        PUBLIC _Z13gcode_M18_M84v
        PUBLIC _Z13home_all_axesv
        PUBLIC _Z13lcd_hasstatusv
        PUBLIC _Z13lcd_setstatusPKcb
        PUBLIC _Z13setup_killpinv
        PUBLIC _Z14do_probe_raisef
        PUBLIC _Z14host_keepalivev
        PUBLIC _Z14mks_WriteToEprv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z15_commit_commandb
        PUBLIC _Z15_enqueuecommandPKcb
        PUBLIC _Z15_manual_goto_xyRKfS0_
        PUBLIC _Z15bltouch_commandi
        PUBLIC _Z15gcode_M666_dualv
        PUBLIC _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        PUBLIC _Z15mbl_mesh_reportv
        PUBLIC _Z15mks_setFeedratev
        PUBLIC _Z15reset_bed_levelv
        PUBLIC _Z15setup_powerholdv
        PUBLIC _Z16display_sd_errorv
        PUBLIC _Z16echo_not_enteredv
        PUBLIC _Z16gcode_line_errorPKcb
        PUBLIC _Z16lcd_setstatusPGMPKca
        PUBLIC _Z16mks_get_commandsv
        PUBLIC _Z17SCARA_move_to_calhh
        PUBLIC _Z17bilinear_z_offsetPKf
        PUBLIC _Z17gcode_G0_G1_SCARAb
        PUBLIC _Z17get_wifi_commandsv
        PUBLIC _Z17leveling_is_validv
        PUBLIC _Z17manage_inactivityb
        PUBLIC _Z17mkstft_ui_set_eprv
        PUBLIC _Z17quickstop_stepperv
        PUBLIC _Z17refresh_bed_levelv
        PUBLIC _Z17serial_echopair_PPKcb
        PUBLIC _Z17set_z_fade_heightfb
        PUBLIC _Z17temper_error_killv
        PUBLIC _Z18axis_unhomed_errorbbb
        PUBLIC _Z18disable_e_steppersv
        PUBLIC _Z18inverse_kinematicsPKf
        PUBLIC _Z18mks_ResetPositionZf
        PUBLIC _Z18mks_leveling_moveZf
        PUBLIC _Z18mks_moveZ_relativef
        PUBLIC _Z18mks_setTemperaturev
        PUBLIC _Z18out_of_range_errorPKc
        PUBLIC _Z18set_probe_deployedb
        PUBLIC _Z18sync_plan_positionv
        PUBLIC _Z19clear_command_queuev
        PUBLIC _Z19do_blocking_move_toRKfS0_S0_S0_
        PUBLIC _Z19enable_all_steppersv
        PUBLIC _Z19get_sdcard_commandsv
        PUBLIC _Z19get_serial_commandsv
        PUBLIC _Z19mks_leveling_moveXYff
        PUBLIC _Z19refresh_cmd_timeoutv
        PUBLIC _Z20SysTick_Handler_Userv
        PUBLIC _Z20disable_all_steppersv
        PUBLIC _Z20display_temper_errorv
        PUBLIC _Z20process_next_commandv
        PUBLIC _Z20set_bltouch_deployedb
        PUBLIC _Z20sync_plan_position_ev
        PUBLIC _Z21do_blocking_move_to_xRKfS0_
        PUBLIC _Z21do_blocking_move_to_zRKfS0_
        PUBLIC _Z21gcode_get_destinationv
        PUBLIC _Z21incremental_LSF_resetP15linear_fit_data
        PUBLIC _Z21lcd_reset_alert_levelv
        PUBLIC _Z21lcd_setalertstatusPGMPKc
        PUBLIC _Z21mks_WriteToEpr_pwroffv
        PUBLIC _Z21recalc_delta_settingsv
        PUBLIC _Z21soft_endstop_min_initv
        PUBLIC _Z22do_blocking_move_to_xyRKfS0_S0_
        PUBLIC _Z22get_available_commandsv
        PUBLIC _Z22invalid_extruder_errorh
        PUBLIC _Z22mks_ReadFromEpr_pwroffv
        PUBLIC _Z22process_parsed_commandv
        PUBLIC _Z23report_current_positionv
        PUBLIC _Z24FlushSerialRequestResendv
        PUBLIC _Z24enqueue_and_echo_commandPKcb
        PUBLIC _Z24forward_kinematics_DELTAPf
        PUBLIC _Z24forward_kinematics_DELTAfff
        PUBLIC _Z24forward_kinematics_SCARARKfS0_
        PUBLIC _Z24get_homing_bump_feedrate8AxisEnum
        PUBLIC _Z24mesh_line_to_destinationfhh
        PUBLIC _Z24set_bed_leveling_enabledb
        PUBLIC _Z24update_software_endstops8AxisEnum
        PUBLIC _Z25prepare_kinematic_move_toRA4_Kf
        PUBLIC _Z26buffer_line_to_destinationf
        PUBLIC _Z26clamp_to_software_endstopsPf
        PUBLIC _Z27enqueue_and_echo_commands_PPKc
        PUBLIC _Z27gcode_G29_MESH_BED_LEVELINGv
        PUBLIC _Z27get_cartesian_from_steppersv
        PUBLIC _Z27prepare_move_to_destinationv
        PUBLIC _Z28SYNC_PLAN_POSITION_KINEMATICv
        PUBLIC _Z28bilinear_line_to_destinationftt
        PUBLIC _Z28delta_safe_distance_from_topv
        PUBLIC _Z28gcode_M421_MESH_BED_LEVELINGv
        PUBLIC _Z28set_current_from_destinationv
        PUBLIC _Z28set_destination_from_currentv
        PUBLIC _Z28sync_plan_position_kinematicv
        PUBLIC _Z31buffer_line_to_current_positionv
        PUBLIC _Z31inverse_kinematics_MORGAN_SCARAPKf
        PUBLIC _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        PUBLIC _Z32get_target_extruder_from_commandt
        PUBLIC _Z34position_is_reachable_IS_CARTESIANRKfS0_
        PUBLIC _Z34position_is_reachable_IS_KINEMATICRKfS0_
        PUBLIC _Z34set_current_from_steppers_for_axis8AxisEnum
        PUBLIC _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        PUBLIC _Z37prepare_move_to_destination_cartesianv
        PUBLIC _Z42prepare_uninterpolated_move_to_destinationf
        PUBLIC _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        PUBLIC _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        PUBLIC _Z4idlev
        PUBLIC _Z4killPKc
        PUBLIC _Z4stopv
        PUBLIC _Z5dwellm
        PUBLIC _Z6Beeperj
        PUBLIC _Z6strchrPci
        PUBLIC _Z6strstrPcPKc
        PUBLIC _Z7gcode_Th
        PUBLIC _Z7mks_G28Pc
        PUBLIC _Z7pft_getv
        PUBLIC _Z7strrchrPci
        PUBLIC _Z7suicidev
        PUBLIC _Z8gcode_G4v
        PUBLIC _Z8lcd_initv
        PUBLIC _Z8plan_arcRA4_KfRA2_S_b
        PUBLIC _Z8probe_ptRKfS0_bhb
        PUBLIC _Z9IsRunningv
        PUBLIC _Z9IsStoppedv
        PUBLIC _Z9gcode_G28b
        PUBLIC _Z9gcode_G29v
        PUBLIC _Z9gcode_G30v
        PUBLIC _Z9gcode_G42v
        PUBLIC _Z9gcode_G92v
        PUBLIC _Z9gcode_M17v
        PUBLIC _Z9gcode_M20v
        PUBLIC _Z9gcode_M22v
        PUBLIC _Z9gcode_M23v
        PUBLIC _Z9gcode_M24v
        PUBLIC _Z9gcode_M25v
        PUBLIC _Z9gcode_M26v
        PUBLIC _Z9gcode_M27v
        PUBLIC _Z9gcode_M28v
        PUBLIC _Z9gcode_M29v
        PUBLIC _Z9gcode_M30v
        PUBLIC _Z9gcode_M31v
        PUBLIC _Z9gcode_M32v
        PUBLIC _Z9gcode_M42v
        PUBLIC _Z9gcode_M49v
        PUBLIC _Z9gcode_M75v
        PUBLIC _Z9gcode_M76v
        PUBLIC _Z9gcode_M77v
        PUBLIC _Z9gcode_M81v
        PUBLIC _Z9gcode_M82v
        PUBLIC _Z9gcode_M83v
        PUBLIC _Z9gcode_M85v
        PUBLIC _Z9gcode_M92v
        PUBLIC _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        PUBLIC _ZN10CardReader10isFileOpenEv
        PUBLIC _ZN10CardReader3eofEv
        PUBLIC _ZN10CardReader3getEv
        PUBLIC _ZN10CardReader8setIndexEl
        PUBLIC _ZN10duration_tC1ERKj
        PUBLIC _ZN11GCodeParser10celsiusvalEcf
        PUBLIC _ZN11GCodeParser10value_boolEv
        PUBLIC _ZN11GCodeParser10value_byteEv
        PUBLIC _ZN11GCodeParser10value_longEv
        PUBLIC _ZN11GCodeParser11value_floatEv
        PUBLIC _ZN11GCodeParser11value_ulongEv
        PUBLIC _ZN11GCodeParser12value_millisEv
        PUBLIC _ZN11GCodeParser12value_ushortEv
        PUBLIC _ZN11GCodeParser13value_celsiusEv
        PUBLIC _ZN11GCodeParser14value_feedrateEv
        PUBLIC _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        PUBLIC _ZN11GCodeParser18value_linear_unitsEv
        PUBLIC _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        PUBLIC _ZN11GCodeParser25value_millis_from_secondsEv
        PUBLIC _ZN11GCodeParser4seenEc
        PUBLIC _ZN11GCodeParser6intvalEcs
        PUBLIC _ZN11GCodeParser7boolvalEc
        PUBLIC _ZN11GCodeParser7bytevalEch
        PUBLIC _ZN11GCodeParser7seenvalEc
        PUBLIC _ZN11GCodeParser9has_valueEv
        PUBLIC _ZN11GCodeParser9linearvalEcf
        PUBLIC _ZN11GCodeParser9ushortvalEct
        PUBLIC _ZN11GCodeParser9value_intEv
        PUBLIC _ZN11Temperature12degTargetBedEv
        PUBLIC _ZN11Temperature12isCoolingBedEv
        PUBLIC _ZN11Temperature12setTargetBedEf
        PUBLIC _ZN11Temperature15degTargetHotendEh
        PUBLIC _ZN11Temperature15isCoolingHotendEh
        PUBLIC _ZN11Temperature15setTargetHotendEfh
        PUBLIC _ZN11Temperature16tooColdToExtrudeEh
        PUBLIC _ZN11Temperature24set_auto_report_intervalEh
        PUBLIC _ZN11Temperature6degBedEv
        PUBLIC _ZN11Temperature9degHotendEh
        PUBLIC _ZN11Temperature9updatePIDEv
        PUBLIC _ZN17mesh_bed_leveling12cell_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling12cell_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling5set_zEaaRKf
        PUBLIC _ZN17mesh_bed_leveling6zigzagEaRaS0_
        PUBLIC _ZN20unified_bed_leveling13mesh_is_validEv
        PUBLIC _ZN20unified_bed_leveling18mesh_index_to_xposEh
        PUBLIC _ZN20unified_bed_leveling18mesh_index_to_yposEh
        PUBLIC _ZN7Planner11buffer_lineEfffRKfS1_h
        PUBLIC _ZN7Planner13blocks_queuedEv
        PUBLIC _ZN7Planner14apply_levelingERA3_f
        PUBLIC _ZN7Planner15set_position_mmEfffRKf
        PUBLIC _ZN7Planner16refresh_e_factorEh
        PUBLIC _ZN7Planner17force_fade_recalcEv
        PUBLIC _ZN7Planner17set_e_position_mmERKf
        PUBLIC _ZN7Planner17set_filament_sizeEhRKf
        PUBLIC _ZN7Planner17set_z_fade_heightERKf
        PUBLIC _ZN7Planner20leveling_active_at_zERKf
        PUBLIC _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        PUBLIC _ZN7Stepper10set_z_lockEb
        PUBLIC _ZN7Stepper11set_z2_lockEb
        PUBLIC _ZN7Stepper17set_homing_flag_zEb
        PUBLIC _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        PUBLIC _ZN8Endstops10not_homingEv
        PUBLIC _ZN8Endstops14enable_z_probeEb
        PUBLIC _ZN8Endstops14hit_on_purposeEv
        PUBLIC _ZN8Endstops15enable_globallyEb
        PUBLIC _ZN8Endstops6enableEb
        PUBLIC _ZNK10duration_t3dayEv
        PUBLIC _ZNK10duration_t4hourEv
        PUBLIC _ZNK10duration_t4yearEv
        PUBLIC _ZNK10duration_t6minuteEv
        PUBLIC _ZNK10duration_t6secondEv
        PUBLIC _ZNK10duration_t8toStringEPc
        PUBLIC _ZTI5Print
        PUBLIC _ZZ10gcode_M104vEs
        PUBLIC _ZZ10gcode_M104vEs_0
        PUBLIC _ZZ10gcode_M104vEs_1
        PUBLIC _ZZ10gcode_M104vEs_2
        PUBLIC _ZZ10gcode_M104vEs_3
        PUBLIC _ZZ10gcode_M104vEs_4
        PUBLIC _ZZ10gcode_M105vEs
        PUBLIC _ZZ10gcode_M109vEs
        PUBLIC _ZZ10gcode_M109vEs_0
        PUBLIC _ZZ10gcode_M109vEs_1
        PUBLIC _ZZ10gcode_M109vEs_2
        PUBLIC _ZZ10gcode_M109vEs_3
        PUBLIC _ZZ10gcode_M109vEs_4
        PUBLIC _ZZ10gcode_M109vEs_5
        PUBLIC _ZZ10gcode_M109vEs_6
        PUBLIC _ZZ10gcode_M111vE11str_debug_1
        PUBLIC _ZZ10gcode_M111vE11str_debug_2
        PUBLIC _ZZ10gcode_M111vE11str_debug_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_8
        PUBLIC _ZZ10gcode_M111vE12str_debug_16
        PUBLIC _ZZ10gcode_M111vE13debug_strings
        PUBLIC _ZZ10gcode_M111vEs_4
        PUBLIC _ZZ10gcode_M111vEs_5
        PUBLIC _ZZ10gcode_M112vEs
        PUBLIC _ZZ10gcode_M113vEs
        PUBLIC _ZZ10gcode_M115vEs
        PUBLIC _ZZ10gcode_M115vEs_0
        PUBLIC _ZZ10gcode_M115vEs_1
        PUBLIC _ZZ10gcode_M115vEs_2
        PUBLIC _ZZ10gcode_M115vEs_3
        PUBLIC _ZZ10gcode_M115vEs_4
        PUBLIC _ZZ10gcode_M115vEs_5
        PUBLIC _ZZ10gcode_M115vEs_6
        PUBLIC _ZZ10gcode_M115vEs_7
        PUBLIC _ZZ10gcode_M115vEs_8
        PUBLIC _ZZ10gcode_M115vEs_9
        PUBLIC _ZZ10gcode_M115vEs__10_
        PUBLIC _ZZ10gcode_M115vEs__11_
        PUBLIC _ZZ10gcode_M115vEs__12_
        PUBLIC _ZZ10gcode_M115vEs__13_
        PUBLIC _ZZ10gcode_M118vEs
        PUBLIC _ZZ10gcode_M190vEs
        PUBLIC _ZZ10gcode_M190vEs_0
        PUBLIC _ZZ10gcode_M190vEs_1
        PUBLIC _ZZ10gcode_M204vEs
        PUBLIC _ZZ10gcode_M204vEs_0
        PUBLIC _ZZ10gcode_M204vEs_1
        PUBLIC _ZZ10gcode_M204vEs_2
        PUBLIC _ZZ10gcode_M211vEs
        PUBLIC _ZZ10gcode_M211vEs_0
        PUBLIC _ZZ10gcode_M211vEs_1
        PUBLIC _ZZ10gcode_M211vEs_2
        PUBLIC _ZZ10gcode_M211vEs_3
        PUBLIC _ZZ10gcode_M211vEs_4
        PUBLIC _ZZ10gcode_M211vEs_5
        PUBLIC _ZZ10gcode_M211vEs_6
        PUBLIC _ZZ10gcode_M218vEs
        PUBLIC _ZZ10gcode_M280vEs
        PUBLIC _ZZ10gcode_M280vEs_0
        PUBLIC _ZZ10gcode_M280vEs_1
        PUBLIC _ZZ10gcode_M301vEs
        PUBLIC _ZZ10gcode_M301vEs_0
        PUBLIC _ZZ10gcode_M301vEs_1
        PUBLIC _ZZ10gcode_M301vEs_2
        PUBLIC _ZZ10gcode_M302vEs
        PUBLIC _ZZ10gcode_M302vEs_0
        PUBLIC _ZZ10gcode_M302vEs_1
        PUBLIC _ZZ10gcode_M302vEs_2
        PUBLIC _ZZ10gcode_M302vEs_3
        PUBLIC _ZZ10gcode_M303vEs
        PUBLIC _ZZ10gcode_M304vEs
        PUBLIC _ZZ10gcode_M304vEs_0
        PUBLIC _ZZ10gcode_M304vEs_1
        PUBLIC _ZZ10gcode_M355vEs
        PUBLIC _ZZ10gcode_M360vEs
        PUBLIC _ZZ10gcode_M361vEs
        PUBLIC _ZZ10gcode_M362vEs
        PUBLIC _ZZ10gcode_M363vEs
        PUBLIC _ZZ10gcode_M364vEs
        PUBLIC _ZZ10gcode_M420vEs
        PUBLIC _ZZ10gcode_M420vEs_0
        PUBLIC _ZZ10gcode_M420vEs_1
        PUBLIC _ZZ10gcode_M420vEs_2
        PUBLIC _ZZ10gcode_M420vEs_3
        PUBLIC _ZZ10gcode_M420vEs_4
        PUBLIC _ZZ10gcode_M420vEs_5
        PUBLIC _ZZ10gcode_M420vEs_6
        PUBLIC _ZZ10gcode_M420vEs_7
        PUBLIC _ZZ10gcode_M420vEs_8
        PUBLIC _ZZ10gcode_M420vEs_9
        PUBLIC _ZZ10gcode_M420vEs__10_
        PUBLIC _ZZ10gcode_M420vEs__11_
        PUBLIC _ZZ10gcode_M428vEs
        PUBLIC _ZZ10gcode_M428vEs_0
        PUBLIC _ZZ10gcode_M428vEs_1
        PUBLIC _ZZ10gcode_M851vEs
        PUBLIC _ZZ10gcode_M851vEs_0
        PUBLIC _ZZ10gcode_M851vEs_1
        PUBLIC _ZZ10home_deltavEs
        PUBLIC _ZZ10home_deltavEs_0
        PUBLIC _ZZ11gcode_G2_G3bEs
        PUBLIC _ZZ15gcode_M666_dualvEs
        PUBLIC _ZZ15gcode_M666_dualvEs_0
        PUBLIC _ZZ17get_wifi_commandsvE16wifi_line_buffer
        PUBLIC _ZZ17get_wifi_commandsvE17wifi_comment_mode
        PUBLIC _ZZ17get_wifi_commandsvEs
        PUBLIC _ZZ17get_wifi_commandsvEs_0
        PUBLIC _ZZ17get_wifi_commandsvEs_1
        PUBLIC _ZZ17get_wifi_commandsvEs_2
        PUBLIC _ZZ17get_wifi_commandsvEs_3
        PUBLIC _ZZ17get_wifi_commandsvEs_4
        PUBLIC _ZZ19get_sdcard_commandsvE14stop_buffering
        PUBLIC _ZZ19get_sdcard_commandsvE15sd_comment_mode
        PUBLIC _ZZ19get_sdcard_commandsvEs
        PUBLIC _ZZ19get_sdcard_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvE14last_wait_time
        PUBLIC _ZZ19get_serial_commandsvE18serial_line_buffer
        PUBLIC _ZZ19get_serial_commandsvE19serial_comment_mode
        PUBLIC _ZZ19get_serial_commandsvEs
        PUBLIC _ZZ19get_serial_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvEs_1
        PUBLIC _ZZ19get_serial_commandsvEs_2
        PUBLIC _ZZ19get_serial_commandsvEs_3
        PUBLIC _ZZ19get_serial_commandsvEs_4
        PUBLIC _ZZ19get_serial_commandsvEs_5
        PUBLIC _ZZ19get_serial_commandsvEs_6
        PUBLIC _ZZ19get_serial_commandsvEs_7
        PUBLIC _ZZ19get_serial_commandsvEs_8
        PUBLIC _ZZ22invalid_extruder_errorhEs
        PUBLIC _ZZ24get_homing_bump_feedrate8AxisEnumEs
        PUBLIC _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
        PUBLIC _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
        PUBLIC _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
        PUBLIC _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
        PUBLIC _ZZ8gcode_G4vEs
        PUBLIC _ZZ9gcode_G29vEs
        PUBLIC _ZZ9gcode_G29vEs_0
        PUBLIC _ZZ9gcode_G29vEs_1
        PUBLIC _ZZ9gcode_G29vEs_2
        PUBLIC _ZZ9gcode_G29vEs_3
        PUBLIC _ZZ9gcode_G29vEs_4
        PUBLIC _ZZ9gcode_G29vEs_5
        PUBLIC _ZZ9gcode_G29vEs_6
        PUBLIC _ZZ9gcode_G29vEs_7
        PUBLIC _ZZ9gcode_G29vEs_8
        PUBLIC _ZZ9gcode_G29vEs_9
        PUBLIC _ZZ9gcode_G29vEs__10_
        PUBLIC _ZZ9gcode_G29vEs__11_
        PUBLIC _ZZ9gcode_G29vEs__12_
        PUBLIC _ZZ9gcode_G29vEs__13_
        PUBLIC _ZZ9gcode_G29vEs__14_
        PUBLIC _ZZ9gcode_G29vEs__15_
        PUBLIC _ZZ9gcode_G29vEs__16_
        PUBLIC _ZZ9gcode_G29vEs__17_
        PUBLIC _ZZ9gcode_G29vEs__18_
        PUBLIC _ZZ9gcode_G30vEs
        PUBLIC _ZZ9gcode_G30vEs_0
        PUBLIC _ZZ9gcode_G30vEs_1
        PUBLIC _ZZ9gcode_G42vEs
        PUBLIC _ZZ9gcode_M17vEs
        PUBLIC _ZZ9gcode_M20vEs
        PUBLIC _ZZ9gcode_M20vEs_0
        PUBLIC _ZZ9gcode_M31vEs
        PUBLIC _ZZ9gcode_M42vEs
        PUBLIC _ZZ9gcode_M49vEs
        PUBLIC _ZZ9gcode_M49vEs_0
        PUBLIC _ZZ9gcode_M49vEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs_2
        PUBLIC _ZZNK10duration_t8toStringEPcEs_3
        PUBLIC active_extruder
        PUBLIC axis_homed
        PUBLIC axis_known_position
        PUBLIC axis_relative_modes
        PUBLIC base_home_pos_P
        PUBLIC base_max_pos_P
        PUBLIC base_min_pos_P
        PUBLIC beep_cnt
        PUBLIC beep_flg
        PUBLIC bilinear_grid_factor
        PUBLIC bilinear_grid_spacing
        PUBLIC bilinear_start
        PUBLIC busy_state
        PUBLIC button_disp_pause_state
        PUBLIC card
        PUBLIC cartes
        PUBLIC cloud_refresh_flg
        PUBLIC commands_in_queue
        PUBLIC continue_print_error_flg
        PUBLIC current_position
        PUBLIC delta
        PUBLIC delta_calibration_radius
        PUBLIC delta_clip_start_height
        PUBLIC delta_diagonal_rod
        PUBLIC delta_diagonal_rod_2_tower
        PUBLIC delta_endstop_adj
        PUBLIC delta_height
        PUBLIC delta_radius
        PUBLIC delta_segments_per_second
        PUBLIC delta_tower
        PUBLIC delta_tower_angle_trim
        PUBLIC destination
        PUBLIC display_hold
        PUBLIC display_hold_cnt
        PUBLIC display_hold_release
        PUBLIC fanSpeeds
        PUBLIC feedrate_mm_s
        PUBLIC feedrate_percentage
        PUBLIC filament_heat_completed_load
        PUBLIC filament_heat_completed_unload
        PUBLIC filament_loading_completed
        PUBLIC filament_loading_time_cnt
        PUBLIC filament_loading_time_flg
        PUBLIC filament_unloading_completed
        PUBLIC filament_unloading_time_cnt
        PUBLIC filament_unloading_time_flg
        PUBLIC from_wifi_flag
        PUBLIC g26_debug_flag
        PUBLIC has_adjust_speed
        PUBLIC home_bump_mm_P
        PUBLIC home_dir_P
        PUBLIC home_offset
        PUBLIC homing_feedrate_mm_s
        PUBLIC host_keepalive_interval
        PUBLIC hotend_offset
        PUBLIC kill_c
        PUBLIC lcd_wait_for_move
        PUBLIC loop
        PUBLIC loop_start
        PUBLIC marlin_debug_flags
        PUBLIC max_length_P
        PUBLIC mksReprint
        PUBLIC mks_PrintStatePolling
        PUBLIC mks_ReadFromEpr
        PUBLIC mks_ReadFromFile
        PUBLIC mks_WriteToFile
        PUBLIC mks_adjust_extrude_speed
        PUBLIC mks_clearDir
        PUBLIC mks_clearFile
        PUBLIC mks_contiuePrintDelta
        PUBLIC mks_contiuePrintPause
        PUBLIC mks_contiuePrintPwdwn
        PUBLIC mks_contiuePrint_UI
        PUBLIC mks_getPositionXYZE
        PUBLIC mks_heating_busy
        PUBLIC mks_initPrint
        PUBLIC mks_manual_leveling
        PUBLIC mks_moveXY
        PUBLIC mks_moveZ
        PUBLIC mks_pausePrint
        PUBLIC mks_pft_name
        PUBLIC mks_preExtrude
        PUBLIC mks_rePrintCheck
        PUBLIC mks_resumePrint
        PUBLIC mks_resume_extrude_speed
        PUBLIC mks_saveFileName
        PUBLIC mks_setPositionZ
        PUBLIC mkstft_ui_init
        PUBLIC mkstft_ui_load
        PUBLIC position_shift
        PUBLIC preview_no_display
        PUBLIC previous_cmd_ms
        PUBLIC print_finish_close_machine
        PUBLIC print_finish_start_timer
        PUBLIC print_finish_timer_count
        PUBLIC print_job_timer
        PUBLIC printing_rate_update_flag
        PUBLIC resume_printed_time
        PUBLIC saved_feedrate_percentage
        PUBLIC sd_read_cnt
        PUBLIC sd_read_error_flg
        PUBLIC serial_wait_tick
        PUBLIC setup
        PUBLIC soft_endstop_max
        PUBLIC soft_endstop_min
        PUBLIC soft_endstop_radius
        PUBLIC soft_endstop_radius_2
        PUBLIC soft_endstops_enabled
        PUBLIC t1
        PUBLIC t12
        PUBLIC t2
        PUBLIC target_extruder
        PUBLIC temper_error_flg
        PUBLIC temper_error_type
        PUBLIC ubl
        PUBLIC wait_for_heatup
        PUBLIC waiting_wifi_time
        PUBLIC wifi_init_flg
        PUBLIC wifi_init_state
        PUBLIC wifi_loop_cycle
        PUBLIC wifi_refresh_flg
        PUBLIC workspace_offset
        PUBLIC xy_probe_feedrate_mm_s
        PUBLIC z_endstop_adj
        PUBLIC z_high_count
        PUBLIC z_values
        PUBLIC zprobe_zoffset
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    1 /**
//    2  * Marlin 3D Printer Firmware
//    3  * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
//    4  *
//    5  * Based on Sprinter and grbl.
//    6  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
//    7  *
//    8  * This program is free software: you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation, either version 3 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License
//   19  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
//   20  *
//   21  */
//   22 
//   23 /**
//   24  * About Marlin
//   25  *
//   26  * This firmware is a mashup between Sprinter and grbl.
//   27  *  - https://github.com/kliment/Sprinter
//   28  *  - https://github.com/simen/grbl/tree
//   29  */
//   30 
//   31 /**
//   32  * -----------------
//   33  * G-Codes in Marlin
//   34  * -----------------
//   35  *
//   36  * Helpful G-code references:
//   37  *  - http://linuxcnc.org/handbook/gcode/g-code.html
//   38  *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
//   39  *
//   40  * Help to document Marlin's G-codes online:
//   41  *  - http://reprap.org/wiki/G-code
//   42  *  - https://github.com/MarlinFirmware/MarlinDocumentation
//   43  *
//   44  * -----------------
//   45  *
//   46  * "G" Codes
//   47  *
//   48  * G0   -> G1
//   49  * G1   - Coordinated Movement X Y Z E
//   50  * G2   - CW ARC
//   51  * G3   - CCW ARC
//   52  * G4   - Dwell S<seconds> or P<milliseconds>
//   53  * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
//   54  * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
//   55  * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
//   56  * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
//   57  * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
//   58  * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
//   59  * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
//   60  * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
//   61  * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
//   62  * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
//   63  * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
//   64  * G28  - Home one or more axes
//   65  * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
//   66  * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
//   67  * G31  - Dock sled (Z_PROBE_SLED only)
//   68  * G32  - Undock sled (Z_PROBE_SLED only)
//   69  * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
//   70  * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
//   71  * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
//   72  * G90  - Use Absolute Coordinates
//   73  * G91  - Use Relative Coordinates
//   74  * G92  - Set current position to coordinates given
//   75  *
//   76  * "M" Codes
//   77  *
//   78  * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
//   79  * M1   -> M0
//   80  * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
//   81  * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
//   82  * M5   - Turn laser/spindle off
//   83  * M17  - Enable/Power all stepper motors
//   84  * M18  - Disable all stepper motors; same as M84
//   85  * M20  - List SD card. (Requires SDSUPPORT)
//   86  * M21  - Init SD card. (Requires SDSUPPORT)
//   87  * M22  - Release SD card. (Requires SDSUPPORT)
//   88  * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
//   89  * M24  - Start/resume SD print. (Requires SDSUPPORT)
//   90  * M25  - Pause SD print. (Requires SDSUPPORT)
//   91  * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
//   92  * M27  - Report SD print status. (Requires SDSUPPORT)
//   93  * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
//   94  * M29  - Stop SD write. (Requires SDSUPPORT)
//   95  * M30  - Delete file from SD: "M30 /path/file.gco"
//   96  * M31  - Report time since last M109 or SD card start to serial.
//   97  * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
//   98  *        Use P to run other files as sub-programs: "M32 P !filename#"
//   99  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
//  100  * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
//  101  * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
//  102  * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
//  103  * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
//  104  * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
//  105  * M75  - Start the print job timer.
//  106  * M76  - Pause the print job timer.
//  107  * M77  - Stop the print job timer.
//  108  * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
//  109  * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
//  110  * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
//  111  * M82  - Set E codes absolute (default).
//  112  * M83  - Set E codes relative while in Absolute (G90) mode.
//  113  * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
//  114  *        duration after which steppers should turn off. S0 disables the timeout.
//  115  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
//  116  * M92  - Set planner.axis_steps_per_mm for one or more axes.
//  117  * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
//  118  * M104 - Set extruder target temp.
//  119  * M105 - Report current temperatures.
//  120  * M106 - Set print fan speed.
//  121  * M107 - Print fan off.
//  122  * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
//  123  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
//  124  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
//  125  *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
//  126  * M110 - Set the current line number. (Used by host printing)
//  127  * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
//  128  * M112 - Emergency stop.
//  129  * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
//  130  * M114 - Report current position.
//  131  * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
//  132  * M117 - Display a message on the controller screen. (Requires an LCD)
//  133  * M118 - Display a message in the host console.
//  134  * M119 - Report endstops status.
//  135  * M120 - Enable endstops detection.
//  136  * M121 - Disable endstops detection.
//  137  * M122 - Debug stepper (Requires HAVE_TMC2130)
//  138  * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
//  139  * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
//  140  * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
//  141  * M128 - EtoP Open. (Requires BARICUDA)
//  142  * M129 - EtoP Closed. (Requires BARICUDA)
//  143  * M140 - Set bed target temp. S<temp>
//  144  * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
//  145  * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
//  146  * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
//  147  * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
//  148  * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
//  149  * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
//  150  * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
//  151  * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
//  152  *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
//  153  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
//  154  * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
//  155  * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
//  156  * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
//  157  * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
//  158  * M205 - Set advanced settings. Current units apply:
//  159             S<print> T<travel> minimum speeds
//  160             B<minimum segment time>
//  161             X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
//  162  * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  163  * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
//  164  * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
//  165  * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
//  166           Every normal extrude-only move will be classified as retract depending on the direction.
//  167  * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
//  168  * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
//  169  * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
//  170  * M221 - Set Flow Percentage: "M221 S<percent>"
//  171  * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
//  172  * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
//  173  * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
//  174  * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
//  175  * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
//  176  * M280 - Set servo position absolute: "M280 P<index> S<angle|碌s>". (Requires servos)
//  177  * M290 - Babystepping (Requires BABYSTEPPING)
//  178  * M300 - Play beep sound S<frequency Hz> P<duration ms>
//  179  * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
//  180  * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
//  181  * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
//  182  * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
//  183  * M350 - Set microstepping mode. (Requires digital microstepping pins.)
//  184  * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
//  185  * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
//  186  * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
//  187  * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
//  188  * M400 - Finish all moves.
//  189  * M401 - Lower Z probe. (Requires a probe)
//  190  * M402 - Raise Z probe. (Requires a probe)
//  191  * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
//  192  * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
//  193  * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
//  194  * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
//  195  * M410 - Quickstop. Abort all planned moves.
//  196  * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
//  197  * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
//  198  * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  199  * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
//  200  * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
//  201  * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
//  202  * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
//  203  * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
//  204  * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
//  205  * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
//  206  * M666 - Set delta endstop adjustment. (Requires DELTA)
//  207  * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
//  208  * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
//  209  * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
//  210  * M860 - Report the position of position encoder modules.
//  211  * M861 - Report the status of position encoder modules.
//  212  * M862 - Perform an axis continuity test for position encoder modules.
//  213  * M863 - Perform steps-per-mm calibration for position encoder modules.
//  214  * M864 - Change position encoder module I2C address.
//  215  * M865 - Check position encoder module firmware version.
//  216  * M866 - Report or reset position encoder module error count.
//  217  * M867 - Enable/disable or toggle error correction for position encoder modules.
//  218  * M868 - Report or set position encoder module error correction threshold.
//  219  * M869 - Report position encoder module error.
//  220  * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
//  221  * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  222  * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
//  223  * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
//  224  * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
//  225  * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
//  226  * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  227  * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  228  * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
//  229  * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
//  230  *
//  231  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
//  232  * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
//  233  * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
//  234  * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
//  235  * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
//  236  *
//  237  * ************ Custom codes - This can change to suit future G-code regulations
//  238  * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
//  239  * M998	- Stop SD print. (Requires SDSUPPORT)
//  240  * M999 - Restart after being stopped by error
//  241  *
//  242  * "T" Codes
//  243  *
//  244  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
//  245  *
//  246  */
//  247 
//  248 #include "Marlin.h"
//  249 
//  250 #include "ultralcd.h"
//  251 #include "planner.h"
//  252 #include "stepper.h"
//  253 #include "endstops.h"
//  254 #include "temperature.h"
//  255 #include "cardreader.h"
//  256 #include "configuration_store.h"
//  257 #include "language.h"
//  258 //#include "pins_arduino.h"
//  259 #include "math.h"
//  260 #include "nozzle.h"
//  261 #include "duration_t.h"
//  262 //#include "types.h"
//  263 #include "tim.h"
//  264 #include "gcode.h"
//  265 
//  266 #include "least_squares_fit.h"
//  267 #include "ubl.h"
//  268 
//  269 #include "mks_cfg.h"
//  270 #include "mks_reprint.h"
//  271 
//  272 #if 1
//  273 
//  274 #include "wifi_module.h"
//  275 
//  276 #include "gui.h"
//  277 
//  278 #include "draw_ready_print.h"
//  279 
//  280 #include "draw_ui.h"
//  281 #include "wifi_module.h"
//  282 #include "draw_printing.h"
//  283 #include "draw_pause_ui.h"
//  284 #include "sdio_sdcard.h"
//  285 #include "draw_keyboard.h"
//  286 #include "draw_Tips.h"
//  287 #include "ili9320.h"
//  288 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  289 volatile uint8_t temper_error_flg = 0;
temper_error_flg:
        DS8 1
//  290 volatile uint8_t temper_error_type = 0;
temper_error_type:
        DS8 1
//  291 
//  292 volatile uint8_t mks_heating_busy = 0;
//  293 
//  294 extern void PowerOff_Filament_Check();
//  295 extern void display_temper_error();
//  296 extern void Close_machine_display();
//  297 
//  298 extern uint8_t IsChooseAutoShutdown;
//  299 
//  300 extern uint8_t temperature_change_frequency;
//  301 
//  302 static uint32_t temperature_change_frequency_cnt = 0;
//  303 static uint32_t After_finish_print_time = 0;
//  304 
//  305 uint8_t filament_loading_time_flg;
//  306 uint32_t filament_loading_time_cnt;
//  307 uint8_t filament_loading_completed;
//  308 uint8_t filament_unloading_time_flg;
//  309 uint32_t filament_unloading_time_cnt;
//  310 uint8_t filament_unloading_completed;
//  311 
//  312 uint8_t filament_heat_completed_load;
//  313 uint8_t filament_heat_completed_unload;
//  314 
//  315 extern uint32_t filament_rate;
//  316 
//  317 
//  318 volatile uint32_t TimeIncrease;
//  319 uint8_t volatile printing_rate_update_flag;
//  320 uint8_t preview_no_display;
//  321 extern PRINT_TIME  print_time;
//  322 
//  323 extern uint8_t from_flash_pic;
//  324 volatile uint8_t loop_start=0;
//  325 #endif
//  326 
//  327 
//  328 #if 0
//  329 #if HAS_ABL
//  330   #include "vector_3.h"
//  331   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
//  332     #include "least_squares_fit.h"
//  333   #endif
//  334 #elif ENABLED(MESH_BED_LEVELING)
//  335   #include "mesh_bed_leveling.h"
//  336 #endif
//  337 #endif
//  338 #include "vector_3.h"
//  339 //#include "qr_solve.h"
//  340 #include "mesh_bed_leveling.h"
//  341 
//  342 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  343   #include "planner_bezier.h"
//  344 #endif
//  345 
//  346 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
//  347   #include "buzzer.h"
//  348 #endif
//  349 
//  350 #if ENABLED(USE_WATCHDOG)
//  351   #include "watchdog.h"
//  352 #endif
//  353 
//  354 #if ENABLED(MAX7219_DEBUG)
//  355   #include "Max7219_Debug_LEDs.h"
//  356 #endif
//  357 
//  358 #if HAS_COLOR_LEDS
//  359   #include "leds.h"
//  360 #endif
//  361 
//  362 #if HAS_SERVOS
//  363   #include "servo.h"
//  364 #endif
//  365 
//  366 #if HAS_DIGIPOTSS
//  367   #include <SPI.h>
//  368 #endif
//  369 
//  370 #if ENABLED(DAC_STEPPER_CURRENT)
//  371   #include "stepper_dac.h"
//  372 #endif
//  373 
//  374 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  375   #include "twibus.h"
//  376 #endif
//  377 
//  378 #if ENABLED(I2C_POSITION_ENCODERS)
//  379   #include "I2CPositionEncoder.h"
//  380 #endif
//  381 
//  382 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
//  383   #include "endstop_interrupts.h"
//  384 #endif
//  385 
//  386 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  387   void gcode_M100();
//  388   void M100_dump_routine(const char * const title, const char *start, const char *end);
//  389 #endif
//  390 
//  391 #if ENABLED(G26_MESH_VALIDATION)
//  392   bool g26_debug_flag; // =false
//  393   void gcode_G26();
//  394 #endif
//  395 
//  396 #if ENABLED(SDSUPPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function __sti__routine
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
//  397   CardReader card;
        LDR.W    R5,??DataTable134_3
        MOV      R0,R5
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
//  398 #endif
//  399 
//  400 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  401   TWIBus i2c;
//  402 #endif
//  403 
//  404 #if ENABLED(G38_PROBE_TARGET)
//  405   bool G38_move = false,
//  406        G38_endstop_hit = false;
//  407 #endif
//  408 
//  409 #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
//  410   #include "ubl.h"
//  411   extern bool defer_return_to_status;
//  412   unified_bed_leveling ubl;
        LDR.W    R4,??DataTable134_4
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_levelingC1Ev
        BL       _ZN20unified_bed_levelingC1Ev
        ADDW     R0,R5,#+3436
          CFI FunCall _ZN9StopwatchC1Ev
        BL       _ZN9StopwatchC1Ev
        LDR.W    R5,??DataTable134_5
        LDR      R0,[R5, #+116]
        LDR.W    R1,??DataTable134_6  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+116]
        LDR      R0,[R5, #+28]
        STR      R0,[R4, #+124]
        LDR.W    R7,??DataTable134_7  ;; 0x43160000
        MOV      R9,R7
        MOV      R10,#+2
        MOV      R6,#+1065353216
        MOV      R8,R6
        B.N      ??__sti__routine_0
??__sti__routine_1:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??__sti__routine_0:
        LSLS     R0,R10,#+31
        BPL.N    ??__sti__routine_2
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??__sti__routine_2:
        LSRS     R10,R10,#+1
        BNE.N    ??__sti__routine_1
        LDR.W    R9,??DataTable134_8
        STR      R8,[R9, #+52]
        MOV      R1,R8
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+128]
        MOVS     R4,#+2
        B.N      ??__sti__routine_3
??__sti__routine_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??__sti__routine_3:
        LSLS     R0,R4,#+31
        BPL.N    ??__sti__routine_5
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??__sti__routine_5:
        LSRS     R4,R4,#+1
        BNE.N    ??__sti__routine_4
        STR      R6,[R9, #+56]
        LDR      R0,[R5, #+8]
        STR      R0,[R9, #+4]
        LDR      R0,[R5, #+12]
        STR      R0,[R9, #+8]
        LDR      R0,[R5, #+16]
        STR      R0,[R9, #+12]
        LDR      R0,[R5, #+20]
        STR      R0,[R9, #+16]
        LDR      R0,[R5, #+24]
        STR      R0,[R9, #+20]
        LDR      R0,[R5, #+28]
        STR      R0,[R9, #+24]
        LDR      R0,[R5, #+80]
        STR      R0,[R9, #+36]
        LDR      R0,[R5, #+20]
        LDR      R1,[R5, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+40]
        LDR      R0,[R5, #+24]
        LDR      R1,[R5, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+44]
        LDR      R0,[R5, #+28]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+48]
        LDRB     R0,[R5, #+5]
        STRB     R0,[R9, #+0]
        LDRB     R0,[R5, #+6]
        STRB     R0,[R9, #+1]
        LDRB     R0,[R5, #+7]
        STRB     R0,[R9, #+2]
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock0
//  413 #endif
//  414 
//  415 #if ENABLED(CNC_COORDINATE_SYSTEMS)
//  416   int8_t active_coordinate_system = -1; // machine space
//  417   float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
//  418 #endif
//  419 
//  420 bool Running = true;
//  421 
//  422 uint8_t marlin_debug_flags = DEBUG_NONE;
//  423 
//  424 /**
//  425  * Cartesian Current Position
//  426  *   Used to track the native machine position as moves are queued.
//  427  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
//  428  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
//  429  */
//  430 float current_position[XYZE] = { 0.0 };
//  431 
//  432 /**
//  433  * Cartesian Destination
//  434  *   The destination for a move, filled in by G-code movement commands,
//  435  *   and expected by functions like 'prepare_move_to_destination'.
//  436  *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
//  437  */
//  438 float destination[XYZE] = { 0.0 };
//  439 
//  440 /**
//  441  * axis_homed
//  442  *   Flags that each linear axis was homed.
//  443  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
//  444  *
//  445  * axis_known_position
//  446  *   Flags that the position is known in each linear axis. Set when homed.
//  447  *   Cleared whenever a stepper powers off, potentially losing its position.
//  448  */
//  449 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
//  450 
//  451 /**
//  452  * GCode line number handling. Hosts may opt to include line numbers when
//  453  * sending commands to Marlin, and lines will be checked for sequentiality.
//  454  * M110 N<int> sets the current line number.
//  455  */
//  456 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
//  457 
//  458 /**
//  459  * GCode Command Queue
//  460  * A simple ring buffer of BUFSIZE command strings.
//  461  *
//  462  * Commands are copied into this buffer by the command injectors
//  463  * (immediate, serial, sd card) and they are processed sequentially by
//  464  * the main loop. The process_next_command function parses the next
//  465  * command and hands off execution to individual handler functions.
//  466  */
//  467 uint8_t commands_in_queue = 0; // Count of commands in the queue
//  468 static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
//  469                cmd_queue_index_w = 0; // Ring buffer write position
//  470 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  471   char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
//  472 #else                                         // This can be collapsed back to the way it was soon.
//  473 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
//  474 #endif
//  475 
//  476 /**
//  477  * Next Injected Command pointer. NULL if no commands are being injected.
//  478  * Used by Marlin internally to ensure that commands initiated from within
//  479  * are enqueued ahead of any pending serial or sd card commands.
//  480  */
//  481 static const char *injected_commands_P = NULL;
//  482 
//  483 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
//  484   TempUnit input_temp_units = TEMPUNIT_C;
//  485 #endif
//  486 
//  487 /**
//  488  * Feed rates are often configured with mm/m
//  489  * but the planner and stepper like mm/s units.
//  490  */
//  491  /*
//  492 static const float homing_feedrate_mm_s[] PROGMEM = {
//  493   #if ENABLED(DELTA)
//  494     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
//  495   #else
//  496     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
//  497   #endif
//  498   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
//  499 };
//  500 
//  501 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
//  502 */
//  503 
//  504 float  homing_feedrate_mm_s[4];
//  505 
//  506 float feedrate_mm_s = MMM_TO_MMS(1500.0);
//  507 static float saved_feedrate_mm_s;
//  508 int16_t feedrate_percentage = 100, saved_feedrate_percentage;
//  509 
//  510 // Initialized by settings.load()
//  511 bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
//  512 
//  513 #if HAS_WORKSPACE_OFFSET
//  514   #if HAS_POSITION_SHIFT
//  515     // The distance that XYZ has been offset by G92. Reset by G28.
//  516     float position_shift[XYZ] = { 0 };
//  517   #endif
//  518   #if HAS_HOME_OFFSET
//  519     // This offset is added to the configured home position.
//  520     // Set by M206, M428, or menu item. Saved to EEPROM.
//  521     float home_offset[XYZ] = { 0 };
//  522   #endif
//  523   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
//  524     // The above two are combined to save on computes
//  525     float workspace_offset[XYZ] = { 0 };
//  526   #endif
//  527 #endif
//  528 
//  529 // Software Endstops are based on the configured limits.
//  530 /*
//  531 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
//  532       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
//  533 */
//  534 float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function _Z21soft_endstop_min_initv
        THUMB
//  535 void soft_endstop_min_init()
//  536 {
_Z21soft_endstop_min_initv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
//  537     if(MACHINETPYE & IS_KINEMATIC)
        LDR.W    R4,??DataTable134_5
        LDR      R0,[R4, #+20]
        LDR.W    R5,??DataTable134_9
        MOV      R6,#+1056964608
        LDR.W    R7,??DataTable134_4
        LDRH     R1,[R4, #+88]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??soft_endstop_min_init_0
//  538     {
//  539         soft_endstop_min[0]= X_MIN_BED_IS_KINEMATIC;
        MOV      R8,#-1090519040
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R7, #+68]
//  540         soft_endstop_min[1]= Y_MIN_BED_IS_KINEMATIC;
        LDR      R0,[R4, #+24]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R7, #+72]
//  541         soft_endstop_min[2]= Z_MIN_POS;
        LDR      R0,[R4, #+16]
        STR      R0,[R7, #+76]
//  542 
//  543         soft_endstop_max[0] = X_MAX_BED_IS_KINEMATIC;
        LDR      R0,[R4, #+20]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+36]
//  544         soft_endstop_max[1] = Y_MAX_BED_IS_KINEMATIC;
        LDR      R0,[R4, #+24]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+40]
//  545         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R0,[R4, #+28]
        STR      R0,[R5, #+44]
        B.N      ??soft_endstop_min_init_1
//  546     }
//  547     else
//  548     {
//  549         soft_endstop_min[0]= X_MIN_BED_IS_CARTESIAN;
??soft_endstop_min_init_0:
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+68]
//  550         soft_endstop_min[1]= Y_MIN_BED_IS_CARTESIAN;
        LDR      R0,[R4, #+24]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+72]
//  551         soft_endstop_min[2]= Z_MIN_POS;
        LDR      R0,[R4, #+16]
        STR      R0,[R7, #+76]
//  552 
//  553         soft_endstop_max[0] = X_MAX_BED_IS_CARTESIAN;
        MOV      R7,#+1073741824
        LDR      R0,[R4, #+20]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+36]
//  554         soft_endstop_max[1] = Y_MAX_BED_IS_CARTESIAN;
        LDR      R0,[R4, #+24]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R5, #+40]
//  555         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R0,[R4, #+28]
        STR      R0,[R5, #+44]
//  556     }        
//  557 }
??soft_endstop_min_init_1:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock1
//  558 
//  559 #if HAS_SOFTWARE_ENDSTOPS
//  560   bool soft_endstops_enabled = true;
//  561   #if 1// IS_KINEMATIC
//  562     float soft_endstop_radius, soft_endstop_radius_2;
//  563   #endif
//  564 #endif
//  565 
//  566 #if FAN_COUNT > 0
//  567   int fanSpeeds[FAN_COUNT] = { 0 };
//  568   #if ENABLED(EXTRA_FAN_SPEED)
//  569     int16_t old_fanSpeeds[FAN_COUNT],
//  570             new_fanSpeeds[FAN_COUNT];
//  571   #endif
//  572   #if ENABLED(PROBING_FANS_OFF)
//  573     bool fans_paused = false;
//  574     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
//  575   #endif
//  576 #endif
//  577 
//  578 // The active extruder (tool). Set with T<extruder> command.
//  579 uint8_t active_extruder = 0;
//  580 
//  581 // Relative Mode. Enable with G91, disable with G90.
//  582 static bool relative_mode = false;
//  583 
//  584 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
//  585 volatile bool wait_for_heatup = true;
//  586 
//  587 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
//  588 #if HAS_RESUME_CONTINUE
//  589   volatile bool wait_for_user = false;
//  590 #endif
//  591 
//  592 const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
//  593 
//  594 // Number of characters read in the current line of serial input
//  595 static int serial_count = 0;
//  596 static int wifi_read_count = 0;
//  597 
//  598 // Inactivity shutdown
//  599 millis_t previous_cmd_ms = 0;
//  600 static millis_t max_inactive_time = 0;
//  601 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
//  602 
//  603 // Print Job Timer
//  604 #if ENABLED(PRINTCOUNTER)
//  605   PrintCounter print_job_timer = PrintCounter();
//  606 #else
//  607   Stopwatch print_job_timer = Stopwatch();
//  608 #endif
//  609 
//  610 // Buzzer - I2C on the LCD or a BEEPER_PIN
//  611 #if ENABLED(LCD_USE_I2C_BUZZER)
//  612   #define BUZZ(d,f) lcd_buzz(d, f)
//  613 #elif PIN_EXISTS(BEEPER)
//  614   Buzzer buzzer;
//  615   #define BUZZ(d,f) buzzer.tone(d, f)
//  616 #else
//  617   #define BUZZ(d,f) NOOP
//  618 #endif
//  619 
//  620 uint8_t target_extruder;
//  621 
//  622 #if HAS_BED_PROBE
//  623   float zprobe_zoffset; // Initialized by settings.load()
//  624 #endif
//  625 
//  626 #if 1//HAS_ABL
//  627   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
//  628   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
//  629 #elif defined(XY_PROBE_SPEED)
//  630   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
//  631 #else
//  632   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
//  633 #endif
//  634 
//  635 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  636 /*
//  637   #if ENABLED(DELTA)
//  638     #define ADJUST_DELTA(V) \ 
//  639       if (planner.leveling_active) { \ 
//  640         const float zadj = bilinear_z_offset(V); \ 
//  641         delta[A_AXIS] += zadj; \ 
//  642         delta[B_AXIS] += zadj; \ 
//  643         delta[C_AXIS] += zadj; \ 
//  644       }
//  645   #else
//  646     #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
//  647   #endif
//  648   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _Z12ADJUST_DELTAPKf
        THUMB
//  649 void  ADJUST_DELTA(const float logical[XYZ])
//  650 {
_Z12ADJUST_DELTAPKf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
//  651 	float zadj;
//  652 
//  653 	if(MACHINETPYE == DELTA)
        LDR.W    R1,??DataTable135
        LDRB     R1,[R1, #+0]
        LDR.W    R2,??DataTable134_5
        LDRSH    R2,[R2, #+88]
        CMP      R2,#+2
        BNE.N    ??ADJUST_DELTA_0
//  654 		{
//  655       	if (planner.leveling_active) { 
        CMP      R1,#+0
        BEQ.N    ??ADJUST_DELTA_1
//  656        	 	zadj = bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R4,R0
//  657         	delta[A_AXIS] += zadj; 
        LDR.W    R5,??DataTable134_4
        LDR      R0,[R5, #+80]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+80]
//  658        		delta[B_AXIS] += zadj; 
        LDR      R0,[R5, #+84]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+84]
//  659         	delta[C_AXIS] += zadj; 
        LDR      R0,[R5, #+88]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+88]
        POP      {R0,R4,R5,PC}
//  660       		}
//  661 		}
//  662 		else
//  663 			{
//  664 			if (planner.leveling_active) 
??ADJUST_DELTA_0:
        CMP      R1,#+0
        BEQ.N    ??ADJUST_DELTA_1
//  665 				 delta[Z_AXIS] += bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        LDR.W    R5,??DataTable134_4
        LDR      R1,[R5, #+88]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+88]
//  666 			}
//  667 }  
??ADJUST_DELTA_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock2

        SECTION `.data`:DATA:REORDER:NOROOT(2)
mks_heating_busy:
        DATA
        DC8 0
marlin_debug_flags:
        DC8 0
commands_in_queue:
        DC8 0
active_extruder:
        DC8 0
wait_for_heatup:
        DC8 1
target_extruder:
        DC8 0
feedrate_percentage:
        DC16 100
current_position:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
destination:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
homing_feedrate_mm_s:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
workspace_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_min:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//  668 //#elif IS_KINEMATIC
//  669 //  #define ADJUST_DELTA(V) NOOP
//  670 #endif
//  671 
//  672 #if ENABLED(X_DUAL_ENDSTOPS)
//  673   float x_endstop_adj;                // Initialized by settings.load()
//  674 #endif
//  675 #if ENABLED(Y_DUAL_ENDSTOPS)
//  676   float y_endstop_adj;                // Initialized by settings.load()
//  677 #endif
//  678 #if 1//ENABLED(Z_DUAL_ENDSTOPS)
//  679   float z_endstop_adj;                // Initialized by settings.load()
//  680 #endif
//  681 
//  682 // Extruder offsets
//  683 #if HOTENDS > 1
//  684   float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
//  685 #endif
//  686 
//  687 #if HAS_Z_SERVO_ENDSTOP
//  688   const int z_servo_angle[2] = Z_SERVO_ANGLES;
//  689 #endif
//  690 
//  691 #if ENABLED(BARICUDA)
//  692   uint8_t baricuda_valve_pressure = 0,
//  693           baricuda_e_to_p_pressure = 0;
//  694 #endif
//  695 
//  696 #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
//  697   bool autoretract_enabled,                 // M209 S - Autoretract switch
//  698        retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
//  699   float retract_length,                     // M207 S - G10 Retract length
//  700         retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
//  701         retract_zlift,                      // M207 Z - G10 Retract hop size
//  702         retract_recover_length,             // M208 S - G11 Recover length
//  703         retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
//  704         swap_retract_length,                // M207 W - G10 Swap Retract length
//  705         swap_retract_recover_length,        // M208 W - G11 Swap Recover length
//  706         swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
//  707   #if EXTRUDERS > 1
//  708     bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
//  709   #else
//  710     constexpr bool retracted_swap[1] = { false };
//  711   #endif
//  712 #endif // FWRETRACT
//  713 
//  714 #if HAS_POWER_SWITCH
//  715   bool powersupply_on =
//  716     #if ENABLED(PS_DEFAULT_OFF)
//  717       false
//  718     #else
//  719       true
//  720     #endif
//  721   ;
//  722 #endif
//  723 
//  724 #if 1//ENABLED(DELTA)
//  725 
//  726   float delta[ABC];
delta:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
feedrate_mm_s:
        DC32 41C80000H
position_shift:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
fanSpeeds:
        DC32 0
zprobe_zoffset:
        DC8 0, 0, 0, 0
xy_probe_feedrate_mm_s:
        DC8 0, 0, 0, 0
//  727 
//  728   // Initialized by settings.load()
//  729   float delta_height,
delta_height:
        DC8 0, 0, 0, 0
//  730         delta_endstop_adj[ABC] = { 0 },
//  731         delta_radius,
//  732         delta_tower_angle_trim[ABC],
//  733         delta_tower[ABC][2],
//  734         delta_diagonal_rod,
//  735         delta_calibration_radius,
//  736         delta_diagonal_rod_2_tower[ABC],
//  737         delta_segments_per_second,
//  738         delta_clip_start_height = Z_MAX_POS;
delta_clip_start_height:
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
ubl:
        DC8 0, 0, 0, 0
//  739 
//  740   float delta_safe_distance_from_top();
//  741 
//  742 #endif
//  743 
//  744 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  745   int bilinear_grid_spacing[2], bilinear_start[2];
//  746   float bilinear_grid_factor[2],
//  747         //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
//  748         z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
//  749 #endif
//  750 
//  751 #if 1//IS_SCARA
//  752   // Float constants for SCARA calculations
//  753   const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
//  754               L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
//  755               L2_2 = sq(float(L2));
//  756 
//  757   //float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
//  758   //      delta[ABC];
//  759 #endif
//  760 
//  761 float cartes[XYZ] = { 0 };
//  762 
//  763 #if ENABLED(FILAMENT_WIDTH_SENSOR)
//  764   bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
//  765   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
//  766         filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
//  767   uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
//  768   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
//  769          filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
//  770 #endif
//  771 
//  772 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  773   static bool filament_ran_out = false;
//  774 #endif
//  775 
//  776 #if ENABLED(ADVANCED_PAUSE_FEATURE)
//  777   AdvancedPauseMenuResponse advanced_pause_menu_response;
//  778 #endif
//  779 
//  780 #if ENABLED(MIXING_EXTRUDER)
//  781   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
//  782   #if MIXING_VIRTUAL_TOOLS > 1
//  783     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
//  784   #endif
//  785 #endif
//  786 
//  787 static bool send_ok[BUFSIZE];
//  788 
//  789 #if HAS_SERVOS
//  790   Servo servo[NUM_SERVOS];
//  791   #define MOVE_SERVO(I, P) servo[I].move(P)
//  792   #if HAS_Z_SERVO_ENDSTOP
//  793     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
//  794     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
//  795   #endif
//  796 #endif
//  797 
//  798 #ifdef CHDK
//  799   millis_t chdkHigh = 0;
//  800   bool chdkActive = false;
//  801 #endif
//  802 
//  803 #if ENABLED(PID_EXTRUSION_SCALING)
//  804   int lpq_len = 20;
//  805 #endif
//  806 
//  807 #if ENABLED(HOST_KEEPALIVE_FEATURE)
//  808   MarlinBusyState busy_state = NOT_BUSY;
//  809   static millis_t next_busy_signal_ms = 0;
//  810   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
//  811 #else
//  812   #define host_keepalive() NOOP
//  813 #endif
//  814 
//  815 #if ENABLED(I2C_POSITION_ENCODERS)
//  816   I2CPositionEncodersMgr I2CPEM;
//  817   uint8_t blockBufferIndexRef = 0;
//  818   millis_t lastUpdateMillis;
//  819 #endif
//  820 
//  821 #if ENABLED(CNC_WORKSPACE_PLANES)
//  822   static WorkspacePlane workspace_plane = PLANE_XY;
//  823 #endif
//  824 
//  825 //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
//  826 //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
//  827 static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
//  828 static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
//  829 /*P
//  830 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  831   static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  832   static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \ 
//  833   typedef void __void_##CONFIG##__
//  834 */
//  835 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  836 	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  837 	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
//  838 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _Z12base_min_pos8AxisEnum
          CFI NoCalls
        THUMB
//  839 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
_Z12base_min_pos8AxisEnum:
        LDR.W    R1,??DataTable134_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+4]
        BX       LR               ;; return
          CFI EndBlock cfiBlock3

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _Z12base_max_pos8AxisEnum
          CFI NoCalls
        THUMB
//  840 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
_Z12base_max_pos8AxisEnum:
        LDR.W    R1,??DataTable134_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+16]
        BX       LR               ;; return
          CFI EndBlock cfiBlock4

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _Z13base_home_pos8AxisEnum
          CFI NoCalls
        THUMB
//  841 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
_Z13base_home_pos8AxisEnum:
        LDR.W    R1,??DataTable134_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+28]
        BX       LR               ;; return
          CFI EndBlock cfiBlock5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _Z10max_length8AxisEnum
          CFI NoCalls
        THUMB
//  842 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
_Z10max_length8AxisEnum:
        LDR.W    R1,??DataTable134_8
        ADD      R0,R1,R0, LSL #+2
        LDR      R0,[R0, #+40]
        BX       LR               ;; return
          CFI EndBlock cfiBlock6

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function _Z12home_bump_mm8AxisEnum
          CFI NoCalls
        THUMB
//  843 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
_Z12home_bump_mm8AxisEnum:
        LDR.W    R1,??DataTable137
        LDR      R0,[R1, R0, LSL #+2]
        BX       LR               ;; return
          CFI EndBlock cfiBlock7

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z8home_dir8AxisEnum
          CFI NoCalls
        THUMB
//  844 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
_Z8home_dir8AxisEnum:
        LDR.W    R1,??DataTable134_8
        LDRSB    R0,[R0, R1]
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
//  845 
//  846 /**
//  847  * ***************************************************************************
//  848  * ******************************** FUNCTIONS ********************************
//  849  * ***************************************************************************
//  850  */
//  851 
//  852 void stop();
//  853 
//  854 void get_available_commands();
//  855 void process_next_command();
//  856 void process_parsed_command();
//  857 
//  858 void get_cartesian_from_steppers();
//  859 void set_current_from_steppers_for_axis(const AxisEnum axis);
//  860 
//  861 #if ENABLED(ARC_SUPPORT)
//  862   void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
//  863 #endif
//  864 
//  865 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  866   void plan_cubic_move(const float (&offset)[4]);
//  867 #endif
//  868 
//  869 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
//  870 void report_current_position();
//  871 void report_current_position_detail();
//  872 
//  873 #if ENABLED(DEBUG_LEVELING_FEATURE)
//  874   void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
//  875     serialprintPGM(prefix);
//  876     SERIAL_CHAR('(');
//  877     SERIAL_ECHO(x);
//  878     SERIAL_ECHOPAIR(", ", y);
//  879     SERIAL_ECHOPAIR(", ", z);
//  880     SERIAL_CHAR(')');
//  881     if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
//  882   }
//  883 
//  884   void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
//  885     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
//  886   }
//  887 
//  888   #if 1//HAS_ABL
//  889     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
//  890       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
//  891     }
//  892   #endif
//  893 
//  894   #define DEBUG_POS(SUFFIX,VAR) do { \ 
//  895     print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
//  896 #endif
//  897 
//  898 /**
//  899  * sync_plan_position
//  900  *
//  901  * Set the planner/stepper positions directly from current_position with
//  902  * no kinematic translation. Used for homing axes and cartesian/core syncing.
//  903  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z18sync_plan_positionv
        THUMB
//  904 void sync_plan_position() {
//  905   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  906     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
//  907   #endif
//  908   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
_Z18sync_plan_positionv:
        LDR.W    R0,??DataTable134_4
        ADD      R3,R0,#+20
        LDR      R2,[R0, #+16]
        LDR      R1,[R0, #+12]
        LDR      R0,[R0, #+8]
          CFI FunCall _ZN7Planner15set_position_mmEfffRKf
        B.W      _ZN7Planner15set_position_mmEfffRKf
          CFI EndBlock cfiBlock9
//  909 }
//  910 inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
//  911 
//  912 //#if IS_KINEMATIC
//  913 
//  914   inline void sync_plan_position_kinematic() {
//  915     #if ENABLED(DEBUG_LEVELING_FEATURE)
//  916       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  917     #endif
//  918     planner.set_position_mm_kinematic(current_position);
//  919   }
//  920 //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
//  921 
//  922 //#else
//  923 
//  924 //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
//  925 
//  926 //#endif
//  927 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _Z28SYNC_PLAN_POSITION_KINEMATICv
        THUMB
//  928 void SYNC_PLAN_POSITION_KINEMATIC()
//  929 {
//  930 	if(MACHINETPYE & IS_KINEMATIC)
_Z28SYNC_PLAN_POSITION_KINEMATICv:
        LDR.W    R0,??DataTable134_5
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??SYNC_PLAN_POSITION_KINEMATIC_0
//  931 		sync_plan_position_kinematic();
          CFI FunCall _Z28sync_plan_position_kinematicv
        B.W      _Z28sync_plan_position_kinematicv
//  932 	else
//  933 		sync_plan_position();
??SYNC_PLAN_POSITION_KINEMATIC_0:
          CFI FunCall _Z18sync_plan_positionv
        B.N      _Z18sync_plan_positionv
          CFI EndBlock cfiBlock10
//  934 }
//  935 
//  936 #if 0//ENABLED(SDSUPPORT)
//  937   #include "SdFatUtil.h"
//  938   int freeMemory() { return SdFatUtil::FreeRam(); }
//  939 #else
//  940 /*
//  941 extern "C" {
//  942   extern char __bss_end;
//  943   extern char __heap_start;
//  944   extern void* __brkval;
//  945 
//  946   int freeMemory() {
//  947     int free_memory;
//  948     if ((int)__brkval == 0)
//  949       free_memory = ((int)&free_memory) - ((int)&__bss_end);
//  950     else
//  951       free_memory = ((int)&free_memory) - ((int)__brkval);
//  952     return free_memory;
//  953   }
//  954 }
//  955 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z10freeMemoryv
          CFI NoCalls
        THUMB
//  956 	int freeMemory() { return 4396; }	//No free ram management
_Z10freeMemoryv:
        MOVW     R0,#+4396
        BX       LR               ;; return
          CFI EndBlock cfiBlock11
//  957 
//  958 #endif // !SDSUPPORT
//  959 
//  960 #if ENABLED(DIGIPOT_I2C)
//  961   extern void digipot_i2c_set_current(uint8_t channel, float current);
//  962   extern void digipot_i2c_init();
//  963 #endif
//  964 
//  965 /**
//  966  * Inject the next "immediate" command, when possible, onto the front of the queue.
//  967  * Return true if any immediate commands remain to inject.
//  968  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function _Z25drain_injected_commands_Pv
        THUMB
//  969 static bool drain_injected_commands_P() {
_Z25drain_injected_commands_Pv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
//  970   if (injected_commands_P != NULL) {
        LDR.W    R4,??DataTable137_1
        LDR      R1,[R4, #+0]
        CMP      R1,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  971     size_t i = 0;
        MOVS     R5,#+0
//  972     char c, cmd[30];
//  973     //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
//  974     strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
        MOVS     R2,#+29
        ADD      R0,SP,#+0
          CFI FunCall strncpy
        BL       strncpy
//  975     cmd[sizeof(cmd) - 1] = '\0';
        ADD      R0,SP,#+0
        MOV      R1,R5
        STRB     R1,[R0, #+29]
        B.N      ??drain_injected_commands_P_1
//  976     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
??drain_injected_commands_P_2:
        ADDS     R5,R5,#+1
??drain_injected_commands_P_1:
        LDRSB    R6,[R5, R0]
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_3
        CMP      R6,#+10
        BNE.N    ??drain_injected_commands_P_2
//  977     cmd[i] = '\0';
??drain_injected_commands_P_3:
        STRB     R1,[R5, R0]
//  978     if (enqueue_and_echo_command(cmd))     // success?
          CFI FunCall _Z24enqueue_and_echo_commandPKcb
        BL       _Z24enqueue_and_echo_commandPKcb
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_0
//  979       injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
        CMP      R6,#+0
        BEQ.N    ??drain_injected_commands_P_4
        LDR      R0,[R4, #+0]
        ADDS     R0,R5,R0
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+0]
        B.N      ??drain_injected_commands_P_0
??drain_injected_commands_P_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+0]
//  980   }
//  981   return (injected_commands_P != NULL);    // return whether any more remain
??drain_injected_commands_P_0:
        LDR      R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??drain_injected_commands_P_5
        MOVS     R0,#+1
        B.N      ??drain_injected_commands_P_6
??drain_injected_commands_P_5:
        MOVS     R0,#+0
??drain_injected_commands_P_6:
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock12
//  982 }
//  983 
//  984 /**
//  985  * Record one or many commands to run from program memory.
//  986  * Aborts the current queue, if any.
//  987  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
//  988  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function _Z27enqueue_and_echo_commands_PPKc
        THUMB
//  989 void enqueue_and_echo_commands_P(const char * const pgcode) {
//  990   injected_commands_P = pgcode;
_Z27enqueue_and_echo_commands_PPKc:
        LDR.W    R1,??DataTable137_1
        STR      R0,[R1, #+0]
//  991   drain_injected_commands_P(); // first command executed asap (when possible)
          CFI FunCall _Z25drain_injected_commands_Pv
        B.N      _Z25drain_injected_commands_Pv
          CFI EndBlock cfiBlock13
//  992 }
//  993 
//  994 /**
//  995  * Clear the Marlin command queue
//  996  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function _Z19clear_command_queuev
          CFI NoCalls
        THUMB
//  997 void clear_command_queue() {
//  998   cmd_queue_index_r = cmd_queue_index_w;
_Z19clear_command_queuev:
        LDR.W    R0,??DataTable137_2
        LDRB     R1,[R0, #+8]
        STRB     R1,[R0, #+7]
//  999   commands_in_queue = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable134_4
        STRB     R0,[R1, #+2]
// 1000 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock14
// 1001 
// 1002 /**
// 1003  * Once a new command is in the ring buffer, call this to commit it
// 1004  */
// 1005 inline void _commit_command(bool say_ok) {
// 1006   send_ok[cmd_queue_index_w] = say_ok;
// 1007   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
// 1008   commands_in_queue++;
// 1009 }
// 1010 
// 1011 /**
// 1012  * Copy a command from RAM into the main command buffer.
// 1013  * Return true if the command was successfully added.
// 1014  * Return false for a full buffer, or if the 'command' is a comment.
// 1015  */
// 1016 inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
// 1017   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
// 1018   strcpy(command_queue[cmd_queue_index_w], cmd);
// 1019   _commit_command(say_ok);
// 1020   return true;
// 1021 }
// 1022 
// 1023 /**
// 1024  * Enqueue with Serial Echo
// 1025  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function _Z24enqueue_and_echo_commandPKcb
        THUMB
// 1026 bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
_Z24enqueue_and_echo_commandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 1027   if (_enqueuecommand(cmd, say_ok)) {
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
        CMP      R0,#+0
        BEQ.N    ??enqueue_and_echo_command_0
// 1028     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable137_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1029     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
        MOV      R1,R4
        ADR.W    R0,`?<Constant "enqueueing \\"">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
// 1030     SERIAL_CHAR('"');
        LDR.W    R4,??DataTable137_4
        MOVS     R1,#+34
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1031     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1032     return true;
        MOVS     R0,#+1
        POP      {R4,PC}
// 1033   }
// 1034   return false;
??enqueue_and_echo_command_0:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock15
// 1035 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "enqueueing \\"">`:
        DC8 "enqueueing \""
        DC8 0, 0, 0
// 1036 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function _Z13setup_killpinv
          CFI NoCalls
        THUMB
// 1037 void setup_killpin() {
// 1038   #if HAS_KILL
// 1039     SET_INPUT_PULLUP(KILL_PIN);
// 1040   #endif
// 1041 }
_Z13setup_killpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock16
// 1042 
// 1043 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 1044 
// 1045   void setup_filrunoutpin() {
// 1046     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
// 1047       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
// 1048     #else
// 1049       SET_INPUT(FIL_RUNOUT_PIN);
// 1050     #endif
// 1051   }
// 1052 
// 1053 #endif
// 1054 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function _Z15setup_powerholdv
          CFI NoCalls
        THUMB
// 1055 void setup_powerhold() {
// 1056   #if HAS_SUICIDE
// 1057     OUT_WRITE(SUICIDE_PIN, HIGH);
// 1058   #endif
// 1059   #if HAS_POWER_SWITCH
// 1060     #if ENABLED(PS_DEFAULT_OFF)
// 1061       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 1062     #else
// 1063       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
// 1064     #endif
// 1065   #endif
// 1066 }
_Z15setup_powerholdv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock17
// 1067 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function _Z7suicidev
          CFI NoCalls
        THUMB
// 1068 void suicide() {
// 1069   #if HAS_SUICIDE
// 1070     OUT_WRITE(SUICIDE_PIN, LOW);
// 1071   #endif
// 1072 }
_Z7suicidev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock18
// 1073 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function _Z10servo_initv
          CFI NoCalls
        THUMB
// 1074 void servo_init() {
// 1075   #if NUM_SERVOS >= 1 && HAS_SERVO_0
// 1076     servo[0].attach(SERVO0_PIN);
// 1077     servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
// 1078   #endif
// 1079   #if NUM_SERVOS >= 2 && HAS_SERVO_1
// 1080     servo[1].attach(SERVO1_PIN);
// 1081     servo[1].detach();
// 1082   #endif
// 1083   #if NUM_SERVOS >= 3 && HAS_SERVO_2
// 1084     servo[2].attach(SERVO2_PIN);
// 1085     servo[2].detach();
// 1086   #endif
// 1087   #if NUM_SERVOS >= 4 && HAS_SERVO_3
// 1088     servo[3].attach(SERVO3_PIN);
// 1089     servo[3].detach();
// 1090   #endif
// 1091 
// 1092   #if HAS_Z_SERVO_ENDSTOP
// 1093     /**
// 1094      * Set position of Z Servo Endstop
// 1095      *
// 1096      * The servo might be deployed and positioned too low to stow
// 1097      * when starting up the machine or rebooting the board.
// 1098      * There's no way to know where the nozzle is positioned until
// 1099      * homing has been done - no homing with z-probe without init!
// 1100      *
// 1101      */
// 1102     STOW_Z_SERVO();
// 1103   #endif
// 1104 }
_Z10servo_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock19
// 1105 
// 1106 /**
// 1107  * Stepper Reset (RigidBoard, et.al.)
// 1108  */
// 1109 #if HAS_STEPPER_RESET
// 1110   void disableStepperDrivers() {
// 1111     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
// 1112   }
// 1113   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
// 1114 #endif
// 1115 
// 1116 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 1117 
// 1118   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
// 1119     i2c.receive(bytes);
// 1120   }
// 1121 
// 1122   void i2c_on_request() {          // just send dummy data for now
// 1123     i2c.reply("Hello World!\n");
// 1124   }
// 1125 
// 1126 #endif
// 1127 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function _Z16gcode_line_errorPKcb
        THUMB
// 1128 void gcode_line_error(const char* err, bool doFlush = true) {
_Z16gcode_line_errorPKcb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1129   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable137_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1130   serialprintPGM(err);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1131   SERIAL_ERRORLN(gcode_LastN);
        LDR.W    R4,??DataTable137_4
        LDR.W    R6,??DataTable139
        MOVS     R2,#+10
        LDR      R1,[R6, #+44]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1132   //Serial.println(gcode_N);
// 1133   if (doFlush) FlushSerialRequestResend();
        CMP      R5,#+0
        BEQ.N    ??gcode_line_error_0
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
// 1134   serial_count = 0;
??gcode_line_error_0:
        MOVS     R0,#+0
        STR      R0,[R6, #+52]
// 1135 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock20
// 1136 
// 1137 uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
// 1138 
// 1139 uint8_t from_wifi_flag = 0; // whether data comes from wifi model
// 1140 
// 1141 /**
// 1142  * Get all commands waiting on the serial port and queue them.
// 1143  * Exit when the buffer is full or when no more characters are
// 1144  * left on the serial port.
// 1145  */
// 1146 inline void get_serial_commands() {
// 1147   static char serial_line_buffer[MAX_CMD_SIZE];
// 1148   static bool serial_comment_mode = false;
// 1149   static millis_t last_wait_time = 0;
// 1150   const millis_t wait_ms = millis();
// 1151 
// 1152   // If the command buffer is empty for too long,
// 1153   // send "wait" to indicate Marlin is still waiting.
// 1154   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1155     static millis_t last_command_time = 0;
// 1156     const millis_t ms = millis();
// 1157     if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
// 1158       SERIAL_ECHOLNPGM(MSG_WAIT);
// 1159       last_command_time = ms;
// 1160     }
// 1161   #endif
// 1162 #if 1
// 1163   
// 1164 	  /*5s?¨?2a2?|ì?????¨2¨oy?Y?¨°¨¨??a??¨?D¨￠a?¨2?????ê??¨|¨o1¨??wifi*/
// 1165 	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
// 1166 		if(serial_wait_tick <= 5)
// 1167 	  {
// 1168 		  serial_wait_tick ++;
// 1169 	  }
// 1170 		last_wait_time = wait_ms;
// 1171 	  }
// 1172 #endif
// 1173 
// 1174   /**
// 1175    * Loop while serial characters are incoming and the queue is not full
// 1176    */
// 1177   int c;
// 1178   while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
// 1179 
// 1180     char serial_char = c;
// 1181 	
// 1182 	serial_wait_tick = 0;
// 1183 	from_wifi_flag = 0;
// 1184 
// 1185     /**
// 1186      * If the character ends the line
// 1187      */
// 1188     if (serial_char == '\n' || serial_char == '\r') {
// 1189 
// 1190       serial_comment_mode = false;                      // end of line == end of comment
// 1191 
// 1192       if (!serial_count) continue;                      // Skip empty lines
// 1193 
// 1194       serial_line_buffer[serial_count] = 0;             // Terminate string
// 1195       serial_count = 0;                                 // Reset buffer
// 1196 
// 1197       char* command = serial_line_buffer;
// 1198 
// 1199       while (*command == ' ') command++;                // Skip leading spaces
// 1200       char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
// 1201 
// 1202       if (npos) {
// 1203 
// 1204         bool M110 = strstr_P(command, PSTR("M110")) != NULL;
// 1205 
// 1206         if (M110) {
// 1207           char* n2pos = strchr(command + 4, 'N');
// 1208           if (n2pos) npos = n2pos;
// 1209         }
// 1210 
// 1211         gcode_N = strtol(npos + 1, NULL, 10);
// 1212 
// 1213         if (gcode_N != gcode_LastN + 1 && !M110) {
// 1214           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
// 1215           return;
// 1216         }
// 1217 
// 1218         char *apos = strrchr(command, '*');
// 1219         if (apos) {
// 1220           uint8_t checksum = 0, count = uint8_t(apos - command);
// 1221           while (count) checksum ^= command[--count];
// 1222           if (strtol(apos + 1, NULL, 10) != checksum) {
// 1223             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
// 1224             return;
// 1225           }
// 1226         }
// 1227         else {
// 1228           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
// 1229           return;
// 1230         }
// 1231 
// 1232         gcode_LastN = gcode_N;
// 1233       }
// 1234 
// 1235       // Movement commands alert when stopped
// 1236       if (IsStopped()) {
// 1237         char* gpos = strchr(command, 'G');
// 1238         if (gpos) {
// 1239           const int codenum = strtol(gpos + 1, NULL, 10);
// 1240           switch (codenum) {
// 1241             case 0:
// 1242             case 1:
// 1243             case 2:
// 1244             case 3:
// 1245               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1246               LCD_MESSAGEPGM(MSG_STOPPED);
// 1247               break;
// 1248           }
// 1249         }
// 1250       }
// 1251 
// 1252       #if DISABLED(EMERGENCY_PARSER)
// 1253         // If command was e-stop process now
// 1254         if (strcmp(command, "M108") == 0) {
// 1255           wait_for_heatup = false;
// 1256           #if ENABLED(ULTIPANEL)
// 1257             wait_for_user = false;
// 1258           #endif
// 1259         }
// 1260         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1261         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1262       #endif
// 1263 
// 1264       #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1265         last_command_time = ms;
// 1266       #endif
// 1267 
// 1268       // Add the command to the queue
// 1269       _enqueuecommand(serial_line_buffer, true);
// 1270     }
// 1271     else if (serial_count >= MAX_CMD_SIZE - 1) {
// 1272       // Keep fetching, but ignore normal characters beyond the max length
// 1273       // The command will be injected when EOL is reached
// 1274     }
// 1275     else if (serial_char == '\\') {  // Handle escapes
// 1276       if ((c = MYSERIAL.read()) >= 0) {
// 1277         // if we have one more character, copy it over
// 1278         serial_char = c;
// 1279         if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1280       }
// 1281       // otherwise do nothing
// 1282     }
// 1283     else { // it's not a newline, carriage return or escape char
// 1284       if (serial_char == ';') serial_comment_mode = true;
// 1285       if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1286     }
// 1287 
// 1288   } // queue has space, serial has data
// 1289 }
// 1290 
// 1291 #if ENABLED(SDSUPPORT)
// 1292 
// 1293 uint8_t sd_read_error_flg=0;
// 1294 uint8_t sd_read_cnt=0;
// 1295 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function _Z16display_sd_errorv
        THUMB
// 1296 void display_sd_error()
// 1297 {
_Z16display_sd_errorv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
// 1298   char buf_sd_err[30]={0};
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 1299   
// 1300   if(sd_read_error_flg == 1)
        LDR.W    R4,??DataTable137_2
        LDRB     R0,[R4, #+9]
        CMP      R0,#+1
        BNE.N    ??display_sd_error_0
// 1301   {
// 1302       GUI_SetBkColor(gCfgItems.background_color);
        LDR.W    R5,??DataTable139_1
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 1303       GUI_SetColor(0X0000ff);//   oìé?×?ì?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 1304       //memset(buf_sd_err,' ',sizeof(buf_sd_err)-1);
// 1305       //GUI_DispStringAt(buf_sd_err,250, TITLE_YPOS);
// 1306       sprintf(buf_sd_err,"sd:%d",sd_read_cnt);
        LDRB     R2,[R4, #+10]
        ADR.W    R1,`?<Constant "sd:%d">`
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
// 1307       GUI_DispStringAt(buf_sd_err,400, TITLE_YPOS);
        MOVS     R2,#+5
        MOV      R1,#+400
        ADD      R0,SP,#+0
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1308       GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 1309       GUI_SetColor(gCfgItems.title_color);            
        LDR      R0,[R5, #+8]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 1310   }
// 1311 }
??display_sd_error_0:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock21

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "sd:%d">`:
        DC8 "sd:%d"
        DC8 0, 0
// 1312 
// 1313 
// 1314   /**
// 1315    * Get commands from the SD Card until the command buffer is full
// 1316    * or until the end of the file is reached. The special character '#'
// 1317    * can also interrupt buffering.
// 1318    */
// 1319   inline void get_sdcard_commands() {
// 1320     static bool stop_buffering = false,
// 1321                 sd_comment_mode = false;
// 1322 
// 1323     if (!card.sdprinting) return;
// 1324 
// 1325     /**
// 1326      * '#' stops reading from SD to the buffer prematurely, so procedural
// 1327      * macro calls are possible. If it occurs, stop_buffering is triggered
// 1328      * and the buffer is run dry; this character _can_ occur in serial com
// 1329      * due to checksums, however, no checksums are used in SD printing.
// 1330      */
// 1331 
// 1332     if (commands_in_queue == 0) stop_buffering = false;
// 1333 
// 1334     uint16_t sd_count = 0;
// 1335     bool card_eof = card.eof();
// 1336     while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
// 1337       const int16_t n = card.get();
// 1338       char sd_char = (char)n;
// 1339       card_eof = card.eof();
// 1340       if (card_eof || n == -1
// 1341           || sd_char == '\n' || sd_char == '\r'
// 1342           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
// 1343       ) {
// 1344         if (card_eof) {
// 1345           gCfgItems.breakpoint_reprint_flg = 0;
// 1346           gCfgItems.breakpoint_z_pos = 0;
// 1347           gCfgItems.breakpoint_flg=0;
// 1348 
// 1349           card.printingHasFinished();
// 1350 
// 1351           if (card.sdprinting)
// 1352             sd_count = 0; // If a sub-file was printing, continue from call point
// 1353           else {
// 1354             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
// 1355             #if ENABLED(PRINTER_EVENT_LEDS)
// 1356               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
// 1357               leds.set_green();
// 1358               #if HAS_RESUME_CONTINUE
// 1359                 enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
// 1360               #else
// 1361                 safe_delay(1000);
// 1362               #endif
// 1363               leds.set_off();
// 1364             #endif
// 1365             card.checkautostart(true);
// 1366 			
// 1367 			#if 1
// 1368 			
// 1369 			
// 1370 			//′òíê1??ú?￡
// 1371 			//if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
// 1372 			//    Close_machine_display();
// 1373 
// 1374             #endif 				
// 1375           }
// 1376         }
// 1377         else if (n == -1) {
// 1378           SERIAL_ERROR_START();
// 1379           SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
// 1380           //sd_count++;
// 1381           //card.cardOK=false;
// 1382           //commands_in_queue+=1;
// 1383           //sdpos_bak=card.sdpos;
// 1384           //card.sdprinting=false;
// 1385           SD_Init();
// 1386           card.initsd();
// 1387           if(card.reopenfile(curFileName))
// 1388           {
// 1389             card.setIndex(card.sdpos);
// 1390           }
// 1391           memset(command_queue[cmd_queue_index_w],0,sizeof(command_queue[cmd_queue_index_w]));
// 1392           //GUI_TOUCH_Exec(); 	  
// 1393           //GUI_Exec();
// 1394          #if 1
// 1395 	  thermalManager.manage_heater();
// 1396 	  
// 1397 	  display_temper_error();
// 1398 	  
// 1399 	  //wifi_looping();
// 1400 	  
// 1401 	  if(wifi_link_state != WIFI_TRANS_FILE)
// 1402 	  {
// 1403 		  GUI_RefreshPage();
// 1404 	  }
// 1405 	  #if defined(TFT70)
// 1406 	  disp_pre_gcode(3,40);
// 1407 	  #elif defined(TFT35)
// 1408 	  //#if defined(MKS_ROBIN2)
// 1409 	  if(preview_no_display != 1)
// 1410 	  {
// 1411 		  disp_pre_gcode(2,36);
// 1412 	  }
// 1413 	  //#endif
// 1414 	  #endif
// 1415 	  
// 1416 	  GUI_TOUCH_Exec(); 	  
// 1417 	  GUI_Exec(); 
// 1418 
// 1419 	#endif
// 1420 
// 1421           sd_read_error_flg=1;
// 1422           sd_read_cnt++;
// 1423         }
// 1424         if (sd_char == '#') stop_buffering = true;
// 1425 
// 1426         sd_comment_mode = false; // for new command
// 1427 
// 1428         if (!sd_count) continue; // skip empty lines (and comment lines)
// 1429 
// 1430         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
// 1431         sd_count = 0; // clear sd line buffer
// 1432 
// 1433         _commit_command(false);
// 1434       }
// 1435       else if (sd_count >= MAX_CMD_SIZE - 1) {
// 1436         /**
// 1437          * Keep fetching, but ignore normal characters beyond the max length
// 1438          * The command will be injected when EOL is reached
// 1439          */
// 1440       }
// 1441       else {
// 1442         if (sd_char == ';') sd_comment_mode = true;
// 1443         //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1444         if (!sd_comment_mode) 
// 1445         {
// 1446 			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1447 			if(sd_char == 0x5a ) //"Z"
// 1448 			{
// 1449 				mksReprint.sdpos = card.getsdpos()-3;	//"・?2?????"
// 1450 				#if 1
// 1451 				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bakμ?èY??μ?￡????′ê1ó?
// 1452 				if(gCfgItems.pwroff_save_mode != 1)//sd?¨±￡′???μ?êy?Y
// 1453                 #endif
// 1454 					mksReprint.refresh = true;
// 1455 			}
// 1456         }        
// 1457       }
// 1458     }
// 1459   }
// 1460 
// 1461 #endif // SDSUPPORT
// 1462 #if 1
// 1463 inline void get_wifi_commands() {
// 1464   static char wifi_line_buffer[MAX_CMD_SIZE];
// 1465   static bool wifi_comment_mode = false;
// 1466 
// 1467   if(serial_wait_tick > 5)
// 1468   {
// 1469   	from_wifi_flag = 1;
// 1470 
// 1471 /**
// 1472 	   * Loop while serial characters are incoming and the queue is not full
// 1473 	   */
// 1474 	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
// 1475 
// 1476 	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
// 1477 
// 1478 	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
// 1479 
// 1480 	    /**
// 1481 	     * If the character ends the line
// 1482 	     */
// 1483 	    if (wifi_char == '\n' || wifi_char == '\r') {
// 1484 
// 1485 	      wifi_comment_mode = false; // end of line == end of comment
// 1486 
// 1487 	      if (!wifi_read_count) continue; // skip empty lines
// 1488 
// 1489 	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
// 1490 	      wifi_read_count = 0; //reset buffer
// 1491 
// 1492 	      char* command = wifi_line_buffer;
// 1493 
// 1494 	      while (*command == ' ') command++; // skip any leading spaces	    
// 1495 
// 1496 	      // Movement commands alert when stopped
// 1497 	      if (IsStopped()) {
// 1498 	        char* gpos = strchr(command, 'G');
// 1499 	        if (gpos) {
// 1500 	          const int codenum = strtol(gpos + 1, NULL, 10);
// 1501 	          switch (codenum) {
// 1502 	            case 0:
// 1503 	            case 1:
// 1504 	            case 2:
// 1505 	            case 3:
// 1506 	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1507 	              LCD_MESSAGEPGM(MSG_STOPPED);
// 1508 	              break;
// 1509 	          }
// 1510 	        }
// 1511 	      }
// 1512 
// 1513 	      #if DISABLED(EMERGENCY_PARSER)
// 1514 	        // If command was e-stop process now
// 1515 	        if (strcmp(command, "M108") == 0) {
// 1516 	          wait_for_heatup = false;
// 1517 	          #if ENABLED(ULTIPANEL)
// 1518 	            wait_for_user = false;
// 1519 	          #endif
// 1520 	        }
// 1521 	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1522 	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1523 	      #endif
// 1524 
// 1525 	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1526 	        last_command_time = ms;
// 1527 	      #endif
// 1528 
// 1529 	      // Add the command to the queue
// 1530 	      _enqueuecommand(wifi_line_buffer, true);
// 1531 	    }
// 1532 	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
// 1533 	      // Keep fetching, but ignore normal characters beyond the max length
// 1534 	      // The command will be injected when EOL is reached
// 1535 	    }
// 1536 		/*
// 1537 	    else if (wifi_char == '\\') {  // Handle escapes
// 1538 	      if (MYSERIAL.available() > 0) {
// 1539 	        // if we have one more character, copy it over
// 1540 	        wifi_char = MYSERIAL.read();
// 1541 	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1542 	      }
// 1543 	      // otherwise do nothing
// 1544 	    }*/
// 1545 	    else { // it's not a newline, carriage return or escape char
// 1546 	      if (wifi_char == ';') wifi_comment_mode = true;
// 1547 	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
// 1548 	    }
// 1549 
// 1550 	  }
// 1551     }// queue has space, serial has data
// 1552     else
// 1553     {
// 1554     	from_wifi_flag = 0;
// 1555     }
// 1556 }
// 1557 #endif
// 1558 
// 1559 /**
// 1560  * Add to the circular command queue the next command from:
// 1561  *  - The command-injection queue (injected_commands_P)
// 1562  *  - The active serial input (usually USB)
// 1563  *  - The SD card file being actively printed
// 1564  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function _Z22get_available_commandsv
        THUMB
// 1565 void get_available_commands() {
_Z22get_available_commandsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1566 
// 1567   // if any immediate commands remain, don't get other commands yet
// 1568   if (drain_injected_commands_P()) return;
          CFI FunCall _Z25drain_injected_commands_Pv
        BL       _Z25drain_injected_commands_Pv
        CMP      R0,#+0
        BNE.N    ??get_available_commands_0
// 1569 
// 1570   get_serial_commands();
          CFI FunCall _Z19get_serial_commandsv
        BL       _Z19get_serial_commandsv
// 1571   
// 1572 #if 1
// 1573 	get_wifi_commands();
          CFI FunCall _Z17get_wifi_commandsv
        BL       _Z17get_wifi_commandsv
// 1574 #endif
// 1575 
// 1576   #if ENABLED(SDSUPPORT)
// 1577     get_sdcard_commands();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19get_sdcard_commandsv
        B.W      _Z19get_sdcard_commandsv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_commands_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock22
// 1578   #endif
// 1579 }
// 1580 
// 1581 /**
// 1582  * Set target_extruder from the T parameter or the active_extruder
// 1583  *
// 1584  * Returns TRUE if the target is invalid
// 1585  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function _Z32get_target_extruder_from_commandt
        THUMB
// 1586 bool get_target_extruder_from_command(const uint16_t code) {
_Z32get_target_extruder_from_commandt:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1587   if (parser.seenval('T')) {
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??get_target_extruder_from_command_0
// 1588     const int8_t e = parser.value_byte();
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R5,R0
        SXTB     R5,R5
// 1589     if (e >= EXTRUDERS) {
        CMP      R5,#+2
        BLT.N    ??get_target_extruder_from_command_1
// 1590       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable137_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1591       SERIAL_CHAR('M');
        LDR.W    R6,??DataTable137_4
        MOVS     R1,#+77
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1592       SERIAL_ECHO(code);
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R6
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 1593       SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
        MOV      R1,R5
        ADR.W    R0,`?<Constant " Invalid extruder ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1594       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 1595     }
// 1596     target_extruder = e;
??get_target_extruder_from_command_1:
        LDR.W    R0,??DataTable134_4
        STRB     R5,[R0, #+5]
        B.N      ??get_target_extruder_from_command_2
// 1597   }
// 1598   else
// 1599     target_extruder = active_extruder;
??get_target_extruder_from_command_0:
        LDR.W    R0,??DataTable134_4
        LDRB     R1,[R0, #+3]
        STRB     R1,[R0, #+5]
// 1600 
// 1601   return false;
??get_target_extruder_from_command_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock23
// 1602 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Invalid extruder ">`:
        DC8 " Invalid extruder "
        DC8 0
// 1603 
// 1604 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 1605   bool extruder_duplication_enabled = false; // Used in Dual X mode 2
// 1606 #endif
// 1607 
// 1608 #if ENABLED(DUAL_X_CARRIAGE)
// 1609 
// 1610   static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 1611 
// 1612   static float x_home_pos(const int extruder) {
// 1613     if (extruder == 0)
// 1614       return base_home_pos(X_AXIS);
// 1615     else
// 1616       /**
// 1617        * In dual carriage mode the extruder offset provides an override of the
// 1618        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
// 1619        * This allows soft recalibration of the second extruder home position
// 1620        * without firmware reflash (through the M218 command).
// 1621        */
// 1622       return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
// 1623   }
// 1624 
// 1625   static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
// 1626 
// 1627   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
// 1628   static bool active_extruder_parked = false;        // used in mode 1 & 2
// 1629   static float raised_parked_position[XYZE];         // used in mode 1
// 1630   static millis_t delayed_move_time = 0;             // used in mode 1
// 1631   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
// 1632   static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
// 1633 
// 1634 #endif // DUAL_X_CARRIAGE
// 1635 
// 1636 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 1637 
// 1638   /**
// 1639    * Software endstops can be used to monitor the open end of
// 1640    * an axis that has a hardware endstop on the other end. Or
// 1641    * they can prevent axes from moving past endstops and grinding.
// 1642    *
// 1643    * To keep doing their job as the coordinate system changes,
// 1644    * the software endstop positions must be refreshed to remain
// 1645    * at the same positions relative to the machine.
// 1646    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function _Z24update_software_endstops8AxisEnum
        THUMB
// 1647   void update_software_endstops(const AxisEnum axis) {
_Z24update_software_endstops8AxisEnum:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R6,R0
// 1648     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
// 1649       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
        MOV      R7,R6
        LDR.W    R4,??DataTable134_4
        ADD      R8,R4,R7, LSL #+2
        LDR.W    R0,??DataTable137_2
        ADD      R0,R0,R7, LSL #+2
        LDR      R1,[R0, #+48]
        LDR      R0,[R8, #+96]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R8, #+56]
// 1650     #endif
// 1651 
// 1652     #if ENABLED(DUAL_X_CARRIAGE)
// 1653       if (axis == X_AXIS) {
// 1654 
// 1655         // In Dual X mode hotend_offset[X] is T1's home position
// 1656         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
// 1657 
// 1658         if (active_extruder != 0) {
// 1659           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
// 1660           soft_endstop_min[X_AXIS] = X2_MIN_POS;
// 1661           soft_endstop_max[X_AXIS] = dual_max_x;
// 1662         }
// 1663         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
// 1664           // In Duplication Mode, T0 can move as far left as X_MIN_POS
// 1665           // but not so far to the right that T1 would move past the end
// 1666           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
// 1667           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
// 1668         }
// 1669         else {
// 1670           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
// 1671           soft_endstop_min[axis] = base_min_pos(axis);
// 1672           soft_endstop_max[axis] = base_max_pos(axis);
// 1673         }
// 1674       }
// 1675 	#else
// 1676     if (MACHINETPYE == DELTA)//ENABLED(DELTA)
        LDR.W    R5,??DataTable134_9
        LDR.W    R9,??DataTable134_5
        LDRSH    R0,[R9, #+88]
        CMP      R0,#+2
        MOV      R0,R6
        BNE.N    ??update_software_endstops_0
// 1677     {
// 1678       soft_endstop_min[axis] = base_min_pos(axis);
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        STR      R0,[R8, #+68]
// 1679       soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
        CMP      R7,#+2
        BNE.N    ??update_software_endstops_1
        LDR      R0,[R4, #+120]
        B.N      ??update_software_endstops_2
??update_software_endstops_1:
        MOV      R0,R6
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
??update_software_endstops_2:
        ADD      R1,R5,R7, LSL #+2
        STR      R0,[R1, #+36]
        B.N      ??update_software_endstops_3
// 1680     }
// 1681     else
// 1682     {
// 1683       soft_endstop_min[axis] = base_min_pos(axis);
??update_software_endstops_0:
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        STR      R0,[R8, #+68]
// 1684       soft_endstop_max[axis] = base_max_pos(axis);
        MOV      R0,R6
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
        ADD      R1,R5,R7, LSL #+2
        STR      R0,[R1, #+36]
// 1685     }
// 1686     #endif
// 1687 
// 1688     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1689       if (DEBUGGING(LEVELING)) {
// 1690         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
// 1691         #if HAS_HOME_OFFSET
// 1692           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
// 1693         #endif
// 1694         #if HAS_POSITION_SHIFT
// 1695           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
// 1696         #endif
// 1697         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
// 1698         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
// 1699       }
// 1700     #endif
// 1701 
// 1702     //#if ENABLED(DELTA)
// 1703     if(MACHINETPYE == DELTA)
??update_software_endstops_3:
        LDRSH    R0,[R9, #+88]
        CMP      R0,#+2
        BNE.N    ??update_software_endstops_4
// 1704     {
// 1705       switch(axis) {
        CMP      R6,#+0
        BEQ.N    ??update_software_endstops_5
        CMP      R6,#+2
        BEQ.N    ??update_software_endstops_6
        BCS.N    ??update_software_endstops_4
// 1706         case X_AXIS:
// 1707         case Y_AXIS:
// 1708           // Get a minimum radius for clamping
// 1709           soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
??update_software_endstops_5:
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_7
        MOV      R1,R0
??update_software_endstops_7:
        BIC      R0,R1,#0x80000000
        LDR      R2,[R5, #+36]
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_8
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_9
        MOV      R1,R0
??update_software_endstops_9:
        BIC      R2,R1,#0x80000000
??update_software_endstops_8:
        LDR      R1,[R5, #+40]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_10
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_11
        MOV      R1,R0
??update_software_endstops_11:
        BIC      R0,R1,#0x80000000
        LDR      R1,[R5, #+36]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_12
        LDR      R1,[R4, #+68]
        LDR      R0,[R4, #+72]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??update_software_endstops_13
        MOV      R1,R0
??update_software_endstops_13:
        BIC      R0,R1,#0x80000000
        STR      R0,[R5, #+84]
        B.N      ??update_software_endstops_14
??update_software_endstops_12:
        STR      R1,[R5, #+84]
        B.N      ??update_software_endstops_14
??update_software_endstops_10:
        STR      R1,[R5, #+84]
// 1710           soft_endstop_radius_2 = sq(soft_endstop_radius);
??update_software_endstops_14:
        LDR      R4,[R5, #+84]
        MOVS     R6,#+2
        MOV      R7,#+1065353216
        B.N      ??update_software_endstops_15
??update_software_endstops_16:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??update_software_endstops_15:
        LSLS     R0,R6,#+31
        BPL.N    ??update_software_endstops_17
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??update_software_endstops_17:
        LSRS     R6,R6,#+1
        BNE.N    ??update_software_endstops_16
        STR      R7,[R5, #+88]
// 1711           break;
        B.N      ??update_software_endstops_4
// 1712         case Z_AXIS:
// 1713           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
??update_software_endstops_6:
          CFI FunCall _Z28delta_safe_distance_from_topv
        BL       _Z28delta_safe_distance_from_topv
        MOV      R1,R0
        LDR      R0,[R5, #+44]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+124]
// 1714         default: break;
// 1715       }
// 1716     }
// 1717     //#endif
// 1718   }
??update_software_endstops_4:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock24
// 1719 
// 1720 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
// 1721 
// 1722 #if 1//HAS_M206_COMMAND
// 1723   /**
// 1724    * Change the home offset for an axis, update the current
// 1725    * position and the software endstops to retain the same
// 1726    * relative distance to the new home.
// 1727    *
// 1728    * Since this changes the current_position, code should
// 1729    * call sync_plan_position soon after this.
// 1730    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI Function _Z15set_home_offset8AxisEnumf
        THUMB
// 1731   static void set_home_offset(const AxisEnum axis, const float v) {
// 1732 
// 1733   	if(MACHINETPYE == DELTA)	return;
_Z15set_home_offset8AxisEnumf:
        LDR.W    R2,??DataTable134_5
        LDRSH    R2,[R2, #+88]
        CMP      R2,#+2
        BEQ.N    ??set_home_offset_0
// 1734 	
// 1735     home_offset[axis] = v;
        LDR.W    R2,??DataTable137_2
        ADD      R2,R2,R0, LSL #+2
        STR      R1,[R2, #+48]
// 1736     update_software_endstops(axis);
          CFI FunCall _Z24update_software_endstops8AxisEnum
        B.N      _Z24update_software_endstops8AxisEnum
??set_home_offset_0:
        BX       LR               ;; return
          CFI EndBlock cfiBlock25
// 1737   }
// 1738 #endif // HAS_M206_COMMAND
// 1739 
// 1740 /**
// 1741  * Set an axis' current position to its home position (after homing).
// 1742  *
// 1743  * For Core and Cartesian robots this applies one-to-one when an
// 1744  * individual axis has been homed.
// 1745  *
// 1746  * DELTA should wait until all homing is done before setting the XYZ
// 1747  * current_position to home, because homing is a single operation.
// 1748  * In the case where the axis positions are already known and previously
// 1749  * homed, DELTA could home to X or Y individually by moving either one
// 1750  * to the center. However, homing Z always homes XY and Z.
// 1751  *
// 1752  * SCARA should wait until all XY homing is done before setting the XY
// 1753  * current_position to home, because neither X nor Y is at home until
// 1754  * both are at home. Z can however be homed individually.
// 1755  *
// 1756  * Callers must sync the planner position after calling this!
// 1757  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function _Z19set_axis_is_at_home8AxisEnum
        THUMB
// 1758 static void set_axis_is_at_home(const AxisEnum axis) {
_Z19set_axis_is_at_home8AxisEnum:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R4,R0
// 1759   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1760     if (DEBUGGING(LEVELING)) {
// 1761       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
// 1762       SERIAL_CHAR(')');
// 1763       SERIAL_EOL();
// 1764     }
// 1765   #endif
// 1766 
// 1767   axis_known_position[axis] = axis_homed[axis] = true;
        MOV      R5,R4
        LDR.W    R6,??DataTable134_9
        MOVS     R0,#+1
        STRB     R0,[R5, R6]
        ADDS     R1,R5,R6
        STRB     R0,[R1, #+4]
// 1768 
// 1769   #if HAS_POSITION_SHIFT
// 1770     position_shift[axis] = 0;
        LDR.W    R7,??DataTable134_4
        ADD      R8,R7,R5, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R8, #+96]
// 1771     update_software_endstops(axis);
        MOV      R0,R4
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 1772   #endif
// 1773 
// 1774   #if ENABLED(DUAL_X_CARRIAGE)
// 1775     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
// 1776       current_position[X_AXIS] = x_home_pos(active_extruder);
// 1777       return;
// 1778     }
// 1779   #endif
// 1780 
// 1781   //#if ENABLED(MORGAN_SCARA)
// 1782   if(MACHINETPYE&MORGAN_SCARA)
        LDR.W    R9,??DataTable134_5
        LDRSH    R0,[R9, #+88]
        LSLS     R1,R0,#+23
        BPL.N    ??set_axis_is_at_home_0
// 1783   	{
// 1784     /**
// 1785      * Morgan SCARA homes XY at the same time
// 1786      */
// 1787     if (axis == X_AXIS || axis == Y_AXIS) {
        CMP      R4,#+0
        BEQ.N    ??set_axis_is_at_home_1
        CMP      R5,#+1
        BNE.N    ??set_axis_is_at_home_2
// 1788 
// 1789       float homeposition[XYZ] = {
??set_axis_is_at_home_1:
        MOVS     R0,#+0
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[SP, #+0]
        ADD      R10,SP,#+0
        MOVS     R0,#+1
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R10, #+4]
        MOVS     R0,#+2
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R10, #+8]
// 1790         base_home_pos(X_AXIS),
// 1791         base_home_pos(Y_AXIS),
// 1792         base_home_pos(Z_AXIS)
// 1793       };
// 1794 
// 1795       // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
// 1796       // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
// 1797 
// 1798       /**
// 1799        * Get Home position SCARA arm angles using inverse kinematics,
// 1800        * and calculate homing offset using forward kinematics
// 1801        */
// 1802       inverse_kinematics_MORGAN_SCARA(homeposition);
        ADD      R0,SP,#+0
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
// 1803       forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
        ADD      R1,R7,#+84
        ADD      R0,R7,#+80
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 1804 
// 1805       // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
// 1806       // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
// 1807 
// 1808       current_position[axis] = cartes[axis];
        ADD      R6,R6,R5, LSL #+2
        LDR      R0,[R6, #+72]
        STR      R0,[R8, #+8]
// 1809 
// 1810       /**
// 1811        * SCARA home positions are based on configuration since the actual
// 1812        * limits are determined by the inverse kinematic transform.
// 1813        */
// 1814       soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        MOV      R0,R4
          CFI FunCall _Z12base_min_pos8AxisEnum
        BL       _Z12base_min_pos8AxisEnum
        STR      R0,[R8, #+68]
// 1815       soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        MOV      R0,R4
          CFI FunCall _Z12base_max_pos8AxisEnum
        BL       _Z12base_max_pos8AxisEnum
        STR      R0,[R6, #+36]
        B.N      ??set_axis_is_at_home_3
// 1816     }
// 1817     else
// 1818 	{
// 1819 	    current_position[axis] = base_home_pos(axis);
??set_axis_is_at_home_2:
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_3
// 1820 	}		
// 1821   	}
// 1822   //#elif ENABLED(DELTA)
// 1823   else if(MACHINETPYE&DELTA)
??set_axis_is_at_home_0:
        LSLS     R0,R0,#+30
        BPL.N    ??set_axis_is_at_home_4
// 1824   {
// 1825     if (axis == Z_AXIS)
        CMP      R5,#+2
        BNE.N    ??set_axis_is_at_home_5
// 1826       current_position[axis] = delta_height;
        LDR      R0,[R7, #+120]
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_3
// 1827     else
// 1828   //#endif
// 1829   	{
// 1830     	current_position[axis] = base_home_pos(axis);
??set_axis_is_at_home_5:
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R8, #+8]
        B.N      ??set_axis_is_at_home_3
// 1831   	}
// 1832   }
// 1833   else
// 1834   {
// 1835     	current_position[axis] = base_home_pos(axis);
??set_axis_is_at_home_4:
        MOV      R0,R4
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        STR      R0,[R8, #+8]
// 1836   }    
// 1837   /**
// 1838    * Z Probe Z Homing? Account for the probe's Z offset.
// 1839    */
// 1840   #if HAS_BED_PROBE //&& Z_HOME_DIR < 0
// 1841   if(Z_HOME_DIR < 0)
??set_axis_is_at_home_3:
        LDRSB    R0,[R9, #+7]
        CMP      R0,#+0
        BPL.N    ??set_axis_is_at_home_6
// 1842   {
// 1843     if (axis == Z_AXIS) {
        CMP      R5,#+2
        BNE.N    ??set_axis_is_at_home_6
// 1844       #if HOMING_Z_WITH_PROBE
// 1845 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
        LDRB     R0,[R9, #+153]
        CMP      R0,#+1
        BNE.N    ??set_axis_is_at_home_7
// 1846 	  {
// 1847         current_position[Z_AXIS] -= zprobe_zoffset;
        LDR      R0,[R7, #+16]
        LDR      R1,[R7, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R7, #+16]
        B.N      ??set_axis_is_at_home_6
// 1848 
// 1849         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1850           if (DEBUGGING(LEVELING)) {
// 1851             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
// 1852             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
// 1853           }
// 1854         #endif
// 1855 	  }
// 1856 	  else
// 1857 	  {
// 1858 		  if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");	  
??set_axis_is_at_home_7:
        LDRB     R0,[R7, #+1]
        LSLS     R0,R0,#+26
        BPL.N    ??set_axis_is_at_home_6
        ADR.W    R0,`?<Constant "*** Z HOMED TO ENDSTO...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1859 	  }
// 1860       #elif ENABLED(DEBUG_LEVELING_FEATURE)
// 1861 
// 1862         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
// 1863 
// 1864       #endif
// 1865     }
// 1866   }
// 1867   #endif
// 1868 
// 1869   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1870     if (DEBUGGING(LEVELING)) {
// 1871       #if HAS_HOME_OFFSET
// 1872         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
// 1873         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
// 1874       #endif
// 1875       DEBUG_POS("", current_position);
// 1876       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
// 1877       SERIAL_CHAR(')');
// 1878       SERIAL_EOL();
// 1879     }
// 1880   #endif
// 1881 
// 1882   #if ENABLED(I2C_POSITION_ENCODERS)
// 1883     I2CPEM.homed(axis);
// 1884   #endif
// 1885 }
??set_axis_is_at_home_6:
        POP      {R0-R10,PC}      ;; return
          CFI EndBlock cfiBlock26

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "*** Z HOMED TO ENDSTO...">`:
        DC8 "*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***\012"
        DC8 0, 0
// 1886 
// 1887 /**
// 1888  * Some planner shorthand inline functions
// 1889  */
// 1890 inline float get_homing_bump_feedrate(const AxisEnum axis) {
// 1891   //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
// 1892 	int  homing_bump_divisor[4];
// 1893 	if(MACHINETPYE == DELTA)
// 1894 	{
// 1895 		homing_bump_divisor[0] = 10;
// 1896 		homing_bump_divisor[1] = 10;
// 1897 		homing_bump_divisor[2] = 10;
// 1898 	}
// 1899 	else
// 1900 	{
// 1901 		homing_bump_divisor[0] = 2;
// 1902 		homing_bump_divisor[1] = 2;
// 1903 		homing_bump_divisor[2] = 4;
// 1904 	}  
// 1905   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
// 1906   if (hbd < 1) {
// 1907     hbd = 10;
// 1908     SERIAL_ECHO_START();
// 1909     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
// 1910   }
// 1911   //return homing_feedrate(axis) / hbd;
// 1912   return homing_feedrate_mm_s[axis] / hbd;
// 1913 }
// 1914 
// 1915 /**
// 1916  * Move the planner to the current position from wherever it last moved
// 1917  * (or from wherever it has been told it is located).
// 1918  */
// 1919 inline void buffer_line_to_current_position() {
// 1920   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
// 1921 }
// 1922 
// 1923 /**
// 1924  * Move the planner to the position stored in the destination array, which is
// 1925  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
// 1926  */
// 1927 inline void buffer_line_to_destination(const float fr_mm_s) {
// 1928   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
// 1929 }
// 1930 
// 1931 #if 1//IS_KINEMATIC
// 1932   /**
// 1933    * Calculate delta, start a line, and set current_position to destination
// 1934    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function _Z42prepare_uninterpolated_move_to_destinationf
        THUMB
// 1935   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
_Z42prepare_uninterpolated_move_to_destinationf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1936     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1937       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
// 1938     #endif
// 1939 
// 1940     refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 1941 
// 1942     #if UBL_SEGMENTED
// 1943       // ubl segmented line will do z-only moves in single segment
// 1944       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
// 1945     #else
// 1946       if ( current_position[X_AXIS] == destination[X_AXIS]
// 1947         && current_position[Y_AXIS] == destination[Y_AXIS]
// 1948         && current_position[Z_AXIS] == destination[Z_AXIS]
// 1949         && current_position[E_AXIS] == destination[E_AXIS]
// 1950       ) return;
        LDR.W    R5,??DataTable134_4
        LDR      R0,[R5, #+8]
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+12]
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+16]
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+20]
        LDR      R1,[R5, #+36]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_uninterpolated_move_to_destination_1
// 1951 
// 1952       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
??prepare_uninterpolated_move_to_destination_0:
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_2
        LDR      R4,[R5, #+92]
??prepare_uninterpolated_move_to_destination_2:
        LDRSH    R0,[R5, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable143  ;; 0x47ae147b
        LDR.W    R3,??DataTable144  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        LDRB     R2,[R5, #+3]
        ADD      R1,SP,#+0
        ADD      R0,R5,#+24
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 1953     #endif
// 1954 
// 1955     set_current_from_destination();
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 1956   }
??prepare_uninterpolated_move_to_destination_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock27
// 1957 #endif // IS_KINEMATIC
// 1958 
// 1959 /**
// 1960  *  Plan a move to (X, Y, Z) and set the current_position
// 1961  *  The final current_position may not be the one that was requested
// 1962  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function _Z19do_blocking_move_toRKfS0_S0_S0_
        THUMB
// 1963 void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z19do_blocking_move_toRKfS0_S0_S0_:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R7,R0
        MOV      R8,R1
        MOV      R4,R2
        MOV      R9,R3
// 1964   const float old_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R5,??DataTable134_4
        LDR      R6,[R5, #+92]
// 1965 
// 1966   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1967     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1968   #endif
// 1969 
// 1970   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        LDR      R10,[R9, #+0]
        MOV      R0,R10
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_0
        LDR      R10,[R5, #+48]
??do_blocking_move_to_0:
        LDR.W    R0,??DataTable134_5
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??do_blocking_move_to_1
// 1971 
// 1972   //#if ENABLED(DELTA)
// 1973   if(MACHINETPYE == DELTA)
// 1974   {
// 1975     if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
        MOV      R1,R8
        MOV      R0,R7
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.W    ??do_blocking_move_to_2
// 1976 
// 1977     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_3
        STR      R2,[R5, #+92]
        B.N      ??do_blocking_move_to_4
??do_blocking_move_to_3:
        LDR      R0,[R5, #+116]
        STR      R0,[R5, #+92]
// 1978 
// 1979     set_destination_from_current();          // sync destination at the start
??do_blocking_move_to_4:
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
// 1980 
// 1981     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1982       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1983     #endif
// 1984 
// 1985     // when in the danger zone
// 1986     if (current_position[Z_AXIS] > delta_clip_start_height) {
        LDR      R0,[R5, #+124]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_5
// 1987       if (rz > delta_clip_start_height) {   // staying in the danger zone
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_6
// 1988         destination[X_AXIS] = rx;           // move directly (uninterpolated)
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+24]
// 1989         destination[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+28]
// 1990         destination[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+32]
// 1991         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
        MOVS     R0,#+0
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.N      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
// 1992         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1993           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1994         #endif
// 1995         return;
// 1996       }
// 1997       destination[Z_AXIS] = delta_clip_start_height;
??do_blocking_move_to_6:
        STR      R0,[R5, #+32]
// 1998       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 1999       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2000         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 2001       #endif
// 2002     }
// 2003 
// 2004     if (rz > current_position[Z_AXIS]) {    // raising?
??do_blocking_move_to_5:
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_7
// 2005       destination[Z_AXIS] = rz;
        STR      R1,[R5, #+32]
// 2006       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2007       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2008         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 2009       #endif
// 2010     }
// 2011 
// 2012     destination[X_AXIS] = rx;
??do_blocking_move_to_7:
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+24]
// 2013     destination[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+28]
// 2014     prepare_move_to_destination();         // set_current_from_destination
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 2015     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2016       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 2017     #endif
// 2018 
// 2019     if (rz < current_position[Z_AXIS]) {    // lowering?
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
        B.N      ??do_blocking_move_to_9
// 2020       destination[Z_AXIS] = rz;
// 2021       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 2022       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2023         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 2024       #endif
// 2025     }
// 2026   }
// 2027   //#elif IS_SCARA
// 2028   else if(MACHINETPYE&IS_SCARA) {
??do_blocking_move_to_1:
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??do_blocking_move_to_10
// 2029 
// 2030     if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
        MOV      R1,R8
        MOV      R0,R7
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??do_blocking_move_to_2
// 2031 
// 2032     set_destination_from_current();
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
// 2033 
// 2034     // If Z needs to raise, do it before moving XY
// 2035     if (destination[Z_AXIS] < rz) {
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+32]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_11
// 2036       destination[Z_AXIS] = rz;
        STR      R1,[R5, #+32]
// 2037       prepare_uninterpolated_move_to_destination(z_feedrate);
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2038     }
// 2039 
// 2040     destination[X_AXIS] = rx;
??do_blocking_move_to_11:
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+24]
// 2041     destination[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+28]
// 2042     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??do_blocking_move_to_12
        LDR      R2,[R5, #+116]
??do_blocking_move_to_12:
        MOV      R0,R2
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2043 
// 2044     // If Z needs to lower, do it after moving XY
// 2045     if (destination[Z_AXIS] > rz) {
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
// 2046       destination[Z_AXIS] = rz;
??do_blocking_move_to_9:
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+32]
// 2047       prepare_uninterpolated_move_to_destination(z_feedrate);
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
        B.N      ??do_blocking_move_to_8
// 2048     }
// 2049   }
// 2050   //#else
// 2051   else
// 2052   {
// 2053     // If Z needs to raise, do it before moving XY
// 2054     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_10:
        LDR      R0,[R5, #+16]
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_13
// 2055       feedrate_mm_s = z_feedrate;
        STR      R10,[R5, #+92]
// 2056       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+16]
// 2057       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2058     }
// 2059 
// 2060     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_13:
        LDR      R2,[R9, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_blocking_move_to_14
        STR      R2,[R5, #+92]
        B.N      ??do_blocking_move_to_15
??do_blocking_move_to_14:
        LDR      R0,[R5, #+116]
        STR      R0,[R5, #+92]
// 2061     current_position[X_AXIS] = rx;
??do_blocking_move_to_15:
        LDR      R0,[R7, #+0]
        STR      R0,[R5, #+8]
// 2062     current_position[Y_AXIS] = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[R5, #+12]
// 2063     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2064 
// 2065     // If Z needs to lower, do it after moving XY
// 2066     if (current_position[Z_AXIS] > rz) {
        LDR      R0,[R4, #+0]
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
// 2067       feedrate_mm_s = z_feedrate;
        STR      R10,[R5, #+92]
// 2068       current_position[Z_AXIS] = rz;
        LDR      R0,[R4, #+0]
        STR      R0,[R5, #+16]
// 2069       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2070     }
// 2071   }
// 2072   //#endif
// 2073 
// 2074   stepper.synchronize();
??do_blocking_move_to_8:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 2075 
// 2076   feedrate_mm_s = old_feedrate_mm_s;
        STR      R6,[R5, #+92]
// 2077 
// 2078   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2079     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 2080   #endif
// 2081 }
??do_blocking_move_to_2:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock28

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_xRKfS0_
        THUMB
// 2082 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_xRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2083   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
        LDR.N    R4,??DataTable134_4
        MOV      R3,R1
        ADD      R2,R4,#+16
        ADD      R1,R4,#+12
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock29
// 2084 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_zRKfS0_
        THUMB
// 2085 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_zRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2086   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.N    R4,??DataTable134_4
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+12
        ADD      R0,R4,#+8
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI R4 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock30
// 2087 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function _Z22do_blocking_move_to_xyRKfS0_S0_
        THUMB
// 2088 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
// 2089   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
_Z22do_blocking_move_to_xyRKfS0_S0_:
        MOV      R3,R2
        LDR.W    R2,??DataTable145
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock31
// 2090 }
// 2091 
// 2092 //
// 2093 // Prepare to do endstop or probe moves
// 2094 // with custom feedrates.
// 2095 //
// 2096 //  - Save current feedrates
// 2097 //  - Reset the rate multiplier
// 2098 //  - Reset the command timeout
// 2099 //  - Enable the endstops (for endstop moves)
// 2100 //

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function _Z31setup_for_endstop_or_probe_movev
        THUMB
// 2101 static void setup_for_endstop_or_probe_move() {
// 2102   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2103     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
// 2104   #endif
// 2105   saved_feedrate_mm_s = feedrate_mm_s;
_Z31setup_for_endstop_or_probe_movev:
        LDR.W    R0,??DataTable145_1
        LDR.N    R1,??DataTable134_4
        LDR      R2,[R1, #+92]
        STR      R2,[R0, #+4]
// 2106   saved_feedrate_percentage = feedrate_percentage;
        LDRH     R2,[R1, #+6]
        STRH     R2,[R0, #+0]
// 2107   feedrate_percentage = 100;
        MOVS     R0,#+100
        STRH     R0,[R1, #+6]
// 2108   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock32
// 2109 }
// 2110 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function _Z36clean_up_after_endstop_or_probe_movev
        THUMB
// 2111 static void clean_up_after_endstop_or_probe_move() {
// 2112   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2113     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
// 2114   #endif
// 2115   feedrate_mm_s = saved_feedrate_mm_s;
_Z36clean_up_after_endstop_or_probe_movev:
        LDR.N    R0,??DataTable134_4
        LDR.W    R1,??DataTable145_1
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+92]
// 2116   feedrate_percentage = saved_feedrate_percentage;
        LDRH     R1,[R1, #+0]
        STRH     R1,[R0, #+6]
// 2117   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        B.W      _Z19refresh_cmd_timeoutv
          CFI EndBlock cfiBlock33
// 2118 }
// 2119 
// 2120 #if HAS_BED_PROBE
// 2121   /**
// 2122    * Raise Z to a minimum height to make room for a probe to move
// 2123    */
// 2124   inline void do_probe_raise(const float z_raise) {
// 2125     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2126       if (DEBUGGING(LEVELING)) {
// 2127         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
// 2128         SERIAL_CHAR(')');
// 2129         SERIAL_EOL();
// 2130       }
// 2131     #endif
// 2132 
// 2133     float z_dest = z_raise;
// 2134     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
// 2135 
// 2136     if (z_dest > current_position[Z_AXIS])
// 2137       do_blocking_move_to_z(z_dest);
// 2138   }
// 2139 
// 2140 #endif // HAS_BED_PROBE
// 2141 
// 2142 #if HAS_AXIS_UNHOMED_ERR
// 2143 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function _Z18axis_unhomed_errorbbb
        THUMB
// 2144   bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
_Z18axis_unhomed_errorbbb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 2145     #if ENABLED(HOME_AFTER_DEACTIVATE)
// 2146       const bool xx = x && !axis_known_position[X_AXIS],
// 2147                  yy = y && !axis_known_position[Y_AXIS],
// 2148                  zz = z && !axis_known_position[Z_AXIS];
// 2149     #else
// 2150       const bool xx = x && !axis_homed[X_AXIS],
        CMP      R0,#+0
        BEQ.N    ??axis_unhomed_error_0
        LDR.N    R0,??DataTable134_9
        LDRB     R0,[R0, #+0]
        EOR      R4,R0,#0x1
        B.N      ??axis_unhomed_error_1
??axis_unhomed_error_0:
        MOVS     R4,#+0
// 2151                  yy = y && !axis_homed[Y_AXIS],
??axis_unhomed_error_1:
        CMP      R1,#+0
        BEQ.N    ??axis_unhomed_error_2
        LDR.N    R0,??DataTable134_9
        LDRB     R0,[R0, #+1]
        EOR      R5,R0,#0x1
        B.N      ??axis_unhomed_error_3
??axis_unhomed_error_2:
        MOVS     R5,#+0
// 2152                  zz = z && !axis_homed[Z_AXIS];
??axis_unhomed_error_3:
        CMP      R2,#+0
        BEQ.N    ??axis_unhomed_error_4
        LDR.N    R0,??DataTable134_9
        LDRB     R0,[R0, #+2]
        EOR      R6,R0,#0x1
        B.N      ??axis_unhomed_error_5
??axis_unhomed_error_4:
        MOVS     R6,#+0
// 2153     #endif
// 2154     if (xx || yy || zz) {
??axis_unhomed_error_5:
        ORR      R0,R5,R4
        ORRS     R0,R6,R0
        BEQ.N    ??axis_unhomed_error_6
// 2155       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable137_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2156       SERIAL_ECHOPGM(MSG_HOME " ");
        ADR.W    R0,`?<Constant "Home ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2157       if (xx) SERIAL_ECHOPGM(MSG_X);
        CMP      R4,#+0
        BEQ.N    ??axis_unhomed_error_7
        ADR.N    R0,??DataTable134  ;; "X"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2158       if (yy) SERIAL_ECHOPGM(MSG_Y);
??axis_unhomed_error_7:
        CMP      R5,#+0
        BEQ.N    ??axis_unhomed_error_8
        ADR.N    R0,??DataTable134_1  ;; "Y"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2159       if (zz) SERIAL_ECHOPGM(MSG_Z);
??axis_unhomed_error_8:
        CMP      R6,#+0
        BEQ.N    ??axis_unhomed_error_9
        ADR.N    R0,??DataTable134_2  ;; "Z"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2160       SERIAL_ECHOLNPGM(" " MSG_FIRST);
??axis_unhomed_error_9:
        ADR.W    R0,`?<Constant " first\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2161 
// 2162       #if ENABLED(ULTRA_LCD)
// 2163         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 2164       #endif
// 2165       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 2166     }
// 2167     return false;
??axis_unhomed_error_6:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock34
// 2168   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Home ">`:
        DC8 "Home "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " first\\n">`:
        DC8 " first\012"
// 2169 
// 2170 #endif // HAS_AXIS_UNHOMED_ERR
// 2171 
// 2172 #if ENABLED(Z_PROBE_SLED)
// 2173 
// 2174   #ifndef SLED_DOCKING_OFFSET
// 2175     #define SLED_DOCKING_OFFSET 0
// 2176   #endif
// 2177 
// 2178   /**
// 2179    * Method to dock/undock a sled designed by Charles Bell.
// 2180    *
// 2181    * stow[in]     If false, move to MAX_X and engage the solenoid
// 2182    *              If true, move to MAX_X and release the solenoid
// 2183    */
// 2184   static void dock_sled(bool stow) {
// 2185     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2186       if (DEBUGGING(LEVELING)) {
// 2187         SERIAL_ECHOPAIR("dock_sled(", stow);
// 2188         SERIAL_CHAR(')');
// 2189         SERIAL_EOL();
// 2190       }
// 2191     #endif
// 2192 
// 2193     // Dock sled a bit closer to ensure proper capturing
// 2194     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
// 2195 
// 2196     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
// 2197       WRITE(SOL1_PIN, !stow); // switch solenoid
// 2198     #endif
// 2199   }
// 2200 
// 2201 #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2202 
// 2203   FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
// 2204     do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
// 2205   }
// 2206 
// 2207   void run_deploy_moves_script() {
// 2208     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
// 2209       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
// 2210         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
// 2211       #endif
// 2212       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
// 2213         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
// 2214       #endif
// 2215       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
// 2216         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
// 2217       #endif
// 2218       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
// 2219         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
// 2220       #endif
// 2221       const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
// 2222       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
// 2223     #endif
// 2224     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
// 2225       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
// 2226         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
// 2227       #endif
// 2228       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
// 2229         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
// 2230       #endif
// 2231       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
// 2232         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
// 2233       #endif
// 2234       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
// 2235         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
// 2236       #endif
// 2237       const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
// 2238       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
// 2239     #endif
// 2240     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
// 2241       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
// 2242         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
// 2243       #endif
// 2244       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
// 2245         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
// 2246       #endif
// 2247       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
// 2248         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
// 2249       #endif
// 2250       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
// 2251         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
// 2252       #endif
// 2253       const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
// 2254       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
// 2255     #endif
// 2256     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
// 2257       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
// 2258         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
// 2259       #endif
// 2260       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
// 2261         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
// 2262       #endif
// 2263       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
// 2264         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
// 2265       #endif
// 2266       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
// 2267         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
// 2268       #endif
// 2269       const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
// 2270       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
// 2271     #endif
// 2272     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
// 2273       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
// 2274         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
// 2275       #endif
// 2276       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
// 2277         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
// 2278       #endif
// 2279       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
// 2280         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
// 2281       #endif
// 2282       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
// 2283         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
// 2284       #endif
// 2285       const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
// 2286       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
// 2287     #endif
// 2288   }
// 2289 
// 2290   void run_stow_moves_script() {
// 2291     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
// 2292       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
// 2293         #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
// 2294       #endif
// 2295       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
// 2296         #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
// 2297       #endif
// 2298       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
// 2299         #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
// 2300       #endif
// 2301       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
// 2302         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
// 2303       #endif
// 2304       const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
// 2305       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
// 2306     #endif
// 2307     #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
// 2308       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
// 2309         #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
// 2310       #endif
// 2311       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
// 2312         #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
// 2313       #endif
// 2314       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
// 2315         #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
// 2316       #endif
// 2317       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
// 2318         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
// 2319       #endif
// 2320       const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
// 2321       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
// 2322     #endif
// 2323     #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
// 2324       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
// 2325         #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
// 2326       #endif
// 2327       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
// 2328         #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
// 2329       #endif
// 2330       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
// 2331         #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
// 2332       #endif
// 2333       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
// 2334         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
// 2335       #endif
// 2336       const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
// 2337       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
// 2338     #endif
// 2339     #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
// 2340       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
// 2341         #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
// 2342       #endif
// 2343       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
// 2344         #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
// 2345       #endif
// 2346       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
// 2347         #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
// 2348       #endif
// 2349       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
// 2350         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
// 2351       #endif
// 2352       const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
// 2353       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
// 2354     #endif
// 2355     #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
// 2356       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
// 2357         #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
// 2358       #endif
// 2359       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
// 2360         #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
// 2361       #endif
// 2362       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
// 2363         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
// 2364       #endif
// 2365       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
// 2366         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
// 2367       #endif
// 2368       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
// 2369       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
// 2370     #endif
// 2371   }
// 2372 
// 2373 #endif // Z_PROBE_ALLEN_KEY
// 2374 
// 2375 #if ENABLED(PROBING_FANS_OFF)
// 2376 
// 2377   void fans_pause(const bool p) {
// 2378     if (p != fans_paused) {
// 2379       fans_paused = p;
// 2380       if (p)
// 2381         for (uint8_t x = 0; x < FAN_COUNT; x++) {
// 2382           paused_fanSpeeds[x] = fanSpeeds[x];
// 2383           fanSpeeds[x] = 0;
// 2384         }
// 2385       else
// 2386         for (uint8_t x = 0; x < FAN_COUNT; x++)
// 2387           fanSpeeds[x] = paused_fanSpeeds[x];
// 2388     }
// 2389   }
// 2390 
// 2391 #endif // PROBING_FANS_OFF
// 2392 
// 2393 #if HAS_BED_PROBE
// 2394 
// 2395   // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
// 2396   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
// 2397     #if 1 //ENABLED(Z_MIN_PROBE_ENDSTOP)
// 2398       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
// 2399     #else
// 2400       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
// 2401     #endif
// 2402   #endif
// 2403 
// 2404   #if QUIET_PROBING
// 2405     void probing_pause(const bool p) {
// 2406       #if ENABLED(PROBING_HEATERS_OFF)
// 2407         thermalManager.pause(p);
// 2408       #endif
// 2409       #if ENABLED(PROBING_FANS_OFF)
// 2410         fans_pause(p);
// 2411       #endif
// 2412       if (p) safe_delay(
// 2413         #if DELAY_BEFORE_PROBING > 25
// 2414           DELAY_BEFORE_PROBING
// 2415         #else
// 2416           25
// 2417         #endif
// 2418       );
// 2419     }
// 2420   #endif // QUIET_PROBING
// 2421 
// 2422   //#if ENABLED(BLTOUCH)
// 2423 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function _Z15bltouch_commandi
        THUMB
// 2424     void bltouch_command(int angle) {
// 2425     #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
// 2426       //MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
// 2427       int mksAngle;
// 2428  	  switch(angle)
_Z15bltouch_commandi:
        CMP      R0,#+10
        BEQ.N    ??bltouch_command_0
        CMP      R0,#+60
        BEQ.N    ??bltouch_command_1
        CMP      R0,#+90
        BEQ.N    ??bltouch_command_2
        CMP      R0,#+120
        BEQ.N    ??bltouch_command_3
        B.N      ??bltouch_command_4
// 2429 	  {
// 2430 		 case 10:
// 2431 			 mksAngle = 700/2;
??bltouch_command_0:
        MOV      R0,#+350
// 2432 			 break;
        B.N      ??bltouch_command_5
// 2433 		 case 90:
// 2434 			 mksAngle = 1500/2;
??bltouch_command_2:
        MOVW     R0,#+750
// 2435 			 break;
        B.N      ??bltouch_command_5
// 2436 		 case 120:
// 2437 			 mksAngle = 1800/2;
??bltouch_command_3:
        MOV      R0,#+900
// 2438 			 break;
        B.N      ??bltouch_command_5
// 2439 		 case 160:
// 2440 			 mksAngle = 2200/2;
// 2441 			 break;
// 2442 		 case 60:
// 2443 			 mksAngle = 1200/2;
??bltouch_command_1:
        MOV      R0,#+600
// 2444 			 break;
        B.N      ??bltouch_command_5
// 2445 		 default:
// 2446 			 mksAngle = 2200/2;
??bltouch_command_4:
        MOVW     R0,#+1100
// 2447 			 break;
// 2448 	  }
// 2449       MKS_TOUCH_TIM = mksAngle;	  
??bltouch_command_5:
        LDR.W    R1,??DataTable145_2  ;; 0x40012c34
        STR      R0,[R1, #+0]
// 2450       safe_delay(BLTOUCH_DELAY);
        MOVW     R0,#+375
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
          CFI EndBlock cfiBlock35
// 2451       #endif
// 2452     }
// 2453 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI Function _Z20set_bltouch_deployedb
        THUMB
// 2454     bool set_bltouch_deployed(const bool deploy) {
_Z20set_bltouch_deployedb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R0
// 2455       if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
        LDR.N    R5,??DataTable134_5
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??set_bltouch_deployed_0
// 2456 		{
// 2457 		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_1
        LDR.W    R6,??DataTable145_3
        LDR.W    R7,??DataTable145_4
        LDRH     R1,[R7, #+26]
        LDR      R0,[R6, #+52]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+57]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
// 2458 		  { 	 // If BL-Touch says it's triggered
// 2459 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2460 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
        MOVS     R0,#+10
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2461 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
        MOVS     R0,#+90
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2462 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
        MOVW     R0,#+1500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 2463 											 //  (Measured completion time was 0.65 seconds
// 2464 											 //   after reset, deploy, and stow sequence)
// 2465 		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
        LDRH     R1,[R7, #+26]
        LDR      R0,[R6, #+52]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+57]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
        B.N      ??set_bltouch_deployed_2
// 2466 			SERIAL_ERROR_START();
// 2467 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2468 			stop(); 						 // punt!
// 2469 		  	}
// 2470 			}
// 2471 		
// 2472 		}
// 2473 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
??set_bltouch_deployed_0:
        CMP      R0,#+2
        BNE.N    ??set_bltouch_deployed_1
// 2474 		{
// 2475 		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_1
        LDR.W    R6,??DataTable145_3
        LDR.W    R7,??DataTable145_4
        LDRH     R1,[R7, #+28]
        LDR      R0,[R6, #+56]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        ADDW     R5,R5,#+57
        LDRB     R1,[R5, #+4]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
// 2476 		  { 	 // If BL-Touch says it's triggered
// 2477 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2478 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
        MOVS     R0,#+10
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2479 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
        MOVS     R0,#+90
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2480 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
        MOVW     R0,#+1500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 2481 											 //  (Measured completion time was 0.65 seconds
// 2482 											 //   after reset, deploy, and stow sequence)
// 2483 		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
        LDRH     R1,[R7, #+28]
        LDR      R0,[R6, #+56]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+4]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_1
// 2484 			SERIAL_ERROR_START();
??set_bltouch_deployed_2:
        LDR.W    R0,??DataTable137_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2485 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
        ADR.W    R0,`?<Constant "STOP called because o...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2486 			stop(); 						 // punt!
          CFI FunCall _Z4stopv
        BL       _Z4stopv
// 2487 		  }
// 2488 		}
// 2489 		}
// 2490       //}
// 2491 
// 2492       bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
??set_bltouch_deployed_1:
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_3
        MOVS     R0,#+10
        B.N      ??set_bltouch_deployed_4
??set_bltouch_deployed_3:
        MOVS     R0,#+90
??set_bltouch_deployed_4:
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2493 
// 2494       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2495         if (DEBUGGING(LEVELING)) {
// 2496           SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
// 2497           SERIAL_CHAR(')');
// 2498           SERIAL_EOL();
// 2499         }
// 2500       #endif
// 2501 
// 2502       return false;
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock36
// 2503     }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "STOP called because o...">`:
        DC8 53H, 54H, 4FH, 50H, 20H, 63H, 61H, 6CH
        DC8 6CH, 65H, 64H, 20H, 62H, 65H, 63H, 61H
        DC8 75H, 73H, 65H, 20H, 6FH, 66H, 20H, 42H
        DC8 4CH, 54H, 6FH, 75H, 63H, 68H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 2DH, 20H, 72H
        DC8 65H, 73H, 74H, 61H, 72H, 74H, 20H, 77H
        DC8 69H, 74H, 68H, 20H, 4DH, 39H, 39H, 39H
        DC8 0AH, 0
        DC8 0, 0
// 2504 
// 2505   //#endif // BLTOUCH
// 2506 
// 2507   // returns false for ok and true for failure

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function _Z18set_probe_deployedb
        THUMB
// 2508   bool set_probe_deployed(bool deploy) {
_Z18set_probe_deployedb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+16
          CFI CFA R13+24
        MOV      R4,R0
// 2509 
// 2510     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2511       if (DEBUGGING(LEVELING)) {
// 2512         DEBUG_POS("set_probe_deployed", current_position);
// 2513         SERIAL_ECHOLNPAIR("deploy: ", deploy);
// 2514       }
// 2515     #endif
// 2516 
// 2517     if (endstops.z_probe_enabled == deploy) return false;
        LDR.W    R0,??DataTable146
        LDRB     R0,[R0, #+0]
        CMP      R0,R4
        BNE.N    ??set_probe_deployed_0
        MOVS     R0,#+0
        B.N      ??set_probe_deployed_1
// 2518 
// 2519     // Make room for probe
// 2520     //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
// 2521     do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
??set_probe_deployed_0:
        LDR.N    R0,??DataTable134_5
        LDR      R1,[R0, #+100]
        LDR      R0,[R0, #+104]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??set_probe_deployed_2
        MOV      R1,R0
??set_probe_deployed_2:
        MOV      R0,R1
          CFI FunCall _Z14do_probe_raisef
        BL       _Z14do_probe_raisef
// 2522 
// 2523     #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
// 2524       #if ENABLED(Z_PROBE_SLED)
// 2525         #define _AUE_ARGS true, false, false
// 2526       #else
// 2527         #define _AUE_ARGS
// 2528       #endif
// 2529       if (axis_unhomed_error(_AUE_ARGS)) {
// 2530         SERIAL_ERROR_START();
// 2531         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2532         stop();
// 2533         return true;
// 2534       }
// 2535     #endif
// 2536 
// 2537     const float oldXpos = current_position[X_AXIS],
        LDR.N    R0,??DataTable134_4
        LDR      R1,[R0, #+8]
        STR      R1,[SP, #+8]
// 2538                 oldYpos = current_position[Y_AXIS];
        LDR      R1,[R0, #+12]
        STR      R1,[SP, #+4]
// 2539 
// 2540     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2541       bool _triggered_bool =false;
// 2542 	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2543 		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2544 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2545 		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2546 
// 2547       // If endstop is already false, the Z probe is deployed
// 2548       if (_triggered_bool == deploy) {
// 2549       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
// 2550                                                        // Would a goto be less ugly?
// 2551         //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
// 2552                                                        // for a triggered when stowed manual probe.
// 2553 
// 2554         if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
// 2555                                                      // otherwise an Allen-Key probe can't be stowed.
// 2556     #endif
// 2557 
// 2558         #if ENABLED(SOLENOID_PROBE)
// 2559 
// 2560           #if HAS_SOLENOID_1
// 2561             WRITE(SOL1_PIN, deploy);
// 2562           #endif
// 2563 
// 2564         #elif ENABLED(Z_PROBE_SLED)
// 2565 
// 2566           dock_sled(!deploy);
// 2567 
// 2568         #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
// 2569 
// 2570           MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
// 2571 
// 2572         #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2573 
// 2574           deploy ? run_deploy_moves_script() : run_stow_moves_script();
// 2575 
// 2576         #endif
// 2577 
// 2578     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2579       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2580       
// 2581 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2582 		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2583 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2584 		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2585 
// 2586       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
// 2587       if (_triggered_bool == deploy) { 
// 2588 
// 2589         if (IsRunning()) {
// 2590           SERIAL_ERROR_START();
// 2591           SERIAL_ERRORLNPGM("Z-Probe failed");
// 2592           LCD_ALERTMESSAGEPGM("Err: ZPROBE");
// 2593         }
// 2594         stop();
// 2595         return true;
// 2596 
// 2597       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2598 
// 2599     #endif
// 2600 
// 2601     do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
        MOVS     R1,#+0
        STR      R1,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R0,#+16
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2602     endstops.enable_z_probe(deploy);
        MOV      R0,R4
          CFI FunCall _ZN8Endstops14enable_z_probeEb
        BL       _ZN8Endstops14enable_z_probeEb
// 2603     return false;
        MOVS     R0,#+0
??set_probe_deployed_1:
        ADD      SP,SP,#+16
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock37
// 2604   }
// 2605 
// 2606   /**
// 2607    * @brief Used by run_z_probe to do a single Z probe move.
// 2608    *
// 2609    * @param  z        Z destination
// 2610    * @param  fr_mm_s  Feedrate in mm/s
// 2611    * @return true to indicate an error
// 2612    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function _Z13do_probe_moveff
        THUMB
// 2613   static bool do_probe_move(const float z, const float fr_mm_m) {
_Z13do_probe_moveff:
        PUSH     {R0,R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOV      R5,R1
// 2614     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2615       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
// 2616     #endif
// 2617 
// 2618     // Deploy BLTouch at the start of any probe
// 2619     //#if ENABLED(BLTOUCH)
// 2620     if(MKSTOUCH == 1)
        LDR.N    R4,??DataTable134_5
        LDRB     R0,[R4, #+256]
        CMP      R0,#+1
        BNE.N    ??do_probe_move_0
// 2621       {if (set_bltouch_deployed(true)) return true;}
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        CMP      R0,#+0
        BNE.N    ??do_probe_move_1
// 2622     //#endif
// 2623 
// 2624     #if QUIET_PROBING
// 2625       probing_pause(true);
// 2626     #endif
// 2627 
// 2628     // Move down until probe triggered
// 2629     do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
??do_probe_move_0:
        MOV      R0,R5
        LDR.N    R1,??DataTable134_6  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2630    /*
// 2631     // Check to see if the probe was triggered
// 2632     const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
// 2633       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2634         Z_MIN
// 2635       #else
// 2636         Z_MIN_PROBE
// 2637       #endif
// 2638     );
// 2639     */
// 2640       bool probe_triggered;
// 2641       if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
        LDR.W    R0,??DataTable148
        LDRB     R1,[R4, #+153]
        CMP      R1,#+2
        LDRSB    R0,[R0, #+0]
        UXTB     R0,R0
        BEQ.N    ??do_probe_move_2
// 2642       {
// 2643         probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN);
        LSRS     R0,R0,#+2
        AND      R5,R0,#0x1
        B.N      ??do_probe_move_3
// 2644       }
// 2645       else
// 2646       {
// 2647         probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN_PROBE);
??do_probe_move_2:
        LSRS     R0,R0,#+3
        AND      R5,R0,#0x1
// 2648       }
// 2649 
// 2650     #if QUIET_PROBING
// 2651       probing_pause(false);
// 2652     #endif
// 2653 
// 2654     // Retract BLTouch immediately after a probe if it was triggered
// 2655     //#if ENABLED(BLTOUCH)
// 2656     if(MKSTOUCH == 1)
??do_probe_move_3:
        LDRB     R0,[R4, #+256]
        CMP      R0,#+1
        BNE.N    ??do_probe_move_4
// 2657       {if (probe_triggered && set_bltouch_deployed(false)) return true;}
        CMP      R5,#+0
        BEQ.N    ??do_probe_move_4
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        CMP      R0,#+0
        BEQ.N    ??do_probe_move_4
??do_probe_move_1:
        MOVS     R0,#+1
        POP      {R1-R5,PC}
// 2658     //#endif
// 2659 
// 2660     // Clear endstop flags
// 2661     endstops.hit_on_purpose();
??do_probe_move_4:
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 2662 
// 2663     // Get Z where the steppers were interrupted
// 2664     set_current_from_steppers_for_axis(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 2665 
// 2666     // Tell the planner where we actually are
// 2667     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 2668 
// 2669     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2670       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
// 2671     #endif
// 2672 
// 2673     return !probe_triggered;
        EOR      R0,R5,#0x1
        POP      {R1-R5,PC}       ;; return
          CFI EndBlock cfiBlock38
// 2674   }
// 2675 
// 2676   /**
// 2677    * @details Used by probe_pt to do a single Z probe at the current position.
// 2678    *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
// 2679    *
// 2680    * @return The raw Z position where the probe was triggered
// 2681    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function _Z11run_z_probev
        THUMB
// 2682   static float run_z_probe() {
_Z11run_z_probev:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
// 2683 
// 2684     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2685       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
// 2686     #endif
// 2687 
// 2688     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
// 2689     refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 2690 
// 2691     // Double-probing does a fast probe followed by a slow probe
// 2692     #if MULTIPLE_PROBING == 2
// 2693 
// 2694       // Do a first probe at the fast speed
// 2695       if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
// 2696 
// 2697       float first_probe_z = current_position[Z_AXIS];
// 2698 
// 2699       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2700         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
// 2701       #endif
// 2702 
// 2703       // move up to make clearance for the probe
// 2704       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2705 
// 2706     #else
// 2707 
// 2708       // If the nozzle is above the travel height then
// 2709       // move down quickly before doing the slow probe
// 2710       float z = Z_CLEARANCE_DEPLOY_PROBE;
        LDR.N    R4,??DataTable134_5
        LDR      R2,[R4, #+100]
// 2711       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
        LDR.N    R5,??DataTable134_4
        LDR      R3,[R5, #+112]
        MOV      R0,R3
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??run_z_probe_0
        MOV      R0,R2
        MOV      R1,R3
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R2,R0
// 2712 
// 2713       if (z < current_position[Z_AXIS]) {
??run_z_probe_0:
        MOV      R0,R2
        LDR      R1,[R5, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??run_z_probe_1
// 2714 
// 2715         // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
// 2716         if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
        LDR      R1,[R4, #+120]
          CFI FunCall _Z13do_probe_moveff
        BL       _Z13do_probe_moveff
        CMP      R0,#+0
        BNE.N    ??run_z_probe_1
// 2717           do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
        LDR      R1,[R5, #+16]
        LDR      R0,[R4, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+120]
        LDR.N    R1,??DataTable134_6  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
// 2718       }
// 2719     #endif
// 2720 
// 2721     #if MULTIPLE_PROBING > 2
// 2722       float probes_total = 0;
// 2723       for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
// 2724     #endif
// 2725 
// 2726         // move down slowly to find bed
// 2727         if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
??run_z_probe_1:
        LDR      R1,[R4, #+124]
        LDR.W    R0,??DataTable149  ;; 0xc1200000
          CFI FunCall _Z13do_probe_moveff
        BL       _Z13do_probe_moveff
        CMP      R0,#+0
        BEQ.N    ??run_z_probe_2
        MVN      R0,#-2147483648
        POP      {R1-R5,PC}
// 2728 
// 2729     #if MULTIPLE_PROBING > 2
// 2730         probes_total += current_position[Z_AXIS];
// 2731         if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2732       }
// 2733     #endif
// 2734 
// 2735     #if MULTIPLE_PROBING > 2
// 2736 
// 2737       // Return the average value of all probes
// 2738       return probes_total * (1.0 / (MULTIPLE_PROBING));
// 2739 
// 2740     #elif MULTIPLE_PROBING == 2
// 2741 
// 2742       const float z2 = current_position[Z_AXIS];
// 2743 
// 2744       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2745         if (DEBUGGING(LEVELING)) {
// 2746           SERIAL_ECHOPAIR("2nd Probe Z:", z2);
// 2747           SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
// 2748         }
// 2749       #endif
// 2750 
// 2751       // Return a weighted average of the fast and slow probes
// 2752       return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
// 2753 
// 2754     #else
// 2755 
// 2756       // Return the single probe result
// 2757       return current_position[Z_AXIS];
??run_z_probe_2:
        LDR      R0,[R5, #+16]
        POP      {R1-R5,PC}       ;; return
          CFI EndBlock cfiBlock39
// 2758 
// 2759     #endif
// 2760 
// 2761     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2762       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
// 2763     #endif
// 2764   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134:
        DC8      "X",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_1:
        DC8      "Y",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_2:
        DC8      "Z",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_3:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_4:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_5:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_6:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_7:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_8:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134_9:
        DC32     axis_homed
// 2765 
// 2766   /**
// 2767    * - Move to the given XY
// 2768    * - Deploy the probe, if not already deployed
// 2769    * - Probe the bed, get the Z position
// 2770    * - Depending on the 'stow' flag
// 2771    *   - Stow the probe, or
// 2772    *   - Raise to the BETWEEN height
// 2773    * - Return the probed Z position
// 2774    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function _Z8probe_ptRKfS0_bhb
        THUMB
// 2775   float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
_Z8probe_ptRKfS0_bhb:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOV      R8,R0
        MOV      R4,R1
        MOV      R7,R2
        MOV      R9,R3
// 2776     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2777       if (DEBUGGING(LEVELING)) {
// 2778         SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
// 2779         SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
// 2780         SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
// 2781         SERIAL_ECHOLNPGM("stow)");
// 2782         DEBUG_POS("", current_position);
// 2783       }
// 2784     #endif
// 2785 
// 2786     // TODO: Adapt for SCARA, where the offset rotates
// 2787     float nx = rx, ny = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+0]
        STR      R0,[SP, #+4]
// 2788     if (probe_relative) {
        LDR.W    R10,??DataTable149_1
        LDRSH    R1,[R10, #+88]
        MOVW     R2,#+770
        LDR      R0,[SP, #+64]
        CMP      R0,#+0
        BEQ.N    ??probe_pt_0
// 2789       if(MACHINETPYE & IS_KINEMATIC)
        TST      R1,R2
        MOV      R1,R4
        MOV      R0,R8
        BEQ.N    ??probe_pt_1
// 2790       {
// 2791         if (!position_is_reachable_by_probe_IS_KINEMATIC(rx, ry)) return NAN;  // The given position is in terms of the probe
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_2
        B.N      ??probe_pt_3
// 2792       }
// 2793       else
// 2794       {
// 2795         if (!position_is_reachable_by_probe_IS_CARTESIAN(rx, ry)) return NAN;  // The given position is in terms of the probe
??probe_pt_1:
          CFI FunCall _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??probe_pt_3
// 2796       }
// 2797       nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
??probe_pt_2:
        LDR      R0,[SP, #+8]
        LDR      R1,[R10, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
// 2798       ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
        LDR      R0,[SP, #+4]
        LDR      R1,[R10, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
// 2799     }
// 2800     else
// 2801     {
// 2802         if(MACHINETPYE & IS_KINEMATIC)
// 2803         {
// 2804             if (!position_is_reachable_IS_KINEMATIC(nx, ny)) return NAN;        // The given position is in terms of the nozzle
// 2805         }
// 2806         else
// 2807         {
// 2808             if (!position_is_reachable_IS_CARTESIAN(nx, ny)) return NAN;        // The given position is in terms of the nozzle            
// 2809         }
// 2810      }
// 2811     //const 
// 2812         float nz;/* =
// 2813       #if ENABLED(DELTA)
// 2814         // Move below clip height or xy move will be aborted by do_blocking_move_to
// 2815         min(current_position[Z_AXIS], delta_clip_start_height)
// 2816       #else
// 2817         current_position[Z_AXIS]
// 2818       #endif
// 2819     ;
// 2820     */
// 2821     if(MACHINETPYE ==  DELTA)
??probe_pt_4:
        LDR.W    R5,??DataTable149_2
        LDR      R0,[R5, #+16]
        LDRSH    R1,[R10, #+88]
        CMP      R1,#+2
        BNE.N    ??probe_pt_5
// 2822     {
// 2823         nz = min(current_position[Z_AXIS], delta_clip_start_height);
        LDR      R1,[R5, #+124]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_pt_6
        STR      R0,[SP, #+12]
        B.N      ??probe_pt_7
// 2824     }
??probe_pt_0:
        TST      R1,R2
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
        BEQ.N    ??probe_pt_8
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_4
        B.N      ??probe_pt_3
??probe_pt_8:
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_4
??probe_pt_3:
        MVN      R0,#-2147483648
        B.N      ??probe_pt_9
??probe_pt_6:
        STR      R1,[SP, #+12]
        B.N      ??probe_pt_7
// 2825     else
// 2826     {
// 2827         nz = current_position[Z_AXIS];
??probe_pt_5:
        STR      R0,[SP, #+12]
// 2828     }
// 2829     const float old_feedrate_mm_s = feedrate_mm_s;
??probe_pt_7:
        LDR      R0,[R5, #+92]
        STR      R0,[SP, #+20]
// 2830     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
        LDR      R0,[R5, #+116]
        STR      R0,[R5, #+92]
// 2831 
// 2832     // Move the probe to the starting XYZ
// 2833     do_blocking_move_to(nx, ny, nz);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,SP,#+12
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2834 
// 2835     float measured_z = NAN;
        MVN      R11,#-2147483648
        MOV      R6,R11
// 2836     if (!DEPLOY_PROBE()) {
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.N    ??probe_pt_10
// 2837       measured_z = run_z_probe() + zprobe_zoffset;
          CFI FunCall _Z11run_z_probev
        BL       _Z11run_z_probev
        MOV      R1,R0
        LDR      R0,[R5, #+112]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
// 2838 
// 2839       if (!stow)
        CMP      R7,#+0
        BNE.N    ??probe_pt_11
// 2840         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
        LDR      R1,[R5, #+16]
        LDR      R0,[R10, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+16]
        LDR      R0,[R10, #+120]
        LDR.W    R1,??DataTable150  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+16
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
        B.N      ??probe_pt_10
// 2841       else
// 2842         if (STOW_PROBE()) measured_z = NAN;
??probe_pt_11:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??probe_pt_10
        MOV      R6,R11
// 2843     }
// 2844 
// 2845     if (verbose_level > 2) {
??probe_pt_10:
        CMP      R9,#+3
        BLT.N    ??probe_pt_12
// 2846       SERIAL_PROTOCOLPGM("Bed X: ");
        ADR.W    R0,`?<Constant "Bed X: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2847       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
        LDR.N    R7,??DataTable137_4
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR      R1,[R8, #+0]
        LDR      R0,[R5, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2848       SERIAL_PROTOCOLPGM(" Y: ");
        ADR.W    R0,`?<Constant " Y: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2849       SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2850       SERIAL_PROTOCOLPGM(" Z: ");
        ADR.W    R0,`?<Constant " Z: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2851       SERIAL_PROTOCOL_F(measured_z, 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2852       SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R7
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 2853     }
// 2854 
// 2855     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2856       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
// 2857     #endif
// 2858 
// 2859     feedrate_mm_s = old_feedrate_mm_s;
??probe_pt_12:
        LDR      R0,[SP, #+20]
        STR      R0,[R5, #+92]
// 2860 
// 2861     if (isnan(measured_z)) {
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??probe_pt_13
// 2862       LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "Probing failed">`
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
// 2863       SERIAL_ERROR_START();
        LDR.N    R0,??DataTable137_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2864       SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
        ADR.W    R0,`?<Constant "Probing failed\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2865     }
// 2866 
// 2867     return measured_z;
??probe_pt_13:
        MOV      R0,R6
??probe_pt_9:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock40
// 2868   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Bed X: ">`:
        DC8 "Bed X: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Y: ">`:
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Z: ">`:
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Probing failed">`:
        DC8 "Probing failed"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Probing failed\\n">`:
        DC8 "Probing failed\012"
// 2869 
// 2870 #endif // HAS_BED_PROBE
// 2871 
// 2872 #if 1//HAS_LEVELING
// 2873 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function _Z17leveling_is_validv
          CFI NoCalls
        THUMB
// 2874   bool leveling_is_valid() {
_Z17leveling_is_validv:
        LDR.W    R0,??DataTable149_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??leveling_is_valid_0
// 2875   /*
// 2876     return
// 2877       #if ENABLED(MESH_BED_LEVELING)
// 2878         mbl.has_mesh
// 2879       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2880         !!bilinear_grid_spacing[X_AXIS]
// 2881       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2882         true
// 2883       #else // 3POINT, LINEAR
// 2884         true
// 2885       #endif
// 2886     ;
// 2887     */
// 2888       if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 2889         return mbl.has_mesh;
        LDR.W    R0,??DataTable151
        LDRB     R0,[R0, #+0]
        BX       LR
// 2890       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??leveling_is_valid_0:
        CMP      R0,#+8
        BNE.N    ??leveling_is_valid_1
// 2891         return !!bilinear_grid_spacing[X_AXIS];
        LDR.N    R0,??DataTable139
        LDR      R0,[R0, #+16]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR
// 2892       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??leveling_is_valid_1:
        CMP      R0,#+16
        BNE.N    ??leveling_is_valid_2
// 2893         return true;
        MOVS     R0,#+1
        BX       LR
// 2894       else
// 2895         return true;
??leveling_is_valid_2:
        MOVS     R0,#+1
        BX       LR               ;; return
          CFI EndBlock cfiBlock41
// 2896   }
// 2897 
// 2898   /**
// 2899    * Turn bed leveling on or off, fixing the current
// 2900    * position as-needed.
// 2901    *
// 2902    * Disable: Current position = physical position
// 2903    *  Enable: Current position = "unleveled" physical position
// 2904    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function _Z24set_bed_leveling_enabledb
        THUMB
// 2905   void set_bed_leveling_enabled(const bool enable/*=true*/) {
_Z24set_bed_leveling_enabledb:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOV      R5,R0
// 2906     bool can_change;
// 2907 /*
// 2908     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2909       const bool can_change = (!enable || leveling_is_valid());
// 2910     #else
// 2911       constexpr bool can_change = true;
// 2912     #endif
// 2913 */
// 2914     if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
        LDR.W    R6,??DataTable149_1
        LDRB     R7,[R6, #+64]
        MOV      R8,R7
        CMP      R8,#+8
        BNE.N    ??set_bed_leveling_enabled_0
// 2915         can_change = (!enable || leveling_is_valid());
        CMP      R5,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        B.N      ??set_bed_leveling_enabled_2
??set_bed_leveling_enabled_1:
        MOVS     R0,#+1
        B.N      ??set_bed_leveling_enabled_2
// 2916     else
// 2917         can_change = true;
??set_bed_leveling_enabled_0:
        MOVS     R0,#+1
// 2918         
// 2919     if (can_change && enable != planner.leveling_active) {
??set_bed_leveling_enabled_2:
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_3
        LDR.W    R4,??DataTable151_1
        LDRB     R0,[R4, #+0]
        CMP      R5,R0
        BEQ.N    ??set_bed_leveling_enabled_3
// 2920 
// 2921       //#if ENABLED(MESH_BED_LEVELING)
// 2922       if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
        CMP      R8,#+32
        BNE.N    ??set_bed_leveling_enabled_4
// 2923       {
// 2924         if (!enable)
        CMP      R5,#+0
        BNE.N    ??set_bed_leveling_enabled_5
// 2925           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        LDR.W    R3,??DataTable149_2
        ADD      R2,R3,#+16
        ADD      R1,R3,#+12
        ADD      R0,R3,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 2926 
// 2927         const bool enabling = enable && leveling_is_valid();
??set_bed_leveling_enabled_5:
        CMP      R5,#+0
        BEQ.N    ??set_bed_leveling_enabled_6
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        B.N      ??set_bed_leveling_enabled_7
??set_bed_leveling_enabled_6:
        MOVS     R0,#+0
// 2928         planner.leveling_active = enabling;
??set_bed_leveling_enabled_7:
        STRB     R0,[R4, #+0]
// 2929         if (enabling) planner.unapply_leveling(current_position);
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_3
        LDR.W    R0,??DataTable152
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        B.N      ??set_bed_leveling_enabled_3
// 2930       }
// 2931       //#elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2932       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??set_bed_leveling_enabled_4:
        CMP      R8,#+16
        BNE.N    ??set_bed_leveling_enabled_8
// 2933       {
// 2934         //#if PLANNER_LEVELING
// 2935         if(BED_LEVELING_METHOD&ABL_PLANAR)
        MOVS     R1,#+6
        TST      R7,R1
        BEQ.N    ??set_bed_leveling_enabled_9
// 2936         {
// 2937           if (planner.leveling_active) {                       // leveling from on to off
        LDR.W    R3,??DataTable149_2
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_10
// 2938             // change unleveled current_position to physical current_position without moving steppers.
// 2939             planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        ADD      R2,R3,#+16
        ADD      R1,R3,#+12
        ADD      R0,R3,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 2940             planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        B.N      ??set_bed_leveling_enabled_3
// 2941           }
// 2942           else {                                        // leveling from off to on
// 2943             planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
??set_bed_leveling_enabled_10:
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
// 2944             // change physical current_position to unleveled current_position without moving steppers.
// 2945             planner.unapply_leveling(current_position);
        ADD      R0,R3,#+8
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        B.N      ??set_bed_leveling_enabled_3
// 2946           }
// 2947         }
// 2948         //#else
// 2949         else
// 2950           planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
??set_bed_leveling_enabled_9:
        STRB     R5,[R4, #+0]
        B.N      ??set_bed_leveling_enabled_3
// 2951         //#endif
// 2952       }
// 2953       //#else // ABL
// 2954       else
// 2955       {
// 2956         //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2957         if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
??set_bed_leveling_enabled_8:
        CMP      R8,#+8
        BNE.N    ??set_bed_leveling_enabled_11
// 2958         {
// 2959           // Force bilinear_z_offset to re-calculate next time
// 2960           const float reset[XYZ] = { -9999.999, -9999.999, 0 };
        ADD      R0,SP,#+0
        ADR.W    R1,`?<Constant {(-9.9999990233E+3F), (-9.999999023`
        LDM      R1!,{R2,R3,R7}
        STM      R0!,{R2,R3,R7}
// 2961           (void)bilinear_z_offset(reset);
        ADD      R0,SP,#+0
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
// 2962         }
// 2963         //#endif
// 2964 
// 2965         // Enable or disable leveling compensation in the planner
// 2966         planner.leveling_active = enable;
??set_bed_leveling_enabled_11:
        STRB     R5,[R4, #+0]
// 2967 
// 2968         if (!enable)
        CMP      R5,#+0
        BNE.N    ??set_bed_leveling_enabled_12
// 2969             /*
// 2970           // When disabling just get the current position from the steppers.
// 2971           // This will yield the smallest error when first converted back to steps.
// 2972           set_current_from_steppers_for_axis(
// 2973             #if ABL_PLANAR
// 2974               ALL_AXES
// 2975             #else
// 2976               Z_AXIS
// 2977             #endif
// 2978           );
// 2979           */
// 2980         {
// 2981             if(BED_LEVELING_METHOD&ABL_PLANAR)
        LDRB     R0,[R6, #+64]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??set_bed_leveling_enabled_13
// 2982                 set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
        B.N      ??set_bed_leveling_enabled_14
// 2983             else
// 2984                 set_current_from_steppers_for_axis(Z_AXIS);
??set_bed_leveling_enabled_13:
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
        B.N      ??set_bed_leveling_enabled_14
// 2985         }
// 2986         else
// 2987           // When enabling, remove compensation from the current position,
// 2988           // so compensation will give the right stepper counts.
// 2989           planner.unapply_leveling(current_position);
??set_bed_leveling_enabled_12:
        LDR.W    R0,??DataTable152
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
// 2990 
// 2991         SYNC_PLAN_POSITION_KINEMATIC();
??set_bed_leveling_enabled_14:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 2992       }
// 2993       //#endif // ABL
// 2994     }
// 2995   }
??set_bed_leveling_enabled_3:
        POP      {R0-R8,PC}       ;; return
          CFI EndBlock cfiBlock42

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137:
        DC32     home_bump_mm_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_1:
        DC32     injected_commands_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_2:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_3:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_4:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_5:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant {(-9.9999990233E+3F), (-9.999999023`:
        DC32 0C61C3FFFH, 0C61C3FFFH, 0H
// 2996 
// 2997   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 2998 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function _Z17set_z_fade_heightfb
        THUMB
// 2999     void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
_Z17set_z_fade_heightfb:
        PUSH     {R0,R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+20
        SUB      SP,SP,#+12
          CFI CFA R13+32
        MOV      R4,R1
// 3000 
// 3001       if (planner.z_fade_height == zfh) return; // do nothing if no change
        LDR.W    R0,??DataTable152_1
        LDR      R0,[R0, #+0]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??set_z_fade_height_0
// 3002 
// 3003       const bool level_active = planner.leveling_active;
        LDR.W    R0,??DataTable151_1
        LDRB     R6,[R0, #+0]
// 3004 
// 3005       //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 3006       if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
        LDR.W    R5,??DataTable149_1
        LDRB     R0,[R5, #+64]
        CMP      R0,#+16
        BNE.N    ??set_z_fade_height_1
// 3007         if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
        CMP      R6,#+0
        BEQ.N    ??set_z_fade_height_1
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 3008       //#endif
// 3009 
// 3010       planner.set_z_fade_height(zfh);
??set_z_fade_height_1:
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner17set_z_fade_heightERKf
        BL       _ZN7Planner17set_z_fade_heightERKf
// 3011 
// 3012       if (level_active) {
        CMP      R6,#+0
        BEQ.N    ??set_z_fade_height_0
// 3013         const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
        LDR.W    R6,??DataTable149_2
        LDR      R0,[R6, #+8]
        STR      R0,[SP, #+0]
        LDR      R0,[R6, #+12]
        STR      R0,[SP, #+4]
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+8]
// 3014         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 3015         if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
        LDRB     R0,[R5, #+64]
        CMP      R0,#+16
        BNE.N    ??set_z_fade_height_2
// 3016           set_bed_leveling_enabled(true);  // turn back on after changing fade height
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.N      ??set_z_fade_height_3
// 3017         //#else
// 3018         else
// 3019         {
// 3020         /*
// 3021           set_current_from_steppers_for_axis(
// 3022             #if ABL_PLANAR
// 3023               ALL_AXES
// 3024             #else
// 3025               Z_AXIS
// 3026             #endif
// 3027           );
// 3028             */
// 3029           if(BED_LEVELING_METHOD&ABL_PLANAR)
??set_z_fade_height_2:
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??set_z_fade_height_4
// 3030           {
// 3031             set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
        B.N      ??set_z_fade_height_5
// 3032           }
// 3033           else
// 3034           {
// 3035             set_current_from_steppers_for_axis(Z_AXIS);
??set_z_fade_height_4:
        MOVS     R0,#+2
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 3036           }
// 3037             
// 3038           SYNC_PLAN_POSITION_KINEMATIC();
??set_z_fade_height_5:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3039         }
// 3040         //#endif
// 3041         if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
??set_z_fade_height_3:
        CMP      R4,#+0
        BEQ.N    ??set_z_fade_height_0
        MOVS     R2,#+12
        ADD      R1,R6,#+8
        ADD      R0,SP,#+0
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??set_z_fade_height_0
// 3042           report_current_position();
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
// 3043       }
// 3044     }
??set_z_fade_height_0:
        POP      {R0-R6,PC}       ;; return
          CFI EndBlock cfiBlock43
// 3045 
// 3046   #endif // LEVELING_FADE_HEIGHT
// 3047 
// 3048   /**
// 3049    * Reset calibration results to zero.
// 3050    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function _Z15reset_bed_levelv
        THUMB
// 3051   void reset_bed_level() {
_Z15reset_bed_levelv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3052     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3053       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 3054     #endif
// 3055     set_bed_leveling_enabled(false);
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 3056     //#if ENABLED(MESH_BED_LEVELING)
// 3057     if(BED_LEVELING_METHOD==MESH_BED_LEVELING)
        LDR.W    R0,??DataTable149_1
        LDRB     R1,[R0, #+64]
        MOV      R2,R1
        CMP      R2,#+32
        BNE.N    ??reset_bed_level_0
// 3058     {
// 3059       if (leveling_is_valid()) {
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??reset_bed_level_1
// 3060         mbl.reset();
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
// 3061         mbl.has_mesh = false;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable151
        STRB     R0,[R1, #+0]
        POP      {R4,PC}
// 3062       }
// 3063     }
// 3064     //#elif ENABLED(AUTO_BED_LEVELING_UBL)
// 3065     else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
??reset_bed_level_0:
        CMP      R2,#+16
        BNE.N    ??reset_bed_level_2
// 3066       ubl.reset();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN20unified_bed_leveling5resetEv
        B.W      _ZN20unified_bed_leveling5resetEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3067     //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3068     else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
??reset_bed_level_2:
        CMP      R2,#+8
        BNE.N    ??reset_bed_level_3
// 3069     {
// 3070       bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 3071       bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
        LDR.N    R1,??DataTable139
        MOVS     R2,#+0
        STR      R2,[R1, #+20]
        STR      R2,[R1, #+16]
        STR      R2,[R1, #+28]
        STR      R2,[R1, #+24]
// 3072       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
        MOV      R1,R2
        B.N      ??reset_bed_level_4
// 3073         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3074           z_values[x][y] = NAN;
??reset_bed_level_5:
        ADD      R3,R1,R1, LSL #+1
        LDR.W    R4,??DataTable154
        ADD      R3,R4,R3, LSL #+4
        MVN      R4,#-2147483648
        STR      R4,[R3, R2, LSL #+2]
        ADDS     R2,R2,#+1
??reset_bed_level_6:
        LDRB     R3,[R0, #+97]
        UXTB     R2,R2
        CMP      R2,R3
        BCC.N    ??reset_bed_level_5
        ADDS     R1,R1,#+1
        UXTB     R1,R1
??reset_bed_level_4:
        LDRB     R2,[R0, #+96]
        CMP      R1,R2
        BGE.N    ??reset_bed_level_1
        MOVS     R2,#+0
        B.N      ??reset_bed_level_6
// 3075     }
// 3076     //#elif ABL_PLANAR
// 3077     else if(BED_LEVELING_METHOD&ABL_PLANAR)
??reset_bed_level_3:
        MOVS     R0,#+6
        TST      R1,R0
        BEQ.N    ??reset_bed_level_1
// 3078       planner.bed_level_matrix.set_to_identity();
        LDR.W    R0,??DataTable154_1
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10matrix_3x315set_to_identityEv
        B.W      _ZN10matrix_3x315set_to_identityEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3079     //#endif
// 3080   }
??reset_bed_level_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock44

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_1:
        DC32     gCfgItems
// 3081 
// 3082 #endif // HAS_LEVELING
// 3083 
// 3084 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
// 3085 
// 3086   /**
// 3087    * Enable to produce output in JSON format suitable
// 3088    * for SCAD or JavaScript mesh visualizers.
// 3089    *
// 3090    * Visualize meshes in OpenSCAD using the included script.
// 3091    *
// 3092    *   buildroot/shared/scripts/MarlinMesh.scad
// 3093    */
// 3094   //#define SCAD_MESH_OUTPUT
// 3095 
// 3096   /**
// 3097    * Print calibration results for plotting or manual frame adjustment.
// 3098    */
// 3099   //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function _Z14print_2d_arrayhhhh
        THUMB
// 3100     static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
_Z14print_2d_arrayhhhh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R9,R0
        MOV      R10,R1
        MOV      R4,R2
        MOV      R8,R3
// 3101     #ifndef SCAD_MESH_OUTPUT
// 3102       for (uint8_t x = 0; x < sx; x++) {
        MOVS     R6,#+0
        LDR.W    R5,??DataTable154_2
        B.N      ??print_2d_array_0
// 3103         for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
??print_2d_array_1:
        MOVS     R0,#+0
??print_2d_array_2:
        UXTB     R7,R7
        ADDS     R0,R0,R4
        ADDS     R0,R0,#+2
        CMP      R7,R0
        BLT.N    ??print_2d_array_3
// 3104           SERIAL_PROTOCOLCHAR(' ');
// 3105         SERIAL_PROTOCOL((int)x);
        MOVS     R2,#+10
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??print_2d_array_0:
        CMP      R6,R9
        BGE.N    ??print_2d_array_4
        MOVS     R7,#+0
        B.N      ??print_2d_array_5
??print_2d_array_3:
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADDS     R7,R7,#+1
??print_2d_array_5:
        CMP      R6,#+10
        BGE.N    ??print_2d_array_1
        MOVS     R0,#+1
        B.N      ??print_2d_array_2
// 3106       }
// 3107       SERIAL_EOL();
??print_2d_array_4:
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3108     #endif
// 3109     #ifdef SCAD_MESH_OUTPUT
// 3110       SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
// 3111     #endif
// 3112     for (uint8_t y = 0; y < sy; y++) {
        MOVS     R6,#+0
        B.N      ??print_2d_array_6
// 3113       #ifdef SCAD_MESH_OUTPUT
// 3114         SERIAL_PROTOCOLPGM(" [");           // open sub-array
// 3115       #else
// 3116         if (y < 10) SERIAL_PROTOCOLCHAR(' ');
// 3117         SERIAL_PROTOCOL((int)y);
// 3118       #endif
// 3119       for (uint8_t x = 0; x < sx; x++) {
// 3120         SERIAL_PROTOCOLCHAR(' ');
// 3121         //const float offset = fn(x, y);
// 3122         float offset;
// 3123 		switch(fn)
// 3124 		{
// 3125 			case 0:	
// 3126 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 3127 				offset =z_values[x][y];
// 3128 			break;
// 3129 			case 1:	
// 3130 			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3131 				offset =z_values_virt[x][y];	
// 3132 			#endif
// 3133 			break;
// 3134 			case 2:	
// 3135 				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 3136                    offset =mbl.z_values[x][y];		
// 3137                           break;
// 3138 			default:		break;
// 3139 		}        
// 3140         if (!isnan(offset)) {
// 3141           if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
// 3142           SERIAL_PROTOCOL_F(offset, precision);
// 3143         }
// 3144         else {
// 3145           #ifdef SCAD_MESH_OUTPUT
// 3146             for (uint8_t i = 3; i < precision + 3; i++)
// 3147               SERIAL_PROTOCOLCHAR(' ');
// 3148             SERIAL_PROTOCOLPGM("NAN");
// 3149           #else
// 3150             for (uint8_t i = 0; i < precision + 3; i++)
// 3151               SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
// 3152           #endif
// 3153         }
// 3154         #ifdef SCAD_MESH_OUTPUT
// 3155           if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
// 3156         #endif
// 3157       }
// 3158       #ifdef SCAD_MESH_OUTPUT
// 3159         SERIAL_PROTOCOLCHAR(' ');
// 3160         SERIAL_PROTOCOLCHAR(']');                     // close sub-array
// 3161         if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
// 3162       #endif
// 3163       SERIAL_EOL();
??print_2d_array_7:
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??print_2d_array_6:
        CMP      R6,R10
        BGE.N    ??print_2d_array_8
        CMP      R6,#+10
        BGE.N    ??print_2d_array_9
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??print_2d_array_9:
        MOVS     R2,#+10
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        MOVS     R7,#+0
        B.N      ??print_2d_array_10
??print_2d_array_11:
        LDR.W    R0,??DataTable149_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??print_2d_array_12
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable154_5
        ADD      R0,R1,R0, LSL #+4
        LDR      R11,[R0, R6, LSL #+2]
??print_2d_array_12:
        MOV      R0,R11
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_13
        MOV      R0,R11
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??print_2d_array_14
        MOVS     R1,#+43
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??print_2d_array_14:
        STR      R4,[SP, #+0]
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
??print_2d_array_15:
        ADDS     R7,R7,#+1
        UXTB     R7,R7
??print_2d_array_10:
        CMP      R7,R9
        BGE.N    ??print_2d_array_7
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOV      R0,R8
        CMP      R0,#+0
        BEQ.N    ??print_2d_array_16
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_11
        B.N      ??print_2d_array_12
??print_2d_array_16:
        LDR.W    R0,??DataTable149_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??print_2d_array_12
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable154
        ADD      R0,R1,R0, LSL #+4
        LDR      R11,[R0, R6, LSL #+2]
        B.N      ??print_2d_array_12
??print_2d_array_13:
        MOV      R11,#+0
        B.N      ??print_2d_array_17
??print_2d_array_18:
        MOVS     R1,#+32
??print_2d_array_19:
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      R11,R11,#+1
??print_2d_array_17:
        UXTB     R11,R11
        ADDS     R0,R4,#+3
        CMP      R11,R0
        BGE.N    ??print_2d_array_15
        CMP      R11,#+0
        BEQ.N    ??print_2d_array_18
        MOVS     R1,#+61
        B.N      ??print_2d_array_19
// 3164     }
// 3165     #ifdef SCAD_MESH_OUTPUT
// 3166       SERIAL_PROTOCOLPGM("];");                       // close 2D array
// 3167     #endif
// 3168     SERIAL_EOL();
??print_2d_array_8:
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock45
// 3169   }
// 3170 
// 3171 #endif
// 3172 
// 3173 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3174 
// 3175   /**
// 3176    * Extrapolate a single point from its neighbors
// 3177    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function _Z21extrapolate_one_pointhhaa
        THUMB
// 3178   static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
_Z21extrapolate_one_pointhhaa:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R10,R0
        MOV      R9,R1
        MOV      R7,R2
        MOV      R8,R3
// 3179     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3180       if (DEBUGGING(LEVELING)) {
// 3181         SERIAL_ECHOPGM("Extrapolate [");
// 3182         if (x < 10) SERIAL_CHAR(' ');
// 3183         SERIAL_ECHO((int)x);
// 3184         SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
// 3185         SERIAL_CHAR(' ');
// 3186         if (y < 10) SERIAL_CHAR(' ');
// 3187         SERIAL_ECHO((int)y);
// 3188         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
// 3189         SERIAL_CHAR(']');
// 3190       }
// 3191     #endif
// 3192     if (!isnan(z_values[x][y])) {
        MOVS     R5,#+48
        LDR.W    R6,??DataTable154
        MLA      R0,R5,R10,R6
        STR      R0,[SP, #+0]
        MOV      R4,R9
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_0
// 3193       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3194         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
// 3195       #endif
// 3196       return;  // Don't overwrite good values.
// 3197     }
// 3198     SERIAL_EOL();
        MOVS     R1,#+10
        LDR.W    R0,??DataTable154_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3199 
// 3200     // Get X neighbors, Y neighbors, and XY neighbors
// 3201     const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
        ADD      R2,R7,R10
        UXTB     R2,R2
        ADD      R0,R8,R9
        UXTB     R0,R0
        ADDS     R3,R7,R2
        UXTB     R3,R3
        ADD      R1,R8,R0
        UXTB     R1,R1
// 3202     float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
        MLA      R2,R5,R2,R6
        LDR      R7,[R2, R4, LSL #+2]
        MLA      R3,R5,R3,R6
        LDR      R5,[R3, R4, LSL #+2]
// 3203           b1 = z_values[x ][y1], b2 = z_values[x ][y2],
        LDR      R6,[SP, #+0]
        LDR      R6,[R6, R0, LSL #+2]
        LDR      R12,[SP, #+0]
        LDR      R8,[R12, R1, LSL #+2]
// 3204           c1 = z_values[x1][y1], c2 = z_values[x2][y2];
        LDR      R9,[R2, R0, LSL #+2]
        LDR      R10,[R3, R1, LSL #+2]
// 3205 
// 3206     // Treat far unprobed points as zero, near as equal to far
// 3207     if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
        MOV      R0,R5
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_1
        MOVS     R5,#+0
??extrapolate_one_point_1:
        MOV      R0,R7
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_2
        MOV      R7,R5
// 3208     if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
??extrapolate_one_point_2:
        MOV      R0,R8
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_3
        MOV      R8,#+0
??extrapolate_one_point_3:
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_4
        MOV      R6,R8
// 3209     if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
??extrapolate_one_point_4:
        MOV      R0,R10
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_5
        MOV      R10,#+0
??extrapolate_one_point_5:
        MOV      R0,R9
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_6
        MOV      R9,R10
// 3210 
// 3211     const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
// 3212 
// 3213     // Take the average instead of the median
// 3214     z_values[x][y] = (a + b + c) / 3.0;
??extrapolate_one_point_6:
        MOV      R11,#+1073741824
        MOV      R0,R7
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable155_2  ;; 0x40400000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[SP, #+0]
        STR      R0,[R1, R4, LSL #+2]
// 3215 
// 3216     // Median is robust (ignores outliers).
// 3217     // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
// 3218     //                                : ((c < b) ? b : (a < c) ? a : c);
// 3219   }
??extrapolate_one_point_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock46
// 3220 
// 3221   //Enable this if your SCARA uses 180掳 of total area
// 3222   //#define EXTRAPOLATE_FROM_EDGE
// 3223 
// 3224   #if ENABLED(EXTRAPOLATE_FROM_EDGE)
// 3225     #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
// 3226       #define HALF_IN_X
// 3227     #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
// 3228       #define HALF_IN_Y
// 3229     #endif
// 3230   #endif
// 3231 
// 3232   /**
// 3233    * Fill in the unprobed points (corners of circular print surface)
// 3234    * using linear extrapolation, away from the center.
// 3235    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function _Z30extrapolate_unprobed_bed_levelv
        THUMB
// 3236   static void extrapolate_unprobed_bed_level() {
_Z30extrapolate_unprobed_bed_levelv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
// 3237     #ifdef HALF_IN_X
// 3238       constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
// 3239     #else
// 3240       constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
        LDR.W    R0,??DataTable149_1
        LDRB     R1,[R0, #+96]
        SUBS     R2,R1,#+1
        ADD      R2,R2,R2, LSR #+31
        ASRS     R4,R2,#+1
        UXTB     R4,R4
// 3241                         ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
        LSRS     R1,R1,#+1
        STR      R1,[SP, #+12]
// 3242                         xlen = ctrx1;
        MOV      R1,R4
        STR      R1,[SP, #+8]
        ADDS     R0,R0,#+96
        LDRB     R0,[R0, #+1]
        SUBS     R1,R0,#+1
        ADD      R1,R1,R1, LSR #+31
        ASRS     R5,R1,#+1
        UXTB     R5,R5
// 3243     #endif
// 3244 
// 3245     #ifdef HALF_IN_Y
// 3246       constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
// 3247     #else
// 3248       constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
// 3249                         ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
        LSRS     R0,R0,#+1
        STR      R0,[SP, #+4]
// 3250                         ylen = ctry1;
        MOV      R0,R5
        STR      R0,[SP, #+0]
// 3251     #endif
// 3252 
// 3253     for (uint8_t xo = 0; xo <= xlen; xo++)
        MOVS     R6,#+0
        B.N      ??extrapolate_unprobed_bed_level_0
// 3254       for (uint8_t yo = 0; yo <= ylen; yo++) {
// 3255         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
??extrapolate_unprobed_bed_level_1:
        LDR      R0,[SP, #+12]
        ADD      R8,R6,R0
        LDR      R0,[SP, #+4]
        ADD      R9,R7,R0
// 3256         #ifndef HALF_IN_X
// 3257           const uint8_t x1 = ctrx1 - xo;
// 3258         #endif
// 3259         #ifndef HALF_IN_Y
// 3260           const uint8_t y1 = ctry1 - yo;
        SUB      R11,R5,R7
// 3261           #ifndef HALF_IN_X
// 3262             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R11
        UXTB     R1,R1
        MOV      R0,R10
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3263           #endif
// 3264           extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
        MOVS     R3,#+1
        MOV      R2,#-1
        MOV      R1,R11
        UXTB     R1,R1
        MOV      R0,R8
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3265         #endif
// 3266         #ifndef HALF_IN_X
// 3267           extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
        MOV      R3,#-1
        MOVS     R2,#+1
        MOV      R1,R9
        UXTB     R1,R1
        MOV      R0,R10
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3268         #endif
// 3269         extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
        MOV      R3,#-1
        MOV      R2,R3
        MOV      R1,R9
        UXTB     R1,R1
        MOV      R0,R8
        UXTB     R0,R0
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3270       }
        ADDS     R7,R7,#+1
        UXTB     R7,R7
??extrapolate_unprobed_bed_level_2:
        LDR      R0,[SP, #+0]
        CMP      R0,R7
        BGE.N    ??extrapolate_unprobed_bed_level_1
        ADDS     R6,R6,#+1
        UXTB     R6,R6
??extrapolate_unprobed_bed_level_0:
        LDR      R0,[SP, #+8]
        CMP      R0,R6
        BLT.N    ??extrapolate_unprobed_bed_level_3
        MOVS     R7,#+0
        SUB      R10,R4,R6
        B.N      ??extrapolate_unprobed_bed_level_2
// 3271 
// 3272   }
??extrapolate_unprobed_bed_level_3:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock47
// 3273 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI Function _Z28print_bilinear_leveling_gridv
        THUMB
// 3274   static void print_bilinear_leveling_grid() {
_Z28print_bilinear_leveling_gridv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3275     SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
        ADR.W    R0,`?<Constant "Bilinear Leveling Grid:\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3276     /*
// 3277     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
// 3278       [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
// 3279     );
// 3280     */
// 3281     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
        LDR.W    R0,??DataTable149_1
        MOVS     R3,#+0
        MOVS     R2,#+3
        LDRB     R1,[R0, #+97]
        LDRB     R0,[R0, #+96]
        POP      {R12,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14print_2d_arrayhhhh
        B.N      _Z14print_2d_arrayhhhh
          CFI EndBlock cfiBlock48
// 3282   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Bilinear Leveling Grid:\\n">`:
        DC8 "Bilinear Leveling Grid:\012"
        DC8 0, 0, 0
// 3283 
// 3284   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3285 
// 3286     #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3287     #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3288     #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
// 3289     #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
// 3290     float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
// 3291     int bilinear_grid_spacing_virt[2] = { 0 };
// 3292     float bilinear_grid_factor_virt[2] = { 0 };
// 3293 
// 3294     static void print_bilinear_leveling_grid_virt() {
// 3295       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
// 3296       /*
// 3297       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
// 3298         [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
// 3299       );
// 3300       */
// 3301       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
// 3302     }
// 3303 
// 3304     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
// 3305     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
// 3306       uint8_t ep = 0, ip = 1;
// 3307       if (!x || x == ABL_TEMP_POINTS_X - 1) {
// 3308         if (x) {
// 3309           ep = GRID_MAX_POINTS_X - 1;
// 3310           ip = GRID_MAX_POINTS_X - 2;
// 3311         }
// 3312         if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
// 3313           return LINEAR_EXTRAPOLATION(
// 3314             z_values[ep][y - 1],
// 3315             z_values[ip][y - 1]
// 3316           );
// 3317         else
// 3318           return LINEAR_EXTRAPOLATION(
// 3319             bed_level_virt_coord(ep + 1, y),
// 3320             bed_level_virt_coord(ip + 1, y)
// 3321           );
// 3322       }
// 3323       if (!y || y == ABL_TEMP_POINTS_Y - 1) {
// 3324         if (y) {
// 3325           ep = GRID_MAX_POINTS_Y - 1;
// 3326           ip = GRID_MAX_POINTS_Y - 2;
// 3327         }
// 3328         if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
// 3329           return LINEAR_EXTRAPOLATION(
// 3330             z_values[x - 1][ep],
// 3331             z_values[x - 1][ip]
// 3332           );
// 3333         else
// 3334           return LINEAR_EXTRAPOLATION(
// 3335             bed_level_virt_coord(x, ep + 1),
// 3336             bed_level_virt_coord(x, ip + 1)
// 3337           );
// 3338       }
// 3339       return z_values[x - 1][y - 1];
// 3340     }
// 3341 
// 3342     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
// 3343       return (
// 3344           p[i-1] * -t * sq(1 - t)
// 3345         + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
// 3346         + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
// 3347         - p[i+2] * sq(t) * (1 - t)
// 3348       ) * 0.5;
// 3349     }
// 3350 
// 3351     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
// 3352       float row[4], column[4];
// 3353       for (uint8_t i = 0; i < 4; i++) {
// 3354         for (uint8_t j = 0; j < 4; j++) {
// 3355           column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
// 3356         }
// 3357         row[i] = bed_level_virt_cmr(column, 1, ty);
// 3358       }
// 3359       return bed_level_virt_cmr(row, 1, tx);
// 3360     }
// 3361 
// 3362     void bed_level_virt_interpolate() {
// 3363       bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3364       bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3365       bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
// 3366       bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
// 3367       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3368         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 3369           for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
// 3370             for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
// 3371               if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
// 3372                 continue;
// 3373               z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
// 3374                 bed_level_virt_2cmr(
// 3375                   x + 1,
// 3376                   y + 1,
// 3377                   (float)tx / (BILINEAR_SUBDIVISIONS),
// 3378                   (float)ty / (BILINEAR_SUBDIVISIONS)
// 3379                 );
// 3380             }
// 3381     }
// 3382   #endif // ABL_BILINEAR_SUBDIVISION
// 3383 
// 3384   // Refresh after other values have been updated

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function _Z17refresh_bed_levelv
        THUMB
// 3385   void refresh_bed_level() {
_Z17refresh_bed_levelv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3386     bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
        LDR.W    R4,??DataTable154_7
        LDR      R0,[R4, #+16]
        CMP      R0,#+0
        BNE.N    ??refresh_bed_level_0
        MOVS     R0,#+0
        STR      R0,[R4, #+32]
        B.N      ??refresh_bed_level_1
??refresh_bed_level_0:
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable155_3  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+32]
// 3387     bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
??refresh_bed_level_1:
        LDR      R0,[R4, #+20]
        CMP      R0,#+0
        BNE.N    ??refresh_bed_level_2
        MOVS     R0,#+0
        STR      R0,[R4, #+36]
        POP      {R4,PC}
??refresh_bed_level_2:
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable155_3  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+36]
// 3388     #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3389       bed_level_virt_interpolate();
// 3390     #endif
// 3391   }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock49

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144:
        DC32     0x3f847ae1
// 3392 
// 3393 #endif // AUTO_BED_LEVELING_BILINEAR
// 3394 
// 3395 /**
// 3396  * Home an individual linear axis
// 3397  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function _Z14do_homing_move8AxisEnumff
        THUMB
// 3398 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
_Z14do_homing_move8AxisEnumff:
        PUSH     {R1-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+40
        MOV      R9,R0
        MOV      R8,R1
        MOV      R7,R2
// 3399 
// 3400   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3401     if (DEBUGGING(LEVELING)) {
// 3402       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
// 3403       SERIAL_ECHOPAIR(", ", distance);
// 3404       SERIAL_ECHOPAIR(", ", fr_mm_s);
// 3405       SERIAL_CHAR(')');
// 3406       SERIAL_EOL();
// 3407     }
// 3408   #endif
// 3409 
// 3410   //#if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3411   #if HOMING_Z_WITH_PROBE
// 3412     //const 
// 3413     bool deploy_bltouch;
// 3414   if(MKSTOUCH == 1)
        LDR.W    R5,??DataTable149_1
        LDRB     R0,[R5, #+256]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_0
// 3415   {
// 3416   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??do_homing_move_0
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_0
// 3417     deploy_bltouch = (axis == Z_AXIS && distance < 0);
        CMP      R9,#+2
        BNE.N    ??do_homing_move_1
        MOV      R0,R8
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_homing_move_1
        MOVS     R4,#+1
        B.N      ??do_homing_move_2
??do_homing_move_1:
        MOVS     R4,#+0
// 3418     if (deploy_bltouch) set_bltouch_deployed(true);
??do_homing_move_2:
        CMP      R4,#+0
        BEQ.N    ??do_homing_move_0
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 3419     }
// 3420   }
// 3421   #endif
// 3422 
// 3423   #if QUIET_PROBING
// 3424     if (axis == Z_AXIS) probing_pause(true);
// 3425   #endif
// 3426 
// 3427   // Tell the planner the axis is at 0
// 3428   current_position[axis] = 0;
??do_homing_move_0:
        LDR.W    R6,??DataTable149_2
        ADD      R9,R6,R9, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R9, #+8]
// 3429 
// 3430   //#if IS_SCARA
// 3431   if(MACHINETPYE&IS_SCARA)
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??do_homing_move_3
// 3432   {
// 3433     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3434     current_position[axis] = distance;
        STR      R8,[R9, #+8]
// 3435     if(MACHINETPYE&IS_SCARA)
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        ADD      R0,R6,#+8
        BEQ.N    ??do_homing_move_4
// 3436 		inverse_kinematics_MORGAN_SCARA(current_position);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??do_homing_move_5
// 3437 	else
// 3438         inverse_kinematics(current_position);
??do_homing_move_4:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 3439     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
??do_homing_move_5:
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_homing_move_6
        STR      R7,[SP, #+8]
        B.N      ??do_homing_move_7
??do_homing_move_6:
        LDR      R0,[R9, #+40]
        STR      R0,[SP, #+8]
??do_homing_move_7:
        LDRB     R0,[R6, #+3]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,R6,#+20
        LDR      R2,[R6, #+88]
        LDR      R1,[R6, #+84]
        LDR      R0,[R6, #+80]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        B.N      ??do_homing_move_8
// 3440   }
// 3441   //#else
// 3442   else
// 3443   {
// 3444     sync_plan_position();
??do_homing_move_3:
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3445     current_position[axis] = distance;
        STR      R8,[R9, #+8]
// 3446     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??do_homing_move_9
        STR      R7,[SP, #+8]
        B.N      ??do_homing_move_10
??do_homing_move_9:
        LDR      R0,[R9, #+40]
        STR      R0,[SP, #+8]
??do_homing_move_10:
        LDRB     R0,[R6, #+3]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,R6,#+20
        LDR      R2,[R6, #+16]
        LDR      R1,[R6, #+12]
        LDR      R0,[R6, #+8]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
// 3447   }
// 3448   //#endif
// 3449 
// 3450   stepper.synchronize();
??do_homing_move_8:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 3451 
// 3452   #if QUIET_PROBING
// 3453     if (axis == Z_AXIS) probing_pause(false);
// 3454   #endif
// 3455 
// 3456   #if HOMING_Z_WITH_PROBE //&& ENABLED(BLTOUCH)
// 3457   if(MKSTOUCH == 1)
        LDRB     R0,[R5, #+256]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_11
// 3458   {
// 3459     if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??do_homing_move_11
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_11
// 3460     {
// 3461         if (deploy_bltouch) set_bltouch_deployed(false);
        UXTB     R4,R4
        CMP      R4,#+0
        BEQ.N    ??do_homing_move_11
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 3462     }
// 3463   }
// 3464   #endif
// 3465 
// 3466   endstops.hit_on_purpose();
??do_homing_move_11:
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 3467 
// 3468   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3469     if (DEBUGGING(LEVELING)) {
// 3470       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
// 3471       SERIAL_CHAR(')');
// 3472       SERIAL_EOL();
// 3473     }
// 3474   #endif
// 3475 }
        POP      {R0-R2,R4-R9,PC}  ;; return
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145:
        DC32     mks_heating_busy+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_1:
        DC32     saved_feedrate_percentage

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_2:
        DC32     0x40012c34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_3:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_4:
        DC32     gArrayGpioPin
// 3476 
// 3477 /**
// 3478  * TMC2130 specific sensorless homing using stallGuard2.
// 3479  * stallGuard2 only works when in spreadCycle mode.
// 3480  * spreadCycle and stealthChop are mutually exclusive.
// 3481  */
// 3482 #if ENABLED(SENSORLESS_HOMING)
// 3483   template<typename TMC>
// 3484   void tmc_sensorless_homing(TMC &st, bool enable=true) {
// 3485     #if ENABLED(STEALTHCHOP)
// 3486       if (enable) {
// 3487         st.coolstep_min_speed(1024UL * 1024UL - 1UL);
// 3488         st.stealthChop(0);
// 3489       }
// 3490       else {
// 3491         st.coolstep_min_speed(0);
// 3492         st.stealthChop(1);
// 3493       }
// 3494     #endif
// 3495 
// 3496     st.diag1_stall(enable ? 1 : 0);
// 3497   }
// 3498 #endif
// 3499 
// 3500 /**
// 3501  * Home an individual "raw axis" to its endstop.
// 3502  * This applies to XYZ on Cartesian and Core robots, and
// 3503  * to the individual ABC steppers on DELTA and SCARA.
// 3504  *
// 3505  * At the end of the procedure the axis is marked as
// 3506  * homed and the current position of that axis is updated.
// 3507  * Kinematic robots should wait till all axes are homed
// 3508  * before updating the current position.
// 3509  */
// 3510 
// 3511 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
// 3512 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function _Z8homeaxis8AxisEnum
        THUMB
// 3513 static void homeaxis(const AxisEnum axis) {
_Z8homeaxis8AxisEnum:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
// 3514 
// 3515 #define CAN_HOME(A) \ 
// 3516     (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
// 3517 
// 3518   //#if IS_SCARA
// 3519   if(MACHINETPYE&IS_SCARA)
        LDR.W    R5,??DataTable149_1
        ADDW     R8,R5,#+5
        MOV      R6,R4
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??homeaxis_0
// 3520   {
// 3521     // Only Z homing (with probe) is permitted
// 3522     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
        CMP      R6,#+2
        BEQ.N    ??homeaxis_1
        B.N      ??homeaxis_2
// 3523   }
// 3524   //#else
// 3525   else
// 3526    {
// 3527     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
??homeaxis_0:
        CMP      R4,#+0
        BNE.N    ??homeaxis_3
        LDRSB    R0,[R5, #+5]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
??homeaxis_3:
        CMP      R6,#+1
        BNE.N    ??homeaxis_4
        LDRSB    R0,[R8, #+1]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
??homeaxis_4:
        CMP      R6,#+2
        BNE.W    ??homeaxis_2
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BEQ.W    ??homeaxis_2
// 3528    }
// 3529   //#endif
// 3530 
// 3531   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3532     if (DEBUGGING(LEVELING)) {
// 3533       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
// 3534       SERIAL_CHAR(')');
// 3535       SERIAL_EOL();
// 3536     }
// 3537   #endif
// 3538 
// 3539   const int axis_home_dir =
// 3540     #if ENABLED(DUAL_X_CARRIAGE)
// 3541       (axis == X_AXIS) ? x_home_dir(active_extruder) :
// 3542     #endif
// 3543     home_dir(axis);
??homeaxis_1:
        MOV      R0,R4
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        MOV      R7,R0
// 3544 
// 3545   // Homing Z towards the bed? Deploy the Z probe or endstop.
// 3546   #if HOMING_Z_WITH_PROBE
// 3547   
// 3548   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_5
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_5
// 3549   {
// 3550     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
        CMP      R6,#+2
        BNE.N    ??homeaxis_5
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.W    ??homeaxis_2
// 3551   }
// 3552   #endif
// 3553 
// 3554   // Set flags for X, Y, Z motor locking
// 3555   #if ENABLED(X_DUAL_ENDSTOPS)
// 3556     if (axis == X_AXIS) stepper.set_homing_flag_x(true);
// 3557   #endif
// 3558   #if ENABLED(Y_DUAL_ENDSTOPS)
// 3559     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
// 3560   #endif
// 3561   #if 1//ENABLED(Z_DUAL_ENDSTOPS)
// 3562     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
??homeaxis_5:
        CMP      R6,#+2
        BNE.N    ??homeaxis_6
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper17set_homing_flag_zEb
        BL       _ZN7Stepper17set_homing_flag_zEb
// 3563   #endif
// 3564 
// 3565   // Disable stealthChop if used. Enable diag1 pin on driver.
// 3566   #if ENABLED(SENSORLESS_HOMING)
// 3567     #if ENABLED(X_IS_TMC2130)
// 3568       if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
// 3569     #endif
// 3570     #if ENABLED(Y_IS_TMC2130)
// 3571       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
// 3572     #endif
// 3573   #endif
// 3574 
// 3575   // Fast move towards endstop until triggered
// 3576   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3577     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
// 3578   #endif
// 3579   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
??homeaxis_6:
        MOV      R0,R4
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        MOVS     R2,#+0
        MOV      R9,R2
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R9
        LDR.W    R3,??DataTable155_4  ;; 0x3ff80000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOV      R2,R9
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3580 
// 3581   // When homing Z with probe respect probe clearance
// 3582   /*
// 3583   const float bump = axis_home_dir * (
// 3584     #if HOMING_Z_WITH_PROBE
// 3585       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
// 3586     #endif
// 3587     home_bump_mm(axis)
// 3588   );
// 3589   */
// 3590     float bump = 0;
// 3591     #if HOMING_Z_WITH_PROBE
// 3592         if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))    /*--mks cfg--*/
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_7
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_7
// 3593             bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
        CMP      R6,#+2
        BNE.N    ??homeaxis_8
        ADD      R0,R5,#+88
        LDR      R9,[R0, #+16]
        MOVS     R0,#+2
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R1,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??homeaxis_9
        MOVS     R0,#+2
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R9,R0
        B.N      ??homeaxis_9
??homeaxis_8:
        MOV      R0,R4
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R9,R0
??homeaxis_9:
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        B.N      ??homeaxis_10
// 3594         else
// 3595             bump = axis_home_dir *home_bump_mm(axis);
??homeaxis_7:
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R9,R0
        MOV      R0,R4
          CFI FunCall _Z12home_bump_mm8AxisEnum
        BL       _Z12home_bump_mm8AxisEnum
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
// 3596     #else
// 3597         bump = axis_home_dir *home_bump_mm(axis);
// 3598     #endif
// 3599 
// 3600   // If a second homing move is configured...
// 3601   if (bump) {
??homeaxis_10:
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??homeaxis_11
// 3602     // Move away from the endstop by the axis HOME_BUMP_MM
// 3603     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3604       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
// 3605     #endif
// 3606     do_homing_move(axis, -bump);
        MOV      R2,R1
        MOV      R1,R9
        EOR      R1,R1,#0x80000000
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3607 
// 3608     // Slow move towards endstop until triggered
// 3609     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3610       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
// 3611     #endif
// 3612     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
        MOV      R0,R4
          CFI FunCall _Z24get_homing_bump_feedrate8AxisEnum
        BL       _Z24get_homing_bump_feedrate8AxisEnum
        MOV      R2,R0
        MOV      R10,R2
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R2,R10
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3613   }
// 3614 
// 3615   /**
// 3616    * Home axes that have dual endstops... differently
// 3617    */
// 3618   #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 3619     const bool pos_dir = axis_home_dir > 0;
??homeaxis_11:
        CMP      R7,#+1
        BLT.N    ??homeaxis_12
        MOVS     R7,#+1
        B.N      ??homeaxis_13
??homeaxis_12:
        MOVS     R7,#+0
// 3620     #if ENABLED(X_DUAL_ENDSTOPS)
// 3621       if (axis == X_AXIS) {
// 3622         const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
// 3623         const float adj = FABS(x_endstop_adj);
// 3624         if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
// 3625         do_homing_move(axis, pos_dir ? -adj : adj);
// 3626         if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
// 3627         stepper.set_homing_flag_x(false);
// 3628       }
// 3629     #endif
// 3630     #if ENABLED(Y_DUAL_ENDSTOPS)
// 3631       if (axis == Y_AXIS) {
// 3632         const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
// 3633         const float adj = FABS(y_endstop_adj);
// 3634         if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
// 3635         do_homing_move(axis, pos_dir ? -adj : adj);
// 3636         if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
// 3637         stepper.set_homing_flag_y(false);
// 3638       }
// 3639     #endif
// 3640     //#if ENABLED(Z_DUAL_ENDSTOPS)
// 3641     if(Z_DUAL_ENDSTOPS==1)
??homeaxis_13:
        LDRB     R0,[R5, #+258]
        CMP      R0,#+1
        BNE.N    ??homeaxis_14
// 3642     {
// 3643       if (axis == Z_AXIS) {
        CMP      R6,#+2
        BNE.N    ??homeaxis_14
// 3644         const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
        LDR.W    R0,??DataTable155_5
        LDR      R0,[R0, #+0]
        CMP      R7,#+0
        BEQ.N    ??homeaxis_15
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??homeaxis_16
        MOV      R9,#+1
        B.N      ??homeaxis_17
??homeaxis_16:
        MOV      R9,R1
        B.N      ??homeaxis_17
??homeaxis_15:
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??homeaxis_18
        MOV      R9,#+1
        B.N      ??homeaxis_17
??homeaxis_18:
        MOV      R9,R1
// 3645         const float adj = FABS(z_endstop_adj);
??homeaxis_17:
        BIC      R10,R0,#0x80000000
// 3646         if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
        CMP      R9,#+0
        BEQ.N    ??homeaxis_19
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper10set_z_lockEb
        BL       _ZN7Stepper10set_z_lockEb
        B.N      ??homeaxis_20
??homeaxis_19:
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper11set_z2_lockEb
        BL       _ZN7Stepper11set_z2_lockEb
// 3647         do_homing_move(axis, pos_dir ? -adj : adj);
??homeaxis_20:
        CMP      R7,#+0
        BEQ.N    ??homeaxis_21
        EOR      R10,R10,#0x80000000
??homeaxis_21:
        MOVS     R2,#+0
        MOV      R1,R10
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
// 3648         if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
        CMP      R9,#+0
        BEQ.N    ??homeaxis_22
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper10set_z_lockEb
        BL       _ZN7Stepper10set_z_lockEb
        B.N      ??homeaxis_23
??homeaxis_22:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper11set_z2_lockEb
        BL       _ZN7Stepper11set_z2_lockEb
// 3649         stepper.set_homing_flag_z(false);
??homeaxis_23:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper17set_homing_flag_zEb
        BL       _ZN7Stepper17set_homing_flag_zEb
// 3650       }
// 3651     }
// 3652     //#endif
// 3653   #endif
// 3654 
// 3655   //#if IS_SCARA
// 3656   if(MACHINETPYE&IS_SCARA)
??homeaxis_14:
        LDRSH    R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??homeaxis_24
// 3657   {
// 3658     set_axis_is_at_home(axis);
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
// 3659     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??homeaxis_25
// 3660   }
// 3661   //#elif ENABLED(DELTA)
// 3662   else if(MACHINETPYE == DELTA) {
??homeaxis_24:
        CMP      R0,#+2
        BNE.N    ??homeaxis_26
// 3663 
// 3664     // Delta has already moved all three towers up in G28
// 3665     // so here it re-homes each tower in turn.
// 3666     // Delta homing treats the axes as normal linear axes.
// 3667 
// 3668     // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
// 3669     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
        LDR.W    R0,??DataTable155_5
        ADD      R0,R0,R6, LSL #+2
        LDR      R10,[R0, #+4]
        LDRSB    R7,[R8, #+2]
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BHI.N    ??homeaxis_25
// 3670       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3671         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
// 3672       #endif
// 3673       do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
        MOV      R2,R1
        MOV      R9,R2
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.W    R2,??DataTable155_6  ;; 0x9999999a
        LDR.W    R3,??DataTable155_7  ;; 0x3fb99999
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOV      R2,R9
        MOV      R0,R4
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
        B.N      ??homeaxis_25
// 3674     }
// 3675   }
// 3676   //#else
// 3677   else
// 3678   {
// 3679     // For cartesian/core machines,
// 3680     // set the axis to its home position
// 3681     set_axis_is_at_home(axis);
??homeaxis_26:
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
// 3682     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3683 
// 3684     destination[axis] = current_position[axis];
        LDR.N    R0,??DataTable149_2
        ADD      R0,R0,R6, LSL #+2
        LDR      R1,[R0, #+8]
        STR      R1,[R0, #+24]
// 3685 
// 3686     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3687       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
// 3688     #endif
// 3689   }
// 3690   //#endif
// 3691 
// 3692   // Re-enable stealthChop if used. Disable diag1 pin on driver.
// 3693   #if ENABLED(SENSORLESS_HOMING)
// 3694     #if ENABLED(X_IS_TMC2130)
// 3695       if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
// 3696     #endif
// 3697     #if ENABLED(Y_IS_TMC2130)
// 3698       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
// 3699     #endif
// 3700   #endif
// 3701 
// 3702   // Put away the Z probe
// 3703   #if HOMING_Z_WITH_PROBE
// 3704   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
??homeaxis_25:
        LDRSB    R0,[R8, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_2
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_2
// 3705   {    
// 3706     if (axis == Z_AXIS && STOW_PROBE()) return;
        CMP      R6,#+2
        BNE.N    ??homeaxis_2
        MOVS     R0,#+0
        POP      {R1,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
// 3707    }
// 3708   #endif
// 3709 
// 3710   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3711     if (DEBUGGING(LEVELING)) {
// 3712       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
// 3713       SERIAL_CHAR(')');
// 3714       SERIAL_EOL();
// 3715     }
// 3716   #endif
// 3717 } // homeaxis()
??homeaxis_2:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146:
        DC32     _ZN8Endstops15z_probe_enabledE
// 3718 
// 3719 #if ENABLED(FWRETRACT)
// 3720 
// 3721   /**
// 3722    * Retract or recover according to firmware settings
// 3723    *
// 3724    * This function handles retract/recover moves for G10 and G11,
// 3725    * plus auto-retract moves sent from G0/G1 when E-only moves are done.
// 3726    *
// 3727    * To simplify the logic, doubled retract/recover moves are ignored.
// 3728    *
// 3729    * Note: Z lift is done transparently to the planner. Aborting
// 3730    *       a print between G10 and G11 may corrupt the Z position.
// 3731    *
// 3732    * Note: Auto-retract will apply the set Z hop in addition to any Z hop
// 3733    *       included in the G-code. Use M207 Z0 to to prevent double hop.
// 3734    */
// 3735   void retract(const bool retracting
// 3736     #if EXTRUDERS > 1
// 3737       , bool swapping = false
// 3738     #endif
// 3739   ) {
// 3740 
// 3741     static float hop_amount = 0.0;  // Total amount lifted, for use in recover
// 3742 
// 3743     // Prevent two retracts or recovers in a row
// 3744     if (retracted[active_extruder] == retracting) return;
// 3745 
// 3746     // Prevent two swap-retract or recovers in a row
// 3747     #if EXTRUDERS > 1
// 3748       // Allow G10 S1 only after G10
// 3749       if (swapping && retracted_swap[active_extruder] == retracting) return;
// 3750       // G11 priority to recover the long retract if activated
// 3751       if (!retracting) swapping = retracted_swap[active_extruder];
// 3752     #else
// 3753       const bool swapping = false;
// 3754     #endif
// 3755 
// 3756     /* // debugging
// 3757       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3758       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3759       SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
// 3760       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3761         SERIAL_ECHOPAIR("retracted[", i);
// 3762         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3763         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3764         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3765       }
// 3766       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3767       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3768     //*/
// 3769 
// 3770     const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
// 3771     const float old_feedrate_mm_s = feedrate_mm_s;
// 3772 
// 3773     // The current position will be the destination for E and Z moves
// 3774     set_destination_from_current();
// 3775     stepper.synchronize();  // Wait for buffered moves to complete
// 3776 
// 3777     const float renormalize = 1.0 / planner.e_factor[active_extruder];
// 3778 
// 3779     if (retracting) {
// 3780       // Retract by moving from a faux E position back to the current E position
// 3781       feedrate_mm_s = retract_feedrate_mm_s;
// 3782       current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
// 3783       sync_plan_position_e();
// 3784       prepare_move_to_destination();
// 3785 
// 3786       // Is a Z hop set, and has the hop not yet been done?
// 3787       if (has_zhop && !hop_amount) {
// 3788         hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
// 3789         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3790         current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3791         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3792         prepare_move_to_destination();                      // Raise up to the old current pos
// 3793         feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
// 3794       }
// 3795     }
// 3796     else {
// 3797       // If a hop was done and Z hasn't changed, undo the Z hop
// 3798       if (hop_amount) {
// 3799         current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3800         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3801         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3802         prepare_move_to_destination();                      // Raise up to the old current pos
// 3803         hop_amount = 0.0;                                   // Clear hop
// 3804       }
// 3805 
// 3806       // A retract multiplier has been added here to get faster swap recovery
// 3807       feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
// 3808 
// 3809       const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
// 3810       current_position[E_AXIS] -= move_e * renormalize;
// 3811       sync_plan_position_e();
// 3812       prepare_move_to_destination();                        // Recover E
// 3813     }
// 3814 
// 3815     feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
// 3816 
// 3817     retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
// 3818 
// 3819     // If swap retract/recover update the retracted_swap flag too
// 3820     #if EXTRUDERS > 1
// 3821       if (swapping) retracted_swap[active_extruder] = retracting;
// 3822     #endif
// 3823 
// 3824     /* // debugging
// 3825       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3826       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3827       SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
// 3828       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3829         SERIAL_ECHOPAIR("retracted[", i);
// 3830         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3831         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3832         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3833       }
// 3834       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3835       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3836     //*/
// 3837 
// 3838   }
// 3839 
// 3840 #endif // FWRETRACT
// 3841 
// 3842 #if ENABLED(MIXING_EXTRUDER)
// 3843 
// 3844   void normalize_mix() {
// 3845     float mix_total = 0.0;
// 3846     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
// 3847     // Scale all values if they don't add up to ~1.0
// 3848     if (!NEAR(mix_total, 1.0)) {
// 3849       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
// 3850       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
// 3851     }
// 3852   }
// 3853 
// 3854   #if ENABLED(DIRECT_MIXING_IN_G1)
// 3855     // Get mixing parameters from the GCode
// 3856     // The total "must" be 1.0 (but it will be normalized)
// 3857     // If no mix factors are given, the old mix is preserved
// 3858     void gcode_get_mix() {
// 3859       const char* mixing_codes = "ABCDHI";
// 3860       byte mix_bits = 0;
// 3861       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
// 3862         if (parser.seenval(mixing_codes[i])) {
// 3863           SBI(mix_bits, i);
// 3864           float v = parser.value_float();
// 3865           NOLESS(v, 0.0);
// 3866           mixing_factor[i] = RECIPROCAL(v);
// 3867         }
// 3868       }
// 3869       // If any mixing factors were included, clear the rest
// 3870       // If none were included, preserve the last mix
// 3871       if (mix_bits) {
// 3872         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 3873           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
// 3874         normalize_mix();
// 3875       }
// 3876     }
// 3877   #endif
// 3878 
// 3879 #endif
// 3880 
// 3881 /**
// 3882  * ***************************************************************************
// 3883  * ***************************** G-CODE HANDLING *****************************
// 3884  * ***************************************************************************
// 3885  */
// 3886 
// 3887 /**
// 3888  * Set XYZE destination and feedrate from the current GCode command
// 3889  *
// 3890  *  - Set destination from included axis codes
// 3891  *  - Set to current for missing axis codes
// 3892  *  - Set the feedrate, if included
// 3893  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function _Z21gcode_get_destinationv
        THUMB
// 3894 void gcode_get_destination() {
_Z21gcode_get_destinationv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3895   LOOP_XYZE(i) {
        MOVS     R4,#+0
        B.N      ??gcode_get_destination_0
// 3896     if (parser.seen(axis_codes[i])) {
// 3897       const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
// 3898       //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
// 3899       destination[i] = v;
// 3900     }
// 3901     else
// 3902       destination[i] = current_position[i];
??gcode_get_destination_1:
        LDR      R0,[R5, #+8]
        STR      R0,[R5, #+24]
??gcode_get_destination_2:
        ADDS     R4,R4,#+1
??gcode_get_destination_0:
        CMP      R4,#+4
        BGE.N    ??gcode_get_destination_3
        LDR.N    R0,??DataTable149_2
        ADD      R5,R0,R4, LSL #+2
        ADR.W    R0,axis_codes
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_get_destination_1
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDR.W    R1,??DataTable154_7
        LDRB     R2,[R4, R1]
        LDRB     R1,[R1, #+5]
        ORRS     R1,R1,R2
        BEQ.N    ??gcode_get_destination_4
        LDR      R1,[R5, #+8]
        B.N      ??gcode_get_destination_5
??gcode_get_destination_4:
        MOVS     R1,#+0
??gcode_get_destination_5:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+24]
        B.N      ??gcode_get_destination_2
// 3903   }
// 3904 
// 3905   if (parser.linearval('F') > 0.0)
??gcode_get_destination_3:
        MOVS     R1,#+0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_get_destination_6
// 3906     feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
          CFI FunCall _ZN11GCodeParser14value_feedrateEv
        BL       _ZN11GCodeParser14value_feedrateEv
        LDR.N    R1,??DataTable150  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.N    R1,??DataTable149_2
        STR      R0,[R1, #+92]
// 3907 
// 3908   #if ENABLED(PRINTCOUNTER)
// 3909     if (!DEBUGGING(DRYRUN))
// 3910       print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
// 3911   #endif
// 3912 
// 3913   // Get ABCDHI mixing factors
// 3914   #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
// 3915     gcode_get_mix();
// 3916   #endif
// 3917 }
??gcode_get_destination_6:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock52

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
axis_codes:
        DC8 88, 89, 90, 69
// 3918 
// 3919 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 3920 
// 3921   /**
// 3922    * Output a "busy" message at regular intervals
// 3923    * while the machine is not accepting commands.
// 3924    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function _Z14host_keepalivev
        THUMB
// 3925   void host_keepalive() {
_Z14host_keepalivev:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3926     const millis_t ms = millis();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R5,R0
// 3927     if (host_keepalive_interval && busy_state != NOT_BUSY) {
        LDR.W    R4,??DataTable154_7
        LDRB     R0,[R4, #+7]
        CMP      R0,#+0
        BEQ.N    ??host_keepalive_0
        LDRSB    R0,[R4, #+6]
        CMP      R0,#+0
        BEQ.N    ??host_keepalive_0
// 3928       if (PENDING(ms, next_busy_signal_ms)) return;
        LDR      R1,[R4, #+60]
        SUBS     R1,R5,R1
        BMI.N    ??host_keepalive_1
// 3929       switch (busy_state) {
        CMP      R0,#+1
        BEQ.N    ??host_keepalive_2
        BCC.N    ??host_keepalive_0
        CMP      R0,#+3
        BEQ.N    ??host_keepalive_3
        BCC.N    ??host_keepalive_2
        CMP      R0,#+4
        BEQ.N    ??host_keepalive_4
        B.N      ??host_keepalive_0
// 3930         case IN_HANDLER:
// 3931         case IN_PROCESS:
// 3932           SERIAL_ECHO_START();
??host_keepalive_2:
        LDR.W    R0,??DataTable155_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3933           SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
        ADR.W    R0,`?<Constant "busy: processing\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3934           break;
        B.N      ??host_keepalive_0
// 3935         case PAUSED_FOR_USER:
// 3936           SERIAL_ECHO_START();
??host_keepalive_3:
        LDR.W    R0,??DataTable155_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3937           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
        ADR.W    R0,`?<Constant "busy: paused for user\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3938           break;
        B.N      ??host_keepalive_0
// 3939         case PAUSED_FOR_INPUT:
// 3940           SERIAL_ECHO_START();
??host_keepalive_4:
        LDR.W    R0,??DataTable155_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3941           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
        ADR.W    R0,`?<Constant "busy: paused for input\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3942           break;
// 3943         default:
// 3944           break;
// 3945       }
// 3946     }
// 3947     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
??host_keepalive_0:
        LDRB     R0,[R4, #+7]
        MOV      R1,#+1000
        MLA      R0,R1,R0,R5
        STR      R0,[R4, #+60]
// 3948   }
??host_keepalive_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock53

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148:
        DC32     _ZN8Endstops16endstop_hit_bitsE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "busy: processing\\n">`:
        DC8 "busy: processing\012"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "busy: paused for user\\n">`:
        DC8 "busy: paused for user\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "busy: paused for input\\n">`:
        DC8 "busy: paused for input\012"
// 3949 
// 3950 #endif // HOST_KEEPALIVE_FEATURE
// 3951 
// 3952 
// 3953 /**************************************************
// 3954  ***************** GCode Handlers *****************
// 3955  **************************************************/
// 3956 
// 3957 #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3958   #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
// 3959 #else
// 3960   #define G0_G1_CONDITION true
// 3961 #endif
// 3962 
// 3963 /**
// 3964  * G0, G1: Coordinated movement of X Y Z E axes
// 3965  */
// 3966 inline void gcode_G0_G1(
// 3967   #if 0//IS_SCARA
// 3968     bool fast_move=false
// 3969   #endif
// 3970 ) {
// 3971   if (IsRunning() && G0_G1_CONDITION) {
// 3972     gcode_get_destination(); // For X Y Z E F
// 3973     
// 3974    /*    
// 3975     if (gCfgItems.breakpoint_reprint_flg == 1) 
// 3976     {
// 3977         if ((destination[2] <= gCfgItems.breakpoint_z_pos)&&(card.sdpos >= 5000)) //断点续打需要大于5k之后的内容才能进行续打。
// 3978         {
// 3979             return;
// 3980         }
// 3981     }
// 3982     */
// 3983     #if ENABLED(FWRETRACT)
// 3984       if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 3985         // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 3986         if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 3987           const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3988           // Is this a retract or recover move?
// 3989           if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 3990             current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 3991             sync_plan_position_e();                         // AND from the planner
// 3992             return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 3993           }
// 3994         }
// 3995       }
// 3996     #endif // FWRETRACT
// 3997 
// 3998     #if 0//IS_SCARA
// 3999       fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 4000     #else
// 4001       prepare_move_to_destination();
// 4002     #endif
// 4003 
// 4004     #if ENABLED(NANODLP_Z_SYNC)
// 4005       #if ENABLED(NANODLP_ALL_AXIS)
// 4006         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 4007       #else
// 4008         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 4009       #endif
// 4010       if (_MOVE_SYNC) {
// 4011         stepper.synchronize();
// 4012         SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4013       }
// 4014     #endif
// 4015   }
// 4016 }
// 4017 inline void gcode_G0_G1_SCARA(
// 4018 	  bool fast_move=false
// 4019   )
// 4020   {
// 4021     if (IsRunning() && G0_G1_CONDITION) {
// 4022       gcode_get_destination(); // For X Y Z E F
// 4023 
// 4024     #if ENABLED(FWRETRACT)
// 4025         if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 4026           // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 4027           if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 4028             const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 4029             // Is this a retract or recover move?
// 4030             if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 4031               current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 4032               sync_plan_position_e();                         // AND from the planner
// 4033               return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 4034             }
// 4035           }
// 4036         }
// 4037     #endif // FWRETRACT
// 4038 
// 4039     #if 1//IS_SCARA
// 4040         fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 4041     #else
// 4042         prepare_move_to_destination();
// 4043     #endif
// 4044 
// 4045     #if ENABLED(NANODLP_Z_SYNC)
// 4046     #if ENABLED(NANODLP_ALL_AXIS)
// 4047         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 4048     #else
// 4049         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 4050     #endif
// 4051         if (_MOVE_SYNC) {
// 4052           stepper.synchronize();
// 4053           SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4054         }
// 4055     #endif
// 4056     }
// 4057 }
// 4058 
// 4059 /**
// 4060  * G2: Clockwise Arc
// 4061  * G3: Counterclockwise Arc
// 4062  *
// 4063  * This command has two forms: IJ-form and R-form.
// 4064  *
// 4065  *  - I specifies an X offset. J specifies a Y offset.
// 4066  *    At least one of the IJ parameters is required.
// 4067  *    X and Y can be omitted to do a complete circle.
// 4068  *    The given XY is not error-checked. The arc ends
// 4069  *     based on the angle of the destination.
// 4070  *    Mixing I or J with R will throw an error.
// 4071  *
// 4072  *  - R specifies the radius. X or Y is required.
// 4073  *    Omitting both X and Y will throw an error.
// 4074  *    X or Y must differ from the current XY.
// 4075  *    Mixing R with I or J will throw an error.
// 4076  *
// 4077  *  - P specifies the number of full circles to do
// 4078  *    before the specified arc move.
// 4079  *
// 4080  *  Examples:
// 4081  *
// 4082  *    G2 I10           ; CW circle centered at X+10
// 4083  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
// 4084  */
// 4085 #if ENABLED(ARC_SUPPORT)
// 4086 
// 4087   inline void gcode_G2_G3(const bool clockwise) {
// 4088     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 4089       if (axis_unhomed_error()) return;
// 4090     #endif
// 4091 
// 4092     if (IsRunning()) {
// 4093 
// 4094       #if ENABLED(SF_ARC_FIX)
// 4095         const bool relative_mode_backup = relative_mode;
// 4096         relative_mode = true;
// 4097       #endif
// 4098 
// 4099       gcode_get_destination();
// 4100 
// 4101       #if ENABLED(SF_ARC_FIX)
// 4102         relative_mode = relative_mode_backup;
// 4103       #endif
// 4104 
// 4105       float arc_offset[2] = { 0.0, 0.0 };
// 4106       if (parser.seenval('R')) {
// 4107         const float r = parser.value_linear_units(),
// 4108                     p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
// 4109                     p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
// 4110         if (r && (p2 != p1 || q2 != q1)) {
// 4111           const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
// 4112                       dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
// 4113                       d = HYPOT(dx, dy),                          // Linear distance between the points
// 4114                       h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
// 4115                       mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
// 4116                       sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
// 4117                       cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
// 4118           arc_offset[0] = cx - p1;
// 4119           arc_offset[1] = cy - q1;
// 4120         }
// 4121       }
// 4122       else {
// 4123         if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
// 4124         if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
// 4125       }
// 4126 
// 4127       if (arc_offset[0] || arc_offset[1]) {
// 4128 
// 4129         #if ENABLED(ARC_P_CIRCLES)
// 4130           // P indicates number of circles to do
// 4131           int8_t circles_to_do = parser.byteval('P');
// 4132           if (!WITHIN(circles_to_do, 0, 100)) {
// 4133             SERIAL_ERROR_START();
// 4134             SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 4135           }
// 4136           while (circles_to_do--)
// 4137             plan_arc(current_position, arc_offset, clockwise);
// 4138         #endif
// 4139 
// 4140         // Send the arc to the planner
// 4141         plan_arc(destination, arc_offset, clockwise);
// 4142         refresh_cmd_timeout();
// 4143       }
// 4144       else {
// 4145         // Bad arguments
// 4146         SERIAL_ERROR_START();
// 4147         SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 4148       }
// 4149     }
// 4150   }
// 4151 
// 4152 #endif // ARC_SUPPORT
// 4153 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function _Z5dwellm
        THUMB
// 4154 void dwell(millis_t time) {
_Z5dwellm:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4155   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 4156   time += previous_cmd_ms;
        LDR.W    R0,??DataTable156
        LDR      R0,[R0, #+92]
        ADDS     R4,R0,R4
        B.N      ??dwell_0
// 4157   while (PENDING(millis(), time)) idle();
??dwell_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??dwell_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BMI.N    ??dwell_1
// 4158 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock54

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149:
        DC32     0xc1200000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_1:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_2:
        DC32     mks_heating_busy
// 4159 
// 4160 /**
// 4161  * G4: Dwell S<seconds> or P<milliseconds>
// 4162  */
// 4163 inline void gcode_G4() {
// 4164   millis_t dwell_ms = 0;
// 4165 
// 4166   if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
// 4167   if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
// 4168 
// 4169   stepper.synchronize();
// 4170   #if ENABLED(NANODLP_Z_SYNC)
// 4171     SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4172   #endif
// 4173 
// 4174   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
// 4175 
// 4176   dwell(dwell_ms);
// 4177 }
// 4178 
// 4179 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 4180 
// 4181   /**
// 4182    * Parameters interpreted according to:
// 4183    * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
// 4184    * However I, J omission is not supported at this point; all
// 4185    * parameters can be omitted and default to zero.
// 4186    */
// 4187 
// 4188   /**
// 4189    * G5: Cubic B-spline
// 4190    */
// 4191   inline void gcode_G5() {
// 4192     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 4193       if (axis_unhomed_error()) return;
// 4194     #endif
// 4195 
// 4196     if (IsRunning()) {
// 4197 
// 4198       #if ENABLED(CNC_WORKSPACE_PLANES)
// 4199         if (workspace_plane != PLANE_XY) {
// 4200           SERIAL_ERROR_START();
// 4201           SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
// 4202           return;
// 4203         }
// 4204       #endif
// 4205 
// 4206       gcode_get_destination();
// 4207 
// 4208       const float offset[] = {
// 4209         parser.linearval('I'),
// 4210         parser.linearval('J'),
// 4211         parser.linearval('P'),
// 4212         parser.linearval('Q')
// 4213       };
// 4214 
// 4215       plan_cubic_move(offset);
// 4216     }
// 4217   }
// 4218 
// 4219 #endif // BEZIER_CURVE_SUPPORT
// 4220 
// 4221 #if ENABLED(FWRETRACT)
// 4222 
// 4223   /**
// 4224    * G10 - Retract filament according to settings of M207
// 4225    */
// 4226   inline void gcode_G10() {
// 4227     #if EXTRUDERS > 1
// 4228       const bool rs = parser.boolval('S');
// 4229       retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
// 4230     #endif
// 4231     retract(true
// 4232       #if EXTRUDERS > 1
// 4233         , rs
// 4234       #endif
// 4235     );
// 4236   }
// 4237 
// 4238   /**
// 4239    * G11 - Recover filament according to settings of M208
// 4240    */
// 4241   inline void gcode_G11() { retract(false); }
// 4242 
// 4243 #endif // FWRETRACT
// 4244 
// 4245 #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 4246   /**
// 4247    * G12: Clean the nozzle
// 4248    */
// 4249   inline void gcode_G12() {
// 4250     // Don't allow nozzle cleaning without homing first
// 4251     if (axis_unhomed_error()) return;
// 4252 
// 4253     const uint8_t pattern = parser.ushortval('P', 0),
// 4254                   strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
// 4255                   objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
// 4256     const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
// 4257 
// 4258     Nozzle::clean(pattern, strokes, radius, objects);
// 4259   }
// 4260 #endif
// 4261 
// 4262 #if ENABLED(CNC_WORKSPACE_PLANES)
// 4263 
// 4264   inline void report_workspace_plane() {
// 4265     SERIAL_ECHO_START();
// 4266     SERIAL_ECHOPGM("Workspace Plane ");
// 4267     serialprintPGM(
// 4268       workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
// 4269       workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
// 4270                                     PSTR("XY\n")
// 4271     );
// 4272   }
// 4273 
// 4274   inline void set_workspace_plane(const WorkspacePlane plane) {
// 4275     workspace_plane = plane;
// 4276     if (DEBUGGING(INFO)) report_workspace_plane();
// 4277   }
// 4278 
// 4279   /**
// 4280    * G17: Select Plane XY
// 4281    * G18: Select Plane ZX
// 4282    * G19: Select Plane YZ
// 4283    */
// 4284   inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
// 4285   inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
// 4286   inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
// 4287 
// 4288 #endif // CNC_WORKSPACE_PLANES
// 4289 
// 4290 #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 4291 
// 4292   /**
// 4293    * Select a coordinate system and update the workspace offset.
// 4294    * System index -1 is used to specify machine-native.
// 4295    */
// 4296   bool select_coordinate_system(const int8_t _new) {
// 4297     if (active_coordinate_system == _new) return false;
// 4298     float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
// 4299     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4300       COPY(old_offset, coordinate_system[active_coordinate_system]);
// 4301     if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4302       COPY(new_offset, coordinate_system[_new]);
// 4303     active_coordinate_system = _new;
// 4304     LOOP_XYZ(i) {
// 4305       const float diff = new_offset[i] - old_offset[i];
// 4306       if (diff) {
// 4307         position_shift[i] += diff;
// 4308         update_software_endstops((AxisEnum)i);
// 4309       }
// 4310     }
// 4311     return true;
// 4312   }
// 4313 
// 4314   /**
// 4315    * In CNC G-code G53 is like a modifier
// 4316    * It precedes a movement command (or other modifiers) on the same line.
// 4317    * This is the first command to use parser.chain() to make this possible.
// 4318    */
// 4319   inline void gcode_G53() {
// 4320     // If this command has more following...
// 4321     if (parser.chain()) {
// 4322       const int8_t _system = active_coordinate_system;
// 4323       active_coordinate_system = -1;
// 4324       process_parsed_command();
// 4325       active_coordinate_system = _system;
// 4326     }
// 4327   }
// 4328 
// 4329   /**
// 4330    * G54-G59.3: Select a new workspace
// 4331    *
// 4332    * A workspace is an XYZ offset to the machine native space.
// 4333    * All workspaces default to 0,0,0 at start, or with EEPROM
// 4334    * support they may be restored from a previous session.
// 4335    *
// 4336    * G92 is used to set the current workspace's offset.
// 4337    */
// 4338   inline void gcode_G54_59(uint8_t subcode=0) {
// 4339     const int8_t _space = parser.codenum - 54 + subcode;
// 4340     if (select_coordinate_system(_space)) {
// 4341       SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
// 4342       report_current_position();
// 4343     }
// 4344   }
// 4345   FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
// 4346   FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
// 4347   FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
// 4348   FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
// 4349   FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
// 4350   FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
// 4351 
// 4352 #endif
// 4353 
// 4354 #if ENABLED(INCH_MODE_SUPPORT)
// 4355   /**
// 4356    * G20: Set input mode to inches
// 4357    */
// 4358   inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
// 4359 
// 4360   /**
// 4361    * G21: Set input mode to millimeters
// 4362    */
// 4363   inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
// 4364 #endif
// 4365 
// 4366 #if ENABLED(NOZZLE_PARK_FEATURE)
// 4367   /**
// 4368    * G27: Park the nozzle
// 4369    */
// 4370   inline void gcode_G27() {
// 4371     // Don't allow nozzle parking without homing first
// 4372     if (axis_unhomed_error()) return;
// 4373     Nozzle::park(parser.ushortval('P'));
// 4374   }
// 4375 #endif // NOZZLE_PARK_FEATURE
// 4376 
// 4377 #if 1//ENABLED(QUICK_HOME)
// 4378 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function _Z13quick_home_xyv
        THUMB
// 4379   static void quick_home_xy() {
_Z13quick_home_xyv:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
// 4380 
// 4381     // Pretend the current position is 0,0
// 4382     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        LDR.W    R6,??DataTable156_1
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
        STR      R0,[R6, #+8]
// 4383     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 4384 
// 4385     const int x_axis_home_dir =
// 4386       #if ENABLED(DUAL_X_CARRIAGE)
// 4387         x_home_dir(active_extruder)
// 4388       #else
// 4389         home_dir(X_AXIS)
// 4390       #endif
// 4391     ;
        MOVS     R0,#+0
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        MOV      R9,R0
// 4392 
// 4393     const float mlx = max_length(X_AXIS),
        MOVS     R0,#+0
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        MOV      R8,R0
// 4394                 mly = max_length(Y_AXIS),
        MOVS     R0,#+1
          CFI FunCall _Z10max_length8AxisEnum
        BL       _Z10max_length8AxisEnum
        MOV      R7,R0
// 4395                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??quick_home_xy_0
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
        B.N      ??quick_home_xy_1
??quick_home_xy_0:
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
// 4396                 fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
??quick_home_xy_1:
        LDR      R11,[R6, #+44]
        LDR      R0,[R6, #+40]
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??quick_home_xy_2
        MOV      R11,R0
??quick_home_xy_2:
        MOVS     R5,#+2
        MOV      R4,#+1065353216
        B.N      ??quick_home_xy_3
??quick_home_xy_4:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??quick_home_xy_3:
        LSLS     R0,R5,#+31
        BPL.N    ??quick_home_xy_5
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??quick_home_xy_5:
        LSRS     R5,R5,#+1
        BNE.N    ??quick_home_xy_4
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable155_3  ;; 0x3ff00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall sqrt
        BL       sqrt
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
// 4397 
// 4398     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
        MOVS     R4,#+0
        LDR.W    R5,??DataTable155_4  ;; 0x3ff80000
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R9
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R0,#+1
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+4]
        ADD      R2,SP,#+0
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
// 4399     endstops.hit_on_purpose(); // clear endstop hit flags
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
// 4400     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        MOVS     R0,#+0
        STR      R0,[R6, #+12]
        STR      R0,[R6, #+8]
// 4401   }
        POP      {R0-R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock55

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable150:
        DC32     0x42700000
// 4402 
// 4403 #endif // QUICK_HOME
// 4404 
// 4405 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4406 
// 4407   void log_machine_info() {
// 4408     SERIAL_ECHOPGM("Machine Type: ");
// 4409     #if ENABLED(DELTA)
// 4410       SERIAL_ECHOLNPGM("Delta");
// 4411     #elif IS_SCARA
// 4412       SERIAL_ECHOLNPGM("SCARA");
// 4413     #elif IS_CORE
// 4414       SERIAL_ECHOLNPGM("Core");
// 4415     #else
// 4416       SERIAL_ECHOLNPGM("Cartesian");
// 4417     #endif
// 4418 
// 4419     SERIAL_ECHOPGM("Probe: ");
// 4420     #if ENABLED(PROBE_MANUALLY)
// 4421       SERIAL_ECHOLNPGM("PROBE_MANUALLY");
// 4422     #elif ENABLED(FIX_MOUNTED_PROBE)
// 4423       SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
// 4424     #elif ENABLED(BLTOUCH)
// 4425       SERIAL_ECHOLNPGM("BLTOUCH");
// 4426     #elif HAS_Z_SERVO_ENDSTOP
// 4427       SERIAL_ECHOLNPGM("SERVO PROBE");
// 4428     #elif ENABLED(Z_PROBE_SLED)
// 4429       SERIAL_ECHOLNPGM("Z_PROBE_SLED");
// 4430     #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 4431       SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
// 4432     #else
// 4433       SERIAL_ECHOLNPGM("NONE");
// 4434     #endif
// 4435 
// 4436     #if HAS_BED_PROBE
// 4437       SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
// 4438       SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
// 4439       SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
// 4440       #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4441         SERIAL_ECHOPGM(" (Right");
// 4442       #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4443         SERIAL_ECHOPGM(" (Left");
// 4444       #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4445         SERIAL_ECHOPGM(" (Middle");
// 4446       #else
// 4447         SERIAL_ECHOPGM(" (Aligned With");
// 4448       #endif
// 4449       #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4450         SERIAL_ECHOPGM("-Back");
// 4451       #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4452         SERIAL_ECHOPGM("-Front");
// 4453       #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4454         SERIAL_ECHOPGM("-Center");
// 4455       #endif
// 4456       if (zprobe_zoffset < 0)
// 4457         SERIAL_ECHOPGM(" & Below");
// 4458       else if (zprobe_zoffset > 0)
// 4459         SERIAL_ECHOPGM(" & Above");
// 4460       else
// 4461         SERIAL_ECHOPGM(" & Same Z as");
// 4462       SERIAL_ECHOLNPGM(" Nozzle)");
// 4463     #endif
// 4464 
// 4465     #if HAS_ABL
// 4466       SERIAL_ECHOPGM("Auto Bed Leveling: ");
// 4467       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4468         SERIAL_ECHOPGM("LINEAR");
// 4469       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4470         SERIAL_ECHOPGM("BILINEAR");
// 4471       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4472         SERIAL_ECHOPGM("3POINT");
// 4473       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4474         SERIAL_ECHOPGM("UBL");
// 4475       #endif
// 4476       if (planner.leveling_active) {
// 4477         SERIAL_ECHOLNPGM(" (enabled)");
// 4478         #if ABL_PLANAR
// 4479           const float diff[XYZ] = {
// 4480             stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
// 4481             stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
// 4482             stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
// 4483           };
// 4484           SERIAL_ECHOPGM("ABL Adjustment X");
// 4485           if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
// 4486           SERIAL_ECHO(diff[X_AXIS]);
// 4487           SERIAL_ECHOPGM(" Y");
// 4488           if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
// 4489           SERIAL_ECHO(diff[Y_AXIS]);
// 4490           SERIAL_ECHOPGM(" Z");
// 4491           if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
// 4492           SERIAL_ECHO(diff[Z_AXIS]);
// 4493         #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4494           SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
// 4495         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4496           SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
// 4497         #endif
// 4498       }
// 4499       else
// 4500         SERIAL_ECHOLNPGM(" (disabled)");
// 4501 
// 4502       SERIAL_EOL();
// 4503 
// 4504     #elif ENABLED(MESH_BED_LEVELING)
// 4505 
// 4506       SERIAL_ECHOPGM("Mesh Bed Leveling");
// 4507       if (planner.leveling_active) {
// 4508         float rz = current_position[Z_AXIS];
// 4509         planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
// 4510         SERIAL_ECHOLNPGM(" (enabled)");
// 4511         SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
// 4512       }
// 4513       else
// 4514         SERIAL_ECHOPGM(" (disabled)");
// 4515 
// 4516       SERIAL_EOL();
// 4517 
// 4518     #endif // MESH_BED_LEVELING
// 4519   }
// 4520 
// 4521 #endif // DEBUG_LEVELING_FEATURE
// 4522 
// 4523 #if 1//ENABLED(DELTA)
// 4524 
// 4525   /**
// 4526    * A delta can only safely home all axes at the same time
// 4527    * This is like quick_home_xy() but for 3 towers.
// 4528    */
// 4529   inline bool home_delta() {
// 4530     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4531       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
// 4532     #endif
// 4533     // Init the current position of all carriages to 0,0,0
// 4534     ZERO(current_position);
// 4535     sync_plan_position();
// 4536 
// 4537     // Move all carriages together linearly until an endstop is hit.
// 4538     current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
// 4539     feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
// 4540     buffer_line_to_current_position();
// 4541     stepper.synchronize();
// 4542 
// 4543     // If an endstop was not hit, then damage can occur if homing is continued.
// 4544     // This can occur if the delta height not set correctly.
// 4545     if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
// 4546       LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
// 4547       SERIAL_ERROR_START();
// 4548       SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
// 4549       return false;
// 4550     }
// 4551 
// 4552     endstops.hit_on_purpose(); // clear endstop hit flags
// 4553 
// 4554     // At least one carriage has reached the top.
// 4555     // Now re-home each carriage separately.
// 4556     HOMEAXIS(A);
// 4557     HOMEAXIS(B);
// 4558     HOMEAXIS(C);
// 4559 
// 4560     // Set all carriages to their home positions
// 4561     // Do this here all at once for Delta, because
// 4562     // XYZ isn't ABC. Applying this per-tower would
// 4563     // give the impression that they are the same.
// 4564     LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
// 4565 
// 4566     SYNC_PLAN_POSITION_KINEMATIC();
// 4567 
// 4568     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4569       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
// 4570     #endif
// 4571 
// 4572     return true;
// 4573   }
// 4574 
// 4575 #endif // DELTA
// 4576 
// 4577 #if ENABLED(Z_SAFE_HOMING)
// 4578 
// 4579   inline void home_z_safely() {
// 4580 
// 4581     // Disallow Z homing if X or Y are unknown
// 4582     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
// 4583       LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
// 4584       SERIAL_ECHO_START();
// 4585       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
// 4586       return;
// 4587     }
// 4588 
// 4589     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4590       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
// 4591     #endif
// 4592 
// 4593     SYNC_PLAN_POSITION_KINEMATIC();
// 4594 
// 4595     /**
// 4596      * Move the Z probe (or just the nozzle) to the safe homing point
// 4597      */
// 4598     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
// 4599     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
// 4600     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
// 4601 
// 4602     #if HOMING_Z_WITH_PROBE
// 4603     if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))  /*--mks cfg--*/
// 4604     {      
// 4605         destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 4606         destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 4607     }
// 4608     #endif
// 4609 if(MACHINETPYE & IS_KINEMATIC)
// 4610 {
// 4611     if (position_is_reachable_IS_KINEMATIC(destination[X_AXIS], destination[Y_AXIS])) {
// 4612 
// 4613       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4614         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4615       #endif
// 4616 
// 4617       // This causes the carriage on Dual X to unpark
// 4618       #if ENABLED(DUAL_X_CARRIAGE)
// 4619         active_extruder_parked = false;
// 4620       #endif
// 4621 
// 4622       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4623       HOMEAXIS(Z);
// 4624     }
// 4625     else {
// 4626       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4627       SERIAL_ECHO_START();
// 4628       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4629     }
// 4630 }
// 4631 else
// 4632 {
// 4633     if (position_is_reachable_IS_CARTESIAN(destination[X_AXIS], destination[Y_AXIS])) {
// 4634 
// 4635       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4636         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4637       #endif
// 4638 
// 4639       // This causes the carriage on Dual X to unpark
// 4640       #if ENABLED(DUAL_X_CARRIAGE)
// 4641         active_extruder_parked = false;
// 4642       #endif
// 4643 
// 4644       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4645       HOMEAXIS(Z);
// 4646     }
// 4647     else {
// 4648       LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4649       SERIAL_ECHO_START();
// 4650       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4651     }    
// 4652 }
// 4653     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4654       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
// 4655     #endif
// 4656   }
// 4657 
// 4658 #endif // Z_SAFE_HOMING
// 4659 
// 4660 #if ENABLED(PROBE_MANUALLY)
// 4661   bool g29_in_progress = false;
// 4662 #else
// 4663   constexpr bool g29_in_progress = false;
// 4664 #endif
// 4665 
// 4666 /**
// 4667  * G28: Home all axes according to settings
// 4668  *
// 4669  * Parameters
// 4670  *
// 4671  *  None  Home to all axes with no parameters.
// 4672  *        With QUICK_HOME enabled XY will home together, then Z.
// 4673  *
// 4674  * Cartesian parameters
// 4675  *
// 4676  *  X   Home to the X endstop
// 4677  *  Y   Home to the Y endstop
// 4678  *  Z   Home to the Z endstop
// 4679  *
// 4680  */
// 4681 inline void gcode_G28(const bool always_home_all) {
// 4682 
// 4683   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4684     if (DEBUGGING(LEVELING)) {
// 4685       SERIAL_ECHOLNPGM(">>> gcode_G28");
// 4686       log_machine_info();
// 4687     }
// 4688   #endif
// 4689 
// 4690   // Wait for planner moves to finish!
// 4691   stepper.synchronize();
// 4692 
// 4693   // Cancel the active G29 session
// 4694   #if ENABLED(PROBE_MANUALLY)
// 4695     g29_in_progress = false;
// 4696   #endif
// 4697 
// 4698   // Disable the leveling matrix before homing
// 4699   //#if HAS_LEVELING
// 4700   	//const 
// 4701   	bool ubl_state_at_entry;
// 4702     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4703     if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4704     {
// 4705     	ubl_state_at_entry = planner.leveling_active;
// 4706     }
// 4707     //#endif
// 4708     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 4709     {
// 4710     	set_bed_leveling_enabled(false);
// 4711     }
// 4712   //#endif
// 4713 
// 4714   #if ENABLED(CNC_WORKSPACE_PLANES)
// 4715     workspace_plane = PLANE_XY;
// 4716   #endif
// 4717 
// 4718   // Always home with tool 0 active
// 4719   #if HOTENDS > 1
// 4720     const uint8_t old_tool_index = active_extruder;
// 4721     tool_change(0, 0, true);
// 4722   #endif
// 4723 
// 4724   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 4725     extruder_duplication_enabled = false;
// 4726   #endif
// 4727 
// 4728   setup_for_endstop_or_probe_move();
// 4729   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4730     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
// 4731   #endif
// 4732   endstops.enable(true); // Enable endstops for next homing move
// 4733 
// 4734   //#if ENABLED(DELTA)
// 4735   if(MACHINETPYE == DELTA)
// 4736   {
// 4737     home_delta();
// 4738     UNUSED(always_home_all);
// 4739   }
// 4740   //#else // NOT DELTA
// 4741   else
// 4742   {
// 4743     const bool homeX = always_home_all || parser.seen('X'),
// 4744                homeY = always_home_all || parser.seen('Y'),
// 4745                homeZ = always_home_all || parser.seen('Z'),
// 4746                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
// 4747 
// 4748     set_destination_from_current();
// 4749 
// 4750     //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
// 4751 	if(Z_HOME_DIR > 0)
// 4752 	{
// 4753       if (home_all || homeZ) {
// 4754         HOMEAXIS(Z);
// 4755         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4756           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
// 4757         #endif
// 4758       }
// 4759 	}
// 4760     //#endif
// 4761 
// 4762     if ((home_all || homeX || homeY) 
// 4763         #if 1
// 4764 		&& ((mksReprint.mks_printer_state != MKS_REPRINTING)
// 4765 	  	||(mksReprint.mks_printer_state != MKS_REPRINTED))
// 4766 	  	#endif
// 4767         )
// 4768       {
// 4769       // Raise Z before homing any other axes and z is not already high enough (never lower z)
// 4770       destination[Z_AXIS] = Z_HOMING_HEIGHT;
// 4771       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
// 4772 
// 4773         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4774           if (DEBUGGING(LEVELING))
// 4775             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
// 4776         #endif
// 4777 
// 4778         do_blocking_move_to_z(destination[Z_AXIS]);
// 4779       }
// 4780     }
// 4781 
// 4782     //#if ENABLED(QUICK_HOME)
// 4783 	if(MACHINETPYE&IS_SCARA)
// 4784 	{
// 4785       if (home_all || (homeX && homeY)) quick_home_xy();
// 4786 	}
// 4787     //#endif
// 4788 
// 4789     //#if ENABLED(HOME_Y_BEFORE_X)
// 4790 	if(MACHINETPYE&IS_SCARA)
// 4791 	{
// 4792       // Home Y
// 4793       if (home_all || homeY) {
// 4794         HOMEAXIS(Y);
// 4795         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4796           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4797         #endif
// 4798       }
// 4799 	}
// 4800     //#endif
// 4801 
// 4802     // Home X
// 4803     if (home_all || homeX) {
// 4804 
// 4805       #if ENABLED(DUAL_X_CARRIAGE)
// 4806 
// 4807         // Always home the 2nd (right) extruder first
// 4808         active_extruder = 1;
// 4809         HOMEAXIS(X);
// 4810 
// 4811         // Remember this extruder's position for later tool change
// 4812         inactive_extruder_x_pos = current_position[X_AXIS];
// 4813 
// 4814         // Home the 1st (left) extruder
// 4815         active_extruder = 0;
// 4816         HOMEAXIS(X);
// 4817 
// 4818         // Consider the active extruder to be parked
// 4819         COPY(raised_parked_position, current_position);
// 4820         delayed_move_time = 0;
// 4821         active_extruder_parked = true;
// 4822 
// 4823       #else
// 4824 
// 4825         HOMEAXIS(X);
// 4826 
// 4827       #endif
// 4828 
// 4829       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4830         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
// 4831       #endif
// 4832     }
// 4833 
// 4834     //#if DISABLED(HOME_Y_BEFORE_X)
// 4835 	if(!HOME_Y_BEFORE_X)
// 4836 	{
// 4837       // Home Y
// 4838       if (home_all || homeY) {
// 4839         HOMEAXIS(Y);
// 4840         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4841           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4842         #endif
// 4843       }
// 4844 	}
// 4845     //#endif
// 4846 
// 4847     // Home Z last if homing towards the bed
// 4848     //#if Z_HOME_DIR < 0
// 4849     if(Z_HOME_DIR < 0)
// 4850     {
// 4851       if (home_all || homeZ) {
// 4852         #if ENABLED(Z_SAFE_HOMING)
// 4853           home_z_safely();
// 4854         #else
// 4855           HOMEAXIS(Z);
// 4856         #endif
// 4857         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4858           if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
// 4859         #endif
// 4860       } // home_all || homeZ
// 4861     }
// 4862     //#endif // Z_HOME_DIR < 0
// 4863 
// 4864     SYNC_PLAN_POSITION_KINEMATIC();
// 4865 }
// 4866   //#endif // !DELTA (gcode_G28)
// 4867 
// 4868   endstops.not_homing();
// 4869 
// 4870   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 4871     // move to a height where we can use the full xy-area
// 4872     do_blocking_move_to_z(delta_clip_start_height);
// 4873   #endif
// 4874 
// 4875   //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4876   if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4877     set_bed_leveling_enabled(ubl_state_at_entry);
// 4878   //#endif
// 4879 
// 4880   clean_up_after_endstop_or_probe_move();
// 4881 
// 4882   // Restore the active tool after homing
// 4883   #if HOTENDS > 1
// 4884     #if ENABLED(PARKING_EXTRUDER)
// 4885       #define NO_FETCH false // fetch the previous toolhead
// 4886     #else
// 4887       #define NO_FETCH true
// 4888     #endif
// 4889     tool_change(old_tool_index, 0, NO_FETCH);
// 4890   #endif
// 4891 
// 4892   lcd_refresh();
// 4893 
// 4894   report_current_position();
// 4895 
// 4896   #if ENABLED(NANODLP_Z_SYNC)
// 4897     #if ENABLED(NANODLP_ALL_AXIS)
// 4898       #define _HOME_SYNC true                 // For any axis, output sync text.
// 4899     #else
// 4900       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
// 4901     #endif
// 4902     if (_HOME_SYNC)
// 4903       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4904   #endif
// 4905 
// 4906   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4907     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
// 4908   #endif
// 4909 } // G28
// 4910 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function _Z13home_all_axesv
        THUMB
// 4911 void home_all_axes() { gcode_G28(true); }
_Z13home_all_axesv:
        MOVS     R0,#+1
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock56
// 4912 
// 4913 #if HAS_PROBING_PROCEDURE
// 4914 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function _Z18out_of_range_errorPKc
        THUMB
// 4915   void out_of_range_error(const char* p_edge) {
_Z18out_of_range_errorPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4916     SERIAL_PROTOCOLPGM("?Probe ");
        ADR.W    R0,`?<Constant "?Probe ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4917     serialprintPGM(p_edge);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4918     SERIAL_PROTOCOLLNPGM(" position out of range.");
        ADR.W    R0,`?<Constant " position out of range.\\n">`
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI EndBlock cfiBlock57
// 4919   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "?Probe ">`:
        DC8 "?Probe "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " position out of range.\\n">`:
        DC8 " position out of range.\012"
        DC8 0, 0, 0
// 4920 
// 4921 #endif
// 4922 
// 4923 #if 1//ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
// 4924 
// 4925   #if ENABLED(LCD_BED_LEVELING)
// 4926     //extern 
// 4927     bool lcd_wait_for_move;
// 4928   #else
// 4929     constexpr bool lcd_wait_for_move = false;
// 4930   #endif
// 4931 
// 4932   inline void _manual_goto_xy(const float &rx, const float &ry) {
// 4933 
// 4934     //#if MANUAL_PROBE_HEIGHT > 0
// 4935     if(MANUAL_PROBE_HEIGHT > 0)
// 4936     {
// 4937       const float prev_z = current_position[Z_AXIS];
// 4938       do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
// 4939       do_blocking_move_to_z(prev_z);
// 4940     }
// 4941     //#else
// 4942     else
// 4943     {
// 4944       do_blocking_move_to_xy(rx, ry);
// 4945     }
// 4946     //#endif
// 4947 
// 4948     current_position[X_AXIS] = rx;
// 4949     current_position[Y_AXIS] = ry;
// 4950 
// 4951     #if ENABLED(LCD_BED_LEVELING)
// 4952       lcd_wait_for_move = false;
// 4953     #endif
// 4954   }
// 4955 
// 4956 #endif
// 4957 
// 4958 #if 1//ENABLED(MESH_BED_LEVELING)
// 4959 
// 4960   // Save 130 bytes with non-duplication of PSTR

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function _Z16echo_not_enteredv
        THUMB
// 4961   void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
_Z16echo_not_enteredv:
        ADR.W    R0,`?<Constant " not entered.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI EndBlock cfiBlock58

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " not entered.\\n">`:
        DC8 " not entered.\012"
        DC8 0
// 4962 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI Function _Z15mbl_mesh_reportv
        THUMB
// 4963   void mbl_mesh_report() {
_Z15mbl_mesh_reportv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
// 4964     //SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
// 4965     SERIAL_PROTOCOLPGM("Num X,Y: ");
        ADR.W    R0,`?<Constant "Num X,Y: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4966     SERIAL_PROTOCOL((int)GRID_MAX_POINTS_X);
        LDR.N    R4,??DataTable154_2
        LDR.W    R5,??DataTable158
        MOVS     R2,#+10
        LDRB     R1,[R5, #+96]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 4967     SERIAL_PROTOCOLCHAR(',');
        MOVS     R1,#+44
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 4968     SERIAL_PROTOCOL((int)GRID_MAX_POINTS_Y);
        ADD      R6,R5,#+96
        MOVS     R2,#+10
        LDRB     R1,[R6, #+1]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 4969     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 4970     SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
        ADR.W    R0,`?<Constant "Z offset: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable159
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 4971     SERIAL_PROTOCOLLNPGM("\nMeasured points:");
        ADR.W    R0,`?<Constant "\\nMeasured points:\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4972 	/*
// 4973     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
// 4974       [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
// 4975     );
// 4976     */
// 4977     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
        MOVS     R3,#+2
        MOVS     R2,#+5
        LDRB     R1,[R6, #+1]
        LDRB     R0,[R5, #+96]
        ADD      SP,SP,#+8
          CFI CFA R13+16
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14print_2d_arrayhhhh
        B.W      _Z14print_2d_arrayhhhh
          CFI EndBlock cfiBlock59
// 4978   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151:
        DC32     _ZN17mesh_bed_leveling8has_meshE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_1:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Num X,Y: ">`:
        DC8 "Num X,Y: "
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Z offset: ">`:
        DC8 "Z offset: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "\\nMeasured points:\\n">`:
        DC8 "\012Measured points:\012"
        DC8 0
// 4979 
// 4980   /**
// 4981    * G29: Mesh-based Z probe, probes a grid and produces a
// 4982    *      mesh to compensate for variable bed height
// 4983    *
// 4984    * Parameters With MESH_BED_LEVELING:
// 4985    *
// 4986    *  S0              Produce a mesh report
// 4987    *  S1              Start probing mesh points
// 4988    *  S2              Probe the next mesh point
// 4989    *  S3 Xn Yn Zn.nn  Manually modify a single point
// 4990    *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
// 4991    *  S5              Reset and disable mesh
// 4992    *
// 4993    * The S0 report the points as below
// 4994    *
// 4995    *  +----> X-axis  1-n
// 4996    *  |
// 4997    *  |
// 4998    *  v Y-axis  1-n
// 4999    *
// 5000    */
// 5001 //  inline void gcode_G29() {
// 5002 inline void gcode_G29_MESH_BED_LEVELING() {
// 5003 
// 5004     static int mbl_probe_index = -1;
// 5005     #if HAS_SOFTWARE_ENDSTOPS
// 5006       static bool enable_soft_endstops;
// 5007     #endif
// 5008 
// 5009     const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
// 5010     if (!WITHIN(state, 0, 5)) {
// 5011       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
// 5012       return;
// 5013     }
// 5014 
// 5015     int8_t px, py;
// 5016 
// 5017     switch (state) {
// 5018       case MeshReport:
// 5019         if (leveling_is_valid()) {
// 5020           SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
// 5021           mbl_mesh_report();
// 5022         }
// 5023         else
// 5024           SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
// 5025         break;
// 5026 
// 5027       case MeshStart:
// 5028         mbl.reset();
// 5029         mbl_probe_index = 0;
// 5030         enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
// 5031         break;
// 5032 
// 5033       case MeshNext:
// 5034         if (mbl_probe_index < 0) {
// 5035           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
// 5036           return;
// 5037         }
// 5038         // For each G29 S2...
// 5039         if (mbl_probe_index == 0) {
// 5040           #if HAS_SOFTWARE_ENDSTOPS
// 5041             // For the initial G29 S2 save software endstop state
// 5042             enable_soft_endstops = soft_endstops_enabled;
// 5043           #endif
// 5044         }
// 5045         else {
// 5046           // For G29 S2 after adjusting Z.
// 5047           mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
// 5048           #if HAS_SOFTWARE_ENDSTOPS
// 5049             soft_endstops_enabled = enable_soft_endstops;
// 5050           #endif
// 5051         }
// 5052         // If there's another point to sample, move there with optional lift.
// 5053         if (mbl_probe_index < GRID_MAX_POINTS) {
// 5054           mbl.zigzag(mbl_probe_index, px, py);
// 5055           _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
// 5056 
// 5057           #if HAS_SOFTWARE_ENDSTOPS
// 5058             // Disable software endstops to allow manual adjustment
// 5059             // If G29 is not completed, they will not be re-enabled
// 5060             soft_endstops_enabled = false;
// 5061           #endif
// 5062 
// 5063           mbl_probe_index++;
// 5064         }
// 5065         else {
// 5066           // One last "return to the bed" (as originally coded) at completion
// 5067           current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
// 5068           buffer_line_to_current_position();
// 5069           stepper.synchronize();
// 5070 
// 5071           // After recording the last point, activate home and activate
// 5072           mbl_probe_index = -1;
// 5073           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
// 5074           BUZZ(100, 659);
// 5075           BUZZ(100, 698);
// 5076           mbl.has_mesh = true;
// 5077 
// 5078           home_all_axes();
// 5079           set_bed_leveling_enabled(true);
// 5080 
// 5081           #if ENABLED(MESH_G28_REST_ORIGIN)
// 5082             current_position[Z_AXIS] = Z_MIN_POS;
// 5083             set_destination_from_current();
// 5084             buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
// 5085             stepper.synchronize();
// 5086           #endif
// 5087 
// 5088           #if ENABLED(LCD_BED_LEVELING)
// 5089             lcd_wait_for_move = false;
// 5090           #endif
// 5091         }
// 5092         break;
// 5093 
// 5094       case MeshSet:
// 5095         if (parser.seenval('X')) {
// 5096           px = parser.value_int() - 1;
// 5097           if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
// 5098             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
// 5099             return;
// 5100           }
// 5101         }
// 5102         else {
// 5103           SERIAL_CHAR('X'); echo_not_entered();
// 5104           return;
// 5105         }
// 5106 
// 5107         if (parser.seenval('Y')) {
// 5108           py = parser.value_int() - 1;
// 5109           if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
// 5110             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
// 5111             return;
// 5112           }
// 5113         }
// 5114         else {
// 5115           SERIAL_CHAR('Y'); echo_not_entered();
// 5116           return;
// 5117         }
// 5118 
// 5119         if (parser.seenval('Z'))
// 5120           mbl.z_values[px][py] = parser.value_linear_units();
// 5121         else {
// 5122           SERIAL_CHAR('Z'); echo_not_entered();
// 5123           return;
// 5124         }
// 5125         break;
// 5126 
// 5127       case MeshSetZOffset:
// 5128         if (parser.seenval('Z'))
// 5129           mbl.z_offset = parser.value_linear_units();
// 5130         else {
// 5131           SERIAL_CHAR('Z'); echo_not_entered();
// 5132           return;
// 5133         }
// 5134         break;
// 5135 
// 5136       case MeshReset:
// 5137         reset_bed_level();
// 5138         break;
// 5139 
// 5140     } // switch(state)
// 5141 
// 5142     if (state == MeshStart || state == MeshNext) {
// 5143       SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
// 5144       SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
// 5145     }
// 5146 
// 5147     report_current_position();
// 5148   }
// 5149 #endif
// 5150 //#if 1
// 5151 //#elif OLDSCHOOL_ABL
// 5152 
// 5153   #if 1//ABL_GRID
// 5154     #if ENABLED(PROBE_Y_FIRST)
// 5155       #define PR_OUTER_VAR xCount
// 5156       #define PR_OUTER_END abl_grid_points_x
// 5157       #define PR_INNER_VAR yCount
// 5158       #define PR_INNER_END abl_grid_points_y
// 5159     #else
// 5160       #define PR_OUTER_VAR yCount
// 5161       #define PR_OUTER_END abl_grid_points_y
// 5162       #define PR_INNER_VAR xCount
// 5163       #define PR_INNER_END abl_grid_points_x
// 5164     #endif
// 5165   #endif
// 5166 
// 5167   /**
// 5168    * G29: Detailed Z probe, probes the bed at 3 or more points.
// 5169    *      Will fail if the printer has not been homed with G28.
// 5170    *
// 5171    * Enhanced G29 Auto Bed Leveling Probe Routine
// 5172    *
// 5173    *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
// 5174    *     or alter the bed level data. Useful to check the topology
// 5175    *     after a first run of G29.
// 5176    *
// 5177    *  J  Jettison current bed leveling data
// 5178    *
// 5179    *  V  Set the verbose level (0-4). Example: "G29 V3"
// 5180    *
// 5181    * Parameters With LINEAR leveling only:
// 5182    *
// 5183    *  P  Set the size of the grid that will be probed (P x P points).
// 5184    *     Example: "G29 P4"
// 5185    *
// 5186    *  X  Set the X size of the grid that will be probed (X x Y points).
// 5187    *     Example: "G29 X7 Y5"
// 5188    *
// 5189    *  Y  Set the Y size of the grid that will be probed (X x Y points).
// 5190    *
// 5191    *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
// 5192    *     This is useful for manual bed leveling and finding flaws in the bed (to
// 5193    *     assist with part placement).
// 5194    *     Not supported by non-linear delta printer bed leveling.
// 5195    *
// 5196    * Parameters With LINEAR and BILINEAR leveling only:
// 5197    *
// 5198    *  S  Set the XY travel speed between probe points (in units/min)
// 5199    *
// 5200    *  F  Set the Front limit of the probing grid
// 5201    *  B  Set the Back limit of the probing grid
// 5202    *  L  Set the Left limit of the probing grid
// 5203    *  R  Set the Right limit of the probing grid
// 5204    *
// 5205    * Parameters with DEBUG_LEVELING_FEATURE only:
// 5206    *
// 5207    *  C  Make a totally fake grid with no actual probing.
// 5208    *     For use in testing when no probing is possible.
// 5209    *
// 5210    * Parameters with BILINEAR leveling only:
// 5211    *
// 5212    *  Z  Supply an additional Z probe offset
// 5213    *
// 5214    * Extra parameters with PROBE_MANUALLY:
// 5215    *
// 5216    *  To do manual probing simply repeat G29 until the procedure is complete.
// 5217    *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
// 5218    *
// 5219    *  Q  Query leveling and G29 state
// 5220    *
// 5221    *  A  Abort current leveling procedure
// 5222    *
// 5223    * Extra parameters with BILINEAR only:
// 5224    *
// 5225    *  W  Write a mesh point. (If G29 is idle.)
// 5226    *  I  X index for mesh point
// 5227    *  J  Y index for mesh point
// 5228    *  X  X for mesh point, overrides I
// 5229    *  Y  Y for mesh point, overrides J
// 5230    *  Z  Z for mesh point. Otherwise, raw current Z.
// 5231    *
// 5232    * Without PROBE_MANUALLY:
// 5233    *
// 5234    *  E  By default G29 will engage the Z probe, test the bed, then disengage.
// 5235    *     Include "E" to engage/disengage the Z probe for each sample.
// 5236    *     There's no extra effect if you have a fixed Z probe.
// 5237    *
// 5238    */
// 5239   inline void gcode_G29() {
// 5240 
// 5241     // G29 Q is also available if debugging
// 5242     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5243       const bool query = parser.seen('Q');
// 5244       const uint8_t old_debug_flags = marlin_debug_flags;
// 5245       if (query) marlin_debug_flags |= DEBUG_LEVELING;
// 5246       if (DEBUGGING(LEVELING)) {
// 5247         DEBUG_POS(">>> G29", current_position);
// 5248         log_machine_info();
// 5249       }
// 5250       marlin_debug_flags = old_debug_flags;
// 5251       #if DISABLED(PROBE_MANUALLY)
// 5252         if (query) return;
// 5253       #endif
// 5254     #endif
// 5255 
// 5256     #if ENABLED(PROBE_MANUALLY)
// 5257       const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
// 5258     #endif
// 5259 
// 5260     #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
// 5261       const bool faux = parser.boolval('C');
// 5262     #elif ENABLED(PROBE_MANUALLY)
// 5263       const bool faux = no_action;
// 5264     #else
// 5265       bool constexpr faux = false;
// 5266     #endif
// 5267 
// 5268     // Don't allow auto-leveling without homing first
// 5269     if (axis_unhomed_error()) return;
// 5270 
// 5271     // Define local vars 'static' for manual probing, 'auto' otherwise
// 5272     #if ENABLED(PROBE_MANUALLY)
// 5273       #define ABL_VAR static
// 5274     #else
// 5275       #define ABL_VAR
// 5276     #endif
// 5277 
// 5278     ABL_VAR int verbose_level=0;
// 5279     ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
// 5280     ABL_VAR bool dryrun=false, abl_should_enable=false;
// 5281 
// 5282     //#if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5283       ABL_VAR int abl_probe_index=0;
// 5284     //#endif
// 5285 
// 5286     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
// 5287       ABL_VAR bool enable_soft_endstops = true;
// 5288     #endif
// 5289 
// 5290     #if 1//ABL_GRID
// 5291 
// 5292       #if ENABLED(PROBE_MANUALLY)
// 5293         ABL_VAR uint8_t PR_OUTER_VAR;
// 5294         ABL_VAR  int8_t PR_INNER_VAR;
// 5295       #endif
// 5296 
// 5297       ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
// 5298       ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
// 5299 
// 5300       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5301         ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
// 5302                         abl_grid_points_y = GRID_MAX_POINTS_Y;
// 5303         ABL_VAR bool do_topography_map=0;
// 5304       //#else // Bilinear
// 5305       //  uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
// 5306       //                    abl_grid_points_y = GRID_MAX_POINTS_Y;
// 5307       //#endif
// 5308 
// 5309       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5310         ABL_VAR int abl2;
// 5311       //#elif ENABLED(PROBE_MANUALLY) // Bilinear
// 5312       //  int constexpr abl2 = GRID_MAX_POINTS;
// 5313       //#endif
// 5314       if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = GRID_MAX_POINTS;
// 5315 
// 5316       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5317 
// 5318         ABL_VAR float zoffset;
// 5319 
// 5320       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5321 
// 5322         ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
// 5323 
// 5324         ABL_VAR float *eqnAMatrix=NULL,//[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
// 5325                       *eqnBVector=NULL,//[GRID_MAX_POINTS],     // "B" vector of Z points
// 5326                       mean;
// 5327 		eqnAMatrix = (float *)malloc((GRID_MAX_POINTS * 3 + 1) * sizeof(float));
// 5328 		if(eqnAMatrix == NULL)
// 5329 			{
// 5330 			Running = false;
// 5331 			kill("malloc eqnAMatrix err!");
// 5332 			}
// 5333 		for(int i=0;i<GRID_MAX_POINTS * 3 + 1;i++)
// 5334             *(eqnAMatrix+i) = 0.0;
// 5335 
// 5336 		
// 5337 		eqnBVector = (float *)malloc((GRID_MAX_POINTS + 1) * sizeof(float));
// 5338 		if(eqnBVector == NULL)
// 5339 		{
// 5340 			Running = false;
// 5341 			kill("malloc eqnBVector err!");
// 5342 		}
// 5343 		for(int i=0;i<GRID_MAX_POINTS + 1;i++) 	*(eqnBVector+i) = 0.0;        
// 5344       //#endif
// 5345 
// 5346    // #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5347 
// 5348       #if ENABLED(PROBE_MANUALLY)
// 5349         int constexpr abl2 = 3; // used to show total points
// 5350       #endif
// 5351 
// 5352       // Probe at 3 arbitrary points
// 5353       ABL_VAR vector_3 points[3] = {
// 5354         vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
// 5355         vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
// 5356         vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
// 5357       };
// 5358 
// 5359    // #endif // AUTO_BED_LEVELING_3POINT
// 5360 
// 5361     //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5362     struct linear_fit_data lsf_results;
// 5363     if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_LINEAR)
// 5364     {
// 5365       incremental_LSF_reset(&lsf_results);
// 5366     }
// 5367     //#endif
// 5368 
// 5369     /**
// 5370      * On the initial G29 fetch command parameters.
// 5371      */
// 5372     if (!g29_in_progress) {
// 5373 #if 0
// 5374       #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5375         abl_probe_index = -1;
// 5376       #endif
// 5377 #else
// 5378       if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5379          abl_probe_index = -1;
// 5380 #endif
// 5381       abl_should_enable = planner.leveling_active;
// 5382 
// 5383       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5384       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 5385 
// 5386         if (parser.seen('W')) {
// 5387           if (!leveling_is_valid()) {
// 5388             SERIAL_ERROR_START();
// 5389             SERIAL_ERRORLNPGM("No bilinear grid");
// 5390             return;
// 5391           }
// 5392 
// 5393           const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
// 5394           if (!WITHIN(rz, -10, 10)) {
// 5395             SERIAL_ERROR_START();
// 5396             SERIAL_ERRORLNPGM("Bad Z value");
// 5397             return;
// 5398           }
// 5399 
// 5400           const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
// 5401                       ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
// 5402           int8_t i = parser.byteval('I', -1),
// 5403                  j = parser.byteval('J', -1);
// 5404 
// 5405           if (!isnan(rx) && !isnan(ry)) {
// 5406             // Get nearest i / j from rx / ry
// 5407             i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
// 5408             j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
// 5409             i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
// 5410             j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
// 5411           }
// 5412           if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
// 5413             set_bed_leveling_enabled(false);
// 5414             z_values[i][j] = rz;
// 5415             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5416               bed_level_virt_interpolate();
// 5417             #endif
// 5418             set_bed_leveling_enabled(abl_should_enable);
// 5419             if (abl_should_enable) report_current_position();
// 5420           }
// 5421           return;
// 5422         } // parser.seen('W')
// 5423       }
// 5424       //#endif
// 5425 
// 5426       // Jettison bed leveling data
// 5427       if (parser.seen('J')) {
// 5428         reset_bed_level();
// 5429         return;
// 5430       }
// 5431 
// 5432       verbose_level = parser.intval('V');
// 5433       if (!WITHIN(verbose_level, 0, 4)) {
// 5434         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 5435         return;
// 5436       }
// 5437 
// 5438       dryrun = parser.boolval('D')
// 5439         #if ENABLED(PROBE_MANUALLY)
// 5440           || no_action
// 5441         #endif
// 5442       ;
// 5443 
// 5444       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5445       if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5446         {
// 5447         do_topography_map = verbose_level > 2 || parser.boolval('T');
// 5448 
// 5449         // X and Y specify points in each direction, overriding the default
// 5450         // These values may be saved with the completed mesh
// 5451         abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
// 5452         abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
// 5453         if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
// 5454 
// 5455         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 5456           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 5457           return;
// 5458         }
// 5459 
// 5460         abl2 = abl_grid_points_x * abl_grid_points_y;
// 5461         mean = 0;
// 5462         }
// 5463       //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5464       else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5465       {
// 5466         zoffset = parser.linearval('Z');
// 5467       }
// 5468 
// 5469       //#endif
// 5470 
// 5471       //#if ABL_GRID
// 5472       if(BED_LEVELING_METHOD&ABL_GRID)  {
// 5473 
// 5474         xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
// 5475 
// 5476         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
// 5477         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
// 5478         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
// 5479         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
// 5480 
// 5481         const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
// 5482                    left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
// 5483                    right_out_r = right_probe_bed_position > MAX_PROBE_X,
// 5484                    right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
// 5485                    front_out_f = front_probe_bed_position < MIN_PROBE_Y,
// 5486                    front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
// 5487                    back_out_b = back_probe_bed_position > MAX_PROBE_Y,
// 5488                    back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
// 5489 
// 5490         if (left_out || right_out || front_out || back_out) {
// 5491           if (left_out) {
// 5492             out_of_range_error(PSTR("(L)eft"));
// 5493             left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
// 5494           }
// 5495           if (right_out) {
// 5496             out_of_range_error(PSTR("(R)ight"));
// 5497             right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
// 5498           }
// 5499           if (front_out) {
// 5500             out_of_range_error(PSTR("(F)ront"));
// 5501             front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
// 5502           }
// 5503           if (back_out) {
// 5504             out_of_range_error(PSTR("(B)ack"));
// 5505             back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
// 5506           }
// 5507           return;
// 5508         }
// 5509 
// 5510         // probe at the points of a lattice grid
// 5511         xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
// 5512         yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
// 5513       }
// 5514       //#endif // ABL_GRID
// 5515 
// 5516       if (verbose_level > 0) {
// 5517         SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
// 5518         if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
// 5519         SERIAL_EOL();
// 5520       }
// 5521 
// 5522       stepper.synchronize();
// 5523 
// 5524       // Disable auto bed leveling during G29.
// 5525       // Be formal so G29 can be done successively without G28.
// 5526       set_bed_leveling_enabled(false);
// 5527 
// 5528       #if HAS_BED_PROBE
// 5529         // Deploy the probe. Probe will raise if needed.
// 5530         if (DEPLOY_PROBE()) {
// 5531           set_bed_leveling_enabled(abl_should_enable);
// 5532           return;
// 5533         }
// 5534       #endif
// 5535 
// 5536       if (!faux) setup_for_endstop_or_probe_move();
// 5537 
// 5538       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5539       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5540       {
// 5541         #if ENABLED(PROBE_MANUALLY)
// 5542           if (!no_action)
// 5543         #endif
// 5544         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5545           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5546           || left_probe_bed_position != bilinear_start[X_AXIS]
// 5547           || front_probe_bed_position != bilinear_start[Y_AXIS]
// 5548         ) {
// 5549           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5550           reset_bed_level();
// 5551 
// 5552           // Initialize a grid with the given dimensions
// 5553           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5554           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5555           bilinear_start[X_AXIS] = left_probe_bed_position;
// 5556           bilinear_start[Y_AXIS] = front_probe_bed_position;
// 5557 
// 5558           // Can't re-enable (on error) until the new grid is written
// 5559           abl_should_enable = false;
// 5560         }
// 5561       }
// 5562       //#endif // AUTO_BED_LEVELING_BILINEAR
// 5563 
// 5564       //#if ENABLED(AUTO_BED_LEVELING_3POINT)
// 5565       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
// 5566       {
// 5567         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5568           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
// 5569         #endif
// 5570 
// 5571         // Probe at 3 arbitrary points
// 5572         points[0].z = points[1].z = points[2].z = 0;
// 5573       }
// 5574       //#endif // AUTO_BED_LEVELING_3POINT
// 5575 
// 5576     } // !g29_in_progress
// 5577 
// 5578     #if ENABLED(PROBE_MANUALLY)
// 5579 
// 5580       // For manual probing, get the next index to probe now.
// 5581       // On the first probe this will be incremented to 0.
// 5582       if (!no_action) {
// 5583         ++abl_probe_index;
// 5584         g29_in_progress = true;
// 5585       }
// 5586 
// 5587       // Abort current G29 procedure, go back to idle state
// 5588       if (seenA && g29_in_progress) {
// 5589         SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
// 5590         #if HAS_SOFTWARE_ENDSTOPS
// 5591           soft_endstops_enabled = enable_soft_endstops;
// 5592         #endif
// 5593         set_bed_leveling_enabled(abl_should_enable);
// 5594         g29_in_progress = false;
// 5595         #if ENABLED(LCD_BED_LEVELING)
// 5596           lcd_wait_for_move = false;
// 5597         #endif
// 5598       }
// 5599 
// 5600       // Query G29 status
// 5601       if (verbose_level || seenQ) {
// 5602         SERIAL_PROTOCOLPGM("Manual G29 ");
// 5603         if (g29_in_progress) {
// 5604           SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
// 5605           SERIAL_PROTOCOLLNPAIR(" of ", abl2);
// 5606         }
// 5607         else
// 5608           SERIAL_PROTOCOLLNPGM("idle");
// 5609       }
// 5610 
// 5611       if (no_action) return;
// 5612 
// 5613       if (abl_probe_index == 0) {
// 5614         // For the initial G29 save software endstop state
// 5615         #if HAS_SOFTWARE_ENDSTOPS
// 5616           enable_soft_endstops = soft_endstops_enabled;
// 5617         #endif
// 5618       }
// 5619       else {
// 5620         // For G29 after adjusting Z.
// 5621         // Save the previous Z before going to the next point
// 5622         measured_z = current_position[Z_AXIS];
// 5623 
// 5624         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5625 
// 5626           mean += measured_z;
// 5627           eqnBVector[abl_probe_index] = measured_z;
// 5628           eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5629           eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5630           eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5631 
// 5632           incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5633 
// 5634         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5635 
// 5636           z_values[xCount][yCount] = measured_z + zoffset;
// 5637 
// 5638           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5639             if (DEBUGGING(LEVELING)) {
// 5640               SERIAL_PROTOCOLPAIR("Save X", xCount);
// 5641               SERIAL_PROTOCOLPAIR(" Y", yCount);
// 5642               SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
// 5643             }
// 5644           #endif
// 5645 
// 5646         #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5647 
// 5648           points[abl_probe_index].z = measured_z;
// 5649 
// 5650         #endif
// 5651       }
// 5652 
// 5653       //
// 5654       // If there's another point to sample, move there with optional lift.
// 5655       //
// 5656 
// 5657       #if ABL_GRID
// 5658 
// 5659         // Skip any unreachable points
// 5660         while (abl_probe_index < abl2) {
// 5661 
// 5662           // Set xCount, yCount based on abl_probe_index, with zig-zag
// 5663           PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
// 5664           PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
// 5665 
// 5666           // Probe in reverse order for every other row/column
// 5667           bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
// 5668 
// 5669           if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
// 5670 
// 5671           const float xBase = xCount * xGridSpacing + left_probe_bed_position,
// 5672                       yBase = yCount * yGridSpacing + front_probe_bed_position;
// 5673 
// 5674           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5675           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5676 
// 5677           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5678             indexIntoAB[xCount][yCount] = abl_probe_index;
// 5679           #endif
// 5680 
// 5681           // Keep looping till a reachable point is found
// 5682           if(MACHINETPYE & IS_KINEMATIC)
// 5683             if (position_is_reachable_IS_KINEMATIC(xProbe, yProbe)) break;
// 5684           else
// 5685             if (position_is_reachable_IS_CARTESIAN(xProbe, yProbe)) break;
// 5686             
// 5687           ++abl_probe_index;
// 5688         }
// 5689 
// 5690         // Is there a next point to move to?
// 5691         if (abl_probe_index < abl2) {
// 5692           _manual_goto_xy(xProbe, yProbe); // Can be used here too!
// 5693           #if HAS_SOFTWARE_ENDSTOPS
// 5694             // Disable software endstops to allow manual adjustment
// 5695             // If G29 is not completed, they will not be re-enabled
// 5696             soft_endstops_enabled = false;
// 5697           #endif
// 5698           return;
// 5699         }
// 5700         else {
// 5701 
// 5702           // Leveling done! Fall through to G29 finishing code below
// 5703 
// 5704           SERIAL_PROTOCOLLNPGM("Grid probing done.");
// 5705 
// 5706           // Re-enable software endstops, if needed
// 5707           #if HAS_SOFTWARE_ENDSTOPS
// 5708             soft_endstops_enabled = enable_soft_endstops;
// 5709           #endif
// 5710         }
// 5711 
// 5712       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5713 
// 5714         // Probe at 3 arbitrary points
// 5715         if (abl_probe_index < abl2) {
// 5716           xProbe = points[abl_probe_index].x;
// 5717           yProbe = points[abl_probe_index].y;
// 5718           _manual_goto_xy(xProbe, yProbe);
// 5719           #if HAS_SOFTWARE_ENDSTOPS
// 5720             // Disable software endstops to allow manual adjustment
// 5721             // If G29 is not completed, they will not be re-enabled
// 5722             soft_endstops_enabled = false;
// 5723           #endif
// 5724           return;
// 5725         }
// 5726         else {
// 5727 
// 5728           SERIAL_PROTOCOLLNPGM("3-point probing done.");
// 5729 
// 5730           // Re-enable software endstops, if needed
// 5731           #if HAS_SOFTWARE_ENDSTOPS
// 5732             soft_endstops_enabled = enable_soft_endstops;
// 5733           #endif
// 5734 
// 5735           if (!dryrun) {
// 5736             vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5737             if (planeNormal.z < 0) {
// 5738               planeNormal.x *= -1;
// 5739               planeNormal.y *= -1;
// 5740               planeNormal.z *= -1;
// 5741             }
// 5742             planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5743 
// 5744             // Can't re-enable (on error) until the new grid is written
// 5745             abl_should_enable = false;
// 5746           }
// 5747 
// 5748         }
// 5749 
// 5750       #endif // AUTO_BED_LEVELING_3POINT
// 5751 
// 5752     #else // !PROBE_MANUALLY
// 5753     {
// 5754       const bool stow_probe_after_each = parser.boolval('E');
// 5755 
// 5756       measured_z = 0;
// 5757 
// 5758       //#if ABL_GRID
// 5759         if(BED_LEVELING_METHOD&ABL_GRID)
// 5760         {
// 5761         bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
// 5762 
// 5763         measured_z = 0;
// 5764 
// 5765         // Outer loop is Y with PROBE_Y_FIRST disabled
// 5766         for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
// 5767 
// 5768           int8_t inStart, inStop, inInc;
// 5769 
// 5770           if (zig) { // away from origin
// 5771             inStart = 0;
// 5772             inStop = PR_INNER_END;
// 5773             inInc = 1;
// 5774           }
// 5775           else {     // towards origin
// 5776             inStart = PR_INNER_END - 1;
// 5777             inStop = -1;
// 5778             inInc = -1;
// 5779           }
// 5780 
// 5781           zig ^= true; // zag
// 5782 
// 5783           // Inner loop is Y with PROBE_Y_FIRST enabled
// 5784           for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
// 5785 
// 5786             float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5787                   yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5788 
// 5789             xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5790             yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5791 
// 5792             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5793             if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5794               indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
// 5795             //#endif
// 5796 
// 5797             //#if IS_KINEMATIC
// 5798             if(MACHINETPYE & IS_KINEMATIC)
// 5799               // Avoid probing outside the round or hexagonal area
// 5800               if (!position_is_reachable_by_probe_IS_KINEMATIC(xProbe, yProbe)) continue;
// 5801             //#endif
// 5802             
// 5803             int16_t randData = rand()%200;
// 5804             if(randData > 100)  randData = 100 - randData;
// 5805 
// 5806             measured_z = faux ? 0.001 * randData/*random(-100, 101) */: probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5807 
// 5808             if (isnan(measured_z)) {
// 5809               set_bed_leveling_enabled(abl_should_enable);
// 5810               break;
// 5811             }
// 5812 
// 5813             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5814             if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5815             {
// 5816               mean += measured_z;
// 5817               /*
// 5818               eqnBVector[abl_probe_index] = measured_z;
// 5819               eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5820               eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5821               eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5822               */
// 5823             *(eqnBVector+abl_probe_index) = measured_z;
// 5824             *(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
// 5825             *(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
// 5826             *(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
// 5827 
// 5828               incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5829             }
// 5830             //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5831             else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5832             {
// 5833               z_values[xCount][yCount] = measured_z + zoffset;
// 5834             }
// 5835             //#endif
// 5836 
// 5837             abl_should_enable = false;
// 5838             idle();
// 5839 
// 5840           } // inner
// 5841         } // outer
// 5842       }
// 5843       //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5844       else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_3POINT)
// 5845       {
// 5846         // Probe at 3 arbitrary points
// 5847 
// 5848         for (uint8_t i = 0; i < 3; ++i) {
// 5849           // Retain the last probe position
// 5850           xProbe = points[i].x;
// 5851           yProbe = points[i].y;
// 5852           int16_t randData = rand()%200;
// 5853 	      if(randData > 100)	randData = 100 - randData;
// 5854           measured_z = faux ? 0.001 * randData/*random(-100, 101)*/ : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5855           if (isnan(measured_z)) {
// 5856             set_bed_leveling_enabled(abl_should_enable);
// 5857             break;
// 5858           }
// 5859           points[i].z = measured_z;
// 5860         }
// 5861 
// 5862         if (!dryrun && !isnan(measured_z)) {
// 5863           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5864           if (planeNormal.z < 0) {
// 5865             planeNormal.x *= -1;
// 5866             planeNormal.y *= -1;
// 5867             planeNormal.z *= -1;
// 5868           }
// 5869           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5870 
// 5871           // Can't re-enable (on error) until the new grid is written
// 5872           abl_should_enable = false;
// 5873         }
// 5874       }
// 5875       //#endif // AUTO_BED_LEVELING_3POINT
// 5876 
// 5877       // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
// 5878       if (STOW_PROBE()) {
// 5879         set_bed_leveling_enabled(abl_should_enable);
// 5880         measured_z = NAN;
// 5881       }
// 5882     }
// 5883     #endif // !PROBE_MANUALLY
// 5884 
// 5885     //
// 5886     // G29 Finishing Code
// 5887     //
// 5888     // Unless this is a dry run, auto bed leveling will
// 5889     // definitely be enabled after this point.
// 5890     //
// 5891     // If code above wants to continue leveling, it should
// 5892     // return or loop before this point.
// 5893     //
// 5894 
// 5895     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5896       if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
// 5897     #endif
// 5898 
// 5899     #if ENABLED(PROBE_MANUALLY)
// 5900       g29_in_progress = false;
// 5901       #if ENABLED(LCD_BED_LEVELING)
// 5902         lcd_wait_for_move = false;
// 5903       #endif
// 5904     #endif
// 5905 
// 5906     // Calculate leveling, print reports, correct the position
// 5907     if (!isnan(measured_z)) {
// 5908       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5909         if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5910         {
// 5911             if (!dryrun) extrapolate_unprobed_bed_level();
// 5912             print_bilinear_leveling_grid();
// 5913 
// 5914             refresh_bed_level();
// 5915 
// 5916             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5917               print_bilinear_leveling_grid_virt();
// 5918             #endif
// 5919        }
// 5920       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5921        else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5922         {
// 5923         // For LINEAR leveling calculate matrix, print reports, correct the position
// 5924 
// 5925         /**
// 5926          * solve the plane equation ax + by + d = z
// 5927          * A is the matrix with rows [x y 1] for all the probed points
// 5928          * B is the vector of the Z positions
// 5929          * the normal vector to the plane is formed by the coefficients of the
// 5930          * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
// 5931          * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
// 5932          */
// 5933         float plane_equation_coefficients[3];
// 5934 
// 5935         finish_incremental_LSF(&lsf_results);
// 5936         plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
// 5937         plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
// 5938         plane_equation_coefficients[2] = -lsf_results.D;
// 5939 
// 5940         mean /= abl2;
// 5941 
// 5942         if (verbose_level) {
// 5943           SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5944           SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5945           SERIAL_PROTOCOLPGM(" b: ");
// 5946           SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5947           SERIAL_PROTOCOLPGM(" d: ");
// 5948           SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5949           SERIAL_EOL();
// 5950           if (verbose_level > 2) {
// 5951             SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5952             SERIAL_PROTOCOL_F(mean, 8);
// 5953             SERIAL_EOL();
// 5954           }
// 5955         }
// 5956 
// 5957         // Create the matrix but don't correct the position yet
// 5958         if (!dryrun)
// 5959           planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5960             vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
// 5961           );
// 5962 
// 5963         // Show the Topography map if enabled
// 5964         if (do_topography_map) {
// 5965 
// 5966           SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5967                                  "   +--- BACK --+\n"
// 5968                                  "   |           |\n"
// 5969                                  " L |    (+)    | R\n"
// 5970                                  " E |           | I\n"
// 5971                                  " F | (-) N (+) | G\n"
// 5972                                  " T |           | H\n"
// 5973                                  "   |    (-)    | T\n"
// 5974                                  "   |           |\n"
// 5975                                  "   O-- FRONT --+\n"
// 5976                                  " (0,0)");
// 5977 
// 5978           float min_diff = 999;
// 5979 
// 5980           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5981             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5982               int ind = indexIntoAB[xx][yy];
// 5983               /*
// 5984               float diff = eqnBVector[ind] - mean,
// 5985                     x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5986                     y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5987                     z_tmp = 0;
// 5988                     */
// 5989                   float diff = *(eqnBVector+ind) - mean,
// 5990                         x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 5991                         y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 5992                         z_tmp = 0;
// 5993 
// 5994               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 5995 
// 5996               //NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 5997               NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
// 5998 
// 5999               if (diff >= 0.0)
// 6000                 SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
// 6001               else
// 6002                 SERIAL_PROTOCOLCHAR(' ');
// 6003               SERIAL_PROTOCOL_F(diff, 5);
// 6004             } // xx
// 6005             SERIAL_EOL();
// 6006           } // yy
// 6007           SERIAL_EOL();
// 6008 
// 6009           if (verbose_level > 3) {
// 6010             SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 6011 
// 6012             for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 6013               for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 6014                 int ind = indexIntoAB[xx][yy];
// 6015                 /*
// 6016                 float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 6017                       y_tmp = eqnAMatrix[ind + 1 * abl2],
// 6018                       z_tmp = 0;
// 6019                       */
// 6020                 float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 6021                       y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 6022                       z_tmp = 0;
// 6023 
// 6024                 apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 6025 
// 6026                 //float diff = eqnBVector[ind] - z_tmp - min_diff;
// 6027                 float diff = *(eqnBVector+ind) - z_tmp - min_diff;
// 6028                 if (diff >= 0.0)
// 6029                   SERIAL_PROTOCOLPGM(" +");
// 6030                 // Include + for column alignment
// 6031                 else
// 6032                   SERIAL_PROTOCOLCHAR(' ');
// 6033                 SERIAL_PROTOCOL_F(diff, 5);
// 6034               } // xx
// 6035               SERIAL_EOL();
// 6036             } // yy
// 6037             SERIAL_EOL();
// 6038           }
// 6039         } //do_topography_map
// 6040         }
// 6041       //#endif // AUTO_BED_LEVELING_LINEAR
// 6042 
// 6043       //#if ABL_PLANAR
// 6044       if(BED_LEVELING_METHOD&ABL_PLANAR)  {
// 6045 
// 6046         // For LINEAR and 3POINT leveling correct the current position
// 6047 
// 6048         if (verbose_level > 0)
// 6049           planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 6050 
// 6051         if (!dryrun) {
// 6052           //
// 6053           // Correct the current XYZ position based on the tilted plane.
// 6054           //
// 6055 
// 6056           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6057             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 6058           #endif
// 6059 
// 6060           float converted[XYZ];
// 6061           COPY(converted, current_position);
// 6062 
// 6063           planner.leveling_active = true;
// 6064           planner.unapply_leveling(converted); // use conversion machinery
// 6065           planner.leveling_active = false;
// 6066 
// 6067           // Use the last measured distance to the bed, if possible
// 6068           if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 6069             && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 6070           ) {
// 6071             const float simple_z = current_position[Z_AXIS] - measured_z;
// 6072             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6073               if (DEBUGGING(LEVELING)) {
// 6074                 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 6075                 SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
// 6076                 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 6077               }
// 6078             #endif
// 6079             converted[Z_AXIS] = simple_z;
// 6080           }
// 6081 
// 6082           // The rotated XY and corrected Z are now current_position
// 6083           COPY(current_position, converted);
// 6084 
// 6085           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6086             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 6087           #endif
// 6088         }
// 6089         }
// 6090       //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 6091       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 6092 
// 6093         if (!dryrun) {
// 6094           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6095             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 6096           #endif
// 6097 
// 6098           // Unapply the offset because it is going to be immediately applied
// 6099           // and cause compensation movement in Z
// 6100           current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 6101 
// 6102           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6103             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 6104           #endif
// 6105         }
// 6106         }
// 6107       //#endif // ABL_PLANAR
// 6108 
// 6109       #ifdef Z_PROBE_END_SCRIPT
// 6110         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6111           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
// 6112         #endif
// 6113         enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
// 6114         stepper.synchronize();
// 6115       #endif
// 6116 
// 6117       // Auto Bed Leveling is complete! Enable if possible.
// 6118       planner.leveling_active = dryrun ? abl_should_enable : true;
// 6119     } // !isnan(measured_z)
// 6120 
// 6121     // Restore state after probing
// 6122     if (!faux) clean_up_after_endstop_or_probe_move();
// 6123 
// 6124     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6125       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
// 6126     #endif
// 6127 
// 6128     report_current_position();
// 6129 
// 6130     KEEPALIVE_STATE(IN_HANDLER);
// 6131 
// 6132     if (planner.leveling_active)
// 6133       SYNC_PLAN_POSITION_KINEMATIC();
// 6134 
// 6135     free(eqnBVector);
// 6136 	free(eqnAMatrix);
// 6137   }
// 6138 
// 6139 #endif // OLDSCHOOL_ABL
// 6140 
// 6141 #if HAS_BED_PROBE
// 6142 
// 6143   /**
// 6144    * G30: Do a single Z probe at the current XY
// 6145    *
// 6146    * Parameters:
// 6147    *
// 6148    *   X   Probe X position (default current X)
// 6149    *   Y   Probe Y position (default current Y)
// 6150    *   E   Engage the probe for each probe
// 6151    */
// 6152   inline void gcode_G30() {
// 6153     const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
// 6154                 ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 6155     if(MACHINETPYE & IS_KINEMATIC)
// 6156         if (!position_is_reachable_by_probe_IS_KINEMATIC(xpos, ypos)) return;
// 6157     else
// 6158         if (!position_is_reachable_by_probe_IS_CARTESIAN(xpos, ypos)) return;
// 6159 
// 6160     // Disable leveling so the planner won't mess with us
// 6161     //#if HAS_LEVELING
// 6162 	if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6163       set_bed_leveling_enabled(false);
// 6164     //#endif
// 6165 
// 6166     setup_for_endstop_or_probe_move();
// 6167 
// 6168     const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
// 6169 
// 6170     if (!isnan(measured_z)) {
// 6171       SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
// 6172       SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
// 6173       SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
// 6174     }
// 6175 
// 6176     clean_up_after_endstop_or_probe_move();
// 6177 
// 6178     report_current_position();
// 6179   }
// 6180 
// 6181   #if ENABLED(Z_PROBE_SLED)
// 6182 
// 6183     /**
// 6184      * G31: Deploy the Z probe
// 6185      */
// 6186     inline void gcode_G31() { DEPLOY_PROBE(); }
// 6187 
// 6188     /**
// 6189      * G32: Stow the Z probe
// 6190      */
// 6191     inline void gcode_G32() { STOW_PROBE(); }
// 6192 
// 6193   #endif // Z_PROBE_SLED
// 6194 
// 6195 #endif // HAS_BED_PROBE
// 6196 
// 6197 #if ENABLED(DELTA_AUTO_CALIBRATION)
// 6198 
// 6199   constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
// 6200                     _4P_STEP = _7P_STEP * 2,   // 4-point step
// 6201                     NPP      = _7P_STEP * 6;   // number of calibration points on the radius
// 6202   enum CalEnum {                               // the 7 main calibration points - add definitions if needed
// 6203     CEN      = 0,
// 6204     __A      = 1,
// 6205     _AB      = __A + _7P_STEP,
// 6206     __B      = _AB + _7P_STEP,
// 6207     _BC      = __B + _7P_STEP,
// 6208     __C      = _BC + _7P_STEP,
// 6209     _CA      = __C + _7P_STEP,
// 6210   };
// 6211 
// 6212   #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
// 6213   #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
// 6214   #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
// 6215   #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
// 6216   #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
// 6217   #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
// 6218 
// 6219   static void print_signed_float(const char * const prefix, const float &f) {
// 6220     SERIAL_PROTOCOLPGM("  ");
// 6221     serialprintPGM(prefix);
// 6222     SERIAL_PROTOCOLCHAR(':');
// 6223     if (f >= 0) SERIAL_CHAR('+');
// 6224     SERIAL_PROTOCOL_F(f, 2);
// 6225   }
// 6226 
// 6227   static void print_G33_settings(const bool end_stops, const bool tower_angles) {
// 6228     SERIAL_PROTOCOLPAIR(".Height:", delta_height);
// 6229     if (end_stops) {
// 6230       print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
// 6231       print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
// 6232       print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
// 6233     }
// 6234     if (end_stops && tower_angles) {
// 6235       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 6236       SERIAL_EOL();
// 6237       SERIAL_CHAR('.');
// 6238       SERIAL_PROTOCOL_SP(13);
// 6239     }
// 6240     if (tower_angles) {
// 6241       print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
// 6242       print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
// 6243       print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
// 6244     }
// 6245     if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
// 6246       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 6247     }
// 6248     SERIAL_EOL();
// 6249   }
// 6250 
// 6251   static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
// 6252     SERIAL_PROTOCOLPGM(".    ");
// 6253     print_signed_float(PSTR("c"), z_at_pt[CEN]);
// 6254     if (tower_points) {
// 6255       print_signed_float(PSTR(" x"), z_at_pt[__A]);
// 6256       print_signed_float(PSTR(" y"), z_at_pt[__B]);
// 6257       print_signed_float(PSTR(" z"), z_at_pt[__C]);
// 6258     }
// 6259     if (tower_points && opposite_points) {
// 6260       SERIAL_EOL();
// 6261       SERIAL_CHAR('.');
// 6262       SERIAL_PROTOCOL_SP(13);
// 6263     }
// 6264     if (opposite_points) {
// 6265       print_signed_float(PSTR("yz"), z_at_pt[_BC]);
// 6266       print_signed_float(PSTR("zx"), z_at_pt[_CA]);
// 6267       print_signed_float(PSTR("xy"), z_at_pt[_AB]);
// 6268     }
// 6269     SERIAL_EOL();
// 6270   }
// 6271 
// 6272   /**
// 6273    * After G33:
// 6274    *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
// 6275    *  - Stow the probe
// 6276    *  - Restore endstops state
// 6277    *  - Select the old tool, if needed
// 6278    */
// 6279   static void G33_cleanup(
// 6280     #if HOTENDS > 1
// 6281       const uint8_t old_tool_index
// 6282     #endif
// 6283   ) {
// 6284     #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 6285       do_blocking_move_to_z(delta_clip_start_height);
// 6286     #endif
// 6287     STOW_PROBE();
// 6288     clean_up_after_endstop_or_probe_move();
// 6289     #if HOTENDS > 1
// 6290       tool_change(old_tool_index, 0, true);
// 6291     #endif
// 6292   }
// 6293 
// 6294   inline float calibration_probe(const float nx, const float ny, const bool stow) {
// 6295     #if HAS_BED_PROBE
// 6296       return probe_pt(nx, ny, stow, 0, false);
// 6297     #else
// 6298       UNUSED(stow);
// 6299       return lcd_probe_pt(nx, ny);
// 6300     #endif
// 6301   }
// 6302 
// 6303   static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
// 6304     const bool _0p_calibration      = probe_points == 0,
// 6305                _1p_calibration      = probe_points == 1,
// 6306                _4p_calibration      = probe_points == 2,
// 6307                _4p_opposite_points  = _4p_calibration && !towers_set,
// 6308                _7p_calibration      = probe_points >= 3 || probe_points == 0,
// 6309                _7p_no_intermediates = probe_points == 3,
// 6310                _7p_1_intermediates  = probe_points == 4,
// 6311                _7p_2_intermediates  = probe_points == 5,
// 6312                _7p_4_intermediates  = probe_points == 6,
// 6313                _7p_6_intermediates  = probe_points == 7,
// 6314                _7p_8_intermediates  = probe_points == 8,
// 6315                _7p_11_intermediates = probe_points == 9,
// 6316                _7p_14_intermediates = probe_points == 10,
// 6317                _7p_intermed_points  = probe_points >= 4,
// 6318                _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
// 6319                _7p_9_centre         = probe_points >= 8;
// 6320 
// 6321     LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
// 6322 
// 6323     if (!_0p_calibration) {
// 6324 
// 6325       if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
// 6326         z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
// 6327         if (isnan(z_at_pt[CEN])) return NAN;
// 6328       }
// 6329 
// 6330       if (_7p_calibration) { // probe extra center points
// 6331         const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
// 6332                     steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
// 6333         I_LOOP_CAL_PT(axis, start, steps) {
// 6334           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6335                       r = delta_calibration_radius * 0.1;
// 6336           z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 6337           if (isnan(z_at_pt[CEN])) return NAN;
// 6338        }
// 6339         z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
// 6340       }
// 6341 
// 6342       if (!_1p_calibration) {  // probe the radius
// 6343         const CalEnum start  = _4p_opposite_points ? _AB : __A;
// 6344         const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
// 6345                                _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
// 6346                                _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
// 6347                                _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
// 6348                                _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
// 6349                                _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
// 6350                                _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
// 6351                                _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
// 6352                                _4P_STEP;                                // .5r * 6 +  1c = 4
// 6353         bool zig_zag = true;
// 6354         F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
// 6355           const int8_t offset = _7p_9_centre ? 1 : 0;
// 6356           for (int8_t circle = -offset; circle <= offset; circle++) {
// 6357             const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6358                         r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
// 6359                         interpol = fmod(axis, 1);
// 6360             const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 6361             if (isnan(z_temp)) return NAN;
// 6362             // split probe point to neighbouring calibration points
// 6363             z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
// 6364             z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
// 6365           }
// 6366           zig_zag = !zig_zag;
// 6367         }
// 6368         if (_7p_intermed_points)
// 6369           LOOP_CAL_RAD(axis)
// 6370             z_at_pt[axis] /= _7P_STEP / steps;
// 6371       }
// 6372 
// 6373       float S1 = z_at_pt[CEN],
// 6374             S2 = sq(z_at_pt[CEN]);
// 6375       int16_t N = 1;
// 6376       if (!_1p_calibration) { // std dev from zero plane
// 6377         LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
// 6378           S1 += z_at_pt[axis];
// 6379           S2 += sq(z_at_pt[axis]);
// 6380           N++;
// 6381         }
// 6382         return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
// 6383       }
// 6384     }
// 6385 
// 6386     return 0.00001;
// 6387   }
// 6388 
// 6389   #if HAS_BED_PROBE
// 6390 
// 6391     static bool G33_auto_tune() {
// 6392       float z_at_pt[NPP + 1]      = { 0.0 },
// 6393             z_at_pt_base[NPP + 1] = { 0.0 },
// 6394             z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
// 6395 
// 6396       #define ZP(N,I) ((N) * z_at_pt[I])
// 6397       #define Z06(I)  ZP(6, I)
// 6398       #define Z03(I)  ZP(3, I)
// 6399       #define Z02(I)  ZP(2, I)
// 6400       #define Z01(I)  ZP(1, I)
// 6401       #define Z32(I)  ZP(3/2, I)
// 6402 
// 6403       SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
// 6404       SERIAL_EOL();
// 6405       if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
// 6406       print_G33_results(z_at_pt_base, true, true);
// 6407 
// 6408       LOOP_XYZ(axis) {
// 6409         delta_endstop_adj[axis] -= 1.0;
// 6410         recalc_delta_settings();
// 6411 
// 6412         endstops.enable(true);
// 6413         if (!home_delta()) return false;
// 6414         endstops.not_homing();
// 6415 
// 6416         SERIAL_PROTOCOLPGM("Tuning E");
// 6417         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6418         SERIAL_EOL();
// 6419 
// 6420         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6421         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6422         print_G33_results(z_at_pt, true, true);
// 6423         delta_endstop_adj[axis] += 1.0;
// 6424         recalc_delta_settings();
// 6425         switch (axis) {
// 6426           case A_AXIS :
// 6427             h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
// 6428             break;
// 6429           case B_AXIS :
// 6430             h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
// 6431             break;
// 6432           case C_AXIS :
// 6433             h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
// 6434             break;
// 6435         }
// 6436       }
// 6437       h_fac /= 3.0;
// 6438       h_fac *= norm; // Normalize to 1.02 for Kossel mini
// 6439 
// 6440       for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
// 6441         delta_radius += 1.0 * zig_zag;
// 6442         recalc_delta_settings();
// 6443 
// 6444         endstops.enable(true);
// 6445         if (!home_delta()) return false;
// 6446         endstops.not_homing();
// 6447 
// 6448         SERIAL_PROTOCOLPGM("Tuning R");
// 6449         SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
// 6450         SERIAL_EOL();
// 6451         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6452         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6453         print_G33_results(z_at_pt, true, true);
// 6454         delta_radius -= 1.0 * zig_zag;
// 6455         recalc_delta_settings();
// 6456         r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
// 6457       }
// 6458       r_fac /= 2.0;
// 6459       r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
// 6460 
// 6461       LOOP_XYZ(axis) {
// 6462         delta_tower_angle_trim[axis] += 1.0;
// 6463         delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
// 6464         delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
// 6465         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6466         delta_height -= z_temp;
// 6467         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6468         recalc_delta_settings();
// 6469 
// 6470         endstops.enable(true);
// 6471         if (!home_delta()) return false;
// 6472         endstops.not_homing();
// 6473 
// 6474         SERIAL_PROTOCOLPGM("Tuning T");
// 6475         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6476         SERIAL_EOL();
// 6477 
// 6478         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6479         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6480         print_G33_results(z_at_pt, true, true);
// 6481 
// 6482         delta_tower_angle_trim[axis] -= 1.0;
// 6483         delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
// 6484         delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
// 6485         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6486         delta_height -= z_temp;
// 6487         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6488         recalc_delta_settings();
// 6489         switch (axis) {
// 6490           case A_AXIS :
// 6491             a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
// 6492             break;
// 6493           case B_AXIS :
// 6494             a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
// 6495             break;
// 6496           case C_AXIS :
// 6497             a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
// 6498             break;
// 6499         }
// 6500       }
// 6501       a_fac /= 3.0;
// 6502       a_fac *= norm; // Normalize to 0.83 for Kossel mini
// 6503 
// 6504       endstops.enable(true);
// 6505       if (!home_delta()) return false;
// 6506       endstops.not_homing();
// 6507       print_signed_float(PSTR( "H_FACTOR: "), h_fac);
// 6508       print_signed_float(PSTR(" R_FACTOR: "), r_fac);
// 6509       print_signed_float(PSTR(" A_FACTOR: "), a_fac);
// 6510       SERIAL_EOL();
// 6511       SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
// 6512       SERIAL_EOL();
// 6513       return true;
// 6514     }
// 6515 
// 6516   #endif // HAS_BED_PROBE
// 6517 
// 6518   /**
// 6519    * G33 - Delta '1-4-7-point' Auto-Calibration
// 6520    *       Calibrate height, endstops, delta radius, and tower angles.
// 6521    *
// 6522    * Parameters:
// 6523    *
// 6524    *   Pn  Number of probe points:
// 6525    *      P0     No probe. Normalize only.
// 6526    *      P1     Probe center and set height only.
// 6527    *      P2     Probe center and towers. Set height, endstops and delta radius.
// 6528    *      P3     Probe all positions: center, towers and opposite towers. Set all.
// 6529    *      P4-P10 Probe all positions + at different itermediate locations and average them.
// 6530    *
// 6531    *   T   Don't calibrate tower angle corrections
// 6532    *
// 6533    *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
// 6534    *
// 6535    *   Fn  Force to run at least n iterations and takes the best result
// 6536    *
// 6537    *   A   Auto tune calibartion factors (set in Configuration.h)
// 6538    *
// 6539    *   Vn  Verbose level:
// 6540    *      V0  Dry-run mode. Report settings and probe results. No calibration.
// 6541    *      V1  Report start and end settings only
// 6542    *      V2  Report settings at each iteration
// 6543    *      V3  Report settings and probe results
// 6544    *
// 6545    *   E   Engage the probe for each point
// 6546    */
// 6547   inline void gcode_G33() {
// 6548 
// 6549     const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
// 6550     if (!WITHIN(probe_points, 0, 10)) {
// 6551       SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
// 6552       return;
// 6553     }
// 6554 
// 6555     const int8_t verbose_level = parser.byteval('V', 1);
// 6556     if (!WITHIN(verbose_level, 0, 3)) {
// 6557       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
// 6558       return;
// 6559     }
// 6560 
// 6561     const float calibration_precision = parser.floatval('C', 0.0);
// 6562     if (calibration_precision < 0) {
// 6563       SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
// 6564       return;
// 6565     }
// 6566 
// 6567     const int8_t force_iterations = parser.intval('F', 0);
// 6568     if (!WITHIN(force_iterations, 0, 30)) {
// 6569       SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
// 6570       return;
// 6571     }
// 6572 
// 6573     const bool towers_set           = !parser.boolval('T'),
// 6574                auto_tune            = parser.boolval('A'),
// 6575                stow_after_each      = parser.boolval('E'),
// 6576                _0p_calibration      = probe_points == 0,
// 6577                _1p_calibration      = probe_points == 1,
// 6578                _4p_calibration      = probe_points == 2,
// 6579                _7p_9_centre         = probe_points >= 8,
// 6580                _tower_results       = (_4p_calibration && towers_set)
// 6581                                       || probe_points >= 3 || probe_points == 0,
// 6582                _opposite_results    = (_4p_calibration && !towers_set)
// 6583                                       || probe_points >= 3 || probe_points == 0,
// 6584                _endstop_results     = probe_points != 1,
// 6585                _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
// 6586     const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
// 6587     int8_t iterations = 0;
// 6588     float test_precision,
// 6589           zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
// 6590           zero_std_dev_min = zero_std_dev,
// 6591           e_old[ABC] = {
// 6592             delta_endstop_adj[A_AXIS],
// 6593             delta_endstop_adj[B_AXIS],
// 6594             delta_endstop_adj[C_AXIS]
// 6595           },
// 6596           dr_old = delta_radius,
// 6597           zh_old = delta_height,
// 6598           ta_old[ABC] = {
// 6599             delta_tower_angle_trim[A_AXIS],
// 6600             delta_tower_angle_trim[B_AXIS],
// 6601             delta_tower_angle_trim[C_AXIS]
// 6602           };
// 6603 
// 6604     SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
// 6605 
// 6606     if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
// 6607       LOOP_CAL_RAD(axis) {
// 6608         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6609                     r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
// 6610         if(MACHINETPYE & IS_KINEMATIC)
// 6611         {
// 6612         if (!position_is_reachable_IS_KINEMATIC(cos(a) * r, sin(a) * r)) {
// 6613           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6614           return;
// 6615         }
// 6616         else
// 6617         {
// 6618         if (!position_is_reachable_IS_CARTESIAN(cos(a) * r, sin(a) * r)) {
// 6619           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6620           return;        
// 6621         }
// 6622         }
// 6623       }
// 6624     }
// 6625 
// 6626     stepper.synchronize();
// 6627     //#if HAS_LEVELING
// 6628     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6629       reset_bed_level(); // After calibration bed-level data is no longer valid
// 6630     //#endif
// 6631 
// 6632     #if HOTENDS > 1
// 6633       const uint8_t old_tool_index = active_extruder;
// 6634       tool_change(0, 0, true);
// 6635       #define G33_CLEANUP() G33_cleanup(old_tool_index)
// 6636     #else
// 6637       #define G33_CLEANUP() G33_cleanup()
// 6638     #endif
// 6639 
// 6640     setup_for_endstop_or_probe_move();
// 6641     endstops.enable(true);
// 6642     if (!_0p_calibration) {
// 6643       if (!home_delta())
// 6644         return;
// 6645       endstops.not_homing();
// 6646     }
// 6647 
// 6648     if (auto_tune) {
// 6649       #if HAS_BED_PROBE
// 6650         G33_auto_tune();
// 6651       #else
// 6652         SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
// 6653       #endif
// 6654       G33_CLEANUP();
// 6655       return;
// 6656     }
// 6657 
// 6658     // Report settings
// 6659 
// 6660     const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
// 6661     serialprintPGM(checkingac);
// 6662     if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
// 6663     SERIAL_EOL();
// 6664     lcd_setstatusPGM(checkingac);
// 6665 
// 6666     print_G33_settings(_endstop_results, _angle_results);
// 6667 
// 6668     do {
// 6669 
// 6670       float z_at_pt[NPP + 1] = { 0.0 };
// 6671 
// 6672       test_precision = zero_std_dev;
// 6673 
// 6674       iterations++;
// 6675 
// 6676       // Probe the points
// 6677 
// 6678       zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
// 6679       if (isnan(zero_std_dev)) {
// 6680         SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
// 6681         SERIAL_EOL();
// 6682         return G33_CLEANUP();
// 6683       }
// 6684 
// 6685       // Solve matrices
// 6686 
// 6687       if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
// 6688         if (zero_std_dev < zero_std_dev_min) {
// 6689           COPY(e_old, delta_endstop_adj);
// 6690           dr_old = delta_radius;
// 6691           zh_old = delta_height;
// 6692           COPY(ta_old, delta_tower_angle_trim);
// 6693         }
// 6694 
// 6695         float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
// 6696         const float r_diff = delta_radius - delta_calibration_radius,
// 6697                     h_factor = 1 / 6.0 *
// 6698                       #ifdef H_FACTOR
// 6699                         (H_FACTOR),                                       // Set in Configuration.h
// 6700                       #else
// 6701                         (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
// 6702                       #endif
// 6703                     r_factor = 1 / 6.0 *
// 6704                       #ifdef R_FACTOR
// 6705                         -(R_FACTOR),                                      // Set in Configuration.h
// 6706                       #else
// 6707                         -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
// 6708                       #endif
// 6709                     a_factor = 1 / 6.0 *
// 6710                       #ifdef A_FACTOR
// 6711                         (A_FACTOR);                                       // Set in Configuration.h
// 6712                       #else
// 6713                         (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
// 6714                       #endif
// 6715 
// 6716         #define ZP(N,I) ((N) * z_at_pt[I])
// 6717         #define Z6(I) ZP(6, I)
// 6718         #define Z4(I) ZP(4, I)
// 6719         #define Z2(I) ZP(2, I)
// 6720         #define Z1(I) ZP(1, I)
// 6721 
// 6722         #if !HAS_BED_PROBE
// 6723           test_precision = 0.00; // forced end
// 6724         #endif
// 6725 
// 6726         switch (probe_points) {
// 6727           case 0:
// 6728             test_precision = 0.00; // forced end
// 6729             break;
// 6730 
// 6731           case 1:
// 6732             test_precision = 0.00; // forced end
// 6733             LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
// 6734             break;
// 6735 
// 6736           case 2:
// 6737             if (towers_set) {
// 6738               e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
// 6739               e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
// 6740               e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
// 6741               r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
// 6742             }
// 6743             else {
// 6744               e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
// 6745               e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
// 6746               e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
// 6747               r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
// 6748             }
// 6749             break;
// 6750 
// 6751           default:
// 6752             e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
// 6753             e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
// 6754             e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
// 6755             r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
// 6756 
// 6757             if (towers_set) {
// 6758               t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
// 6759               t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
// 6760               t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
// 6761               e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
// 6762               e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
// 6763               e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
// 6764             }
// 6765             break;
// 6766         }
// 6767 
// 6768         LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
// 6769         delta_radius += r_delta;
// 6770         LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
// 6771       }
// 6772       else if (zero_std_dev >= test_precision) {   // step one back
// 6773         COPY(delta_endstop_adj, e_old);
// 6774         delta_radius = dr_old;
// 6775         delta_height = zh_old;
// 6776         COPY(delta_tower_angle_trim, ta_old);
// 6777       }
// 6778 
// 6779       if (verbose_level != 0) {                                    // !dry run
// 6780         // normalise angles to least squares
// 6781         if (_angle_results) {
// 6782           float a_sum = 0.0;
// 6783           LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
// 6784           LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
// 6785         }
// 6786 
// 6787         // adjust delta_height and endstops by the max amount
// 6788         const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6789         delta_height -= z_temp;
// 6790         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6791       }
// 6792       recalc_delta_settings();
// 6793       NOMORE(zero_std_dev_min, zero_std_dev);
// 6794 
// 6795       // print report
// 6796 
// 6797       if (verbose_level > 2)
// 6798         print_G33_results(z_at_pt, _tower_results, _opposite_results);
// 6799 
// 6800       if (verbose_level != 0) {                                    // !dry run
// 6801         if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
// 6802           SERIAL_PROTOCOLPGM("Calibration OK");
// 6803           SERIAL_PROTOCOL_SP(32);
// 6804           #if HAS_BED_PROBE
// 6805             if (zero_std_dev >= test_precision && !_1p_calibration)
// 6806               SERIAL_PROTOCOLPGM("rolling back.");
// 6807             else
// 6808           #endif
// 6809             {
// 6810               SERIAL_PROTOCOLPGM("std dev:");
// 6811               SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
// 6812             }
// 6813           SERIAL_EOL();
// 6814           char mess[21];
// 6815           strcpy_P(mess, PSTR("Calibration sd:"));
// 6816           if (zero_std_dev_min < 1)
// 6817             sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
// 6818           else
// 6819             sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
// 6820           lcd_setstatus(mess);
// 6821           print_G33_settings(_endstop_results, _angle_results);
// 6822           serialprintPGM(save_message);
// 6823           SERIAL_EOL();
// 6824         }
// 6825         else {                                                     // !end iterations
// 6826           char mess[15];
// 6827           if (iterations < 31)
// 6828             sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
// 6829           else
// 6830             strcpy_P(mess, PSTR("No convergence"));
// 6831           SERIAL_PROTOCOL(mess);
// 6832           SERIAL_PROTOCOL_SP(32);
// 6833           SERIAL_PROTOCOLPGM("std dev:");
// 6834           SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6835           SERIAL_EOL();
// 6836           lcd_setstatus(mess);
// 6837           if (verbose_level > 1)
// 6838             print_G33_settings(_endstop_results, _angle_results);
// 6839         }
// 6840       }
// 6841       else {                                                       // dry run
// 6842         const char *enddryrun = PSTR("End DRY-RUN");
// 6843         serialprintPGM(enddryrun);
// 6844         SERIAL_PROTOCOL_SP(35);
// 6845         SERIAL_PROTOCOLPGM("std dev:");
// 6846         SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6847         SERIAL_EOL();
// 6848 
// 6849         char mess[21];
// 6850         strcpy_P(mess, enddryrun);
// 6851         strcpy_P(&mess[11], PSTR(" sd:"));
// 6852         if (zero_std_dev < 1)
// 6853           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
// 6854         else
// 6855           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
// 6856         lcd_setstatus(mess);
// 6857       }
// 6858 
// 6859       endstops.enable(true);
// 6860       if (!home_delta())
// 6861         return;
// 6862       endstops.not_homing();
// 6863 
// 6864     }
// 6865     while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
// 6866 
// 6867     G33_CLEANUP();
// 6868   }
// 6869 
// 6870 #endif // DELTA_AUTO_CALIBRATION
// 6871 
// 6872 #if ENABLED(G38_PROBE_TARGET)
// 6873 
// 6874   static bool G38_run_probe() {
// 6875 
// 6876     bool G38_pass_fail = false;
// 6877 
// 6878     #if MULTIPLE_PROBING > 1
// 6879       // Get direction of move and retract
// 6880       float retract_mm[XYZ];
// 6881       LOOP_XYZ(i) {
// 6882         float dist = destination[i] - current_position[i];
// 6883         retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
// 6884       }
// 6885     #endif
// 6886 
// 6887     stepper.synchronize();  // wait until the machine is idle
// 6888 
// 6889     // Move until destination reached or target hit
// 6890     endstops.enable(true);
// 6891     G38_move = true;
// 6892     G38_endstop_hit = false;
// 6893     prepare_move_to_destination();
// 6894     stepper.synchronize();
// 6895     G38_move = false;
// 6896 
// 6897     endstops.hit_on_purpose();
// 6898     set_current_from_steppers_for_axis(ALL_AXES);
// 6899     SYNC_PLAN_POSITION_KINEMATIC();
// 6900 
// 6901     if (G38_endstop_hit) {
// 6902 
// 6903       G38_pass_fail = true;
// 6904 
// 6905       #if MULTIPLE_PROBING > 1
// 6906         // Move away by the retract distance
// 6907         set_destination_from_current();
// 6908         LOOP_XYZ(i) destination[i] += retract_mm[i];
// 6909         endstops.enable(false);
// 6910         prepare_move_to_destination();
// 6911         stepper.synchronize();
// 6912 
// 6913         feedrate_mm_s /= 4;
// 6914 
// 6915         // Bump the target more slowly
// 6916         LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
// 6917 
// 6918         endstops.enable(true);
// 6919         G38_move = true;
// 6920         prepare_move_to_destination();
// 6921         stepper.synchronize();
// 6922         G38_move = false;
// 6923 
// 6924         set_current_from_steppers_for_axis(ALL_AXES);
// 6925         SYNC_PLAN_POSITION_KINEMATIC();
// 6926       #endif
// 6927     }
// 6928 
// 6929     endstops.hit_on_purpose();
// 6930     endstops.not_homing();
// 6931     return G38_pass_fail;
// 6932   }
// 6933 
// 6934   /**
// 6935    * G38.2 - probe toward workpiece, stop on contact, signal error if failure
// 6936    * G38.3 - probe toward workpiece, stop on contact
// 6937    *
// 6938    * Like G28 except uses Z min probe for all axes
// 6939    */
// 6940   inline void gcode_G38(bool is_38_2) {
// 6941     // Get X Y Z E F
// 6942     gcode_get_destination();
// 6943 
// 6944     setup_for_endstop_or_probe_move();
// 6945 
// 6946     // If any axis has enough movement, do the move
// 6947     LOOP_XYZ(i)
// 6948       if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
// 6949         if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
// 6950         // If G38.2 fails throw an error
// 6951         if (!G38_run_probe() && is_38_2) {
// 6952           SERIAL_ERROR_START();
// 6953           SERIAL_ERRORLNPGM("Failed to reach target");
// 6954         }
// 6955         break;
// 6956       }
// 6957 
// 6958     clean_up_after_endstop_or_probe_move();
// 6959   }
// 6960 
// 6961 #endif // G38_PROBE_TARGET
// 6962 
// 6963 #if 1//HAS_MESH
// 6964 
// 6965   /**
// 6966    * G42: Move X & Y axes to mesh coordinates (I & J)
// 6967    */
// 6968   inline void gcode_G42() {
// 6969     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 6970       if (axis_unhomed_error()) return;
// 6971     #endif
// 6972 
// 6973     if (IsRunning()) {
// 6974       const bool hasI = parser.seenval('I');
// 6975       const int8_t ix = hasI ? parser.value_int() : 0;
// 6976       const bool hasJ = parser.seenval('J');
// 6977       const int8_t iy = hasJ ? parser.value_int() : 0;
// 6978 
// 6979       if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
// 6980         SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
// 6981         return;
// 6982       }
// 6983 
// 6984       set_destination_from_current();
// 6985       if (hasI) 
// 6986       {
// 6987         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 6988             destination[X_AXIS] = _GET_MESH_X_ABL(ix);
// 6989         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 6990             destination[X_AXIS] = _GET_MESH_X_UBL(ix);
// 6991         if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 6992             destination[X_AXIS] = _GET_MESH_X_MBL(ix);        
// 6993       }
// 6994       if (hasJ) 
// 6995       {
// 6996         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 6997             destination[Y_AXIS] = _GET_MESH_Y_ABL (iy);
// 6998         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 6999             destination[Y_AXIS] = _GET_MESH_Y_UBL(iy);
// 7000         if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 7001             destination[Y_AXIS] = _GET_MESH_Y_MBL(iy);        
// 7002       }         
// 7003       if (parser.boolval('P')) {
// 7004         if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 7005         if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 7006       }
// 7007 
// 7008       const float fval = parser.linearval('F');
// 7009       if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
// 7010 
// 7011       // SCARA kinematic has "safe" XY raw moves
// 7012       //#if IS_SCARA
// 7013       if(MACHINETPYE & IS_SCARA)
// 7014         prepare_uninterpolated_move_to_destination();
// 7015       //#else
// 7016       else
// 7017         prepare_move_to_destination();
// 7018       //#endif
// 7019     }
// 7020   }
// 7021 
// 7022 #endif // HAS_MESH
// 7023 #if 0
// 7024 /**
// 7025  * G92: Set current position to given X Y Z E
// 7026  */
// 7027 inline void gcode_G92() {
// 7028 
// 7029   stepper.synchronize();
// 7030 
// 7031   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7032     switch (parser.subcode) {
// 7033       case 1:
// 7034         // Zero the G92 values and restore current position
// 7035         #if !IS_SCARA
// 7036           LOOP_XYZ(i) {
// 7037             const float v = position_shift[i];
// 7038             if (v) {
// 7039               position_shift[i] = 0;
// 7040               update_software_endstops((AxisEnum)i);
// 7041             }
// 7042           }
// 7043         #endif // Not SCARA
// 7044         return;
// 7045     }
// 7046   #endif
// 7047 
// 7048   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7049     #define IS_G92_0 (parser.subcode == 0)
// 7050   #else
// 7051     #define IS_G92_0 true
// 7052   #endif
// 7053 
// 7054   bool didE = false;
// 7055   bool didXYZ = false;
// 7056   //#if IS_SCARA || !HAS_POSITION_SHIFT
// 7057   if(MACHINETPYE&IS_SCARA) {
// 7058     //bool 
// 7059     didXYZ = false;
// 7060   }
// 7061   //#else
// 7062   else
// 7063   {
// 7064   	#if !HAS_POSITION_SHIFT
// 7065 		//bool 
// 7066 		didXYZ = false;	
// 7067   	#else
// 7068 		//constexpr bool 
// 7069 		didXYZ = false;
// 7070 	#endif
// 7071   }
// 7072   //#endif
// 7073 
// 7074   if (IS_G92_0) LOOP_XYZE(i) {
// 7075     if (parser.seenval(axis_codes[i])) {
// 7076       const float l = parser.value_axis_units((AxisEnum)i),
// 7077                   v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
// 7078                   d = v - current_position[i];
// 7079       if (!NEAR_ZERO(d)) {
// 7080         //#if IS_SCARA || !HAS_POSITION_SHIFT
// 7081         if(MACHINETPYE&IS_SCARA) {
// 7082           if (i == E_AXIS) didE = true; else didXYZ = true;
// 7083           current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
// 7084         }
// 7085 		else
// 7086 		{
// 7087 			#if HAS_POSITION_SHIFT
// 7088 	          if (i == E_AXIS) {
// 7089 	            didE = true;
// 7090 	            current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
// 7091 	          }
// 7092 	          else {
// 7093 	            position_shift[i] += d;       // Other axes simply offset the coordinate space
// 7094 	            update_software_endstops((AxisEnum)i);
// 7095 	          }
// 7096 			
// 7097         	#endif
// 7098 		}
// 7099       }
// 7100     }
// 7101   }
// 7102 
// 7103   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7104     // Apply workspace offset to the active coordinate system
// 7105     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 7106       COPY(coordinate_system[active_coordinate_system], position_shift);
// 7107   #endif
// 7108 
// 7109   if (didXYZ)
// 7110     SYNC_PLAN_POSITION_KINEMATIC();
// 7111   else if (didE)
// 7112     sync_plan_position_e();
// 7113 
// 7114   report_current_position();
// 7115 }
// 7116 #else
// 7117 
// 7118 /**
// 7119  * G92: Set current position to given X Y Z E
// 7120  */
// 7121 inline void gcode_G92() {
// 7122   bool didXYZ = false,
// 7123        didE = parser.seen('E');
// 7124 
// 7125   if (!didE) stepper.synchronize();
// 7126 
// 7127   LOOP_XYZE(i) {
// 7128     if (parser.seenval(axis_codes[i])) {
// 7129       //#if IS_SCARA
// 7130       if(MACHINETPYE&IS_SCARA)
// 7131       {
// 7132         current_position[i] = parser.value_axis_units((AxisEnum)i);
// 7133         if (i != E_AXIS) didXYZ = true;
// 7134       }
// 7135       //#else
// 7136       else
// 7137       {
// 7138         #if HAS_POSITION_SHIFT
// 7139           const float p = current_position[i];
// 7140         #endif
// 7141         float v = parser.value_axis_units((AxisEnum)i);
// 7142 
// 7143         current_position[i] = v;
// 7144 
// 7145         if (i != E_AXIS) {
// 7146           didXYZ = true;
// 7147           #if HAS_POSITION_SHIFT
// 7148             position_shift[i] += v - p; // Offset the coordinate space
// 7149             update_software_endstops((AxisEnum)i);
// 7150           #endif
// 7151         }
// 7152       }
// 7153       //#endif
// 7154     }
// 7155   }
// 7156   if (didXYZ)
// 7157     SYNC_PLAN_POSITION_KINEMATIC();
// 7158   else if (didE)
// 7159     sync_plan_position_e();
// 7160 
// 7161   report_current_position();
// 7162 }
// 7163 
// 7164 #endif
// 7165 #if HAS_RESUME_CONTINUE
// 7166 
// 7167   /**
// 7168    * M0: Unconditional stop - Wait for user button press on LCD
// 7169    * M1: Conditional stop   - Wait for user button press on LCD
// 7170    */
// 7171   inline void gcode_M0_M1() {
// 7172     const char * const args = parser.string_arg;
// 7173 
// 7174     millis_t ms = 0;
// 7175     bool hasP = false, hasS = false;
// 7176     if (parser.seenval('P')) {
// 7177       ms = parser.value_millis(); // milliseconds to wait
// 7178       hasP = ms > 0;
// 7179     }
// 7180     if (parser.seenval('S')) {
// 7181       ms = parser.value_millis_from_seconds(); // seconds to wait
// 7182       hasS = ms > 0;
// 7183     }
// 7184 
// 7185     #if ENABLED(ULTIPANEL)
// 7186 
// 7187       if (!hasP && !hasS && args && *args)
// 7188         lcd_setstatus(args, true);
// 7189       else {
// 7190         LCD_MESSAGEPGM(MSG_USERWAIT);
// 7191         #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
// 7192           dontExpireStatus();
// 7193         #endif
// 7194       }
// 7195 
// 7196     #else
// 7197 
// 7198       if (!hasP && !hasS && args && *args) {
// 7199         SERIAL_ECHO_START();
// 7200         SERIAL_ECHOLN(args);
// 7201       }
// 7202 
// 7203     #endif
// 7204 
// 7205     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7206     wait_for_user = true;
// 7207 
// 7208     stepper.synchronize();
// 7209     refresh_cmd_timeout();
// 7210 
// 7211     if (ms > 0) {
// 7212       ms += previous_cmd_ms;  // wait until this time for a click
// 7213       while (PENDING(millis(), ms) && wait_for_user) idle();
// 7214     }
// 7215     else {
// 7216       #if ENABLED(ULTIPANEL)
// 7217         if (lcd_detected()) {
// 7218           while (wait_for_user) idle();
// 7219           print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
// 7220         }
// 7221       #else
// 7222         while (wait_for_user) idle();
// 7223       #endif
// 7224     }
// 7225 
// 7226     wait_for_user = false;
// 7227     KEEPALIVE_STATE(IN_HANDLER);
// 7228   }
// 7229 
// 7230 #endif // HAS_RESUME_CONTINUE
// 7231 
// 7232 #if ENABLED(SPINDLE_LASER_ENABLE)
// 7233   /**
// 7234    * M3: Spindle Clockwise
// 7235    * M4: Spindle Counter-clockwise
// 7236    *
// 7237    *  S0 turns off spindle.
// 7238    *
// 7239    *  If no speed PWM output is defined then M3/M4 just turns it on.
// 7240    *
// 7241    *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
// 7242    *  Hardware PWM is required. ISRs are too slow.
// 7243    *
// 7244    * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
// 7245    *       No other settings give a PWM signal that goes from 0 to 5 volts.
// 7246    *
// 7247    *       The system automatically sets WGM to Mode 1, so no special
// 7248    *       initialization is needed.
// 7249    *
// 7250    *       WGM bits for timer 2 are automatically set by the system to
// 7251    *       Mode 1. This produces an acceptable 0 to 5 volt signal.
// 7252    *       No special initialization is needed.
// 7253    *
// 7254    * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
// 7255    *       factors for timers 2, 3, 4, and 5 are acceptable.
// 7256    *
// 7257    *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
// 7258    *  the spindle/laser during power-up or when connecting to the host
// 7259    *  (usually goes through a reset which sets all I/O pins to tri-state)
// 7260    *
// 7261    *  PWM duty cycle goes from 0 (off) to 255 (always on).
// 7262    */
// 7263 
// 7264   // Wait for spindle to come up to speed
// 7265   inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
// 7266 
// 7267   // Wait for spindle to stop turning
// 7268   inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
// 7269 
// 7270   /**
// 7271    * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
// 7272    *
// 7273    * it accepts inputs of 0-255
// 7274    */
// 7275 
// 7276   inline void ocr_val_mode() {
// 7277     uint8_t spindle_laser_power = parser.value_byte();
// 7278     WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
// 7279     if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
// 7280     analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
// 7281   }
// 7282 
// 7283   inline void gcode_M3_M4(bool is_M3) {
// 7284 
// 7285     stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
// 7286     #if SPINDLE_DIR_CHANGE
// 7287       const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
// 7288       if (SPINDLE_STOP_ON_DIR_CHANGE \ 
// 7289          && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \ 
// 7290          && READ(SPINDLE_DIR_PIN) != rotation_dir
// 7291       ) {
// 7292         WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
// 7293         delay_for_power_down();
// 7294       }
// 7295       WRITE(SPINDLE_DIR_PIN, rotation_dir);
// 7296     #endif
// 7297 
// 7298     /**
// 7299      * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
// 7300      * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
// 7301      * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
// 7302      */
// 7303     #if ENABLED(SPINDLE_LASER_PWM)
// 7304       if (parser.seen('O')) ocr_val_mode();
// 7305       else {
// 7306         const float spindle_laser_power = parser.floatval('S');
// 7307         if (spindle_laser_power == 0) {
// 7308           WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
// 7309           analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
// 7310           delay_for_power_down();
// 7311         }
// 7312         else {
// 7313           int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
// 7314           NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
// 7315           if (spindle_laser_power <= SPEED_POWER_MIN)
// 7316             ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
// 7317           if (spindle_laser_power >= SPEED_POWER_MAX)
// 7318             ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
// 7319           if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
// 7320           WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
// 7321           analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
// 7322           delay_for_power_up();
// 7323         }
// 7324       }
// 7325     #else
// 7326       WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
// 7327       delay_for_power_up();
// 7328     #endif
// 7329   }
// 7330 
// 7331  /**
// 7332   * M5 turn off spindle
// 7333   */
// 7334   inline void gcode_M5() {
// 7335     stepper.synchronize();
// 7336     WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
// 7337     delay_for_power_down();
// 7338   }
// 7339 
// 7340 #endif // SPINDLE_LASER_ENABLE
// 7341 
// 7342 /**
// 7343  * M17: Enable power on all stepper motors
// 7344  */
// 7345 inline void gcode_M17() {
// 7346   LCD_MESSAGEPGM(MSG_NO_MOVE);
// 7347   enable_all_steppers();
// 7348 }
// 7349 
// 7350 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 7351 
// 7352   static float resume_position[XYZE];
// 7353   static bool move_away_flag = false;
// 7354   #if ENABLED(SDSUPPORT)
// 7355     static bool sd_print_paused = false;
// 7356   #endif
// 7357 
// 7358   static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
// 7359     static millis_t next_buzz = 0;
// 7360     static int8_t runout_beep = 0;
// 7361 
// 7362     if (init) next_buzz = runout_beep = 0;
// 7363 
// 7364     const millis_t ms = millis();
// 7365     if (ELAPSED(ms, next_buzz)) {
// 7366       if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
// 7367         next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
// 7368         BUZZ(300, 2000);
// 7369         runout_beep++;
// 7370       }
// 7371     }
// 7372   }
// 7373 
// 7374   static void ensure_safe_temperature() {
// 7375     bool heaters_heating = true;
// 7376 
// 7377     wait_for_heatup = true;    // M108 will clear this
// 7378     while (wait_for_heatup && heaters_heating) {
// 7379       idle();
// 7380       heaters_heating = false;
// 7381       HOTEND_LOOP() {
// 7382         if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
// 7383           heaters_heating = true;
// 7384           #if ENABLED(ULTIPANEL)
// 7385             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
// 7386           #endif
// 7387           break;
// 7388         }
// 7389       }
// 7390     }
// 7391   }
// 7392 
// 7393   #if IS_KINEMATIC
// 7394     #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
// 7395   #else
// 7396     #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
// 7397   #endif
// 7398 
// 7399   void do_pause_e_move(const float &length, const float fr) {
// 7400     current_position[E_AXIS] += length / planner.e_factor[active_extruder];
// 7401     set_destination_from_current();
// 7402     RUNPLAN(fr);
// 7403     stepper.synchronize();
// 7404   }
// 7405 
// 7406   static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
// 7407                           const int8_t max_beep_count = 0, const bool show_lcd = false
// 7408   ) {
// 7409     if (move_away_flag) return false; // already paused
// 7410 
// 7411     #ifdef ACTION_ON_PAUSE
// 7412       SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
// 7413     #endif
// 7414 
// 7415     if (!DEBUGGING(DRYRUN) && unload_length != 0) {
// 7416       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 7417         if (!thermalManager.allow_cold_extrude &&
// 7418             thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
// 7419           SERIAL_ERROR_START();
// 7420           SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
// 7421           return false;
// 7422         }
// 7423       #endif
// 7424 
// 7425       ensure_safe_temperature(); // wait for extruder to heat up before unloading
// 7426     }
// 7427 
// 7428     // Indicate that the printer is paused
// 7429     move_away_flag = true;
// 7430 
// 7431     // Pause the print job and timer
// 7432     #if ENABLED(SDSUPPORT)
// 7433       if (card.sdprinting) {
// 7434         card.pauseSDPrint();
// 7435         sd_print_paused = true;
// 7436       }
// 7437     #endif
// 7438     print_job_timer.pause();
// 7439 
// 7440     // Show initial message and wait for synchronize steppers
// 7441     if (show_lcd) {
// 7442       #if ENABLED(ULTIPANEL)
// 7443         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
// 7444       #endif
// 7445     }
// 7446 
// 7447     // Save current position
// 7448     stepper.synchronize();
// 7449     COPY(resume_position, current_position);
// 7450 
// 7451     // Initial retract before move to filament change position
// 7452     if (retract && !thermalManager.tooColdToExtrude(active_extruder))
// 7453       do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
// 7454 
// 7455     // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
// 7456     Nozzle::park(2, park_point);
// 7457 
// 7458     if (unload_length != 0) {
// 7459       if (show_lcd) {
// 7460         #if ENABLED(ULTIPANEL)
// 7461           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
// 7462           idle();
// 7463         #endif
// 7464       }
// 7465 
// 7466       // Unload filament
// 7467       do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
// 7468     }
// 7469 
// 7470     if (show_lcd) {
// 7471       #if ENABLED(ULTIPANEL)
// 7472         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7473       #endif
// 7474     }
// 7475 
// 7476     #if HAS_BUZZER
// 7477       filament_change_beep(max_beep_count, true);
// 7478     #endif
// 7479 
// 7480     idle();
// 7481 
// 7482     // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
// 7483     #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
// 7484       disable_e_steppers();
// 7485       safe_delay(100);
// 7486     #endif
// 7487 
// 7488     // Start the heater idle timers
// 7489     const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7490 
// 7491     HOTEND_LOOP()
// 7492       thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7493 
// 7494     return true;
// 7495   }
// 7496 
// 7497   static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
// 7498     bool nozzle_timed_out = false;
// 7499 
// 7500     // Wait for filament insert by user and press button
// 7501     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7502     wait_for_user = true;    // LCD click or M108 will clear this
// 7503     while (wait_for_user) {
// 7504       #if HAS_BUZZER
// 7505         filament_change_beep(max_beep_count);
// 7506       #endif
// 7507 
// 7508       // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
// 7509       // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
// 7510       if (!nozzle_timed_out)
// 7511         HOTEND_LOOP()
// 7512           nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7513 
// 7514       if (nozzle_timed_out) {
// 7515         #if ENABLED(ULTIPANEL)
// 7516           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 7517         #endif
// 7518 
// 7519         // Wait for LCD click or M108
// 7520         while (wait_for_user) idle(true);
// 7521 
// 7522         // Re-enable the heaters if they timed out
// 7523         HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
// 7524 
// 7525         // Wait for the heaters to reach the target temperatures
// 7526         ensure_safe_temperature();
// 7527 
// 7528         #if ENABLED(ULTIPANEL)
// 7529           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7530         #endif
// 7531 
// 7532         // Start the heater idle timers
// 7533         const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7534 
// 7535         HOTEND_LOOP()
// 7536           thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7537 
// 7538         wait_for_user = true; /* Wait for user to load filament */
// 7539         nozzle_timed_out = false;
// 7540 
// 7541         #if HAS_BUZZER
// 7542           filament_change_beep(max_beep_count, true);
// 7543         #endif
// 7544       }
// 7545 
// 7546       idle(true);
// 7547     }
// 7548     KEEPALIVE_STATE(IN_HANDLER);
// 7549   }
// 7550 
// 7551   static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
// 7552     bool nozzle_timed_out = false;
// 7553 
// 7554     if (!move_away_flag) return;
// 7555 
// 7556     // Re-enable the heaters if they timed out
// 7557     HOTEND_LOOP() {
// 7558       nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7559       thermalManager.reset_heater_idle_timer(e);
// 7560     }
// 7561 
// 7562     if (nozzle_timed_out) ensure_safe_temperature();
// 7563 
// 7564     #if HAS_BUZZER
// 7565       filament_change_beep(max_beep_count, true);
// 7566     #endif
// 7567 
// 7568     set_destination_from_current();
// 7569 
// 7570     if (load_length != 0) {
// 7571       #if ENABLED(ULTIPANEL)
// 7572         // Show "insert filament"
// 7573         if (nozzle_timed_out)
// 7574           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7575       #endif
// 7576 
// 7577       KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7578       wait_for_user = true;    // LCD click or M108 will clear this
// 7579       while (wait_for_user && nozzle_timed_out) {
// 7580         #if HAS_BUZZER
// 7581           filament_change_beep(max_beep_count);
// 7582         #endif
// 7583         idle(true);
// 7584       }
// 7585       KEEPALIVE_STATE(IN_HANDLER);
// 7586 
// 7587       #if ENABLED(ULTIPANEL)
// 7588         // Show "load" message
// 7589         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
// 7590       #endif
// 7591 
// 7592       // Load filament
// 7593       do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
// 7594     }
// 7595 
// 7596     #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
// 7597 
// 7598       if (!thermalManager.tooColdToExtrude(active_extruder)) {
// 7599         float extrude_length = initial_extrude_length;
// 7600 
// 7601         do {
// 7602           if (extrude_length > 0) {
// 7603             // "Wait for filament extrude"
// 7604             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
// 7605 
// 7606             // Extrude filament to get into hotend
// 7607             do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
// 7608           }
// 7609 
// 7610           // Show "Extrude More" / "Resume" menu and wait for reply
// 7611           KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7612           wait_for_user = false;
// 7613           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
// 7614           while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
// 7615           KEEPALIVE_STATE(IN_HANDLER);
// 7616 
// 7617           extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
// 7618 
// 7619           // Keep looping if "Extrude More" was selected
// 7620         } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
// 7621       }
// 7622 
// 7623     #endif
// 7624 
// 7625     #if ENABLED(ULTIPANEL)
// 7626       // "Wait for print to resume"
// 7627       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
// 7628     #endif
// 7629 
// 7630     // Set extruder to saved position
// 7631     destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
// 7632     planner.set_e_position_mm(current_position[E_AXIS]);
// 7633 
// 7634     // Move XY to starting position, then Z
// 7635     do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
// 7636     do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
// 7637 
// 7638     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 7639       filament_ran_out = false;
// 7640     #endif
// 7641 
// 7642     #if ENABLED(ULTIPANEL)
// 7643       // Show status screen
// 7644       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
// 7645     #endif
// 7646 
// 7647     #ifdef ACTION_ON_RESUME
// 7648       SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
// 7649     #endif
// 7650 
// 7651     #if ENABLED(SDSUPPORT)
// 7652       if (sd_print_paused) {
// 7653         card.startFileprint();
// 7654         sd_print_paused = false;
// 7655       }
// 7656     #endif
// 7657 
// 7658     move_away_flag = false;
// 7659   }
// 7660 #endif // ADVANCED_PAUSE_FEATURE
// 7661 
// 7662 #if ENABLED(SDSUPPORT)
// 7663 
// 7664   /**
// 7665    * M20: List SD card to serial output
// 7666    */
// 7667   inline void gcode_M20() {
// 7668     SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
// 7669     card.ls();
// 7670     SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
// 7671   }
// 7672 
// 7673   /**
// 7674    * M21: Init SD Card
// 7675    */
// 7676   inline void gcode_M21() { card.initsd(); }
// 7677 
// 7678   /**
// 7679    * M22: Release SD Card
// 7680    */
// 7681   inline void gcode_M22() { card.release(); }
// 7682 
// 7683   /**
// 7684    * M23: Open a file
// 7685    */
// 7686    #ifdef USE_MKS_WIFI    
// 7687   inline void gcode_M23() { 
// 7688   	if(card.openFile(parser.command_ptr, true) < 0)
// 7689   	{
// 7690   		/*for 8.3 principle*/
// 7691 		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
// 7692 		if(!gSuffix)
// 7693 		{
// 7694 			gSuffix = strstr((char *)parser.command_ptr, ".G");		
// 7695 		}
// 7696 		if(gSuffix)
// 7697 		{
// 7698 			*(gSuffix + 2) = '\0';
// 7699 			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
// 7700 			{
// 7701 				parser.command_ptr[7] = '~';
// 7702 				parser.command_ptr[8] = '.';
// 7703 				parser.command_ptr[9] = 'g';
// 7704 				parser.command_ptr[10] = '\0';
// 7705 			}
// 7706 			card.openFile(parser.command_ptr, true) ;
// 7707 		}
// 7708   	}
// 7709   }
// 7710 #else
// 7711   inline void gcode_M23() {
// 7712     // Simplify3D includes the size, so zero out all spaces (#7227)
// 7713     for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
// 7714     card.openFile(parser.string_arg, true);
// 7715     strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
// 7716   }
// 7717 #endif
// 7718   /**
// 7719    * M24: Start or Resume SD Print
// 7720    */
// 7721   inline void gcode_M24() {
// 7722   	mks_resumePrint();
// 7723   
// 7724     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7725       resume_print();
// 7726     #endif
// 7727 	
// 7728 	#ifdef USE_MKS_WIFI
// 7729 	if(card.lastOpenOk())
// 7730 	#endif	
// 7731 		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
// 7732 		{
// 7733 
// 7734 	    	card.startFileprint();
// 7735 	    	print_job_timer.start();
// 7736 		}
// 7737   }
// 7738 
// 7739   /**
// 7740    * M25: Pause SD Print
// 7741    */
// 7742   inline void gcode_M25() {
// 7743     card.pauseSDPrint();
// 7744     print_job_timer.pause();
// 7745 
// 7746     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7747       enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
// 7748     #endif
// 7749 	
// 7750 	mksReprint.mks_printer_state = MKS_PAUSING;
// 7751   }
// 7752 /**
// 7753 	 * M998: Stop SD Print
// 7754 */
// 7755 	inline void gcode_M998() {
// 7756 		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
// 7757 		return;
// 7758 			
// 7759 		mksReprint.mks_printer_state = MKS_IDLE;
// 7760         if(gCfgItems.pwroff_save_mode != 1)
// 7761 		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
// 7762 
// 7763 		card.stopSDPrint();
// 7764 		clear_command_queue();
// 7765 		quickstop_stepper();
// 7766 		print_job_timer.stop();
// 7767 		thermalManager.disable_all_heaters();
// 7768 		#if FAN_COUNT > 0
// 7769 			for (uint8_t i = 0; i < FAN_COUNT; i++) 
// 7770             {         
// 7771                 fanSpeeds[i] = 0;
// 7772                 #if 1
// 7773                 MKS_FAN_TIM = 0 ;
// 7774                 #endif
// 7775              }
// 7776 		#endif
// 7777 		wait_for_heatup = false;
// 7778 	}
// 7779 
// 7780   /**
// 7781    * M26: Set SD Card file index
// 7782    */
// 7783   inline void gcode_M26() {
// 7784     if (card.cardOK && parser.seenval('S'))
// 7785       card.setIndex(parser.value_long());
// 7786   }
// 7787 
// 7788   /**
// 7789    * M27: Get SD Card status
// 7790    */
// 7791   inline void gcode_M27() { card.getStatus(); }
// 7792 
// 7793   /**
// 7794    * M28: Start SD Write
// 7795    */
// 7796   inline void gcode_M28() { card.openFile(parser.string_arg, false); }
// 7797 
// 7798   /**
// 7799    * M29: Stop SD Write
// 7800    * Processed in write to file routine above
// 7801    */
// 7802   inline void gcode_M29() {
// 7803     // card.saving = false;
// 7804   }
// 7805 
// 7806   /**
// 7807    * M30 <filename>: Delete SD Card file
// 7808    */
// 7809   inline void gcode_M30() {
// 7810     if (card.cardOK) {
// 7811       card.closefile();
// 7812       card.removeFile(parser.string_arg);
// 7813     }
// 7814   }
// 7815 
// 7816 #endif // SDSUPPORT
// 7817 
// 7818 /**
// 7819  * M31: Get the time since the start of SD Print (or last M109)
// 7820  */
// 7821 inline void gcode_M31() {
// 7822   char buffer[21];
// 7823   duration_t elapsed = print_job_timer.duration();
// 7824   elapsed.toString(buffer);
// 7825   lcd_setstatus(buffer);
// 7826 
// 7827   SERIAL_ECHO_START();
// 7828   SERIAL_ECHOLNPAIR("Print time: ", buffer);
// 7829 }
// 7830 
// 7831 #if ENABLED(SDSUPPORT)
// 7832 
// 7833   /**
// 7834    * M32: Select file and start SD Print
// 7835    *
// 7836    * Examples:
// 7837    *
// 7838    *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
// 7839    *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
// 7840    *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
// 7841    *
// 7842    */
// 7843   inline void gcode_M32() {
// 7844     if (card.sdprinting) stepper.synchronize();
// 7845 
// 7846     if (card.cardOK|| card.usbOK) {
// 7847       const bool call_procedure = parser.boolval('P');
// 7848 
// 7849       card.openFile(parser.string_arg, true, call_procedure);
// 7850 
// 7851       if (parser.seenval('S')) card.setIndex(parser.value_long());
// 7852 
// 7853       card.startFileprint();
// 7854 
// 7855       // Procedure calls count as normal print time.
// 7856       if (!call_procedure) print_job_timer.start();
// 7857     }
// 7858   }
// 7859 
// 7860   #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 7861 
// 7862     /**
// 7863      * M33: Get the long full path of a file or folder
// 7864      *
// 7865      * Parameters:
// 7866      *   <dospath> Case-insensitive DOS-style path to a file or folder
// 7867      *
// 7868      * Example:
// 7869      *   M33 miscel~1/armchair/armcha~1.gco
// 7870      *
// 7871      * Output:
// 7872      *   /Miscellaneous/Armchair/Armchair.gcode
// 7873      */
// 7874     inline void gcode_M33() {
// 7875       card.printLongPath(parser.string_arg);
// 7876     }
// 7877 
// 7878   #endif
// 7879 
// 7880   #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 7881     /**
// 7882      * M34: Set SD Card Sorting Options
// 7883      */
// 7884     inline void gcode_M34() {
// 7885       if (parser.seen('S')) card.setSortOn(parser.value_bool());
// 7886       if (parser.seenval('F')) {
// 7887         const int v = parser.value_long();
// 7888         card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
// 7889       }
// 7890       //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
// 7891     }
// 7892   #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 7893 
// 7894   /**
// 7895    * M928: Start SD Write
// 7896    */
// 7897   inline void gcode_M928() {
// 7898     card.openLogFile(parser.string_arg);
// 7899   }
// 7900 
// 7901 #endif // SDSUPPORT
// 7902 
// 7903 /**
// 7904  * Sensitive pin test for M42, M226
// 7905  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function _Z16pin_is_protecteda
          CFI NoCalls
        THUMB
// 7906 static bool pin_is_protected(const int8_t pin) {
// 7907   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
// 7908   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
_Z16pin_is_protecteda:
        MOVS     R1,#+0
        B.N      ??pin_is_protected_0
??pin_is_protected_1:
        ADDS     R1,R1,#+1
??pin_is_protected_0:
        UXTB     R1,R1
        CMP      R1,#+51
        BCS.N    ??pin_is_protected_2
// 7909     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
        ADR.W    R2,??sensitive_pins
        LDRSB    R2,[R1, R2]
        CMP      R0,R2
        BNE.N    ??pin_is_protected_1
        MOVS     R0,#+1
        BX       LR
// 7910   return false;
??pin_is_protected_2:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock60
// 7911 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??sensitive_pins:
        DC8 0, 1, 1, 0, 2, 3, 3, 6, 5, 7, 8, 8, 11, 10, 12, 13, 14, 14, -1, 21
        DC8 17, -1, -1, -1, 16, 15, 17, -1, -1, 19, 18, 20, -1, -1, 21, 78, 22
        DC8 -1, 79, 23, -1, 80, 19, 18, 20, -1, -1, -1, -1, -1, -1, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        SECTION_GROUP _ZTI5Print
// __absolute char const <Typeinfo for Print>
_ZTI5Print:
        DATA
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs
// __absolute char const <_ZZNK10duration_t8toStringEPcEs>[20]
_ZZNK10duration_t8toStringEPcEs:
        DATA
        DC8 "%iy %id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_0
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_0>[16]
_ZZNK10duration_t8toStringEPcEs_0:
        DATA
        DC8 "%id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_1
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_1>[12]
_ZZNK10duration_t8toStringEPcEs_1:
        DATA
        DC8 "%ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_2
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_2>[8]
_ZZNK10duration_t8toStringEPcEs_2:
        DATA
        DC8 "%im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_3
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_3>[4]
_ZZNK10duration_t8toStringEPcEs_3:
        DATA
        DC8 "%is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs
// __absolute char const <_ZZ19get_serial_commandsvEs>[5]
_ZZ19get_serial_commandsvEs:
        DATA
        DC8 "M110"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_0
// __absolute char const <_ZZ19get_serial_commandsvEs_0>[51]
_ZZ19get_serial_commandsvEs_0:
        DATA
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 69H, 73H, 20H, 6EH
        DC8 6FH, 74H, 20H, 4CH, 61H, 73H, 74H, 20H
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 2BH, 31H, 2CH, 20H, 4CH
        DC8 61H, 73H, 74H, 20H, 4CH, 69H, 6EH, 65H
        DC8 3AH, 20H, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_1
// __absolute char const <_ZZ19get_serial_commandsvEs_1>[31]
_ZZ19get_serial_commandsvEs_1:
        DATA
        DC8 "checksum mismatch, Last Line: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_2
// __absolute char const <_ZZ19get_serial_commandsvEs_2>[42]
_ZZ19get_serial_commandsvEs_2:
        DATA
        DC8 "No Checksum with line number, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_3
// __absolute char const <_ZZ19get_serial_commandsvEs_3>[119]
_ZZ19get_serial_commandsvEs_3:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_4
// __absolute char const <_ZZ19get_serial_commandsvEs_4>[10]
_ZZ19get_serial_commandsvEs_4:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_5
// __absolute char const <_ZZ19get_serial_commandsvEs_5>[5]
_ZZ19get_serial_commandsvEs_5:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_6
// __absolute char const <_ZZ19get_serial_commandsvEs_6>[5]
_ZZ19get_serial_commandsvEs_6:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_7
// __absolute char const <_ZZ19get_serial_commandsvEs_7>[9]
_ZZ19get_serial_commandsvEs_7:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_8
// __absolute char const <_ZZ19get_serial_commandsvEs_8>[5]
_ZZ19get_serial_commandsvEs_8:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs
// __absolute char const <_ZZ19get_sdcard_commandsvEs>[20]
_ZZ19get_sdcard_commandsvEs:
        DATA
        DC8 "Done printing file\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs_0
// __absolute char const <_ZZ19get_sdcard_commandsvEs_0>[15]
_ZZ19get_sdcard_commandsvEs_0:
        DATA
        DC8 "SD read error\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs
// __absolute char const <_ZZ17get_wifi_commandsvEs>[119]
_ZZ17get_wifi_commandsvEs:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_0
// __absolute char const <_ZZ17get_wifi_commandsvEs_0>[10]
_ZZ17get_wifi_commandsvEs_0:
        DATA
        DC8 "STOPPED. "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_1
// __absolute char const <_ZZ17get_wifi_commandsvEs_1>[5]
_ZZ17get_wifi_commandsvEs_1:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_2
// __absolute char const <_ZZ17get_wifi_commandsvEs_2>[5]
_ZZ17get_wifi_commandsvEs_2:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_3
// __absolute char const <_ZZ17get_wifi_commandsvEs_3>[9]
_ZZ17get_wifi_commandsvEs_3:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_4
// __absolute char const <_ZZ17get_wifi_commandsvEs_4>[5]
_ZZ17get_wifi_commandsvEs_4:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ24get_homing_bump_feedrate8AxisEnumEs
// __absolute char const <_ZZ24get_homing_bump_feedrate8AxisEnumEs>[34]
_ZZ24get_homing_bump_feedrate8AxisEnumEs:
        DATA
        DC8 "Warning: Homing Bump Divisor < 1\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_G2_G3bEs
// __absolute char const <_ZZ11gcode_G2_G3bEs>[22]
_ZZ11gcode_G2_G3bEs:
        DATA
        DC8 "G2/G3 bad parameters\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ8gcode_G4vEs
// __absolute char const <_ZZ8gcode_G4vEs>[9]
_ZZ8gcode_G4vEs:
        DATA
        DC8 "Sleep..."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10home_deltavEs
// __absolute char const <_ZZ10home_deltavEs>[14]
_ZZ10home_deltavEs:
        DATA
        DC8 "Homing failed"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10home_deltavEs_0
// __absolute char const <_ZZ10home_deltavEs_0>[15]
_ZZ10home_deltavEs_0:
        DATA
        DC8 "Homing failed\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs>[23]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs:
        DATA
        DC8 "S out of range (0-5).\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0>[8]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0:
        DATA
        DC8 "State: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1>[4]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2>[4]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3>[32]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3:
        DATA
        DC8 "Mesh bed leveling has no data.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4>[7]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4:
        DATA
        DC8 "G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5>[11]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5:
        DATA
        DC8 "G28\012G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6>[41]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6:
        DATA
        DC8 "Start mesh probing with \"G29 S1\" first.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7>[20]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7:
        DATA
        DC8 "Mesh probing done.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8:
        DATA
        DC8 "X out of range (1-mksCfg.grid_max_points_x).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9:
        DATA
        DC8 "Y out of range (1-mksCfg.grid_max_points_y).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_>[15]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_:
        DATA
        DC8 "MBL G29 point "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_>[5]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_:
        DATA
        DC8 " of "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs
// __absolute char const <_ZZ9gcode_G29vEs>[23]
_ZZ9gcode_G29vEs:
        DATA
        DC8 "malloc eqnAMatrix err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_0
// __absolute char const <_ZZ9gcode_G29vEs_0>[23]
_ZZ9gcode_G29vEs_0:
        DATA
        DC8 "malloc eqnBVector err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_1
// __absolute char const <_ZZ9gcode_G29vEs_1>[18]
_ZZ9gcode_G29vEs_1:
        DATA
        DC8 "No bilinear grid\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_2
// __absolute char const <_ZZ9gcode_G29vEs_2>[13]
_ZZ9gcode_G29vEs_2:
        DATA
        DC8 "Bad Z value\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_3
// __absolute char const <_ZZ9gcode_G29vEs_3>[40]
_ZZ9gcode_G29vEs_3:
        DATA
        DC8 "?(V)erbose level is implausible (0-4).\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_4
// __absolute char const <_ZZ9gcode_G29vEs_4>[53]
_ZZ9gcode_G29vEs_4:
        DATA
        DC8 3FH, 4EH, 75H, 6DH, 62H, 65H, 72H, 20H
        DC8 6FH, 66H, 20H, 70H, 72H, 6FH, 62H, 65H
        DC8 20H, 70H, 6FH, 69H, 6EH, 74H, 73H, 20H
        DC8 69H, 73H, 20H, 69H, 6DH, 70H, 6CH, 61H
        DC8 75H, 73H, 69H, 62H, 6CH, 65H, 20H, 28H
        DC8 32H, 20H, 6DH, 69H, 6EH, 69H, 6DH, 75H
        DC8 6DH, 29H, 2EH, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_5
// __absolute char const <_ZZ9gcode_G29vEs_5>[7]
_ZZ9gcode_G29vEs_5:
        DATA
        DC8 "(L)eft"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_6
// __absolute char const <_ZZ9gcode_G29vEs_6>[8]
_ZZ9gcode_G29vEs_6:
        DATA
        DC8 "(R)ight"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_7
// __absolute char const <_ZZ9gcode_G29vEs_7>[8]
_ZZ9gcode_G29vEs_7:
        DATA
        DC8 "(F)ront"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_8
// __absolute char const <_ZZ9gcode_G29vEs_8>[7]
_ZZ9gcode_G29vEs_8:
        DATA
        DC8 "(B)ack"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_9
// __absolute char const <_ZZ9gcode_G29vEs_9>[22]
_ZZ9gcode_G29vEs_9:
        DATA
        DC8 "G29 Auto Bed Leveling"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__10_
// __absolute char const <_ZZ9gcode_G29vEs__10_>[10]
_ZZ9gcode_G29vEs__10_:
        DATA
        DC8 " (DRYRUN)"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__11_
// __absolute char const <_ZZ9gcode_G29vEs__11_>[22]
_ZZ9gcode_G29vEs__11_:
        DATA
        DC8 "Eqn coefficients: a: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__12_
// __absolute char const <_ZZ9gcode_G29vEs__12_>[5]
_ZZ9gcode_G29vEs__12_:
        DATA
        DC8 " b: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__13_
// __absolute char const <_ZZ9gcode_G29vEs__13_>[5]
_ZZ9gcode_G29vEs__13_:
        DATA
        DC8 " d: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__14_
// __absolute char const <_ZZ9gcode_G29vEs__14_>[25]
_ZZ9gcode_G29vEs__14_:
        DATA
        DC8 "Mean of sampled points: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__15_
// __absolute char const <_ZZ9gcode_G29vEs__15_>[195]
_ZZ9gcode_G29vEs__15_:
        DATA
        DC8 0AH, 42H, 65H, 64H, 20H, 48H, 65H, 69H
        DC8 67H, 68H, 74H, 20H, 54H, 6FH, 70H, 6FH
        DC8 67H, 72H, 61H, 70H, 68H, 79H, 3AH, 0AH
        DC8 20H, 20H, 20H, 2BH, 2DH, 2DH, 2DH, 20H
        DC8 42H, 41H, 43H, 4BH, 20H, 2DH, 2DH, 2BH
        DC8 0AH, 20H, 20H, 20H, 7CH, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 7CH, 0AH, 20H, 4CH, 20H, 7CH, 20H, 20H
        DC8 20H, 20H, 28H, 2BH, 29H, 20H, 20H, 20H
        DC8 20H, 7CH, 20H, 52H, 0AH, 20H, 45H, 20H
        DC8 7CH, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 7CH, 20H, 49H, 0AH
        DC8 20H, 46H, 20H, 7CH, 20H, 28H, 2DH, 29H
        DC8 20H, 4EH, 20H, 28H, 2BH, 29H, 20H, 7CH
        DC8 20H, 47H, 0AH, 20H, 54H, 20H, 7CH, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 20H, 20H, 7CH, 20H, 48H, 0AH, 20H, 20H
        DC8 20H, 7CH, 20H, 20H, 20H, 20H, 28H, 2DH
        DC8 29H, 20H, 20H, 20H, 20H, 7CH, 20H, 54H
        DC8 0AH, 20H, 20H, 20H, 7CH, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 7CH, 0AH, 20H, 20H, 20H, 4FH, 2DH, 2DH
        DC8 20H, 46H, 52H, 4FH, 4EH, 54H, 20H, 2DH
        DC8 2DH, 2BH, 0AH, 20H, 28H, 30H, 2CH, 30H
        DC8 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__16_
// __absolute char const <_ZZ9gcode_G29vEs__16_>[3]
_ZZ9gcode_G29vEs__16_:
        DATA
        DC8 " +"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__17_
// __absolute char const <_ZZ9gcode_G29vEs__17_>[41]
_ZZ9gcode_G29vEs__17_:
        DATA
        DC8 "\012Corrected Bed Height vs. Bed Topology:\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__18_
// __absolute char const <_ZZ9gcode_G29vEs__18_>[31]
_ZZ9gcode_G29vEs__18_:
        DATA
        DC8 "\012\012Bed Level Correction Matrix:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs
// __absolute char const <_ZZ9gcode_G30vEs>[8]
_ZZ9gcode_G30vEs:
        DATA
        DC8 "Bed X: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_0
// __absolute char const <_ZZ9gcode_G30vEs_0>[5]
_ZZ9gcode_G30vEs_0:
        DATA
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_1
// __absolute char const <_ZZ9gcode_G30vEs_1>[5]
_ZZ9gcode_G30vEs_1:
        DATA
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G42vEs
// __absolute char const <_ZZ9gcode_G42vEs>[31]
_ZZ9gcode_G42vEs:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M17vEs
// __absolute char const <_ZZ9gcode_M17vEs>[9]
_ZZ9gcode_M17vEs:
        DATA
        DC8 "No move."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs
// __absolute char const <_ZZ9gcode_M20vEs>[17]
_ZZ9gcode_M20vEs:
        DATA
        DC8 "Begin file list\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs_0
// __absolute char const <_ZZ9gcode_M20vEs_0>[15]
_ZZ9gcode_M20vEs_0:
        DATA
        DC8 "End file list\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M31vEs
// __absolute char const <_ZZ9gcode_M31vEs>[13]
_ZZ9gcode_M31vEs:
        DATA
        DC8 "Print time: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M42vEs
// __absolute char const <_ZZ9gcode_M42vEs>[15]
_ZZ9gcode_M42vEs:
        DATA
        DC8 "Protected Pin\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs
// __absolute char const <_ZZ9gcode_M49vEs>[11]
_ZZ9gcode_M49vEs:
        DATA
        DC8 "G26 Debug "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_0
// __absolute char const <_ZZ9gcode_M49vEs_0>[5]
_ZZ9gcode_M49vEs_0:
        DATA
        DC8 "on.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_1
// __absolute char const <_ZZ9gcode_M49vEs_1>[6]
_ZZ9gcode_M49vEs_1:
        DATA
        DC8 "off.\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs
// __absolute char const <_ZZ10gcode_M104vEs>[18]
_ZZ10gcode_M104vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_0
// __absolute char const <_ZZ10gcode_M104vEs_0>[14]
_ZZ10gcode_M104vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_1
// __absolute char const <_ZZ10gcode_M104vEs_1>[14]
_ZZ10gcode_M104vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_2
// __absolute char const <_ZZ10gcode_M104vEs_2>[14]
_ZZ10gcode_M104vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_3
// __absolute char const <_ZZ10gcode_M104vEs_3>[14]
_ZZ10gcode_M104vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M104vEs_4
// __absolute char const <_ZZ10gcode_M104vEs_4>[14]
_ZZ10gcode_M104vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M105vEs
// __absolute char const <_ZZ10gcode_M105vEs>[3]
_ZZ10gcode_M105vEs:
        DATA
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M112vEs
// __absolute char const <_ZZ10gcode_M112vEs>[9]
_ZZ10gcode_M112vEs:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs
// __absolute char const <_ZZ10gcode_M109vEs>[18]
_ZZ10gcode_M109vEs:
        DATA
        DC8 "3D Printer ready."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_0
// __absolute char const <_ZZ10gcode_M109vEs_0>[14]
_ZZ10gcode_M109vEs_0:
        DATA
        DC8 "E1 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_1
// __absolute char const <_ZZ10gcode_M109vEs_1>[14]
_ZZ10gcode_M109vEs_1:
        DATA
        DC8 "E2 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_2
// __absolute char const <_ZZ10gcode_M109vEs_2>[14]
_ZZ10gcode_M109vEs_2:
        DATA
        DC8 "E3 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_3
// __absolute char const <_ZZ10gcode_M109vEs_3>[14]
_ZZ10gcode_M109vEs_3:
        DATA
        DC8 "E4 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_4
// __absolute char const <_ZZ10gcode_M109vEs_4>[14]
_ZZ10gcode_M109vEs_4:
        DATA
        DC8 "E5 Heating..."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_5
// __absolute char const <_ZZ10gcode_M109vEs_5>[4]
_ZZ10gcode_M109vEs_5:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_6
// __absolute char const <_ZZ10gcode_M109vEs_6>[14]
_ZZ10gcode_M109vEs_6:
        DATA
        DC8 "Heating done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs
// __absolute char const <_ZZ10gcode_M190vEs>[13]
_ZZ10gcode_M190vEs:
        DATA
        DC8 "Bed Heating."
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs_0
// __absolute char const <_ZZ10gcode_M190vEs_0>[4]
_ZZ10gcode_M190vEs_0:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs_1
// __absolute char const <_ZZ10gcode_M190vEs_1>[10]
_ZZ10gcode_M190vEs_1:
        DATA
        DC8 "Bed done."
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_4
// __absolute char const <_ZZ10gcode_M111vEs_4>[7]
_ZZ10gcode_M111vEs_4:
        DATA
        DC8 "DEBUG:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_5
// __absolute char const <_ZZ10gcode_M111vEs_5>[4]
_ZZ10gcode_M111vEs_5:
        DATA
        DC8 "off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M113vEs
// __absolute char const <_ZZ10gcode_M113vEs>[7]
_ZZ10gcode_M113vEs:
        DATA
        DC8 "M113 S"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs
// __absolute char const <_ZZ10gcode_M115vEs>[198]
_ZZ10gcode_M115vEs:
        DATA
        DC8 46H, 49H, 52H, 4DH, 57H, 41H, 52H, 45H
        DC8 5FH, 4EH, 41H, 4DH, 45H, 3AH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 31H, 2EH, 30H
        DC8 2EH, 30H, 20H, 28H, 47H, 69H, 74H, 68H
        DC8 75H, 62H, 29H, 20H, 53H, 4FH, 55H, 52H
        DC8 43H, 45H, 5FH, 43H, 4FH, 44H, 45H, 5FH
        DC8 55H, 52H, 4CH, 3AH, 68H, 74H, 74H, 70H
        DC8 73H, 3AH, 2FH, 2FH, 67H, 69H, 74H, 68H
        DC8 75H, 62H, 2EH, 63H, 6FH, 6DH, 2FH, 4DH
        DC8 61H, 72H, 6CH, 69H, 6EH, 46H, 69H, 72H
        DC8 6DH, 77H, 61H, 72H, 65H, 2FH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 50H, 52H, 4FH
        DC8 54H, 4FH, 43H, 4FH, 4CH, 5FH, 56H, 45H
        DC8 52H, 53H, 49H, 4FH, 4EH, 3AH, 31H, 2EH
        DC8 30H, 20H, 4DH, 41H, 43H, 48H, 49H, 4EH
        DC8 45H, 5FH, 54H, 59H, 50H, 45H, 3AH, 33H
        DC8 44H, 20H, 50H, 72H, 69H, 6EH, 74H, 65H
        DC8 72H, 20H, 45H, 58H, 54H, 52H, 55H, 44H
        DC8 45H, 52H, 5FH, 43H, 4FH, 55H, 4EH, 54H
        DC8 3AH, 32H, 20H, 55H, 55H, 49H, 44H, 3AH
        DC8 63H, 65H, 64H, 65H, 32H, 61H, 32H, 66H
        DC8 2DH, 34H, 31H, 61H, 32H, 2DH, 34H, 37H
        DC8 34H, 38H, 2DH, 39H, 62H, 31H, 32H, 2DH
        DC8 63H, 35H, 35H, 63H, 36H, 32H, 66H, 33H
        DC8 36H, 37H, 66H, 66H, 0AH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_0
// __absolute char const <_ZZ10gcode_M115vEs_0>[16]
_ZZ10gcode_M115vEs_0:
        DATA
        DC8 "SERIAL_XON_XOFF"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_1
// __absolute char const <_ZZ10gcode_M115vEs_1>[7]
_ZZ10gcode_M115vEs_1:
        DATA
        DC8 "EEPROM"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_2
// __absolute char const <_ZZ10gcode_M115vEs_2>[11]
_ZZ10gcode_M115vEs_2:
        DATA
        DC8 "VOLUMETRIC"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_3
// __absolute char const <_ZZ10gcode_M115vEs_3>[16]
_ZZ10gcode_M115vEs_3:
        DATA
        DC8 "AUTOREPORT_TEMP"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_4
// __absolute char const <_ZZ10gcode_M115vEs_4>[9]
_ZZ10gcode_M115vEs_4:
        DATA
        DC8 "PROGRESS"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_5
// __absolute char const <_ZZ10gcode_M115vEs_5>[10]
_ZZ10gcode_M115vEs_5:
        DATA
        DC8 "PRINT_JOB"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_6
// __absolute char const <_ZZ10gcode_M115vEs_6>[10]
_ZZ10gcode_M115vEs_6:
        DATA
        DC8 "AUTOLEVEL"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_7
// __absolute char const <_ZZ10gcode_M115vEs_7>[8]
_ZZ10gcode_M115vEs_7:
        DATA
        DC8 "Z_PROBE"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_8
// __absolute char const <_ZZ10gcode_M115vEs_8>[14]
_ZZ10gcode_M115vEs_8:
        DATA
        DC8 "LEVELING_DATA"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_9
// __absolute char const <_ZZ10gcode_M115vEs_9>[14]
_ZZ10gcode_M115vEs_9:
        DATA
        DC8 "BUILD_PERCENT"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__10_
// __absolute char const <_ZZ10gcode_M115vEs__10_>[15]
_ZZ10gcode_M115vEs__10_:
        DATA
        DC8 "SOFTWARE_POWER"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__11_
// __absolute char const <_ZZ10gcode_M115vEs__11_>[14]
_ZZ10gcode_M115vEs__11_:
        DATA
        DC8 "TOGGLE_LIGHTS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__12_
// __absolute char const <_ZZ10gcode_M115vEs__12_>[22]
_ZZ10gcode_M115vEs__12_:
        DATA
        DC8 "CASE_LIGHT_BRIGHTNESS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__13_
// __absolute char const <_ZZ10gcode_M115vEs__13_>[17]
_ZZ10gcode_M115vEs__13_:
        DATA
        DC8 "EMERGENCY_PARSER"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M118vEs
// __absolute char const <_ZZ10gcode_M118vEs>[4]
_ZZ10gcode_M118vEs:
        DATA
        DC8 "// "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs
// __absolute char const <_ZZ10gcode_M204vEs>[40]
_ZZ10gcode_M204vEs:
        DATA
        DC8 "Setting Print and Travel Acceleration: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_0
// __absolute char const <_ZZ10gcode_M204vEs_0>[29]
_ZZ10gcode_M204vEs_0:
        DATA
        DC8 "Setting Print Acceleration: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_1
// __absolute char const <_ZZ10gcode_M204vEs_1>[31]
_ZZ10gcode_M204vEs_1:
        DATA
        DC8 "Setting Retract Acceleration: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_2
// __absolute char const <_ZZ10gcode_M204vEs_2>[30]
_ZZ10gcode_M204vEs_2:
        DATA
        DC8 "Setting Travel Acceleration: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ15gcode_M666_dualvEs
// __absolute char const <_ZZ15gcode_M666_dualvEs>[31]
_ZZ15gcode_M666_dualvEs:
        DATA
        DC8 "Dual Endstop Adjustment (mm): "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ15gcode_M666_dualvEs_0
// __absolute char const <_ZZ15gcode_M666_dualvEs_0>[3]
_ZZ15gcode_M666_dualvEs_0:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs
// __absolute char const <_ZZ10gcode_M211vEs>[16]
_ZZ10gcode_M211vEs:
        DATA
        DC8 "Soft endstops: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_0
// __absolute char const <_ZZ10gcode_M211vEs_0>[4]
_ZZ10gcode_M211vEs_0:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_1
// __absolute char const <_ZZ10gcode_M211vEs_1>[4]
_ZZ10gcode_M211vEs_1:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_2
// __absolute char const <_ZZ10gcode_M211vEs_2>[8]
_ZZ10gcode_M211vEs_2:
        DATA
        DC8 "  Min: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        SECTION_GROUP _ZZ10gcode_M211vEs_3
// __absolute char const <_ZZ10gcode_M211vEs_3>[2]
_ZZ10gcode_M211vEs_3:
        DATA
        DC8 "X"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_4
// __absolute char const <_ZZ10gcode_M211vEs_4>[3]
_ZZ10gcode_M211vEs_4:
        DATA
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_5
// __absolute char const <_ZZ10gcode_M211vEs_5>[3]
_ZZ10gcode_M211vEs_5:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_6
// __absolute char const <_ZZ10gcode_M211vEs_6>[8]
_ZZ10gcode_M211vEs_6:
        DATA
        DC8 "  Max: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M218vEs
// __absolute char const <_ZZ10gcode_M218vEs>[16]
_ZZ10gcode_M218vEs:
        DATA
        DC8 "Hotend offsets:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs
// __absolute char const <_ZZ10gcode_M280vEs>[8]
_ZZ10gcode_M280vEs:
        DATA
        DC8 " Servo "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs_0
// __absolute char const <_ZZ10gcode_M280vEs_0>[15]
_ZZ10gcode_M280vEs_0:
        DATA
        DC8 " out of range\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs_1
// __absolute char const <_ZZ10gcode_M280vEs_1>[7]
_ZZ10gcode_M280vEs_1:
        DATA
        DC8 "Servo "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs
// __absolute char const <_ZZ10gcode_M301vEs>[4]
_ZZ10gcode_M301vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_0
// __absolute char const <_ZZ10gcode_M301vEs_0>[4]
_ZZ10gcode_M301vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_1
// __absolute char const <_ZZ10gcode_M301vEs_1>[4]
_ZZ10gcode_M301vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_2
// __absolute char const <_ZZ10gcode_M301vEs_2>[17]
_ZZ10gcode_M301vEs_2:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs
// __absolute char const <_ZZ10gcode_M304vEs>[4]
_ZZ10gcode_M304vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_0
// __absolute char const <_ZZ10gcode_M304vEs_0>[4]
_ZZ10gcode_M304vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_1
// __absolute char const <_ZZ10gcode_M304vEs_1>[4]
_ZZ10gcode_M304vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs
// __absolute char const <_ZZ10gcode_M302vEs>[19]
_ZZ10gcode_M302vEs:
        DATA
        DC8 "Cold extrudes are "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_0
// __absolute char const <_ZZ10gcode_M302vEs_0>[3]
_ZZ10gcode_M302vEs_0:
        DATA
        DC8 "en"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_1
// __absolute char const <_ZZ10gcode_M302vEs_1>[4]
_ZZ10gcode_M302vEs_1:
        DATA
        DC8 "dis"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_2
// __absolute char const <_ZZ10gcode_M302vEs_2>[17]
_ZZ10gcode_M302vEs_2:
        DATA
        DC8 "abled (min temp "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_3
// __absolute char const <_ZZ10gcode_M302vEs_3>[4]
_ZZ10gcode_M302vEs_3:
        DATA
        DC8 "C)\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M303vEs
// __absolute char const <_ZZ10gcode_M303vEs>[18]
_ZZ10gcode_M303vEs:
        DATA
        DC8 "PIDTEMP disabled\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M360vEs
// __absolute char const <_ZZ10gcode_M360vEs>[15]
_ZZ10gcode_M360vEs:
        DATA
        DC8 " Cal: Theta 0\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M361vEs
// __absolute char const <_ZZ10gcode_M361vEs>[16]
_ZZ10gcode_M361vEs:
        DATA
        DC8 " Cal: Theta 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M362vEs
// __absolute char const <_ZZ10gcode_M362vEs>[13]
_ZZ10gcode_M362vEs:
        DATA
        DC8 " Cal: Psi 0\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M363vEs
// __absolute char const <_ZZ10gcode_M363vEs>[14]
_ZZ10gcode_M363vEs:
        DATA
        DC8 " Cal: Psi 90\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M364vEs
// __absolute char const <_ZZ10gcode_M364vEs>[20]
_ZZ10gcode_M364vEs:
        DATA
        DC8 " Cal: Theta-Psi 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs
// __absolute char const <_ZZ10gcode_M420vEs>[32]
_ZZ10gcode_M420vEs:
        DATA
        DC8 "?EEPROM storage not available.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_0
// __absolute char const <_ZZ10gcode_M420vEs_0>[24]
_ZZ10gcode_M420vEs_0:
        DATA
        DC8 "?Invalid storage slot.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_1
// __absolute char const <_ZZ10gcode_M420vEs_1>[11]
_ZZ10gcode_M420vEs_1:
        DATA
        DC8 "?Use 0 to "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_2
// __absolute char const <_ZZ10gcode_M420vEs_2>[21]
_ZZ10gcode_M420vEs_2:
        DATA
        DC8 "ubl.mesh_is_valid = "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_3
// __absolute char const <_ZZ10gcode_M420vEs_3>[20]
_ZZ10gcode_M420vEs_3:
        DATA
        DC8 "ubl.storage_slot = "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_4
// __absolute char const <_ZZ10gcode_M420vEs_4>[29]
_ZZ10gcode_M420vEs_4:
        DATA
        DC8 "Bed Level Correction Matrix:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_5
// __absolute char const <_ZZ10gcode_M420vEs_5>[22]
_ZZ10gcode_M420vEs_5:
        DATA
        DC8 "Mesh Bed Level data:\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_6
// __absolute char const <_ZZ10gcode_M420vEs_6>[31]
_ZZ10gcode_M420vEs_6:
        DATA
        DC8 "Failed to enable Bed Leveling\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_7
// __absolute char const <_ZZ10gcode_M420vEs_7>[14]
_ZZ10gcode_M420vEs_7:
        DATA
        DC8 "Bed Leveling "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_8
// __absolute char const <_ZZ10gcode_M420vEs_8>[4]
_ZZ10gcode_M420vEs_8:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_9
// __absolute char const <_ZZ10gcode_M420vEs_9>[4]
_ZZ10gcode_M420vEs_9:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs__10_
// __absolute char const <_ZZ10gcode_M420vEs__10_>[13]
_ZZ10gcode_M420vEs__10_:
        DATA
        DC8 "Fade Height "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs__11_
// __absolute char const <_ZZ10gcode_M420vEs__11_>[5]
_ZZ10gcode_M420vEs__11_:
        DATA
        DC8 "Off\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs>[32]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0>[31]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
// __absolute char const <_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs>[32]
_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
// __absolute char const <_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0>[31]
_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
// __absolute char const <_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs>[32]
_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
// __absolute char const <_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0>[31]
_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs
// __absolute char const <_ZZ10gcode_M428vEs>[30]
_ZZ10gcode_M428vEs:
        DATA
        DC8 "Too far from reference point\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_0
// __absolute char const <_ZZ10gcode_M428vEs_0>[14]
_ZZ10gcode_M428vEs_0:
        DATA
        DC8 "Err: Too far!"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs_1
// __absolute char const <_ZZ10gcode_M428vEs_1>[16]
_ZZ10gcode_M428vEs_1:
        DATA
        DC8 "Offsets applied"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs
// __absolute char const <_ZZ10gcode_M851vEs>[15]
_ZZ10gcode_M851vEs:
        DATA
        DC8 "Probe Z Offset"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_0
// __absolute char const <_ZZ10gcode_M851vEs_0>[25]
_ZZ10gcode_M851vEs_0:
        DATA
        DC8 " z_min:  -20 z_max:  20\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_1
// __absolute char const <_ZZ10gcode_M851vEs_1>[3]
_ZZ10gcode_M851vEs_1:
        DATA
        DC8 ": "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M355vEs
// __absolute char const <_ZZ10gcode_M355vEs>[15]
_ZZ10gcode_M355vEs:
        DATA
        DC8 "No case light\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ22invalid_extruder_errorhEs
// __absolute char const <_ZZ22invalid_extruder_errorhEs>[17]
_ZZ22invalid_extruder_errorhEs:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0
// 7912 
// 7913 /**
// 7914  * M42: Change pin status via GCode
// 7915  *
// 7916  *  P<pin>  Pin number (LED if omitted)
// 7917  *  S<byte> Pin status from 0 - 255
// 7918  */
// 7919 inline void gcode_M42() {
// 7920   if (!parser.seenval('S')) return;
// 7921   const byte pin_status = parser.value_byte();
// 7922 
// 7923   const int pin_number = parser.intval('P', LED_PIN);
// 7924   if (pin_number < 0) return;
// 7925 
// 7926   if (pin_is_protected(pin_number)) {
// 7927     SERIAL_ERROR_START();
// 7928     SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
// 7929     return;
// 7930   }
// 7931 
// 7932   pinMode(pin_number, OUTPUT);
// 7933   digitalWrite(pin_number, pin_status);
// 7934   //analogWrite(pin_number, pin_status);
// 7935 
// 7936   #if FAN_COUNT > 0
// 7937     switch (pin_number) {
// 7938       #if HAS_FAN0
// 7939         case FAN_PIN: fanSpeeds[0] = pin_status; break;
// 7940       #endif
// 7941       #if HAS_FAN1
// 7942         case FAN1_PIN: fanSpeeds[1] = pin_status; break;
// 7943       #endif
// 7944       #if HAS_FAN2
// 7945         case FAN2_PIN: fanSpeeds[2] = pin_status; break;
// 7946       #endif
// 7947     }
// 7948   #endif
// 7949 }
// 7950 
// 7951 #if ENABLED(PINS_DEBUGGING)
// 7952 
// 7953   #include "pinsDebug.h"
// 7954 
// 7955   inline void toggle_pins() {
// 7956     const bool I_flag = parser.boolval('I');
// 7957     const int repeat = parser.intval('R', 1),
// 7958               start = parser.intval('S'),
// 7959               end = parser.intval('L', NUM_DIGITAL_PINS - 1),
// 7960               wait = parser.intval('W', 500);
// 7961 
// 7962     for (uint8_t pin = start; pin <= end; pin++) {
// 7963       //report_pin_state_extended(pin, I_flag, false);
// 7964 
// 7965       if (!I_flag && pin_is_protected(pin)) {
// 7966         report_pin_state_extended(pin, I_flag, true, "Untouched ");
// 7967         SERIAL_EOL();
// 7968       }
// 7969       else {
// 7970         report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
// 7971         #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
// 7972           if (pin == TEENSY_E2) {
// 7973             SET_OUTPUT(TEENSY_E2);
// 7974             for (int16_t j = 0; j < repeat; j++) {
// 7975               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7976               WRITE(TEENSY_E2, HIGH); safe_delay(wait);
// 7977               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7978             }
// 7979           }
// 7980           else if (pin == TEENSY_E3) {
// 7981             SET_OUTPUT(TEENSY_E3);
// 7982             for (int16_t j = 0; j < repeat; j++) {
// 7983               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7984               WRITE(TEENSY_E3, HIGH); safe_delay(wait);
// 7985               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7986             }
// 7987           }
// 7988           else
// 7989         #endif
// 7990         {
// 7991           pinMode(pin, OUTPUT);
// 7992           for (int16_t j = 0; j < repeat; j++) {
// 7993             digitalWrite(pin, 0); safe_delay(wait);
// 7994             digitalWrite(pin, 1); safe_delay(wait);
// 7995             digitalWrite(pin, 0); safe_delay(wait);
// 7996           }
// 7997         }
// 7998 
// 7999       }
// 8000       SERIAL_EOL();
// 8001     }
// 8002     SERIAL_ECHOLNPGM("Done.");
// 8003 
// 8004   } // toggle_pins
// 8005 
// 8006   inline void servo_probe_test() {
// 8007     #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
// 8008 
// 8009       SERIAL_ERROR_START();
// 8010       SERIAL_ERRORLNPGM("SERVO not setup");
// 8011 
// 8012     #elif !HAS_Z_SERVO_ENDSTOP
// 8013 
// 8014       SERIAL_ERROR_START();
// 8015       SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
// 8016 
// 8017     #else // HAS_Z_SERVO_ENDSTOP
// 8018 
// 8019       const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
// 8020 
// 8021       SERIAL_PROTOCOLLNPGM("Servo probe test");
// 8022       SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
// 8023       SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
// 8024       SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
// 8025 
// 8026       bool probe_inverting;
// 8027 
// 8028       //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 8029       uint8_t PROBE_TEST_PIN = 0;
// 8030 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 8031 	  {
// 8032 
// 8033        // #define PROBE_TEST_PIN Z_MIN_PIN
// 8034 	   PROBE_TEST_PIN = Z_MIN_PIN;
// 8035 
// 8036         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
// 8037         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
// 8038         SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
// 8039 /*
// 8040         #if Z_MIN_ENDSTOP_INVERTING
// 8041           SERIAL_PROTOCOLLNPGM("true");
// 8042         #else
// 8043           SERIAL_PROTOCOLLNPGM("false");
// 8044         #endif
// 8045 */		if(Z_MIN_ENDSTOP_INVERTING)
// 8046 			SERIAL_PROTOCOLLNPGM("true");
// 8047 		else
// 8048 			SERIAL_PROTOCOLLNPGM("false");
// 8049 		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 8050 
// 8051         probe_inverting = Z_MIN_ENDSTOP_INVERTING;
// 8052 	  }
// 8053       //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
// 8054 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
// 8055 	  {
// 8056         //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
// 8057         PROBE_TEST_PIN = Z_MAX_PIN;
// 8058         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
// 8059         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
// 8060         SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
// 8061 /*
// 8062         #if Z_MIN_PROBE_ENDSTOP_INVERTING
// 8063           SERIAL_PROTOCOLLNPGM("true");
// 8064         #else
// 8065           SERIAL_PROTOCOLLNPGM("false");
// 8066         #endif
// 8067 */
// 8068 		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
// 8069 			SERIAL_PROTOCOLLNPGM("true");
// 8070 		else
// 8071 			SERIAL_PROTOCOLLNPGM("false");
// 8072 	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 8073 
// 8074         probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
// 8075 	  }
// 8076       //#endif
// 8077 
// 8078       SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
// 8079       SET_INPUT_PULLUP(PROBE_TEST_PIN);
// 8080       bool deploy_state, stow_state;
// 8081       for (uint8_t i = 0; i < 4; i++) {
// 8082         MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
// 8083         safe_delay(500);
// 8084         deploy_state = READ(PROBE_TEST_PIN);
// 8085         MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 8086         safe_delay(500);
// 8087         stow_state = READ(PROBE_TEST_PIN);
// 8088       }
// 8089       if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
// 8090 
// 8091       refresh_cmd_timeout();
// 8092 
// 8093       if (deploy_state != stow_state) {
// 8094         SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
// 8095         if (deploy_state) {
// 8096           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
// 8097           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
// 8098         }
// 8099         else {
// 8100           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
// 8101           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
// 8102         }
// 8103         //#if ENABLED(BLTOUCH)
// 8104         if(MKSTOUCH == 1)
// 8105           SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
// 8106         //#endif
// 8107 
// 8108       }
// 8109       else {                                           // measure active signal length
// 8110         MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
// 8111         safe_delay(500);
// 8112         SERIAL_PROTOCOLLNPGM("please trigger probe");
// 8113         uint16_t probe_counter = 0;
// 8114 
// 8115         // Allow 30 seconds max for operator to trigger probe
// 8116         for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
// 8117 
// 8118           safe_delay(2);
// 8119 
// 8120           if (0 == j % (500 * 1)) // keep cmd_timeout happy
// 8121             refresh_cmd_timeout();
// 8122 
// 8123           if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
// 8124 
// 8125             for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
// 8126               safe_delay(2);
// 8127 
// 8128             if (probe_counter == 50)
// 8129               SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
// 8130             else if (probe_counter >= 2)
// 8131               SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
// 8132             else
// 8133               SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
// 8134 
// 8135             MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 8136 
// 8137           }  // pulse detected
// 8138 
// 8139         } // for loop waiting for trigger
// 8140 
// 8141         if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
// 8142 
// 8143       } // measure active signal length
// 8144 
// 8145     #endif
// 8146 
// 8147   } // servo_probe_test
// 8148 
// 8149   /**
// 8150    * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
// 8151    *
// 8152    *  M43         - report name and state of pin(s)
// 8153    *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
// 8154    *                  I       Flag to ignore Marlin's pin protection.
// 8155    *
// 8156    *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
// 8157    *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
// 8158    *                  I       Flag to ignore Marlin's pin protection.
// 8159    *
// 8160    *  M43 E<bool> - Enable / disable background endstop monitoring
// 8161    *                  - Machine continues to operate
// 8162    *                  - Reports changes to endstops
// 8163    *                  - Toggles LED_PIN when an endstop changes
// 8164    *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
// 8165    *
// 8166    *  M43 T       - Toggle pin(s) and report which pin is being toggled
// 8167    *                  S<pin>  - Start Pin number.   If not given, will default to 0
// 8168    *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
// 8169    *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
// 8170    *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
// 8171    *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
// 8172    *
// 8173    *  M43 S       - Servo probe test
// 8174    *                  P<index> - Probe index (optional - defaults to 0
// 8175    */
// 8176   inline void gcode_M43() {
// 8177 
// 8178     if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
// 8179       toggle_pins();
// 8180       return;
// 8181     }
// 8182 
// 8183     // Enable or disable endstop monitoring
// 8184     if (parser.seen('E')) {
// 8185       endstop_monitor_flag = parser.value_bool();
// 8186       SERIAL_PROTOCOLPGM("endstop monitor ");
// 8187       serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
// 8188       SERIAL_PROTOCOLLNPGM("abled");
// 8189       return;
// 8190     }
// 8191 
// 8192     if (parser.seen('S')) {
// 8193       servo_probe_test();
// 8194       return;
// 8195     }
// 8196 
// 8197     // Get the range of pins to test or watch
// 8198     const uint8_t first_pin = parser.byteval('P'),
// 8199                   last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
// 8200 
// 8201     if (first_pin > last_pin) return;
// 8202 
// 8203     const bool ignore_protection = parser.boolval('I');
// 8204 
// 8205     // Watch until click, M108, or reset
// 8206     if (parser.boolval('W')) {
// 8207       SERIAL_PROTOCOLLNPGM("Watching pins");
// 8208       byte pin_state[last_pin - first_pin + 1];
// 8209       for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 8210         if (pin_is_protected(pin) && !ignore_protection) continue;
// 8211         pinMode(pin, INPUT_PULLUP);
// 8212         delay(1);
// 8213         /*
// 8214           if (IS_ANALOG(pin))
// 8215             pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
// 8216           else
// 8217         //
// 8218         */
// 8219             pin_state[pin - first_pin] = digitalRead(pin);
// 8220       }
// 8221 
// 8222       #if HAS_RESUME_CONTINUE
// 8223         wait_for_user = true;
// 8224         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 8225       #endif
// 8226 
// 8227       for (;;) {
// 8228         for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 8229           if (pin_is_protected(pin) && !ignore_protection) continue;
// 8230           const byte val =
// 8231             /*
// 8232               IS_ANALOG(pin)
// 8233                 ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
// 8234                 :
// 8235             //
// 8236             */
// 8237               digitalRead(pin);
// 8238           if (val != pin_state[pin - first_pin]) {
// 8239             report_pin_state_extended(pin, ignore_protection, false);
// 8240             pin_state[pin - first_pin] = val;
// 8241           }
// 8242         }
// 8243 
// 8244         #if HAS_RESUME_CONTINUE
// 8245           if (!wait_for_user) {
// 8246             KEEPALIVE_STATE(IN_HANDLER);
// 8247             break;
// 8248           }
// 8249         #endif
// 8250 
// 8251         safe_delay(200);
// 8252       }
// 8253       return;
// 8254     }
// 8255 
// 8256     // Report current state of selected pin(s)
// 8257     for (uint8_t pin = first_pin; pin <= last_pin; pin++)
// 8258       report_pin_state_extended(pin, ignore_protection, true);
// 8259   }
// 8260 
// 8261 #endif // PINS_DEBUGGING
// 8262 
// 8263 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 8264 
// 8265   /**
// 8266    * M48: Z probe repeatability measurement function.
// 8267    *
// 8268    * Usage:
// 8269    *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
// 8270    *     P = Number of sampled points (4-50, default 10)
// 8271    *     X = Sample X position
// 8272    *     Y = Sample Y position
// 8273    *     V = Verbose level (0-4, default=1)
// 8274    *     E = Engage Z probe for each reading
// 8275    *     L = Number of legs of movement before probe
// 8276    *     S = Schizoid (Or Star if you prefer)
// 8277    *
// 8278    * This function requires the machine to be homed before invocation.
// 8279    */
// 8280   inline void gcode_M48() {
// 8281 
// 8282     if (axis_unhomed_error()) return;
// 8283 
// 8284     const int8_t verbose_level = parser.byteval('V', 1);
// 8285     if (!WITHIN(verbose_level, 0, 4)) {
// 8286       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 8287       return;
// 8288     }
// 8289 
// 8290     if (verbose_level > 0)
// 8291       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
// 8292 
// 8293     const int8_t n_samples = parser.byteval('P', 10);
// 8294     if (!WITHIN(n_samples, 4, 50)) {
// 8295       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
// 8296       return;
// 8297     }
// 8298 
// 8299     const bool stow_probe_after_each = parser.boolval('E');
// 8300 
// 8301     float X_current = current_position[X_AXIS],
// 8302           Y_current = current_position[Y_AXIS];
// 8303 
// 8304     const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
// 8305                 Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 8306 
// 8307     //#if DISABLED(DELTA)
// 8308     if(MACHINETPYE != DELTA)
// 8309     {
// 8310       if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
// 8311         out_of_range_error(PSTR("X"));
// 8312         return;
// 8313       }
// 8314       if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
// 8315         out_of_range_error(PSTR("Y"));
// 8316         return;
// 8317       }
// 8318     }
// 8319     //#else
// 8320     else
// 8321      {
// 8322      if(MACHINETPYE & IS_KINEMATIC)
// 8323         {
// 8324       if (!position_is_reachable_by_probe_IS_KINEMATIC(X_probe_location, Y_probe_location)) {
// 8325         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 8326         return;
// 8327       }
// 8328         }
// 8329      else
// 8330         {
// 8331       if (!position_is_reachable_by_probe_IS_CARTESIAN(X_probe_location, Y_probe_location)) {
// 8332         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 8333         return;
// 8334       }
// 8335         }        
// 8336      }
// 8337     //#endif
// 8338 
// 8339     bool seen_L = parser.seen('L');
// 8340     uint8_t n_legs = seen_L ? parser.value_byte() : 0;
// 8341     if (n_legs > 15) {
// 8342       SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
// 8343       return;
// 8344     }
// 8345     if (n_legs == 1) n_legs = 2;
// 8346 
// 8347     const bool schizoid_flag = parser.boolval('S');
// 8348     if (schizoid_flag && !seen_L) n_legs = 7;
// 8349 
// 8350     /**
// 8351      * Now get everything to the specified probe point So we can safely do a
// 8352      * probe to get us close to the bed.  If the Z-Axis is far from the bed,
// 8353      * we don't want to use that as a starting point for each probe.
// 8354      */
// 8355     if (verbose_level > 2)
// 8356       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
// 8357 
// 8358     // Disable bed level correction in M48 because we want the raw data when we probe
// 8359 /*
// 8360     #if HAS_LEVELING
// 8361       const bool was_enabled = planner.leveling_active;
// 8362       set_bed_leveling_enabled(false);
// 8363     #endif
// 8364 */
// 8365 	bool was_enabled;
// 8366 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 8367 		was_enabled = ubl.state.active;
// 8368 	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 8369 		was_enabled = mbl.active();
// 8370 	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 8371 		was_enabled = planner.leveling_active;
// 8372 
// 8373 	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 8374 		set_bed_leveling_enabled(false);
// 8375 
// 8376     setup_for_endstop_or_probe_move();
// 8377 
// 8378     double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
// 8379 
// 8380     // Move to the first point, deploy, and probe
// 8381     const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
// 8382     bool probing_good = !isnan(t);
// 8383 
// 8384     if (probing_good) {
// 8385       //randomSeed(millis());
// 8386 	  srand(millis());
// 8387 
// 8388       for (uint8_t n = 0; n < n_samples; n++) {
// 8389         if (n_legs) {
// 8390           const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
// 8391           float angle = random(0.0, 360.0);
// 8392           const float radius = random(
// 8393             #if ENABLED(DELTA)
// 8394               0.1250000000 * (DELTA_PROBEABLE_RADIUS),
// 8395               0.3333333333 * (DELTA_PROBEABLE_RADIUS)
// 8396             #else
// 8397               5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
// 8398             #endif
// 8399           );
// 8400 
// 8401           if (verbose_level > 3) {
// 8402             SERIAL_ECHOPAIR("Starting radius: ", radius);
// 8403             SERIAL_ECHOPAIR("   angle: ", angle);
// 8404             SERIAL_ECHOPGM(" Direction: ");
// 8405             if (dir > 0) SERIAL_ECHOPGM("Counter-");
// 8406             SERIAL_ECHOLNPGM("Clockwise");
// 8407           }
// 8408 
// 8409           for (uint8_t l = 0; l < n_legs - 1; l++) {
// 8410             double delta_angle;
// 8411 
// 8412             if (schizoid_flag)
// 8413               // The points of a 5 point star are 72 degrees apart.  We need to
// 8414               // skip a point and go to the next one on the star.
// 8415               delta_angle = dir * 2.0 * 72.0;
// 8416 
// 8417             else
// 8418               // If we do this line, we are just trying to move further
// 8419               // around the circle.
// 8420               delta_angle = dir * (float) random(25, 45);
// 8421 
// 8422             angle += delta_angle;
// 8423 
// 8424             while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
// 8425               angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
// 8426             while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
// 8427               angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
// 8428 
// 8429             X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
// 8430             Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
// 8431 
// 8432             //#if DISABLED(DELTA)
// 8433             if(MACHINETPYE != DELTA)
// 8434             {
// 8435               X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
// 8436               Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
// 8437             }
// 8438             //#else
// 8439             else
// 8440             {
// 8441               // If we have gone out too far, we can do a simple fix and scale the numbers
// 8442               // back in closer to the origin.
// 8443               if(MACHINETPYE & IS_KINEMATIC)
// 8444                 {
// 8445               while (!position_is_reachable_by_probe_IS_KINEMATIC(X_current, Y_current)) {
// 8446                 X_current *= 0.8;
// 8447                 Y_current *= 0.8;
// 8448                 if (verbose_level > 3) {
// 8449                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 8450                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 8451                 }
// 8452               }
// 8453                 }
// 8454               else
// 8455                  {
// 8456               while (!position_is_reachable_by_probe_IS_CARTESIAN(X_current, Y_current)) {
// 8457                 X_current *= 0.8;
// 8458                 Y_current *= 0.8;
// 8459                 if (verbose_level > 3) {
// 8460                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 8461                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 8462                 }
// 8463               }
// 8464                 }               
// 8465             }
// 8466             //#endif
// 8467             if (verbose_level > 3) {
// 8468               SERIAL_PROTOCOLPGM("Going to:");
// 8469               SERIAL_ECHOPAIR(" X", X_current);
// 8470               SERIAL_ECHOPAIR(" Y", Y_current);
// 8471               SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
// 8472             }
// 8473             do_blocking_move_to_xy(X_current, Y_current);
// 8474           } // n_legs loop
// 8475         } // n_legs
// 8476 
// 8477         // Probe a single point
// 8478         sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
// 8479 
// 8480         // Break the loop if the probe fails
// 8481         probing_good = !isnan(sample_set[n]);
// 8482         if (!probing_good) break;
// 8483 
// 8484         /**
// 8485          * Get the current mean for the data points we have so far
// 8486          */
// 8487         double sum = 0.0;
// 8488         for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
// 8489         mean = sum / (n + 1);
// 8490 
// 8491         NOMORE(min, sample_set[n]);
// 8492         NOLESS(max, sample_set[n]);
// 8493 
// 8494         /**
// 8495          * Now, use that mean to calculate the standard deviation for the
// 8496          * data points we have so far
// 8497          */
// 8498         sum = 0.0;
// 8499         for (uint8_t j = 0; j <= n; j++)
// 8500           sum += sq(sample_set[j] - mean);
// 8501 
// 8502         sigma = SQRT(sum / (n + 1));
// 8503         if (verbose_level > 0) {
// 8504           if (verbose_level > 1) {
// 8505             SERIAL_PROTOCOL(n + 1);
// 8506             SERIAL_PROTOCOLPGM(" of ");
// 8507             SERIAL_PROTOCOL((int)n_samples);
// 8508             SERIAL_PROTOCOLPGM(": z: ");
// 8509             SERIAL_PROTOCOL_F(sample_set[n], 3);
// 8510             if (verbose_level > 2) {
// 8511               SERIAL_PROTOCOLPGM(" mean: ");
// 8512               SERIAL_PROTOCOL_F(mean, 4);
// 8513               SERIAL_PROTOCOLPGM(" sigma: ");
// 8514               SERIAL_PROTOCOL_F(sigma, 6);
// 8515               SERIAL_PROTOCOLPGM(" min: ");
// 8516               SERIAL_PROTOCOL_F(min, 3);
// 8517               SERIAL_PROTOCOLPGM(" max: ");
// 8518               SERIAL_PROTOCOL_F(max, 3);
// 8519               SERIAL_PROTOCOLPGM(" range: ");
// 8520               SERIAL_PROTOCOL_F(max-min, 3);
// 8521             }
// 8522             SERIAL_EOL();
// 8523           }
// 8524         }
// 8525 
// 8526       } // n_samples loop
// 8527     }
// 8528 
// 8529     STOW_PROBE();
// 8530 
// 8531     if (probing_good) {
// 8532       SERIAL_PROTOCOLLNPGM("Finished!");
// 8533 
// 8534       if (verbose_level > 0) {
// 8535         SERIAL_PROTOCOLPGM("Mean: ");
// 8536         SERIAL_PROTOCOL_F(mean, 6);
// 8537         SERIAL_PROTOCOLPGM(" Min: ");
// 8538         SERIAL_PROTOCOL_F(min, 3);
// 8539         SERIAL_PROTOCOLPGM(" Max: ");
// 8540         SERIAL_PROTOCOL_F(max, 3);
// 8541         SERIAL_PROTOCOLPGM(" Range: ");
// 8542         SERIAL_PROTOCOL_F(max-min, 3);
// 8543         SERIAL_EOL();
// 8544       }
// 8545 
// 8546       SERIAL_PROTOCOLPGM("Standard Deviation: ");
// 8547       SERIAL_PROTOCOL_F(sigma, 6);
// 8548       SERIAL_EOL();
// 8549       SERIAL_EOL();
// 8550     }
// 8551 
// 8552     clean_up_after_endstop_or_probe_move();
// 8553 
// 8554     // Re-enable bed level correction if it had been on
// 8555     //#if HAS_LEVELING
// 8556     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 8557       set_bed_leveling_enabled(was_enabled);
// 8558     //#endif
// 8559 
// 8560     report_current_position();
// 8561   }
// 8562 
// 8563 #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 8564 
// 8565 #if 1//ENABLED(G26_MESH_VALIDATION)
// 8566 
// 8567   inline void gcode_M49() {
// 8568     g26_debug_flag ^= true;
// 8569     SERIAL_PROTOCOLPGM("G26 Debug ");
// 8570     serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
// 8571   }
// 8572 
// 8573 #endif // G26_MESH_VALIDATION
// 8574 
// 8575 #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 8576   /**
// 8577    * M73: Set percentage complete (for display on LCD)
// 8578    *
// 8579    * Example:
// 8580    *   M73 P25 ; Set progress to 25%
// 8581    *
// 8582    * Notes:
// 8583    *   This has no effect during an SD print job
// 8584    */
// 8585   inline void gcode_M73() {
// 8586     if (!IS_SD_PRINTING && parser.seen('P')) {
// 8587       progress_bar_percent = parser.value_byte();
// 8588       NOMORE(progress_bar_percent, 100);
// 8589     }
// 8590   }
// 8591 #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
// 8592 
// 8593 /**
// 8594  * M75: Start print timer
// 8595  */
// 8596 inline void gcode_M75() { print_job_timer.start(); }
// 8597 
// 8598 /**
// 8599  * M76: Pause print timer
// 8600  */
// 8601 inline void gcode_M76() { print_job_timer.pause(); }
// 8602 
// 8603 /**
// 8604  * M77: Stop print timer
// 8605  */
// 8606 inline void gcode_M77() { print_job_timer.stop(); }
// 8607 
// 8608 #if ENABLED(PRINTCOUNTER)
// 8609   /**
// 8610    * M78: Show print statistics
// 8611    */
// 8612   inline void gcode_M78() {
// 8613     // "M78 S78" will reset the statistics
// 8614     if (parser.intval('S') == 78)
// 8615       print_job_timer.initStats();
// 8616     else
// 8617       print_job_timer.showStats();
// 8618   }
// 8619 #endif
// 8620 
// 8621 /**
// 8622  * M104: Set hot end temperature
// 8623  */
// 8624 inline void gcode_M104() {
// 8625   if (get_target_extruder_from_command(104)) return;
// 8626   if (DEBUGGING(DRYRUN)) return;
// 8627 
// 8628   #if ENABLED(SINGLENOZZLE)
// 8629     if (target_extruder != active_extruder) return;
// 8630   #endif
// 8631 
// 8632   if (parser.seenval('S')) {
// 8633     const int16_t temp = parser.value_celsius();
// 8634     thermalManager.setTargetHotend(temp, target_extruder);
// 8635 
// 8636     #if ENABLED(DUAL_X_CARRIAGE)
// 8637       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8638         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8639     #endif
// 8640 
// 8641     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8642       /**
// 8643        * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
// 8644        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
// 8645        * standby mode, for instance in a dual extruder setup, without affecting
// 8646        * the running print timer.
// 8647        */
// 8648       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8649         print_job_timer.stop();
// 8650         LCD_MESSAGEPGM(WELCOME_MSG);
// 8651       }
// 8652     #endif
// 8653 
// 8654     //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8655     //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8656 		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8657 		{
// 8658 		switch(target_extruder)
// 8659 			{
// 8660 			case 0:
// 8661 				LCD_MESSAGEPGM("E1 Heating...");
// 8662 				break;
// 8663 			case 1:
// 8664 				LCD_MESSAGEPGM("E2 Heating...");
// 8665 				break;
// 8666 			case 2:
// 8667 				LCD_MESSAGEPGM("E3 Heating...");
// 8668 				break;
// 8669 			case 3:
// 8670 				LCD_MESSAGEPGM("E4 Heating...");
// 8671 				break;
// 8672 			case 4:
// 8673 				LCD_MESSAGEPGM("E5 Heating...");
// 8674 				break;
// 8675 			default: break;
// 8676 				
// 8677 			}
// 8678 		}    
// 8679   }
// 8680 
// 8681   #if ENABLED(AUTOTEMP)
// 8682     planner.autotemp_M104_M109();
// 8683   #endif
// 8684 }
// 8685 
// 8686 /**
// 8687  * M105: Read hot end and bed temperature
// 8688  */
// 8689 inline void gcode_M105() {
// 8690   if (get_target_extruder_from_command(105)) return;
// 8691 /*
// 8692   #if HAS_TEMP_HOTEND || HAS_TEMP_BED
// 8693     SERIAL_PROTOCOLPGM(MSG_OK);
// 8694     thermalManager.print_heaterstates();
// 8695   #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
// 8696     SERIAL_ERROR_START();
// 8697     SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
// 8698   #endif
// 8699 */
// 8700   SERIAL_PROTOCOLPGM(MSG_OK);
// 8701   thermalManager.print_heaterstates();
// 8702 
// 8703   SERIAL_EOL();
// 8704 }
// 8705 
// 8706 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND /*|| HAS_TEMP_BED*/)
// 8707 
// 8708   /**
// 8709    * M155: Set temperature auto-report interval. M155 S<seconds>
// 8710    */
// 8711   inline void gcode_M155() {
// 8712     if (parser.seenval('S'))
// 8713       thermalManager.set_auto_report_interval(parser.value_byte());
// 8714   }
// 8715 
// 8716 #endif // AUTO_REPORT_TEMPERATURES
// 8717 
// 8718 #if FAN_COUNT > 0
// 8719 
// 8720   /**
// 8721    * M106: Set Fan Speed
// 8722    *
// 8723    *  S<int>   Speed between 0-255
// 8724    *  P<index> Fan index, if more than one fan
// 8725    *
// 8726    * With EXTRA_FAN_SPEED enabled:
// 8727    *
// 8728    *  T<int>   Restore/Use/Set Temporary Speed:
// 8729    *           1     = Restore previous speed after T2
// 8730    *           2     = Use temporary speed set with T3-255
// 8731    *           3-255 = Set the speed for use with T2
// 8732    */
// 8733   inline void gcode_M106() {
// 8734     const uint8_t p = parser.byteval('P');
// 8735     if (p < FAN_COUNT) {
// 8736       #if ENABLED(EXTRA_FAN_SPEED)
// 8737         const int16_t t = parser.intval('T');
// 8738         if (t > 0) {
// 8739           switch (t) {
// 8740             case 1:
// 8741               fanSpeeds[p] = old_fanSpeeds[p];
// 8742               break;
// 8743             case 2:
// 8744               old_fanSpeeds[p] = fanSpeeds[p];
// 8745               fanSpeeds[p] = new_fanSpeeds[p];
// 8746               break;
// 8747             default:
// 8748               new_fanSpeeds[p] = min(t, 255);
// 8749               break;
// 8750           }
// 8751           return;
// 8752         }
// 8753       #endif // EXTRA_FAN_SPEED
// 8754       const uint16_t s = parser.ushortval('S', 255);
// 8755       fanSpeeds[p] = min(s, 255);
// 8756 	  MKS_FAN_TIM = s*10000/255;
// 8757     }
// 8758   }
// 8759 
// 8760   /**
// 8761    * M107: Fan Off
// 8762    */
// 8763   inline void gcode_M107() {
// 8764     const uint16_t p = parser.ushortval('P');
// 8765     if (p < FAN_COUNT) 
// 8766     {
// 8767 		fanSpeeds[p] = 0;
// 8768 		MKS_FAN_TIM = 0 ;
// 8769     }
// 8770   }
// 8771 
// 8772 #endif // FAN_COUNT > 0
// 8773 
// 8774 #if DISABLED(EMERGENCY_PARSER)
// 8775 
// 8776   /**
// 8777    * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
// 8778    */
// 8779   inline void gcode_M108() { wait_for_heatup = false; }
// 8780 
// 8781 
// 8782   /**
// 8783    * M112: Emergency Stop
// 8784    */
// 8785   inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
// 8786 
// 8787 
// 8788   /**
// 8789    * M410: Quickstop - Abort all planned moves
// 8790    *
// 8791    * This will stop the carriages mid-move, so most likely they
// 8792    * will be out of sync with the stepper position after this.
// 8793    */
// 8794   inline void gcode_M410() { quickstop_stepper(); }
// 8795 
// 8796 #endif
// 8797 
// 8798 /**
// 8799  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
// 8800  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
// 8801  */
// 8802 
// 8803 #ifndef MIN_COOLING_SLOPE_DEG
// 8804   #define MIN_COOLING_SLOPE_DEG 1.50
// 8805 #endif
// 8806 #ifndef MIN_COOLING_SLOPE_TIME
// 8807   #define MIN_COOLING_SLOPE_TIME 60
// 8808 #endif
// 8809 
// 8810 inline void gcode_M109() {
// 8811 
// 8812   if (get_target_extruder_from_command(109)) return;
// 8813   if (DEBUGGING(DRYRUN)) return;
// 8814 
// 8815   #if ENABLED(SINGLENOZZLE)
// 8816     if (target_extruder != active_extruder) return;
// 8817   #endif
// 8818 
// 8819   const bool no_wait_for_cooling = parser.seenval('S');
// 8820   if (no_wait_for_cooling || parser.seenval('R')) {
// 8821     const int16_t temp = parser.value_celsius();
// 8822     thermalManager.setTargetHotend(temp, target_extruder);
// 8823 
// 8824     #if ENABLED(DUAL_X_CARRIAGE)
// 8825       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8826         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8827     #endif
// 8828 
// 8829     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8830       /**
// 8831        * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
// 8832        * standby mode, (e.g., in a dual extruder setup) without affecting
// 8833        * the running print timer.
// 8834        */
// 8835       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8836         print_job_timer.stop();
// 8837         LCD_MESSAGEPGM(WELCOME_MSG);
// 8838       }
// 8839       else
// 8840         print_job_timer.start();
// 8841     #endif
// 8842 
// 8843     //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8844 	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8845 	{
// 8846 			switch(target_extruder)
// 8847 			{
// 8848 			case 0:
// 8849 				LCD_MESSAGEPGM("E1 Heating...");
// 8850 				break;
// 8851 			case 1:
// 8852 				LCD_MESSAGEPGM("E2 Heating...");
// 8853 				break;
// 8854 			case 2:
// 8855 				LCD_MESSAGEPGM("E3 Heating...");
// 8856 				break;
// 8857 			case 3:
// 8858 				LCD_MESSAGEPGM("E4 Heating...");
// 8859 				break;
// 8860 			case 4:
// 8861 				LCD_MESSAGEPGM("E5 Heating...");
// 8862 				break;
// 8863 			default: break;
// 8864 			}
// 8865 	}
// 8866 
// 8867   }
// 8868   else return;
// 8869 
// 8870   #if ENABLED(AUTOTEMP)
// 8871     planner.autotemp_M104_M109();
// 8872   #endif
// 8873 
// 8874   #if TEMP_RESIDENCY_TIME > 0
// 8875     millis_t residency_start_ms = 0;
// 8876     // Loop until the temperature has stabilized
// 8877     #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
// 8878   #else
// 8879     // Loop until the temperature is very close target
// 8880     #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
// 8881   #endif
// 8882 
// 8883   float target_temp = -1.0, old_temp = 9999.0;
// 8884   bool wants_to_cool = false;
// 8885   wait_for_heatup = true;
// 8886   millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8887 
// 8888   #if DISABLED(BUSY_WHILE_HEATING)
// 8889     KEEPALIVE_STATE(NOT_BUSY);
// 8890   #endif
// 8891 
// 8892   #if ENABLED(PRINTER_EVENT_LEDS)
// 8893     const float start_temp = thermalManager.degHotend(target_extruder);
// 8894     uint8_t old_blue = 0;
// 8895   #endif
// 8896   
// 8897   #if WATCH_HOTENDS
// 8898     thermalManager.start_watching_heater(target_extruder);
// 8899   #endif
// 8900       
// 8901   mks_heating_busy = 1;
// 8902 
// 8903   do {
// 8904     // Target temperature might be changed during the loop
// 8905     if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
// 8906       wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
// 8907       target_temp = thermalManager.degTargetHotend(target_extruder);
// 8908 
// 8909       // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8910       if (no_wait_for_cooling && wants_to_cool) break;
// 8911     }
// 8912 
// 8913     now = millis();
// 8914     if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
// 8915       next_temp_ms = now + 1000UL;
// 8916       thermalManager.print_heaterstates();
// 8917       #if TEMP_RESIDENCY_TIME > 0
// 8918         SERIAL_PROTOCOLPGM(" W:");
// 8919         if (residency_start_ms)
// 8920           SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8921         else
// 8922           SERIAL_PROTOCOLCHAR('?');
// 8923       #endif
// 8924       SERIAL_EOL();
// 8925     }
// 8926 
// 8927     idle();
// 8928     refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8929 
// 8930     const float temp = thermalManager.degHotend(target_extruder);
// 8931 
// 8932     #if ENABLED(PRINTER_EVENT_LEDS)
// 8933       // Gradually change LED strip from violet to red as nozzle heats up
// 8934       if (!wants_to_cool) {
// 8935         const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
// 8936         if (blue != old_blue) {
// 8937           old_blue = blue;
// 8938           leds.set_color(
// 8939             MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
// 8940             #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8941               , true
// 8942             #endif
// 8943           );
// 8944         }
// 8945       }
// 8946     #endif
// 8947 
// 8948     #if TEMP_RESIDENCY_TIME > 0
// 8949 
// 8950       const float temp_diff = FABS(target_temp - temp);
// 8951 
// 8952       if (!residency_start_ms) {
// 8953         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8954         if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
// 8955       }
// 8956       else if (temp_diff > TEMP_HYSTERESIS) {
// 8957         // Restart the timer whenever the temperature falls outside the hysteresis.
// 8958         residency_start_ms = now;
// 8959       }
// 8960 
// 8961     #endif
// 8962 
// 8963     // Prevent a wait-forever situation if R is misused i.e. M109 R0
// 8964     if (wants_to_cool) {
// 8965       // break after MIN_COOLING_SLOPE_TIME seconds
// 8966       // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
// 8967       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8968         if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
// 8969         next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
// 8970         old_temp = temp;
// 8971       }
// 8972     }
// 8973 
// 8974   } while (wait_for_heatup && TEMP_CONDITIONS);
// 8975   
// 8976   mks_heating_busy = 0;
// 8977 
// 8978   if (wait_for_heatup) {
// 8979     LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
// 8980     #if ENABLED(PRINTER_EVENT_LEDS)
// 8981       leds.set_white();
// 8982     #endif
// 8983   }
// 8984 
// 8985   #if DISABLED(BUSY_WHILE_HEATING)
// 8986     KEEPALIVE_STATE(IN_HANDLER);
// 8987   #endif
// 8988 }
// 8989 
// 8990 #if 1//HAS_TEMP_BED
// 8991 
// 8992   #ifndef MIN_COOLING_SLOPE_DEG_BED
// 8993     #define MIN_COOLING_SLOPE_DEG_BED 1.50
// 8994   #endif
// 8995   #ifndef MIN_COOLING_SLOPE_TIME_BED
// 8996     #define MIN_COOLING_SLOPE_TIME_BED 60
// 8997   #endif
// 8998 
// 8999   /**
// 9000    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
// 9001    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
// 9002    */
// 9003   inline void gcode_M190() {
// 9004     if (DEBUGGING(DRYRUN)) return;
// 9005 
// 9006     LCD_MESSAGEPGM(MSG_BED_HEATING);
// 9007     const bool no_wait_for_cooling = parser.seenval('S');
// 9008     if (no_wait_for_cooling || parser.seenval('R')) {
// 9009       thermalManager.setTargetBed(parser.value_celsius());
// 9010       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 9011         if (parser.value_celsius() > BED_MINTEMP)
// 9012           print_job_timer.start();
// 9013       #endif
// 9014     }
// 9015     else return;
// 9016 
// 9017     #if TEMP_BED_RESIDENCY_TIME > 0
// 9018       millis_t residency_start_ms = 0;
// 9019       // Loop until the temperature has stabilized
// 9020       #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
// 9021     #else
// 9022       // Loop until the temperature is very close target
// 9023       #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
// 9024     #endif
// 9025 
// 9026     float target_temp = -1.0, old_temp = 9999.0;
// 9027     bool wants_to_cool = false;
// 9028     wait_for_heatup = true;
// 9029     millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 9030 
// 9031     #if DISABLED(BUSY_WHILE_HEATING)
// 9032       KEEPALIVE_STATE(NOT_BUSY);
// 9033     #endif
// 9034 
// 9035     target_extruder = active_extruder; // for print_heaterstates
// 9036 
// 9037     #if ENABLED(PRINTER_EVENT_LEDS)
// 9038       const float start_temp = thermalManager.degBed();
// 9039       uint8_t old_red = 255;
// 9040     #endif
// 9041 	mks_heating_busy = 1;
// 9042 
// 9043     do {
// 9044       // Target temperature might be changed during the loop
// 9045       if (target_temp != thermalManager.degTargetBed()) {
// 9046         wants_to_cool = thermalManager.isCoolingBed();
// 9047         target_temp = thermalManager.degTargetBed();
// 9048 
// 9049         // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 9050         if (no_wait_for_cooling && wants_to_cool) break;
// 9051       }
// 9052 
// 9053       now = millis();
// 9054       if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
// 9055         next_temp_ms = now + 1000UL;
// 9056         thermalManager.print_heaterstates();
// 9057         #if TEMP_BED_RESIDENCY_TIME > 0
// 9058           SERIAL_PROTOCOLPGM(" W:");
// 9059           if (residency_start_ms)
// 9060             SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 9061           else
// 9062             SERIAL_PROTOCOLCHAR('?');
// 9063         #endif
// 9064         SERIAL_EOL();
// 9065       }
// 9066 
// 9067       idle();
// 9068       refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 9069 
// 9070       const float temp = thermalManager.degBed();
// 9071 
// 9072       #if ENABLED(PRINTER_EVENT_LEDS)
// 9073         // Gradually change LED strip from blue to violet as bed heats up
// 9074         if (!wants_to_cool) {
// 9075           const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
// 9076           if (red != old_red) {
// 9077             old_red = red;
// 9078             leds.set_color(
// 9079               MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
// 9080               #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 9081                 , true
// 9082               #endif
// 9083             );
// 9084           }
// 9085         }
// 9086       #endif
// 9087 
// 9088       #if TEMP_BED_RESIDENCY_TIME > 0
// 9089 
// 9090         const float temp_diff = FABS(target_temp - temp);
// 9091 
// 9092         if (!residency_start_ms) {
// 9093           // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
// 9094           if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
// 9095         }
// 9096         else if (temp_diff > TEMP_BED_HYSTERESIS) {
// 9097           // Restart the timer whenever the temperature falls outside the hysteresis.
// 9098           residency_start_ms = now;
// 9099         }
// 9100 
// 9101       #endif // TEMP_BED_RESIDENCY_TIME > 0
// 9102 
// 9103       // Prevent a wait-forever situation if R is misused i.e. M190 R0
// 9104       if (wants_to_cool) {
// 9105         // Break after MIN_COOLING_SLOPE_TIME_BED seconds
// 9106         // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
// 9107         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 9108           if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
// 9109           next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
// 9110           old_temp = temp;
// 9111         }
// 9112       }
// 9113 
// 9114     } while (wait_for_heatup && TEMP_BED_CONDITIONS);
// 9115 
// 9116 	mks_heating_busy = 0;
// 9117 
// 9118     if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
// 9119     #if DISABLED(BUSY_WHILE_HEATING)
// 9120       KEEPALIVE_STATE(IN_HANDLER);
// 9121     #endif
// 9122   }
// 9123 
// 9124 #endif // HAS_TEMP_BED
// 9125 
// 9126 /**
// 9127  * M110: Set Current Line Number
// 9128  */
// 9129 inline void gcode_M110() {
// 9130   if (parser.seenval('N')) gcode_LastN = parser.value_long();
// 9131 }
// 9132 
// 9133 /**
// 9134  * M111: Set the debug level
// 9135  */
// 9136 inline void gcode_M111() {
// 9137   if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
// 9138 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_1
// 9139   const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
_ZZ10gcode_M111vE11str_debug_1:
        DATA
        DC8 "ECHO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_2
// 9140                     str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
_ZZ10gcode_M111vE11str_debug_2:
        DATA
        DC8 "INFO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_4
// 9141                     str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
_ZZ10gcode_M111vE11str_debug_4:
        DATA
        DC8 "ERRORS"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_8
// 9142                     str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
_ZZ10gcode_M111vE11str_debug_8:
        DATA
        DC8 "DRYRUN"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE12str_debug_16
// 9143                     str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
_ZZ10gcode_M111vE12str_debug_16:
        DATA
        DC8 "COMMUNICATION"
        DC8 0, 0
// 9144                     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9145                       , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
// 9146                     #endif
// 9147                     ;
// 9148 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE13debug_strings
// 9149   const static char* const debug_strings[] PROGMEM = {
_ZZ10gcode_M111vE13debug_strings:
        DATA
        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
        DC32 _ZZ10gcode_M111vE12str_debug_16

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "mks_pft.sys">`:
        DC8 "mks_pft.sys"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "X">`:
        DC8 "X"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Y">`:
        DC8 "Y"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Z">`:
        DC8 "Z"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F)}>`:
        DC32 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "X:">`:
        DC8 "X:"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y:">`:
        DC8 " Y:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Z:">`:
        DC8 " Z:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " E:">`:
        DC8 " E:"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant ":">`:
        DC8 ":"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "bed leveling hasn\\'t d...">`:
        DC8 "bed leveling hasn't defined!"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "ok">`:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F), (0.0F)}>`:
        DC32 0H, 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_1`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M29">`:
        DC8 "M29"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%d">`:
        DC8 "%d"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%f">`:
        DC8 "%f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y">`:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G28">`:
        DC8 "G28"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "/">`:
        DC8 "/"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_2`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "\\n">`:
        DC8 "\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "end">`:
        DC8 "end"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_3`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_4`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
L1:
        DC32 43160000H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
L2:
        DC32 43160000H
// 9150     str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
// 9151     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9152       , str_debug_32
// 9153     #endif
// 9154   };
// 9155 
// 9156   SERIAL_ECHO_START();
// 9157   SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
// 9158   if (marlin_debug_flags) {
// 9159     uint8_t comma = 0;
// 9160     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
// 9161       if (TEST(marlin_debug_flags, i)) {
// 9162         if (comma++) SERIAL_CHAR(',');
// 9163         //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
// 9164         serialprintPGM((char*)&(debug_strings[i]));
// 9165       }
// 9166     }
// 9167   }
// 9168   else {
// 9169     SERIAL_ECHOPGM(MSG_DEBUG_OFF);
// 9170   }
// 9171   SERIAL_EOL();
// 9172 }
// 9173 
// 9174 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 9175 
// 9176   /**
// 9177    * M113: Get or set Host Keepalive interval (0 to disable)
// 9178    *
// 9179    *   S<seconds> Optional. Set the keepalive interval.
// 9180    */
// 9181   inline void gcode_M113() {
// 9182     if (parser.seenval('S')) {
// 9183       host_keepalive_interval = parser.value_byte();
// 9184       NOMORE(host_keepalive_interval, 60);
// 9185     }
// 9186     else {
// 9187       SERIAL_ECHO_START();
// 9188       SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
// 9189     }
// 9190   }
// 9191 
// 9192 #endif
// 9193 
// 9194 #if ENABLED(BARICUDA)
// 9195 
// 9196   #if HAS_HEATER_1
// 9197     /**
// 9198      * M126: Heater 1 valve open
// 9199      */
// 9200     inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
// 9201     /**
// 9202      * M127: Heater 1 valve close
// 9203      */
// 9204     inline void gcode_M127() { baricuda_valve_pressure = 0; }
// 9205   #endif
// 9206 
// 9207   #if HAS_HEATER_2
// 9208     /**
// 9209      * M128: Heater 2 valve open
// 9210      */
// 9211     inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
// 9212     /**
// 9213      * M129: Heater 2 valve close
// 9214      */
// 9215     inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
// 9216   #endif
// 9217 
// 9218 #endif // BARICUDA
// 9219 
// 9220 /**
// 9221  * M140: Set bed temperature
// 9222  */
// 9223 inline void gcode_M140() {
// 9224   if (DEBUGGING(DRYRUN)) return;
// 9225   if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
// 9226 }
// 9227 
// 9228 #if ENABLED(ULTIPANEL)
// 9229 
// 9230   /**
// 9231    * M145: Set the heatup state for a material in the LCD menu
// 9232    *
// 9233    *   S<material> (0=PLA, 1=ABS)
// 9234    *   H<hotend temp>
// 9235    *   B<bed temp>
// 9236    *   F<fan speed>
// 9237    */
// 9238   inline void gcode_M145() {
// 9239     const uint8_t material = (uint8_t)parser.intval('S');
// 9240     if (material >= COUNT(lcd_preheat_hotend_temp)) {
// 9241       SERIAL_ERROR_START();
// 9242       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
// 9243     }
// 9244     else {
// 9245       int v;
// 9246       if (parser.seenval('H')) {
// 9247         v = parser.value_int();
// 9248         lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
// 9249       }
// 9250       if (parser.seenval('F')) {
// 9251         v = parser.value_int();
// 9252         lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
// 9253       }
// 9254       #if TEMP_SENSOR_BED != 0
// 9255         if (parser.seenval('B')) {
// 9256           v = parser.value_int();
// 9257           lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
// 9258         }
// 9259       #endif
// 9260     }
// 9261   }
// 9262 
// 9263 #endif // ULTIPANEL
// 9264 
// 9265 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 9266   /**
// 9267    * M149: Set temperature units
// 9268    */
// 9269   inline void gcode_M149() {
// 9270          if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
// 9271     else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
// 9272     else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
// 9273   }
// 9274 #endif
// 9275 
// 9276 #if HAS_POWER_SWITCH
// 9277 
// 9278   /**
// 9279    * M80   : Turn on the Power Supply
// 9280    * M80 S : Report the current state and exit
// 9281    */
// 9282   inline void gcode_M80() {
// 9283 
// 9284     // S: Report the current power supply state and exit
// 9285     if (parser.seen('S')) {
// 9286       serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
// 9287       return;
// 9288     }
// 9289 
// 9290     OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
// 9291 
// 9292     /**
// 9293      * If you have a switch on suicide pin, this is useful
// 9294      * if you want to start another print with suicide feature after
// 9295      * a print without suicide...
// 9296      */
// 9297     #if HAS_SUICIDE
// 9298       OUT_WRITE(SUICIDE_PIN, HIGH);
// 9299     #endif
// 9300 
// 9301     #if ENABLED(HAVE_TMC2130)
// 9302       delay(100);
// 9303       tmc2130_init(); // Settings only stick when the driver has power
// 9304     #endif
// 9305 
// 9306     powersupply_on = true;
// 9307 
// 9308     #if ENABLED(ULTIPANEL)
// 9309       LCD_MESSAGEPGM(WELCOME_MSG);
// 9310     #endif
// 9311 
// 9312     #if ENABLED(HAVE_TMC2208)
// 9313       delay(100);
// 9314       tmc2208_init();
// 9315     #endif
// 9316   }
// 9317 
// 9318 #endif // HAS_POWER_SWITCH
// 9319 
// 9320 /**
// 9321  * M81: Turn off Power, including Power Supply, if there is one.
// 9322  *
// 9323  *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
// 9324  */
// 9325 inline void gcode_M81() {
// 9326   thermalManager.disable_all_heaters();
// 9327   stepper.finish_and_disable();
// 9328 
// 9329   #if FAN_COUNT > 0
// 9330     for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
// 9331     #if ENABLED(PROBING_FANS_OFF)
// 9332       fans_paused = false;
// 9333       ZERO(paused_fanSpeeds);
// 9334     #endif
// 9335   #endif
// 9336 
// 9337   safe_delay(1000); // Wait 1 second before switching off
// 9338 
// 9339   #if HAS_SUICIDE
// 9340     stepper.synchronize();
// 9341     suicide();
// 9342   #elif HAS_POWER_SWITCH
// 9343     OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 9344     powersupply_on = false;
// 9345   #endif
// 9346 
// 9347   #if ENABLED(ULTIPANEL)
// 9348     //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
// 9349       if(LCD_LANGUAGE)
// 9350         LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
// 9351       else
// 9352         LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");    
// 9353   #endif
// 9354 }
// 9355 
// 9356 /**
// 9357  * M82: Set E codes absolute (default)
// 9358  */
// 9359 inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
// 9360 
// 9361 /**
// 9362  * M83: Set E codes relative while in Absolute Coordinates (G90) mode
// 9363  */
// 9364 inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
// 9365 
// 9366 /**
// 9367  * M18, M84: Disable stepper motors
// 9368  */
// 9369 inline void gcode_M18_M84() {
// 9370   if (parser.seenval('S')) {
// 9371     stepper_inactive_time = parser.value_millis_from_seconds();
// 9372   }
// 9373   else {
// 9374     bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
// 9375     if (all_axis) {
// 9376       stepper.finish_and_disable();
// 9377     }
// 9378     else {
// 9379       stepper.synchronize();
// 9380       if (parser.seen('X')) disable_X();
// 9381       if (parser.seen('Y')) disable_Y();
// 9382       if (parser.seen('Z')) disable_Z();
// 9383       #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
// 9384         if (parser.seen('E')) disable_e_steppers();
// 9385       #endif
// 9386     }
// 9387 
// 9388     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 9389       ubl.lcd_map_control = defer_return_to_status = false;
// 9390     #endif
// 9391   }
// 9392 }
// 9393 
// 9394 /**
// 9395  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
// 9396  */
// 9397 inline void gcode_M85() {
// 9398   if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
// 9399 }
// 9400 
// 9401 /**
// 9402  * Multi-stepper support for M92, M201, M203
// 9403  */
// 9404 #if ENABLED(DISTINCT_E_FACTORS)
// 9405   #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
// 9406   #define TARGET_EXTRUDER target_extruder
// 9407 #else
// 9408   #define GET_TARGET_EXTRUDER(CMD) NOOP
// 9409   #define TARGET_EXTRUDER 0
// 9410 #endif
// 9411 
// 9412 /**
// 9413  * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
// 9414  *      (Follows the same syntax as G92)
// 9415  *
// 9416  *      With multiple extruders use T to specify which one.
// 9417  */
// 9418 inline void gcode_M92() {
// 9419 
// 9420   GET_TARGET_EXTRUDER(92);
// 9421 
// 9422   LOOP_XYZE(i) {
// 9423     if (parser.seen(axis_codes[i])) {
// 9424       if (i == E_AXIS) {
// 9425         const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
// 9426         if (value < 20.0) {
// 9427           float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
// 9428           planner.max_jerk[E_AXIS] *= factor;
// 9429           planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
// 9430           planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
// 9431         }
// 9432         planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
// 9433       }
// 9434       else {
// 9435         planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
// 9436       }
// 9437     }
// 9438   }
// 9439   planner.refresh_positioning();
// 9440 }
// 9441 
// 9442 /**
// 9443  * Output the current position to serial
// 9444  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function _Z23report_current_positionv
        THUMB
// 9445 void report_current_position() {
_Z23report_current_positionv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 9446   SERIAL_PROTOCOLPGM("X:");
        ADR.N    R0,??DataTable154_3  ;; 0x58, 0x3A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9447   SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
        LDR.N    R4,??DataTable154_2
        LDR.W    R5,??DataTable156_1
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9448   SERIAL_PROTOCOLPGM(" Y:");
        ADR.N    R0,??DataTable154_4  ;; " Y:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9449   SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9450   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable154_6  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9451   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+16]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9452   SERIAL_PROTOCOLPGM(" E:");
        ADR.N    R0,??DataTable155  ;; " E:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9453   SERIAL_PROTOCOL(current_position[E_AXIS]);
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9454 
// 9455   stepper.report_positions();
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
// 9456 
// 9457   //#if IS_SCARA
// 9458   if(MACHINETPYE&IS_SCARA)  
        LDR.W    R0,??DataTable158
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??report_current_position_0
// 9459   {
// 9460     SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        MOV      R1,R0
        ADR.W    R0,`?<Constant "SCARA Theta:">`
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
// 9461     SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        MOV      R1,R0
        ADR.W    R0,`?<Constant "   Psi+Theta:">`
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 9462     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 9463   }
// 9464   //#endif
// 9465 }
??report_current_position_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock61

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152:
        DC32     mks_heating_busy+0x8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_1:
        DC32     _ZN7Planner13z_fade_heightE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "SCARA Theta:">`:
        DC8 "SCARA Theta:"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "   Psi+Theta:">`:
        DC8 "   Psi+Theta:"
        DC8 0, 0
// 9466 
// 9467 #ifdef M114_DETAIL
// 9468 
// 9469   void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
// 9470     char str[12];
// 9471     for (uint8_t i = 0; i < n; i++) {
// 9472       SERIAL_CHAR(' ');
// 9473       SERIAL_CHAR(axis_codes[i]);
// 9474       SERIAL_CHAR(':');
// 9475       SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
// 9476     }
// 9477     SERIAL_EOL();
// 9478   }
// 9479 
// 9480   inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
// 9481 
// 9482   void report_current_position_detail() {
// 9483 
// 9484     stepper.synchronize();
// 9485 
// 9486     SERIAL_PROTOCOLPGM("\nLogical:");
// 9487     const float logical[XYZ] = {
// 9488       LOGICAL_X_POSITION(current_position[X_AXIS]),
// 9489       LOGICAL_Y_POSITION(current_position[Y_AXIS]),
// 9490       LOGICAL_Z_POSITION(current_position[Z_AXIS])
// 9491     };
// 9492     report_xyze(logical);
// 9493 
// 9494     SERIAL_PROTOCOLPGM("Raw:    ");
// 9495     report_xyz(current_position);
// 9496 
// 9497     float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 9498 
// 9499     #if PLANNER_LEVELING
// 9500       SERIAL_PROTOCOLPGM("Leveled:");
// 9501       planner.apply_leveling(leveled);
// 9502       report_xyz(leveled);
// 9503 
// 9504       SERIAL_PROTOCOLPGM("UnLevel:");
// 9505       float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
// 9506       planner.unapply_leveling(unleveled);
// 9507       report_xyz(unleveled);
// 9508     #endif
// 9509 
// 9510     #if IS_KINEMATIC
// 9511       #if IS_SCARA
// 9512         SERIAL_PROTOCOLPGM("ScaraK: ");
// 9513       #else
// 9514         SERIAL_PROTOCOLPGM("DeltaK: ");
// 9515       #endif
// 9516       inverse_kinematics(leveled);  // writes delta[]
// 9517       report_xyz(delta);
// 9518     #endif
// 9519 
// 9520     SERIAL_PROTOCOLPGM("Stepper:");
// 9521     LOOP_XYZE(i) {
// 9522       SERIAL_CHAR(' ');
// 9523       SERIAL_CHAR(axis_codes[i]);
// 9524       SERIAL_CHAR(':');
// 9525       SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
// 9526     }
// 9527     SERIAL_EOL();
// 9528 
// 9529     #if IS_SCARA
// 9530       const float deg[XYZ] = {
// 9531         stepper.get_axis_position_degrees(A_AXIS),
// 9532         stepper.get_axis_position_degrees(B_AXIS)
// 9533       };
// 9534       SERIAL_PROTOCOLPGM("Degrees:");
// 9535       report_xyze(deg, 2);
// 9536     #endif
// 9537 
// 9538     SERIAL_PROTOCOLPGM("FromStp:");
// 9539     get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
// 9540     const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
// 9541     report_xyze(from_steppers);
// 9542 
// 9543     const float diff[XYZE] = {
// 9544       from_steppers[X_AXIS] - leveled[X_AXIS],
// 9545       from_steppers[Y_AXIS] - leveled[Y_AXIS],
// 9546       from_steppers[Z_AXIS] - leveled[Z_AXIS],
// 9547       from_steppers[E_AXIS] - current_position[E_AXIS]
// 9548     };
// 9549     SERIAL_PROTOCOLPGM("Differ: ");
// 9550     report_xyze(diff);
// 9551   }
// 9552 #endif // M114_DETAIL
// 9553 
// 9554 /**
// 9555  * M114: Report current position to host
// 9556  */
// 9557 inline void gcode_M114() {
// 9558 
// 9559   #ifdef M114_DETAIL
// 9560     if (parser.seen('D')) {
// 9561       report_current_position_detail();
// 9562       return;
// 9563     }
// 9564   #endif
// 9565 
// 9566   stepper.synchronize();
// 9567   report_current_position();
// 9568 }
// 9569 
// 9570 /**
// 9571  * M115: Capabilities string
// 9572  */
// 9573 
// 9574 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function _Z8cap_linePKcb
        THUMB
// 9575   static void cap_line(const char * const name, bool ena=false) {
_Z8cap_linePKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 9576     SERIAL_PROTOCOLPGM("Cap:");
        ADR.W    R0,`?<Constant "Cap:">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9577     serialprintPGM(name);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9578     SERIAL_PROTOCOLPGM(":");
        ADR.N    R0,??DataTable155_1  ;; ":"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9579     SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
        LDR.N    R4,??DataTable154_2
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock62
// 9580   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Cap:">`:
        DC8 "Cap:"
        DC8 0, 0, 0
// 9581 #endif
// 9582 
// 9583 inline void gcode_M115() {
// 9584   SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
// 9585 
// 9586   #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
// 9587 
// 9588     // SERIAL_XON_XOFF
// 9589     cap_line(PSTR("SERIAL_XON_XOFF")
// 9590       #if ENABLED(SERIAL_XON_XOFF)
// 9591         , true
// 9592       #endif
// 9593     );
// 9594 
// 9595     // EEPROM (M500, M501)
// 9596     cap_line(PSTR("EEPROM")
// 9597       #if ENABLED(EEPROM_SETTINGS)
// 9598         , true
// 9599       #endif
// 9600     );
// 9601 
// 9602     // Volumetric Extrusion (M200)
// 9603     cap_line(PSTR("VOLUMETRIC")
// 9604       #if DISABLED(NO_VOLUMETRICS)
// 9605         , true
// 9606       #endif
// 9607     );
// 9608 
// 9609     // AUTOREPORT_TEMP (M155)
// 9610     cap_line(PSTR("AUTOREPORT_TEMP")
// 9611       #if ENABLED(AUTO_REPORT_TEMPERATURES)
// 9612         , true
// 9613       #endif
// 9614     );
// 9615 
// 9616     // PROGRESS (M530 S L, M531 <file>, M532 X L)
// 9617     cap_line(PSTR("PROGRESS"));
// 9618 
// 9619     // Print Job timer M75, M76, M77
// 9620     cap_line(PSTR("PRINT_JOB"), true);
// 9621 
// 9622     // AUTOLEVEL (G29)
// 9623     cap_line(PSTR("AUTOLEVEL")
// 9624       #if HAS_AUTOLEVEL
// 9625         , true
// 9626       #endif
// 9627     );
// 9628 
// 9629     // Z_PROBE (G30)
// 9630     cap_line(PSTR("Z_PROBE")
// 9631       #if HAS_BED_PROBE
// 9632         , true
// 9633       #endif
// 9634     );
// 9635 
// 9636     // MESH_REPORT (M420 V)
// 9637     cap_line(PSTR("LEVELING_DATA")
// 9638       #if HAS_LEVELING
// 9639         , true
// 9640       #endif
// 9641     );
// 9642 
// 9643     // BUILD_PERCENT (M73)
// 9644     cap_line(PSTR("BUILD_PERCENT")
// 9645       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 9646         , true
// 9647       #endif
// 9648     );
// 9649 
// 9650     // SOFTWARE_POWER (M80, M81)
// 9651     cap_line(PSTR("SOFTWARE_POWER")
// 9652       #if HAS_POWER_SWITCH
// 9653         , true
// 9654       #endif
// 9655     );
// 9656 
// 9657     // CASE LIGHTS (M355)
// 9658     cap_line(PSTR("TOGGLE_LIGHTS")
// 9659       #if HAS_CASE_LIGHT
// 9660         , true
// 9661       #endif
// 9662     );
// 9663     cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
// 9664       #if HAS_CASE_LIGHT
// 9665         , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
// 9666       #endif
// 9667     );
// 9668 
// 9669     // EMERGENCY_PARSER (M108, M112, M410)
// 9670     cap_line(PSTR("EMERGENCY_PARSER")
// 9671       #if ENABLED(EMERGENCY_PARSER)
// 9672         , true
// 9673       #endif
// 9674     );
// 9675 
// 9676   #endif // EXTENDED_CAPABILITIES_REPORT
// 9677 }
// 9678 
// 9679 /**
// 9680  * M117: Set LCD Status Message
// 9681  */
// 9682 inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
// 9683 
// 9684 /**
// 9685  * M118: Display a message in the host console.
// 9686  *
// 9687  *  A1  Append '// ' for an action command, as in OctoPrint
// 9688  *  E1  Have the host 'echo:' the text
// 9689  */
// 9690 inline void gcode_M118() {
// 9691   if (parser.boolval('E')) SERIAL_ECHO_START();
// 9692   if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
// 9693   SERIAL_ECHOLN(parser.string_arg);
// 9694 }
// 9695 
// 9696 /**
// 9697  * M119: Output endstop states to serial output
// 9698  */
// 9699 inline void gcode_M119() { endstops.M119(); }
// 9700 
// 9701 /**
// 9702  * M120: Enable endstops and set non-homing endstop state to "enabled"
// 9703  */
// 9704 inline void gcode_M120() { endstops.enable_globally(true); }
// 9705 
// 9706 /**
// 9707  * M121: Disable endstops and set non-homing endstop state to "disabled"
// 9708  */
// 9709 inline void gcode_M121() { endstops.enable_globally(false); }
// 9710 
// 9711 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 9712 
// 9713   /**
// 9714    * M125: Store current position and move to filament change position.
// 9715    *       Called on pause (by M25) to prevent material leaking onto the
// 9716    *       object. On resume (M24) the head will be moved back and the
// 9717    *       print will resume.
// 9718    *
// 9719    *       If Marlin is compiled without SD Card support, M125 can be
// 9720    *       used directly to pause the print and move to park position,
// 9721    *       resuming with a button click or M108.
// 9722    *
// 9723    *    L = override retract length
// 9724    *    X = override X
// 9725    *    Y = override Y
// 9726    *    Z = override Z raise
// 9727    */
// 9728   inline void gcode_M125() {
// 9729 
// 9730     // Initial retract before move to filament change position
// 9731     const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 9732       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 9733         - (PAUSE_PARK_RETRACT_LENGTH)
// 9734       #endif
// 9735     ;
// 9736 
// 9737     point_t park_point = NOZZLE_PARK_POINT;
// 9738 
// 9739     // Move XY axes to filament change position or given position
// 9740     if (parser.seenval('X')) park_point.x = parser.linearval('X');
// 9741     if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
// 9742 
// 9743     // Lift Z axis
// 9744     if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
// 9745 
// 9746     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 9747       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 9748       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 9749     #endif
// 9750 
// 9751     #if DISABLED(SDSUPPORT)
// 9752       const bool job_running = print_job_timer.isRunning();
// 9753     #endif
// 9754 
// 9755     if (pause_print(retract, park_point)) {
// 9756       #if DISABLED(SDSUPPORT)
// 9757         // Wait for lcd click or M108
// 9758         wait_for_filament_reload();
// 9759 
// 9760         // Return to print position and continue
// 9761         resume_print();
// 9762 
// 9763         if (job_running) print_job_timer.start();
// 9764       #endif
// 9765     }
// 9766   }
// 9767 
// 9768 #endif // PARK_HEAD_ON_PAUSE
// 9769 
// 9770 #if HAS_COLOR_LEDS
// 9771 
// 9772   /**
// 9773    * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
// 9774    *       and Brightness       - Use P (for NEOPIXEL only)
// 9775    *
// 9776    * Always sets all 3 or 4 components. If a component is left out, set to 0.
// 9777    *                                    If brightness is left out, no value changed
// 9778    *
// 9779    * Examples:
// 9780    *
// 9781    *   M150 R255       ; Turn LED red
// 9782    *   M150 R255 U127  ; Turn LED orange (PWM only)
// 9783    *   M150            ; Turn LED off
// 9784    *   M150 R U B      ; Turn LED white
// 9785    *   M150 W          ; Turn LED white using a white LED
// 9786    *   M150 P127       ; Set LED 50% brightness
// 9787    *   M150 P          ; Set LED full brightness
// 9788    */
// 9789   inline void gcode_M150() {
// 9790     leds.set_color(MakeLEDColor(
// 9791       parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9792       parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9793       parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9794       parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9795       parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
// 9796     ));
// 9797   }
// 9798 
// 9799 #endif // HAS_COLOR_LEDS
// 9800 
// 9801 #if DISABLED(NO_VOLUMETRICS)
// 9802 
// 9803   /**
// 9804    * M200: Set filament diameter and set E axis units to cubic units
// 9805    *
// 9806    *    T<extruder> - Optional extruder number. Current extruder if omitted.
// 9807    *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
// 9808    */
// 9809   inline void gcode_M200() {
// 9810 
// 9811     if (get_target_extruder_from_command(200)) return;
// 9812 
// 9813     if (parser.seen('D')) {
// 9814       // setting any extruder filament size disables volumetric on the assumption that
// 9815       // slicers either generate in extruder values as cubic mm or as as filament feeds
// 9816       // for all extruders
// 9817       if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
// 9818         planner.set_filament_size(target_extruder, parser.value_linear_units());
// 9819     }
// 9820     planner.calculate_volumetric_multipliers();
// 9821   }
// 9822 
// 9823 #endif // !NO_VOLUMETRICS
// 9824 
// 9825 /**
// 9826  * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
// 9827  *
// 9828  *       With multiple extruders use T to specify which one.
// 9829  */
// 9830 inline void gcode_M201() {
// 9831 
// 9832   GET_TARGET_EXTRUDER(201);
// 9833 
// 9834   LOOP_XYZE(i) {
// 9835     if (parser.seen(axis_codes[i])) {
// 9836       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9837       planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
// 9838     }
// 9839   }
// 9840   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
// 9841   planner.reset_acceleration_rates();
// 9842 }
// 9843 
// 9844 #if 0 // Not used for Sprinter/grbl gen6
// 9845   inline void gcode_M202() {
// 9846     LOOP_XYZE(i) {
// 9847       if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
// 9848     }
// 9849   }
// 9850 #endif
// 9851 
// 9852 
// 9853 /**
// 9854  * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
// 9855  *
// 9856  *       With multiple extruders use T to specify which one.
// 9857  */
// 9858 inline void gcode_M203() {
// 9859 
// 9860   GET_TARGET_EXTRUDER(203);
// 9861 
// 9862   LOOP_XYZE(i)
// 9863     if (parser.seen(axis_codes[i])) {
// 9864       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9865       planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
// 9866     }
// 9867 }
// 9868 
// 9869 /**
// 9870  * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
// 9871  *
// 9872  *    P = Printing moves
// 9873  *    R = Retract only (no X, Y, Z) moves
// 9874  *    T = Travel (non printing) moves
// 9875  *
// 9876  *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
// 9877  */
// 9878 inline void gcode_M204() {
// 9879   if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
// 9880     planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
// 9881     SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
// 9882   }
// 9883   if (parser.seen('P')) {
// 9884     planner.acceleration = parser.value_linear_units();
// 9885     SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
// 9886   }
// 9887   if (parser.seen('R')) {
// 9888     planner.retract_acceleration = parser.value_linear_units();
// 9889     SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
// 9890   }
// 9891   if (parser.seen('T')) {
// 9892     planner.travel_acceleration = parser.value_linear_units();
// 9893     SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
// 9894   }
// 9895 }
// 9896 
// 9897 /**
// 9898  * M205: Set Advanced Settings
// 9899  *
// 9900  *    S = Min Feed Rate (units/s)
// 9901  *    T = Min Travel Feed Rate (units/s)
// 9902  *    B = Min Segment Time (碌s)
// 9903  *    X = Max X Jerk (units/sec^2)
// 9904  *    Y = Max Y Jerk (units/sec^2)
// 9905  *    Z = Max Z Jerk (units/sec^2)
// 9906  *    E = Max E Jerk (units/sec^2)
// 9907  */
// 9908 inline void gcode_M205() {
// 9909   if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
// 9910   if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
// 9911   if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
// 9912   if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
// 9913   if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
// 9914   if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
// 9915   if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
// 9916 }
// 9917 
// 9918 #if 1//HAS_M206_COMMAND
// 9919 
// 9920   /**
// 9921    * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
// 9922    *
// 9923    * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
// 9924    * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
// 9925    * ***              In the next 1.2 release, it will simply be disabled by default.
// 9926    */
// 9927   inline void gcode_M206() {
// 9928   if(MACHINETPYE == DELTA) return;
// 9929     LOOP_XYZ(i)
// 9930       if (parser.seen(axis_codes[i]))
// 9931         set_home_offset((AxisEnum)i, parser.value_linear_units());
// 9932 
// 9933     //#if ENABLED(MORGAN_SCARA)
// 9934     if(MACHINETPYE == MORGAN_SCARA)
// 9935     {
// 9936       if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
// 9937       if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
// 9938     }
// 9939     //#endif
// 9940 
// 9941     report_current_position();
// 9942   }
// 9943 
// 9944 #endif // HAS_M206_COMMAND
// 9945 
// 9946 #if 1//ENABLED(DELTA)
// 9947   /**
// 9948    * M665: Set delta configurations
// 9949    *
// 9950    *    H = delta height
// 9951    *    L = diagonal rod
// 9952    *    R = delta radius
// 9953    *    S = segments per second
// 9954    *    B = delta calibration radius
// 9955    *    X = Alpha (Tower 1) angle trim
// 9956    *    Y = Beta (Tower 2) angle trim
// 9957    *    Z = Rotate A and B by this angle
// 9958    */
// 9959   inline void gcode_M665() {
// 9960     if (parser.seen('H')) delta_height                   = parser.value_linear_units();
// 9961     if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
// 9962     if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
// 9963     if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
// 9964     if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
// 9965     if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
// 9966     if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
// 9967     if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
// 9968     recalc_delta_settings();
// 9969   }
// 9970   /**
// 9971    * M666: Set delta endstop adjustment
// 9972    */
// 9973   inline void gcode_M666() {
// 9974     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9975       if (DEBUGGING(LEVELING)) {
// 9976         SERIAL_ECHOLNPGM(">>> gcode_M666");
// 9977       }
// 9978     #endif
// 9979     LOOP_XYZ(i) {
// 9980       if (parser.seen(axis_codes[i])) {
// 9981         if (parser.value_linear_units() * Z_HOME_DIR <= 0)
// 9982           delta_endstop_adj[i] = parser.value_linear_units();
// 9983         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9984           if (DEBUGGING(LEVELING)) {
// 9985             SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
// 9986             SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
// 9987           }
// 9988         #endif
// 9989       }
// 9990     }
// 9991     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9992       if (DEBUGGING(LEVELING)) {
// 9993         SERIAL_ECHOLNPGM("<<< gcode_M666");
// 9994       }
// 9995     #endif
// 9996   }
// 9997 
// 9998 #elif IS_SCARA
// 9999 
// 10000   /**
// 10001    * M665: Set SCARA settings
// 10002    *
// 10003    * Parameters:
// 10004    *
// 10005    *   S[segments-per-second] - Segments-per-second
// 10006    *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
// 10007    *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
// 10008    *
// 10009    *   A, P, and X are all aliases for the shoulder angle
// 10010    *   B, T, and Y are all aliases for the elbow angle
// 10011    */
// 10012   inline void gcode_M665() {
// 10013     if (parser.seen('S')) delta_segments_per_second = parser.value_float();
// 10014 
// 10015     const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
// 10016     const uint8_t sumAPX = hasA + hasP + hasX;
// 10017     if (sumAPX == 1)
// 10018       home_offset[A_AXIS] = parser.value_float();
// 10019     else if (sumAPX > 1) {
// 10020       SERIAL_ERROR_START();
// 10021       SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
// 10022       return;
// 10023     }
// 10024 
// 10025     const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
// 10026     const uint8_t sumBTY = hasB + hasT + hasY;
// 10027     if (sumBTY == 1)
// 10028       home_offset[B_AXIS] = parser.value_float();
// 10029     else if (sumBTY > 1) {
// 10030       SERIAL_ERROR_START();
// 10031       SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
// 10032       return;
// 10033     }
// 10034   }
// 10035 
// 10036 
// 10037 #endif
// 10038 //#elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 10039 
// 10040   /**
// 10041    * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
// 10042    */
// 10043   inline void gcode_M666_dual() {
// 10044     SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
// 10045     #if ENABLED(X_DUAL_ENDSTOPS)
// 10046       if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
// 10047       SERIAL_ECHOPAIR(" X", x_endstop_adj);
// 10048     #endif
// 10049     #if ENABLED(Y_DUAL_ENDSTOPS)
// 10050       if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
// 10051       SERIAL_ECHOPAIR(" Y", y_endstop_adj);
// 10052     #endif
// 10053     //#if ENABLED(Z_DUAL_ENDSTOPS)
// 10054     if(Z_DUAL_ENDSTOPS==1)
// 10055     {
// 10056       if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
// 10057       SERIAL_ECHOPAIR(" Z", z_endstop_adj);
// 10058     }
// 10059     //#endif
// 10060     SERIAL_EOL();
// 10061   }
// 10062 
// 10063 //#endif // !DELTA && Z_DUAL_ENDSTOPS
// 10064 
// 10065 #if ENABLED(FWRETRACT)
// 10066 
// 10067   /**
// 10068    * M207: Set firmware retraction values
// 10069    *
// 10070    *   S[+units]    retract_length
// 10071    *   W[+units]    swap_retract_length (multi-extruder)
// 10072    *   F[units/min] retract_feedrate_mm_s
// 10073    *   Z[units]     retract_zlift
// 10074    */
// 10075   inline void gcode_M207() {
// 10076     if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
// 10077     if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10078     if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
// 10079     if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
// 10080   }
// 10081 
// 10082   /**
// 10083    * M208: Set firmware un-retraction values
// 10084    *
// 10085    *   S[+units]    retract_recover_length (in addition to M207 S*)
// 10086    *   W[+units]    swap_retract_recover_length (multi-extruder)
// 10087    *   F[units/min] retract_recover_feedrate_mm_s
// 10088    *   R[units/min] swap_retract_recover_feedrate_mm_s
// 10089    */
// 10090   inline void gcode_M208() {
// 10091     if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
// 10092     if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10093     if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10094     if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
// 10095   }
// 10096 
// 10097   /**
// 10098    * M209: Enable automatic retract (M209 S1)
// 10099    *   For slicers that don't support G10/11, reversed extrude-only
// 10100    *   moves will be classified as retraction.
// 10101    */
// 10102   inline void gcode_M209() {
// 10103     if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 10104       if (parser.seen('S')) {
// 10105         autoretract_enabled = parser.value_bool();
// 10106         for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
// 10107       }
// 10108     }
// 10109   }
// 10110 
// 10111 #endif // FWRETRACT
// 10112 
// 10113 /**
// 10114  * M211: Enable, Disable, and/or Report software endstops
// 10115  *
// 10116  * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
// 10117  */
// 10118 inline void gcode_M211() {
// 10119   SERIAL_ECHO_START();
// 10120   #if HAS_SOFTWARE_ENDSTOPS
// 10121     if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
// 10122     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 10123     serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
// 10124   #else
// 10125     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 10126     SERIAL_ECHOPGM(MSG_OFF);
// 10127   #endif
// 10128   SERIAL_ECHOPGM(MSG_SOFT_MIN);
// 10129   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
// 10130   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
// 10131   SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
// 10132   SERIAL_ECHOPGM(MSG_SOFT_MAX);
// 10133   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
// 10134   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
// 10135   SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
// 10136 }
// 10137 
// 10138 #if HOTENDS > 1
// 10139 
// 10140   /**
// 10141    * M218 - set hotend offset (in linear units)
// 10142    *
// 10143    *   T<tool>
// 10144    *   X<xoffset>
// 10145    *   Y<yoffset>
// 10146    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
// 10147    */
// 10148   inline void gcode_M218() {
// 10149     if (get_target_extruder_from_command(218) || target_extruder == 0) return;
// 10150 
// 10151     if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
// 10152     if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
// 10153 
// 10154     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 10155       if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
// 10156     #endif
// 10157 
// 10158     SERIAL_ECHO_START();
// 10159     SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 10160     HOTEND_LOOP() {
// 10161       SERIAL_CHAR(' ');
// 10162       SERIAL_ECHO(hotend_offset[X_AXIS][e]);
// 10163       SERIAL_CHAR(',');
// 10164       SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
// 10165       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 10166         SERIAL_CHAR(',');
// 10167         SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
// 10168       #endif
// 10169     }
// 10170     SERIAL_EOL();
// 10171   }
// 10172 
// 10173 #endif // HOTENDS > 1
// 10174 
// 10175 /**
// 10176  * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
// 10177  */
// 10178 inline void gcode_M220() {
// 10179   if (parser.seenval('S')) feedrate_percentage = parser.value_int();
// 10180 }
// 10181 
// 10182 /**
// 10183  * M221: Set extrusion percentage (M221 T0 S95)
// 10184  */
// 10185 inline void gcode_M221() {
// 10186   if (get_target_extruder_from_command(221)) return;
// 10187   if (parser.seenval('S')) {
// 10188     planner.flow_percentage[target_extruder] = parser.value_int();
// 10189     planner.refresh_e_factor(target_extruder);
// 10190   }
// 10191 }
// 10192 
// 10193 /**
// 10194  * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
// 10195  */
// 10196 inline void gcode_M226() {
// 10197   if (parser.seen('P')) {
// 10198     const int pin_number = parser.value_int(),
// 10199               pin_state = parser.intval('S', -1); // required pin state - default is inverted
// 10200 
// 10201     if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
// 10202 
// 10203       int target = LOW;
// 10204 
// 10205       stepper.synchronize();
// 10206 
// 10207       pinMode(pin_number, INPUT);
// 10208       switch (pin_state) {
// 10209         case 1:
// 10210           target = HIGH;
// 10211           break;
// 10212         case 0:
// 10213           target = LOW;
// 10214           break;
// 10215         case -1:
// 10216           target = !digitalRead(pin_number);
// 10217           break;
// 10218       }
// 10219 
// 10220       while (digitalRead(pin_number) != target) idle();
// 10221 
// 10222     } // pin_state -1 0 1 && pin_number > -1
// 10223   } // parser.seen('P')
// 10224 }
// 10225 
// 10226 #if ENABLED(EXPERIMENTAL_I2CBUS)
// 10227 
// 10228   /**
// 10229    * M260: Send data to a I2C slave device
// 10230    *
// 10231    * This is a PoC, the formating and arguments for the GCODE will
// 10232    * change to be more compatible, the current proposal is:
// 10233    *
// 10234    *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
// 10235    *
// 10236    *  M260 B<byte-1 value in base 10>
// 10237    *  M260 B<byte-2 value in base 10>
// 10238    *  M260 B<byte-3 value in base 10>
// 10239    *
// 10240    *  M260 S1 ; Send the buffered data and reset the buffer
// 10241    *  M260 R1 ; Reset the buffer without sending data
// 10242    *
// 10243    */
// 10244   inline void gcode_M260() {
// 10245     // Set the target address
// 10246     if (parser.seen('A')) i2c.address(parser.value_byte());
// 10247 
// 10248     // Add a new byte to the buffer
// 10249     if (parser.seen('B')) i2c.addbyte(parser.value_byte());
// 10250 
// 10251     // Flush the buffer to the bus
// 10252     if (parser.seen('S')) i2c.send();
// 10253 
// 10254     // Reset and rewind the buffer
// 10255     else if (parser.seen('R')) i2c.reset();
// 10256   }
// 10257 
// 10258   /**
// 10259    * M261: Request X bytes from I2C slave device
// 10260    *
// 10261    * Usage: M261 A<slave device address base 10> B<number of bytes>
// 10262    */
// 10263   inline void gcode_M261() {
// 10264     if (parser.seen('A')) i2c.address(parser.value_byte());
// 10265 
// 10266     uint8_t bytes = parser.byteval('B', 1);
// 10267 
// 10268     if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
// 10269       i2c.relay(bytes);
// 10270     }
// 10271     else {
// 10272       SERIAL_ERROR_START();
// 10273       SERIAL_ERRORLN("Bad i2c request");
// 10274     }
// 10275   }
// 10276 
// 10277 #endif // EXPERIMENTAL_I2CBUS
// 10278 
// 10279 //#if HAS_SERVOS
// 10280 
// 10281   /**
// 10282    * M280: Get or set servo position. P<index> [S<angle>]
// 10283    */
// 10284   inline void gcode_M280() {
// 10285   	int mksAngle;
// 10286   #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
// 10287     if (!parser.seen('P')) return;
// 10288     const int servo_index = parser.value_int();
// 10289     if (WITHIN(servo_index, 0, 0/*NUM_SERVOS - 1*/)) {
// 10290     if (parser.seen('S'))
// 10291     //MOVE_SERVO(servo_index, parser.value_int());
// 10292     {
// 10293      switch(parser.value_int())
// 10294     	{
// 10295     	case 10:
// 10296 			mksAngle = 700/2;
// 10297 			break;
// 10298 		case 90:
// 10299 			mksAngle = 1500/2;
// 10300 			break;
// 10301 			case 120:
// 10302 			mksAngle = 1800/2;
// 10303 			break;
// 10304 		case 160:
// 10305 			mksAngle = 2200/2;
// 10306 			break;
// 10307 		case 60:
// 10308 			mksAngle = 1200/2;
// 10309 			break;
// 10310 		default:
// 10311 			mksAngle = 2200/2;
// 10312 			break;
// 10313 			
// 10314     	}
// 10315 		MKS_TOUCH_TIM = mksAngle;
// 10316     }        
// 10317       else {
// 10318         SERIAL_ECHO_START();
// 10319         SERIAL_ECHOPAIR(" Servo ", servo_index);
// 10320 		SERIAL_ECHOLNPGM(" out of range");
// 10321         //SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
// 10322       }
// 10323     }
// 10324     else {
// 10325       SERIAL_ERROR_START();
// 10326       SERIAL_ECHOPAIR("Servo ", servo_index);
// 10327       SERIAL_ECHOLNPGM(" out of range");
// 10328     }
// 10329     #endif
// 10330   }
// 10331 
// 10332 //#endif // HAS_SERVOS
// 10333 
// 10334 #if ENABLED(BABYSTEPPING)
// 10335 
// 10336   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10337     FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
// 10338       zprobe_zoffset += offs;
// 10339       SERIAL_ECHO_START();
// 10340       SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
// 10341     }
// 10342   #endif
// 10343 
// 10344   /**
// 10345    * M290: Babystepping
// 10346    */
// 10347   inline void gcode_M290() {
// 10348     #if ENABLED(BABYSTEP_XY)
// 10349       for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
// 10350         if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
// 10351           const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
// 10352           thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
// 10353           #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10354             if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
// 10355           #endif
// 10356         }
// 10357     #else
// 10358       if (parser.seenval('Z') || parser.seenval('S')) {
// 10359         const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
// 10360         thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
// 10361         #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10362           if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
// 10363         #endif
// 10364       }
// 10365     #endif
// 10366   }
// 10367 
// 10368 #endif // BABYSTEPPING
// 10369 
// 10370 #if HAS_BUZZER
// 10371 
// 10372   /**
// 10373    * M300: Play beep sound S<frequency Hz> P<duration ms>
// 10374    */
// 10375   inline void gcode_M300() {
// 10376     uint16_t const frequency = parser.ushortval('S', 260);
// 10377     uint16_t duration = parser.ushortval('P', 1000);
// 10378 
// 10379     // Limits the tone duration to 0-5 seconds.
// 10380     NOMORE(duration, 5000);
// 10381 
// 10382     BUZZ(duration, frequency);
// 10383   }
// 10384 
// 10385 #endif // HAS_BUZZER
// 10386 
// 10387 #if 1//ENABLED(PIDTEMP)
// 10388 
// 10389   /**
// 10390    * M301: Set PID parameters P I D (and optionally C, L)
// 10391    *
// 10392    *   P[float] Kp term
// 10393    *   I[float] Ki term (unscaled)
// 10394    *   D[float] Kd term (unscaled)
// 10395    *
// 10396    * With PID_EXTRUSION_SCALING:
// 10397    *
// 10398    *   C[float] Kc term
// 10399    *   L[float] LPQ length
// 10400    */
// 10401   inline void gcode_M301() {
// 10402 
// 10403     // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
// 10404     // default behaviour (omitting E parameter) is to update for extruder 0 only
// 10405     const uint8_t e = parser.byteval('E'); // extruder being updated
// 10406 
// 10407     if (e < HOTENDS) { // catch bad input value
// 10408       if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
// 10409       if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
// 10410       if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
// 10411       #if ENABLED(PID_EXTRUSION_SCALING)
// 10412         if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
// 10413         if (parser.seen('L')) lpq_len = parser.value_float();
// 10414         NOMORE(lpq_len, LPQ_MAX_LEN);
// 10415       #endif
// 10416 
// 10417       thermalManager.updatePID();
// 10418       SERIAL_ECHO_START();
// 10419       #if ENABLED(PID_PARAMS_PER_HOTEND)
// 10420         SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
// 10421       #endif // PID_PARAMS_PER_HOTEND
// 10422       SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
// 10423       SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
// 10424       SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
// 10425       #if ENABLED(PID_EXTRUSION_SCALING)
// 10426         //Kc does not have scaling applied above, or in resetting defaults
// 10427         SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
// 10428       #endif
// 10429       SERIAL_EOL();
// 10430     }
// 10431     else {
// 10432       SERIAL_ERROR_START();
// 10433       SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
// 10434     }
// 10435   }
// 10436 
// 10437 #endif // PIDTEMP
// 10438 
// 10439 #if 1//ENABLED(PIDTEMPBED)
// 10440 
// 10441   inline void gcode_M304() {
// 10442     if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
// 10443     if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
// 10444     if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
// 10445 
// 10446     SERIAL_ECHO_START();
// 10447     SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
// 10448     SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
// 10449     SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
// 10450   }
// 10451 
// 10452 #endif // PIDTEMPBED
// 10453 
// 10454 #if defined(CHDK) || HAS_PHOTOGRAPH
// 10455 
// 10456   /**
// 10457    * M240: Trigger a camera by emulating a Canon RC-1
// 10458    *       See http://www.doc-diy.net/photo/rc-1_hacked/
// 10459    */
// 10460   inline void gcode_M240() {
// 10461     #ifdef CHDK
// 10462 
// 10463       OUT_WRITE(CHDK, HIGH);
// 10464       chdkHigh = millis();
// 10465       chdkActive = true;
// 10466 
// 10467     #elif HAS_PHOTOGRAPH
// 10468 
// 10469       const uint8_t NUM_PULSES = 16;
// 10470       const float PULSE_LENGTH = 0.01524;
// 10471       for (int i = 0; i < NUM_PULSES; i++) {
// 10472         WRITE(PHOTOGRAPH_PIN, HIGH);
// 10473         _delay_ms(PULSE_LENGTH);
// 10474         WRITE(PHOTOGRAPH_PIN, LOW);
// 10475         _delay_ms(PULSE_LENGTH);
// 10476       }
// 10477       delay(7.33);
// 10478       for (int i = 0; i < NUM_PULSES; i++) {
// 10479         WRITE(PHOTOGRAPH_PIN, HIGH);
// 10480         _delay_ms(PULSE_LENGTH);
// 10481         WRITE(PHOTOGRAPH_PIN, LOW);
// 10482         _delay_ms(PULSE_LENGTH);
// 10483       }
// 10484 
// 10485     #endif // !CHDK && HAS_PHOTOGRAPH
// 10486   }
// 10487 
// 10488 #endif // CHDK || PHOTOGRAPH_PIN
// 10489 
// 10490 #if HAS_LCD_CONTRAST
// 10491 
// 10492   /**
// 10493    * M250: Read and optionally set the LCD contrast
// 10494    */
// 10495   inline void gcode_M250() {
// 10496     if (parser.seen('C')) set_lcd_contrast(parser.value_int());
// 10497     SERIAL_PROTOCOLPGM("lcd contrast value: ");
// 10498     SERIAL_PROTOCOL(lcd_contrast);
// 10499     SERIAL_EOL();
// 10500   }
// 10501 
// 10502 #endif // HAS_LCD_CONTRAST
// 10503 
// 10504 #if ENABLED(PREVENT_COLD_EXTRUSION)
// 10505 
// 10506   /**
// 10507    * M302: Allow cold extrudes, or set the minimum extrude temperature
// 10508    *
// 10509    *       S<temperature> sets the minimum extrude temperature
// 10510    *       P<bool> enables (1) or disables (0) cold extrusion
// 10511    *
// 10512    *  Examples:
// 10513    *
// 10514    *       M302         ; report current cold extrusion state
// 10515    *       M302 P0      ; enable cold extrusion checking
// 10516    *       M302 P1      ; disables cold extrusion checking
// 10517    *       M302 S0      ; always allow extrusion (disables checking)
// 10518    *       M302 S170    ; only allow extrusion above 170
// 10519    *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
// 10520    */
// 10521   inline void gcode_M302() {
// 10522     const bool seen_S = parser.seen('S');
// 10523     if (seen_S) {
// 10524       thermalManager.extrude_min_temp = parser.value_celsius();
// 10525       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
// 10526     }
// 10527 
// 10528     if (parser.seen('P'))
// 10529       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
// 10530     else if (!seen_S) {
// 10531       // Report current state
// 10532       SERIAL_ECHO_START();
// 10533       SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
// 10534       SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
// 10535       SERIAL_ECHOLNPGM("C)");
// 10536     }
// 10537   }
// 10538 
// 10539 #endif // PREVENT_COLD_EXTRUSION
// 10540 
// 10541 /**
// 10542  * M303: PID relay autotune
// 10543  *
// 10544  *       S<temperature> sets the target temperature. (default 150C)
// 10545  *       E<extruder> (-1 for the bed) (default 0)
// 10546  *       C<cycles>
// 10547  *       U<bool> with a non-zero value will apply the result to current settings
// 10548  */
// 10549 inline void gcode_M303() {
// 10550   //#if HAS_PID_HEATING
// 10551   if(HAS_PID_HEATING) {
// 10552     const int e = parser.intval('E'), c = parser.intval('C', 5);
// 10553     const bool u = parser.boolval('U');
// 10554 
// 10555     int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
// 10556 
// 10557     if (WITHIN(e, 0, HOTENDS - 1))
// 10558       target_extruder = e;
// 10559 
// 10560     #if DISABLED(BUSY_WHILE_HEATING)
// 10561       KEEPALIVE_STATE(NOT_BUSY);
// 10562     #endif
// 10563 
// 10564     thermalManager.PID_autotune(temp, e, c, u);
// 10565 
// 10566     #if DISABLED(BUSY_WHILE_HEATING)
// 10567       KEEPALIVE_STATE(IN_HANDLER);
// 10568     #endif
// 10569   }
// 10570   //#else
// 10571   else
// 10572   {
// 10573     SERIAL_ERROR_START();
// 10574     SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
// 10575   }
// 10576   //#endif
// 10577 }
// 10578 
// 10579 #if 1//ENABLED(MORGAN_SCARA)
// 10580 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function _Z17SCARA_move_to_calhh
        THUMB
// 10581   bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
_Z17SCARA_move_to_calhh:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
// 10582     if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??SCARA_move_to_cal_0
// 10583       forward_kinematics_SCARA(delta_a, delta_b);
        MOV      R0,R4
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+4]
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 10584       destination[X_AXIS] = cartes[X_AXIS];
        LDR.W    R0,??DataTable156_1
        LDR.W    R1,??DataTable156
        LDR      R2,[R1, #+72]
        STR      R2,[R0, #+24]
// 10585       destination[Y_AXIS] = cartes[Y_AXIS];
        LDR      R1,[R1, #+76]
        STR      R1,[R0, #+28]
// 10586       destination[Z_AXIS] = current_position[Z_AXIS];
        LDR      R1,[R0, #+16]
        STR      R1,[R0, #+32]
// 10587       prepare_move_to_destination();
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 10588       return true;
        MOVS     R0,#+1
        POP      {R1-R5,PC}
// 10589     }
// 10590     return false;
??SCARA_move_to_cal_0:
        MOVS     R0,#+0
        POP      {R1-R5,PC}       ;; return
          CFI EndBlock cfiBlock63
// 10591   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_1:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_2:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_3:
        DC8      0x58, 0x3A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_4:
        DC8      " Y:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_5:
        DC32     _ZN17mesh_bed_leveling8z_valuesE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_6:
        DC8      " Z:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable154_7:
        DC32     axis_relative_modes
// 10592 
// 10593   /**
// 10594    * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
// 10595    */
// 10596   inline bool gcode_M360() {
// 10597     SERIAL_ECHOLNPGM(" Cal: Theta 0");
// 10598     return SCARA_move_to_cal(0, 120);
// 10599   }
// 10600 
// 10601   /**
// 10602    * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
// 10603    */
// 10604   inline bool gcode_M361() {
// 10605     SERIAL_ECHOLNPGM(" Cal: Theta 90");
// 10606     return SCARA_move_to_cal(90, 130);
// 10607   }
// 10608 
// 10609   /**
// 10610    * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
// 10611    */
// 10612   inline bool gcode_M362() {
// 10613     SERIAL_ECHOLNPGM(" Cal: Psi 0");
// 10614     return SCARA_move_to_cal(60, 180);
// 10615   }
// 10616 
// 10617   /**
// 10618    * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
// 10619    */
// 10620   inline bool gcode_M363() {
// 10621     SERIAL_ECHOLNPGM(" Cal: Psi 90");
// 10622     return SCARA_move_to_cal(50, 90);
// 10623   }
// 10624 
// 10625   /**
// 10626    * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
// 10627    */
// 10628   inline bool gcode_M364() {
// 10629     SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
// 10630     return SCARA_move_to_cal(45, 135);
// 10631   }
// 10632 
// 10633 #endif // SCARA
// 10634 
// 10635 #if ENABLED(EXT_SOLENOID)
// 10636 
// 10637   void enable_solenoid(const uint8_t num) {
// 10638     switch (num) {
// 10639       case 0:
// 10640         OUT_WRITE(SOL0_PIN, HIGH);
// 10641         break;
// 10642         #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10643           case 1:
// 10644             OUT_WRITE(SOL1_PIN, HIGH);
// 10645             break;
// 10646         #endif
// 10647         #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10648           case 2:
// 10649             OUT_WRITE(SOL2_PIN, HIGH);
// 10650             break;
// 10651         #endif
// 10652         #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10653           case 3:
// 10654             OUT_WRITE(SOL3_PIN, HIGH);
// 10655             break;
// 10656         #endif
// 10657         #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10658           case 4:
// 10659             OUT_WRITE(SOL4_PIN, HIGH);
// 10660             break;
// 10661         #endif
// 10662       default:
// 10663         SERIAL_ECHO_START();
// 10664         SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
// 10665         break;
// 10666     }
// 10667   }
// 10668 
// 10669   void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
// 10670 
// 10671   void disable_all_solenoids() {
// 10672     OUT_WRITE(SOL0_PIN, LOW);
// 10673     #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10674       OUT_WRITE(SOL1_PIN, LOW);
// 10675     #endif
// 10676     #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10677       OUT_WRITE(SOL2_PIN, LOW);
// 10678     #endif
// 10679     #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10680       OUT_WRITE(SOL3_PIN, LOW);
// 10681     #endif
// 10682     #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10683       OUT_WRITE(SOL4_PIN, LOW);
// 10684     #endif
// 10685   }
// 10686 
// 10687   /**
// 10688    * M380: Enable solenoid on the active extruder
// 10689    */
// 10690   inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
// 10691 
// 10692   /**
// 10693    * M381: Disable all solenoids
// 10694    */
// 10695   inline void gcode_M381() { disable_all_solenoids(); }
// 10696 
// 10697 #endif // EXT_SOLENOID
// 10698 
// 10699 /**
// 10700  * M400: Finish all moves
// 10701  */
// 10702 inline void gcode_M400() { stepper.synchronize(); }
// 10703 
// 10704 #if HAS_BED_PROBE
// 10705 
// 10706   /**
// 10707    * M401: Engage Z Servo endstop if available
// 10708    */
// 10709   inline void gcode_M401() { DEPLOY_PROBE(); }
// 10710 
// 10711   /**
// 10712    * M402: Retract Z Servo endstop if enabled
// 10713    */
// 10714   inline void gcode_M402() { STOW_PROBE(); }
// 10715 
// 10716 #endif // HAS_BED_PROBE
// 10717 
// 10718 #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 10719 
// 10720   /**
// 10721    * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
// 10722    */
// 10723   inline void gcode_M404() {
// 10724     if (parser.seen('W')) {
// 10725       filament_width_nominal = parser.value_linear_units();
// 10726       planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
// 10727     }
// 10728     else {
// 10729       SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
// 10730       SERIAL_PROTOCOLLN(filament_width_nominal);
// 10731     }
// 10732   }
// 10733 
// 10734   /**
// 10735    * M405: Turn on filament sensor for control
// 10736    */
// 10737   inline void gcode_M405() {
// 10738     // This is technically a linear measurement, but since it's quantized to centimeters and is a different
// 10739     // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
// 10740     if (parser.seen('D')) {
// 10741       meas_delay_cm = parser.value_byte();
// 10742       NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
// 10743     }
// 10744 
// 10745     if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
// 10746       const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
// 10747 
// 10748       for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
// 10749         measurement_delay[i] = temp_ratio;
// 10750 
// 10751       filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
// 10752     }
// 10753 
// 10754     filament_sensor = true;
// 10755   }
// 10756 
// 10757   /**
// 10758    * M406: Turn off filament sensor for control
// 10759    */
// 10760   inline void gcode_M406() {
// 10761     filament_sensor = false;
// 10762     planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
// 10763   }
// 10764 
// 10765   /**
// 10766    * M407: Get measured filament diameter on serial output
// 10767    */
// 10768   inline void gcode_M407() {
// 10769     SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 10770     SERIAL_PROTOCOLLN(filament_width_meas);
// 10771   }
// 10772 
// 10773 #endif // FILAMENT_WIDTH_SENSOR
// 10774 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function _Z17quickstop_stepperv
        THUMB
// 10775 void quickstop_stepper() {
_Z17quickstop_stepperv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 10776   stepper.quick_stop();
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
// 10777   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 10778   set_current_from_steppers_for_axis(ALL_AXES);
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
// 10779   SYNC_PLAN_POSITION_KINEMATIC();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
          CFI EndBlock cfiBlock64
// 10780 }
// 10781 
// 10782 #if 1//HAS_LEVELING
// 10783   /**
// 10784    * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
// 10785    *
// 10786    *   S[bool]   Turns leveling on or off
// 10787    *   Z[height] Sets the Z fade height (0 or none to disable)
// 10788    *   V[bool]   Verbose - Print the leveling grid
// 10789    *
// 10790    * With AUTO_BED_LEVELING_UBL only:
// 10791    *
// 10792    *   L[index]  Load UBL mesh from index (0 is default)
// 10793    */
// 10794   inline void gcode_M420() {
// 10795 
// 10796     const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 10797 
// 10798     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 10799 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	
// 10800 	{
// 10801       // L to load a mesh from the EEPROM
// 10802       if (parser.seen('L')) {
// 10803 
// 10804         #if ENABLED(EEPROM_SETTINGS)
// 10805           const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
// 10806           const int16_t a = settings.calc_num_meshes();
// 10807 
// 10808           if (!a) {
// 10809             SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10810             return;
// 10811           }
// 10812 
// 10813           if (!WITHIN(storage_slot, 0, a - 1)) {
// 10814             SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
// 10815             SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
// 10816             return;
// 10817           }
// 10818 
// 10819           settings.load_mesh(storage_slot);
// 10820           ubl.storage_slot = storage_slot;
// 10821 
// 10822         #else
// 10823 
// 10824           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10825           return;
// 10826 
// 10827         #endif
// 10828       }
// 10829 
// 10830       // L to load a mesh from the EEPROM
// 10831       if (parser.seen('L') || parser.seen('V')) {
// 10832         ubl.display_map(0);  // Currently only supports one map type
// 10833         SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
// 10834         SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
// 10835       }
// 10836 	}
// 10837     //#endif // AUTO_BED_LEVELING_UBL
// 10838 
// 10839     // V to print the matrix or mesh
// 10840     if (parser.seen('V')) {
// 10841       //#if ABL_PLANAR
// 10842       if(BED_LEVELING_METHOD&ABL_PLANAR)
// 10843         planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 10844 	  else
// 10845 	  {
// 10846       //#else
// 10847         if (leveling_is_valid()) {
// 10848           //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10849           if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 10850           {
// 10851             print_bilinear_leveling_grid();
// 10852             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10853               print_bilinear_leveling_grid_virt();
// 10854             #endif
// 10855           }
// 10856          //#elif ENABLED(MESH_BED_LEVELING)
// 10857          else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 10858          {
// 10859             SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 10860             mbl_mesh_report();
// 10861          }
// 10862          // #endif
// 10863         }
// 10864 	  }
// 10865       //#endif
// 10866     }
// 10867 
// 10868     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10869 	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
// 10870 	{
// 10871       if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
// 10872 	}
// 10873     #endif
// 10874 
// 10875     bool to_enable = false;
// 10876     if (parser.seen('S')) {
// 10877       to_enable = parser.value_bool();
// 10878       set_bed_leveling_enabled(to_enable);
// 10879     }
// 10880 
// 10881     const bool new_status = planner.leveling_active;
// 10882 
// 10883     if (to_enable && !new_status) {
// 10884       SERIAL_ERROR_START();
// 10885       SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
// 10886     }
// 10887 
// 10888     SERIAL_ECHO_START();
// 10889     SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
// 10890 
// 10891     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10892       SERIAL_ECHO_START();
// 10893       SERIAL_ECHOPGM("Fade Height ");
// 10894       if (planner.z_fade_height > 0.0)
// 10895         SERIAL_ECHOLN(planner.z_fade_height);
// 10896       else
// 10897         SERIAL_ECHOLNPGM(MSG_OFF);
// 10898     #endif
// 10899 
// 10900     // Report change in position
// 10901     if (memcmp(oldpos, current_position, sizeof(oldpos)))
// 10902       report_current_position();
// 10903   }
// 10904 #endif
// 10905 
// 10906 #if 1//ENABLED(MESH_BED_LEVELING)
// 10907 
// 10908   /**
// 10909    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10910    *
// 10911    * Usage:
// 10912    *   M421 X<linear> Y<linear> Z<linear>
// 10913    *   M421 X<linear> Y<linear> Q<offset>
// 10914    *   M421 I<xindex> J<yindex> Z<linear>
// 10915    *   M421 I<xindex> J<yindex> Q<offset>
// 10916    */
// 10917   inline void gcode_M421_MESH_BED_LEVELING() {
// 10918     const bool hasX = parser.seen('X'), hasI = parser.seen('I');
// 10919     const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
// 10920     const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
// 10921     const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
// 10922     const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
// 10923 
// 10924     if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
// 10925       SERIAL_ERROR_START();
// 10926       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10927     }
// 10928     else if (ix < 0 || iy < 0) {
// 10929       SERIAL_ERROR_START();
// 10930       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10931     }
// 10932     else
// 10933       mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
// 10934   }
// 10935 #endif
// 10936 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10937 
// 10938   /**
// 10939    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10940    *
// 10941    * Usage:
// 10942    *   M421 I<xindex> J<yindex> Z<linear>
// 10943    *   M421 I<xindex> J<yindex> Q<offset>
// 10944    */
// 10945   inline void gcode_M421_AUTO_BED_LEVELING_BILINEAR() {
// 10946     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10947     const bool hasI = ix >= 0,
// 10948                hasJ = iy >= 0,
// 10949                hasZ = parser.seen('Z'),
// 10950                hasQ = !hasZ && parser.seen('Q');
// 10951 
// 10952     if (!hasI || !hasJ || !(hasZ || hasQ)) {
// 10953       SERIAL_ERROR_START();
// 10954       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10955     }
// 10956     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10957       SERIAL_ERROR_START();
// 10958       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10959     }
// 10960     else {
// 10961       z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
// 10962       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10963         bed_level_virt_interpolate();
// 10964       #endif
// 10965     }
// 10966   }
// 10967 #endif
// 10968 #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
// 10969 
// 10970   /**
// 10971    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10972    *
// 10973    * Usage:
// 10974    *   M421 I<xindex> J<yindex> Z<linear>
// 10975    *   M421 I<xindex> J<yindex> Q<offset>
// 10976    *   M421 C Z<linear>
// 10977    *   M421 C Q<offset>
// 10978    */
// 10979   inline void gcode_M421_AUTO_BED_LEVELING_UBL() {
// 10980     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10981     const bool hasI = ix >= 0,
// 10982                hasJ = iy >= 0,
// 10983                hasC = parser.seen('C'),
// 10984                hasZ = parser.seen('Z'),
// 10985                hasQ = !hasZ && parser.seen('Q');
// 10986 
// 10987     if (hasC) {
// 10988       const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
// 10989       ix = location.x_index;
// 10990       iy = location.y_index;
// 10991     }
// 10992 
// 10993     if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
// 10994       SERIAL_ERROR_START();
// 10995       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10996     }
// 10997     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10998       SERIAL_ERROR_START();
// 10999       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 11000     }
// 11001     else
// 11002       ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
// 11003   }
// 11004 
// 11005 #endif // AUTO_BED_LEVELING_UBL
// 11006 
// 11007 #if 1//HAS_M206_COMMAND
// 11008 
// 11009   /**
// 11010    * M428: Set home_offset based on the distance between the
// 11011    *       current_position and the nearest "reference point."
// 11012    *       If an axis is past center its endstop position
// 11013    *       is the reference-point. Otherwise it uses 0. This allows
// 11014    *       the Z offset to be set near the bed when using a max endstop.
// 11015    *
// 11016    *       M428 can't be used more than 2cm away from 0 or an endstop.
// 11017    *
// 11018    *       Use M206 to set these values directly.
// 11019    */
// 11020   inline void gcode_M428() {
// 11021   
// 11022   	if(MACHINETPYE == DELTA) return;
// 11023 	
// 11024     if (axis_unhomed_error()) return;
// 11025 
// 11026     float diff[XYZ];
// 11027     LOOP_XYZ(i) {
// 11028       diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
// 11029       if (!WITHIN(diff[i], -20, 20) && home_dir((AxisEnum)i) > 0)
// 11030         diff[i] = -current_position[i];
// 11031       if (!WITHIN(diff[i], -20, 20)) {
// 11032         SERIAL_ERROR_START();
// 11033         SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
// 11034         LCD_ALERTMESSAGEPGM("Err: Too far!");
// 11035         BUZZ(200, 40);
// 11036         return;
// 11037       }
// 11038     }
// 11039 
// 11040     LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
// 11041     report_current_position();
// 11042     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
// 11043     BUZZ(100, 659);
// 11044     BUZZ(100, 698);
// 11045   }
// 11046 
// 11047 #endif // HAS_M206_COMMAND
// 11048 
// 11049 /**
// 11050  * M500: Store settings in EEPROM
// 11051  */
// 11052 inline void gcode_M500() {
// 11053   (void)settings.save();
// 11054 }
// 11055 
// 11056 /**
// 11057  * M501: Read settings from EEPROM
// 11058  */
// 11059 inline void gcode_M501() {
// 11060   (void)settings.load();
// 11061 }
// 11062 
// 11063 /**
// 11064  * M502: Revert to default settings
// 11065  */
// 11066 inline void gcode_M502() {
// 11067   (void)settings.reset();
// 11068 }
// 11069 
// 11070 #if DISABLED(DISABLE_M503)
// 11071   /**
// 11072    * M503: print settings currently in memory
// 11073    */
// 11074   inline void gcode_M503() {
// 11075     (void)settings.report(parser.seen('S') && !parser.value_bool());
// 11076   }
// 11077 #endif
// 11078 
// 11079 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 11080 
// 11081   /**
// 11082    * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
// 11083    */
// 11084   inline void gcode_M540() {
// 11085     if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
// 11086   }
// 11087 
// 11088 #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
// 11089 
// 11090 #if HAS_BED_PROBE
// 11091 
// 11092   inline void gcode_M851() {
// 11093     SERIAL_ECHO_START();
// 11094     SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
// 11095     if (parser.seen('Z')) {
// 11096       const float value = parser.value_linear_units();
// 11097       if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
// 11098         SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
// 11099         return;
// 11100       }
// 11101       zprobe_zoffset = value;
// 11102     }
// 11103     SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
// 11104   }
// 11105 
// 11106 #endif // HAS_BED_PROBE
// 11107 
// 11108 #if ENABLED(SKEW_CORRECTION_GCODE)
// 11109 
// 11110   /**
// 11111    * M852: Get or set the machine skew factors. Reports current values with no arguments.
// 11112    *
// 11113    *  S[xy_factor] - Alias for 'I'
// 11114    *  I[xy_factor] - New XY skew factor
// 11115    *  J[xz_factor] - New XZ skew factor
// 11116    *  K[yz_factor] - New YZ skew factor
// 11117    */
// 11118   inline void gcode_M852() {
// 11119     uint8_t ijk = 0, badval = 0, setval = 0;
// 11120 
// 11121     if (parser.seen('I') || parser.seen('S')) {
// 11122       ++ijk;
// 11123       const float value = parser.value_linear_units();
// 11124       if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11125         if (planner.xy_skew_factor != value) {
// 11126           planner.xy_skew_factor = value;
// 11127           ++setval;
// 11128         }
// 11129       }
// 11130       else
// 11131         ++badval;
// 11132     }
// 11133 
// 11134     #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 11135 
// 11136       if (parser.seen('J')) {
// 11137         ++ijk;
// 11138         const float value = parser.value_linear_units();
// 11139         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11140           if (planner.xz_skew_factor != value) {
// 11141             planner.xz_skew_factor = value;
// 11142             ++setval;
// 11143           }
// 11144         }
// 11145         else
// 11146           ++badval;
// 11147       }
// 11148 
// 11149       if (parser.seen('K')) {
// 11150         ++ijk;
// 11151         const float value = parser.value_linear_units();
// 11152         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11153           if (planner.yz_skew_factor != value) {
// 11154             planner.yz_skew_factor = value;
// 11155             ++setval;
// 11156           }
// 11157         }
// 11158         else
// 11159           ++badval;
// 11160       }
// 11161 
// 11162     #endif
// 11163 
// 11164     if (badval)
// 11165       SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
// 11166 
// 11167     // When skew is changed the current position changes
// 11168     if (setval) {
// 11169       set_current_from_steppers_for_axis(ALL_AXES);
// 11170       SYNC_PLAN_POSITION_KINEMATIC();
// 11171       report_current_position();
// 11172     }
// 11173 
// 11174     if (!ijk) {
// 11175       SERIAL_ECHO_START();
// 11176       SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
// 11177       #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 11178         SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
// 11179         SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
// 11180       #else
// 11181         SERIAL_EOL();
// 11182       #endif
// 11183     }
// 11184   }
// 11185 
// 11186 #endif // SKEW_CORRECTION_GCODE
// 11187 
// 11188 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 11189 
// 11190   /**
// 11191    * M600: Pause for filament change
// 11192    *
// 11193    *  E[distance] - Retract the filament this far (negative value)
// 11194    *  Z[distance] - Move the Z axis by this distance
// 11195    *  X[position] - Move to this X position, with Y
// 11196    *  Y[position] - Move to this Y position, with X
// 11197    *  U[distance] - Retract distance for removal (negative value) (manual reload)
// 11198    *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
// 11199    *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
// 11200    *
// 11201    *  Default values are used for omitted arguments.
// 11202    *
// 11203    */
// 11204   inline void gcode_M600() {
// 11205     point_t park_point = NOZZLE_PARK_POINT;
// 11206 
// 11207     #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
// 11208       // Don't allow filament change without homing first
// 11209       if (axis_unhomed_error()) home_all_axes();
// 11210     #endif
// 11211 
// 11212     // Initial retract before move to filament change position
// 11213     const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
// 11214       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 11215         - (PAUSE_PARK_RETRACT_LENGTH)
// 11216       #endif
// 11217     ;
// 11218 
// 11219     // Lift Z axis
// 11220     if (parser.seenval('Z'))
// 11221       park_point.z = parser.linearval('Z');
// 11222 
// 11223     // Move XY axes to filament change position or given position
// 11224     if (parser.seenval('X'))
// 11225       park_point.x = parser.linearval('X');
// 11226 
// 11227     if (parser.seenval('Y'))
// 11228       park_point.y = parser.linearval('Y');
// 11229 
// 11230     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 11231       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 11232       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 11233     #endif
// 11234 
// 11235     // Unload filament
// 11236     const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
// 11237       #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
// 11238         - (FILAMENT_CHANGE_UNLOAD_LENGTH)
// 11239       #endif
// 11240     ;
// 11241 
// 11242     // Load filament
// 11243     const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 11244       #ifdef FILAMENT_CHANGE_LOAD_LENGTH
// 11245         + FILAMENT_CHANGE_LOAD_LENGTH
// 11246       #endif
// 11247     ;
// 11248 
// 11249     const int beep_count = parser.intval('B',
// 11250       #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 11251         FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 11252       #else
// 11253         -1
// 11254       #endif
// 11255     );
// 11256 
// 11257     const bool job_running = print_job_timer.isRunning();
// 11258 
// 11259     if (pause_print(retract, park_point, unload_length, beep_count, true)) {
// 11260       wait_for_filament_reload(beep_count);
// 11261       resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
// 11262     }
// 11263 
// 11264     // Resume the print job timer if it was running
// 11265     if (job_running) print_job_timer.start();
// 11266   }
// 11267 
// 11268 #endif // ADVANCED_PAUSE_FEATURE
// 11269 
// 11270 #if ENABLED(MK2_MULTIPLEXER)
// 11271 
// 11272   inline void select_multiplexed_stepper(const uint8_t e) {
// 11273     stepper.synchronize();
// 11274     disable_e_steppers();
// 11275     WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 11276     WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 11277     WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
// 11278     safe_delay(100);
// 11279   }
// 11280 
// 11281   /**
// 11282    * M702: Unload all extruders
// 11283    */
// 11284   inline void gcode_M702() {
// 11285     for (uint8_t s = 0; s < E_STEPPERS; s++) {
// 11286       select_multiplexed_stepper(e);
// 11287       // TODO: standard unload filament function
// 11288       // MK2 firmware behavior:
// 11289       //  - Make sure temperature is high enough
// 11290       //  - Raise Z to at least 15 to make room
// 11291       //  - Extrude 1cm of filament in 1 second
// 11292       //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
// 11293       //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
// 11294       //  - Restore E max feedrate to 50
// 11295     }
// 11296     // Go back to the last active extruder
// 11297     select_multiplexed_stepper(active_extruder);
// 11298     disable_e_steppers();
// 11299   }
// 11300 
// 11301 #endif // MK2_MULTIPLEXER
// 11302 
// 11303 #if ENABLED(DUAL_X_CARRIAGE)
// 11304 
// 11305   /**
// 11306    * M605: Set dual x-carriage movement mode
// 11307    *
// 11308    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
// 11309    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
// 11310    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
// 11311    *                         units x-offset and an optional differential hotend temperature of
// 11312    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
// 11313    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
// 11314    *
// 11315    *    Note: the X axis should be homed after changing dual x-carriage mode.
// 11316    */
// 11317   inline void gcode_M605() {
// 11318     stepper.synchronize();
// 11319     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
// 11320     switch (dual_x_carriage_mode) {
// 11321       case DXC_FULL_CONTROL_MODE:
// 11322       case DXC_AUTO_PARK_MODE:
// 11323         break;
// 11324       case DXC_DUPLICATION_MODE:
// 11325         if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
// 11326         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
// 11327         SERIAL_ECHO_START();
// 11328         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 11329         SERIAL_CHAR(' ');
// 11330         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
// 11331         SERIAL_CHAR(',');
// 11332         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
// 11333         SERIAL_CHAR(' ');
// 11334         SERIAL_ECHO(duplicate_extruder_x_offset);
// 11335         SERIAL_CHAR(',');
// 11336         SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
// 11337         break;
// 11338       default:
// 11339         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 11340         break;
// 11341     }
// 11342     active_extruder_parked = false;
// 11343     extruder_duplication_enabled = false;
// 11344     delayed_move_time = 0;
// 11345   }
// 11346 
// 11347 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 11348 
// 11349   inline void gcode_M605() {
// 11350     stepper.synchronize();
// 11351     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
// 11352     SERIAL_ECHO_START();
// 11353     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
// 11354   }
// 11355 
// 11356 #endif // DUAL_NOZZLE_DUPLICATION_MODE
// 11357 
// 11358 #if ENABLED(LIN_ADVANCE)
// 11359   /**
// 11360    * M900: Set and/or Get advance K factor and WH/D ratio
// 11361    *
// 11362    *  K<factor>                  Set advance K factor
// 11363    *  R<ratio>                   Set ratio directly (overrides WH/D)
// 11364    *  W<width> H<height> D<diam> Set ratio from WH/D
// 11365    */
// 11366   inline void gcode_M900() {
// 11367     stepper.synchronize();
// 11368 
// 11369     const float newK = parser.floatval('K', -1);
// 11370     if (newK >= 0) planner.extruder_advance_k = newK;
// 11371 
// 11372     float newR = parser.floatval('R', -1);
// 11373     if (newR < 0) {
// 11374       const float newD = parser.floatval('D', -1),
// 11375                   newW = parser.floatval('W', -1),
// 11376                   newH = parser.floatval('H', -1);
// 11377       if (newD >= 0 && newW >= 0 && newH >= 0)
// 11378         newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
// 11379     }
// 11380     if (newR >= 0) planner.advance_ed_ratio = newR;
// 11381 
// 11382     SERIAL_ECHO_START();
// 11383     SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
// 11384     SERIAL_ECHOPGM(" E/D=");
// 11385     const float ratio = planner.advance_ed_ratio;
// 11386     if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
// 11387     SERIAL_EOL();
// 11388   }
// 11389 #endif // LIN_ADVANCE
// 11390 
// 11391 #if HAS_TRINAMIC
// 11392   static bool report_tmc_status = false;
// 11393   const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
// 11394   enum TMC_AxisEnum {
// 11395     TMC_X,
// 11396     TMC_X2,
// 11397     TMC_Y,
// 11398     TMC_Y2,
// 11399     TMC_Z,
// 11400     TMC_Z2,
// 11401     TMC_E0,
// 11402     TMC_E1,
// 11403     TMC_E2,
// 11404     TMC_E3,
// 11405     TMC_E4
// 11406   };
// 11407   #if ENABLED(TMC_DEBUG)
// 11408     enum TMC_debug_enum {
// 11409       TMC_CODES,
// 11410       TMC_ENABLED,
// 11411       TMC_CURRENT,
// 11412       TMC_RMS_CURRENT,
// 11413       TMC_MAX_CURRENT,
// 11414       TMC_IRUN,
// 11415       TMC_IHOLD,
// 11416       TMC_CS_ACTUAL,
// 11417       TMC_PWM_SCALE,
// 11418       TMC_VSENSE,
// 11419       TMC_STEALTHCHOP,
// 11420       TMC_MICROSTEPS,
// 11421       TMC_TSTEP,
// 11422       TMC_TPWMTHRS,
// 11423       TMC_TPWMTHRS_MMS,
// 11424       TMC_OTPW,
// 11425       TMC_OTPW_TRIGGERED,
// 11426       TMC_TOFF,
// 11427       TMC_TBL,
// 11428       TMC_HEND,
// 11429       TMC_HSTRT,
// 11430       TMC_SGT
// 11431     };
// 11432     enum TMC_drv_status_enum {
// 11433       TMC_DRV_CODES,
// 11434       TMC_STST,
// 11435       TMC_OLB,
// 11436       TMC_OLA,
// 11437       TMC_S2GB,
// 11438       TMC_S2GA,
// 11439       TMC_DRV_OTPW,
// 11440       TMC_OT,
// 11441       TMC_STALLGUARD,
// 11442       TMC_DRV_CS_ACTUAL,
// 11443       TMC_FSACTIVE,
// 11444       TMC_SG_RESULT,
// 11445       TMC_DRV_STATUS_HEX,
// 11446       TMC_T157,
// 11447       TMC_T150,
// 11448       TMC_T143,
// 11449       TMC_T120,
// 11450       TMC_STEALTH,
// 11451       TMC_S2VSB,
// 11452       TMC_S2VSA
// 11453     };
// 11454     static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
// 11455       SERIAL_ECHO(name);
// 11456       SERIAL_ECHOPGM(" = 0x");
// 11457       for(int B=24; B>=8; B-=8){
// 11458         MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
// 11459         MYSERIAL.print((drv_status>>B)&0xF, HEX);
// 11460         MYSERIAL.print(':');
// 11461       }
// 11462       MYSERIAL.print((drv_status>>4)&0xF, HEX);
// 11463       MYSERIAL.print((drv_status)&0xF, HEX);
// 11464       SERIAL_EOL();
// 11465     }
// 11466 
// 11467     #if ENABLED(HAVE_TMC2130)
// 11468       static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
// 11469         switch(i) {
// 11470           case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
// 11471           case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
// 11472           case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
// 11473           case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
// 11474           default: break;
// 11475         }
// 11476       }
// 11477       static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
// 11478         switch(i) {
// 11479           case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
// 11480           case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
// 11481           case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
// 11482           default: break;
// 11483         }
// 11484       }
// 11485     #endif
// 11486     #if ENABLED(HAVE_TMC2208)
// 11487       static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
// 11488         switch(i) {
// 11489           case TMC_TSTEP:
// 11490             {
// 11491               uint32_t data = 0;
// 11492               st.TSTEP(&data);
// 11493               MYSERIAL.print(data);
// 11494               break;
// 11495             }
// 11496           case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
// 11497           case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
// 11498           case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
// 11499           case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
// 11500           default: break;
// 11501         }
// 11502       }
// 11503       static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
// 11504         switch(i) {
// 11505           case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
// 11506           case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
// 11507           case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
// 11508           case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
// 11509           default: break;
// 11510         }
// 11511       }
// 11512     #endif
// 11513     template <typename TMC>
// 11514     static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
// 11515       SERIAL_ECHO('\t');
// 11516       switch(i) {
// 11517         case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
// 11518         case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
// 11519         case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
// 11520         case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
// 11521         case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
// 11522         case TMC_IRUN:
// 11523           MYSERIAL.print(st.irun(), DEC);
// 11524           SERIAL_ECHOPGM("/31");
// 11525           break;
// 11526         case TMC_IHOLD:
// 11527           MYSERIAL.print(st.ihold(), DEC);
// 11528           SERIAL_ECHOPGM("/31");
// 11529           break;
// 11530         case TMC_CS_ACTUAL:
// 11531           MYSERIAL.print(st.cs_actual(), DEC);
// 11532           SERIAL_ECHOPGM("/31");
// 11533           break;
// 11534 
// 11535         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
// 11536 
// 11537         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
// 11538         case TMC_TPWMTHRS:
// 11539           {
// 11540             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 11541             SERIAL_ECHO(tpwmthrs_val);
// 11542           }
// 11543           break;
// 11544         case TMC_TPWMTHRS_MMS:
// 11545           {
// 11546             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 11547             tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
// 11548           }
// 11549           break;
// 11550         case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
// 11551         case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
// 11552         case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
// 11553         case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
// 11554         case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
// 11555         case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
// 11556         default: tmc_status(st, i); break;
// 11557       }
// 11558     }
// 11559     template <typename TMC>
// 11560     static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
// 11561       SERIAL_ECHOPGM("\t");
// 11562       switch(i) {
// 11563         case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
// 11564         case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
// 11565         case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
// 11566         case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
// 11567         case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
// 11568         case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
// 11569         case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
// 11570         case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
// 11571         case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
// 11572         case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
// 11573         default: tmc_parse_drv_status(st, i); break;
// 11574       }
// 11575     }
// 11576 
// 11577     static void tmc_debug_loop(const TMC_debug_enum i) {
// 11578       #if X_IS_TRINAMIC
// 11579         tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
// 11580       #endif
// 11581       #if X2_IS_TRINAMIC
// 11582         tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
// 11583       #endif
// 11584 
// 11585       #if Y_IS_TRINAMIC
// 11586         tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
// 11587       #endif
// 11588       #if Y2_IS_TRINAMIC
// 11589         tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
// 11590       #endif
// 11591 
// 11592       #if Z_IS_TRINAMIC
// 11593         tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
// 11594       #endif
// 11595       #if Z2_IS_TRINAMIC
// 11596         tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
// 11597       #endif
// 11598 
// 11599       #if E0_IS_TRINAMIC
// 11600         tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
// 11601       #endif
// 11602       #if E1_IS_TRINAMIC
// 11603         tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
// 11604       #endif
// 11605       #if E2_IS_TRINAMIC
// 11606         tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
// 11607       #endif
// 11608       #if E3_IS_TRINAMIC
// 11609         tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
// 11610       #endif
// 11611       #if E4_IS_TRINAMIC
// 11612         tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
// 11613       #endif
// 11614 
// 11615       SERIAL_EOL();
// 11616     }
// 11617 
// 11618     static void drv_status_loop(const TMC_drv_status_enum i) {
// 11619       #if X_IS_TRINAMIC
// 11620         tmc_parse_drv_status(stepperX, TMC_X, i);
// 11621       #endif
// 11622       #if X2_IS_TRINAMIC
// 11623         tmc_parse_drv_status(stepperX2, TMC_X2, i);
// 11624       #endif
// 11625 
// 11626       #if Y_IS_TRINAMIC
// 11627         tmc_parse_drv_status(stepperY, TMC_Y, i);
// 11628       #endif
// 11629       #if Y2_IS_TRINAMIC
// 11630         tmc_parse_drv_status(stepperY2, TMC_Y2, i);
// 11631       #endif
// 11632 
// 11633       #if Z_IS_TRINAMIC
// 11634         tmc_parse_drv_status(stepperZ, TMC_Z, i);
// 11635       #endif
// 11636       #if Z2_IS_TRINAMIC
// 11637         tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
// 11638       #endif
// 11639 
// 11640       #if E0_IS_TRINAMIC
// 11641         tmc_parse_drv_status(stepperE0, TMC_E0, i);
// 11642       #endif
// 11643       #if E1_IS_TRINAMIC
// 11644         tmc_parse_drv_status(stepperE1, TMC_E1, i);
// 11645       #endif
// 11646       #if E2_IS_TRINAMIC
// 11647         tmc_parse_drv_status(stepperE2, TMC_E2, i);
// 11648       #endif
// 11649       #if E3_IS_TRINAMIC
// 11650         tmc_parse_drv_status(stepperE3, TMC_E3, i);
// 11651       #endif
// 11652       #if E4_IS_TRINAMIC
// 11653         tmc_parse_drv_status(stepperE4, TMC_E4, i);
// 11654       #endif
// 11655 
// 11656       SERIAL_EOL();
// 11657     }
// 11658 
// 11659     inline void gcode_M122() {
// 11660       if (parser.seen('S')) {
// 11661         if (parser.value_bool()) {
// 11662           SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
// 11663           report_tmc_status = true;
// 11664         } else
// 11665           report_tmc_status = false;
// 11666       } else {
// 11667         SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
// 11668         SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
// 11669         SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
// 11670         SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
// 11671         SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
// 11672         SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
// 11673         SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
// 11674         SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
// 11675         SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
// 11676         SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
// 11677         SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
// 11678         SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
// 11679         SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
// 11680         SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
// 11681         SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
// 11682         SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
// 11683         SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
// 11684         SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
// 11685         SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
// 11686         SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
// 11687         SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
// 11688         SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
// 11689 
// 11690         SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
// 11691         #if ENABLED(HAVE_TMC2130)
// 11692           SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
// 11693           SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
// 11694           SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
// 11695         #endif
// 11696         SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
// 11697         SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
// 11698         SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
// 11699         SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
// 11700         SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
// 11701         SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
// 11702         SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
// 11703         #if ENABLED(HAVE_TMC2208)
// 11704           SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
// 11705           SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
// 11706           SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
// 11707           SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
// 11708           SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
// 11709           SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
// 11710         #endif
// 11711         SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
// 11712       }
// 11713     }
// 11714   #endif
// 11715 
// 11716   template<typename TMC>
// 11717   static void tmc_get_current(TMC &st, const char name[]) {
// 11718     SERIAL_ECHO(name);
// 11719     SERIAL_ECHOPGM(" axis driver current: ");
// 11720     SERIAL_ECHOLN(st.getCurrent());
// 11721   }
// 11722   template<typename TMC>
// 11723   static void tmc_set_current(TMC &st, const char name[], const int mA) {
// 11724     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
// 11725     tmc_get_current(st, name);
// 11726   }
// 11727 
// 11728   template<typename TMC>
// 11729   static void tmc_report_otpw(TMC &st, const char name[]) {
// 11730     SERIAL_ECHO(name);
// 11731     SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
// 11732     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
// 11733     SERIAL_EOL();
// 11734   }
// 11735   template<typename TMC>
// 11736   static void tmc_clear_otpw(TMC &st, const char name[]) {
// 11737     st.clear_otpw();
// 11738     SERIAL_ECHO(name);
// 11739     SERIAL_ECHOLNPGM(" prewarn flag cleared");
// 11740   }
// 11741 
// 11742   template<typename TMC>
// 11743   static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
// 11744     SERIAL_ECHO(name);
// 11745     SERIAL_ECHOPGM(" stealthChop max speed set to ");
// 11746     SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
// 11747   }
// 11748   template<typename TMC>
// 11749   static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
// 11750     st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
// 11751     tmc_get_pwmthrs(st, name, spmm);
// 11752   }
// 11753 
// 11754   template<typename TMC>
// 11755   static void tmc_get_sgt(TMC &st, const char name[]) {
// 11756     SERIAL_ECHO(name);
// 11757     SERIAL_ECHOPGM(" driver homing sensitivity set to ");
// 11758     MYSERIAL.println(st.sgt(), DEC);
// 11759   }
// 11760   template<typename TMC>
// 11761   static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
// 11762     st.sgt(sgt_val);
// 11763     tmc_get_sgt(st, name);
// 11764   }
// 11765 
// 11766   /**
// 11767    * M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 11768    * Report driver currents when no axis specified
// 11769    */
// 11770   inline void gcode_M906() {
// 11771     uint16_t values[XYZE];
// 11772     LOOP_XYZE(i)
// 11773       values[i] = parser.intval(axis_codes[i]);
// 11774 
// 11775     #if X_IS_TRINAMIC
// 11776       if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
// 11777       else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
// 11778     #endif
// 11779     #if X2_IS_TRINAMIC
// 11780       if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
// 11781       else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
// 11782     #endif
// 11783     #if Y_IS_TRINAMIC
// 11784       if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
// 11785       else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
// 11786     #endif
// 11787     #if Y2_IS_TRINAMIC
// 11788       if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
// 11789       else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
// 11790     #endif
// 11791     #if Z_IS_TRINAMIC
// 11792       if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
// 11793       else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
// 11794     #endif
// 11795     #if Z2_IS_TRINAMIC
// 11796       if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
// 11797       else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
// 11798     #endif
// 11799     #if E0_IS_TRINAMIC
// 11800       if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
// 11801       else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
// 11802     #endif
// 11803     #if E1_IS_TRINAMIC
// 11804       if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
// 11805       else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
// 11806     #endif
// 11807     #if E2_IS_TRINAMIC
// 11808       if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
// 11809       else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
// 11810     #endif
// 11811     #if E3_IS_TRINAMIC
// 11812       if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
// 11813       else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
// 11814     #endif
// 11815     #if E4_IS_TRINAMIC
// 11816       if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
// 11817       else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
// 11818     #endif
// 11819 
// 11820   }
// 11821 
// 11822   /**
// 11823    * M911: Report TMC stepper driver overtemperature pre-warn flag
// 11824    * The flag is held by the library and persist until manually cleared by M912
// 11825    */
// 11826   inline void gcode_M911() {
// 11827     #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11828       tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11829     #endif
// 11830     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11831       tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11832     #endif
// 11833     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11834       tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11835     #endif
// 11836     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11837       tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11838     #endif
// 11839   }
// 11840 
// 11841   /**
// 11842    * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
// 11843    */
// 11844   inline void gcode_M912() {
// 11845     const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
// 11846              clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
// 11847     #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11848       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11849     #endif
// 11850     #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11851       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11852     #endif
// 11853 
// 11854     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
// 11855       if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11856     #endif
// 11857 
// 11858     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
// 11859       if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11860     #endif
// 11861 
// 11862     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
// 11863       if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11864     #endif
// 11865   }
// 11866 
// 11867   /**
// 11868    * M913: Set HYBRID_THRESHOLD speed.
// 11869    */
// 11870   #if ENABLED(HYBRID_THRESHOLD)
// 11871     inline void gcode_M913() {
// 11872       uint16_t values[XYZE];
// 11873       LOOP_XYZE(i)
// 11874         values[i] = parser.intval(axis_codes[i]);
// 11875 
// 11876       #if X_IS_TRINAMIC
// 11877         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11878         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
// 11879       #endif
// 11880       #if X2_IS_TRINAMIC
// 11881         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11882         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
// 11883       #endif
// 11884 
// 11885       #if Y_IS_TRINAMIC
// 11886         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11887         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
// 11888       #endif
// 11889       #if Y2_IS_TRINAMIC
// 11890         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11891         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
// 11892       #endif
// 11893 
// 11894       #if Z_IS_TRINAMIC
// 11895         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11896         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
// 11897       #endif
// 11898       #if Z2_IS_TRINAMIC
// 11899         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11900         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
// 11901       #endif
// 11902 
// 11903       #if E0_IS_TRINAMIC
// 11904         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11905         else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
// 11906       #endif
// 11907       #if E1_IS_TRINAMIC
// 11908         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11909         else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
// 11910       #endif
// 11911       #if E2_IS_TRINAMIC
// 11912         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11913         else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
// 11914       #endif
// 11915       #if E3_IS_TRINAMIC
// 11916         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11917         else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
// 11918       #endif
// 11919       #if E4_IS_TRINAMIC
// 11920         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11921         else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
// 11922       #endif
// 11923     }
// 11924   #endif // HYBRID_THRESHOLD
// 11925 
// 11926   /**
// 11927    * M914: Set SENSORLESS_HOMING sensitivity.
// 11928    */
// 11929   #if ENABLED(SENSORLESS_HOMING)
// 11930     inline void gcode_M914() {
// 11931       #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11932         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
// 11933         else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
// 11934       #endif
// 11935       #if ENABLED(X2_IS_TMC2130)
// 11936         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
// 11937         else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
// 11938       #endif
// 11939       #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11940         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
// 11941         else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
// 11942       #endif
// 11943       #if ENABLED(Y2_IS_TMC2130)
// 11944         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
// 11945         else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
// 11946       #endif
// 11947     }
// 11948   #endif // SENSORLESS_HOMING
// 11949 
// 11950   /**
// 11951    * TMC Z axis calibration routine
// 11952    */
// 11953   #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 11954     inline void gcode_M915() {
// 11955       uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
// 11956       uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
// 11957 
// 11958       if (!axis_known_position[Z_AXIS]) {
// 11959         SERIAL_ECHOLNPGM("\nPlease home Z axis first");
// 11960         return;
// 11961       }
// 11962 
// 11963       uint16_t Z_current_1 = stepperZ.getCurrent();
// 11964       uint16_t Z2_current_1 = stepperZ.getCurrent();
// 11965 
// 11966       stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11967       stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11968       SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
// 11969 
// 11970       soft_endstops_enabled = false;
// 11971 
// 11972       do_blocking_move_to_z(Z_MAX_POS+_z);
// 11973 
// 11974       stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11975       stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11976 
// 11977       do_blocking_move_to_z(Z_MAX_POS);
// 11978       soft_endstops_enabled = true;
// 11979 
// 11980       SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
// 11981       home_z_safely();
// 11982     }
// 11983   #endif
// 11984 
// 11985 #endif // HAS_TRINAMIC
// 11986 
// 11987 /**
// 11988  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
// 11989  */
// 11990 inline void gcode_M907() {
// 11991   #if HAS_DIGIPOTSS
// 11992 
// 11993     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
// 11994     if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
// 11995     if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
// 11996 
// 11997   #elif HAS_MOTOR_CURRENT_PWM
// 11998 
// 11999     #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
// 12000       if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
// 12001     #endif
// 12002     #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
// 12003       if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
// 12004     #endif
// 12005     #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
// 12006       if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
// 12007     #endif
// 12008 
// 12009   #endif
// 12010 
// 12011   #if ENABLED(DIGIPOT_I2C)
// 12012     // this one uses actual amps in floating point
// 12013     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
// 12014     // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
// 12015     for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
// 12016   #endif
// 12017 
// 12018   #if ENABLED(DAC_STEPPER_CURRENT)
// 12019     if (parser.seen('S')) {
// 12020       const float dac_percent = parser.value_float();
// 12021       for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
// 12022     }
// 12023     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
// 12024   #endif
// 12025 }
// 12026 
// 12027 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 12028 
// 12029   /**
// 12030    * M908: Control digital trimpot directly (M908 P<pin> S<current>)
// 12031    */
// 12032   inline void gcode_M908() {
// 12033     #if HAS_DIGIPOTSS
// 12034       stepper.digitalPotWrite(
// 12035         parser.intval('P'),
// 12036         parser.intval('S')
// 12037       );
// 12038     #endif
// 12039     #ifdef DAC_STEPPER_CURRENT
// 12040       dac_current_raw(
// 12041         parser.byteval('P', -1),
// 12042         parser.ushortval('S', 0)
// 12043       );
// 12044     #endif
// 12045   }
// 12046 
// 12047   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 12048 
// 12049     inline void gcode_M909() { dac_print_values(); }
// 12050 
// 12051     inline void gcode_M910() { dac_commit_eeprom(); }
// 12052 
// 12053   #endif
// 12054 
// 12055 #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 12056 
// 12057 #if HAS_MICROSTEPS
// 12058 
// 12059   // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 12060   inline void gcode_M350() {
// 12061     if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
// 12062     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
// 12063     if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
// 12064     stepper.microstep_readings();
// 12065   }
// 12066 
// 12067   /**
// 12068    * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
// 12069    *       S# determines MS1 or MS2, X# sets the pin high/low.
// 12070    */
// 12071   inline void gcode_M351() {
// 12072     if (parser.seenval('S')) switch (parser.value_byte()) {
// 12073       case 1:
// 12074         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
// 12075         if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
// 12076         break;
// 12077       case 2:
// 12078         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
// 12079         if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
// 12080         break;
// 12081     }
// 12082     stepper.microstep_readings();
// 12083   }
// 12084 
// 12085 #endif // HAS_MICROSTEPS
// 12086 
// 12087 #if HAS_CASE_LIGHT
// 12088   #ifndef INVERT_CASE_LIGHT
// 12089     #define INVERT_CASE_LIGHT false
// 12090   #endif
// 12091   uint8_t case_light_brightness;  // LCD routine wants INT
// 12092   bool case_light_on;
// 12093 
// 12094   void update_case_light() {
// 12095     pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
// 12096     if (case_light_on) {
// 12097       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 12098         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
// 12099       else
// 12100         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
// 12101     }
// 12102     else {
// 12103       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 12104         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
// 12105       else
// 12106         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
// 12107     }
// 12108   }
// 12109 #endif // HAS_CASE_LIGHT
// 12110 
// 12111 /**
// 12112  * M355: Turn case light on/off and set brightness
// 12113  *
// 12114  *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
// 12115  *
// 12116  *   S<bool>  Set case light on/off
// 12117  *
// 12118  *   When S turns on the light on a PWM pin then the current brightness level is used/restored
// 12119  *
// 12120  *   M355 P200 S0 turns off the light & sets the brightness level
// 12121  *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
// 12122  */
// 12123 inline void gcode_M355() {
// 12124   #if HAS_CASE_LIGHT
// 12125     uint8_t args = 0;
// 12126     if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
// 12127     if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
// 12128     if (args) update_case_light();
// 12129 
// 12130     // always report case light status
// 12131     SERIAL_ECHO_START();
// 12132     if (!case_light_on) {
// 12133       SERIAL_ECHOLN("Case light: off");
// 12134     }
// 12135     else {
// 12136       if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
// 12137       else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
// 12138     }
// 12139 
// 12140   #else
// 12141     SERIAL_ERROR_START();
// 12142     SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
// 12143   #endif // HAS_CASE_LIGHT
// 12144 }
// 12145 
// 12146 #if ENABLED(MIXING_EXTRUDER)
// 12147 
// 12148   /**
// 12149    * M163: Set a single mix factor for a mixing extruder
// 12150    *       This is called "weight" by some systems.
// 12151    *
// 12152    *   S[index]   The channel index to set
// 12153    *   P[float]   The mix value
// 12154    *
// 12155    */
// 12156   inline void gcode_M163() {
// 12157     const int mix_index = parser.intval('S');
// 12158     if (mix_index < MIXING_STEPPERS) {
// 12159       float mix_value = parser.floatval('P');
// 12160       NOLESS(mix_value, 0.0);
// 12161       mixing_factor[mix_index] = RECIPROCAL(mix_value);
// 12162     }
// 12163   }
// 12164 
// 12165   #if MIXING_VIRTUAL_TOOLS > 1
// 12166 
// 12167     /**
// 12168      * M164: Store the current mix factors as a virtual tool.
// 12169      *
// 12170      *   S[index]   The virtual tool to store
// 12171      *
// 12172      */
// 12173     inline void gcode_M164() {
// 12174       const int tool_index = parser.intval('S');
// 12175       if (tool_index < MIXING_VIRTUAL_TOOLS) {
// 12176         normalize_mix();
// 12177         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 12178           mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
// 12179       }
// 12180     }
// 12181 
// 12182   #endif
// 12183 
// 12184   #if ENABLED(DIRECT_MIXING_IN_G1)
// 12185     /**
// 12186      * M165: Set multiple mix factors for a mixing extruder.
// 12187      *       Factors that are left out will be set to 0.
// 12188      *       All factors together must add up to 1.0.
// 12189      *
// 12190      *   A[factor] Mix factor for extruder stepper 1
// 12191      *   B[factor] Mix factor for extruder stepper 2
// 12192      *   C[factor] Mix factor for extruder stepper 3
// 12193      *   D[factor] Mix factor for extruder stepper 4
// 12194      *   H[factor] Mix factor for extruder stepper 5
// 12195      *   I[factor] Mix factor for extruder stepper 6
// 12196      *
// 12197      */
// 12198     inline void gcode_M165() { gcode_get_mix(); }
// 12199   #endif
// 12200 
// 12201 #endif // MIXING_EXTRUDER
// 12202 
// 12203 /**
// 12204  * M999: Restart after being stopped
// 12205  *
// 12206  * Default behaviour is to flush the serial buffer and request
// 12207  * a resend to the host starting on the last N line received.
// 12208  *
// 12209  * Sending "M999 S1" will resume printing without flushing the
// 12210  * existing command buffer.
// 12211  *
// 12212  */
// 12213 inline void gcode_M999() {
// 12214   Running = true;
// 12215   lcd_reset_alert_level();
// 12216 
// 12217   if (parser.boolval('S')) return;
// 12218 
// 12219   // gcode_LastN = Stopped_gcode_LastN;
// 12220   FlushSerialRequestResend();
// 12221 }
// 12222 
// 12223 #if ENABLED(SWITCHING_EXTRUDER)
// 12224   #if EXTRUDERS > 3
// 12225     #define REQ_ANGLES 4
// 12226     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
// 12227   #else
// 12228     #define REQ_ANGLES 2
// 12229     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
// 12230   #endif
// 12231   inline void move_extruder_servo(const uint8_t e) {
// 12232     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
// 12233     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
// 12234     stepper.synchronize();
// 12235     #if EXTRUDERS & 1
// 12236       if (e < EXTRUDERS - 1)
// 12237     #endif
// 12238     {
// 12239       MOVE_SERVO(_SERVO_NR, angles[e]);
// 12240       safe_delay(500);
// 12241     }
// 12242   }
// 12243 #endif // SWITCHING_EXTRUDER
// 12244 
// 12245 #if ENABLED(SWITCHING_NOZZLE)
// 12246   inline void move_nozzle_servo(const uint8_t e) {
// 12247     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
// 12248     stepper.synchronize();
// 12249     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
// 12250     safe_delay(500);
// 12251   }
// 12252 #endif
// 12253 
// 12254 inline void invalid_extruder_error(const uint8_t e) {
// 12255   SERIAL_ECHO_START();
// 12256   SERIAL_CHAR('T');
// 12257   SERIAL_ECHO_F(e, DEC);
// 12258   SERIAL_CHAR(' ');
// 12259   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
// 12260 }
// 12261 
// 12262 #if ENABLED(PARKING_EXTRUDER)
// 12263 
// 12264   #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12265     #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 12266   #else
// 12267     #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 12268   #endif
// 12269 
// 12270   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
// 12271     switch (extruder_num) {
// 12272       case 1: OUT_WRITE(SOL1_PIN, state); break;
// 12273       default: OUT_WRITE(SOL0_PIN, state); break;
// 12274     }
// 12275     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
// 12276       dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
// 12277     #endif
// 12278   }
// 12279 
// 12280   inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
// 12281   inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
// 12282 
// 12283 #endif // PARKING_EXTRUDER
// 12284 
// 12285 #if HAS_FANMUX
// 12286 
// 12287   void fanmux_switch(const uint8_t e) {
// 12288     WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 12289     #if PIN_EXISTS(FANMUX1)
// 12290       WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 12291       #if PIN_EXISTS(FANMUX2)
// 12292         WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
// 12293       #endif
// 12294     #endif
// 12295   }
// 12296 
// 12297   FORCE_INLINE void fanmux_init(void) {
// 12298     SET_OUTPUT(FANMUX0_PIN);
// 12299     #if PIN_EXISTS(FANMUX1)
// 12300       SET_OUTPUT(FANMUX1_PIN);
// 12301       #if PIN_EXISTS(FANMUX2)
// 12302         SET_OUTPUT(FANMUX2_PIN);
// 12303       #endif
// 12304     #endif
// 12305     fanmux_switch(0);
// 12306   }
// 12307 
// 12308 #endif // HAS_FANMUX
// 12309 
// 12310 /**
// 12311  * Perform a tool-change, which may result in moving the
// 12312  * previous tool out of the way and the new tool into place.
// 12313  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function _Z11tool_changehfb
        THUMB
// 12314 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
_Z11tool_changehfb:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+100
          CFI CFA R13+136
        MOV      R6,R0
        MOV      R0,R1
        MOV      R5,R2
// 12315   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 12316 
// 12317     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
// 12318       return invalid_extruder_error(tmp_extruder);
// 12319 
// 12320     // T0-Tnnn: Switch virtual tool by changing the mix
// 12321     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
// 12322       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
// 12323 
// 12324   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12325 
// 12326     if (tmp_extruder >= EXTRUDERS)
        MOV      R10,R6
        CMP      R10,#+2
        BLT.N    ??tool_change_0
// 12327       return invalid_extruder_error(tmp_extruder);
        MOV      R0,R6
          CFI FunCall _Z22invalid_extruder_errorh
        BL       _Z22invalid_extruder_errorh
        B.N      ??tool_change_1
// 12328 
// 12329     #if HOTENDS > 1
// 12330 
// 12331       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
??tool_change_0:
        LDR.W    R4,??DataTable156_1
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??tool_change_2
        STR      R0,[SP, #+24]
        B.N      ??tool_change_3
??tool_change_2:
        LDR      R1,[R4, #+92]
        STR      R1,[SP, #+24]
// 12332 
// 12333       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??tool_change_3:
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??tool_change_4
        STR      R0,[R4, #+92]
        B.N      ??tool_change_5
??tool_change_4:
        LDR      R0,[R4, #+116]
        STR      R0,[R4, #+92]
// 12334 
// 12335       if (tmp_extruder != active_extruder) {
??tool_change_5:
        LDRB     R0,[R4, #+3]
        CMP      R6,R0
        BEQ.W    ??tool_change_6
// 12336         if (!no_move && axis_unhomed_error()) {
        CMP      R5,#+0
        BNE.N    ??tool_change_7
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BEQ.N    ??tool_change_7
// 12337           no_move = true;
        MOVS     R5,#+1
// 12338           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12339             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
// 12340           #endif
// 12341         }
// 12342 
// 12343         // Save current position to destination, for use later
// 12344         //if(gCfgItems.breakpoint_flg!=1)
// 12345             set_destination_from_current();
??tool_change_7:
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
// 12346 
// 12347         #if ENABLED(DUAL_X_CARRIAGE)
// 12348 
// 12349           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12350             if (DEBUGGING(LEVELING)) {
// 12351               SERIAL_ECHOPGM("Dual X Carriage Mode ");
// 12352               switch (dual_x_carriage_mode) {
// 12353                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
// 12354                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
// 12355                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
// 12356               }
// 12357             }
// 12358           #endif
// 12359 
// 12360           const float xhome = x_home_pos(active_extruder);
// 12361           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
// 12362               && IsRunning()
// 12363               && (delayed_move_time || current_position[X_AXIS] != xhome)
// 12364           ) {
// 12365             float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
// 12366             //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 12367             if(mksCfg.max_software_endstops){
// 12368               NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
// 12369             }
// 12370             //#endif
// 12371             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12372               if (DEBUGGING(LEVELING)) {
// 12373                 SERIAL_ECHOLNPAIR("Raise to ", raised_z);
// 12374                 SERIAL_ECHOLNPAIR("MoveX to ", xhome);
// 12375                 SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
// 12376               }
// 12377             #endif
// 12378             // Park old head: 1) raise 2) move to park position 3) lower
// 12379             for (uint8_t i = 0; i < 3; i++)
// 12380               planner.buffer_line(
// 12381                 i == 0 ? current_position[X_AXIS] : xhome,
// 12382                 current_position[Y_AXIS],
// 12383                 i == 2 ? current_position[Z_AXIS] : raised_z,
// 12384                 current_position[E_AXIS],
// 12385                 planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
// 12386                 active_extruder
// 12387               );
// 12388             stepper.synchronize();
// 12389           }
// 12390 
// 12391           // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
// 12392           current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
// 12393           current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 12394 
// 12395           // Activate the new extruder ahead of calling set_axis_is_at_home!
// 12396           active_extruder = tmp_extruder;
// 12397 
// 12398           // This function resets the max/min values - the current position may be overwritten below.
// 12399           set_axis_is_at_home(X_AXIS);
// 12400 
// 12401           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12402             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
// 12403           #endif
// 12404 
// 12405           // Only when auto-parking are carriages safe to move
// 12406           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
// 12407 
// 12408           switch (dual_x_carriage_mode) {
// 12409             case DXC_FULL_CONTROL_MODE:
// 12410               // New current position is the position of the activated extruder
// 12411               current_position[X_AXIS] = inactive_extruder_x_pos;
// 12412               // Save the inactive extruder's position (from the old current_position)
// 12413               inactive_extruder_x_pos = destination[X_AXIS];
// 12414               break;
// 12415             case DXC_AUTO_PARK_MODE:
// 12416               // record raised toolhead position for use by unpark
// 12417               COPY(raised_parked_position, current_position);
// 12418               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
// 12419               //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 12420               if(mksCfg.max_software_endstops){
// 12421                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
// 12422               }
// 12423               //#endif
// 12424               active_extruder_parked = true;
// 12425               delayed_move_time = 0;
// 12426               break;
// 12427             case DXC_DUPLICATION_MODE:
// 12428               // If the new extruder is the left one, set it "parked"
// 12429               // This triggers the second extruder to move into the duplication position
// 12430               active_extruder_parked = (active_extruder == 0);
// 12431 
// 12432               if (active_extruder_parked)
// 12433                 current_position[X_AXIS] = inactive_extruder_x_pos;
// 12434               else
// 12435                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
// 12436               inactive_extruder_x_pos = destination[X_AXIS];
// 12437               extruder_duplication_enabled = false;
// 12438               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12439                 if (DEBUGGING(LEVELING)) {
// 12440                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
// 12441                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
// 12442                 }
// 12443               #endif
// 12444               break;
// 12445           }
// 12446 
// 12447           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12448             if (DEBUGGING(LEVELING)) {
// 12449               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
// 12450               DEBUG_POS("New extruder (parked)", current_position);
// 12451             }
// 12452           #endif
// 12453 
// 12454           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
// 12455 
// 12456         #else // !DUAL_X_CARRIAGE
// 12457 
// 12458           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
// 12459             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 12460             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
// 12461             if (!no_move) {
// 12462 
// 12463               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
// 12464                           midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
// 12465                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
// 12466                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
// 12467               /**
// 12468                *  Steps:
// 12469                *    1. Raise Z-Axis to give enough clearance
// 12470                *    2. Move to park position of old extruder
// 12471                *    3. Disengage magnetic field, wait for delay
// 12472                *    4. Move near new extruder
// 12473                *    5. Engage magnetic field for new extruder
// 12474                *    6. Move to parking incl. offset of new extruder
// 12475                *    7. Lower Z-Axis
// 12476                */
// 12477 
// 12478               // STEP 1
// 12479               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12480                 SERIAL_ECHOLNPGM("Starting Autopark");
// 12481                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
// 12482               #endif
// 12483               current_position[Z_AXIS] += z_raise;
// 12484               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12485                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
// 12486                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
// 12487               #endif
// 12488               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 12489               stepper.synchronize();
// 12490 
// 12491               // STEP 2
// 12492               current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
// 12493               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12494                 SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
// 12495                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
// 12496               #endif
// 12497               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12498               stepper.synchronize();
// 12499 
// 12500               // STEP 3
// 12501               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12502                 SERIAL_ECHOLNPGM("(3) Disengage magnet ");
// 12503               #endif
// 12504               pe_deactivate_magnet(active_extruder);
// 12505 
// 12506               // STEP 4
// 12507               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12508                 SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
// 12509               #endif
// 12510               current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
// 12511 
// 12512               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12513                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
// 12514               #endif
// 12515               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12516               stepper.synchronize();
// 12517 
// 12518               // STEP 5
// 12519               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12520                 SERIAL_ECHOLNPGM("(5) Engage magnetic field");
// 12521               #endif
// 12522 
// 12523               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12524                 pe_activate_magnet(active_extruder); //just save power for inverted magnets
// 12525               #endif
// 12526               pe_activate_magnet(tmp_extruder);
// 12527 
// 12528               // STEP 6
// 12529               current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
// 12530               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12531               current_position[X_AXIS] = grabpos;
// 12532               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12533                 SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
// 12534                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
// 12535               #endif
// 12536               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
// 12537               stepper.synchronize();
// 12538 
// 12539               // Step 7
// 12540               current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
// 12541               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12542                 SERIAL_ECHOLNPGM("(7) Move midway between hotends");
// 12543                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
// 12544               #endif
// 12545               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12546               stepper.synchronize();
// 12547               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12548                 SERIAL_ECHOLNPGM("Autopark done.");
// 12549               #endif
// 12550             }
// 12551             else { // nomove == true
// 12552               // Only engage magnetic field for new extruder
// 12553               pe_activate_magnet(tmp_extruder);
// 12554               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12555                 pe_activate_magnet(active_extruder); // Just save power for inverted magnets
// 12556               #endif
// 12557             }
// 12558             current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
// 12559 
// 12560             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12561               if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
// 12562             #endif
// 12563 
// 12564           #endif // dualParking extruder
// 12565 
// 12566           #if ENABLED(SWITCHING_NOZZLE)
// 12567             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
// 12568             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
// 12569             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
// 12570                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
// 12571 
// 12572             // Always raise by some amount (destination copied from current_position earlier)
// 12573             current_position[Z_AXIS] += z_raise;
// 12574             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 12575             move_nozzle_servo(tmp_extruder);
// 12576           #endif
// 12577 
// 12578           /**
// 12579            * Set current_position to the position of the new nozzle.
// 12580            * Offsets are based on linear distance, so we need to get
// 12581            * the resulting position in coordinate space.
// 12582            *
// 12583            * - With grid or 3-point leveling, offset XYZ by a tilted vector
// 12584            * - With mesh leveling, update Z for the new position
// 12585            * - Otherwise, just use the raw linear distance
// 12586            *
// 12587            * Software endstops are altered here too. Consider a case where:
// 12588            *   E0 at X=0 ... E1 at X=10
// 12589            * When we switch to E1 now X=10, but E1 can't move left.
// 12590            * To express this we apply the change in XY to the software endstops.
// 12591            * E1 can move farther right than E0, so the right limit is extended.
// 12592            *
// 12593            * Note that we don't adjust the Z software endstops. Why not?
// 12594            * Consider a case where Z=0 (here) and switching to E1 makes Z=1
// 12595            * because the bed is 1mm lower at the new position. As long as
// 12596            * the first nozzle is out of the way, the carriage should be
// 12597            * allowed to move 1mm lower. This technically "breaks" the
// 12598            * Z software endstop. But this is technically correct (and
// 12599            * there is no viable alternative).
// 12600            */
// 12601           //#if ABL_PLANAR
// 12602           float xydiff[2]={0};
        MOV      R8,#+0
        MOV      R9,R8
        LDR.W    R7,??DataTable160_1
        LDR.W    R0,??DataTable158
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??tool_change_8
// 12603 		  if(BED_LEVELING_METHOD&ABL_PLANAR)
// 12604 		  	{
// 12605             // Offset extruder, make sure to apply the bed level rotation matrix
// 12606             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 12607                                                hotend_offset[Y_AXIS][tmp_extruder],
// 12608                                                0),
        LDR.W    R9,??DataTable160_2
        MOV      R3,R8
        ADD      R0,R9,R10, LSL #+2
        LDR      R2,[R0, #+8]
        LDR      R1,[R9, R10, LSL #+2]
        ADD      R0,SP,#+52
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDRB     R0,[R4, #+3]
        MOV      R3,R8
        ADD      R1,R9,R0, LSL #+2
        LDR      R2,[R1, #+8]
        LDR      R1,[R9, R0, LSL #+2]
        ADD      R0,SP,#+40
// 12609                      act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 12610                                                hotend_offset[Y_AXIS][active_extruder],
// 12611                                                0),
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        ADD      R0,SP,#+40
        SUB      SP,SP,#+8
          CFI CFA R13+144
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+136
        ADD      R1,SP,#+52
        ADD      R0,SP,#+4
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
// 12612                      offset_vec = tmp_offset_vec - act_offset_vec;
        ADD      R0,SP,#+28
        ADD      R1,SP,#+4
        LDM      R1!,{R2,R3,R12}
        STM      R0!,{R2,R3,R12}
// 12613 
// 12614             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12615               if (DEBUGGING(LEVELING)) {
// 12616                 tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 12617                 act_offset_vec.debug(PSTR("act_offset_vec"));
// 12618                 offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 12619               }
// 12620             #endif
// 12621 
// 12622             offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
        LDR.W    R1,??DataTable160_3
        SUB      SP,SP,#+12
          CFI CFA R13+148
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R1-R3}
          CFI CFA R13+136
        ADD      R0,SP,#+64
          CFI FunCall _ZN10matrix_3x39transposeES_
        BL       _ZN10matrix_3x39transposeES_
        ADD      R1,SP,#+64
        SUB      SP,SP,#+12
          CFI CFA R13+148
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R1-R3}
          CFI CFA R13+136
        ADD      R0,SP,#+28
          CFI FunCall _ZN8vector_314apply_rotationE10matrix_3x3
        BL       _ZN8vector_314apply_rotationE10matrix_3x3
// 12623 
// 12624             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12625               if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 12626             #endif
// 12627 
// 12628             // Adjustments to the current position
// 12629             //const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 12630 			xydiff[0] = offset_vec.x;
        LDR      R8,[SP, #+28]
// 12631 			xydiff[1] = offset_vec.y;
        LDR      R9,[SP, #+32]
// 12632             current_position[Z_AXIS] += offset_vec.z;
        LDR      R1,[R4, #+16]
        LDR      R0,[SP, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
        B.N      ??tool_change_9
// 12633 		  }
// 12634           //#else // !ABL_PLANAR
// 12635 			else
// 12636 			{
// 12637 				/*
// 12638             		const float xydiff[2] = {
// 12639               			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 12640              	 		hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 12641             		};*/
// 12642             if(gCfgItems.breakpoint_flg!=1)
??tool_change_8:
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_10
        LDRB     R11,[R4, #+3]
        LDR.W    R9,??DataTable160_2
        LDR      R0,[R9, R10, LSL #+2]
        LDR      R1,[R9, R11, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
// 12643             {
// 12644 			    xydiff[0] = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
// 12645 			    xydiff[1] = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
        ADD      R0,R9,R10, LSL #+2
        LDR      R0,[R0, #+8]
        ADD      R1,R9,R11, LSL #+2
        LDR      R1,[R1, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 12646             }
// 12647 				
// 12648             //#if ENABLED(MESH_BED_LEVELING)
// 12649 			if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
??tool_change_10:
        LDR.W    R0,??DataTable158
        LDRB     R0,[R0, #+64]
        CMP      R0,#+32
        BNE.N    ??tool_change_9
// 12650 			{
// 12651               if (planner.leveling_active) {
        LDR.W    R0,??DataTable160_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??tool_change_9
// 12652                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12653                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 12654                 #endif
// 12655                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
        LDR      R0,[R4, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+12]
// 12656                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+8]
// 12657                       z1 = current_position[Z_AXIS], z2 = z1;
        LDR      R0,[R4, #+16]
        STR      R0,[SP, #+0]
        STR      R0,[SP, #+4]
// 12658                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
        ADD      R2,SP,#+0
        ADD      R1,R4,#+12
        ADD      R0,R4,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 12659                 planner.apply_leveling(x2, y2, z2);
        ADD      R2,SP,#+4
        ADD      R1,SP,#+8
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 12660                 current_position[Z_AXIS] += z2 - z1;
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
// 12661                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12662                   if (DEBUGGING(LEVELING))
// 12663                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 12664                 #endif
// 12665               }
// 12666 			}
// 12667             //#endif // MESH_BED_LEVELING
// 12668 				}
// 12669           //#endif // !HAS_ABL
// 12670 
// 12671           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12672             if (DEBUGGING(LEVELING)) {
// 12673               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
// 12674               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
// 12675               SERIAL_ECHOLNPGM(" }");
// 12676             }
// 12677           #endif
// 12678 
// 12679           // The newly-selected extruder XY is actually at...
// 12680           if(gCfgItems.breakpoint_flg!=1)
??tool_change_9:
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_11
// 12681           {
// 12682             current_position[X_AXIS] += xydiff[X_AXIS];
        LDR      R0,[R4, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+8]
// 12683             current_position[Y_AXIS] += xydiff[Y_AXIS];
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+12]
// 12684           }
// 12685           // Set the new active extruder
// 12686           active_extruder = tmp_extruder;
??tool_change_11:
        STRB     R6,[R4, #+3]
// 12687 
// 12688         #endif // !DUAL_X_CARRIAGE
// 12689 
// 12690         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12691           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
// 12692         #endif
// 12693 
// 12694         // Tell the planner the new "current position"
// 12695         if(gCfgItems.breakpoint_flg!=1)
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_12
// 12696             SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 12697 
// 12698         // Move to the "old position" (move the extruder into place)
// 12699         #if ENABLED(SWITCHING_NOZZLE)
// 12700           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
// 12701         #endif
// 12702         if (!no_move && IsRunning()) {
??tool_change_12:
        CMP      R5,#+0
        BNE.N    ??tool_change_6
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??tool_change_6
// 12703           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12704             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
// 12705           #endif
// 12706           // Move back to the original (or tweaked) position
// 12707           if(gCfgItems.breakpoint_flg!=1)
        LDRB     R0,[R7, #+341]
        CMP      R0,#+1
        BEQ.N    ??tool_change_6
// 12708             do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R4,#+32
        ADD      R1,R4,#+28
        ADD      R0,R4,#+24
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 12709         }
// 12710         #if ENABLED(SWITCHING_NOZZLE)
// 12711           else {
// 12712             // Move back down. (Including when the new tool is higher.)
// 12713             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
// 12714           }
// 12715         #endif
// 12716       } // (tmp_extruder != active_extruder)
// 12717 
// 12718       stepper.synchronize();
??tool_change_6:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 12719 
// 12720       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
// 12721         disable_all_solenoids();
// 12722         enable_solenoid_on_active_extruder();
// 12723       #endif // EXT_SOLENOID
// 12724 
// 12725       feedrate_mm_s = old_feedrate_mm_s;
        LDR      R0,[SP, #+24]
        STR      R0,[R4, #+92]
// 12726 
// 12727     #else // HOTENDS <= 1
// 12728 
// 12729       UNUSED(fr_mm_s);
// 12730       UNUSED(no_move);
// 12731 
// 12732       #if ENABLED(MK2_MULTIPLEXER)
// 12733         if (tmp_extruder >= E_STEPPERS)
// 12734           return invalid_extruder_error(tmp_extruder);
// 12735 
// 12736         select_multiplexed_stepper(tmp_extruder);
// 12737       #endif
// 12738 
// 12739       // Set the new active extruder
// 12740       active_extruder = tmp_extruder;
// 12741 
// 12742     #endif // HOTENDS <= 1
// 12743 
// 12744     #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 12745       stepper.synchronize();
// 12746       move_extruder_servo(active_extruder);
// 12747     #endif
// 12748 
// 12749     #if HAS_FANMUX
// 12750       fanmux_switch(active_extruder);
// 12751     #endif
// 12752 
// 12753     SERIAL_ECHO_START();
        LDR.N    R0,??DataTable155_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12754     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
        LDRB     R1,[R4, #+3]
        ADR.W    R0,`?<Constant "Active Extruder: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.W    R0,??DataTable161
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 12755 
// 12756   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12757 }
??tool_change_1:
        ADD      SP,SP,#+100
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock65

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155:
        DC8      " E:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_1:
        DC8      ":",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_2:
        DC32     0x40400000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_3:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_4:
        DC32     0x3ff80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_5:
        DC32     z_endstop_adj

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_6:
        DC32     0x9999999a

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_7:
        DC32     0x3fb99999

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable155_8:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Active Extruder: ">`:
        DC8 "Active Extruder: "
        DC8 0, 0
// 12758 
// 12759 /**
// 12760  * T0-T3: Switch tool, usually switching extruders
// 12761  *
// 12762  *   F[units/min] Set the movement feedrate
// 12763  *   S1           Don't move the tool in XY after change
// 12764  */
// 12765 inline void gcode_T(const uint8_t tmp_extruder) {
// 12766 
// 12767   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12768     if (DEBUGGING(LEVELING)) {
// 12769       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
// 12770       SERIAL_CHAR(')');
// 12771       SERIAL_EOL();
// 12772       DEBUG_POS("BEFORE", current_position);
// 12773     }
// 12774   #endif
// 12775 
// 12776   #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
// 12777 
// 12778     tool_change(tmp_extruder);
// 12779 
// 12780   #elif HOTENDS > 1
// 12781 
// 12782     tool_change(
// 12783       tmp_extruder,
// 12784       MMM_TO_MMS(parser.linearval('F')),
// 12785       (tmp_extruder == active_extruder) || parser.boolval('S')
// 12786     );
// 12787 
// 12788   #endif
// 12789 
// 12790   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12791     if (DEBUGGING(LEVELING)) {
// 12792       DEBUG_POS("AFTER", current_position);
// 12793       SERIAL_ECHOLNPGM("<<< gcode_T");
// 12794     }
// 12795   #endif
// 12796 }
// 12797 
// 12798 /**
// 12799  * Process the parsed command and dispatch it to its handler
// 12800  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function _Z22process_parsed_commandv
        THUMB
// 12801 void process_parsed_command() {
_Z22process_parsed_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 12802   KEEPALIVE_STATE(IN_HANDLER);
        LDR.W    R4,??DataTable161_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+6]
// 12803 
// 12804   // Handle a known G, M, or T
// 12805   switch (parser.command_letter) {
        LDR.W    R0,??DataTable160_5
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+71
        BEQ.N    ??process_parsed_command_0
        CMP      R0,#+77
        BEQ.W    ??process_parsed_command_1
        CMP      R0,#+84
        BEQ.W    ??process_parsed_command_2
        B.N      ??process_parsed_command_3
// 12806     case 'G': switch (parser.codenum) {
??process_parsed_command_0:
        LDR.W    R0,??DataTable161_2
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+1
        BEQ.N    ??process_parsed_command_4
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+3
        BEQ.N    ??process_parsed_command_5
        CMP      R1,#+4
        BEQ.N    ??process_parsed_command_6
        CMP      R1,#+26
        BEQ.N    ??process_parsed_command_7
        CMP      R1,#+28
        BEQ.N    ??process_parsed_command_8
        CMP      R1,#+29
        BEQ.N    ??process_parsed_command_9
        CMP      R1,#+30
        BEQ.W    ??process_parsed_command_10
        CMP      R1,#+42
        BEQ.W    ??process_parsed_command_11
        CMP      R1,#+90
        BEQ.W    ??process_parsed_command_12
        CMP      R1,#+91
        BEQ.W    ??process_parsed_command_13
        CMP      R1,#+92
        BEQ.W    ??process_parsed_command_14
        B.N      ??process_parsed_command_15
// 12807 
// 12808       // G0, G1
// 12809       case 0:
// 12810       case 1:
// 12811         //#if IS_SCARA
// 12812         if(MACHINETPYE&IS_SCARA)
??process_parsed_command_4:
        LDR.W    R1,??DataTable161_3
        LDRH     R1,[R1, #+36]
        MOV      R2,#+768
        TST      R1,R2
        BEQ.N    ??process_parsed_command_16
// 12813           gcode_G0_G1_SCARA(parser.codenum == 0);
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        LSRS     R0,R0,#+31
          CFI FunCall _Z17gcode_G0_G1_SCARAb
        BL       _Z17gcode_G0_G1_SCARAb
        B.N      ??process_parsed_command_15
// 12814         //#else
// 12815         else
// 12816           gcode_G0_G1();
??process_parsed_command_16:
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
        B.N      ??process_parsed_command_15
// 12817         //#endif
// 12818         break;
// 12819 
// 12820       // G2, G3
// 12821       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
// 12822         case 2: // G2: CW ARC
// 12823         case 3: // G3: CCW ARC
// 12824           gcode_G2_G3(parser.codenum == 2);
??process_parsed_command_5:
        CMP      R0,#+2
        BNE.N    ??process_parsed_command_17
        MOVS     R0,#+1
        B.N      ??process_parsed_command_18
??process_parsed_command_17:
        MOVS     R0,#+0
??process_parsed_command_18:
          CFI FunCall _Z11gcode_G2_G3b
        BL       _Z11gcode_G2_G3b
// 12825           break;
        B.N      ??process_parsed_command_15
// 12826       #endif
// 12827 
// 12828       // G4 Dwell
// 12829       case 4:
// 12830         gcode_G4();
??process_parsed_command_6:
          CFI FunCall _Z8gcode_G4v
        BL       _Z8gcode_G4v
// 12831         break;
        B.N      ??process_parsed_command_15
// 12832 
// 12833       #if ENABLED(BEZIER_CURVE_SUPPORT)
// 12834         case 5: // G5: Cubic B_spline
// 12835           gcode_G5();
// 12836           break;
// 12837       #endif // BEZIER_CURVE_SUPPORT
// 12838 
// 12839       #if ENABLED(FWRETRACT)
// 12840         case 10: // G10: retract
// 12841           gcode_G10();
// 12842           break;
// 12843         case 11: // G11: retract_recover
// 12844           gcode_G11();
// 12845           break;
// 12846       #endif // FWRETRACT
// 12847 
// 12848       #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 12849         case 12:
// 12850           gcode_G12(); // G12: Nozzle Clean
// 12851           break;
// 12852       #endif // NOZZLE_CLEAN_FEATURE
// 12853 
// 12854       #if ENABLED(CNC_WORKSPACE_PLANES)
// 12855         case 17: // G17: Select Plane XY
// 12856           gcode_G17();
// 12857           break;
// 12858         case 18: // G18: Select Plane ZX
// 12859           gcode_G18();
// 12860           break;
// 12861         case 19: // G19: Select Plane YZ
// 12862           gcode_G19();
// 12863           break;
// 12864       #endif // CNC_WORKSPACE_PLANES
// 12865 
// 12866       #if ENABLED(INCH_MODE_SUPPORT)
// 12867         case 20: // G20: Inch Mode
// 12868           gcode_G20();
// 12869           break;
// 12870 
// 12871         case 21: // G21: MM Mode
// 12872           gcode_G21();
// 12873           break;
// 12874       #endif // INCH_MODE_SUPPORT
// 12875 
// 12876       //#if ENABLED(G26_MESH_VALIDATION)
// 12877         case 26: // G26: Mesh Validation Pattern generation
// 12878         if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_parsed_command_7:
        LDR.W    R0,??DataTable161_3
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_15
// 12879           gcode_G26();
          CFI FunCall _Z9gcode_G26v
        BL       _Z9gcode_G26v
        B.N      ??process_parsed_command_15
// 12880           break;
// 12881       //#endif // G26_MESH_VALIDATION
// 12882 
// 12883       #if ENABLED(NOZZLE_PARK_FEATURE)
// 12884         case 27: // G27: Nozzle Park
// 12885           gcode_G27();
// 12886           break;
// 12887       #endif // NOZZLE_PARK_FEATURE
// 12888 
// 12889       case 28: // G28: Home all axes, one at a time
// 12890         #if 1
// 12891       	if (gCfgItems.breakpoint_reprint_flg == 1) break;
??process_parsed_command_8:
        LDR.W    R0,??DataTable160_1
        LDRB     R0,[R0, #+328]
        CMP      R0,#+1
        BEQ.W    ??process_parsed_command_15
// 12892         #endif
// 12893         gcode_G28(false);
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
// 12894 		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
        LDR.W    R0,??DataTable158
        ADD      R5,R0,#+52
        LDRB     R0,[R5, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.W    ??process_parsed_command_15
        CMP      R0,#+16
        BEQ.W    ??process_parsed_command_15
// 12895 		{
// 12896 			 set_bed_leveling_enabled(true);
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 12897 			#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 12898 				if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
        LDRSH    R0,[R5, #+36]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_15
        LDRB     R0,[R5, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_15
// 12899 				 { 
// 12900 				 	if (parser.seenval('Z')) set_z_fade_height(parser.value_linear_units()/*code_value_linear_units()*/);
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+1
          CFI FunCall _Z17set_z_fade_heightfb
        BL       _Z17set_z_fade_heightfb
        B.N      ??process_parsed_command_15
// 12901 				 }
// 12902 			#endif
// 12903           }
// 12904         break;
// 12905 
// 12906       //#if HAS_LEVELING
// 12907         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
// 12908                  // or provides access to the UBL System if enabled.
// 12909 		if(BED_LEVELING_METHOD&HAS_LEVELING)	 
??process_parsed_command_9:
        LDR.W    R0,??DataTable158
        ADD      R5,R0,#+52
        LDRB     R0,[R5, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??process_parsed_command_19
// 12910 		{
// 12911 			switch(BED_LEVELING_METHOD)	 /*--mks cfg-- MESH_BED_LEVELING */ 
        CMP      R0,#+2
        BEQ.N    ??process_parsed_command_20
        CMP      R0,#+4
        BEQ.N    ??process_parsed_command_20
        CMP      R0,#+8
        BEQ.N    ??process_parsed_command_20
        CMP      R0,#+16
        BEQ.N    ??process_parsed_command_21
        CMP      R0,#+32
        BNE.N    ??process_parsed_command_19
// 12912 			{
// 12913 				case MESH_BED_LEVELING:
// 12914 					gcode_G29_MESH_BED_LEVELING();
          CFI FunCall _Z27gcode_G29_MESH_BED_LEVELINGv
        BL       _Z27gcode_G29_MESH_BED_LEVELINGv
// 12915 					(void)settings.save();
          CFI FunCall _ZN14MarlinSettings4saveEv
        BL       _ZN14MarlinSettings4saveEv
// 12916 				break;
        B.N      ??process_parsed_command_15
// 12917 				case AUTO_BED_LEVELING_3POINT:
// 12918 				case AUTO_BED_LEVELING_LINEAR:
// 12919 				case AUTO_BED_LEVELING_BILINEAR:
// 12920 					gcode_G29();
??process_parsed_command_20:
          CFI FunCall _Z9gcode_G29v
        BL       _Z9gcode_G29v
// 12921 					(void)settings.save();
          CFI FunCall _ZN14MarlinSettings4saveEv
        BL       _ZN14MarlinSettings4saveEv
// 12922 				break;
        B.N      ??process_parsed_command_15
// 12923 				case AUTO_BED_LEVELING_UBL:
// 12924 					gcode_G29_UBL();
??process_parsed_command_21:
          CFI FunCall _Z13gcode_G29_UBLv
        BL       _Z13gcode_G29_UBLv
// 12925 				break;
        B.N      ??process_parsed_command_15
// 12926 				default:
// 12927 					SERIAL_PROTOCOL("bed leveling hasn't defined!");
// 12928 					SERIAL_EOL();
// 12929 				break;
// 12930 			}
// 12931 		}
// 12932 		else
// 12933 		{
// 12934 			SERIAL_PROTOCOL("bed leveling hasn't defined!");
??process_parsed_command_19:
        LDR.W    R5,??DataTable161
        LDR.W    R1,??DataTable161_4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
// 12935 			SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??process_parsed_command_15
// 12936 		}
// 12937 
// 12938         break;
// 12939       //#endif // HAS_LEVELING
// 12940 
// 12941       #if HAS_BED_PROBE
// 12942 
// 12943         case 30: // G30 Single Z probe
// 12944           gcode_G30();
??process_parsed_command_10:
          CFI FunCall _Z9gcode_G30v
        BL       _Z9gcode_G30v
// 12945           break;
        B.N      ??process_parsed_command_15
// 12946 
// 12947         #if ENABLED(Z_PROBE_SLED)
// 12948 
// 12949             case 31: // G31: dock the sled
// 12950               gcode_G31();
// 12951               break;
// 12952 
// 12953             case 32: // G32: undock the sled
// 12954               gcode_G32();
// 12955               break;
// 12956 
// 12957         #endif // Z_PROBE_SLED
// 12958 
// 12959       #endif // HAS_BED_PROBE
// 12960 
// 12961       #if ENABLED(DELTA_AUTO_CALIBRATION)
// 12962 
// 12963         case 33: // G33: Delta Auto-Calibration
// 12964           gcode_G33();
// 12965           break;
// 12966 
// 12967       #endif // DELTA_AUTO_CALIBRATION
// 12968 
// 12969       #if ENABLED(G38_PROBE_TARGET)
// 12970         case 38: // G38.2 & G38.3
// 12971           if (parser.subcode == 2 || parser.subcode == 3)
// 12972             gcode_G38(parser.subcode == 2);
// 12973           break;
// 12974       #endif
// 12975 
// 12976       case 90: // G90
// 12977         relative_mode = false;
??process_parsed_command_12:
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
// 12978         break;
        B.N      ??process_parsed_command_15
// 12979       case 91: // G91
// 12980         relative_mode = true;
??process_parsed_command_13:
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
// 12981         break;
        B.N      ??process_parsed_command_15
// 12982 
// 12983       case 92: // G92
// 12984         gcode_G92();
??process_parsed_command_14:
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
// 12985         break;
        B.N      ??process_parsed_command_15
// 12986 
// 12987       #if HAS_MESH
// 12988         case 42:
// 12989           gcode_G42();
??process_parsed_command_11:
          CFI FunCall _Z9gcode_G42v
        BL       _Z9gcode_G42v
// 12990           break;
        B.N      ??process_parsed_command_15
// 12991       #endif
// 12992 
// 12993       #if ENABLED(DEBUG_GCODE_PARSER)
// 12994         case 800:
// 12995           parser.debug(); // GCode Parser Test for G
// 12996           break;
// 12997       #endif
// 12998     }
// 12999     break;
// 13000 
// 13001     case 'M': switch (parser.codenum) {
??process_parsed_command_1:
        LDR.W    R0,??DataTable161_2
        LDR      R0,[R0, #+0]
        SUBS     R0,R0,#+17
        BEQ.W    ??process_parsed_command_22
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_23
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_24
        SUBS     R0,R0,#+1
        CMP      R0,#+1
        BLS.W    ??process_parsed_command_25
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_26
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_27
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_28
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_29
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_30
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_31
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_32
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_33
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_34
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_35
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_36
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_37
        SUBS     R0,R0,#+26
        BEQ.W    ??process_parsed_command_38
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_39
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_40
        SUBS     R0,R0,#+4
        BEQ.W    ??process_parsed_command_41
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_42
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_43
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_23
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_44
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_45
        SUBS     R0,R0,#+12
        BEQ.W    ??process_parsed_command_46
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_47
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_48
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_49
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_50
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_51
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_52
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_53
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_54
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_55
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_56
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_57
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_58
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_59
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_60
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_61
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_62
        SUBS     R0,R0,#+19
        BEQ.W    ??process_parsed_command_63
        SUBS     R0,R0,#+15
        BEQ.W    ??process_parsed_command_64
        SUBS     R0,R0,#+35
        BEQ.W    ??process_parsed_command_65
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_66
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_67
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_68
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_69
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_70
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_71
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_72
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_73
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_74
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_75
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_76
        SUBS     R0,R0,#+54
        BEQ.W    ??process_parsed_command_77
        SUBS     R0,R0,#+21
        BEQ.W    ??process_parsed_command_78
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_79
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_80
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_81
        SUBS     R0,R0,#+51
        BEQ.W    ??process_parsed_command_82
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_83
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_84
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_85
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_86
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_87
        SUBS     R0,R0,#+36
        BEQ.W    ??process_parsed_command_88
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_89
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_90
        SUBS     R0,R0,#+8
        BEQ.W    ??process_parsed_command_91
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_92
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_93
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_94
        SUBS     R0,R0,#+72
        BEQ.W    ??process_parsed_command_95
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_96
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_97
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_98
        SUBS     R0,R0,#+162
        BEQ.W    ??process_parsed_command_99
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_100
        SUBS     R0,R0,#+185
        BEQ.W    ??process_parsed_command_101
        SUBS     R0,R0,#+56
        BEQ.W    ??process_parsed_command_102
        SUBS     R0,R0,#+21
        BEQ.N    ??process_parsed_command_103
        SUBS     R0,R0,#+70
        BEQ.N    ??process_parsed_command_104
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_105
        B.N      ??process_parsed_command_15
// 13002       #if HAS_RESUME_CONTINUE
// 13003         case 0: // M0: Unconditional stop - Wait for user button press on LCD
// 13004         case 1: // M1: Conditional stop - Wait for user button press on LCD
// 13005           gcode_M0_M1();
// 13006           break;
// 13007       #endif // ULTIPANEL
// 13008 
// 13009       #if ENABLED(SPINDLE_LASER_ENABLE)
// 13010         case 3:
// 13011           gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
// 13012           break;               // synchronizes with movement commands
// 13013         case 4:
// 13014           gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
// 13015           break;               // synchronizes with movement commands
// 13016         case 5:
// 13017           gcode_M5();     // M5 - turn spindle/laser off
// 13018           break;          // synchronizes with movement commands
// 13019       #endif
// 13020       case 17: // M17: Enable all stepper motors
// 13021         gcode_M17();
??process_parsed_command_22:
          CFI FunCall _Z9gcode_M17v
        BL       _Z9gcode_M17v
// 13022         break;
        B.N      ??process_parsed_command_15
// 13023 
// 13024       #if ENABLED(SDSUPPORT)
// 13025         case 20: // M20: list SD card
// 13026           gcode_M20(); break;
??process_parsed_command_24:
          CFI FunCall _Z9gcode_M20v
        BL       _Z9gcode_M20v
        B.N      ??process_parsed_command_15
// 13027         case 21: // M21: init SD card
// 13028           //gcode_M21(); break;
// 13029         case 22: // M22: release SD card
// 13030           gcode_M22(); break;
??process_parsed_command_25:
          CFI FunCall _Z9gcode_M22v
        BL       _Z9gcode_M22v
        B.N      ??process_parsed_command_15
// 13031         case 23: // M23: Select file
// 13032           gcode_M23(); break;
??process_parsed_command_26:
          CFI FunCall _Z9gcode_M23v
        BL       _Z9gcode_M23v
        B.N      ??process_parsed_command_15
// 13033         case 24: // M24: Start SD print
// 13034           gcode_M24(); 
??process_parsed_command_27:
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
// 13035 
// 13036           if(mksReprint.mks_printer_state == MKS_WORKING)
        LDR.W    R0,??DataTable163
        LDRB     R0,[R0, #+2720]
        CMP      R0,#+167
        BNE.W    ??process_parsed_command_15
// 13037           {
// 13038             clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 13039             reset_file_info();
          CFI FunCall reset_file_info
        BL       reset_file_info
// 13040             reset_print_time();
          CFI FunCall reset_print_time
        BL       reset_print_time
// 13041             start_print_time();
          CFI FunCall start_print_time
        BL       start_print_time
// 13042             #if defined(TFT35)
// 13043             preview_gcode_prehandle(curFileName);
        LDR.W    R0,??DataTable163_1
          CFI FunCall preview_gcode_prehandle
        BL       preview_gcode_prehandle
// 13044             #endif
// 13045             draw_printing();            
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_15
// 13046            }
// 13047           break;
// 13048         case 25: // M25: Pause SD print
// 13049             gcode_M25(); 
??process_parsed_command_28:
          CFI FunCall _Z9gcode_M25v
        BL       _Z9gcode_M25v
// 13050             if(mksReprint.mks_printer_state == MKS_PAUSING)
        LDR.W    R5,??DataTable163
        LDRB     R0,[R5, #+2720]
        CMP      R0,#+169
        BNE.W    ??process_parsed_command_15
// 13051             {
// 13052             	stop_print_time();							
          CFI FunCall stop_print_time
        BL       stop_print_time
// 13053             	clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 13054             
// 13055             	card.pauseSDPrint();
        MOV      R0,R5
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
// 13056             	print_job_timer.pause();
        ADDW     R0,R5,#+3436
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
// 13057 		#if defined(TFT35)
// 13058             	if(from_flash_pic==1)
        LDR.W    R0,??DataTable163_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??process_parsed_command_106
// 13059             		flash_preview_begin = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable163_3
        STRB     R0,[R1, #+0]
        B.N      ??process_parsed_command_107
// 13060             	else
// 13061             		default_preview_flg = 1;							
??process_parsed_command_106:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable163_4
        STRB     R0,[R1, #+0]
// 13062 
// 13063             	draw_printing();
??process_parsed_command_107:
          CFI FunCall draw_printing
        BL       draw_printing
        B.N      ??process_parsed_command_15
// 13064                #else
// 13065                draw_pause();
// 13066 		#endif
// 13067             }          
// 13068           break;
// 13069         case 998:	//M998: Stop SD print
// 13070           gcode_M998(); break;			  
??process_parsed_command_104:
          CFI FunCall _Z10gcode_M998v
        BL       _Z10gcode_M998v
        B.N      ??process_parsed_command_15
// 13071         case 26: // M26: Set SD index
// 13072           gcode_M26(); break;
??process_parsed_command_29:
          CFI FunCall _Z9gcode_M26v
        BL       _Z9gcode_M26v
        B.N      ??process_parsed_command_15
// 13073         case 27: // M27: Get SD status
// 13074           gcode_M27(); break;
??process_parsed_command_30:
          CFI FunCall _Z9gcode_M27v
        BL       _Z9gcode_M27v
        B.N      ??process_parsed_command_15
// 13075         case 28: // M28: Start SD write
// 13076           gcode_M28(); break;
??process_parsed_command_31:
          CFI FunCall _Z9gcode_M28v
        BL       _Z9gcode_M28v
        B.N      ??process_parsed_command_15
// 13077         case 29: // M29: Stop SD write
// 13078           gcode_M29(); break;
??process_parsed_command_32:
          CFI FunCall _Z9gcode_M29v
        BL       _Z9gcode_M29v
        B.N      ??process_parsed_command_15
// 13079         case 30: // M30 <filename> Delete File
// 13080           gcode_M30(); break;
??process_parsed_command_33:
          CFI FunCall _Z9gcode_M30v
        BL       _Z9gcode_M30v
        B.N      ??process_parsed_command_15
// 13081         case 32: // M32: Select file and start SD print
// 13082           gcode_M32(); break;
??process_parsed_command_35:
          CFI FunCall _Z9gcode_M32v
        BL       _Z9gcode_M32v
        B.N      ??process_parsed_command_15
// 13083 
// 13084         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 13085           case 33: // M33: Get the long full path to a file or folder
// 13086             gcode_M33(); break;
// 13087         #endif
// 13088 
// 13089         #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 13090           case 34: // M34: Set SD card sorting options
// 13091             gcode_M34(); break;
// 13092         #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 13093 
// 13094         case 928: // M928: Start SD write
// 13095           gcode_M928(); break;
??process_parsed_command_103:
          CFI FunCall _Z10gcode_M928v
        BL       _Z10gcode_M928v
        B.N      ??process_parsed_command_15
// 13096       #endif // SDSUPPORT
// 13097 
// 13098       case 31: // M31: Report time since the start of SD print or last M109
// 13099         gcode_M31(); break;
??process_parsed_command_34:
          CFI FunCall _Z9gcode_M31v
        BL       _Z9gcode_M31v
        B.N      ??process_parsed_command_15
// 13100 
// 13101       case 42: // M42: Change pin state
// 13102         gcode_M42(); break;
??process_parsed_command_36:
          CFI FunCall _Z9gcode_M42v
        BL       _Z9gcode_M42v
        B.N      ??process_parsed_command_15
// 13103 
// 13104       #if ENABLED(PINS_DEBUGGING)
// 13105         case 43: // M43: Read pin state
// 13106           gcode_M43(); break;
// 13107       #endif
// 13108 
// 13109 
// 13110       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 13111         case 48: // M48: Z probe repeatability test
// 13112           gcode_M48();
// 13113           break;
// 13114       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 13115 
// 13116       //#if ENABLED(G26_MESH_VALIDATION)
// 13117         case 49: // M49: Turn on or off G26 debug flag for verbose output
// 13118         if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_parsed_command_37:
        LDR.W    R0,??DataTable161_3
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_15
// 13119           gcode_M49();
          CFI FunCall _Z9gcode_M49v
        BL       _Z9gcode_M49v
        B.N      ??process_parsed_command_15
// 13120           break;
// 13121       //#endif // G26_MESH_VALIDATION
// 13122 
// 13123       #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 13124         case 73: // M73: Set print progress percentage
// 13125           gcode_M73(); break;
// 13126       #endif
// 13127 
// 13128       case 75: // M75: Start print timer
// 13129         gcode_M75(); break;
??process_parsed_command_38:
          CFI FunCall _Z9gcode_M75v
        BL       _Z9gcode_M75v
        B.N      ??process_parsed_command_15
// 13130       case 76: // M76: Pause print timer
// 13131         gcode_M76(); break;
??process_parsed_command_39:
          CFI FunCall _Z9gcode_M76v
        BL       _Z9gcode_M76v
        B.N      ??process_parsed_command_15
// 13132       case 77: // M77: Stop print timer
// 13133         gcode_M77(); break;
??process_parsed_command_40:
          CFI FunCall _Z9gcode_M77v
        BL       _Z9gcode_M77v
        B.N      ??process_parsed_command_15
// 13134 
// 13135       #if ENABLED(PRINTCOUNTER)
// 13136         case 78: // M78: Show print statistics
// 13137           gcode_M78(); break;
// 13138       #endif
// 13139 
// 13140       #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13141         case 100: // M100: Free Memory Report
// 13142           gcode_M100();
// 13143           break;
// 13144       #endif
// 13145 
// 13146       case 104: // M104: Set hot end temperature
// 13147         gcode_M104();
??process_parsed_command_46:
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
// 13148         break;
        B.N      ??process_parsed_command_15
// 13149 
// 13150       case 110: // M110: Set Current Line Number
// 13151         gcode_M110();
??process_parsed_command_52:
          CFI FunCall _Z10gcode_M110v
        BL       _Z10gcode_M110v
// 13152         break;
        B.N      ??process_parsed_command_15
// 13153 
// 13154       case 111: // M111: Set debug level
// 13155         gcode_M111();
??process_parsed_command_53:
          CFI FunCall _Z10gcode_M111v
        BL       _Z10gcode_M111v
// 13156         break;
        B.N      ??process_parsed_command_15
// 13157 
// 13158       #if DISABLED(EMERGENCY_PARSER)
// 13159 
// 13160         case 108: // M108: Cancel Waiting
// 13161           gcode_M108();
??process_parsed_command_50:
          CFI FunCall _Z10gcode_M108v
        BL       _Z10gcode_M108v
// 13162           break;
        B.N      ??process_parsed_command_15
// 13163 
// 13164         case 112: // M112: Emergency Stop
// 13165           gcode_M112();
??process_parsed_command_54:
          CFI FunCall _Z10gcode_M112v
        BL       _Z10gcode_M112v
// 13166           break;
        B.N      ??process_parsed_command_15
// 13167 
// 13168         case 410: // M410 quickstop - Abort all the planned moves.
// 13169           gcode_M410();
??process_parsed_command_91:
          CFI FunCall _Z10gcode_M410v
        BL       _Z10gcode_M410v
// 13170           break;
        B.N      ??process_parsed_command_15
// 13171 
// 13172       #endif
// 13173 
// 13174       #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 13175         case 113: // M113: Set Host Keepalive interval
// 13176           gcode_M113();
??process_parsed_command_55:
          CFI FunCall _Z10gcode_M113v
        BL       _Z10gcode_M113v
// 13177           break;
        B.N      ??process_parsed_command_15
// 13178       #endif
// 13179 
// 13180       case 140: // M140: Set bed temperature
// 13181       if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
??process_parsed_command_63:
        LDR.W    R0,??DataTable161_3
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_108
// 13182         gcode_M140();
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
        B.N      ??process_parsed_command_15
// 13183         else
// 13184           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 	  
??process_parsed_command_108:
        ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_parsed_command_15
// 13185         break;
// 13186 
// 13187       case 105: // M105: Report current temperature
// 13188         gcode_M105();
??process_parsed_command_47:
          CFI FunCall _Z10gcode_M105v
        BL       _Z10gcode_M105v
// 13189         KEEPALIVE_STATE(NOT_BUSY);
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 13190         return; // "ok" already printed
        POP      {R0,R4,R5,PC}
// 13191 
// 13192      // #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 13193      #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
// 13194         case 155: // M155: Set temperature auto-report interval
// 13195           gcode_M155();
??process_parsed_command_64:
          CFI FunCall _Z10gcode_M155v
        BL       _Z10gcode_M155v
// 13196           break;
        B.N      ??process_parsed_command_15
// 13197       #endif
// 13198 
// 13199       case 109: // M109: Wait for hotend temperature to reach target
// 13200         gcode_M109();
??process_parsed_command_51:
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
// 13201         break;
        B.N      ??process_parsed_command_15
// 13202 
// 13203       //#if HAS_TEMP_BED
// 13204         case 190: // M190: Wait for bed temperature to reach target
// 13205         if(HAS_TEMP_BED) 
??process_parsed_command_65:
        LDR.W    R0,??DataTable161_3
        LDRB     R0,[R0, #+2]
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_109
// 13206           gcode_M190();
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
        B.N      ??process_parsed_command_15
// 13207 		else
// 13208           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
??process_parsed_command_109:
        ADR.W    R0,`?<Constant "HAS_NO_TEMP_BED!\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_parsed_command_15
// 13209           break;
// 13210       //#endif // HAS_TEMP_BED
// 13211 
// 13212       #if FAN_COUNT > 0
// 13213         case 106: // M106: Fan On
// 13214           gcode_M106();
??process_parsed_command_48:
          CFI FunCall _Z10gcode_M106v
        BL       _Z10gcode_M106v
// 13215           break;
        B.N      ??process_parsed_command_15
// 13216         case 107: // M107: Fan Off
// 13217           gcode_M107();
??process_parsed_command_49:
          CFI FunCall _Z10gcode_M107v
        BL       _Z10gcode_M107v
// 13218           break;
        B.N      ??process_parsed_command_15
// 13219       #endif // FAN_COUNT > 0
// 13220 
// 13221       #if ENABLED(PARK_HEAD_ON_PAUSE)
// 13222         case 125: // M125: Store current position and move to filament change position
// 13223           gcode_M125(); break;
// 13224       #endif
// 13225 
// 13226       #if ENABLED(BARICUDA)
// 13227         // PWM for HEATER_1_PIN
// 13228         #if HAS_HEATER_1
// 13229           case 126: // M126: valve open
// 13230             gcode_M126();
// 13231             break;
// 13232           case 127: // M127: valve closed
// 13233             gcode_M127();
// 13234             break;
// 13235         #endif // HAS_HEATER_1
// 13236 
// 13237         // PWM for HEATER_2_PIN
// 13238         #if HAS_HEATER_2
// 13239           case 128: // M128: valve open
// 13240             gcode_M128();
// 13241             break;
// 13242           case 129: // M129: valve closed
// 13243             gcode_M129();
// 13244             break;
// 13245         #endif // HAS_HEATER_2
// 13246       #endif // BARICUDA
// 13247 
// 13248       #if HAS_POWER_SWITCH
// 13249 
// 13250         case 80: // M80: Turn on Power Supply
// 13251           gcode_M80();
// 13252           break;
// 13253 
// 13254       #endif // HAS_POWER_SWITCH
// 13255 
// 13256       case 81: // M81: Turn off Power, including Power Supply, if possible
// 13257         gcode_M81();
??process_parsed_command_41:
          CFI FunCall _Z9gcode_M81v
        BL       _Z9gcode_M81v
// 13258         break;
        B.N      ??process_parsed_command_15
// 13259 
// 13260       case 82: // M82: Set E axis normal mode (same as other axes)
// 13261         gcode_M82();
??process_parsed_command_42:
          CFI FunCall _Z9gcode_M82v
        BL       _Z9gcode_M82v
// 13262         break;
        B.N      ??process_parsed_command_15
// 13263       case 83: // M83: Set E axis relative mode
// 13264         gcode_M83();
??process_parsed_command_43:
          CFI FunCall _Z9gcode_M83v
        BL       _Z9gcode_M83v
// 13265         break;
        B.N      ??process_parsed_command_15
// 13266       case 18: // M18 => M84
// 13267       case 84: // M84: Disable all steppers or set timeout
// 13268         gcode_M18_M84();
??process_parsed_command_23:
          CFI FunCall _Z13gcode_M18_M84v
        BL       _Z13gcode_M18_M84v
// 13269         break;
        B.N      ??process_parsed_command_15
// 13270       case 85: // M85: Set inactivity stepper shutdown timeout
// 13271         gcode_M85();
??process_parsed_command_44:
          CFI FunCall _Z9gcode_M85v
        BL       _Z9gcode_M85v
// 13272         break;
        B.N      ??process_parsed_command_15
// 13273       case 92: // M92: Set the steps-per-unit for one or more axes
// 13274         gcode_M92();
??process_parsed_command_45:
          CFI FunCall _Z9gcode_M92v
        BL       _Z9gcode_M92v
// 13275         break;
        B.N      ??process_parsed_command_15
// 13276       case 114: // M114: Report current position
// 13277         gcode_M114();
??process_parsed_command_56:
          CFI FunCall _Z10gcode_M114v
        BL       _Z10gcode_M114v
// 13278         break;
        B.N      ??process_parsed_command_15
// 13279       case 115: // M115: Report capabilities
// 13280         gcode_M115();
??process_parsed_command_57:
          CFI FunCall _Z10gcode_M115v
        BL       _Z10gcode_M115v
// 13281         break;
        B.N      ??process_parsed_command_15
// 13282       case 117: // M117: Set LCD message text, if possible
// 13283         gcode_M117();
??process_parsed_command_58:
          CFI FunCall _Z10gcode_M117v
        BL       _Z10gcode_M117v
// 13284         break;
        B.N      ??process_parsed_command_15
// 13285       case 118: // M118: Display a message in the host console
// 13286         gcode_M118();
??process_parsed_command_59:
          CFI FunCall _Z10gcode_M118v
        BL       _Z10gcode_M118v
// 13287         break;
        B.N      ??process_parsed_command_15
// 13288       case 119: // M119: Report endstop states
// 13289         gcode_M119();
??process_parsed_command_60:
          CFI FunCall _Z10gcode_M119v
        BL       _Z10gcode_M119v
// 13290         break;
        B.N      ??process_parsed_command_15
// 13291       case 120: // M120: Enable endstops
// 13292         gcode_M120();
??process_parsed_command_61:
          CFI FunCall _Z10gcode_M120v
        BL       _Z10gcode_M120v
// 13293         break;
        B.N      ??process_parsed_command_15
// 13294       case 121: // M121: Disable endstops
// 13295         gcode_M121();
??process_parsed_command_62:
          CFI FunCall _Z10gcode_M121v
        BL       _Z10gcode_M121v
// 13296         break;
        B.N      ??process_parsed_command_15
// 13297 
// 13298       #if ENABLED(ULTIPANEL)
// 13299 
// 13300         case 145: // M145: Set material heatup parameters
// 13301           gcode_M145();
// 13302           break;
// 13303 
// 13304       #endif
// 13305 
// 13306       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 13307         case 149: // M149: Set temperature units
// 13308           gcode_M149();
// 13309           break;
// 13310       #endif
// 13311 
// 13312       #if HAS_COLOR_LEDS
// 13313 
// 13314         case 150: // M150: Set Status LED Color
// 13315           gcode_M150();
// 13316           break;
// 13317 
// 13318       #endif // HAS_COLOR_LEDS
// 13319 
// 13320       #if ENABLED(MIXING_EXTRUDER)
// 13321         case 163: // M163: Set a component weight for mixing extruder
// 13322           gcode_M163();
// 13323           break;
// 13324         #if MIXING_VIRTUAL_TOOLS > 1
// 13325           case 164: // M164: Save current mix as a virtual extruder
// 13326             gcode_M164();
// 13327             break;
// 13328         #endif
// 13329         #if ENABLED(DIRECT_MIXING_IN_G1)
// 13330           case 165: // M165: Set multiple mix weights
// 13331             gcode_M165();
// 13332             break;
// 13333         #endif
// 13334       #endif
// 13335 
// 13336       #if DISABLED(NO_VOLUMETRICS)
// 13337         case 200: // M200: Set filament diameter, E to cubic units
// 13338           gcode_M200();
??process_parsed_command_66:
          CFI FunCall _Z10gcode_M200v
        BL       _Z10gcode_M200v
// 13339           break;
        B.N      ??process_parsed_command_15
// 13340       #endif
// 13341 
// 13342       case 201: // M201: Set max acceleration for print moves (units/s^2)
// 13343         gcode_M201();
??process_parsed_command_67:
          CFI FunCall _Z10gcode_M201v
        BL       _Z10gcode_M201v
// 13344         break;
        B.N      ??process_parsed_command_15
// 13345       #if 0 // Not used for Sprinter/grbl gen6
// 13346         case 202: // M202
// 13347           gcode_M202();
// 13348           break;
// 13349       #endif
// 13350       case 203: // M203: Set max feedrate (units/sec)
// 13351         gcode_M203();
??process_parsed_command_68:
          CFI FunCall _Z10gcode_M203v
        BL       _Z10gcode_M203v
// 13352         break;
        B.N      ??process_parsed_command_15
// 13353       case 204: // M204: Set acceleration
// 13354         gcode_M204();
??process_parsed_command_69:
          CFI FunCall _Z10gcode_M204v
        BL       _Z10gcode_M204v
// 13355         break;
        B.N      ??process_parsed_command_15
// 13356       case 205: // M205: Set advanced settings
// 13357         gcode_M205();
??process_parsed_command_70:
          CFI FunCall _Z10gcode_M205v
        BL       _Z10gcode_M205v
// 13358         break;
        B.N      ??process_parsed_command_15
// 13359 
// 13360       //#if HAS_M206_COMMAND
// 13361         case 206: // M206: Set home offsets
// 13362         if(MACHINETPYE != DELTA)
??process_parsed_command_71:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_15
// 13363           gcode_M206();
          CFI FunCall _Z10gcode_M206v
        BL       _Z10gcode_M206v
        B.N      ??process_parsed_command_15
// 13364           break;
// 13365       //#endif
// 13366 
// 13367       //#if ENABLED(DELTA)
// 13368         case 665: // M665: Set delta configurations
// 13369         if(MACHINETPYE == DELTA)
??process_parsed_command_99:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BNE.W    ??process_parsed_command_15
// 13370           gcode_M665();
          CFI FunCall _Z10gcode_M665v
        BL       _Z10gcode_M665v
        B.N      ??process_parsed_command_15
// 13371           break;
// 13372       //#endif
// 13373 
// 13374       //#if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 13375         case 666: // M666: Set delta or dual endstop adjustment
// 13376         if(MACHINETPYE == DELTA)
??process_parsed_command_100:
        LDR.N    R0,??DataTable158
        ADD      R1,R0,#+52
        LDRSH    R1,[R1, #+36]
        CMP      R1,#+2
        BNE.N    ??process_parsed_command_110
// 13377           gcode_M666();
          CFI FunCall _Z10gcode_M666v
        BL       _Z10gcode_M666v
        B.N      ??process_parsed_command_15
// 13378         else if(Z_DUAL_ENDSTOPS==1)
??process_parsed_command_110:
        LDRB     R0,[R0, #+258]
        CMP      R0,#+1
        BNE.W    ??process_parsed_command_15
// 13379         {
// 13380           gcode_M666_dual();  
          CFI FunCall _Z15gcode_M666_dualv
        BL       _Z15gcode_M666_dualv
        B.N      ??process_parsed_command_15
// 13381         }
// 13382           break;
// 13383       //#endif
// 13384 
// 13385       #if ENABLED(FWRETRACT)
// 13386         case 207: // M207: Set Retract Length, Feedrate, and Z lift
// 13387           gcode_M207();
// 13388           break;
// 13389         case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
// 13390           gcode_M208();
// 13391           break;
// 13392         case 209: // M209: Turn Automatic Retract Detection on/off
// 13393           if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
// 13394           break;
// 13395       #endif // FWRETRACT
// 13396 
// 13397       case 211: // M211: Enable, Disable, and/or Report software endstops
// 13398         gcode_M211();
??process_parsed_command_72:
          CFI FunCall _Z10gcode_M211v
        BL       _Z10gcode_M211v
// 13399         break;
        B.N      ??process_parsed_command_15
// 13400 
// 13401       #if HOTENDS > 1
// 13402         case 218: // M218: Set a tool offset
// 13403           gcode_M218();
??process_parsed_command_73:
          CFI FunCall _Z10gcode_M218v
        BL       _Z10gcode_M218v
// 13404           break;
        B.N      ??process_parsed_command_15
// 13405       #endif // HOTENDS > 1
// 13406 
// 13407       case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
// 13408         gcode_M220();
??process_parsed_command_74:
          CFI FunCall _Z10gcode_M220v
        BL       _Z10gcode_M220v
// 13409         break;
        B.N      ??process_parsed_command_15
// 13410 
// 13411       case 221: // M221: Set Flow Percentage
// 13412         gcode_M221();
??process_parsed_command_75:
          CFI FunCall _Z10gcode_M221v
        BL       _Z10gcode_M221v
// 13413         break;
        B.N      ??process_parsed_command_15
// 13414 
// 13415       case 226: // M226: Wait until a pin reaches a state
// 13416         gcode_M226();
??process_parsed_command_76:
          CFI FunCall _Z10gcode_M226v
        BL       _Z10gcode_M226v
// 13417         break;
        B.N      ??process_parsed_command_15
// 13418 
// 13419       //#if HAS_SERVOS
// 13420         case 280: // M280: Set servo position absolute
// 13421           gcode_M280();
??process_parsed_command_77:
          CFI FunCall _Z10gcode_M280v
        BL       _Z10gcode_M280v
// 13422           break;
        B.N      ??process_parsed_command_15
// 13423       //#endif // HAS_SERVOS
// 13424 
// 13425       #if ENABLED(BABYSTEPPING)
// 13426         case 290: // M290: Babystepping
// 13427           gcode_M290();
// 13428           break;
// 13429       #endif // BABYSTEPPING
// 13430 
// 13431       #if HAS_BUZZER
// 13432         case 300: // M300: Play beep tone
// 13433           gcode_M300();
// 13434           break;
// 13435       #endif // HAS_BUZZER
// 13436 
// 13437       //#if ENABLED(PIDTEMP)
// 13438         case 301: // M301: Set hotend PID parameters
// 13439         if(PIDTEMP) 
??process_parsed_command_78:
        LDR.N    R0,??DataTable158
        LDRB     R0,[R0, #+52]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
// 13440           gcode_M301();
          CFI FunCall _Z10gcode_M301v
        BL       _Z10gcode_M301v
        B.N      ??process_parsed_command_15
// 13441           break;
// 13442       //#endif // PIDTEMP
// 13443 
// 13444       //#if ENABLED(PIDTEMPBED)
// 13445         case 304: // M304: Set bed PID parameters
// 13446         if(PIDTEMPBED) 
??process_parsed_command_81:
        LDR.W    R0,??DataTable161_3
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
// 13447           gcode_M304();
          CFI FunCall _Z10gcode_M304v
        BL       _Z10gcode_M304v
        B.N      ??process_parsed_command_15
// 13448           break;
// 13449       //#endif // PIDTEMPBED
// 13450 
// 13451       #if defined(CHDK) || HAS_PHOTOGRAPH
// 13452         case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
// 13453           gcode_M240();
// 13454           break;
// 13455       #endif // CHDK || PHOTOGRAPH_PIN
// 13456 
// 13457       #if HAS_LCD_CONTRAST
// 13458         case 250: // M250: Set LCD contrast
// 13459           gcode_M250();
// 13460           break;
// 13461       #endif // HAS_LCD_CONTRAST
// 13462 
// 13463       #if ENABLED(EXPERIMENTAL_I2CBUS)
// 13464 
// 13465         case 260: // M260: Send data to an i2c slave
// 13466           gcode_M260();
// 13467           break;
// 13468 
// 13469         case 261: // M261: Request data from an i2c slave
// 13470           gcode_M261();
// 13471           break;
// 13472 
// 13473       #endif // EXPERIMENTAL_I2CBUS
// 13474 
// 13475       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 13476         case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
// 13477           gcode_M302();
??process_parsed_command_79:
          CFI FunCall _Z10gcode_M302v
        BL       _Z10gcode_M302v
// 13478           break;
        B.N      ??process_parsed_command_15
// 13479       #endif // PREVENT_COLD_EXTRUSION
// 13480 
// 13481       case 303: // M303: PID autotune
// 13482         gcode_M303();
??process_parsed_command_80:
          CFI FunCall _Z10gcode_M303v
        BL       _Z10gcode_M303v
// 13483         break;
        B.N      ??process_parsed_command_15
// 13484 
// 13485       //#if ENABLED(MORGAN_SCARA)
// 13486         case 360:  // M360: SCARA Theta pos1
// 13487         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_83:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_15
// 13488           if (gcode_M360()) return;
          CFI FunCall _Z10gcode_M360v
        BL       _Z10gcode_M360v
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13489           break;
// 13490         case 361:  // M361: SCARA Theta pos2
// 13491         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_84:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13492           if (gcode_M361()) return;
          CFI FunCall _Z10gcode_M361v
        BL       _Z10gcode_M361v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13493           break;
// 13494         case 362:  // M362: SCARA Psi pos1
// 13495         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_85:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13496           if (gcode_M362()) return;
          CFI FunCall _Z10gcode_M362v
        BL       _Z10gcode_M362v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13497           break;
// 13498         case 363:  // M363: SCARA Psi pos2
// 13499         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_86:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13500           if (gcode_M363()) return;
          CFI FunCall _Z10gcode_M363v
        BL       _Z10gcode_M363v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13501           break;
// 13502         case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
// 13503         if(MACHINETPYE == MORGAN_SCARA)
??process_parsed_command_87:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_15
// 13504           if (gcode_M364()) return;
          CFI FunCall _Z10gcode_M364v
        BL       _Z10gcode_M364v
        CMP      R0,#+0
        BEQ.N    ??process_parsed_command_15
        POP      {R0,R4,R5,PC}
// 13505           break;
// 13506       //#endif // SCARA
// 13507 
// 13508       case 400: // M400: Finish all moves
// 13509         gcode_M400();
??process_parsed_command_88:
          CFI FunCall _Z10gcode_M400v
        BL       _Z10gcode_M400v
// 13510         break;
        B.N      ??process_parsed_command_15
// 13511 
// 13512       #if HAS_BED_PROBE
// 13513         case 401: // M401: Deploy probe
// 13514           gcode_M401();
??process_parsed_command_89:
          CFI FunCall _Z10gcode_M401v
        BL       _Z10gcode_M401v
// 13515           break;
        B.N      ??process_parsed_command_15
// 13516         case 402: // M402: Stow probe
// 13517           gcode_M402();
??process_parsed_command_90:
          CFI FunCall _Z10gcode_M402v
        BL       _Z10gcode_M402v
// 13518           break;
        B.N      ??process_parsed_command_15
// 13519       #endif // HAS_BED_PROBE
// 13520 
// 13521       #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 13522         case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
// 13523           gcode_M404();
// 13524           break;
// 13525         case 405:  // M405: Turn on filament sensor for control
// 13526           gcode_M405();
// 13527           break;
// 13528         case 406:  // M406: Turn off filament sensor for control
// 13529           gcode_M406();
// 13530           break;
// 13531         case 407:   // M407: Display measured filament diameter
// 13532           gcode_M407();
// 13533           break;
// 13534       #endif // FILAMENT_WIDTH_SENSOR
// 13535 
// 13536       //#if HAS_LEVELING
// 13537         case 420: // M420: Enable/Disable Bed Leveling
// 13538         if(BED_LEVELING_METHOD&HAS_LEVELING)
??process_parsed_command_92:
        LDR.W    R0,??DataTable161_3
        LDRB     R0,[R0, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??process_parsed_command_15
// 13539           gcode_M420();
          CFI FunCall _Z10gcode_M420v
        BL       _Z10gcode_M420v
        B.N      ??process_parsed_command_15
// 13540           break;
// 13541       //#endif
// 13542 
// 13543       //#if HAS_MESH
// 13544         case 421: // M421: Set a Mesh Bed Leveling Z coordinate
// 13545           if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
??process_parsed_command_93:
        LDR.N    R0,??DataTable158
        ADD      R5,R0,#+52
        LDRB     R0,[R5, #+12]
        LSLS     R1,R0,#+26
        BPL.N    ??process_parsed_command_111
// 13546           	gcode_M421_MESH_BED_LEVELING();
          CFI FunCall _Z28gcode_M421_MESH_BED_LEVELINGv
        BL       _Z28gcode_M421_MESH_BED_LEVELINGv
        B.N      ??process_parsed_command_15
// 13547 		  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
??process_parsed_command_111:
        LSLS     R1,R0,#+28
        BPL.N    ??process_parsed_command_112
// 13548           	gcode_M421_AUTO_BED_LEVELING_BILINEAR();
          CFI FunCall _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        BL       _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        B.N      ??process_parsed_command_15
// 13549           else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
??process_parsed_command_112:
        LSLS     R0,R0,#+27
        BPL.N    ??process_parsed_command_15
// 13550             gcode_M421_AUTO_BED_LEVELING_UBL();
          CFI FunCall _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        BL       _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        B.N      ??process_parsed_command_15
// 13551           break;
// 13552       //#endif
// 13553 
// 13554       //#if HAS_M206_COMMAND
// 13555         case 428: // M428: Apply current_position to home_offset
// 13556         if(MACHINETPYE != DELTA)
??process_parsed_command_94:
        LDR.W    R0,??DataTable161_3
        LDRSH    R0,[R0, #+36]
        CMP      R0,#+2
        BEQ.N    ??process_parsed_command_15
// 13557           gcode_M428();
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
        B.N      ??process_parsed_command_15
// 13558           break;
// 13559       //#endif
// 13560 
// 13561       case 500: // M500: Store settings in EEPROM
// 13562         gcode_M500();
??process_parsed_command_95:
          CFI FunCall _Z10gcode_M500v
        BL       _Z10gcode_M500v
// 13563         break;
        B.N      ??process_parsed_command_15
// 13564       case 501: // M501: Read settings from EEPROM
// 13565         gcode_M501();
??process_parsed_command_96:
          CFI FunCall _Z10gcode_M501v
        BL       _Z10gcode_M501v
// 13566         break;
        B.N      ??process_parsed_command_15
// 13567       case 502: // M502: Revert to default settings
// 13568         gcode_M502();
??process_parsed_command_97:
          CFI FunCall _Z10gcode_M502v
        BL       _Z10gcode_M502v
// 13569         break;
        B.N      ??process_parsed_command_15
// 13570 
// 13571       #if DISABLED(DISABLE_M503)
// 13572         case 503: // M503: print settings currently in memory
// 13573           gcode_M503();
??process_parsed_command_98:
          CFI FunCall _Z10gcode_M503v
        BL       _Z10gcode_M503v
// 13574           break;
        B.N      ??process_parsed_command_15
// 13575       #endif
// 13576 
// 13577       #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 13578         case 540: // M540: Set abort on endstop hit for SD printing
// 13579           gcode_M540();
// 13580           break;
// 13581       #endif
// 13582 
// 13583       #if HAS_BED_PROBE
// 13584         case 851: // M851: Set Z Probe Z Offset
// 13585           gcode_M851();
??process_parsed_command_101:
          CFI FunCall _Z10gcode_M851v
        BL       _Z10gcode_M851v
// 13586           break;
        B.N      ??process_parsed_command_15
// 13587       #endif // HAS_BED_PROBE
// 13588 
// 13589       #if ENABLED(SKEW_CORRECTION_GCODE)
// 13590         case 852: // M852: Set Skew factors
// 13591           gcode_M852();
// 13592           break;
// 13593       #endif
// 13594 
// 13595       #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 13596         case 600: // M600: Pause for filament change
// 13597           gcode_M600();
// 13598           break;
// 13599       #endif // ADVANCED_PAUSE_FEATURE
// 13600 
// 13601       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 13602         case 605: // M605: Set Dual X Carriage movement mode
// 13603           gcode_M605();
// 13604           break;
// 13605       #endif // DUAL_X_CARRIAGE
// 13606 
// 13607       #if ENABLED(MK2_MULTIPLEXER)
// 13608         case 702: // M702: Unload all extruders
// 13609           gcode_M702();
// 13610           break;
// 13611       #endif
// 13612 
// 13613       #if ENABLED(LIN_ADVANCE)
// 13614         case 900: // M900: Set advance K factor.
// 13615           gcode_M900();
// 13616           break;
// 13617       #endif
// 13618 
// 13619       case 907: // M907: Set digital trimpot motor current using axis codes.
// 13620         gcode_M907();
??process_parsed_command_102:
          CFI FunCall _Z10gcode_M907v
        BL       _Z10gcode_M907v
// 13621         break;
        B.N      ??process_parsed_command_15
// 13622 
// 13623       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 13624 
// 13625         case 908: // M908: Control digital trimpot directly.
// 13626           gcode_M908();
// 13627           break;
// 13628 
// 13629         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 13630 
// 13631           case 909: // M909: Print digipot/DAC current value
// 13632             gcode_M909();
// 13633             break;
// 13634 
// 13635           case 910: // M910: Commit digipot/DAC value to external EEPROM
// 13636             gcode_M910();
// 13637             break;
// 13638 
// 13639         #endif
// 13640 
// 13641       #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 13642 
// 13643       #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
// 13644         case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 13645           gcode_M906();
// 13646           break;
// 13647 
// 13648         case 911: // M911: Report TMC prewarn triggered flags
// 13649           gcode_M911();
// 13650           break;
// 13651 
// 13652         case 912: // M911: Clear TMC prewarn triggered flags
// 13653           gcode_M912();
// 13654           break;
// 13655 
// 13656         #if ENABLED(TMC_DEBUG)
// 13657           case 122:  // Debug TMC steppers
// 13658             gcode_M122();
// 13659             break;
// 13660         #endif
// 13661 
// 13662         #if ENABLED(HYBRID_THRESHOLD)
// 13663           case 913: // M913: Set HYBRID_THRESHOLD speed.
// 13664             gcode_M913();
// 13665             break;
// 13666         #endif
// 13667 
// 13668         #if ENABLED(SENSORLESS_HOMING)
// 13669           case 914: // M914: Set SENSORLESS_HOMING sensitivity.
// 13670             gcode_M914();
// 13671             break;
// 13672         #endif
// 13673 
// 13674         #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 13675           case 915: // M915: TMC Z axis calibration routine
// 13676             gcode_M915();
// 13677             break;
// 13678         #endif
// 13679       #endif
// 13680 
// 13681       #if HAS_MICROSTEPS
// 13682 
// 13683         case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 13684           gcode_M350();
// 13685           break;
// 13686 
// 13687         case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
// 13688           gcode_M351();
// 13689           break;
// 13690 
// 13691       #endif // HAS_MICROSTEPS
// 13692 
// 13693       case 355: // M355 set case light brightness
// 13694         gcode_M355();
??process_parsed_command_82:
          CFI FunCall _Z10gcode_M355v
        BL       _Z10gcode_M355v
// 13695         break;
        B.N      ??process_parsed_command_15
// 13696 
// 13697       #if ENABLED(DEBUG_GCODE_PARSER)
// 13698         case 800:
// 13699           parser.debug(); // GCode Parser Test for M
// 13700           break;
// 13701       #endif
// 13702 
// 13703       #if ENABLED(I2C_POSITION_ENCODERS)
// 13704 
// 13705         case 860: // M860 Report encoder module position
// 13706           gcode_M860();
// 13707           break;
// 13708 
// 13709         case 861: // M861 Report encoder module status
// 13710           gcode_M861();
// 13711           break;
// 13712 
// 13713         case 862: // M862 Perform axis test
// 13714           gcode_M862();
// 13715           break;
// 13716 
// 13717         case 863: // M863 Calibrate steps/mm
// 13718           gcode_M863();
// 13719           break;
// 13720 
// 13721         case 864: // M864 Change module address
// 13722           gcode_M864();
// 13723           break;
// 13724 
// 13725         case 865: // M865 Check module firmware version
// 13726           gcode_M865();
// 13727           break;
// 13728 
// 13729         case 866: // M866 Report axis error count
// 13730           gcode_M866();
// 13731           break;
// 13732 
// 13733         case 867: // M867 Toggle error correction
// 13734           gcode_M867();
// 13735           break;
// 13736 
// 13737         case 868: // M868 Set error correction threshold
// 13738           gcode_M868();
// 13739           break;
// 13740 
// 13741         case 869: // M869 Report axis error
// 13742           gcode_M869();
// 13743           break;
// 13744 
// 13745       #endif // I2C_POSITION_ENCODERS
// 13746 
// 13747       case 999: // M999: Restart after being Stopped
// 13748         gcode_M999();
??process_parsed_command_105:
          CFI FunCall _Z10gcode_M999v
        BL       _Z10gcode_M999v
// 13749         break;
        B.N      ??process_parsed_command_15
// 13750     }
// 13751     break;
// 13752 
// 13753     case 'T':
// 13754       gcode_T(parser.codenum);
??process_parsed_command_2:
        LDR.W    R0,??DataTable161_2
        LDR      R0,[R0, #+0]
        UXTB     R0,R0
          CFI FunCall _Z7gcode_Th
        BL       _Z7gcode_Th
// 13755       break;
        B.N      ??process_parsed_command_15
// 13756 
// 13757     default: parser.unknown_command_error();
??process_parsed_command_3:
        LDR.W    R0,??DataTable166
          CFI FunCall _ZN11GCodeParser21unknown_command_errorEv
        BL       _ZN11GCodeParser21unknown_command_errorEv
// 13758   }
// 13759 
// 13760   KEEPALIVE_STATE(NOT_BUSY);
??process_parsed_command_15:
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 13761 
// 13762   ok_to_send();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10ok_to_sendv
        B.N      _Z10ok_to_sendv
          CFI EndBlock cfiBlock66
// 13763 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable156_1:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "HAS_NO_TEMP_BED!\\n">`:
        DC8 "HAS_NO_TEMP_BED!\012"
        DC8 0, 0
// 13764 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function _Z20process_next_commandv
        THUMB
// 13765 void process_next_command() 
// 13766 {
_Z20process_next_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 13767   char * const current_command = command_queue[cmd_queue_index_r];
        LDR.W    R0,??DataTable166_1
        LDRB     R0,[R0, #+7]
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R0,??DataTable166_2
        ADD      R4,R0,R1, LSL #+5
// 13768 
// 13769   if (DEBUGGING(ECHO)) {
        LDR.W    R0,??DataTable166_3
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+31
        BPL.N    ??process_next_command_0
// 13770     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable160_6
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13771     SERIAL_ECHOLN(current_command);
        LDR.W    R5,??DataTable161
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13772     #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13773       SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
// 13774       M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
// 13775     #endif
// 13776   }
// 13777 
// 13778   // Parse the next command in the queue
// 13779   parser.parse(current_command);
??process_next_command_0:
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
// 13780   process_parsed_command();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22process_parsed_commandv
        B.N      _Z22process_parsed_commandv
          CFI EndBlock cfiBlock67
// 13781 }
// 13782 
// 13783 /**
// 13784  * Send a "Resend: nnn" message to the host to
// 13785  * indicate that a command needs to be re-sent.
// 13786  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function _Z24FlushSerialRequestResendv
          CFI FunCall _Z10ok_to_sendv
        THUMB
// 13787 void FlushSerialRequestResend() {
_Z24FlushSerialRequestResendv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13788   //char command_queue[cmd_queue_index_r][100]="Resend:";
// 13789   MYSERIAL.flush();
        LDR.W    R4,??DataTable161
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5flushEv
        BL       _ZN10USARTClass5flushEv
// 13790   SERIAL_PROTOCOLPGM(MSG_RESEND);
        ADR.W    R0,`?<Constant "Resend: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13791   SERIAL_PROTOCOLLN(gcode_LastN + 1);
        MOVS     R2,#+10
        LDR.W    R0,??DataTable161_1
        LDR      R0,[R0, #+44]
        ADDS     R1,R0,#+1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13792   ok_to_send();
        POP      {R4,LR}
          CFI EndBlock cfiBlock68
        REQUIRE _Z10ok_to_sendv
        ;; // Fall through to label ok_to_send()
// 13793 }
// 13794 
// 13795 /**
// 13796  * Send an "ok" message to the host, indicating
// 13797  * that a command was successfully processed.
// 13798  *
// 13799  * If ADVANCED_OK is enabled also include:
// 13800  *   N<int>  Line number of the command, if any
// 13801  *   P<int>  Planner space remaining
// 13802  *   B<int>  Block queue space remaining
// 13803  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function _Z10ok_to_sendv
        THUMB
// 13804 void ok_to_send() {
_Z10ok_to_sendv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 13805   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 13806   if (!send_ok[cmd_queue_index_r]) return;
        LDR.W    R0,??DataTable166_1
        LDRB     R1,[R0, #+7]
        ADDS     R0,R1,R0
        LDRB     R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??ok_to_send_0
// 13807   SERIAL_PROTOCOLPGM(MSG_OK);
        ADR.N    R0,??DataTable160  ;; 0x6F, 0x6B, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13808   #if ENABLED(ADVANCED_OK)
// 13809     char* p = command_queue[cmd_queue_index_r];
// 13810     if (*p == 'N') {
// 13811       SERIAL_PROTOCOL(' ');
// 13812       SERIAL_ECHO(*p++);
// 13813       while (NUMERIC_SIGNED(*p))
// 13814         SERIAL_ECHO(*p++);
// 13815     }
// 13816     SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
// 13817     SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
// 13818   #endif
// 13819   SERIAL_EOL();
        MOVS     R1,#+10
        LDR.W    R0,??DataTable161
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??ok_to_send_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock69
// 13820 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable158:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resend: ">`:
        DC8 "Resend: "
        DC8 0, 0, 0
// 13821 
// 13822 #if HAS_SOFTWARE_ENDSTOPS
// 13823 
// 13824   /**
// 13825    * Constrain the given coordinates to the software endstops.
// 13826    *
// 13827    * For DELTA/SCARA the XY constraint is based on the smallest
// 13828    * radius within the set software endstops.
// 13829    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function _Z26clamp_to_software_endstopsPf
        THUMB
// 13830   void clamp_to_software_endstops(float target[XYZ]) {
_Z26clamp_to_software_endstopsPf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
// 13831     if (!soft_endstops_enabled) return;
        LDR.W    R5,??DataTable166_4
        LDRB     R0,[R5, #+8]
        CMP      R0,#+0
        BEQ.W    ??clamp_to_software_endstops_0
// 13832     //#if IS_KINEMATIC
// 13833     if(MACHINETPYE & IS_KINEMATIC )
        LDR.W    R6,??DataTable166_5
        ADD      R7,R6,#+32
        LDRH     R0,[R7, #+56]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??clamp_to_software_endstops_1
// 13834     {
// 13835       const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
        LDR      R10,[R4, #+0]
        MOV      R9,#+2
        MOV      R11,#+1065353216
        MOV      R8,R11
        B.N      ??clamp_to_software_endstops_2
??clamp_to_software_endstops_3:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??clamp_to_software_endstops_2:
        LSLS     R0,R9,#+31
        BPL.N    ??clamp_to_software_endstops_4
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??clamp_to_software_endstops_4:
        LSRS     R9,R9,#+1
        BNE.N    ??clamp_to_software_endstops_3
        LDR      R9,[R4, #+4]
        MOV      R10,#+2
        B.N      ??clamp_to_software_endstops_5
??clamp_to_software_endstops_6:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??clamp_to_software_endstops_5:
        LSLS     R0,R10,#+31
        BPL.N    ??clamp_to_software_endstops_7
        MOV      R0,R11
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??clamp_to_software_endstops_7:
        LSRS     R10,R10,#+1
        BNE.N    ??clamp_to_software_endstops_6
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
// 13836       if (dist_2 > soft_endstop_radius_2) {
        LDR      R0,[R5, #+88]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_8
// 13837         const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
        MOV      R0,R1
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R5, #+84]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 13838         target[X_AXIS] *= ratio;
        LDR      R0,[R4, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+0]
// 13839         target[Y_AXIS] *= ratio;
        LDR      R0,[R4, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+4]
        B.N      ??clamp_to_software_endstops_8
// 13840       }
// 13841     }
// 13842     //#else
// 13843     else
// 13844     {
// 13845 		if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_1:
        LDRB     R0,[R6, #+32]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_9
// 13846 		{
// 13847       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
// 13848        	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
        LDR.W    R2,??DataTable166_3
        LDR      R1,[R2, #+68]
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_10
        STR      R1,[R4, #+0]
// 13849       		//#endif
// 13850       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
// 13851         	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
??clamp_to_software_endstops_10:
        LDR      R1,[R2, #+72]
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_9
        STR      R1,[R4, #+4]
// 13852       		//#endif
// 13853 		}
// 13854 		if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_9:
        LDRB     R0,[R7, #+1]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_8
// 13855 		{	
// 13856       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
// 13857         	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
        LDR      R0,[R5, #+36]
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_11
        STR      R0,[R4, #+0]
// 13858       		//#endif
// 13859       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
// 13860         	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
??clamp_to_software_endstops_11:
        LDR      R0,[R5, #+40]
        LDR      R1,[R4, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_8
        STR      R0,[R4, #+4]
// 13861       		//#endif
// 13862 		}
// 13863     }
// 13864     //#endif
// 13865 	if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_8:
        LDRB     R0,[R6, #+32]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_12
// 13866 	{
// 13867     //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
// 13868       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
        LDR.W    R2,??DataTable166_3
        LDR      R1,[R2, #+76]
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_12
        STR      R1,[R4, #+8]
// 13869     //#endif
// 13870 	}
// 13871 	if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_12:
        LDRB     R0,[R7, #+1]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 13872 	{
// 13873     //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
// 13874       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
        LDR      R0,[R5, #+44]
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_0
        STR      R0,[R4, #+8]
// 13875     //#endif
// 13876 	}
// 13877   }
??clamp_to_software_endstops_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock70

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable159:
        DC32     _ZN17mesh_bed_leveling8z_offsetE
// 13878 
// 13879 #endif
// 13880 
// 13881 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13882 
// 13883   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 13884     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
// 13885     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
// 13886     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
// 13887     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
// 13888     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
// 13889   #else
// 13890     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
// 13891     #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
// 13892     #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
// 13893     #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
// 13894     #define ABL_BG_GRID(X,Y)  z_values[X][Y]
// 13895   #endif
// 13896 
// 13897   // Get the Z adjustment for non-linear bed leveling

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function _Z17bilinear_z_offsetPKf
        THUMB
// 13898   float bilinear_z_offset(const float raw[XYZ]) {
_Z17bilinear_z_offsetPKf:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R5,R0
// 13899 
// 13900     static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
// 13901                  last_x = -999.999, last_y = -999.999;
// 13902 
// 13903     // Whole units for the grid line indices. Constrained within bounds.
// 13904     static int8_t gridx, gridy, nextx, nexty,
// 13905                   last_gridx = -99, last_gridy = -99;
// 13906 
// 13907     // XY relative to the probed area
// 13908     const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
        LDR.W    R4,??DataTable161_1
        LDR      R0,[R4, #+24]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 13909                 ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
        LDR      R0,[R4, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 13910 
// 13911     #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
// 13912       // Keep using the last grid box
// 13913       #define FAR_EDGE_OR_BOX 2
// 13914     #else
// 13915       // Just use the grid far edge
// 13916       #define FAR_EDGE_OR_BOX 1
// 13917     #endif
// 13918 
// 13919     if (last_x != rx) {
        LDR      R0,[R4, #+96]
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_0
// 13920       last_x = rx;
        STR      R6,[R4, #+96]
// 13921       ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
        LDR      R0,[R4, #+32]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
        STR      R7,[R4, #+88]
// 13922       const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
        LDR.W    R6,??DataTable166_5
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_1
        MOV      R8,R1
        B.N      ??bilinear_z_offset_2
??bilinear_z_offset_1:
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R9,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R8,R0
        MOV      R1,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??bilinear_z_offset_2
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R8,R0
// 13923       ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
??bilinear_z_offset_2:
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+88]
// 13924 
// 13925       #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13926         // Beyond the grid maintain height at grid edges
// 13927         NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_3
        MOV      R0,R1
        STR      R0,[R4, #+88]
// 13928       #endif
// 13929 
// 13930       gridx = gx;
??bilinear_z_offset_3:
        MOV      R0,R8
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+10]
// 13931       nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
        LDRB     R1,[R6, #+96]
        SXTB     R0,R0
        ADDS     R2,R0,#+1
        SUBS     R3,R1,#+1
        CMP      R2,R3
        BGE.N    ??bilinear_z_offset_4
        ADDS     R0,R0,#+1
        B.N      ??bilinear_z_offset_5
??bilinear_z_offset_4:
        SUBS     R0,R1,#+1
??bilinear_z_offset_5:
        STRB     R0,[R4, #+12]
// 13932     }
// 13933 
// 13934     if (last_y != ry || last_gridx != gridx) {
??bilinear_z_offset_0:
        LDR      R2,[R4, #+100]
        MOV      R0,R2
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??bilinear_z_offset_6
        LDRSB    R0,[R4, #+14]
        LDRSB    R1,[R4, #+10]
        CMP      R0,R1
        BEQ.W    ??bilinear_z_offset_7
// 13935 
// 13936       if (last_y != ry) {
??bilinear_z_offset_6:
        MOV      R0,R2
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_8
// 13937         last_y = ry;
        STR      R5,[R4, #+100]
// 13938         ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
        LDR      R0,[R4, #+36]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        STR      R5,[R4, #+92]
// 13939         const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_9
        MOV      R6,R1
        B.N      ??bilinear_z_offset_10
??bilinear_z_offset_9:
        MOV      R0,R5
          CFI FunCall floorf
        BL       floorf
        MOV      R7,R0
        LDR.W    R6,??DataTable166_5
        ADD      R1,R6,#+96
        LDRB     R0,[R1, #+1]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R6,R0
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??bilinear_z_offset_10
        MOV      R0,R5
          CFI FunCall floorf
        BL       floorf
        MOV      R6,R0
// 13940         ratio_y -= gy;
??bilinear_z_offset_10:
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+92]
// 13941 
// 13942         #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13943           // Beyond the grid maintain height at grid edges
// 13944           NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??bilinear_z_offset_11
        MOV      R0,R1
        STR      R0,[R4, #+92]
// 13945         #endif
// 13946 
// 13947         gridy = gy;
??bilinear_z_offset_11:
        MOV      R0,R6
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+11]
// 13948         nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
        LDR.W    R6,??DataTable166_5
        ADD      R1,R6,#+96
        LDRB     R1,[R1, #+1]
        SXTB     R0,R0
        ADDS     R2,R0,#+1
        SUBS     R3,R1,#+1
        CMP      R2,R3
        BGE.N    ??bilinear_z_offset_12
        ADDS     R0,R0,#+1
        B.N      ??bilinear_z_offset_13
??bilinear_z_offset_12:
        SUBS     R0,R1,#+1
??bilinear_z_offset_13:
        STRB     R0,[R4, #+13]
// 13949       }
// 13950 
// 13951       if (last_gridx != gridx || last_gridy != gridy) {
??bilinear_z_offset_8:
        LDRSB    R5,[R4, #+11]
        LDRSB    R0,[R4, #+10]
        LDRSB    R1,[R4, #+14]
        CMP      R1,R0
        BNE.N    ??bilinear_z_offset_14
        LDRSB    R1,[R4, #+15]
        CMP      R1,R5
        BEQ.N    ??bilinear_z_offset_15
// 13952         last_gridx = gridx;
??bilinear_z_offset_14:
        STRB     R0,[R4, #+14]
// 13953         last_gridy = gridy;
        STRB     R5,[R4, #+15]
// 13954         // Z at the box corners
// 13955         z1 = ABL_BG_GRID(gridx, gridy);       // left-front
        MOVS     R7,#+48
        LDR.W    R8,??DataTable168
        MLA      R0,R7,R0,R8
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+64]
        LDRSB    R6,[R4, #+13]
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+68]
// 13956         d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
// 13957         z3 = ABL_BG_GRID(nextx, gridy);       // right-front
        LDRSB    R0,[R4, #+12]
        MLA      R0,R7,R0,R8
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+72]
// 13958         d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+76]
// 13959       }
// 13960 
// 13961       // Bilinear interpolate. Needed since ry or gridx has changed.
// 13962                   L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
??bilinear_z_offset_15:
        LDR      R5,[R4, #+92]
        LDR      R0,[R4, #+68]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        STR      R6,[R4, #+80]
// 13963       const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
// 13964 
// 13965       D = R - L;
        LDR      R0,[R4, #+76]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+84]
// 13966     }
// 13967 
// 13968     const float offset = L + ratio_x * D;   // the offset almost always changes
// 13969 
// 13970     /*
// 13971     static float last_offset = 0;
// 13972     if (FABS(last_offset - offset) > 0.2) {
// 13973       SERIAL_ECHOPGM("Sudden Shift at ");
// 13974       SERIAL_ECHOPAIR("x=", rx);
// 13975       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
// 13976       SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
// 13977       SERIAL_ECHOPAIR(" y=", ry);
// 13978       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
// 13979       SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
// 13980       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
// 13981       SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
// 13982       SERIAL_ECHOPAIR(" z1=", z1);
// 13983       SERIAL_ECHOPAIR(" z2=", z2);
// 13984       SERIAL_ECHOPAIR(" z3=", z3);
// 13985       SERIAL_ECHOLNPAIR(" z4=", z4);
// 13986       SERIAL_ECHOPAIR(" L=", L);
// 13987       SERIAL_ECHOPAIR(" R=", R);
// 13988       SERIAL_ECHOLNPAIR(" offset=", offset);
// 13989     }
// 13990     last_offset = offset;
// 13991     //*/
// 13992 
// 13993     return offset;
??bilinear_z_offset_7:
        LDR      R1,[R4, #+88]
        LDR      R0,[R4, #+84]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+80]
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI EndBlock cfiBlock71
// 13994   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160:
        DC8      0x6F, 0x6B, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160_1:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160_2:
        DC32     hotend_offset

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160_3:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160_4:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160_5:
        DC32     _ZN11GCodeParser14command_letterE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160_6:
        DC32     echomagic

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_relative_modes:
        DATA
        DC8 0, 0, 0, 0
Running:
        DC8 1
        DC8 0
busy_state:
        DC8 0
host_keepalive_interval:
        DC8 2
serial_wait_tick:
        DC8 0
from_wifi_flag:
        DC8 0
        DC8 0
        DC8 0
        DC8 0
        DC8 0
        DC8 -99
        DC8 -99
bilinear_grid_spacing:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_start:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_grid_factor:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0
        DC32 0
        DC32 0
        DC32 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0C479FFF0H
        DC32 0C479FFF0H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_homed:
        DATA
        DC8 0, 0, 0, 0
axis_known_position:
        DC8 0, 0, 0, 0
soft_endstops_enabled:
        DC8 1
lcd_wait_for_move:
        DC8 0
        DC8 0, 0
delta_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_max:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta_tower_angle_trim:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta_diagonal_rod_2_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
cartes:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_radius:
        DC8 0, 0, 0, 0
soft_endstop_radius_2:
        DC8 0, 0, 0, 0
previous_cmd_ms:
        DC32 0
        DC32 0
        DC32 120000
delta_radius:
        DC8 0, 0, 0, 0
delta_diagonal_rod:
        DC8 0, 0, 0, 0
delta_calibration_radius:
        DC8 0, 0, 0, 0
delta_segments_per_second:
        DC8 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
home_bump_mm_P:
        DATA
        DC32 40A00000H, 40A00000H, 40A00000H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
_ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
        DATA
        DC32 -1
// 13995 
// 13996 #endif // AUTO_BED_LEVELING_BILINEAR
// 13997 
// 13998 #if 1//ENABLED(DELTA)
// 13999 
// 14000   /**
// 14001    * Recalculate factors used for delta kinematics whenever
// 14002    * settings have been changed (e.g., by M665).
// 14003    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function _Z21recalc_delta_settingsv
        THUMB
// 14004   void recalc_delta_settings() {
_Z21recalc_delta_settingsv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
// 14005     const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
// 14006                 drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
// 14007     delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
        LDR.W    R8,??DataTable168_1  ;; 0x54442d18
        LDR.W    R9,??DataTable168_2  ;; 0x400921fb
        LDR.W    R7,??DataTable168_3  ;; 0x43520000
        LDR.W    R6,??DataTable166_4
        LDR      R0,[R6, #+48]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable168_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+12]
// 14008     delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
        LDR      R0,[R6, #+48]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable168_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+16]
// 14009     delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
        LDR.W    R7,??DataTable168_5  ;; 0x43a50000
        LDR      R0,[R6, #+52]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable168_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+20]
// 14010     delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
        LDR      R0,[R6, #+52]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable168_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+24]
// 14011     delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
        LDR.W    R7,??DataTable169  ;; 0x42b40000
        LDR      R0,[R6, #+56]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable168_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+28]
// 14012     delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
        LDR      R0,[R6, #+56]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable168_4  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R4,R0
        MOV      R5,R1
        LDR      R1,[R6, #+104]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+32]
// 14013     delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
        LDR      R1,[R6, #+108]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        MOV      R7,R4
        MOV      R8,#+2
        MOV      R5,#+1065353216
        MOV      R9,R5
        B.N      ??recalc_delta_settings_0
??recalc_delta_settings_1:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_0:
        LSLS     R0,R8,#+31
        BPL.N    ??recalc_delta_settings_2
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_2:
        LSRS     R8,R8,#+1
        BNE.N    ??recalc_delta_settings_1
        STR      R9,[R6, #+60]
// 14014     delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
        MOV      R7,R4
        MOV      R8,#+2
        MOV      R9,R5
        B.N      ??recalc_delta_settings_3
??recalc_delta_settings_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_3:
        LSLS     R0,R8,#+31
        BPL.N    ??recalc_delta_settings_5
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_5:
        LSRS     R8,R8,#+1
        BNE.N    ??recalc_delta_settings_4
        STR      R9,[R6, #+64]
// 14015     delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
        MOVS     R7,#+2
        B.N      ??recalc_delta_settings_6
??recalc_delta_settings_7:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??recalc_delta_settings_6:
        LSLS     R0,R7,#+31
        BPL.N    ??recalc_delta_settings_8
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??recalc_delta_settings_8:
        LSRS     R7,R7,#+1
        BNE.N    ??recalc_delta_settings_7
        STR      R5,[R6, #+68]
// 14016     update_software_endstops(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 14017     axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
        MOVS     R0,#+0
        STRB     R0,[R6, #+2]
        STRH     R0,[R6, #+0]
// 14018   }
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock72

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161_2:
        DC32     _ZN11GCodeParser7codenumE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161_3:
        DC32     mksCfg+0x34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable161_4:
        DC32     `?<Constant "bed leveling hasn\\'t d...">`
// 14019 
// 14020   #if ENABLED(DELTA_FAST_SQRT)
// 14021     /**
// 14022      * Fast inverse sqrt from Quake III Arena
// 14023      * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
// 14024      */
// 14025     float Q_rsqrt(const float number) {
// 14026       long i;
// 14027       float x2, y;
// 14028       const float threehalfs = 1.5f;
// 14029       x2 = number * 0.5f;
// 14030       y  = number;
// 14031       i  = * ( long * ) &y;                       // evil floating point bit level hacking
// 14032       i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
// 14033       y  = * ( float * ) &i;
// 14034       y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
// 14035       // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
// 14036       return y;
// 14037     }
// 14038 
// 14039   #endif
// 14040 
// 14041   /**
// 14042    * Delta Inverse Kinematics
// 14043    *
// 14044    * Calculate the tower positions for a given machine
// 14045    * position, storing the result in the delta[] array.
// 14046    *
// 14047    * This is an expensive calculation, requiring 3 square
// 14048    * roots per segmented linear move, and strains the limits
// 14049    * of a Mega2560 with a Graphical Display.
// 14050    *
// 14051    * Suggested optimizations include:
// 14052    *
// 14053    * - Disable the home_offset (M206) and/or position_shift (G92)
// 14054    *   features to remove up to 12 float additions.
// 14055    *
// 14056    * - Use a fast-inverse-sqrt function and add the reciprocal.
// 14057    *   (see above)
// 14058    */
// 14059 
// 14060   #define DELTA_DEBUG() do { \ 
// 14061       SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \ 
// 14062       SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \ 
// 14063       SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \ 
// 14064       SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \ 
// 14065       SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \ 
// 14066       SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \ 
// 14067     }while(0)
// 14068 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function _Z18inverse_kinematicsPKf
        THUMB
// 14069   void inverse_kinematics(const float raw[XYZ]) {
_Z18inverse_kinematicsPKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
// 14070     DELTA_IK(raw);
        LDR.W    R6,??DataTable166_4
        LDR      R0,[R6, #+12]
        LDR      R1,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R9,#+2
        MOV      R4,#+1065353216
        MOV      R7,R4
        B.N      ??inverse_kinematics_0
??inverse_kinematics_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_0:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_2
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_2:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_1
        LDR      R0,[R6, #+16]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??inverse_kinematics_3
??inverse_kinematics_4:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_3:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_5
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_5:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_4
        MOV      R0,R7
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        LDR.W    R7,??DataTable166_3
        LDR      R1,[R5, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+80]
        LDR      R0,[R6, #+20]
        LDR      R1,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??inverse_kinematics_6
??inverse_kinematics_7:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_6:
        LSLS     R0,R10,#+31
        BPL.N    ??inverse_kinematics_8
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_8:
        LSRS     R10,R10,#+1
        BNE.N    ??inverse_kinematics_7
        LDR      R0,[R6, #+24]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??inverse_kinematics_9
??inverse_kinematics_10:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_9:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_11
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_11:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_10
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+84]
        LDR      R0,[R6, #+28]
        LDR      R1,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??inverse_kinematics_12
??inverse_kinematics_13:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_12:
        LSLS     R0,R10,#+31
        BPL.N    ??inverse_kinematics_14
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_14:
        LSRS     R10,R10,#+1
        BNE.N    ??inverse_kinematics_13
        LDR      R0,[R6, #+32]
        LDR      R1,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOV      R9,#+2
        B.N      ??inverse_kinematics_15
??inverse_kinematics_16:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_15:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_17
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??inverse_kinematics_17:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_16
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R6, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R5, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+88]
// 14071     // DELTA_DEBUG();
// 14072   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock73
// 14073 
// 14074   /**
// 14075    * Calculate the highest Z position where the
// 14076    * effector has the full range of XY motion.
// 14077    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function _Z28delta_safe_distance_from_topv
        THUMB
// 14078   float delta_safe_distance_from_top() {
_Z28delta_safe_distance_from_topv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
// 14079     float cartesian[XYZ] = { 0, 0, 0 };
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOV      R2,R1
        MOV      R3,R1
        STM      R0!,{R1-R3}
// 14080 	if(MACHINETPYE == MORGAN_SCARA)
        LDR.W    R4,??DataTable166_5
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        ADD      R0,SP,#+0
        BNE.N    ??delta_safe_distance_from_top_0
// 14081 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_1
// 14082 	else
// 14083     	inverse_kinematics(cartesian);
??delta_safe_distance_from_top_0:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 14084 	
// 14085     float distance = delta[A_AXIS];
??delta_safe_distance_from_top_1:
        LDR.W    R5,??DataTable166_3
        LDR      R6,[R5, #+80]
// 14086     cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
        LDR      R0,[R4, #+84]
        STR      R0,[SP, #+4]
// 14087 	if(MACHINETPYE == MORGAN_SCARA)
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        ADD      R0,SP,#+0
        BNE.N    ??delta_safe_distance_from_top_2
// 14088 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_3
// 14089 	else
// 14090     	inverse_kinematics(cartesian);
??delta_safe_distance_from_top_2:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 14091     return FABS(distance - delta[A_AXIS]);
??delta_safe_distance_from_top_3:
        MOV      R0,R6
        LDR      R1,[R5, #+80]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock74
// 14092   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_1:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_2:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_3:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable163_4:
        DC32     default_preview_flg
// 14093 
// 14094   /**
// 14095    * Delta Forward Kinematics
// 14096    *
// 14097    * See the Wikipedia article "Trilateration"
// 14098    * https://en.wikipedia.org/wiki/Trilateration
// 14099    *
// 14100    * Establish a new coordinate system in the plane of the
// 14101    * three carriage points. This system has its origin at
// 14102    * tower1, with tower2 on the X axis. Tower3 is in the X-Y
// 14103    * plane with a Z component of zero.
// 14104    * We will define unit vectors in this coordinate system
// 14105    * in our original coordinate system. Then when we calculate
// 14106    * the Xnew, Ynew and Znew values, we can translate back into
// 14107    * the original system by moving along those unit vectors
// 14108    * by the corresponding values.
// 14109    *
// 14110    * Variable names matched to Marlin, c-version, and avoid the
// 14111    * use of any vector library.
// 14112    *
// 14113    * by Andreas Hardtung 2016-06-07
// 14114    * based on a Java function from "Delta Robot Kinematics V3"
// 14115    * by Steve Graves
// 14116    *
// 14117    * The result is stored in the cartes[] array.
// 14118    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAfff
        THUMB
// 14119   void forward_kinematics_DELTA(float z1, float z2, float z3) {
_Z24forward_kinematics_DELTAfff:
        PUSH     {R0,R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+36
          CFI CFA R13+80
        MOV      R4,R1
        LDR.W    R0,??DataTable166_4
        LDR      R0,[R0, #+20]
        LDR.W    R1,??DataTable166_4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 14120     // Create a vector in old coordinates along x axis of new coordinate
// 14121     const float p12[] = {
        LDR.W    R0,??DataTable166_4
        LDR      R0,[R0, #+24]
        LDR.W    R1,??DataTable166_4
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R4
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
// 14122       delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 14123       delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 14124       z2 - z1
// 14125     },
// 14126 
// 14127     // Get the Magnitude of vector.
// 14128     d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
        MOV      R8,R6
        MOV      R9,#+2
        MOV      R7,#+1065353216
        B.N      ??forward_kinematics_DELTA_0
??forward_kinematics_DELTA_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_0:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_2
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_2:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_1
        MOV      R9,R5
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_3
??forward_kinematics_DELTA_4:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_3:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_5
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_5:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_4
        MOV      R11,R4
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_6
??forward_kinematics_DELTA_7:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_6:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_8
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_8:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_7
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+20]
// 14129 
// 14130     // Create unit vector by dividing by magnitude.
// 14131     ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
        MOV      R0,R6
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+16]
        MOV      R0,R5
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+12]
        MOV      R0,R4
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+8]
// 14132 
// 14133     // Get the vector from the origin of the new system to the third point.
// 14134     p13[3] = {
        LDR.W    R0,??DataTable166_4
        LDR      R0,[R0, #+28]
        LDR.W    R1,??DataTable166_4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        LDR.W    R0,??DataTable166_4
        LDR      R0,[R0, #+32]
        LDR.W    R1,??DataTable166_4
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[SP, #+40]
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 14135       delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 14136       delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 14137       z3 - z1
// 14138     },
// 14139 
// 14140     // Use the dot product to find the component of this vector on the X axis.
// 14141     i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
        LDR      R0,[SP, #+16]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
// 14142 
// 14143     // Create a vector along the x axis that represents the x component of p13.
// 14144     iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
// 14145 
// 14146     // Subtract the X component from the original vector leaving only Y. We use the
// 14147     // variable that will be the unit vector after we scale it.
// 14148     float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
        LDR      R0,[SP, #+16]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 14149 
// 14150     // The magnitude of Y component
// 14151     const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
        MOV      R8,R5
        MOV      R9,#+2
        MOV      R7,#+1065353216
        B.N      ??forward_kinematics_DELTA_9
??forward_kinematics_DELTA_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_9:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_11
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_11:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_10
        MOV      R9,R6
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_12
??forward_kinematics_DELTA_13:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_12:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_14
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_14:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_13
        LDR      R11,[SP, #+24]
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_15
??forward_kinematics_DELTA_16:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_15:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_17
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_17:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_16
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+4]
// 14152 
// 14153     // Convert to a unit vector
// 14154     ey[0] /= j; ey[1] /= j;  ey[2] /= j;
        MOV      R0,R5
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R5,R0
        MOV      R0,R6
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R6,R0
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
// 14155 
// 14156     // The cross product of the unit x and y is the unit z
// 14157     // float[] ez = vectorCrossProd(ex, ey);
// 14158     const float ez[3] = {
        LDR      R0,[SP, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
        LDR      R0,[SP, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+16]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+32]
        LDR      R0,[SP, #+16]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
// 14159       ex[1] * ey[2] - ex[2] * ey[1],
// 14160       ex[2] * ey[0] - ex[0] * ey[2],
// 14161       ex[0] * ey[1] - ex[1] * ey[0]
// 14162     },
// 14163     // We now have the d, i and j values defined in Wikipedia.
// 14164     // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
// 14165     Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
        LDR      R9,[SP, #+20]
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_18
??forward_kinematics_DELTA_19:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_18:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_20
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_20:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_19
        LDR.N    R0,??DataTable166_4
        LDR      R0,[R0, #+60]
        LDR.N    R1,??DataTable166_4
        LDR      R1,[R1, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R1,[SP, #+20]
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
// 14166     Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
        MOV      R9,R4
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_21
??forward_kinematics_DELTA_22:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_21:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_23
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_23:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_22
        LDR      R11,[SP, #+4]
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_24
??forward_kinematics_DELTA_25:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_24:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_26
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_26:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_25
        LDR.N    R0,??DataTable166_4
        LDR      R0,[R0, #+60]
        LDR.N    R1,??DataTable166_4
        LDR      R1,[R1, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R4,R0
// 14167     Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
        LDR      R9,[SP, #+0]
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_27
??forward_kinematics_DELTA_28:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??forward_kinematics_DELTA_27:
        LSLS     R0,R10,#+31
        BPL.N    ??forward_kinematics_DELTA_29
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_29:
        LSRS     R10,R10,#+1
        BNE.N    ??forward_kinematics_DELTA_28
        MOV      R11,R4
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??forward_kinematics_DELTA_30
??forward_kinematics_DELTA_31:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_30:
        LSLS     R0,R9,#+31
        BPL.N    ??forward_kinematics_DELTA_32
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??forward_kinematics_DELTA_32:
        LSRS     R9,R9,#+1
        BNE.N    ??forward_kinematics_DELTA_31
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR.N    R0,??DataTable166_4
        LDR      R0,[R0, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
// 14168 
// 14169     // Start from the origin of the old coordinates and add vectors in the
// 14170     // old coords that represent the Xnew, Ynew and Znew to find the point
// 14171     // in the old system.
// 14172     cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
        LDR      R1,[SP, #+16]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.N    R1,??DataTable166_4
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+24]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??DataTable166_4
        STR      R0,[R1, #+72]
// 14173     cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
        LDR      R1,[SP, #+12]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.N    R1,??DataTable166_4
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R0,[SP, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??DataTable166_4
        STR      R0,[R1, #+76]
// 14174     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
        LDR      R1,[SP, #+8]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??DataTable166_4
        STR      R0,[R1, #+80]
// 14175   }
        ADD      SP,SP,#+44
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock75
// 14176 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAPf
        THUMB
// 14177   void forward_kinematics_DELTA(float point[ABC]) {
// 14178     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
_Z24forward_kinematics_DELTAPf:
        LDR      R2,[R0, #+8]
        LDR      R1,[R0, #+4]
        LDR      R0,[R0, #+0]
          CFI FunCall _Z24forward_kinematics_DELTAfff
        B.N      _Z24forward_kinematics_DELTAfff
          CFI EndBlock cfiBlock76
// 14179   }
// 14180 
// 14181 #endif // DELTA
// 14182 
// 14183 /**
// 14184  * Get the stepper positions in the cartes[] array.
// 14185  * Forward kinematics are applied for DELTA and SCARA.
// 14186  *
// 14187  * The result is in the current coordinate space with
// 14188  * leveling applied. The coordinates need to be run through
// 14189  * unapply_leveling to obtain machine coordinates suitable
// 14190  * for current_position, etc.
// 14191  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI Function _Z27get_cartesian_from_steppersv
        THUMB
// 14192 void get_cartesian_from_steppers() {
_Z27get_cartesian_from_steppersv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+12
          CFI CFA R13+24
        LDR.N    R0,??DataTable166_5
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??get_cartesian_from_steppers_0
// 14193   //#if ENABLED(DELTA)
// 14194   if(MACHINETPYE == DELTA)  {
// 14195     forward_kinematics_DELTA(
// 14196       stepper.get_axis_position_mm(A_AXIS),
// 14197       stepper.get_axis_position_mm(B_AXIS),
// 14198       stepper.get_axis_position_mm(C_AXIS)
// 14199     );
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R4,R0
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R5,R0
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R2,R4
        MOV      R1,R5
          CFI FunCall _Z24forward_kinematics_DELTAfff
        BL       _Z24forward_kinematics_DELTAfff
        POP      {R0-R2,R4,R5,PC}
// 14200   	}
// 14201   //#else
// 14202   else
// 14203   {
// 14204     //#if IS_SCARA
// 14205 	if(MACHINETPYE&IS_SCARA) {
??get_cartesian_from_steppers_0:
        LDR.N    R4,??DataTable166_4
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??get_cartesian_from_steppers_1
// 14206       forward_kinematics_SCARA(
// 14207         stepper.get_axis_position_degrees(A_AXIS),
// 14208         stepper.get_axis_position_degrees(B_AXIS)
// 14209       );
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+0]
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        BL       _ZN7Stepper25get_axis_position_degreesE8AxisEnum
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
        B.N      ??get_cartesian_from_steppers_2
// 14210 	}
// 14211     //#else
// 14212     else
// 14213     {
// 14214       cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
??get_cartesian_from_steppers_1:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+72]
// 14215       cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+76]
// 14216     }
// 14217     //#endif
// 14218     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
??get_cartesian_from_steppers_2:
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+80]
// 14219   }
// 14220   //#endif
// 14221 }
        POP      {R0-R2,R4,R5,PC}  ;; return
          CFI EndBlock cfiBlock77
// 14222 
// 14223 /**
// 14224  * Set the current_position for an axis based on
// 14225  * the stepper positions, removing any leveling that
// 14226  * may have been applied.
// 14227  *
// 14228  * To prevent small shifts in axis position always call
// 14229  * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
// 14230  *
// 14231  * To keep hosts in sync, always call report_current_position
// 14232  * after updating the current_position.
// 14233  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function _Z34set_current_from_steppers_for_axis8AxisEnum
        THUMB
// 14234 void set_current_from_steppers_for_axis(const AxisEnum axis) {
_Z34set_current_from_steppers_for_axis8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 14235   get_cartesian_from_steppers();
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
// 14236   //#if PLANNER_LEVELING
// 14237   if(BED_LEVELING_METHOD&PLANNER_LEVELING)
        LDR.N    R5,??DataTable166_4
        LDR.N    R0,??DataTable166_5
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+46
        TST      R0,R1
        BEQ.N    ??set_current_from_steppers_for_axis_0
// 14238     planner.unapply_leveling(cartes);
        ADD      R0,R5,#+72
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
// 14239   //#endif
// 14240   if (axis == ALL_AXES)
??set_current_from_steppers_for_axis_0:
        LDR.W    R0,??DataTable175
        CMP      R4,#+100
        BNE.N    ??set_current_from_steppers_for_axis_1
// 14241     COPY(current_position, cartes);
        MOVS     R2,#+12
        ADD      R1,R5,#+72
        ADDS     R0,R0,#+8
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall memcpy
        B.W      memcpy
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 14242   else
// 14243     current_position[axis] = cartes[axis];
??set_current_from_steppers_for_axis_1:
        ADD      R1,R5,R4, LSL #+2
        LDR      R1,[R1, #+72]
        ADD      R0,R0,R4, LSL #+2
        STR      R1,[R0, #+8]
// 14244 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock78

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166:
        DC32     parser

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_1:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_2:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_3:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_4:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_5:
        DC32     mksCfg
// 14245 
// 14246 #if 1//IS_CARTESIAN
// 14247 #if 1//ENABLED(SEGMENT_LEVELED_MOVES)
// 14248 
// 14249   /**
// 14250    * Prepare a segmented move on a CARTESIAN setup.
// 14251    *
// 14252    * This calls planner.buffer_line several times, adding
// 14253    * small incremental moves. This allows the planner to
// 14254    * apply more detailed bed leveling to the full move.
// 14255    */
// 14256   inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
// 14257 
// 14258     const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
// 14259                 ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
// 14260 
// 14261     // If the move is only in Z/E don't split up the move
// 14262     if (!xdiff && !ydiff) {
// 14263       planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 14264       return;
// 14265     }
// 14266 
// 14267     // Remaining cartesian distances
// 14268     const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
// 14269                 ediff = destination[E_AXIS] - current_position[E_AXIS];
// 14270 
// 14271     // Get the linear distance in XYZ
// 14272     // If the move is very short, check the E move distance
// 14273     // No E move either? Game over.
// 14274     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 14275     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 14276     if (UNEAR_ZERO(cartesian_mm)) return;
// 14277 
// 14278     // The length divided by the segment size
// 14279     // At least one segment is required
// 14280     uint16_t segments = cartesian_mm / segment_size;
// 14281     NOLESS(segments, 1);
// 14282 
// 14283     // The approximate length of each segment
// 14284     const float inv_segments = 1.0 / float(segments),
// 14285                 segment_distance[XYZE] = {
// 14286                   xdiff * inv_segments,
// 14287                   ydiff * inv_segments,
// 14288                   zdiff * inv_segments,
// 14289                   ediff * inv_segments
// 14290                 };
// 14291 
// 14292     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 14293     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 14294 
// 14295     // Get the raw current position as starting point
// 14296     float raw[XYZE];
// 14297     COPY(raw, current_position);
// 14298 
// 14299     // Calculate and execute the segments
// 14300     while (--segments) {
// 14301       static millis_t next_idle_ms = millis() + 200UL;
// 14302       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 14303       if (ELAPSED(millis(), next_idle_ms)) {
// 14304         next_idle_ms = millis() + 200UL;
// 14305         idle();
// 14306       }
// 14307       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 14308       planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
// 14309     }
// 14310 
// 14311     // Since segment_distance is only approximate,
// 14312     // the final move must be to the exact destination.
// 14313     planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 14314   }
// 14315 #endif
// 14316 //#elif ENABLED(MESH_BED_LEVELING)
// 14317 #if 1
// 14318   /**
// 14319    * Prepare a mesh-leveled linear move in a Cartesian setup,
// 14320    * splitting the move where it crosses mesh borders.
// 14321    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function _Z24mesh_line_to_destinationfhh
        THUMB
// 14322   void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
_Z24mesh_line_to_destinationfhh:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+16
          CFI CFA R13+56
        MOV      R4,R1
        MOV      R5,R2
// 14323     // Get current and destination cells for this line
// 14324     int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
        LDR.W    R6,??DataTable175
        ADD      R0,R6,#+8
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R7,R0
// 14325         cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
        ADD      R0,R6,#+12
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
        MOV      R8,R0
// 14326         cx2 = mbl.cell_index_x(destination[X_AXIS]),
        ADD      R0,R6,#+24
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R9,R0
// 14327         cy2 = mbl.cell_index_y(destination[Y_AXIS]);
        ADD      R0,R6,#+28
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
// 14328     NOMORE(cx1, GRID_MAX_POINTS_X - 2);
        LDR.W    R1,??DataTable175_1
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R7
        BGE.N    ??mesh_line_to_destination_0
        MOV      R7,R2
??mesh_line_to_destination_0:
        ADDS     R1,R1,#+96
        LDRB     R1,[R1, #+1]
        SUBS     R1,R1,#+2
        CMP      R1,R8
        BGE.N    ??mesh_line_to_destination_1
// 14329     NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
        MOV      R8,R1
// 14330     NOMORE(cx2, GRID_MAX_POINTS_X - 2);
??mesh_line_to_destination_1:
        CMP      R2,R9
        BGE.N    ??mesh_line_to_destination_2
        MOV      R9,R2
// 14331     NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
??mesh_line_to_destination_2:
        CMP      R1,R0
        BGE.N    ??mesh_line_to_destination_3
        MOV      R0,R1
// 14332 
// 14333     // Start and end in the same cell? No split needed.
// 14334     if (cx1 == cx2 && cy1 == cy2) {
??mesh_line_to_destination_3:
        CMP      R7,R9
        BNE.N    ??mesh_line_to_destination_4
        CMP      R8,R0
        BEQ.W    ??mesh_line_to_destination_5
// 14335       buffer_line_to_destination(fr_mm_s);
// 14336       set_current_from_destination();
// 14337       return;
// 14338     }
// 14339 
// 14340     #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 14341 
// 14342     float normalized_dist, end[XYZE];
// 14343     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
??mesh_line_to_destination_4:
        MOV      R10,R9
        CMP      R9,R7
        BGE.N    ??mesh_line_to_destination_6
        MOV      R10,R7
??mesh_line_to_destination_6:
        MOV      R11,R0
        CMP      R0,R8
        BGE.N    ??mesh_line_to_destination_7
        MOV      R11,R8
// 14344 
// 14345     // Crosses on the X and not already split on this X?
// 14346     // The x_splits flags are insurance against rounding errors.
// 14347     if (cx2 != cx1 && TEST(x_splits, gcx)) {
??mesh_line_to_destination_7:
        CMP      R9,R7
        BEQ.N    ??mesh_line_to_destination_8
        MOVS     R1,#+1
        LSL      R2,R1,R10
        MOV      R1,R4
        TST      R1,R2
        BEQ.N    ??mesh_line_to_destination_8
// 14348       // Split on the X grid line
// 14349       CBI(x_splits, gcx);
        BICS     R4,R4,R2
// 14350       COPY(end, destination);
        MOVS     R2,#+16
        ADD      R1,R6,#+24
        ADD      R0,SP,#+0
          CFI FunCall memcpy
        BL       memcpy
// 14351       destination[X_AXIS] = mbl.index_to_xpos[gcx];
        SXTB     R10,R10
        LDR.W    R0,??DataTable176
        LDR      R0,[R0, R10, LSL #+2]
        STR      R0,[R6, #+24]
// 14352       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        LDR      R7,[R6, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
// 14353       destination[Y_AXIS] = MBL_SEGMENT_END(Y);
        LDR      R8,[R6, #+12]
        LDR      R0,[R6, #+28]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+28]
// 14354     }
// 14355     // Crosses on the Y and not already split on this Y?
// 14356     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 14357       // Split on the Y grid line
// 14358       CBI(y_splits, gcy);
// 14359       COPY(end, destination);
// 14360       destination[Y_AXIS] = mbl.index_to_ypos[gcy];
// 14361       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 14362       destination[X_AXIS] = MBL_SEGMENT_END(X);
// 14363     }
// 14364     else {
// 14365       // Must already have been split on these border(s)
// 14366       buffer_line_to_destination(fr_mm_s);
// 14367       set_current_from_destination();
// 14368       return;
// 14369     }
// 14370 
// 14371     destination[Z_AXIS] = MBL_SEGMENT_END(Z);
??mesh_line_to_destination_9:
        LDR      R8,[R6, #+16]
        LDR      R0,[R6, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+32]
// 14372     destination[E_AXIS] = MBL_SEGMENT_END(E);
        LDR      R8,[R6, #+20]
        LDR      R0,[R6, #+36]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+36]
// 14373 
// 14374     // Do the split and look for more borders
// 14375     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R5
        MOV      R1,R4
        LDR      R0,[SP, #+16]
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 14376 
// 14377     // Restore destination from stack
// 14378     COPY(destination, end);
        MOVS     R2,#+16
        ADD      R1,SP,#+0
        ADD      R0,R6,#+24
          CFI FunCall memcpy
        BL       memcpy
// 14379     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R5
        MOV      R1,R4
        LDR      R0,[SP, #+16]
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 14380   }
??mesh_line_to_destination_10:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+56
??mesh_line_to_destination_8:
        CMP      R0,R8
        BEQ.N    ??mesh_line_to_destination_5
        MOVS     R1,#+1
        LSL      R0,R1,R11
        MOV      R1,R5
        TST      R1,R0
        BEQ.N    ??mesh_line_to_destination_5
        BICS     R5,R5,R0
        MOVS     R2,#+16
        ADD      R1,R6,#+24
        ADD      R0,SP,#+0
          CFI FunCall memcpy
        BL       memcpy
        SXTB     R11,R11
        LDR.W    R0,??DataTable182
        LDR      R0,[R0, R11, LSL #+2]
        STR      R0,[R6, #+28]
        LDR      R7,[R6, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R7,R0
        LDR      R8,[R6, #+8]
        LDR      R0,[R6, #+24]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+24]
        B.N      ??mesh_line_to_destination_9
??mesh_line_to_destination_5:
        LDR      R0,[SP, #+16]
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
        B.N      ??mesh_line_to_destination_10
          CFI EndBlock cfiBlock79
// 14381 #endif
// 14382 //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 14383 #if 1
// 14384   #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
// 14385 
// 14386   /**
// 14387    * Prepare a bilinear-leveled linear move on Cartesian,
// 14388    * splitting the move where it crosses grid borders.
// 14389    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function _Z28bilinear_line_to_destinationftt
        THUMB
// 14390   void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
_Z28bilinear_line_to_destinationftt:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
// 14391     // Get current and destination cells for this line
// 14392     int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
        LDR.W    R8,??DataTable178
        LDR      R0,[R8, #+24]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R11,R0
        LDR.W    R7,??DataTable175
        LDR      R0,[R7, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+32]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R9,R0
        LDR      R0,[R8, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+36]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R10,R0
// 14393         cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
// 14394         cx2 = CELL_INDEX(X, destination[X_AXIS]),
        LDR      R0,[R7, #+24]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+32]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R11,R0
// 14395         cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
        LDR      R0,[R8, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+36]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
// 14396     cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
        LDR.W    R1,??DataTable175_1
        CMP      R9,#+0
        BPL.N    ??bilinear_line_to_destination_0
        MOV      R9,#+0
        B.N      ??bilinear_line_to_destination_1
??bilinear_line_to_destination_0:
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R9
        BGE.N    ??bilinear_line_to_destination_1
        MOV      R9,R2
// 14397     cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_1:
        CMP      R10,#+0
        BPL.N    ??bilinear_line_to_destination_2
        MOV      R10,#+0
        B.N      ??bilinear_line_to_destination_3
??bilinear_line_to_destination_2:
        ADD      R2,R1,#+96
        LDRB     R2,[R2, #+1]
        SUBS     R2,R2,#+2
        CMP      R2,R10
        BGE.N    ??bilinear_line_to_destination_3
        MOV      R10,R2
// 14398     cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
??bilinear_line_to_destination_3:
        CMP      R11,#+0
        BPL.N    ??bilinear_line_to_destination_4
        MOV      R11,#+0
        B.N      ??bilinear_line_to_destination_5
??bilinear_line_to_destination_4:
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R11
        BGE.N    ??bilinear_line_to_destination_5
        MOV      R11,R2
// 14399     cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_5:
        CMP      R0,#+0
        BPL.N    ??bilinear_line_to_destination_6
        MOVS     R0,#+0
        B.N      ??bilinear_line_to_destination_7
??bilinear_line_to_destination_6:
        ADD      R2,R1,#+96
        LDRB     R1,[R2, #+1]
        SUBS     R2,R1,#+2
        CMP      R2,R0
        BGE.N    ??bilinear_line_to_destination_7
        MOV      R0,R2
// 14400 
// 14401     // Start and end in the same cell? No split needed.
// 14402     if (cx1 == cx2 && cy1 == cy2) {
??bilinear_line_to_destination_7:
        CMP      R9,R11
        BNE.N    ??bilinear_line_to_destination_8
        CMP      R10,R0
        BEQ.W    ??bilinear_line_to_destination_9
// 14403       buffer_line_to_destination(fr_mm_s);
// 14404       set_current_from_destination();
// 14405       return;
// 14406     }
// 14407 
// 14408     #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 14409 
// 14410     float normalized_dist, end[XYZE];
// 14411     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
??bilinear_line_to_destination_8:
        MOV      R1,R11
        CMP      R11,R9
        BGE.N    ??bilinear_line_to_destination_10
        MOV      R1,R9
??bilinear_line_to_destination_10:
        STR      R1,[SP, #+4]
        MOV      R1,R0
        CMP      R0,R10
        BGE.N    ??bilinear_line_to_destination_11
        MOV      R1,R10
??bilinear_line_to_destination_11:
        STR      R1,[SP, #+0]
// 14412 
// 14413     // Crosses on the X and not already split on this X?
// 14414     // The x_splits flags are insurance against rounding errors.
// 14415     if (cx2 != cx1 && TEST(x_splits, gcx)) {
        CMP      R11,R9
        BEQ.N    ??bilinear_line_to_destination_12
        MOVS     R1,#+1
        LDR      R2,[SP, #+4]
        LSL      R2,R1,R2
        MOV      R1,R5
        TST      R1,R2
        BEQ.N    ??bilinear_line_to_destination_12
// 14416       // Split on the X grid line
// 14417       CBI(x_splits, gcx);
        BICS     R5,R5,R2
// 14418       COPY(end, destination);
        MOVS     R2,#+16
        ADD      R1,R7,#+24
        ADD      R0,SP,#+8
          CFI FunCall memcpy
        BL       memcpy
// 14419       destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
        LDR      R0,[R8, #+24]
        LDR      R1,[R8, #+16]
        ADD      R2,SP,#+4
        LDRSB    R2,[R2, #+0]
        MLA      R0,R2,R1,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R7, #+24]
// 14420       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        LDR      R8,[R7, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 14421       destination[Y_AXIS] = LINE_SEGMENT_END(Y);
        LDR      R9,[R7, #+12]
        LDR      R0,[R7, #+28]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+28]
// 14422     }
// 14423     // Crosses on the Y and not already split on this Y?
// 14424     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 14425       // Split on the Y grid line
// 14426       CBI(y_splits, gcy);
// 14427       COPY(end, destination);
// 14428       destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
// 14429       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 14430       destination[X_AXIS] = LINE_SEGMENT_END(X);
// 14431     }
// 14432     else {
// 14433       // Must already have been split on these border(s)
// 14434       buffer_line_to_destination(fr_mm_s);
// 14435       set_current_from_destination();
// 14436       return;
// 14437     }
// 14438 
// 14439     destination[Z_AXIS] = LINE_SEGMENT_END(Z);
??bilinear_line_to_destination_13:
        LDR      R9,[R7, #+16]
        LDR      R0,[R7, #+32]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+32]
// 14440     destination[E_AXIS] = LINE_SEGMENT_END(E);
        LDR      R9,[R7, #+20]
        LDR      R0,[R7, #+36]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+36]
// 14441 
// 14442     // Do the split and look for more borders
// 14443     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 14444 
// 14445     // Restore destination from stack
// 14446     COPY(destination, end);
        MOVS     R2,#+16
        ADD      R1,SP,#+8
        ADD      R0,R7,#+24
          CFI FunCall memcpy
        BL       memcpy
// 14447     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 14448   }
??bilinear_line_to_destination_14:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+64
??bilinear_line_to_destination_12:
        CMP      R0,R10
        BEQ.N    ??bilinear_line_to_destination_9
        MOVS     R1,#+1
        LDR      R0,[SP, #+0]
        LSL      R0,R1,R0
        MOV      R1,R6
        TST      R1,R0
        BEQ.N    ??bilinear_line_to_destination_9
        BICS     R6,R6,R0
        MOVS     R2,#+16
        ADD      R1,R7,#+24
        ADD      R0,SP,#+8
          CFI FunCall memcpy
        BL       memcpy
        LDR      R0,[R8, #+28]
        LDR      R1,[R8, #+20]
        ADD      R2,SP,#+0
        LDRSB    R2,[R2, #+0]
        MLA      R0,R2,R1,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R7, #+28]
        LDR      R8,[R7, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R9,[R7, #+8]
        LDR      R0,[R7, #+24]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+24]
        B.N      ??bilinear_line_to_destination_13
??bilinear_line_to_destination_9:
        MOV      R0,R4
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
        B.N      ??bilinear_line_to_destination_14
          CFI EndBlock cfiBlock80

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_1:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_2:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_3:
        DC32     0x43520000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_4:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable168_5:
        DC32     0x43a50000
// 14449 
// 14450 #endif // AUTO_BED_LEVELING_BILINEAR
// 14451 #endif // IS_CARTESIAN
// 14452 
// 14453 #if 1//!UBL_SEGMENTED
// 14454 #if 1//IS_KINEMATIC
// 14455 
// 14456   /**
// 14457    * Prepare a linear move in a DELTA or SCARA setup.
// 14458    *
// 14459    * This calls planner.buffer_line several times, adding
// 14460    * small incremental moves for DELTA or SCARA.
// 14461    *
// 14462    * For Unified Bed Leveling (Delta or Segmented Cartesian)
// 14463    * the ubl.prepare_segmented_line_to method replaces this.
// 14464    */
// 14465   inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
// 14466 
// 14467     // Get the top feedrate of the move in the XY plane
// 14468     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
// 14469 
// 14470     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
// 14471                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
// 14472 
// 14473     // If the move is only in Z/E don't split up the move
// 14474     if (!xdiff && !ydiff) {
// 14475       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 14476       return false; // caller will update current_position
// 14477     }
// 14478 
// 14479     // Fail if attempting move outside printable radius
// 14480     if(MACHINETPYE & IS_KINEMATIC)
// 14481     {
// 14482         if (!position_is_reachable_IS_KINEMATIC(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 14483     }
// 14484     else
// 14485     {
// 14486         if (!position_is_reachable_IS_CARTESIAN(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 14487     }
// 14488     // Remaining cartesian distances
// 14489     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
// 14490                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
// 14491 
// 14492     // Get the linear distance in XYZ
// 14493     // If the move is very short, check the E move distance
// 14494     // No E move either? Game over.
// 14495     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 14496     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 14497     if (UNEAR_ZERO(cartesian_mm)) return true;
// 14498 
// 14499     // Minimum number of seconds to move the given distance
// 14500     const float seconds = cartesian_mm / _feedrate_mm_s;
// 14501 
// 14502     // The number of segments-per-second times the duration
// 14503     // gives the number of segments
// 14504     uint16_t segments = delta_segments_per_second * seconds;
// 14505 
// 14506     // For SCARA minimum segment size is 0.25mm
// 14507     //#if IS_SCARA
// 14508 	if(MACHINETPYE&IS_SCARA)
// 14509       NOMORE(segments, cartesian_mm * 4);
// 14510     //#endif
// 14511 
// 14512     // At least one segment is required
// 14513     NOLESS(segments, 1);
// 14514 
// 14515     // The approximate length of each segment
// 14516     const float inv_segments = 1.0 / float(segments),
// 14517                 segment_distance[XYZE] = {
// 14518                   xdiff * inv_segments,
// 14519                   ydiff * inv_segments,
// 14520                   zdiff * inv_segments,
// 14521                   ediff * inv_segments
// 14522                 };
// 14523 
// 14524     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 14525     // SERIAL_ECHOPAIR(" seconds=", seconds);
// 14526     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 14527 
// 14528     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14529       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14530       // i.e., Complete the angular vector in the given time.
// 14531       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
// 14532                   inverse_secs = inv_segment_length * _feedrate_mm_s;
// 14533       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14534             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14535     #endif
// 14536 
// 14537     // Get the current position as starting point
// 14538     float raw[XYZE];
// 14539     COPY(raw, current_position);
// 14540 
// 14541 
// 14542     // Calculate and execute the segments
// 14543     while (--segments) {
// 14544 
// 14545       static millis_t next_idle_ms = millis() + 200UL;
// 14546       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 14547       if (ELAPSED(millis(), next_idle_ms)) {
// 14548         next_idle_ms = millis() + 200UL;
// 14549         idle();
// 14550       }
// 14551 
// 14552       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 14553       //#if ENABLED(DELTA)
// 14554       if(MACHINETPYE&DELTA)
// 14555         DELTA_IK(raw); // Delta can inline its kinematics
// 14556       //#else
// 14557       else
// 14558         inverse_kinematics(raw);
// 14559       //#endif
// 14560 
// 14561       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
// 14562 
// 14563       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14564         // For SCARA scale the feed rate from mm/s to degrees/s
// 14565         // i.e., Complete the angular vector in the given time.
// 14566         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14567         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14568       #else
// 14569           if (gCfgItems.breakpoint_reprint_flg == 1) 
// 14570           {
// 14571               if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
// 14572               {
// 14573                   //current_position[Z_AXIS] = rtarget[Z_AXIS];
// 14574                   //current_position[E_AXIS] = destination[E_AXIS];
// 14575 
// 14576                   gCfgItems.had_breakpoint=1;
// 14577                   gCfgItems.breakpoint_e_position=LROUND(raw[E_AXIS] * planner.axis_steps_per_mm[E_AXIS]);
// 14578                                     
// 14579                   return false;
// 14580               }
// 14581           }
// 14582         //gCfgItems.breakpoint_reprint_flg = 0;
// 14583         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
// 14584       #endif
// 14585     }
// 14586 
// 14587     // Ensure last segment arrives at target location.
// 14588     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14589       inverse_kinematics(rtarget);
// 14590       ADJUST_DELTA(rtarget);
// 14591       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14592     #else
// 14593       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 14594     #endif
// 14595 
// 14596     return false; // caller will update current_position
// 14597   }
// 14598 #endif
// 14599 //#else // !IS_KINEMATIC
// 14600 #if 1
// 14601   /**
// 14602    * Prepare a linear move in a Cartesian setup.
// 14603    *
// 14604    * When a mesh-based leveling system is active, moves are segmented
// 14605    * according to the configuration of the leveling system.
// 14606    *
// 14607    * Returns true if current_position[] was set to destination[]
// 14608    */
// 14609   inline bool prepare_move_to_destination_cartesian() {
// 14610     #if 1//HAS_MESH
// 14611       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
// 14612         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 14613         if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 14614         {
// 14615           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
// 14616           return true;     
// 14617 		 }// all moves, including Z-only moves.
// 14618         //#elif ENABLED(SEGMENT_LEVELED_MOVES)
// 14619 		//{
// 14620         //  segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14621         //  return false; // caller will update current_position
// 14622 		//}
// 14623         //#else
// 14624         else
// 14625         {
// 14626           #if ENABLED(SEGMENT_LEVELED_MOVES)
// 14627             segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14628             return false; // caller will update current_position
// 14629           #else
// 14630           /**
// 14631            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
// 14632            * Otherwise fall through to do a direct single move.
// 14633            */
// 14634           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
// 14635             //#if ENABLED(MESH_BED_LEVELING)
// 14636             if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 14637               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14638             //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 14639             else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 14640               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14641             //#endif
// 14642             return true;
// 14643           }
// 14644           #endif
// 14645         }
// 14646         //#endif
// 14647       }
// 14648     #endif // HAS_MESH
// 14649 
// 14650     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14651     return false; // caller will update current_position
// 14652   }
// 14653 
// 14654 #endif // !IS_KINEMATIC
// 14655 #endif // !UBL_SEGMENTED
// 14656 
// 14657 #if ENABLED(DUAL_X_CARRIAGE)
// 14658 
// 14659   /**
// 14660    * Unpark the carriage, if needed
// 14661    */
// 14662   inline bool dual_x_carriage_unpark() {
// 14663     if (active_extruder_parked)
// 14664       switch (dual_x_carriage_mode) {
// 14665 
// 14666         case DXC_FULL_CONTROL_MODE: break;
// 14667 
// 14668         case DXC_AUTO_PARK_MODE:
// 14669           if (current_position[E_AXIS] == destination[E_AXIS]) {
// 14670             // This is a travel move (with no extrusion)
// 14671             // Skip it, but keep track of the current position
// 14672             // (so it can be used as the start of the next non-travel move)
// 14673             if (delayed_move_time != 0xFFFFFFFFUL) {
// 14674               set_current_from_destination();
// 14675               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
// 14676               delayed_move_time = millis();
// 14677               return true;
// 14678             }
// 14679           }
// 14680           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
// 14681           for (uint8_t i = 0; i < 3; i++)
// 14682             planner.buffer_line(
// 14683               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
// 14684               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
// 14685               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
// 14686               current_position[E_AXIS],
// 14687               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
// 14688               active_extruder
// 14689             );
// 14690           delayed_move_time = 0;
// 14691           active_extruder_parked = false;
// 14692           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14693             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
// 14694           #endif
// 14695           break;
// 14696 
// 14697         case DXC_DUPLICATION_MODE:
// 14698           if (active_extruder == 0) {
// 14699             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14700               if (DEBUGGING(LEVELING)) {
// 14701                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
// 14702                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
// 14703               }
// 14704             #endif
// 14705             // move duplicate extruder into correct duplication position.
// 14706             planner.set_position_mm(
// 14707               inactive_extruder_x_pos,
// 14708               current_position[Y_AXIS],
// 14709               current_position[Z_AXIS],
// 14710               current_position[E_AXIS]
// 14711             );
// 14712             planner.buffer_line(
// 14713               current_position[X_AXIS] + duplicate_extruder_x_offset,
// 14714               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
// 14715               planner.max_feedrate_mm_s[X_AXIS], 1
// 14716             );
// 14717             SYNC_PLAN_POSITION_KINEMATIC();
// 14718             stepper.synchronize();
// 14719             extruder_duplication_enabled = true;
// 14720             active_extruder_parked = false;
// 14721             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14722               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
// 14723             #endif
// 14724           }
// 14725           else {
// 14726             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14727               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
// 14728             #endif
// 14729           }
// 14730           break;
// 14731       }
// 14732     return false;
// 14733   }
// 14734 
// 14735 #endif // DUAL_X_CARRIAGE
// 14736 
// 14737 /**
// 14738  * Prepare a single move and get ready for the next one
// 14739  *
// 14740  * This may result in several calls to planner.buffer_line to
// 14741  * do smaller moves for DELTA, SCARA, mesh moves, etc.
// 14742  *
// 14743  * Make sure current_position[E] and destination[E] are good
// 14744  * before calling or cold/lengthy extrusion may get missed.
// 14745  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function _Z27prepare_move_to_destinationv
        THUMB
// 14746 void prepare_move_to_destination() {
_Z27prepare_move_to_destinationv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 14747   clamp_to_software_endstops(destination);
        LDR.W    R4,??DataTable175
        ADD      R0,R4,#+24
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14748   refresh_cmd_timeout();
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
// 14749 
// 14750   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 14751 
// 14752     if (!DEBUGGING(DRYRUN)) {
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??prepare_move_to_destination_0
// 14753       if (destination[E_AXIS] != current_position[E_AXIS]) {
        LDR      R5,[R4, #+36]
        MOV      R0,R5
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_0
// 14754         #if ENABLED(PREVENT_COLD_EXTRUSION)
// 14755           if (thermalManager.tooColdToExtrude(active_extruder)) {
        LDRB     R0,[R4, #+3]
          CFI FunCall _ZN11Temperature16tooColdToExtrudeEh
        BL       _ZN11Temperature16tooColdToExtrudeEh
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_1
// 14756             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        STR      R5,[R4, #+20]
// 14757             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable183
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14758             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
        ADR.W    R0,`?<Constant " cold extrusion preve...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14759           }
// 14760         #endif // PREVENT_COLD_EXTRUSION
// 14761         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 14762           if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
??prepare_move_to_destination_1:
        LDR      R0,[R4, #+36]
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R1,R0,#0x80000000
        LDRB     R0,[R4, #+3]
        LDR.W    R2,??DataTable183_1
        LDR      R0,[R2, R0, LSL #+2]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.W    R1,??DataTable183_2  ;; 0x447a0001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??prepare_move_to_destination_0
// 14763             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        LDR      R0,[R4, #+36]
        STR      R0,[R4, #+20]
// 14764             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable183
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14765             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        ADR.W    R0,`?<Constant " too long extrusion p...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14766           }
// 14767         #endif // PREVENT_LENGTHY_EXTRUDE
// 14768       }
// 14769     }
// 14770 
// 14771   #endif
// 14772 
// 14773   #if ENABLED(DUAL_X_CARRIAGE)
// 14774     if (dual_x_carriage_unpark()) return;
// 14775   #endif
// 14776   
// 14777 #if 0
// 14778   if (
// 14779     #if UBL_SEGMENTED
// 14780       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
// 14781     #elif IS_KINEMATIC
// 14782       prepare_kinematic_move_to(destination)
// 14783     #else
// 14784       prepare_move_to_destination_cartesian()
// 14785     #endif
// 14786   ) return;
// 14787 #endif
// 14788 
// 14789   if((BED_LEVELING_METHOD &AUTO_BED_LEVELING_UBL) && (MACHINETPYE == DELTA /*|| ENABLED(SEGMENT_LEVELED_MOVES)*/))
??prepare_move_to_destination_0:
        LDR.W    R0,??DataTable175_1
        ADD      R1,R0,#+64
        LDRSH    R1,[R1, #+24]
        LDRB     R0,[R0, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??prepare_move_to_destination_2
        CMP      R1,#+2
        BNE.N    ??prepare_move_to_destination_2
// 14790   {
// 14791     if(ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)))return;
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable184  ;; 0x47ae147b
        LDR.W    R3,??DataTable185  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R4,#+24
          CFI FunCall _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        BL       _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_3
        POP      {R0,R4,R5,PC}
// 14792   } 
// 14793   else if(MACHINETPYE & IS_KINEMATIC)
??prepare_move_to_destination_2:
        MOVW     R0,#+770
        TST      R1,R0
        BEQ.N    ??prepare_move_to_destination_4
// 14794   {
// 14795     if(prepare_kinematic_move_to(destination))return;
        ADD      R0,R4,#+24
          CFI FunCall _Z25prepare_kinematic_move_toRA4_Kf
        BL       _Z25prepare_kinematic_move_toRA4_Kf
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_3
        POP      {R0,R4,R5,PC}
// 14796   }  
// 14797   else//if(MACHINETPYE & IS_CARTESIAN)
// 14798   {
// 14799     if(prepare_move_to_destination_cartesian())return;
??prepare_move_to_destination_4:
          CFI FunCall _Z37prepare_move_to_destination_cartesianv
        BL       _Z37prepare_move_to_destination_cartesianv
        CMP      R0,#+0
        BNE.N    ??prepare_move_to_destination_5
// 14800   }
// 14801 
// 14802   set_current_from_destination();
??prepare_move_to_destination_3:
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 14803 }
??prepare_move_to_destination_5:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock81

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable169:
        DC32     0x42b40000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " cold extrusion preve...">`:
        DC8 " cold extrusion prevented\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " too long extrusion p...">`:
        DC8 " too long extrusion prevented\012"
        DC8 0
// 14804 
// 14805 #if ENABLED(ARC_SUPPORT)
// 14806 
// 14807   #if N_ARC_CORRECTION < 1
// 14808     #undef N_ARC_CORRECTION
// 14809     #define N_ARC_CORRECTION 1
// 14810   #endif
// 14811 
// 14812   /**
// 14813    * Plan an arc in 2 dimensions
// 14814    *
// 14815    * The arc is approximated by generating many small linear segments.
// 14816    * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
// 14817    * Arcs should only be made relatively large (over 5mm), as larger arcs with
// 14818    * larger segments will tend to be more efficient. Your slicer should have
// 14819    * options for G2/G3 arc generation. In future these options may be GCode tunable.
// 14820    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function _Z8plan_arcRA4_KfRA2_S_b
        THUMB
// 14821   void plan_arc(
// 14822     const float (&cart)[XYZE], // Destination position
// 14823     const float (&offset)[2], // Center of rotation relative to current_position
// 14824     const bool clockwise      // Clockwise?
// 14825   ) {
_Z8plan_arcRA4_KfRA2_S_b:
        PUSH     {R0,R1,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+52
          CFI CFA R13+96
        MOV      R4,R2
// 14826     #if ENABLED(CNC_WORKSPACE_PLANES)
// 14827       AxisEnum p_axis, q_axis, l_axis;
// 14828       switch (workspace_plane) {
// 14829         default:
// 14830         case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
// 14831         case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
// 14832         case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
// 14833       }
// 14834     #else
// 14835       constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
// 14836     #endif
// 14837 
// 14838     // Radius vector from center to current location
// 14839     float r_P = -offset[0], r_Q = -offset[1];
        MOV      R0,R1
        LDR      R5,[R0, #+0]
        EOR      R5,R5,#0x80000000
        LDR      R6,[R0, #+4]
        EOR      R6,R6,#0x80000000
// 14840 
// 14841     const float radius = HYPOT(r_P, r_Q),
        MOV      R9,R5
        MOV      R10,#+2
        MOV      R7,#+1065353216
        MOV      R8,R7
        B.N      ??plan_arc_0
??plan_arc_1:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??plan_arc_0:
        LSLS     R0,R10,#+31
        BPL.N    ??plan_arc_2
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_2:
        LSRS     R10,R10,#+1
        BNE.N    ??plan_arc_1
        MOV      R11,R6
        MOV      R9,#+2
        MOV      R10,R7
        B.N      ??plan_arc_3
??plan_arc_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_3:
        LSLS     R0,R9,#+31
        BPL.N    ??plan_arc_5
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_5:
        LSRS     R9,R9,#+1
        BNE.N    ??plan_arc_4
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
        LDR.W    R0,??DataTable175
        LDR      R0,[R0, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 14842                 center_P = current_position[p_axis] - r_P,
// 14843                 center_Q = current_position[q_axis] - r_Q,
        LDR.W    R0,??DataTable175
        LDR      R0,[R0, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
// 14844                 rt_X = cart[p_axis] - center_P,
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+0]
        LDR      R1,[SP, #+24]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 14845                 rt_Y = cart[q_axis] - center_Q,
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+4]
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
// 14846                 linear_travel = cart[l_axis] - current_position[l_axis],
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+8]
        LDR.W    R1,??DataTable175
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
// 14847                 extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+12]
        LDR.W    R1,??DataTable175
        LDR      R1,[R1, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
// 14848 
// 14849     // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
// 14850     float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
        MOV      R0,R5
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R0,R6
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R11,R1
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R0,R6
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R11
          CFI FunCall atan2f
        BL       atan2f
        MOV      R9,R0
// 14851     if (angular_travel < 0) angular_travel += RADIANS(360);
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??plan_arc_6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable186  ;; 0x54442d18
        LDR.W    R3,??DataTable185_1  ;; 0x401921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 14852     if (clockwise) angular_travel -= RADIANS(360);
??plan_arc_6:
        CMP      R4,#+0
        BEQ.N    ??plan_arc_7
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable186  ;; 0x54442d18
        LDR.W    R3,??DataTable186_1  ;; 0xc01921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 14853 
// 14854     // Make a circle if the angular rotation is 0 and the target is current position
// 14855     if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
??plan_arc_7:
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR.W    R0,??DataTable175
        LDR      R0,[R0, #+8]
        LDR      R1,[SP, #+52]
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR.W    R0,??DataTable175
        LDR      R0,[R0, #+12]
        LDR      R1,[SP, #+52]
        LDR      R1,[R1, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
// 14856       angular_travel = RADIANS(360);
        LDR.W    R9,??DataTable186_2  ;; 0x40c90fdb
// 14857 
// 14858     const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
??plan_arc_8:
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        MOV      R10,#+2
        MOV      R4,R7
        B.N      ??plan_arc_9
??plan_arc_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_9:
        LSLS     R0,R10,#+31
        BPL.N    ??plan_arc_11
        MOV      R0,R4
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??plan_arc_11:
        LSRS     R10,R10,#+1
        BNE.N    ??plan_arc_10
        LDR      R0,[SP, #+0]
        BIC      R11,R0,#0x80000000
        MOV      R8,#+2
        MOV      R10,R7
        B.N      ??plan_arc_12
??plan_arc_13:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_12:
        LSLS     R0,R8,#+31
        BPL.N    ??plan_arc_14
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_14:
        LSRS     R8,R8,#+1
        BNE.N    ??plan_arc_13
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
// 14859     if (mm_of_travel < 0.001) return;
        LDR.W    R1,??DataTable186_3  ;; 0x3a83126f
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.W    ??plan_arc_15
// 14860 
// 14861     uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
          CFI FunCall floorf
        BL       floorf
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        UXTH     R0,R0
        STR      R0,[SP, #+12]
// 14862     NOLESS(segments, 1);
        CMP      R0,#+0
        BNE.N    ??plan_arc_16
        MOVS     R0,#+1
        STR      R0,[SP, #+12]
// 14863 
// 14864     /**
// 14865      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
// 14866      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
// 14867      *     r_T = [cos(phi) -sin(phi);
// 14868      *            sin(phi)  cos(phi)] * r ;
// 14869      *
// 14870      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
// 14871      * defined from the circle center to the initial position. Each line segment is formed by successive
// 14872      * vector rotations. This requires only two cos() and sin() computations to form the rotation
// 14873      * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
// 14874      * all double numbers are single precision on the Arduino. (True double precision will not have
// 14875      * round off issues for CNC applications.) Single precision error can accumulate to be greater than
// 14876      * tool precision in some cases. Therefore, arc path correction is implemented.
// 14877      *
// 14878      * Small angle approximation may be used to reduce computation overhead further. This approximation
// 14879      * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
// 14880      * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
// 14881      * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
// 14882      * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
// 14883      * issue for CNC machines with the single precision Arduino calculations.
// 14884      *
// 14885      * This approximation also allows plan_arc to immediately insert a line segment into the planner
// 14886      * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
// 14887      * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
// 14888      * This is important when there are successive arc motions.
// 14889      */
// 14890     // Vector rotation matrix values
// 14891     float raw[XYZE];
// 14892     const float theta_per_segment = angular_travel / segments,
??plan_arc_16:
        ADD      R0,SP,#+12
        LDRH     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R4,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+8]
// 14893                 linear_per_segment = linear_travel / segments,
        LDR      R0,[SP, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+32]
// 14894                 extruder_per_segment = extruder_travel / segments,
        LDR      R0,[SP, #+4]
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+28]
// 14895                 sin_T = theta_per_segment,
// 14896                 cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
        LDR      R4,[SP, #+8]
        MOV      R8,#+2
        B.N      ??plan_arc_17
??plan_arc_18:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??plan_arc_17:
        LSLS     R0,R8,#+31
        BPL.N    ??plan_arc_19
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??plan_arc_19:
        LSRS     R8,R8,#+1
        BNE.N    ??plan_arc_18
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable186_5  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable186_6  ;; 0x3ff00000
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+4]
// 14897 
// 14898     // Initialize the linear axis
// 14899     raw[l_axis] = current_position[l_axis];
        ADD      R4,SP,#+36
        LDR.W    R0,??DataTable175
        LDR      R0,[R0, #+16]
        STR      R0,[R4, #+8]
// 14900 
// 14901     // Initialize the extruder axis
// 14902     raw[E_AXIS] = current_position[E_AXIS];
        LDR.W    R0,??DataTable175
        LDR      R0,[R0, #+20]
        STR      R0,[R4, #+12]
// 14903 
// 14904     const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
        LDR.W    R0,??DataTable175
        LDRSH    R0,[R0, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable175
        LDR      R1,[R1, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable184  ;; 0x47ae147b
        LDR.W    R3,??DataTable185  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+16]
// 14905 
// 14906     millis_t next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R7,R0,#+200
// 14907 
// 14908     #if N_ARC_CORRECTION > 1
// 14909       int8_t arc_recalc_count = N_ARC_CORRECTION;
        MOV      R9,#+25
// 14910     #endif
// 14911 
// 14912     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14913       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14914       const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
// 14915                   inverse_secs = inv_segment_length * fr_mm_s;
// 14916       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14917             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14918     #endif
// 14919 
// 14920     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
        MOV      R8,#+1
        B.N      ??plan_arc_20
// 14921 
// 14922       thermalManager.manage_heater();
// 14923       if (ELAPSED(millis(), next_idle_ms)) {
// 14924         next_idle_ms = millis() + 200UL;
// 14925         idle();
// 14926       }
// 14927 
// 14928       #if N_ARC_CORRECTION > 1
// 14929         if (--arc_recalc_count) {
// 14930           // Apply vector rotation matrix to previous r_P / 1
// 14931           const float r_new_Y = r_P * sin_T + r_Q * cos_T;
// 14932           r_P = r_P * cos_T - r_Q * sin_T;
// 14933           r_Q = r_new_Y;
// 14934         }
// 14935         else
// 14936       #endif
// 14937       {
// 14938         #if N_ARC_CORRECTION > 1
// 14939           arc_recalc_count = N_ARC_CORRECTION;
??plan_arc_21:
        MOV      R9,#+25
// 14940         #endif
// 14941 
// 14942         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
// 14943         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
// 14944         // To reduce stuttering, the sin and cos could be computed at different times.
// 14945         // For now, compute both at the same time.
// 14946         const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
        MOV      R0,R8
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
          CFI FunCall cosf
        BL       cosf
        MOV      R6,R0
        MOV      R0,R5
          CFI FunCall sinf
        BL       sinf
        MOV      R10,R0
// 14947         r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
        LDR      R0,[SP, #+56]
        LDR      R0,[R0, #+4]
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+56]
        LDR      R11,[R0, #+0]
        LDR      R0,[SP, #+0]
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        MOV      R0,R11
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 14948         r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        EOR      R0,R0,#0x80000000
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 14949       }
// 14950 
// 14951       // Update raw location
// 14952       raw[p_axis] = center_P + r_P;
??plan_arc_22:
        LDR      R0,[SP, #+24]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+36]
// 14953       raw[q_axis] = center_Q + r_Q;
        LDR      R0,[SP, #+20]
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+4]
// 14954       raw[l_axis] += linear_per_segment;
        LDR      R0,[R4, #+8]
        LDR      R1,[SP, #+32]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+8]
// 14955       raw[E_AXIS] += extruder_per_segment;
        LDR      R0,[R4, #+12]
        LDR      R1,[SP, #+28]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+12]
// 14956 
// 14957       clamp_to_software_endstops(raw);
        ADD      R0,SP,#+36
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14958 
// 14959       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14960         // For SCARA scale the feed rate from mm/s to degrees/s
// 14961         // i.e., Complete the angular vector in the given time.
// 14962         inverse_kinematics(raw);
// 14963         ADJUST_DELTA(raw);
// 14964         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14965         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14966       #else
// 14967         planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
        LDR.W    R0,??DataTable175
        LDRB     R2,[R0, #+3]
        ADD      R1,SP,#+16
        ADD      R0,SP,#+36
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        ADD      R8,R8,#+1
        UXTH     R8,R8
??plan_arc_20:
        LDR      R0,[SP, #+12]
        CMP      R8,R0
        BGE.N    ??plan_arc_23
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R7
        BMI.N    ??plan_arc_24
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R7,R0,#+200
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??plan_arc_24:
        SUB      R9,R9,#+1
        SXTB     R9,R9
        CMP      R9,#+0
        BEQ.N    ??plan_arc_21
        LDR      R0,[SP, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R6,R10
        B.N      ??plan_arc_22
// 14968       #endif
// 14969     }
// 14970 
// 14971     // Ensure last segment arrives at target location.
// 14972     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14973       inverse_kinematics(cart);
// 14974       ADJUST_DELTA(cart);
// 14975       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14976     #else
// 14977       planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
??plan_arc_23:
        LDR.N    R0,??DataTable175
        LDRB     R2,[R0, #+3]
        ADD      R1,SP,#+16
        LDR      R0,[SP, #+52]
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 14978     #endif
// 14979 
// 14980     // As far as the parser is concerned, the position is now == target. In reality the
// 14981     // motion control system might still be processing the action and the real tool position
// 14982     // in any intermediate location.
// 14983     set_current_from_destination();
          CFI FunCall _Z28set_current_from_destinationv
        BL       _Z28set_current_from_destinationv
// 14984   } // plan_arc
??plan_arc_15:
        ADD      SP,SP,#+60
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock82
// 14985 
// 14986 #endif // ARC_SUPPORT
// 14987 
// 14988 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 14989 
// 14990   void plan_cubic_move(const float (&offset)[4]) {
// 14991     cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
// 14992 
// 14993     // As far as the parser is concerned, the position is now == destination. In reality the
// 14994     // motion control system might still be processing the action and the real tool position
// 14995     // in any intermediate location.
// 14996     set_current_from_destination();
// 14997   }
// 14998 
// 14999 #endif // BEZIER_CURVE_SUPPORT
// 15000 
// 15001 #if ENABLED(USE_CONTROLLER_FAN)
// 15002 
// 15003   void controllerFan() {
// 15004     static millis_t lastMotorOn = 0, // Last time a motor was turned on
// 15005                     nextMotorCheck = 0; // Last time the state was checked
// 15006     const millis_t ms = millis();
// 15007     if (ELAPSED(ms, nextMotorCheck)) {
// 15008       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
// 15009       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
// 15010           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
// 15011           #if E_STEPPERS > 1
// 15012             || E1_ENABLE_READ == E_ENABLE_ON
// 15013             #if HAS_X2_ENABLE
// 15014               || X2_ENABLE_READ == X_ENABLE_ON
// 15015             #endif
// 15016             #if E_STEPPERS > 2
// 15017               || E2_ENABLE_READ == E_ENABLE_ON
// 15018               #if E_STEPPERS > 3
// 15019                 || E3_ENABLE_READ == E_ENABLE_ON
// 15020                 #if E_STEPPERS > 4
// 15021                   || E4_ENABLE_READ == E_ENABLE_ON
// 15022                 #endif // E_STEPPERS > 4
// 15023               #endif // E_STEPPERS > 3
// 15024             #endif // E_STEPPERS > 2
// 15025           #endif // E_STEPPERS > 1
// 15026       ) {
// 15027         lastMotorOn = ms; //... set time to NOW so the fan will turn on
// 15028       }
// 15029 
// 15030       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
// 15031       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
// 15032 
// 15033       // allows digital or PWM fan output to be used (see M42 handling)
// 15034       WRITE(CONTROLLER_FAN_PIN, speed);
// 15035       analogWrite(CONTROLLER_FAN_PIN, speed);
// 15036     }
// 15037   }
// 15038 
// 15039 #endif // USE_CONTROLLER_FAN
// 15040 
// 15041 #if 1//ENABLED(MORGAN_SCARA)
// 15042 
// 15043   /**
// 15044    * Morgan SCARA Forward Kinematics. Results in cartes[].
// 15045    * Maths and first version by QHARLEY.
// 15046    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 15047    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function _Z24forward_kinematics_SCARARKfS0_
        THUMB
// 15048   void forward_kinematics_SCARA(const float &a, const float &b) {
_Z24forward_kinematics_SCARARKfS0_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R8,R0
        MOV      R10,R1
// 15049 
// 15050     float a_sin = sin(RADIANS(a)) * L1,
        MOVS     R6,#+0
        LDR.W    R7,??DataTable186_7  ;; 0x4062c000
        LDR.W    R4,??DataTable186  ;; 0x54442d18
        LDR.W    R5,??DataTable186_8  ;; 0x400921fb
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable186_9  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 15051           a_cos = cos(RADIANS(a)) * L1,
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable186_9  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R8,R0
// 15052           b_sin = sin(RADIANS(b)) * L2,
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable186_9  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall sin
        BL       sin
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R11,R0
// 15053           b_cos = cos(RADIANS(b)) * L2;
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R6
        LDR.W    R3,??DataTable186_9  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall cos
        BL       cos
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
// 15054 
// 15055     cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
        LDR.W    R4,??DataTable186_10
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable186_11  ;; 0x42c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+72]
// 15056     cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
        MOV      R0,R9
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable187  ;; 0xc2600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+76]
// 15057 
// 15058     /*
// 15059       SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
// 15060       SERIAL_ECHOPAIR(" b=", b);
// 15061       SERIAL_ECHOPAIR(" a_sin=", a_sin);
// 15062       SERIAL_ECHOPAIR(" a_cos=", a_cos);
// 15063       SERIAL_ECHOPAIR(" b_sin=", b_sin);
// 15064       SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
// 15065       SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
// 15066       SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
// 15067     //
// 15068     */
// 15069   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock83
// 15070 
// 15071   /**
// 15072    * Morgan SCARA Inverse Kinematics. Results in delta[].
// 15073    *
// 15074    * See http://forums.reprap.org/read.php?185,283327
// 15075    *
// 15076    * Maths and first version by QHARLEY.
// 15077    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 15078    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function _Z31inverse_kinematics_MORGAN_SCARAPKf
        THUMB
// 15079   void inverse_kinematics_MORGAN_SCARA(const float raw[XYZ]) {
_Z31inverse_kinematics_MORGAN_SCARAPKf:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 15080 
// 15081     static float C2, S2, SK1, SK2, THETA, PSI;
// 15082 
// 15083     float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable186_12  ;; 0xc2c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
// 15084           sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
        LDR      R0,[SP, #+0]
        LDR      R1,[R0, #+4]
        LDR.W    R0,??DataTable186_13  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
// 15085 
// 15086     if (L1 == L2)
// 15087       C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
        MOV      R7,R5
        MOV      R8,#+2
        MOV      R11,#+1065353216
        MOV      R4,R11
        B.N      ??inverse_kinematics_MORGAN_SCARA_0
??inverse_kinematics_MORGAN_SCARA_1:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_MORGAN_SCARA_0:
        LSLS     R0,R8,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
        MOV      R0,R4
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??inverse_kinematics_MORGAN_SCARA_2:
        LSRS     R8,R8,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
        MOV      R7,R6
        MOV      R9,#+2
        MOV      R8,R11
        B.N      ??inverse_kinematics_MORGAN_SCARA_3
??inverse_kinematics_MORGAN_SCARA_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_MORGAN_SCARA_3:
        LSLS     R0,R9,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_MORGAN_SCARA_5:
        LSRS     R9,R9,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
        LDR.N    R7,??DataTable175
        MOV      R0,R4
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[R7, #+128]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??DataTable187_1  ;; 0xbf800000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR.W    R4,??DataTable187_2
        STR      R8,[R4, #+0]
// 15088     else
// 15089       C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
// 15090 
// 15091     S2 = SQRT(1 - sq(C2));
        MOV      R9,R8
        MOV      R10,#+2
        B.N      ??inverse_kinematics_MORGAN_SCARA_6
??inverse_kinematics_MORGAN_SCARA_7:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_MORGAN_SCARA_6:
        LSLS     R0,R10,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
        MOV      R0,R11
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_MORGAN_SCARA_8:
        LSRS     R10,R10,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
        MOV      R0,#+1065353216
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R9,R0
        STR      R9,[R4, #+4]
// 15092 
// 15093     // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
// 15094     SK1 = L1 + L2 * C2;
        LDR.W    R10,??DataTable187_3  ;; 0x43160000
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R11,R0
        STR      R11,[R4, #+8]
// 15095 
// 15096     // Rotated Arm2 gives the distance from Arm1 to Arm2
// 15097     SK2 = L2 * S2;
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+12]
// 15098 
// 15099     // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
// 15100     THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
        MOV      R1,R0
        MOV      R0,R11
          CFI FunCall atan2f
        BL       atan2f
        MOV      R10,R0
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall atan2f
        BL       atan2f
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+16]
// 15101 
// 15102     // Angle of Arm2
// 15103     PSI = ATAN2(S2, C2);
        MOV      R1,R8
        MOV      R0,R9
          CFI FunCall atan2f
        BL       atan2f
        MOV      R6,R0
        STR      R6,[R4, #+20]
// 15104 
// 15105     delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
        LDR      R8,[R4, #+16]
        MOVS     R4,#+0
        LDR.W    R5,??DataTable186_9  ;; 0x40668000
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable186  ;; 0x54442d18
        LDR.W    R3,??DataTable186_8  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+80]
// 15106     delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
        MOV      R0,R8
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable186  ;; 0x54442d18
        LDR.W    R3,??DataTable186_8  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+84]
// 15107     delta[C_AXIS] = raw[Z_AXIS];
        LDR      R0,[SP, #+0]
        LDR      R0,[R0, #+8]
        STR      R0,[R7, #+88]
// 15108 
// 15109     /*
// 15110       DEBUG_POS("SCARA IK", raw);
// 15111       DEBUG_POS("SCARA IK", delta);
// 15112       SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
// 15113       SERIAL_ECHOPAIR(",", sy);
// 15114       SERIAL_ECHOPAIR(" C2=", C2);
// 15115       SERIAL_ECHOPAIR(" S2=", S2);
// 15116       SERIAL_ECHOPAIR(" Theta=", THETA);
// 15117       SERIAL_ECHOLNPAIR(" Phi=", PHI);
// 15118     //
// 15119     */
// 15120   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock84
// 15121 
// 15122 #endif // MORGAN_SCARA
// 15123 
// 15124 #if ENABLED(TEMP_STAT_LEDS)
// 15125 
// 15126   static bool red_led = false;
// 15127   static millis_t next_status_led_update_ms = 0;
// 15128 
// 15129   void handle_status_leds(void) {
// 15130     if (ELAPSED(millis(), next_status_led_update_ms)) {
// 15131       next_status_led_update_ms += 500; // Update every 0.5s
// 15132       float max_temp = 0.0;
// 15133       //#if HAS_TEMP_BED
// 15134       if(HAS_TEMP_BED)
// 15135         max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
// 15136       //#endif
// 15137       HOTEND_LOOP()
// 15138         max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
// 15139       const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
// 15140       if (new_led != red_led) {
// 15141         red_led = new_led;
// 15142         #if PIN_EXISTS(STAT_LED_RED)
// 15143           WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
// 15144           #if PIN_EXISTS(STAT_LED_BLUE)
// 15145             WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
// 15146           #endif
// 15147         #else
// 15148           WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
// 15149         #endif
// 15150       }
// 15151     }
// 15152   }
// 15153 
// 15154 #endif
// 15155 
// 15156 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15157 
// 15158   void handle_filament_runout() {
// 15159     if (!filament_ran_out) {
// 15160       filament_ran_out = true;
// 15161       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
// 15162       stepper.synchronize();
// 15163     }
// 15164   }
// 15165 
// 15166 #endif // FILAMENT_RUNOUT_SENSOR
// 15167 
// 15168 #if ENABLED(FAST_PWM_FAN)
// 15169 
// 15170   void setPwmFrequency(uint8_t pin, int val) {
// 15171     val &= 0x07;
// 15172     switch (digitalPinToTimer(pin)) {
// 15173       #ifdef TCCR0A
// 15174         #if !AVR_AT90USB1286_FAMILY
// 15175           case TIMER0A:
// 15176         #endif
// 15177         case TIMER0B:                           //_SET_CS(0, val);
// 15178                                                   break;
// 15179       #endif
// 15180       #ifdef TCCR1A
// 15181         case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
// 15182                                                   break;
// 15183       #endif
// 15184       #if defined(TCCR2) || defined(TCCR2A)
// 15185         #ifdef TCCR2
// 15186           case TIMER2:
// 15187         #endif
// 15188         #ifdef TCCR2A
// 15189           case TIMER2A: case TIMER2B:
// 15190         #endif
// 15191                                                   _SET_CS(2, val); break;
// 15192       #endif
// 15193       #ifdef TCCR3A
// 15194         case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
// 15195       #endif
// 15196       #ifdef TCCR4A
// 15197         case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
// 15198       #endif
// 15199       #ifdef TCCR5A
// 15200         case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
// 15201       #endif
// 15202     }
// 15203   }
// 15204 
// 15205 #endif // FAST_PWM_FAN
// 15206 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function _Z19enable_all_steppersv
        THUMB
// 15207 void enable_all_steppers() {
_Z19enable_all_steppersv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15208   enable_X();
        LDR.W    R4,??DataTable187_4
        LDR.W    R5,??DataTable187_5
        LDR.W    R6,??DataTable184_1
        LDRSB    R2,[R6, #+260]
        LDRH     R1,[R5, #+4]
        LDR      R0,[R4, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15209   enable_Y();
        ADD      R6,R6,#+260
        LDRSB    R2,[R6, #+1]
        LDRH     R1,[R5, #+14]
        LDR      R0,[R4, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15210   enable_Z();
        LDRSB    R2,[R6, #+2]
        LDRH     R1,[R5, #+24]
        LDR      R0,[R4, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRSB    R2,[R6, #+2]
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15211   enable_E0();
        LDRSB    R2,[R6, #+3]
        LDRH     R1,[R5, #+34]
        LDR      R0,[R4, #+68]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15212   enable_E1();
        LDRSB    R2,[R6, #+3]
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock85
// 15213   enable_E2();
// 15214   enable_E3();
// 15215   enable_E4();
// 15216 }
// 15217 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function _Z18disable_e_steppersv
        THUMB
// 15218 void disable_e_steppers() {
_Z18disable_e_steppersv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15219   disable_E0();
        LDR.N    R4,??DataTable175_1
        LDRB     R0,[R4, #+263]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R5,??DataTable187_4
        LDR.W    R6,??DataTable187_5
        SXTB     R2,R2
        LDRH     R1,[R6, #+34]
        LDR      R0,[R5, #+68]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15220   disable_E1();
        LDRB     R0,[R4, #+263]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+40]
        LDR      R0,[R5, #+80]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock86
// 15221   disable_E2();
// 15222   disable_E3();
// 15223   disable_E4();
// 15224 }
// 15225 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function _Z20disable_all_steppersv
        THUMB
// 15226 void disable_all_steppers() {
_Z20disable_all_steppersv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 15227   disable_X();
        LDR.N    R7,??DataTable175_1
        LDRB     R0,[R7, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R4,??DataTable187_4
        LDR.W    R5,??DataTable187_5
        SXTB     R2,R2
        LDRH     R1,[R5, #+4]
        LDR      R0,[R4, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.W    R6,??DataTable186_10
        MOVS     R0,#+0
        STRB     R0,[R6, #+4]
// 15228   disable_Y();
        ADD      R7,R7,#+260
        LDRB     R0,[R7, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R5, #+14]
        LDR      R0,[R4, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+5]
// 15229   disable_Z();
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R5, #+24]
        LDR      R0,[R4, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+6]
// 15230   disable_e_steppers();
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
          CFI EndBlock cfiBlock87
// 15231 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_1:
        DC32     mksCfg
// 15232 
// 15233 #if ENABLED(MONITOR_DRIVER_STATUS)
// 15234   /*
// 15235    * Check for over temperature or short to ground error flags.
// 15236    * Report and log warning of overtemperature condition.
// 15237    * Reduce driver current in a persistent otpw condition.
// 15238    * Keep track of otpw counter so we don't reduce current on a single instance,
// 15239    * and so we don't repeatedly report warning before the condition is cleared.
// 15240    */
// 15241 
// 15242   struct TMC_driver_data {
// 15243     uint32_t drv_status;
// 15244     bool is_otpw;
// 15245     bool is_ot;
// 15246     bool is_error;
// 15247   };
// 15248   #if ENABLED(HAVE_TMC2130)
// 15249     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
// 15250     static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
// 15251     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
// 15252       constexpr uint32_t OTPW_bm = 0x4000000UL;
// 15253       constexpr uint8_t OTPW_bp = 26;
// 15254       constexpr uint32_t OT_bm = 0x2000000UL;
// 15255       constexpr uint8_t OT_bp = 25;
// 15256       constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
// 15257       constexpr uint8_t DRIVER_ERROR_bp = 1;
// 15258       TMC_driver_data data;
// 15259       data.drv_status = st.DRV_STATUS();
// 15260       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 15261       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 15262       data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
// 15263       return data;
// 15264     }
// 15265   #endif
// 15266   #if ENABLED(HAVE_TMC2208)
// 15267     static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
// 15268     static uint8_t get_status_response(TMC2208Stepper &st) {
// 15269       uint32_t drv_status = st.DRV_STATUS();
// 15270       uint8_t gstat = st.GSTAT();
// 15271       uint8_t response = 0;
// 15272       response |= (drv_status >> (31-3)) & 0b1000;
// 15273       response |= gstat & 0b11;
// 15274       return response;
// 15275     }
// 15276     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
// 15277       constexpr uint32_t OTPW_bm = 0b1ul;
// 15278       constexpr uint8_t OTPW_bp = 0;
// 15279       constexpr uint32_t OT_bm = 0b10ul;
// 15280       constexpr uint8_t OT_bp = 1;
// 15281       TMC_driver_data data;
// 15282       data.drv_status = st.DRV_STATUS();
// 15283       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 15284       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 15285       data.is_error = st.drv_err();
// 15286       return data;
// 15287     }
// 15288   #endif
// 15289 
// 15290   template<typename TMC>
// 15291   uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
// 15292     TMC_driver_data data = get_driver_data(st);
// 15293 
// 15294     #if ENABLED(STOP_ON_ERROR)
// 15295       if (data.is_error) {
// 15296         SERIAL_EOL();
// 15297         SERIAL_ECHO(axisID);
// 15298         SERIAL_ECHO(" driver error detected:");
// 15299         if (data.is_ot) SERIAL_ECHO("\novertemperature");
// 15300         if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
// 15301         if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
// 15302         SERIAL_EOL();
// 15303         #if ENABLED(TMC_DEBUG)
// 15304           gcode_M122();
// 15305         #endif
// 15306         kill(PSTR("Driver error"));
// 15307       }
// 15308     #endif
// 15309 
// 15310     // Report if a warning was triggered
// 15311     if (data.is_otpw && otpw_cnt==0) {
// 15312       char timestamp[10];
// 15313       duration_t elapsed = print_job_timer.duration();
// 15314       const bool has_days = (elapsed.value > 60*60*24L);
// 15315       (void)elapsed.toDigital(timestamp, has_days);
// 15316       SERIAL_EOL();
// 15317       SERIAL_ECHO(timestamp);
// 15318       SERIAL_ECHOPGM(": ");
// 15319       SERIAL_ECHO(axisID);
// 15320       SERIAL_ECHOPGM(" driver overtemperature warning! (");
// 15321       SERIAL_ECHO(st.getCurrent());
// 15322       SERIAL_ECHOLN("mA)");
// 15323     }
// 15324     #if CURRENT_STEP_DOWN > 0
// 15325       // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
// 15326       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
// 15327         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
// 15328         #if ENABLED(REPORT_CURRENT_CHANGE)
// 15329           SERIAL_ECHO(axisID);
// 15330           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
// 15331         #endif
// 15332       }
// 15333     #endif
// 15334 
// 15335     if (data.is_otpw) {
// 15336       otpw_cnt++;
// 15337       st.flag_otpw = true;
// 15338     }
// 15339     else if (otpw_cnt>0) otpw_cnt--;
// 15340 
// 15341     if (report_tmc_status) {
// 15342       const uint32_t pwm_scale = get_pwm_scale(st);
// 15343       SERIAL_ECHO(axisID);
// 15344       SERIAL_ECHOPAIR(":", pwm_scale);
// 15345       SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
// 15346       SERIAL_ECHO("| ");
// 15347       if (data.is_error) SERIAL_ECHO('E');
// 15348       else if (data.is_ot) SERIAL_ECHO('O');
// 15349       else if (data.is_otpw) SERIAL_ECHO('W');
// 15350       else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
// 15351       else if (st.flag_otpw) SERIAL_ECHO('F');
// 15352       SERIAL_ECHO("\t");
// 15353     }
// 15354 
// 15355     return otpw_cnt;
// 15356   }
// 15357 
// 15358   void monitor_tmc_driver() {
// 15359     static millis_t next_cOT = 0;
// 15360     if (ELAPSED(millis(), next_cOT)) {
// 15361       next_cOT = millis() + 500;
// 15362       #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15363         static uint8_t x_otpw_cnt = 0;
// 15364         x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
// 15365       #endif
// 15366       #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15367         static uint8_t y_otpw_cnt = 0;
// 15368         y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
// 15369       #endif
// 15370       #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15371         static uint8_t z_otpw_cnt = 0;
// 15372         z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
// 15373       #endif
// 15374       #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
// 15375         static uint8_t x2_otpw_cnt = 0;
// 15376         x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
// 15377       #endif
// 15378       #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
// 15379         static uint8_t y2_otpw_cnt = 0;
// 15380         y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
// 15381       #endif
// 15382       #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
// 15383         static uint8_t z2_otpw_cnt = 0;
// 15384         z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
// 15385       #endif
// 15386       #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15387         static uint8_t e0_otpw_cnt = 0;
// 15388         e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
// 15389       #endif
// 15390       #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
// 15391         static uint8_t e1_otpw_cnt = 0;
// 15392         e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
// 15393       #endif
// 15394       #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
// 15395         static uint8_t e2_otpw_cnt = 0;
// 15396         e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
// 15397       #endif
// 15398       #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
// 15399         static uint8_t e3_otpw_cnt = 0;
// 15400         e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
// 15401       #endif
// 15402       #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
// 15403         static uint8_t e4_otpw_cnt = 0;
// 15404         e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
// 15405       #endif
// 15406 
// 15407       if (report_tmc_status) SERIAL_EOL();
// 15408     }
// 15409   }
// 15410 
// 15411 #endif // MONITOR_DRIVER_STATUS
// 15412 
// 15413 /**
// 15414  * Manage several activities:
// 15415  *  - Check for Filament Runout
// 15416  *  - Keep the command buffer full
// 15417  *  - Check for maximum inactive time between commands
// 15418  *  - Check for maximum inactive time between stepper commands
// 15419  *  - Check if pin CHDK needs to go LOW
// 15420  *  - Check for KILL button held down
// 15421  *  - Check for HOME button held down
// 15422  *  - Check if cooling fan needs to be switched on
// 15423  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
// 15424  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function _Z17manage_inactivityb
        THUMB
// 15425 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
_Z17manage_inactivityb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R5,R0
// 15426 
// 15427   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15428     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
// 15429       handle_filament_runout();
// 15430   #endif
// 15431 
// 15432   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R0,??DataTable184_2
        LDRB     R0,[R0, #+2]
        CMP      R0,#+4
        BGE.N    ??manage_inactivity_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 15433 
// 15434   const millis_t ms = millis();
??manage_inactivity_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
// 15435 
// 15436   if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
        LDR.W    R4,??DataTable186_10
        LDR      R0,[R4, #+96]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_1
        LDR      R1,[R4, #+92]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_1
// 15437     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable184_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15438     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
        LDR.W    R0,??DataTable184_4
        LDR      R1,[R0, #+0]
        ADR.W    R0,`?<Constant "KILL caused by too mu...">`
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.W    R0,??DataTable184_5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15439     kill(PSTR(MSG_KILLED));
        ADR.W    R0,`?<Constant "KILLED. ">`
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 15440   }
// 15441 
// 15442   // Prevent steppers timing-out in the middle of M600
// 15443   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
// 15444     #define MOVE_AWAY_TEST !move_away_flag
// 15445   #else
// 15446     #define MOVE_AWAY_TEST true
// 15447   #endif
// 15448 
// 15449   if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
// 15450       && !ignore_stepper_queue && !planner.blocks_queued()) {
??manage_inactivity_1:
        LDR      R0,[R4, #+100]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_2
        LDR      R1,[R4, #+92]
        SUBS     R1,R6,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_2
        CMP      R5,#+0
        BNE.N    ??manage_inactivity_2
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??manage_inactivity_2
// 15451     #if ENABLED(DISABLE_INACTIVE_X)
// 15452       disable_X();
        LDR.W    R7,??DataTable184_1
        LDRB     R0,[R7, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.W    R5,??DataTable187_4
        LDR.W    R6,??DataTable187_5
        SXTB     R2,R2
        LDRH     R1,[R6, #+4]
        LDR      R0,[R5, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
// 15453     #endif
// 15454     #if ENABLED(DISABLE_INACTIVE_Y)
// 15455       disable_Y();
        ADD      R7,R7,#+260
        LDRB     R0,[R7, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+14]
        LDR      R0,[R5, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
// 15456     #endif
// 15457     #if ENABLED(DISABLE_INACTIVE_Z)
// 15458       disable_Z();
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+24]
        LDR      R0,[R5, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R7, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+40]
        LDR      R0,[R5, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 15459     #endif
// 15460     #if ENABLED(DISABLE_INACTIVE_E)
// 15461       disable_e_steppers();
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
// 15462     #endif
// 15463     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 15464       ubl.lcd_map_control = defer_return_to_status = false;
// 15465     #endif
// 15466   }
// 15467 
// 15468   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
// 15469     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
// 15470       chdkActive = false;
// 15471       WRITE(CHDK, LOW);
// 15472     }
// 15473   #endif
// 15474 
// 15475   #if HAS_KILL
// 15476 
// 15477     // Check if the kill button was pressed and wait just in case it was an accidental
// 15478     // key kill key press
// 15479     // -------------------------------------------------------------------------------
// 15480     static int killCount = 0;   // make the inactivity button a bit less responsive
// 15481     const int KILL_DELAY = 750;
// 15482     if (!READ(KILL_PIN))
// 15483       killCount++;
// 15484     else if (killCount > 0)
// 15485       killCount--;
// 15486 
// 15487     // Exceeded threshold and we can confirm that it was not accidental
// 15488     // KILL the machine
// 15489     // ----------------------------------------------------------------
// 15490     if (killCount >= KILL_DELAY) {
// 15491       SERIAL_ERROR_START();
// 15492       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
// 15493       kill(PSTR(MSG_KILLED));
// 15494     }
// 15495   #endif
// 15496 
// 15497   #if HAS_HOME
// 15498     // Check to see if we have to home, use poor man's debouncer
// 15499     // ---------------------------------------------------------
// 15500     static int homeDebounceCount = 0;   // poor man's debouncing count
// 15501     const int HOME_DEBOUNCE_DELAY = 2500;
// 15502     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
// 15503       if (!homeDebounceCount) {
// 15504         enqueue_and_echo_commands_P(PSTR("G28"));
// 15505         LCD_MESSAGEPGM(MSG_AUTO_HOME);
// 15506       }
// 15507       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
// 15508         homeDebounceCount++;
// 15509       else
// 15510         homeDebounceCount = 0;
// 15511     }
// 15512   #endif
// 15513 
// 15514   #if ENABLED(USE_CONTROLLER_FAN)
// 15515     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
// 15516   #endif
// 15517 
// 15518   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
// 15519     if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
// 15520       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
// 15521       #if ENABLED(SWITCHING_EXTRUDER)
// 15522         const bool oldstatus = E0_ENABLE_READ;
// 15523         enable_E0();
// 15524       #else // !SWITCHING_EXTRUDER
// 15525         bool oldstatus;
// 15526         switch (active_extruder) {
// 15527           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
// 15528           #if E_STEPPERS > 1
// 15529             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
// 15530             #if E_STEPPERS > 2
// 15531               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
// 15532               #if E_STEPPERS > 3
// 15533                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
// 15534                 #if E_STEPPERS > 4
// 15535                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
// 15536                 #endif // E_STEPPERS > 4
// 15537               #endif // E_STEPPERS > 3
// 15538             #endif // E_STEPPERS > 2
// 15539           #endif // E_STEPPERS > 1
// 15540         }
// 15541       #endif // !SWITCHING_EXTRUDER
// 15542 
// 15543       previous_cmd_ms = ms; // refresh_cmd_timeout()
// 15544 
// 15545       const float olde = current_position[E_AXIS];
// 15546       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
// 15547       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
// 15548       current_position[E_AXIS] = olde;
// 15549       planner.set_e_position_mm(olde);
// 15550       stepper.synchronize();
// 15551       #if ENABLED(SWITCHING_EXTRUDER)
// 15552         E0_ENABLE_WRITE(oldstatus);
// 15553       #else
// 15554         switch (active_extruder) {
// 15555           case 0: E0_ENABLE_WRITE(oldstatus); break;
// 15556           #if E_STEPPERS > 1
// 15557             case 1: E1_ENABLE_WRITE(oldstatus); break;
// 15558             #if E_STEPPERS > 2
// 15559               case 2: E2_ENABLE_WRITE(oldstatus); break;
// 15560               #if E_STEPPERS > 3
// 15561                 case 3: E3_ENABLE_WRITE(oldstatus); break;
// 15562                 #if E_STEPPERS > 4
// 15563                   case 4: E4_ENABLE_WRITE(oldstatus); break;
// 15564                 #endif // E_STEPPERS > 4
// 15565               #endif // E_STEPPERS > 3
// 15566             #endif // E_STEPPERS > 2
// 15567           #endif // E_STEPPERS > 1
// 15568         }
// 15569       #endif // !SWITCHING_EXTRUDER
// 15570     }
// 15571   #endif // EXTRUDER_RUNOUT_PREVENT
// 15572 
// 15573   #if ENABLED(DUAL_X_CARRIAGE)
// 15574     // handle delayed move timeout
// 15575     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
// 15576       // travel moves have been received so enact them
// 15577       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
// 15578       set_destination_from_current();
// 15579       prepare_move_to_destination();
// 15580     }
// 15581   #endif
// 15582 
// 15583   #if ENABLED(TEMP_STAT_LEDS)
// 15584     handle_status_leds();
// 15585   #endif
// 15586 
// 15587   #if ENABLED(MONITOR_DRIVER_STATUS)
// 15588     monitor_tmc_driver();
// 15589   #endif
// 15590 
// 15591   planner.check_axes_activity();
??manage_inactivity_2:
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19check_axes_activityEv
        B.W      _ZN7Planner19check_axes_activityEv
          CFI EndBlock cfiBlock88
// 15592 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176:
        DC32     _ZN17mesh_bed_leveling13index_to_xposE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILL caused by too mu...">`:
        DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
        DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
        DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
        DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
        DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
        DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
        DC8 20H, 0
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "KILLED. ">`:
        DC8 "KILLED. "
        DC8 0, 0, 0
// 15593 
// 15594 /**
// 15595  * Standard idle routine keeps the machine alive
// 15596  */
// 15597 //extern uint8_t display_hold;
// 15598 //extern uint32_t display_hold_cnt;
// 15599 //extern uint8_t display_hold_release;
// 15600 
// 15601 uint8_t display_hold=0;
// 15602 uint32_t display_hold_cnt=0;
// 15603 uint8_t display_hold_release=0;
// 15604 uint8_t button_disp_pause_state=0;
// 15605 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function _Z10lcd_reInitv
        THUMB
// 15606 void lcd_reInit()
// 15607 {
_Z10lcd_reInitv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15608    GUI_Init();
          CFI FunCall GUI_Init
        BL       GUI_Init
// 15609    GUI_UC_SetEncodeUTF8();
          CFI FunCall GUI_UC_SetEncodeUTF8
        BL       GUI_UC_SetEncodeUTF8
// 15610    gui_view_init(); 
          CFI FunCall gui_view_init
        BL       gui_view_init
// 15611    clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 15612    disp_state_stack._disp_index += 1;
        LDR.W    R0,??DataTable184_6
        LDRB     R1,[R0, #+100]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+100]
// 15613    if(mksReprint.mks_printer_state == MKS_REPRINTED)
        LDR.N    R4,??DataTable184_7
        LDR.N    R0,??DataTable184_8
        LDRB     R0,[R0, #+2720]
        CMP      R0,#+172
        BNE.N    ??lcd_reInit_0
// 15614    {
// 15615    	button_disp_pause_state=1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
// 15616    }
// 15617    draw_return_ui();
??lcd_reInit_0:
          CFI FunCall draw_return_ui
        BL       draw_return_ui
// 15618    button_disp_pause_state=0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
// 15619    Lcd_Light_ON;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable184_9  ;; 0x422281b4
        STR      R0,[R1, #+0]
// 15620 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock89
// 15621 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function _Z4idlev
        THUMB
// 15622 void idle(
// 15623   #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 15624     bool no_stepper_sleep/*=false*/
// 15625   #endif
// 15626 ) {
_Z4idlev:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15627   #if ENABLED(MAX7219_DEBUG)
// 15628     Max7219_idle_tasks();
// 15629   #endif  // MAX7219_DEBUG
// 15630 
// 15631    if(gCfgItems.standby_mode==1)
        LDR.W    R0,??DataTable188
        LDRB     R1,[R0, #+676]
        CMP      R1,#+1
        BNE.N    ??idle_0
// 15632     {
// 15633         if(display_hold_cnt>=gCfgItems.standby_time)
        LDR.N    R1,??DataTable184_10
        LDR      R2,[R1, #+60]
        ADD      R0,R0,#+676
        LDR      R3,[R0, #+4]
        CMP      R2,R3
        BCC.N    ??idle_1
// 15634         {
// 15635             display_hold_cnt -= gCfgItems.standby_time;
        LDR      R0,[R0, #+4]
        SUBS     R0,R2,R0
        STR      R0,[R1, #+60]
// 15636             display_hold=1;
        MOVS     R0,#+1
        STRB     R0,[R1, #+11]
// 15637             Lcd_Light_OFF;
        MOVS     R0,#+0
        LDR.N    R2,??DataTable184_9  ;; 0x422281b4
        STR      R0,[R2, #+0]
// 15638         }
// 15639         if(display_hold_release==1)
??idle_1:
        LDRB     R0,[R1, #+12]
        CMP      R0,#+1
        BNE.N    ??idle_0
// 15640         {
// 15641             display_hold=0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+11]
// 15642             display_hold_release=0;
        STRB     R0,[R1, #+12]
// 15643             lcd_reInit();
          CFI FunCall _Z10lcd_reInitv
        BL       _Z10lcd_reInitv
// 15644         }
// 15645     }
// 15646 
// 15647   lcd_update();
??idle_0:
          CFI FunCall _Z10lcd_updatev
        BL       _Z10lcd_updatev
// 15648 
// 15649   host_keepalive();
          CFI FunCall _Z14host_keepalivev
        BL       _Z14host_keepalivev
// 15650 
// 15651   //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 15652    #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
// 15653     thermalManager.auto_report_temperatures();
          CFI FunCall _ZN11Temperature24auto_report_temperaturesEv
        BL       _ZN11Temperature24auto_report_temperaturesEv
// 15654   #endif
// 15655 
// 15656   manage_inactivity(
// 15657     #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 15658       no_stepper_sleep
// 15659     #endif
// 15660   );
        MOVS     R0,#+0
          CFI FunCall _Z17manage_inactivityb
        BL       _Z17manage_inactivityb
// 15661 
// 15662   thermalManager.manage_heater();
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
// 15663 
// 15664   #if ENABLED(PRINTCOUNTER)
// 15665     print_job_timer.tick();
// 15666   #endif
// 15667 
// 15668   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
// 15669     buzzer.tick();
// 15670   #endif
// 15671   #if 1
// 15672   display_temper_error();
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
// 15673   
// 15674   wifi_looping();
          CFI FunCall _Z12wifi_loopingv
        BL       _Z12wifi_loopingv
// 15675   
// 15676   if(wifi_link_state != WIFI_TRANS_FILE)
        LDR.N    R0,??DataTable184_11
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+16
        BEQ.N    ??idle_2
// 15677   {
// 15678 	  GUI_RefreshPage();
          CFI FunCall GUI_RefreshPage
        BL       GUI_RefreshPage
// 15679   }
// 15680   #if defined(TFT70)
// 15681   disp_pre_gcode(3,40);
// 15682   #elif defined(TFT35)
// 15683   //#if defined(MKS_ROBIN2)
// 15684   if(preview_no_display != 1)
??idle_2:
        LDR.N    R0,??DataTable184_10
        LDRB     R0,[R0, #+5]
        CMP      R0,#+1
        BEQ.N    ??idle_3
// 15685   {
// 15686 	  disp_pre_gcode(2,36);
        MOVS     R1,#+36
        MOVS     R0,#+2
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
// 15687   }
// 15688   //#endif
// 15689   #endif
// 15690   
// 15691   GUI_TOUCH_Exec(); 	  
??idle_3:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
// 15692   GUI_Exec(); 
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall GUI_Exec
        B.W      GUI_Exec
          CFI EndBlock cfiBlock90
// 15693 
// 15694 #endif
// 15695   #if ENABLED(I2C_POSITION_ENCODERS)
// 15696     if (planner.blocks_queued() &&
// 15697         ( (blockBufferIndexRef != planner.block_buffer_head) ||
// 15698           ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
// 15699       blockBufferIndexRef = planner.block_buffer_head;
// 15700       I2CPEM.update();
// 15701       lastUpdateMillis = millis();
// 15702     }
// 15703   #endif
// 15704 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178:
        DC32     axis_relative_modes
// 15705 
// 15706 extern "C" void kill_c(const char* lcd_msg);

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function kill_c
        THUMB
// 15707 void kill_c(const char* lcd_msg) {
kill_c:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15708   SERIAL_ERROR_START();
        LDR.N    R0,??DataTable184_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15709   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15710 
// 15711   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15712   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15713 
// 15714   #if ENABLED(ULTRA_LCD)
// 15715     kill_screen(lcd_msg);
// 15716   #else
// 15717     UNUSED(lcd_msg);
// 15718   #endif
// 15719 
// 15720   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15721   cli(); // Stop interrupts
        cpsid i
// 15722 
// 15723   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15724   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15725 
// 15726   #if HAS_POWER_SWITCH
// 15727     SET_INPUT(PS_ON_PIN);
// 15728   #endif
// 15729 
// 15730   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 15731   while (1) {
??kill_c_0:
        B.N      ??kill_c_0
          CFI EndBlock cfiBlock91
// 15732     #if ENABLED(USE_WATCHDOG)
// 15733       watchdog_reset();
// 15734     #endif
// 15735   } // Wait for reset
// 15736 }
// 15737 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function _Z17temper_error_killv
        THUMB
// 15738 void temper_error_kill()
// 15739 {
_Z17temper_error_killv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15740   SERIAL_ERROR_START();
        LDR.N    R0,??DataTable184_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15741   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15742 
// 15743   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15744   disable_all_steppers();	
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15745 
// 15746   _delay_ms(600);
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15747 
// 15748   temper_error_flg = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DataTable184_12
        STRB     R0,[R1, #+0]
// 15749 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock92
// 15750 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function _Z20display_temper_errorv
        THUMB
// 15751 void display_temper_error()
// 15752 {
_Z20display_temper_errorv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
// 15753     char buf_err[30]={0};
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 15754     
// 15755 	if(temper_error_flg == 1)
        LDR.N    R4,??DataTable184_12
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??display_temper_error_0
// 15756 	{
// 15757 		card.sdprinting = false;
        MOVS     R0,#+0
        LDR.N    R1,??DataTable184_8
        STRB     R0,[R1, #+2488]
// 15758 		wait_for_heatup = false;
        LDR.N    R1,??DataTable184_2
        STRB     R0,[R1, #+4]
// 15759 
// 15760 		GUI_SetBkColor(gCfgItems.background_color);
        LDR.W    R5,??DataTable188
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 15761 		GUI_SetColor(0X0000ff);//	oìé?×?ì?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 15762         sprintf(buf_err,"Err%d",temper_error_type);
        LDRB     R2,[R4, #+1]
        ADR.W    R1,`?<Constant "Err%d">`
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
// 15763 		GUI_DispStringAt(buf_err,380, TITLE_YPOS);
        MOVS     R2,#+5
        MOV      R1,#+380
        ADD      R0,SP,#+0
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 15764 		GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+4]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 15765 		GUI_SetColor(gCfgItems.title_color);			
        LDR      R0,[R5, #+8]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 15766 	}
// 15767 }
??display_temper_error_0:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock93

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Err%d">`:
        DC8 "Err%d"
        DC8 0, 0
// 15768 
// 15769 #endif
// 15770 
// 15771 /**
// 15772  * Kill all activity and lock the machine.
// 15773  * After this the machine will need to be reset.
// 15774  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function _Z4killPKc
        THUMB
// 15775 void kill(const char* lcd_msg) {
_Z4killPKc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15776   SERIAL_ERROR_START();
        LDR.N    R0,??DataTable184_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15777   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        ADR.W    R0,`?<Constant "Printer halted. kill(...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15778 
// 15779   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15780   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15781 
// 15782   #if ENABLED(ULTRA_LCD)
// 15783     kill_screen(lcd_msg);
// 15784   #else
// 15785     UNUSED(lcd_msg);
// 15786   #endif
// 15787 
// 15788   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15789  
// 15790 
// 15791   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15792    cli(); // Stop interrupts
        cpsid i
// 15793   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15794 
// 15795   #ifdef ACTION_ON_KILL
// 15796     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
// 15797   #endif
// 15798 
// 15799   #if HAS_POWER_SWITCH
// 15800     SET_INPUT(PS_ON_PIN);
// 15801   #endif
// 15802 
// 15803   suicide();
          CFI FunCall _Z7suicidev
        BL       _Z7suicidev
// 15804   while (1) {
??kill_0:
        B.N      ??kill_0
          CFI EndBlock cfiBlock94
// 15805     #if ENABLED(USE_WATCHDOG)
// 15806       watchdog_reset();
// 15807     #endif
// 15808   } // Wait for reset
// 15809 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable182:
        DC32     _ZN17mesh_bed_leveling13index_to_yposE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer halted. kill(...">`:
        DC8 "Printer halted. kill() called!\012"
// 15810 
// 15811 /**
// 15812  * Turn off heaters and stop the print in progress
// 15813  * After a stop the machine may be resumed with M999
// 15814  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function _Z4stopv
        THUMB
// 15815 void stop() {
_Z4stopv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15816   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15817 
// 15818   #if ENABLED(PROBING_FANS_OFF)
// 15819     if (fans_paused) fans_pause(false); // put things back the way they were
// 15820   #endif
// 15821 
// 15822   if (IsRunning()) {
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??stop_0
// 15823     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
        LDR.N    R4,??DataTable184_13
        LDR      R0,[R4, #+44]
        STR      R0,[R4, #+48]
// 15824     SERIAL_ERROR_START();
        LDR.N    R0,??DataTable184_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15825     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
        ADR.W    R0,`?<Constant "Printer stopped due t...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15826     LCD_MESSAGEPGM(MSG_STOPPED);
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "STOPPED. ">`
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
// 15827     safe_delay(350);       // allow enough time for messages to get out before stopping
        MOV      R0,#+350
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 15828     Running = false;
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
// 15829   }
// 15830 }
??stop_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock95

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable183:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable183_1:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable183_2:
        DC32     0x447a0001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Printer stopped due t...">`:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "STOPPED. ">`:
        DC8 "STOPPED. "
        DC8 0, 0
// 15831 
// 15832 /**
// 15833  * Marlin entry-point: Set up before the program loop
// 15834  *  - Set up the kill pin, filament runout, power hold
// 15835  *  - Start the serial port
// 15836  *  - Print startup messages and diagnostics
// 15837  *  - Get EEPROM or default settings
// 15838  *  - Initialize managers for:
// 15839  *     temperature
// 15840  *     planner
// 15841  *     watchdog
// 15842  *     stepper
// 15843  *     photo pin
// 15844  *     servos
// 15845  *     LCD controller
// 15846  *     Digipot I2C
// 15847  *     Z probe sled
// 15848  *     status LEDs
// 15849  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function setup
        THUMB
// 15850 void setup() {
setup:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 15851 
// 15852   #if ENABLED(MAX7219_DEBUG)
// 15853     Max7219_init();
// 15854   #endif
// 15855 /*
// 15856   #if ENABLED(DISABLE_JTAG)
// 15857     // Disable JTAG on AT90USB chips to free up pins for IO
// 15858     MCUCR = 0x80;
// 15859     MCUCR = 0x80;
// 15860   #endif
// 15861   */
// 15862 
// 15863   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15864     setup_filrunoutpin();
// 15865   #endif
// 15866 
// 15867   setup_killpin();
          CFI FunCall _Z13setup_killpinv
        BL       _Z13setup_killpinv
// 15868 
// 15869   //setup_powerhold();
// 15870 
// 15871   #if HAS_STEPPER_RESET
// 15872     disableStepperDrivers();
// 15873   #endif
// 15874 
// 15875   //MYSERIAL.begin(BAUDRATE);
// 15876   //SERIAL_PROTOCOLLNPGM("start");
// 15877   //SERIAL_ECHO_START();
// 15878 
// 15879   #if ENABLED(HAVE_TMC2208)
// 15880     tmc2208_serial_begin();
// 15881   #endif
// 15882 
// 15883   // Check startup - does nothing if bootloader sets MCUSR to 0
// 15884   byte mcu = MCUSR;
// 15885   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
// 15886   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
// 15887   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
// 15888   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
// 15889   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
// 15890   //MCUSR = 0;
// 15891 
// 15892   SERIAL_ECHOPGM(MSG_MARLIN);
        ADR.W    R0,`?<Constant "MKS Robin Nano">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15893   SERIAL_CHAR(' ');
        LDR.N    R4,??DataTable184_5
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15894   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
        ADR.W    R0,`?<Constant "1.0.0\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15895   SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15896 
// 15897   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
// 15898     SERIAL_ECHO_START();
        LDR.N    R5,??DataTable184_14
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15899     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
        ADR.W    R0,`?<Constant " Last Updated: ">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15900     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
        ADR.W    R0,`?<Constant "2017-12-25 12:00">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15901     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
        ADR.W    R0,`?<Constant " | Author: (none, def...">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15902     SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15903     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
        ADR.W    R0,`?<Constant "Compiled: Feb 14 2020\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15904   #endif
// 15905 
// 15906   SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15907   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
          CFI FunCall _Z10freeMemoryv
        BL       _Z10freeMemoryv
        MOV      R1,R0
        ADR.W    R0,`?<Constant " Free Memory: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
// 15908   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
        MOV      R1,#+1344
        ADR.W    R0,`?<Constant "  PlannerBufferBytes: ">`
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15909 
// 15910   // Send "ok" after commands by default
// 15911   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
        MOVS     R0,#+0
        MOVS     R2,#+1
        LDR.N    R4,??DataTable184_10
        B.N      ??setup_0
??setup_1:
        ADDS     R1,R1,R4
        STRB     R2,[R1, #+24]
        ADDS     R0,R0,#+1
??setup_0:
        SXTB     R0,R0
        MOV      R1,R0
        CMP      R1,#+4
        BLT.N    ??setup_1
// 15912 
// 15913   // Load data from EEPROM if available (or use defaults)
// 15914   // This also updates variables in the planner, elsewhere
// 15915   (void)settings.load();
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
// 15916 
// 15917   //#if HAS_M206_COMMAND
// 15918     // Initialize current position based on home_offset
// 15919     if(MACHINETPYE != DELTA)
        LDR.N    R0,??DataTable184_2
        LDR.N    R5,??DataTable184_1
        LDRSH    R1,[R5, #+88]
        CMP      R1,#+2
        BEQ.N    ??setup_2
// 15920     	COPY(current_position, home_offset);
        MOVS     R2,#+12
        ADD      R1,R4,#+48
        ADDS     R0,R0,#+8
          CFI FunCall memcpy
        BL       memcpy
        B.N      ??setup_3
// 15921 	else
// 15922   //#else
// 15923     	ZERO(current_position);
??setup_2:
        MOVS     R2,#+16
        MOVS     R1,#+0
        ADDS     R0,R0,#+8
          CFI FunCall memset
        BL       memset
// 15924   //#endif
// 15925 
// 15926   // Vital to init stepper/planner equivalent for current_position
// 15927   SYNC_PLAN_POSITION_KINEMATIC();
??setup_3:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 15928 
// 15929   thermalManager.init();    // Initialize temperature loop
        LDR.W    R0,??DataTable191
          CFI FunCall _ZN11Temperature4initEv
        BL       _ZN11Temperature4initEv
// 15930 
// 15931   #if ENABLED(USE_WATCHDOG)
// 15932     watchdog_init();
// 15933   #endif
// 15934   //tan add
// 15935   soft_endstop_min_init();
          CFI FunCall _Z21soft_endstop_min_initv
        BL       _Z21soft_endstop_min_initv
// 15936 
// 15937   stepper.init();    // Initialize stepper, this enables interrupts!
          CFI FunCall _ZN7Stepper4initEv
        BL       _ZN7Stepper4initEv
// 15938   servo_init();
          CFI FunCall _Z10servo_initv
        BL       _Z10servo_initv
// 15939 
// 15940   #if HAS_PHOTOGRAPH
// 15941     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
// 15942   #endif
// 15943 
// 15944   #if HAS_CASE_LIGHT
// 15945     case_light_on = CASE_LIGHT_DEFAULT_ON;
// 15946     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
// 15947     update_case_light();
// 15948   #endif
// 15949 
// 15950   #if ENABLED(SPINDLE_LASER_ENABLE)
// 15951     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
// 15952     #if SPINDLE_DIR_CHANGE
// 15953       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
// 15954     #endif
// 15955     #if ENABLED(SPINDLE_LASER_PWM)
// 15956       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
// 15957       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
// 15958     #endif
// 15959   #endif
// 15960 
// 15961   #if HAS_BED_PROBE
// 15962     endstops.enable_z_probe(false);
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops14enable_z_probeEb
        BL       _ZN8Endstops14enable_z_probeEb
// 15963   #endif
// 15964 
// 15965   #if ENABLED(USE_CONTROLLER_FAN)
// 15966     SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
// 15967   #endif
// 15968 
// 15969   #if HAS_STEPPER_RESET
// 15970     enableStepperDrivers();
// 15971   #endif
// 15972 
// 15973   #if ENABLED(DIGIPOT_I2C)
// 15974     digipot_i2c_init();
// 15975   #endif
// 15976 
// 15977   #if ENABLED(DAC_STEPPER_CURRENT)
// 15978     dac_init();
// 15979   #endif
// 15980 
// 15981   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
// 15982     OUT_WRITE(SOL1_PIN, LOW); // turn it off
// 15983   #endif
// 15984 
// 15985   #if HAS_HOME
// 15986     SET_INPUT_PULLUP(HOME_PIN);
// 15987   #endif
// 15988 
// 15989   #if PIN_EXISTS(STAT_LED_RED)
// 15990     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
// 15991   #endif
// 15992 
// 15993   #if PIN_EXISTS(STAT_LED_BLUE)
// 15994     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
// 15995   #endif
// 15996 
// 15997   #if HAS_COLOR_LEDS
// 15998     leds.setup();
// 15999   #endif
// 16000 
// 16001   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
// 16002     SET_OUTPUT(RGB_LED_R_PIN);
// 16003     SET_OUTPUT(RGB_LED_G_PIN);
// 16004     SET_OUTPUT(RGB_LED_B_PIN);
// 16005     #if ENABLED(RGBW_LED)
// 16006       SET_OUTPUT(RGB_LED_W_PIN);
// 16007     #endif
// 16008   #endif
// 16009 
// 16010   #if ENABLED(MK2_MULTIPLEXER)
// 16011     SET_OUTPUT(E_MUX0_PIN);
// 16012     SET_OUTPUT(E_MUX1_PIN);
// 16013     SET_OUTPUT(E_MUX2_PIN);
// 16014   #endif
// 16015 
// 16016   #if HAS_FANMUX
// 16017     fanmux_init();
// 16018   #endif
// 16019 
// 16020   lcd_init();
          CFI FunCall _Z8lcd_initv
        BL       _Z8lcd_initv
// 16021 
// 16022   #if ENABLED(SHOW_BOOTSCREEN)
// 16023     lcd_bootscreen();
// 16024   #endif
// 16025 
// 16026   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 16027     // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
// 16028     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
// 16029       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16030         mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
// 16031 
// 16032     // Remaining virtual tools are 100% filament 1
// 16033     #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
// 16034       for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
// 16035         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16036           mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
// 16037     #endif
// 16038 
// 16039     // Initialize mixing to tool 0 color
// 16040     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16041       mixing_factor[i] = mixing_virtual_tool_mix[0][i];
// 16042   #endif
// 16043 
// 16044   //#if ENABLED(BLTOUCH)
// 16045   mksCfg.mkstouch=1;
        MOVS     R0,#+1
        STRB     R0,[R5, #+256]
// 16046   if(MKSTOUCH == 1)
// 16047   {
// 16048     // Make sure any BLTouch error condition is cleared
// 16049     bltouch_command(BLTOUCH_RESET);
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 16050     set_bltouch_deployed(true);
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 16051     set_bltouch_deployed(false);
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 16052   }
// 16053   //#endif
// 16054 
// 16055   #if ENABLED(I2C_POSITION_ENCODERS)
// 16056     I2CPEM.init();
// 16057   #endif
// 16058 
// 16059   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 16060     i2c.onReceive(i2c_on_receive);
// 16061     i2c.onRequest(i2c_on_request);
// 16062   #endif
// 16063 
// 16064   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
// 16065     setup_endstop_interrupts();
// 16066   #endif
// 16067 
// 16068   #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 16069     move_extruder_servo(0);  // Initialize extruder servo
// 16070   #endif
// 16071 
// 16072   #if ENABLED(SWITCHING_NOZZLE)
// 16073     move_nozzle_servo(0);  // Initialize nozzle servo
// 16074   #endif
// 16075 
// 16076   #if ENABLED(PARKING_EXTRUDER)
// 16077     #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 16078       pe_activate_magnet(0);
// 16079       pe_activate_magnet(1);
// 16080     #else
// 16081       pe_deactivate_magnet(0);
// 16082       pe_deactivate_magnet(1);
// 16083     #endif
// 16084   #endif
// 16085   #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
// 16086     SET_OUTPUT(LCD_PINS_DC);
// 16087     OUT_WRITE(LCD_PINS_RS, LOW);
// 16088     delay(1000);
// 16089     WRITE(LCD_PINS_RS, HIGH);
// 16090   #endif
// 16091     display_hold=0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+11]
// 16092     display_hold_cnt=0;
        STR      R0,[R4, #+60]
// 16093 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock96

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_1:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_2:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_3:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_4:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_5:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_6:
        DC32     disp_state_stack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_7:
        DC32     button_disp_pause_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_8:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_9:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_10:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_11:
        DC32     wifi_link_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_12:
        DC32     temper_error_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_13:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184_14:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "MKS Robin Nano">`:
        DC8 "MKS Robin Nano"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "1.0.0\\n">`:
        DC8 "1.0.0\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Last Updated: ">`:
        DC8 " Last Updated: "

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "2017-12-25 12:00">`:
        DC8 "2017-12-25 12:00"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " | Author: (none, def...">`:
        DC8 " | Author: (none, default config)\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Compiled: Feb 14 2020\\n">`:
        DC8 "Compiled: Feb 14 2020\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant " Free Memory: ">`:
        DC8 " Free Memory: "
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "  PlannerBufferBytes: ">`:
        DC8 "  PlannerBufferBytes: "
        DC8 0
// 16094 
// 16095 /**
// 16096  * The main Marlin program loop
// 16097  *
// 16098  *  - Save or log commands to SD
// 16099  *  - Process available commands (if not saving)
// 16100  *  - Call heater manager
// 16101  *  - Call inactivity manager
// 16102  *  - Call endstop manager
// 16103  *  - Call LCD update
// 16104  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function loop
        THUMB
// 16105 void loop() {
loop:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 16106 #if 1
// 16107     //display_sd_error();
// 16108 
// 16109 	display_temper_error();
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
// 16110 	
// 16111 	PowerOff_Filament_Check();
          CFI FunCall _Z23PowerOff_Filament_Checkv
        BL       _Z23PowerOff_Filament_Checkv
// 16112 	
// 16113 	MYSERIAL.MoremenuCmd();
        LDR.W    R0,??DataTable192
          CFI FunCall _ZN10USARTClass11MoremenuCmdEv
        BL       _ZN10USARTClass11MoremenuCmdEv
// 16114 
// 16115 #endif
// 16116   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R4,??DataTable192_1
        LDRB     R0,[R4, #+2]
        CMP      R0,#+4
        BGE.N    ??loop_0
          CFI FunCall _Z22get_available_commandsv
        BL       _Z22get_available_commandsv
// 16117 
// 16118   #if 0//ENABLED(SDSUPPORT)
// 16119     card.checkautostart(false);
// 16120   #endif
// 16121   card.checkFilesys(gCfgItems.fileSysType);
??loop_0:
        LDR.W    R6,??DataTable192_2
        LDR.W    R0,??DataTable188
        LDRB     R1,[R0, #+186]
        MOV      R0,R6
          CFI FunCall _ZN10CardReader12checkFilesysEh
        BL       _ZN10CardReader12checkFilesysEh
// 16122 
// 16123   if (commands_in_queue) {
        LDR.W    R5,??DataTable191_1
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 16124 
// 16125     #if ENABLED(SDSUPPORT)
// 16126 
// 16127       if (card.saving) {
        LDRB     R0,[R6, #+2489]
        CMP      R0,#+0
        BEQ.N    ??loop_2
// 16128         char* command = command_queue[cmd_queue_index_r];
        LDRB     R0,[R5, #+7]
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R0,??DataTable191_2
        ADD      R7,R0,R1, LSL #+5
// 16129         if (strstr_P(command, PSTR("M29"))) {
        ADR.N    R1,??DataTable186_4  ;; "M29"
        MOV      R0,R7
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??loop_3
// 16130           // M29 closes the file
// 16131           card.closefile();
        MOVS     R1,#+0
        MOV      R0,R6
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
// 16132           SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
        ADR.W    R0,`?<Constant "Done saving file.\\n">`
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 16133 
// 16134           #if ENABLED(SERIAL_STATS_DROPPED_RX)
// 16135             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
// 16136           #endif
// 16137 
// 16138           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
// 16139             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
// 16140           #endif
// 16141 
// 16142           ok_to_send();
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 16143         }
// 16144         else {
// 16145           // Write the string from the read buffer to SD
// 16146           card.write_command(command);
??loop_3:
        MOV      R1,R7
        MOV      R0,R6
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
// 16147           if (card.logging)
        LDRB     R0,[R6, #+2490]
        CMP      R0,#+0
        BEQ.N    ??loop_5
// 16148             process_next_command(); // The card is saving because it's logging
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
        B.N      ??loop_4
// 16149           else
// 16150             ok_to_send();
??loop_5:
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 16151         }
// 16152       }
// 16153       else
// 16154         process_next_command();
??loop_2:
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
// 16155 
// 16156     #else
// 16157 
// 16158       process_next_command();
// 16159 
// 16160     #endif // SDSUPPORT
// 16161 
// 16162     // The queue may be reset by a command handler or by code invoked by idle() within a handler
// 16163     if (commands_in_queue) {
??loop_4:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BEQ.N    ??loop_1
// 16164       --commands_in_queue;
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+2]
// 16165       if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
        LDRB     R0,[R5, #+7]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+7]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??loop_1
        MOVS     R0,#+0
        STRB     R0,[R5, #+7]
// 16166     }
// 16167   }
// 16168   endstops.report_state();
??loop_1:
          CFI FunCall _ZN8Endstops12report_stateEv
        BL       _ZN8Endstops12report_stateEv
// 16169   idle();
          CFI FunCall _Z4idlev
        BL       _Z4idlev
// 16170   loop_start=1;
        MOVS     R0,#+1
        STRB     R0,[R5, #+6]
// 16171   
// 16172   mks_PrintStatePolling();
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_PrintStatePolling
        B.W      mks_PrintStatePolling
          CFI EndBlock cfiBlock97
// 16173 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable185:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable185_1:
        DC32     0x401921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Done saving file.\\n">`:
        DC8 "Done saving file.\012"
        DC8 0
// 16174 #if 1
// 16175 uint16_t z_high_count;
// 16176 
// 16177 extern uint8_t poweroff_det_flg;
// 16178 extern uint32_t poweroff_det_cnt;
// 16179 extern uint8_t poweroff_det_low_flg;
// 16180 extern uint32_t poweroff_det_low_cnt;
// 16181 extern uint8_t poweroff_det_high_flg;
// 16182 extern uint32_t poweroff_det_high_cnt;
// 16183 
// 16184 extern uint8_t filament_det1_flg;
// 16185 extern uint32_t filament_det1_cnt;
// 16186 extern uint8_t filament_det1_low_flg;
// 16187 extern uint32_t filament_det1_low_cnt;
// 16188 extern uint8_t filament_det1_high_flg;
// 16189 extern uint32_t filament_det1_high_cnt;
// 16190 extern uint8_t filament_det1_check;
// 16191 
// 16192 extern uint8_t filament_det2_flg;
// 16193 extern uint32_t filament_det2_cnt;
// 16194 extern uint8_t filament_det2_low_flg;
// 16195 extern uint32_t filament_det2_low_cnt;
// 16196 extern uint8_t filament_det2_high_flg;
// 16197 extern uint32_t filament_det2_high_cnt;
// 16198 extern uint8_t filament_det2_check;
// 16199 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// 16200 uint32_t wifi_loop_cycle = 500;
wifi_loop_cycle:
        DATA
        DC32 500
// 16201 extern char wifi_check_time;
// 16202 uint8_t wifi_init_flg = 0;
// 16203 uint8_t wifi_init_state = 0;
// 16204 uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
// 16205 uint8_t waiting_wifi_time = 0;
// 16206 
// 16207 uint8_t beep_flg = 0;
// 16208 uint32_t beep_cnt = 0;
// 16209 
// 16210 extern volatile uint8_t has_adjust_speed;
// 16211 extern volatile uint16_t resume_printed_time;
// 16212 
// 16213 extern uint8_t print_finish_start_timer;
// 16214 extern uint32_t print_finish_timer_count;
// 16215 extern uint8_t print_finish_close_machine;
// 16216 
// 16217 #if 0
// 16218 uint8_t btn_flg = 0;
// 16219 uint32_t btn_beep_cnt = 0;
// 16220 #endif
// 16221 extern void mksBeeperAlarm(void);
// 16222 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function _Z6Beeperj
          CFI NoCalls
        THUMB
// 16223 void Beeper(uint32_t cnt)
// 16224 {
// 16225     beep_flg = 1;
_Z6Beeperj:
        LDR.W    R1,??DataTable191_1
        MOVS     R2,#+1
        STRB     R2,[R1, #+17]
// 16226     beep_cnt = cnt;
        STR      R0,[R1, #+64]
// 16227     BEEPER_OP = 1;
        MOV      R0,R2
        LDR.W    R1,??DataTable192_3  ;; 0x42220194
        STR      R0,[R1, #+0]
// 16228 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock98

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_1:
        DC32     0xc01921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_2:
        DC32     0x40c90fdb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_3:
        DC32     0x3a83126f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_4:
        DC8      "M29"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_5:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_6:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_7:
        DC32     0x4062c000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_8:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_9:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_10:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_11:
        DC32     0x42c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_12:
        DC32     0xc2c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_13:
        DC32     0x42600000
// 16229 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function _Z20SysTick_Handler_Userv
        THUMB
// 16230 void SysTick_Handler_User()
// 16231 {
_Z20SysTick_Handler_Userv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 16232 		TimeIncrease++;
        LDR.W    R4,??DataTable191_1
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+44]
// 16233 
// 16234 
// 16235 		if(filament_loading_time_flg == 1)
        MOV      R5,#+1000
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_0
// 16236 		{
// 16237 			filament_loading_time_cnt++;
        LDR      R0,[R4, #+36]
        ADDS     R6,R0,#+1
        STR      R6,[R4, #+36]
// 16238 			filament_rate = (uint32_t)(((filament_loading_time_cnt/(gCfgItems.filament_loading_time*1000.0))*100.0)+0.5);
        LDR.W    R0,??DataTable191_3
        LDR      R7,[R0, #+244]
        MOV      R0,R6
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R7
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable192_4  ;; 0x408f4000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable192_5  ;; 0x40590000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable192_6  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        LDR.W    R1,??DataTable192_7
        STR      R0,[R1, #+0]
// 16239 			if(filament_loading_time_cnt >= (gCfgItems.filament_loading_time*1000))
        MUL      R0,R5,R7
        CMP      R6,R0
        BCC.N    ??SysTick_Handler_User_0
// 16240 			{
// 16241 				filament_loading_time_cnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+36]
// 16242 				filament_loading_time_flg = 0;
        STRB     R0,[R4, #+0]
// 16243 				filament_loading_completed = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+1]
// 16244 			}
// 16245 		}
// 16246 		if(filament_unloading_time_flg == 1)
??SysTick_Handler_User_0:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_1
// 16247 		{
// 16248 			filament_unloading_time_cnt++;
        LDR      R0,[R4, #+40]
        ADDS     R6,R0,#+1
        STR      R6,[R4, #+40]
// 16249 			filament_rate = (uint32_t)(((filament_unloading_time_cnt/(gCfgItems.filament_unloading_time*1000.0))*100.0)+0.5);
        LDR.W    R0,??DataTable191_3
        ADDS     R0,R0,#+244
        LDR      R8,[R0, #+4]
        LDR.W    R7,??DataTable192_7
        MOV      R0,R6
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R8
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable192_4  ;; 0x408f4000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable192_5  ;; 0x40590000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable192_6  ;; 0x3fe00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R7, #+0]
// 16250 			if(filament_unloading_time_cnt >= (gCfgItems.filament_unloading_time*1000))
        MUL      R0,R5,R8
        CMP      R6,R0
        BCC.N    ??SysTick_Handler_User_1
// 16251 			{
// 16252 				filament_unloading_time_cnt = 0;
        MOVS     R0,#+0
        STR      R0,[R4, #+40]
// 16253 				filament_unloading_time_flg = 0;
        STRB     R0,[R4, #+2]
// 16254 				filament_unloading_completed = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+3]
// 16255 				filament_rate = 100;
        MOVS     R0,#+100
        STR      R0,[R7, #+0]
// 16256 			}
// 16257 		}	
// 16258 	
// 16259 		temperature_change_frequency_cnt++;
??SysTick_Handler_User_1:
        LDR      R0,[R4, #+32]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+32]
// 16260 		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
        CMP      R0,#+2000
        BCC.N    ??SysTick_Handler_User_2
        LDR.W    R0,??DataTable192_8
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BEQ.N    ??SysTick_Handler_User_2
// 16261 		{
// 16262 			temperature_change_frequency_cnt = 0;
        MOVS     R1,#+0
        STR      R1,[R4, #+32]
// 16263 			temperature_change_frequency = 1;
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
// 16264 		}
// 16265 		
// 16266 		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
??SysTick_Handler_User_2:
        LDR      R0,[R4, #+44]
        MOVW     R1,#+3000
        UDIV     R1,R0,R1
        MOVW     R2,#+3000
        MLS      R0,R2,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_3
// 16267 		{		
// 16268 			printing_rate_update_flag = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
// 16269 		}	
// 16270 
// 16271 		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
??SysTick_Handler_User_3:
        LDR      R0,[R4, #+44]
        MOV      R1,R5
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_4
// 16272 		{		
// 16273 			if(print_time.start == 1)
        LDR.W    R0,??DataTable192_9
        LDRSB    R1,[R0, #+7]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_5
// 16274 			{
// 16275 				print_time.seconds++;
        LDRB     R1,[R0, #+5]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+5]
// 16276 			}
// 16277 			display_hold_cnt++;
??SysTick_Handler_User_5:
        LDR      R0,[R4, #+60]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+60]
// 16278 		}
// 16279 		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
??SysTick_Handler_User_4:
        LDR      R0,[R4, #+44]
        MOV      R1,R5
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_6
// 16280 		{
// 16281 			z_high_count=1;
        MOVS     R0,#+1
        STRH     R0,[R4, #+28]
// 16282 		}
// 16283 
// 16284 	if(poweroff_det_flg==1)
??SysTick_Handler_User_6:
        LDR.W    R0,??DataTable192_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_7
// 16285 	{
// 16286 		poweroff_det_cnt++;
        LDR.W    R0,??DataTable193
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16287 	}
// 16288 		
// 16289 	if(filament_det1_flg==1)
??SysTick_Handler_User_7:
        LDR.W    R0,??DataTable193_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_8
// 16290 	{
// 16291 		filament_det1_cnt++;
        LDR.W    R0,??DataTable193_2
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16292 	}
// 16293 
// 16294 	if(filament_det1_low_flg==1)
??SysTick_Handler_User_8:
        LDR.W    R0,??DataTable193_3
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_9
// 16295 	{
// 16296 		filament_det1_low_cnt++;
        LDR.W    R0,??DataTable193_4
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16297 	}
// 16298 
// 16299 	if(filament_det1_high_flg==1)
??SysTick_Handler_User_9:
        LDR.W    R0,??DataTable194
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_10
// 16300 	{
// 16301 		filament_det1_high_cnt++;
        LDR.W    R0,??DataTable194_1
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16302 	}
// 16303 	if(filament_det2_flg==1)
??SysTick_Handler_User_10:
        LDR.W    R0,??DataTable194_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_11
// 16304 	{
// 16305 		filament_det2_cnt++;
        LDR.W    R0,??DataTable194_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16306 	}
// 16307 
// 16308 	if(filament_det2_low_flg==1)
??SysTick_Handler_User_11:
        LDR.W    R0,??DataTable194_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_12
// 16309 	{
// 16310 		filament_det2_low_cnt++;
        LDR.W    R0,??DataTable194_5
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16311 	}
// 16312 
// 16313 	if(filament_det2_high_flg==1)
??SysTick_Handler_User_12:
        LDR.W    R0,??DataTable194_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_13
// 16314 	{
// 16315 		filament_det2_high_cnt++;
        LDR.W    R0,??DataTable194_7
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16316 	}
// 16317 
// 16318 	if(poweroff_det_low_flg==1)
??SysTick_Handler_User_13:
        LDR.W    R0,??DataTable194_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_14
// 16319 	{
// 16320 		poweroff_det_low_cnt++;
        LDR.W    R0,??DataTable195
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16321 	}
// 16322 	
// 16323 	if(poweroff_det_high_flg==1)
??SysTick_Handler_User_14:
        LDR.W    R0,??DataTable195_1
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_15
// 16324 	{
// 16325 		poweroff_det_high_cnt++;
        LDR.W    R0,??DataTable195_2
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16326 	}		
// 16327 
// 16328 	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
??SysTick_Handler_User_15:
        LDR      R0,[R4, #+44]
        MOVW     R1,#+5000
        UDIV     R1,R0,R1
        MOVW     R2,#+5000
        MLS      R0,R2,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_16
// 16329 	{
// 16330 		wifi_check_time = 1;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable195_3
        STRB     R0,[R1, #+0]
// 16331 		waiting_wifi_time ++;
        LDRB     R0,[R4, #+16]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+16]
// 16332 		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
        UXTB     R0,R0
        CMP      R0,#+8
        BEQ.N    ??SysTick_Handler_User_17
        LDR.W    R0,??DataTable191_3
        LDRB     R0,[R0, #+556]
        CMP      R0,#+2
        BNE.N    ??SysTick_Handler_User_18
// 16333 		{
// 16334 			if(wifi_init_flg == 0)
??SysTick_Handler_User_17:
        LDRB     R0,[R4, #+13]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_18
// 16335 			{
// 16336 				wifi_init_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+13]
// 16337 			}
// 16338 			
// 16339 		}
// 16340 		if(wifi_refresh_flg == 0)
??SysTick_Handler_User_18:
        LDRB     R0,[R4, #+14]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_19
// 16341 			wifi_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+14]
// 16342 		
// 16343 		if(cloud_refresh_flg == 0)
??SysTick_Handler_User_19:
        LDRB     R0,[R4, #+15]
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_16
// 16344 			cloud_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+15]
// 16345 
// 16346 	}
// 16347 	
// 16348 
// 16349 	mksBeeperAlarm();
??SysTick_Handler_User_16:
          CFI FunCall _Z14mksBeeperAlarmv
        BL       _Z14mksBeeperAlarmv
// 16350 
// 16351     if(beep_flg == 1)
        LDRB     R0,[R4, #+17]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_20
// 16352     {
// 16353         beep_cnt--;
        LDR      R0,[R4, #+64]
        SUBS     R0,R0,#+1
        STR      R0,[R4, #+64]
// 16354         if(beep_cnt<=0)
        BNE.N    ??SysTick_Handler_User_20
// 16355         {
// 16356            beep_flg = 0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+17]
// 16357            BEEPER_OP = 0; 
        LDR.W    R1,??DataTable192_3  ;; 0x42220194
        STR      R0,[R1, #+0]
// 16358         }
// 16359     }  
// 16360 	if(key_value_calc.timer == TIMER_START)
??SysTick_Handler_User_20:
        LDR.W    R0,??DataTable195_4
        LDRB     R1,[R0, #+37]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_21
// 16361 	{
// 16362 		key_value_calc.timer_count++;
        LDR      R1,[R0, #+40]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+40]
// 16363 	}
// 16364 	if(((TimeIncrease * TICK_CYCLE % 1000) == 0) )
??SysTick_Handler_User_21:
        LDR      R0,[R4, #+44]
        MOV      R1,R5
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CMP      R0,#+0
        BNE.N    ??SysTick_Handler_User_22
// 16365 	{		
// 16366 		if(tips_disp.timer == TIPS_TIMER_START)
        LDR.W    R0,??DataTable195_5
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_22
// 16367 		{
// 16368 			tips_disp.timer_count++;
        LDRB     R1,[R0, #+1]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+1]
// 16369 		}
// 16370 	}
// 16371 #if 0
// 16372     if(btn_flg == 1)
// 16373     {
// 16374         btn_beep_cnt--;
// 16375         if(btn_beep_cnt<=0)
// 16376         {
// 16377            btn_flg = 0;
// 16378            BEEPER_OP = 0; 
// 16379         }
// 16380     }
// 16381     #endif
// 16382 	if(has_adjust_speed==1)resume_printed_time++;
??SysTick_Handler_User_22:
        LDRB     R0,[R4, #+18]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_23
        LDRH     R0,[R4, #+30]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+30]
// 16383 
// 16384 	if(print_finish_start_timer==TIMER_START)
??SysTick_Handler_User_23:
        LDRB     R0,[R4, #+19]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_24
// 16385 	{
// 16386 		print_finish_timer_count++;
        LDR      R0,[R4, #+68]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+68]
// 16387 		if(print_finish_timer_count>=(gCfgItems.print_finish_count*1000))
        LDR.W    R1,??DataTable191_3
        LDRH     R1,[R1, #+686]
        MULS     R1,R5,R1
        CMP      R0,R1
        BCC.N    ??SysTick_Handler_User_24
// 16388 		{
// 16389 			print_finish_start_timer=TIMER_STOP;
        MOVS     R0,#+0
        STRB     R0,[R4, #+19]
// 16390 			print_finish_timer_count=0;
        STR      R0,[R4, #+68]
// 16391 			print_finish_close_machine=true;
        MOVS     R0,#+1
        STRB     R0,[R4, #+20]
// 16392 		}
// 16393 	}
// 16394 }
??SysTick_Handler_User_24:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187:
        DC32     0xc2600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_1:
        DC32     0xbf800000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_2:
        DC32     ??C2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_3:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_4:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_5:
        DC32     gArrayGpioPin
// 16395 #endif
// 16396 
// 16397 #include "mks_reprint.cpp"

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute char *mks_pft_name
mks_pft_name:
        DATA
        DC32 `?<Constant "mks_pft.sys">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function mkstft_ui_load
        THUMB
// __interwork __softfp void mkstft_ui_load()
mkstft_ui_load:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable191_3
        MOVS     R2,#+4
        ADDS     R1,R4,#+4
        MOVW     R0,#+1694
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+8
        MOVW     R0,#+1698
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+12
        MOVW     R0,#+1702
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+16
        MOVW     R0,#+1706
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+24
        MOVW     R0,#+1710
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+20
        MOVW     R0,#+1714
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+36
        MOVW     R0,#+1718
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOVW     R0,#+1722
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+44
        MOVW     R0,#+1726
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+48
        MOVW     R0,#+1730
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+60
        MOVW     R0,#+1734
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+64
        MOVW     R0,#+1738
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+52
        MOVW     R0,#+1742
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+56
        MOVW     R0,#+1746
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+84
        MOVW     R0,#+1750
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+88
        MOVW     R0,#+1754
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+447
        MOVW     R0,#+1758
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+184
        MOVW     R0,#+1759
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+212
        MOVW     R0,#+1794
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+228
        MOV      R0,#+1768
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+220
        MOVW     R0,#+1772
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+236
        MOV      R0,#+1776
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+232
        MOVW     R0,#+1780
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+224
        MOV      R0,#+1784
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+240
        MOVW     R0,#+1788
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+213
        MOVW     R0,#+1793
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+661
        MOVW     R0,#+1797
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+444
        MOVW     R0,#+1799
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+205
        MOV      R0,#+1800
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+445
        MOVW     R0,#+1801
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+446
        MOVW     R0,#+1802
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+458
        MOVW     R0,#+1803
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+252
        MOVW     R0,#+1804
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+253
        MOVW     R0,#+1805
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+254
        MOVW     R0,#+1806
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+256
        MOV      R0,#+1808
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+258
        MOVW     R0,#+1810
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+260
        MOVW     R0,#+1812
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+262
        MOVW     R0,#+1814
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+264
        MOV      R0,#+1816
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+266
        MOVW     R0,#+1818
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+268
        MOVW     R0,#+1820
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+270
        MOVW     R0,#+1822
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+272
        MOV      R0,#+1824
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+217
        MOVW     R0,#+1826
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+557
        MOVW     R0,#+1827
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+668
        MOVW     R0,#+1841
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+669
        MOVW     R0,#+1836
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+670
        MOVW     R0,#+1837
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+671
        MOVW     R0,#+1838
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+672
        MOVW     R0,#+1839
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+674
        MOVW     R0,#+1842
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+676
        MOVW     R0,#+1843
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+680
        MOVW     R0,#+1844
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+684
        MOV      R0,#+1848
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADDW     R1,R4,#+686
        MOVW     R0,#+1850
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_read_data
        B.W      epr_read_data
          CFI EndBlock cfiBlock100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function _Z17mkstft_ui_set_eprv
        THUMB
// __interwork __softfp void mkstft_ui_set_epr()
_Z17mkstft_ui_set_eprv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVW     R4,#+1450
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable196  ;; 0x76313030
        LDR      R0,[SP, #+0]
        CMP      R0,R5
        BEQ.W    ??mkstft_ui_set_epr_0
        LDR.W    R6,??DataTable191_3
        MOVS     R2,#+4
        ADDS     R1,R6,#+4
        MOVW     R0,#+1694
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+8
        MOVW     R0,#+1698
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+12
        MOVW     R0,#+1702
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+16
        MOVW     R0,#+1706
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+24
        MOVW     R0,#+1710
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+20
        MOVW     R0,#+1714
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+36
        MOVW     R0,#+1718
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOVW     R0,#+1722
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+44
        MOVW     R0,#+1726
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+48
        MOVW     R0,#+1730
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+60
        MOVW     R0,#+1734
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+64
        MOVW     R0,#+1738
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+52
        MOVW     R0,#+1742
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+56
        MOVW     R0,#+1746
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+84
        MOVW     R0,#+1750
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+88
        MOVW     R0,#+1754
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+447
        MOVW     R0,#+1758
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+184
        MOVW     R0,#+1759
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+212
        MOVW     R0,#+1794
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+228
        MOV      R0,#+1768
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+220
        MOVW     R0,#+1772
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+236
        MOV      R0,#+1776
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+232
        MOVW     R0,#+1780
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+224
        MOV      R0,#+1784
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+240
        MOVW     R0,#+1788
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+213
        MOVW     R0,#+1793
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+661
        MOVW     R0,#+1797
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+444
        MOVW     R0,#+1799
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+205
        MOV      R0,#+1800
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+445
        MOVW     R0,#+1801
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+446
        MOVW     R0,#+1802
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+458
        MOVW     R0,#+1803
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+252
        MOVW     R0,#+1804
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+253
        MOVW     R0,#+1805
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+254
        MOVW     R0,#+1806
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+256
        MOV      R0,#+1808
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+258
        MOVW     R0,#+1810
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+260
        MOVW     R0,#+1812
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+262
        MOVW     R0,#+1814
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+264
        MOV      R0,#+1816
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+266
        MOVW     R0,#+1818
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+268
        MOVW     R0,#+1820
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+270
        MOVW     R0,#+1822
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+272
        MOV      R0,#+1824
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+217
        MOVW     R0,#+1826
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+557
        MOVW     R0,#+1827
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+668
        MOVW     R0,#+1841
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+669
        MOVW     R0,#+1836
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+670
        MOVW     R0,#+1837
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+671
        MOVW     R0,#+1838
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+672
        MOVW     R0,#+1839
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+674
        MOVW     R0,#+1842
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+676
        MOVW     R0,#+1843
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+680
        MOVW     R0,#+1844
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+684
        MOV      R0,#+1848
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADDW     R1,R6,#+686
        MOVW     R0,#+1850
          CFI FunCall epr_write_data
        BL       epr_write_data
        STR      R5,[SP, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
??mkstft_ui_set_epr_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function mkstft_ui_init
        THUMB
// __interwork __softfp void mkstft_ui_init()
mkstft_ui_init:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R4,??DataTable191_3
        LDR.W    R0,??DataTable202_1  ;; 0x494949
        STR      R0,[R4, #+4]
        ADDS     R1,R4,#+4
        MVN      R2,#-16777216
        STR      R2,[R1, #+4]
        STR      R0,[R1, #+8]
        STR      R2,[R1, #+12]
        STR      R0,[R1, #+32]
        STR      R2,[R1, #+36]
        STR      R0,[R1, #+40]
        STR      R2,[R1, #+44]
        STR      R0,[R1, #+48]
        STR      R2,[R1, #+52]
        STR      R0,[R1, #+56]
        STR      R2,[R1, #+60]
        MOV      R0,#+65280
        STR      R0,[R1, #+64]
        LDR.W    R0,??DataTable202_2  ;; 0xaaaaaa
        STR      R0,[R1, #+68]
        MOVS     R0,#+0
        STR      R0,[R1, #+72]
        STR      R0,[R1, #+76]
        MOV      R0,#+16711680
        STR      R0,[R1, #+80]
        STR      R2,[R1, #+84]
        MOVS     R0,#+0
        STR      R0,[R1, #+88]
        STR      R2,[R1, #+92]
        MOVS     R0,#+1
        STRB     R0,[R4, #+447]
        ADD      R1,R4,#+156
        MOVS     R0,#+3
        STRB     R0,[R1, #+28]
        MOVS     R0,#+1
        STRB     R0,[R1, #+30]
        MOVS     R0,#+10
        STRB     R0,[R1, #+3]
        MOVS     R0,#+0
        STRB     R0,[R4, #+156]
        MOV      R0,#+1065353216
        STR      R0,[R1, #+24]
        MOVW     R0,#+3000
        STRH     R0,[R1, #+18]
        MOVS     R2,#+1
        STRB     R2,[R1, #+16]
        MOVS     R2,#+5
        STRB     R2,[R1, #+15]
        STRB     R2,[R1, #+14]
        MOVS     R2,#+100
        STRH     R2,[R1, #+8]
        STRH     R2,[R1, #+10]
        MOVS     R1,#+0
        STRB     R1,[R4, #+252]
        ADD      R1,R4,#+252
        MOVS     R2,#+4
        STRB     R2,[R1, #+1]
        MOVS     R2,#+50
        STRH     R2,[R1, #+2]
        STRH     R2,[R1, #+4]
        MOVS     R2,#+180
        STRH     R2,[R1, #+6]
        MOVS     R2,#+50
        STRH     R2,[R1, #+8]
        MOVS     R2,#+180
        STRH     R2,[R1, #+10]
        STRH     R2,[R1, #+12]
        MOVS     R2,#+50
        STRH     R2,[R1, #+14]
        MOVS     R2,#+180
        STRH     R2,[R1, #+16]
        STR      R0,[R1, #+28]
        MOVW     R0,#+1500
        STR      R0,[R1, #+24]
        ADDW     R0,R4,#+415
        MOVS     R1,#+0
        STRB     R1,[R0, #+29]
        STRB     R1,[R4, #+205]
        STRB     R1,[R0, #+30]
        STRB     R1,[R0, #+31]
        MOV      R0,R1
        STRB     R0,[R4, #+458]
        ADDW     R6,R4,#+205
        STRB     R0,[R6, #+12]
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "0.000">`
        ADD      R0,R4,#+352
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R4, #+297]
        ADD      R0,R4,#+220
        MOVS     R1,#+200
        STR      R1,[R0, #+16]
        MOV      R5,#+1000
        STR      R5,[R4, #+220]
        MOVS     R1,#+100
        STR      R1,[R0, #+8]
        MOVS     R1,#+200
        STR      R1,[R0, #+20]
        STR      R5,[R0, #+4]
        MOVS     R1,#+100
        STR      R1,[R0, #+12]
        MOVS     R0,#+0
        STRB     R0,[R6, #+7]
        MOVS     R0,#+1
        STRB     R0,[R6, #+8]
        STRB     R0,[R4, #+555]
        LDR.W    R8,??DataTable204_1
        MOVS     R2,#+108
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        LDR.W    R6,??DataTable204_2
        MOVS     R2,#+162
        MOVS     R1,#+0
        MOV      R0,R6
          CFI FunCall memset
        BL       memset
        MOVS     R7,#+12
        MOV      R2,R7
        ADR.W    R1,`?<Constant "TP-LINK_MKS">`
        MOV      R0,R8
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+10
        ADR.W    R1,`?<Constant "makerbase">`
        ADD      R0,R8,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADR.W    R8,`?<Constant "192.168.3.100">`
        MOV      R9,#+14
        MOV      R2,R9
        MOV      R1,R8
        ADDS     R0,R6,#+1
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADR.W    R10,`?<Constant "255.255.255.0">`
        MOV      R2,R9
        MOV      R1,R10
        ADD      R0,R6,#+17
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        ADR.W    R11,`?<Constant "192.168.3.1">`
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+33
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+49
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+0]
        MOV      R2,R9
        MOV      R1,R8
        ADD      R0,R6,#+66
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R9
        MOV      R1,R10
        ADD      R0,R6,#+82
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+98
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+114
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+130
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R9
        ADR.W    R1,`?<Constant "192.168.3.255">`
        ADD      R0,R6,#+146
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+65]
        ADDW     R6,R4,#+555
        MOVS     R0,#+2
        STRB     R0,[R6, #+1]
        MOVS     R2,#+15
        ADR.W    R1,`?<Constant "baizhongyun.cn">`
        ADDW     R0,R4,#+558
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVW     R0,#+10086
        STR      R0,[R4, #+656]
        MOVS     R0,#+1
        STRB     R0,[R6, #+2]
        ADD      R0,R4,#+656
        MOVS     R1,#+23
        STRB     R1,[R0, #+4]
        MOVS     R1,#+0
        STRB     R1,[R0, #+5]
        STRB     R1,[R4, #+415]
        STRB     R1,[R4, #+328]
        STRB     R1,[R4, #+341]
        STRB     R1,[R0, #+12]
        STRB     R1,[R0, #+13]
        STRB     R1,[R0, #+14]
        STRB     R1,[R0, #+15]
        STRH     R5,[R0, #+16]
        STRB     R1,[R0, #+18]
        STRB     R1,[R0, #+19]
        STRB     R1,[R0, #+20]
        STR      R1,[R0, #+24]
        MOVS     R1,#+5
        STRH     R1,[R0, #+28]
        MOVS     R1,#+180
        STRH     R1,[R0, #+30]
          CFI FunCall _Z17mkstft_ui_set_eprv
        BL       _Z17mkstft_ui_set_eprv
        MOVS     R0,#+0
        LDR.W    R1,??DataTable206
        STRB     R0,[R1, #+0]
        LDR.W    R1,??DataTable208_1
        STRB     R0,[R1, #+0]
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock102

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "0.000">`:
        DC8 "0.000"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "TP-LINK_MKS">`:
        DC8 "TP-LINK_MKS"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "makerbase">`:
        DC8 "makerbase"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.100">`:
        DC8 "192.168.3.100"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "255.255.255.0">`:
        DC8 "255.255.255.0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.1">`:
        DC8 "192.168.3.1"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "192.168.3.255">`:
        DC8 "192.168.3.255"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "baizhongyun.cn">`:
        DC8 "baizhongyun.cn"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function mks_initPrint
        THUMB
// __interwork __softfp void mks_initPrint()
mks_initPrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??DataTable192_2
        LDR.W    R0,??DataTable207
        LDR      R1,[R0, #+212]
        STR      R1,[R4, #+2668]
        ADDW     R1,R4,#+2668
        ADDS     R0,R0,#+212
        LDR      R2,[R0, #+4]
        STR      R2,[R1, #+4]
        LDR      R0,[R0, #+8]
        STR      R0,[R1, #+8]
        LDR.W    R0,??DataTable209  ;; 0x40a00000
        STR      R0,[R1, #+12]
        MOVS     R0,#+0
        STR      R0,[R1, #+16]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2720]
        ADDW     R5,R4,#+2720
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
        MOVS     R2,#+20
        MOV      R1,R0
        ADD      R0,R4,#+2496
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+150
        MOVS     R1,#+0
        ADDW     R0,R4,#+2516
          CFI FunCall memset
        BL       memset
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
        STRH     R0,[R5, #+22]
        STRH     R0,[R5, #+26]
        STRB     R0,[R4, #+3432]
        STRB     R0,[R5, #+20]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock103

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191:
        DC32     thermalManager

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191_1:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191_2:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable191_3:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function _Z14mks_WriteToEprv
        THUMB
// __interwork __softfp void mks_WriteToEpr()
_Z14mks_WriteToEprv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??DataTable192_2
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R4, #+2724]
        ADDW     R5,R4,#+2724
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1201
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable208_2
        LDR      R0,[R6, #+0]
        STRH     R0,[R5, #+18]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2742
        MOVW     R0,#+1205
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R7,??DataTable207
        LDRB     R0,[R7, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_WriteToEpr_0
        LDR      R0,[R6, #+4]
        STRH     R0,[R5, #+20]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2744
        MOVW     R0,#+1207
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_0:
        LDRB     R0,[R7, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToEpr_1
        LDR.W    R0,??DataTable208_3
        LDRH     R0,[R0, #+0]
        STRH     R0,[R5, #+22]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2746
        MOVW     R0,#+1209
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_1:
        MOVS     R2,#+4
        ADD      R1,R4,#+2688
        MOVW     R0,#+1211
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2692
        MOVW     R0,#+1215
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2696
        MOVW     R0,#+1219
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2700
        MOVW     R0,#+1223
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2704
        MOVW     R0,#+1227
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2708
        MOVW     R0,#+1231
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2712
        MOVW     R0,#+1235
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2716
        MOVW     R0,#+1239
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.N    R5,??DataTable192_9
        MOVS     R2,#+2
        ADDS     R1,R5,#+2
        MOV      R0,#+1264
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R4,#+2752
        MOVW     R0,#+1247
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2748
        MOVW     R0,#+1243
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        LDR.W    R1,??DataTable211
        MOVW     R0,#+1268
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_1:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_2:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_3:
        DC32     0x42220194

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_4:
        DC32     0x408f4000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_5:
        DC32     0x40590000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_6:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_7:
        DC32     filament_rate

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_8:
        DC32     temperature_change_frequency

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_9:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable192_10:
        DC32     poweroff_det_flg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function mks_ReadFromEpr
        THUMB
// __interwork __softfp void mks_ReadFromEpr()
mks_ReadFromEpr:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R5,??DataTable207_1
        MOVS     R2,#+150
        ADDW     R1,R5,#+2516
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVW     R0,#+1201
        LDR.W    R4,??DataTable210
        LDRB     R1,[R4, #+415]
        CMP      R1,#+1
        BEQ.N    ??mks_ReadFromEpr_0
        MOVS     R2,#+4
        ADDW     R1,R5,#+2724
          CFI FunCall epr_read_data
        BL       epr_read_data
        B.N      ??mks_ReadFromEpr_1
??mks_ReadFromEpr_0:
        MOVS     R2,#+4
        ADDW     R1,R5,#+2732
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2728
        MOVW     R0,#+1269
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_1:
        MOVS     R2,#+2
        ADDW     R1,R5,#+2742
        MOVW     R0,#+1205
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R6,??DataTable207
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_ReadFromEpr_2
        MOVS     R2,#+2
        ADDW     R1,R5,#+2744
        MOVW     R0,#+1207
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_2:
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromEpr_3
        MOVS     R2,#+2
        ADDW     R1,R5,#+2746
        MOVW     R0,#+1209
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_3:
        MOVS     R2,#+4
        ADD      R1,R5,#+2688
        MOVW     R0,#+1211
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2692
        MOVW     R0,#+1215
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2696
        MOVW     R0,#+1219
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2700
        MOVW     R0,#+1223
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2704
        MOVW     R0,#+1227
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2708
        MOVW     R0,#+1231
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2712
        MOVW     R0,#+1235
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2716
        MOVW     R0,#+1239
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R6,??DataTable211_2
        MOVS     R2,#+2
        ADDS     R1,R6,#+2
        MOV      R0,#+1264
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R5,#+2752
        MOVW     R0,#+1247
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2748
        MOVW     R0,#+1243
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable211_3
        MOVS     R2,#+1
        ADDS     R1,R5,#+3
        MOVW     R0,#+1268
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R5, #+3]
        STRB     R0,[R4, #+156]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock105

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193:
        DC32     poweroff_det_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_1:
        DC32     filament_det1_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_2:
        DC32     filament_det1_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_3:
        DC32     filament_det1_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_4:
        DC32     filament_det1_low_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function mks_resumePrint
        THUMB
// __interwork __softfp void mks_resumePrint()
mks_resumePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable207_1
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+170
        BNE.N    ??mks_resumePrint_0
        MOVS     R0,#+167
        STRB     R0,[R4, #+2720]
        LDR      R0,[R4, #+2680]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        ADDW     R0,R4,#+2680
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        MOVS     R1,#+0
        ADDW     R0,R4,#+2516
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
??mks_resumePrint_0:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+171
        BNE.N    ??mks_resumePrint_1
        MOVS     R0,#+172
        STRB     R0,[R4, #+2720]
??mks_resumePrint_1:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock106

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194:
        DC32     filament_det1_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_1:
        DC32     filament_det1_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_2:
        DC32     filament_det2_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_3:
        DC32     filament_det2_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_4:
        DC32     filament_det2_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_5:
        DC32     filament_det2_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_6:
        DC32     filament_det2_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_7:
        DC32     filament_det2_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable194_8:
        DC32     poweroff_det_low_flg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function mks_pausePrint
        THUMB
// __interwork __softfp void mks_pausePrint()
mks_pausePrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.W    R5,??DataTable207_1
        ADDW     R4,R5,#+2668
        LDR.W    R0,??DataTable211_3
        LDR      R1,[R0, #+8]
        STR      R1,[R4, #+20]
        LDR      R1,[R0, #+12]
        STR      R1,[R4, #+24]
        LDR      R1,[R0, #+16]
        STR      R1,[R4, #+28]
        LDR      R1,[R0, #+20]
        STR      R1,[R4, #+32]
        LDR      R1,[R0, #+24]
        STR      R1,[R4, #+36]
        LDR      R1,[R0, #+28]
        STR      R1,[R4, #+40]
        LDR      R1,[R0, #+32]
        STR      R1,[R4, #+44]
        LDR      R1,[R0, #+36]
        STR      R1,[R4, #+48]
        LDR      R1,[R0, #+108]
        STRB     R1,[R5, #+2752]
        LDR      R0,[R0, #+92]
        STR      R0,[R4, #+80]
        LDR.W    R0,??DataTable210
        LDRSB    R0,[R0, #+670]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R0,[R4, #+8]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR      R2,[R5, #+2668]
        LDR.W    R3,??DataTable212  ;; 0xbf800000
        MOV      R0,R2
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??mks_pausePrint_0
        LDR      R4,[R4, #+4]
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??mks_pausePrint_0
        MOV      R1,R4
        MOV      R0,R2
          CFI FunCall mks_moveXY
        BL       mks_moveXY
??mks_pausePrint_0:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14mks_WriteToEprv
        B.N      _Z14mks_WriteToEprv
          CFI EndBlock cfiBlock107

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195:
        DC32     poweroff_det_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_1:
        DC32     poweroff_det_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_2:
        DC32     poweroff_det_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_3:
        DC32     wifi_check_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_4:
        DC32     key_value_calc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_5:
        DC32     tips_disp

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
filament_loading_time_flg:
        DS8 1
filament_loading_completed:
        DS8 1
filament_unloading_time_flg:
        DS8 1
filament_unloading_completed:
        DS8 1
printing_rate_update_flag:
        DS8 1
preview_no_display:
        DS8 1
loop_start:
        DS8 1
        DS8 1
        DS8 1
sd_read_error_flg:
        DS8 1
sd_read_cnt:
        DS8 1
display_hold:
        DS8 1
display_hold_release:
        DS8 1
wifi_init_flg:
        DS8 1
wifi_refresh_flg:
        DS8 1
cloud_refresh_flg:
        DS8 1
waiting_wifi_time:
        DS8 1
beep_flg:
        DS8 1
// __absolute uint8_t volatile has_adjust_speed
has_adjust_speed:
        DS8 1
// __absolute uint8_t print_finish_start_timer
print_finish_start_timer:
        DS8 1
// __absolute uint8_t print_finish_close_machine
print_finish_close_machine:
        DS8 1
        DS8 3
        DS8 4
z_high_count:
        DS8 2
// __absolute uint16_t volatile resume_printed_time
resume_printed_time:
        DS8 2
        DS8 4
filament_loading_time_cnt:
        DS8 4
filament_unloading_time_cnt:
        DS8 4
TimeIncrease:
        DS8 4
home_offset:
        DS8 12
display_hold_cnt:
        DS8 4
beep_cnt:
        DS8 4
// __absolute uint32_t print_finish_timer_count
print_finish_timer_count:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_heat_completed_load:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_heat_completed_unload:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
g26_debug_flag:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
card:
        DS8 2496
// __absolute DATA_REPRINT_ITMES mksReprint
mksReprint:
        DS8 940
print_job_timer:
        DS8 16

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
command_queue:
        DS8 384

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
injected_commands_P:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
saved_feedrate_percentage:
        DS8 2
        DS8 2
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
z_endstop_adj:
        DS8 4
delta_endstop_adj:
        DS8 12

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
hotend_offset:
        DS8 24

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
z_values:
        DS8 576

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
home_dir_P:
        DS8 4
base_min_pos_P:
        DS8 12
base_max_pos_P:
        DS8 12
base_home_pos_P:
        DS8 12
max_length_P:
        DS8 12
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE18serial_line_buffer
_ZZ19get_serial_commandsvE18serial_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_serial_commandsvE19serial_comment_mode
_ZZ19get_serial_commandsvE19serial_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE14last_wait_time
_ZZ19get_serial_commandsvE14last_wait_time:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE14stop_buffering
_ZZ19get_sdcard_commandsvE14stop_buffering:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE15sd_comment_mode
_ZZ19get_sdcard_commandsvE15sd_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvE16wifi_line_buffer
_ZZ17get_wifi_commandsvE16wifi_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ17get_wifi_commandsvE17wifi_comment_mode
_ZZ17get_wifi_commandsvE17wifi_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
_ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
// __absolute unsigned char prepare_kinematic_move_to(float const (&)[4]){9}::_ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
_ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
_ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
??C2:
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
button_disp_pause_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
wifi_init_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
// __absolute uint8_t continue_print_error_flg
continue_print_error_flg:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t1
t1:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t2
t2:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute char t12[10]
t12:
        DS8 12

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function mks_PrintStatePolling
        THUMB
// __interwork __softfp void mks_PrintStatePolling()
mks_PrintStatePolling:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.W    R4,??DataTable207_1
        ADDW     R6,R4,#+2676
        ADDW     R5,R4,#+2720
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+169
        BNE.N    ??mks_PrintStatePolling_0
          CFI FunCall _ZN7Planner13blocks_queuedEv
        BL       _ZN7Planner13blocks_queuedEv
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        CMP      R0,#+101
        BCC.N    ??mks_PrintStatePolling_1
        LDR      R0,[R6, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R6, #+8]
??mks_PrintStatePolling_1:
        LDR      R0,[R6, #+8]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_2
        MOVS     R0,#+170
        STRB     R0,[R4, #+2720]
        LDR.W    R0,??DataTable210
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_3
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_3:
        MOVS     R0,#+0
        STR      R0,[R6, #+8]
          CFI FunCall mks_pausePrint
        BL       mks_pausePrint
        B.N      ??mks_PrintStatePolling_2
??mks_PrintStatePolling_0:
        MOVS     R0,#+0
        STR      R0,[R6, #+8]
??mks_PrintStatePolling_2:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+170
        BNE.N    ??mks_PrintStatePolling_4
        LDR.W    R8,??DataTable211_4  ;; 0x38d1b718
        LDR.W    R7,??DataTable211_3
        LDR      R0,[R6, #+12]
        LDR      R1,[R7, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_5
        LDR      R0,[R7, #+8]
        STR      R0,[R6, #+12]
        MOVS     R2,#+4
        ADD      R1,R4,#+2688
        MOVW     R0,#+1211
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_5:
        LDR      R0,[R6, #+16]
        LDR      R1,[R7, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_6
        LDR      R0,[R7, #+12]
        STR      R0,[R6, #+16]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2692
        MOVW     R0,#+1215
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_6:
        LDR      R0,[R6, #+20]
        LDR      R1,[R7, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R8
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_4
        LDR      R0,[R7, #+16]
        STR      R0,[R6, #+20]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2696
        MOVW     R0,#+1219
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_4:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+168
        BNE.N    ??mks_PrintStatePolling_7
        LDR.W    R0,??DataTable212_1
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_PrintStatePolling_7
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable210
        LDRSB    R0,[R0, #+671]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R6, #+32]
        LDR      R0,[R6, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+173
        BNE.N    ??mks_PrintStatePolling_8
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        B.N      ??mks_PrintStatePolling_9
??mks_PrintStatePolling_8:
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall mks_adjust_extrude_speed
        BL       mks_adjust_extrude_speed
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADDW     R0,R4,#+3436
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??mks_PrintStatePolling_7:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_10
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BNE.N    ??mks_PrintStatePolling_11
        LDRH     R0,[R5, #+52]
        ADDS     R0,R0,#+1
        STRH     R0,[R5, #+52]
        B.N      ??mks_PrintStatePolling_12
??mks_PrintStatePolling_11:
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
??mks_PrintStatePolling_12:
        LDRH     R0,[R5, #+52]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_10
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2720]
        LDR.W    R8,??DataTable210
        LDRB     R0,[R8, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_13
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall mks_clearFile
        BL       mks_clearFile
??mks_PrintStatePolling_13:
        LDRB     R0,[R8, #+217]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_10
        LDR.W    R0,??DataTable213
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_10
        MOVS     R0,#+1
        LDR.W    R1,??DataTable214
        STRB     R0,[R1, #+19]
??mks_PrintStatePolling_10:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+173
        BNE.N    ??mks_PrintStatePolling_14
        MOVS     R0,#+166
        STRB     R0,[R4, #+2720]
        LDR.W    R8,??DataTable210
        LDRB     R0,[R8, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_15
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_15:
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        LDR.W    R7,??DataTable211_3
        LDR      R0,[R7, #+32]
        STR      R0,[R6, #+36]
        LDR      R0,[R4, #+2676]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.W    R0,??DataTable213_1
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        ADDW     R0,R4,#+3436
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        LDR.W    R1,??DataTable215  ;; 0x40000440
        B.N      ??mks_PrintStatePolling_16
??mks_PrintStatePolling_17:
        MOVS     R0,#+0
        STR      R0,[R7, #+108]
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??mks_PrintStatePolling_16:
        CMP      R0,#+0
        BEQ.N    ??mks_PrintStatePolling_17
        MOVS     R0,#+0
        STRB     R0,[R7, #+4]
        LDRB     R0,[R8, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_14
          CFI FunCall mks_clearFile
        BL       mks_clearFile
??mks_PrintStatePolling_14:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+172
        BNE.N    ??mks_PrintStatePolling_18
        LDR.W    R0,??DataTable207
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_19
        CMP      R0,#+2
        BEQ.N    ??mks_PrintStatePolling_20
        CMP      R0,#+4
        BEQ.N    ??mks_PrintStatePolling_19
        CMP      R0,#+8
        BNE.N    ??mks_PrintStatePolling_18
??mks_PrintStatePolling_19:
        LDRSB    R0,[R4, #+3432]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_21
          CFI FunCall mks_contiuePrintPause
        BL       mks_contiuePrintPause
        B.N      ??mks_PrintStatePolling_18
??mks_PrintStatePolling_21:
        CMP      R0,#+2
        BNE.N    ??mks_PrintStatePolling_18
          CFI FunCall mks_contiuePrintPwdwn
        BL       mks_contiuePrintPwdwn
        B.N      ??mks_PrintStatePolling_18
??mks_PrintStatePolling_20:
          CFI FunCall mks_contiuePrintDelta
        BL       mks_contiuePrintDelta
??mks_PrintStatePolling_18:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_22
        LDRB     R0,[R4, #+2488]
        LDRB     R1,[R5, #+20]
        TST      R0,R1
        BEQ.N    ??mks_PrintStatePolling_22
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        CMP      R0,#+101
        BCC.N    ??mks_PrintStatePolling_23
          CFI FunCall mks_WriteToFile
        BL       mks_WriteToFile
??mks_PrintStatePolling_23:
        MOVS     R0,#+0
        STRB     R0,[R5, #+20]
??mks_PrintStatePolling_22:
        LDR.W    R5,??DataTable214
        LDRB     R0,[R5, #+18]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_24
        LDRH     R0,[R5, #+30]
        MOVW     R1,#+10000
        CMP      R0,R1
        BLT.N    ??mks_PrintStatePolling_24
        MOVS     R0,#+0
        STRH     R0,[R5, #+30]
          CFI FunCall mks_resume_extrude_speed
        BL       mks_resume_extrude_speed
??mks_PrintStatePolling_24:
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+166
        BNE.N    ??mks_PrintStatePolling_9
        LDRB     R0,[R5, #+20]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_9
        MOVS     R0,#+0
        STRB     R0,[R5, #+20]
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21Close_machine_displayv
        B.W      _Z21Close_machine_displayv
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_PrintStatePolling_9:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock108

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196:
        DC32     0x76313030

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function _Z18mks_setTemperaturev
        THUMB
// __interwork __softfp void mks_setTemperature()
_Z18mks_setTemperaturev:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+24
          CFI CFA R13+56
        LDR.W    R4,??DataTable207_1
        ADDW     R5,R4,#+2742
        LDR.W    R6,??DataTable207
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_0
        LDRH     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_0
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R7,R4,#+2774
        MOVS     R2,#+7
        ADR.W    R1,`?<Constant "M140 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+4]
        ADR.N    R1,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
??mks_setTemperature_0:
        LDRH     R0,[R4, #+2742]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_1
        ADDW     R7,R4,#+2774
        ADDW     R8,R4,#+2774
        MOV      R9,#+10
        ADR.W    R10,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_setTemperature_2
        MOVS     R2,#+96
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        MOV      R2,R9
        ADR.W    R1,`?<Constant "M104 T1 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        MOV      R1,R10
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
??mks_setTemperature_2:
        MOVS     R2,#+96
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        MOV      R2,R9
        ADR.W    R1,`?<Constant "M109 T0 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R4, #+2742]
        MOV      R1,R10
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_1:
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_setTemperature_3
        LDRH     R0,[R5, #+2]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_3
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R7,R4,#+2774
        MOVS     R2,#+10
        ADR.W    R1,`?<Constant "M109 T1 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        ADR.N    R1,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_3:
        LDRB     R0,[R6, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_4
        LDRH     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_4
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R7,R4,#+2774
        MOVS     R2,#+7
        ADR.W    R1,`?<Constant "M190 S">`
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+4]
        ADR.N    R1,??DataTable202  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
??mks_setTemperature_4:
        ADD      SP,SP,#+24
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock109

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M140 S">`:
        DC8 "M140 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M104 T1 S">`:
        DC8 "M104 T1 S"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M109 T0 S">`:
        DC8 "M109 T0 S"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M109 T1 S">`:
        DC8 "M109 T1 S"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "M190 S">`:
        DC8 "M190 S"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function mks_setPositionZ
        THUMB
// __interwork __softfp void mks_setPositionZ()
mks_setPositionZ:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        LDR.W    R4,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R4,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R5,R4,#+2774
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R4, #+2696]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        MOVS     R0,#+0
        LDR.W    R1,??DataTable211_3
        STR      R0,[R1, #+76]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock110

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function _Z18mks_ResetPositionZf
        THUMB
// __interwork __softfp void mks_ResetPositionZ(float)
_Z18mks_ResetPositionZf:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        LDR.W    R5,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+2774
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 Z">`
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        MOVS     R0,#+0
        LDR.W    R1,??DataTable211_3
        STR      R0,[R1, #+76]
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G92 Z">`:
        DC8 "G92 Z"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function _Z15mks_setFeedratev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setFeedrate()
_Z15mks_setFeedratev:
        LDR.N    R0,??DataTable207_1
        LDR      R0,[R0, #+2748]
        LDR.W    R1,??DataTable211_3
        STR      R0,[R1, #+92]
        BX       LR               ;; return
          CFI EndBlock cfiBlock112

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function mks_preExtrude
        THUMB
// __interwork __softfp void mks_preExtrude(float)
mks_preExtrude:
        PUSH     {R4-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+28
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOV      R9,R0
        LDR.W    R4,??DataTable215_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
        LDR.N    R5,??DataTable207_1
        ADDW     R8,R5,#+2774
        MOVS     R2,#+96
        MOVS     R1,#+0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        ADDW     R6,R5,#+2774
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 E">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R7,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
        MOVS     R2,#+96
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+6
        ADR.W    R1,`?<Constant "G92 E">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R5, #+2716]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        ADD      SP,SP,#+20
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
          CFI EndBlock cfiBlock113

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 E">`:
        DC8 "G1 E"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G92 E">`:
        DC8 "G92 E"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function mks_moveXY
        THUMB
// __interwork __softfp void mks_moveXY(float, float)
mks_moveXY:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R4,R1
        LDR.N    R6,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R6,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R6,R6,#+2774
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R7,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable208  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock114

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_1:
        DC32     0x494949

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_2:
        DC32     0xaaaaaa

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function mks_moveZ
        THUMB
// __interwork __softfp void mks_moveZ(float)
mks_moveZ:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R5,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R6,R5,#+2774
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R5, #+2712]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock115

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function _Z18mks_moveZ_relativef
        THUMB
// __interwork __softfp void mks_moveZ_relative(float)
_Z18mks_moveZ_relativef:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOV      R5,R0
        LDR.W    R4,??DataTable215_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+5]
        LDR.N    R6,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R6,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R6,R6,#+2774
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable204  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock116

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_1:
        DC32     wifiPara

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable204_2:
        DC32     ipPara

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function _Z7mks_G28Pc
        THUMB
// __interwork __softfp void mks_G28(char *)
_Z7mks_G28Pc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R5,R5,#+2774
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
        LDR.N    R4,??DataTable207
        LDRB     R0,[R4, #+64]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??mks_G28_0
        CMP      R0,#+16
        BEQ.N    ??mks_G28_0
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+2
        BEQ.N    ??mks_G28_0
        LDRB     R0,[R4, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??mks_G28_0
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??mks_G28_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+1
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17set_z_fade_heightfb
        B.W      _Z17set_z_fade_heightfb
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_G28_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock117

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function _Z18mks_leveling_moveZf
        THUMB
// __interwork __softfp void mks_leveling_moveZ(float)
_Z18mks_leveling_moveZf:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R4,R0
        LDR.N    R5,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R5,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R6,R5,#+2774
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 Z">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall memset
        BL       memset
        LDR.W    R0,??DataTable219_1
        LDR      R1,[R0, #+8]
        LDR.W    R0,??DataTable221  ;; 0x42700000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        LDR      R0,[R5, #+2712]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f F%.3f">`
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock118

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable206:
        DC32     BMP_PIC_X

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z">`:
        DC8 "G1 Z"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function _Z19mks_leveling_moveXYff
        THUMB
// __interwork __softfp void mks_leveling_moveXY(float, float)
_Z19mks_leveling_moveXYff:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOV      R5,R0
        MOV      R4,R1
        LDR.N    R6,??DataTable207_1
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADDW     R0,R6,#+2774
          CFI FunCall memset
        BL       memset
        ADDW     R6,R6,#+2774
        MOVS     R2,#+5
        ADR.W    R1,`?<Constant "G1 X">`
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall memset
        BL       memset
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f">`
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable208  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall memset
        BL       memset
        LDR.W    R0,??DataTable223
        LDR      R0,[R0, #+36]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.W    R1,`?<Constant "%.3f F%.3f">`
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z11gcode_G0_G1v
        BL       _Z11gcode_G0_G1v
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 X">`:
        DC8 "G1 X"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "%.3f">`:
        DC8 "%.3f"
        DC8 0, 0, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "%.3f F%.3f">`:
        DC8 "%.3f F%.3f"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function mks_manual_leveling
        THUMB
// __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
mks_manual_leveling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R0,??DataTable219_2
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_manual_leveling_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADR.N    R0,??DataTable211_1  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
??mks_manual_leveling_0:
        LDR.N    R0,??DataTable211_3
        LDR      R0,[R0, #+16]
        LDR.W    R1,??DataTable220_1
        STR      R0,[R1, #+2712]
        LDR.W    R0,??DataTable224  ;; 0x41200000
          CFI FunCall _Z18mks_leveling_moveZf
        BL       _Z18mks_leveling_moveZf
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R5,R1
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _Z19mks_leveling_moveXYff
        BL       _Z19mks_leveling_moveXYff
        ADR.W    R0,`?<Constant "G1 Z0">`
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        B.W      _Z27enqueue_and_echo_commands_PPKc
          CFI EndBlock cfiBlock120

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable208:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable208_1:
        DC32     BMP_PIC_Y

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable208_2:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable208_3:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G1 Z0">`:
        DC8 "G1 Z0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function mks_contiuePrintPause
        THUMB
// __interwork __softfp void mks_contiuePrintPause()
mks_contiuePrintPause:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable220_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.W    R0,`?<Constant "G28 X0 Y0">`
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPause_0
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        POP      {R4,PC}
??mks_contiuePrintPause_0:
        LDR      R0,[R4, #+2680]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        ADDW     R0,R4,#+2680
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
          CFI FunCall mks_adjust_extrude_speed
        BL       mks_adjust_extrude_speed
        LDRB     R0,[R4, #+2752]
        LDR.N    R1,??DataTable211_3
        STR      R0,[R1, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable215  ;; 0x40000440
        STR      R0,[R1, #+0]
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPause_1
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        POP      {R4,PC}
??mks_contiuePrintPause_1:
        MOVS     R0,#+167
        STRB     R0,[R4, #+2720]
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock121

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable209:
        DC32     0x40a00000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function mks_contiuePrintPwdwn
        THUMB
// __interwork __softfp void mks_contiuePrintPwdwn()
mks_contiuePrintPwdwn:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable220_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR      R0,[R4, #+2676]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        ADR.W    R0,`?<Constant "G28 X0 Y0">`
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPwdwn_0
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        POP      {R0,R4,R5,PC}
??mks_contiuePrintPwdwn_0:
        ADDW     R5,R4,#+2676
        LDR.W    R0,??DataTable223
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??mks_contiuePrintPwdwn_1
        LDR      R1,[R5, #+20]
        LDR      R0,[R4, #+2676]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall _Z18mks_ResetPositionZf
        BL       _Z18mks_ResetPositionZf
??mks_contiuePrintPwdwn_1:
        MOVW     R0,#+3000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        LDR      R0,[R5, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
          CFI FunCall mks_adjust_extrude_speed
        BL       mks_adjust_extrude_speed
        LDRB     R0,[R4, #+2752]
        LDR.N    R1,??DataTable211_3
        STR      R0,[R1, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable215  ;; 0x40000440
        STR      R0,[R1, #+0]
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPwdwn_2
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        POP      {R0,R4,R5,PC}
??mks_contiuePrintPwdwn_2:
        MOVS     R0,#+167
        STRB     R0,[R4, #+2720]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R4, #+2740]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock122

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "G28 X0 Y0">`:
        DC8 "G28 X0 Y0"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function mks_contiuePrintDelta
        THUMB
// __interwork __softfp void mks_contiuePrintDelta()
mks_contiuePrintDelta:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable220_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.N    R0,??DataTable211_1  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDR      R0,[R4, #+2676]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        ADDW     R5,R4,#+2676
        LDR      R0,[R5, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall _Z15mks_setFeedratev
        BL       _Z15mks_setFeedratev
        LDRB     R0,[R4, #+2752]
        LDR.N    R1,??DataTable211_3
        STR      R0,[R1, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable215  ;; 0x40000440
        STR      R0,[R1, #+0]
        MOVS     R0,#+167
        STRB     R0,[R4, #+2720]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R4, #+2740]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable211:
        DC32     mks_heating_busy+0x3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable211_1:
        DC8      "G28"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable211_2:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable211_3:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable211_4:
        DC32     0x38d1b718

        SECTION `.data`:DATA:REORDER:NOROOT(0)
// static __absolute uint8_t first_resu
first_resu:
        DATA
        DC8 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function mks_getPositionXYZE
        THUMB
// __interwork __softfp void mks_getPositionXYZE()
mks_getPositionXYZE:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+24
          CFI CFA R13+56
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        LDR.W    R0,??DataTable225
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_getPositionXYZE_0
        LDR.W    R4,??DataTable220_1
        ADDW     R5,R4,#+2696
        LDR      R1,[R5, #+28]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        STRB     R0,[R4, #+2740]
        LDR.W    R6,??DataTable225_1
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_1
??mks_getPositionXYZE_2:
        ADD      R1,R6,R0, LSL #+2
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+24]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_1:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_2
        MOV      R7,R2
        B.N      ??mks_getPositionXYZE_3
??mks_getPositionXYZE_4:
        ADD      R2,R4,R3, LSL #+2
        LDR      R0,[R2, #+2704]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_5
        LDR.W    R6,??DataTable225_1
        ADD      R6,R6,R3, LSL #+2
        LDR      R0,[R6, #+24]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_5
        LDR      R0,[R6, #+24]
        STR      R0,[R2, #+2704]
??mks_getPositionXYZE_5:
        ADDS     R3,R3,#+1
??mks_getPositionXYZE_6:
        CMP      R3,#+4
        BLT.N    ??mks_getPositionXYZE_4
        ADDS     R7,R7,#+1
??mks_getPositionXYZE_3:
        CMP      R7,#+4
        BGE.N    ??mks_getPositionXYZE_7
        CMP      R7,#+0
        BNE.N    ??mks_getPositionXYZE_8
        LDR.W    R0,??DataTable226
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_getPositionXYZE_8
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        MOVS     R1,#+90
        LDR.W    R0,??DataTable226_1
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??mks_getPositionXYZE_9
??mks_getPositionXYZE_10:
        LDRSB    R1,[R0], #+1
        CMP      R1,#+0
        BEQ.N    ??mks_getPositionXYZE_11
        LDRSB    R1,[SP, #+0]
        ADDS     R2,R1,#+1
        STRB     R2,[SP, #+0]
        LDRB     R2,[R0, #+0]
        STRB     R2,[R1, R3]
        LDRSB    R1,[SP, #+0]
        CMP      R1,#+21
        BLT.N    ??mks_getPositionXYZE_10
??mks_getPositionXYZE_11:
        ADD      R0,SP,#+4
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable225_1
        STR      R0,[R1, #+32]
        B.N      ??mks_getPositionXYZE_9
??mks_getPositionXYZE_8:
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable226_1
        ADD      R0,R1,R0, LSL #+5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??mks_getPositionXYZE_9:
        MOVS     R3,#+0
        LDR.W    R1,??DataTable226_2  ;; 0x38d1b718
        B.N      ??mks_getPositionXYZE_6
??mks_getPositionXYZE_7:
        LDR      R0,[R5, #+16]
        STR      R0,[R4, #+2696]
        LDR      R0,[R5, #+20]
        STR      R0,[R5, #+4]
        B.N      ??mks_getPositionXYZE_12
??mks_getPositionXYZE_0:
        MOVS     R0,#+0
        LDR.W    R6,??DataTable225_1
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_13
??mks_getPositionXYZE_14:
        ADD      R1,R6,R0, LSL #+2
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+24]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_13:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_14
        LDR.W    R4,??DataTable220_1
        ADDW     R5,R4,#+2696
        LDR      R1,[R5, #+32]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        B.N      ??mks_getPositionXYZE_15
??mks_getPositionXYZE_16:
        LDR      R0,[R5, #+16]
        STR      R0,[R4, #+2696]
        LDR      R0,[R5, #+20]
        STR      R0,[R5, #+4]
??mks_getPositionXYZE_15:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        LDR      R1,[R5, #+36]
        CMP      R0,R1
        BCS.N    ??mks_getPositionXYZE_17
        MOVS     R0,#+0
        STRB     R0,[R6, #+2]
        MOVS     R0,#+1
        STRB     R0,[R4, #+2488]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R7,#+0
        B.N      ??mks_getPositionXYZE_18
??mks_getPositionXYZE_19:
        ADDS     R7,R7,#+1
??mks_getPositionXYZE_18:
        CMP      R7,#+4
        BGE.N    ??mks_getPositionXYZE_16
        CMP      R7,#+0
        BNE.N    ??mks_getPositionXYZE_20
        LDR.W    R0,??DataTable226
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_getPositionXYZE_20
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        MOVS     R1,#+90
        LDR.W    R0,??DataTable226_1
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??mks_getPositionXYZE_21
??mks_getPositionXYZE_22:
        LDRSB    R1,[R0], #+1
        CMP      R1,#+0
        BEQ.N    ??mks_getPositionXYZE_23
        LDRSB    R1,[SP, #+0]
        ADDS     R2,R1,#+1
        STRB     R2,[SP, #+0]
        LDRB     R2,[R0, #+0]
        STRB     R2,[R1, R3]
        LDRSB    R1,[SP, #+0]
        CMP      R1,#+21
        BLT.N    ??mks_getPositionXYZE_22
??mks_getPositionXYZE_23:
        ADD      R0,SP,#+4
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+32]
        B.N      ??mks_getPositionXYZE_21
??mks_getPositionXYZE_20:
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??DataTable226_1
        ADD      R0,R1,R0, LSL #+5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??mks_getPositionXYZE_21:
        MOV      R8,#+0
        B.N      ??mks_getPositionXYZE_24
??mks_getPositionXYZE_25:
        MOVS     R0,#+0
??mks_getPositionXYZE_26:
          CFI FunCall abs
        BL       abs
        CMP      R0,#+0
        BEQ.N    ??mks_getPositionXYZE_27
        LDR      R0,[R10, #+24]
        STR      R0,[R9, #+2704]
??mks_getPositionXYZE_27:
        ADD      R8,R8,#+1
??mks_getPositionXYZE_24:
        CMP      R8,#+4
        BGE.N    ??mks_getPositionXYZE_19
        ADD      R9,R4,R8, LSL #+2
        LDR.W    R1,??DataTable226_2  ;; 0x38d1b718
        LDR      R0,[R9, #+2704]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_28
        ADD      R10,R6,R8, LSL #+2
        LDR      R0,[R10, #+24]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_28
        LDR      R0,[R10, #+24]
        STR      R0,[R9, #+2704]
??mks_getPositionXYZE_28:
        CMP      R8,#+2
        BEQ.N    ??mks_getPositionXYZE_27
        ADD      R10,R6,R8, LSL #+2
        LDR      R0,[R10, #+24]
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_getPositionXYZE_25
        MOVS     R0,#+1
        B.N      ??mks_getPositionXYZE_26
??mks_getPositionXYZE_17:
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        STRB     R0,[R4, #+2740]
??mks_getPositionXYZE_12:
        MOVS     R0,#+0
        LDR.W    R6,??DataTable225_1
        MOV      R2,R0
        B.N      ??mks_getPositionXYZE_29
??mks_getPositionXYZE_30:
        ADD      R1,R6,R0, LSL #+2
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+24]
        ADDS     R0,R0,#+1
??mks_getPositionXYZE_29:
        CMP      R0,#+4
        BLT.N    ??mks_getPositionXYZE_30
        MOV      R4,R2
        B.N      ??mks_getPositionXYZE_31
??mks_getPositionXYZE_32:
        MOVS     R2,#+96
        MOVS     R1,#+0
        ADD      R0,R4,R4, LSL #+1
        LDR.W    R3,??DataTable226_1
        ADD      R0,R3,R0, LSL #+5
          CFI FunCall memset
        BL       memset
        ADDS     R4,R4,#+1
??mks_getPositionXYZE_31:
        CMP      R4,#+4
        BLT.N    ??mks_getPositionXYZE_32
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
        ADD      SP,SP,#+24
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock124

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable212:
        DC32     0xbf800000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable212_1:
        DC32     pause_resum

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function mks_clearDir
        THUMB
// __interwork __softfp void mks_clearDir()
mks_clearDir:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+32
          CFI CFA R13+40
        LDR.W    R4,??DataTable226_3
        B.N      ??mks_clearDir_0
??mks_clearDir_1:
        ADDS     R1,R0,#+1
        ADD      R0,SP,#+0
          CFI FunCall strcpy
        BL       strcpy
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcpy
        BL       strcpy
??mks_clearDir_0:
        ADR.N    R1,??DataTable215_1  ;; "/"
        MOV      R0,R4
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BNE.N    ??mks_clearDir_1
        ADD      SP,SP,#+32
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock125

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable213:
        DC32     IsChooseAutoShutdown

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable213_1:
        DC32     `?<Constant "G28 X0 Y0">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function mks_contiuePrint_UI
        THUMB
// __interwork __softfp void mks_contiuePrint_UI()
mks_contiuePrint_UI:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R1,#+0
        ADR.W    R0,`?<Constant "Resume print?">`
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.W    R4,??DataTable220_1
        ADDW     R5,R4,#+2516
        MOVS     R3,#+1
        MOV      R2,R3
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R1,R5
        LDR.W    R0,??DataTable226_4
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10isFileOpenEv
        BL       _ZN10CardReader10isFileOpenEv
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_0
        MOV      R0,#+1200
          CFI FunCall _Z6Beeperj
        BL       _Z6Beeperj
        MOVS     R0,#+2
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_dialog
        B.W      draw_dialog
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_0:
        ADDW     R6,R4,#+2720
        LDR      R0,[R6, #+4]
        CMP      R0,#+101
        BCS.N    ??mks_contiuePrint_UI_1
        LDR      R0,[R6, #+12]
        CMP      R0,#+101
        BCC.N    ??mks_contiuePrint_UI_2
??mks_contiuePrint_UI_1:
        MOVS     R2,#+150
        ADDW     R1,R4,#+2516
        MOVW     R0,#+1277
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRB     R0,[R4, #+2488]
        LDRSB    R0,[R4, #+3432]
        CMP      R0,#+2
        BNE.N    ??mks_contiuePrint_UI_3
          CFI FunCall mks_getPositionXYZE
        BL       mks_getPositionXYZE
??mks_contiuePrint_UI_3:
        LDR.W    R5,??DataTable225
        LDRB     R0,[R5, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_4
        LDR      R1,[R6, #+4]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
        B.N      ??mks_contiuePrint_UI_5
??mks_contiuePrint_UI_4:
        LDR      R1,[R6, #+12]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??mks_contiuePrint_UI_5:
        LDR.W    R0,??DataTable225_1
        LDR      R1,[R4, #+2688]
        STR      R1,[R0, #+8]
        ADDW     R1,R4,#+2688
        LDR      R2,[R1, #+4]
        STR      R2,[R0, #+12]
        LDR      R1,[R1, #+8]
        STR      R1,[R0, #+16]
        LDRB     R0,[R5, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_6
          CFI FunCall mks_clearDir
        BL       mks_clearDir
??mks_contiuePrint_UI_6:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable226_5
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable226_6
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCS.N    ??mks_contiuePrint_UI_7
        LDRSB    R0,[R5, #+186]
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_6
??mks_contiuePrint_UI_7:
        LDR.W    R4,??DataTable226_7
        MOVS     R2,#+1
        MOV      R1,R4
        MOV      R0,#+1792
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??mks_contiuePrint_UI_8
        MOVS     R0,#+1
        LDR.W    R1,??DataTable226_8
        STRB     R0,[R1, #+0]
        B.N      ??mks_contiuePrint_UI_9
??mks_contiuePrint_UI_8:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable226_9
        STRB     R0,[R1, #+0]
??mks_contiuePrint_UI_9:
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_printing
        B.W      draw_printing
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_2:
        MOVS     R0,#+0
        STRB     R0,[R4, #+3432]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2720]
        LDR.W    R0,??DataTable225
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_10
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_contiuePrint_UI_10:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable226_10
        STRB     R0,[R1, #+0]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock126

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable214:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "Resume print?">`:
        DC8 "Resume print?"
        DC8 0, 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function mks_rePrintCheck
        THUMB
// __interwork __softfp void mks_rePrintCheck()
mks_rePrintCheck:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable226_11
        ADDW     R5,R4,#+2720
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+170
        BNE.N    ??mks_rePrintCheck_0
        MOVS     R0,#+171
        STRB     R0,[R4, #+2720]
          CFI FunCall mks_ReadFromEpr
        BL       mks_ReadFromEpr
        MOVS     R0,#+1
        STRB     R0,[R4, #+3432]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_0:
        LDR.W    R1,??DataTable226_12
        CMP      R0,#+167
        BNE.N    ??mks_rePrintCheck_2
        LDRB     R0,[R1, #+415]
        CMP      R0,#+1
        BNE.N    ??mks_rePrintCheck_3
        MOVS     R0,#+171
        STRB     R0,[R4, #+2720]
          CFI FunCall _Z22mks_ReadFromEpr_pwroffv
        BL       _Z22mks_ReadFromEpr_pwroffv
        MOVS     R0,#+2
        STRB     R0,[R4, #+3432]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_3:
        MOVS     R0,#+171
        STRB     R0,[R4, #+2720]
        MOVS     R2,#+150
        ADDW     R1,R4,#+2516
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
          CFI FunCall mks_ReadFromFile
        BL       mks_ReadFromFile
        MOVS     R0,#+2
        STRB     R0,[R4, #+3432]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_2:
        MOVS     R0,#+166
        STRB     R0,[R4, #+2720]
        LDRB     R0,[R1, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_rePrintCheck_4
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_rePrintCheck_4:
        MOVS     R0,#+1
        LDR.W    R1,??DataTable226_10
        STRB     R0,[R1, #+0]
??mks_rePrintCheck_1:
        LDR.W    R0,??DataTable226_10
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_rePrintCheck_5
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
??mks_rePrintCheck_6:
        LDR.W    R0,??DataTable226_13
        LDRB     R0,[R0, #+19]
        CMP      R0,#+1
        BEQ.N    ??mks_rePrintCheck_5
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable226_5
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable226_6
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCC.N    ??mks_rePrintCheck_6
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_ready_print
        B.W      draw_ready_print
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_rePrintCheck_5:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock127

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable215:
        DC32     0x40000440

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable215_1:
        DC8      "/",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable215_2:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock128 Using cfiCommon0
          CFI Function mks_WriteToFile
        THUMB
// __interwork __softfp void mks_WriteToFile()
mks_WriteToFile:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+56
          CFI CFA R13+80
        ADD      R0,SP,#+20
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.W    R7,??DataTable220_1
        LDRB     R0,[R7, #+2491]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToFile_0
        LDR.W    R1,??DataTable226_14
        ADD      R0,SP,#+20
          CFI FunCall strcat
        BL       strcat
??mks_WriteToFile_0:
        LDR.W    R0,??DataTable226_15
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+20
          CFI FunCall strcat
        BL       strcat
        ADDW     R4,R7,#+2872
        MOVS     R2,#+3
        ADD      R1,SP,#+20
        MOV      R0,R4
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.W    ??mks_WriteToFile_1
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+7
        ADR.W    R1,`?<Constant "start\\n">`
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADR.N    R5,??DataTable217  ;; 0x25, 0x64, 0x00, 0x00
        LDR      R2,[R7, #+2724]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADR.N    R6,??DataTable217_1  ;; "\n"
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R8,??DataTable226_16
        LDR      R2,[R8, #+0]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R2,[R8, #+4]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R0,??DataTable226_17
        LDRSH    R2,[R0, #+0]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        ADDW     R3,R7,#+2764
        ADDW     R2,R7,#+2760
        ADDW     R1,R7,#+2756
        ADDW     R0,R7,#+3436
          CFI FunCall _ZN9Stopwatch7getTimeEPmS0_S0_
        BL       _ZN9Stopwatch7getTimeEPmS0_S0_
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDW     R7,R7,#+2724
        STR      R0,[R7, #+44]
        LDR      R1,[R7, #+40]
        LDR      R2,[R7, #+36]
        CMP      R1,R2
        BCS.N    ??mks_WriteToFile_2
        STR      R0,[R7, #+40]
??mks_WriteToFile_2:
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R2,[R7, #+32]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R7,??DataTable226_18
        LDRH     R2,[R7, #+2]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDRB     R2,[R7, #+4]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDRSB    R2,[R7, #+5]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR.W    R7,??DataTable225_1
        LDR      R2,[R7, #+108]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDR      R0,[R7, #+92]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable219  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        LDRB     R2,[R7, #+3]
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOVS     R2,#+20
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        MOVS     R2,#+4
        ADR.N    R1,??DataTable220  ;; "end"
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R0,R4
          CFI FunCall f_close
        BL       f_close
??mks_WriteToFile_1:
        ADD      SP,SP,#+56
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock128

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "start\\n">`:
        DC8 "start\012"
        DC8 0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function _Z21mks_WriteToEpr_pwroffv
        THUMB
// __interwork __softfp void mks_WriteToEpr_pwroff()
_Z21mks_WriteToEpr_pwroffv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??DataTable220_1
        MOVS     R2,#+1
        ADD      R1,R4,#+2720
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2728
        MOVW     R0,#+1269
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R4, #+2724]
        ADDW     R5,R4,#+2724
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1201
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable226_16
        LDR      R0,[R6, #+0]
        STRH     R0,[R5, #+18]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2742
        MOVW     R0,#+1205
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R7,??DataTable223
        LDRB     R0,[R7, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_WriteToEpr_pwroff_0
        LDR      R0,[R6, #+4]
        STRH     R0,[R5, #+20]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2744
        MOVW     R0,#+1207
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_pwroff_0:
        LDRB     R0,[R7, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_WriteToEpr_pwroff_1
        LDR.W    R0,??DataTable226_17
        LDRH     R0,[R0, #+0]
        STRH     R0,[R5, #+22]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2746
        MOVW     R0,#+1209
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_pwroff_1:
        LDR.W    R6,??DataTable226_18
        MOVS     R2,#+2
        ADDS     R1,R6,#+2
        MOV      R0,#+1264
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable225_1
        LDR      R0,[R6, #+108]
        STRB     R0,[R5, #+28]
        MOVS     R2,#+1
        ADD      R1,R4,#+2752
        MOVW     R0,#+1247
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR      R0,[R6, #+92]
        STR      R0,[R5, #+24]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2748
        MOVW     R0,#+1243
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+3
        MOVW     R0,#+1268
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable217_1:
        DC8      "\n",0x0,0x0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function _Z22mks_ReadFromEpr_pwroffv
        THUMB
// __interwork __softfp void mks_ReadFromEpr_pwroff()
_Z22mks_ReadFromEpr_pwroffv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??DataTable220_1
        MOVS     R2,#+150
        ADDW     R1,R4,#+2516
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2732
        MOVW     R0,#+1201
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2728
        MOVW     R0,#+1269
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADDW     R1,R4,#+2742
        MOVW     R0,#+1205
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.N    R5,??DataTable223
        LDRB     R0,[R5, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_ReadFromEpr_pwroff_0
        MOVS     R2,#+2
        ADDW     R1,R4,#+2744
        MOVW     R0,#+1207
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_pwroff_0:
        LDRB     R0,[R5, #+54]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromEpr_pwroff_1
        MOVS     R2,#+2
        ADDW     R1,R4,#+2746
        MOVW     R0,#+1209
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_pwroff_1:
        LDR.W    R5,??DataTable226_18
        MOVS     R2,#+2
        ADDS     R1,R5,#+2
        MOV      R0,#+1264
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+2752
        MOVW     R0,#+1247
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2748
        MOVW     R0,#+1243
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.N    R4,??DataTable225_1
        MOVS     R2,#+1
        ADDS     R1,R4,#+3
        MOVW     R0,#+1268
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R4, #+3]
        LDR.W    R1,??DataTable226_12
        STRB     R0,[R1, #+156]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function _Z7pft_getv
        THUMB
// __interwork __softfp int16_t pft_get()
_Z7pft_getv:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        LDR.W    R4,??DataTable226_11
        ADD      R3,SP,#+4
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        ADDW     R0,R4,#+2872
          CFI FunCall f_read
        BL       f_read
        CMP      R0,#+0
        BEQ.N    ??pft_get_0
        MOVS     R0,#+255
        STRB     R0,[SP, #+0]
        B.N      ??pft_get_1
??pft_get_0:
        LDR      R0,[R4, #+2736]
        LDR      R1,[SP, #+4]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+2736]
??pft_get_1:
        LDRB     R0,[SP, #+0]
        POP      {R1,R2,R4,PC}    ;; return
          CFI EndBlock cfiBlock131

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable219:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable219_1:
        DC32     _ZN7Planner17max_feedrate_mm_sE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable219_2:
        DC32     leveling_first_time

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function _Z16mks_get_commandsv
        THUMB
// __interwork __softfp bool mks_get_commands()
_Z16mks_get_commandsv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+24
          CFI CFA R13+48
        MOVS     R5,#+0
        MOV      R8,R5
        MOV      R4,R5
        LDR.N    R7,??DataTable220_1
        B.N      ??mks_get_commands_1
??mks_get_commands_2:
        ADR.N    R1,??DataTable220  ;; "end"
        ADD      R0,SP,#+0
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??mks_get_commands_3
        MOVS     R4,#+1
??mks_get_commands_3:
        MOV      R8,#+0
        MOVS     R2,#+20
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall memset
        BL       memset
        ADDS     R5,R5,#+1
??mks_get_commands_1:
        ADDW     R6,R7,#+2724
        LDR      R0,[R6, #+12]
        LDR      R1,[R7, #+3428]
        CMP      R0,R1
        BCS.N    ??mks_get_commands_4
          CFI FunCall _Z7pft_getv
        BL       _Z7pft_getv
        CMN      R0,#+1
        BEQ.N    ??mks_get_commands_4
        MOV      R1,R8
        SXTB     R0,R0
        CMP      R0,#+10
        BNE.N    ??mks_get_commands_5
        MOVS     R0,#+0
        ADD      R2,SP,#+0
        ADDS     R1,R1,R2
        STRB     R0,[R1, #-1]
        SXTB     R5,R5
        MOV      R0,R5
        SUBS     R0,R0,#+1
        CMP      R0,#+11
        BHI.N    ??mks_get_commands_3
        TBB      [PC, R0]
        DATA
??mks_get_commands_0:
        DC8      0x8,0xE,0x13,0x18
        DC8      0x1D,0x22,0x28,0x2E
        DC8      0x34,0x39,0x40,0x6
        THUMB
??mks_get_commands_6:
        B.N      ??mks_get_commands_2
??mks_get_commands_7:
        B.N      ??mks_get_commands_3
??mks_get_commands_8:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STR      R0,[R7, #+2724]
        B.N      ??mks_get_commands_3
??mks_get_commands_9:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRH     R0,[R6, #+18]
        B.N      ??mks_get_commands_3
??mks_get_commands_10:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRH     R0,[R6, #+20]
        B.N      ??mks_get_commands_3
??mks_get_commands_11:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRH     R0,[R6, #+22]
        B.N      ??mks_get_commands_3
??mks_get_commands_12:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STR      R0,[R6, #+32]
        B.N      ??mks_get_commands_3
??mks_get_commands_13:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        LDR.N    R1,??DataTable226_18
        STRH     R0,[R1, #+2]
        B.N      ??mks_get_commands_3
??mks_get_commands_14:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        LDR.N    R1,??DataTable226_18
        STRB     R0,[R1, #+4]
        B.N      ??mks_get_commands_3
??mks_get_commands_15:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        LDR.N    R1,??DataTable226_18
        STRB     R0,[R1, #+5]
        B.N      ??mks_get_commands_3
??mks_get_commands_16:
        ADD      R0,SP,#+0
          CFI FunCall atoi
        BL       atoi
        STRB     R0,[R6, #+28]
        B.N      ??mks_get_commands_3
??mks_get_commands_17:
        ADD      R0,SP,#+0
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+24]
        B.N      ??mks_get_commands_3
??mks_get_commands_18:
        LDR.N    R6,??DataTable225
        ADD      R0,SP,#+0
          CFI FunCall atof
        BL       atof
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        STRB     R0,[R6, #+156]
        LDRB     R0,[R6, #+156]
        LDR.N    R1,??DataTable225_1
        STRB     R0,[R1, #+3]
        B.N      ??mks_get_commands_3
??mks_get_commands_5:
        ADD      R2,SP,#+0
        STRB     R0,[R1, R2]
        ADD      R8,R8,#+1
        UXTH     R8,R8
        CMP      R8,#+20
        BLT.N    ??mks_get_commands_1
??mks_get_commands_4:
        MOV      R0,R4
        ADD      SP,SP,#+24
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock132

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable220:
        DC8      "end"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable220_1:
        DC32     card

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function mks_ReadFromFile
        THUMB
// __interwork __softfp bool mks_ReadFromFile()
mks_ReadFromFile:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOVS     R4,#+0
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.N    R5,??DataTable226_11
        LDRB     R0,[R5, #+2491]
        CMP      R0,#+0
        BEQ.N    ??mks_ReadFromFile_0
        LDR.N    R1,??DataTable226_14
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
??mks_ReadFromFile_0:
        LDR.N    R0,??DataTable226_15
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADDW     R6,R5,#+2872
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.N    ??mks_ReadFromFile_1
        MOV      R0,R4
        STR      R0,[R5, #+2736]
        LDR      R0,[R5, #+3396]
        STR      R0,[R5, #+3428]
          CFI FunCall _Z16mks_get_commandsv
        BL       _Z16mks_get_commandsv
        MOV      R4,R0
        MOV      R0,R6
          CFI FunCall f_close
        BL       f_close
??mks_ReadFromFile_1:
        MOV      R0,R4
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock133

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable221:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function mks_clearFile
        THUMB
// __interwork __softfp void mks_clearFile()
mks_clearFile:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+56
          CFI CFA R13+64
        ADD      R0,SP,#+32
        ADR.W    R1,`?<Constant "clear">`
        MOVS     R2,#+20
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADD      R0,SP,#+0
        MOVS     R1,#+32
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.N    R4,??DataTable226_11
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??mks_clearFile_0
        LDR.N    R1,??DataTable226_14
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
??mks_clearFile_0:
        LDR.N    R0,??DataTable226_15
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADDW     R4,R4,#+2872
        MOVS     R2,#+10
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.N    ??mks_clearFile_1
        ADD      R1,SP,#+32
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R0,R4
          CFI FunCall f_close
        BL       f_close
??mks_clearFile_1:
        ADD      SP,SP,#+56
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock134

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function mks_saveFileName
        THUMB
// __interwork __softfp void mks_saveFileName(char *)
mks_saveFileName:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable226_11
        MOVS     R2,#+150
        MOVS     R1,#+0
        ADDW     R0,R5,#+2516
          CFI FunCall memset
        BL       memset
        MOV      R1,R4
        ADDW     R0,R5,#+2516
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R2,#+150
        ADDW     R1,R5,#+2516
        MOVW     R0,#+1277
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDRB     R0,[R5, #+2720]
        CMP      R0,#+166
        BNE.N    ??mks_saveFileName_0
        LDR.N    R0,??DataTable226_12
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??mks_saveFileName_0
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_clearFile
        B.N      mks_clearFile
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_saveFileName_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock135

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable223:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function mks_adjust_extrude_speed
        THUMB
// __interwork __softfp void mks_adjust_extrude_speed()
mks_adjust_extrude_speed:
        LDR.N    R0,??DataTable225
        LDRSH    R1,[R0, #+672]
        CMP      R1,#+0
        BNE.N    ??mks_adjust_extrude_speed_0
        BX       LR
??mks_adjust_extrude_speed_0:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??DataTable226_19
        LDRB     R1,[R4, #+18]
        CMP      R1,#+1
        BEQ.N    ??mks_adjust_extrude_speed_1
        LDR.N    R5,??DataTable226_20
        LDRSH    R1,[R5, #+0]
        MOVW     R2,#+999
        LDRSH    R3,[R0, #+672]
        SUBS     R2,R2,R3
        CMP      R1,R2
        BGE.N    ??mks_adjust_extrude_speed_2
        LDRH     R0,[R0, #+672]
        ADDS     R0,R0,R1
        STRH     R0,[R5, #+0]
        B.N      ??mks_adjust_extrude_speed_3
??mks_adjust_extrude_speed_2:
        MOVW     R0,#+999
        STRH     R0,[R5, #+0]
??mks_adjust_extrude_speed_3:
        LDRSH    R6,[R5, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??DataTable226_21  ;; 0x47ae147b
        LDR.N    R3,??DataTable226_22  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??DataTable226_23
        STR      R0,[R1, #+0]
        STRH     R6,[R5, #+2]
        STR      R0,[R1, #+4]
        MOVS     R0,#+1
        STRB     R0,[R4, #+18]
        MOVS     R0,#+0
        STRH     R0,[R4, #+30]
??mks_adjust_extrude_speed_1:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock136

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable224:
        DC32     0x41200000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function mks_resume_extrude_speed
        THUMB
// __interwork __softfp void mks_resume_extrude_speed()
mks_resume_extrude_speed:
        LDR.N    R0,??DataTable225
        LDRSH    R1,[R0, #+672]
        CMP      R1,#+0
        BNE.N    ??mks_resume_extrude_speed_0
        BX       LR
??mks_resume_extrude_speed_0:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??DataTable226_20
        LDRH     R1,[R4, #+0]
        LDRH     R0,[R0, #+672]
        SUBS     R5,R1,R0
        STRH     R5,[R4, #+0]
        SXTH     R5,R5
        MOV      R0,R5
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??DataTable226_21  ;; 0x47ae147b
        LDR.N    R3,??DataTable226_22  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??DataTable226_23
        STR      R0,[R1, #+0]
        STRH     R5,[R4, #+2]
        STR      R0,[R1, #+4]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable226_19
        STRB     R0,[R1, #+18]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock137

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable225:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable225_1:
        DC32     mks_heating_busy

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function EXTI9_5_IRQHandler
        THUMB
// __interwork __softfp void EXTI9_5_IRQHandler()
EXTI9_5_IRQHandler:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+0
        LDR.N    R1,??DataTable226_24  ;; 0x422281b4
        STR      R0,[R1, #+0]
        LDR.N    R0,??DataTable226_25  ;; 0x40010414
        LDR      R1,[R0, #+0]
        LSLS     R1,R1,#+26
        BPL.N    ??EXTI9_5_IRQHandler_0
        MOVS     R1,#+32
        STR      R1,[R0, #+0]
        LDR.N    R0,??DataTable226_11
        LDRB     R0,[R0, #+2720]
        CMP      R0,#+166
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+171
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+169
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+170
        BNE.N    ??EXTI9_5_IRQHandler_2
??EXTI9_5_IRQHandler_1:
        MOVS     R0,#+0
        LDR.N    R1,??DataTable226_26  ;; 0x422381a8
        STR      R0,[R1, #+0]
        POP      {R0,PC}
??EXTI9_5_IRQHandler_2:
        LDR.N    R0,??DataTable226_12
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BNE.N    ??EXTI9_5_IRQHandler_0
        MOVS     R0,#+0
        LDR.N    R1,??DataTable226_27  ;; 0x42210180
        STR      R0,[R1, #+0]
          CFI FunCall _Z21mks_WriteToEpr_pwroffv
        BL       _Z21mks_WriteToEpr_pwroffv
        MOV      R0,#+1000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        LDR.N    R1,??DataTable226_26  ;; 0x422381a8
        STR      R0,[R1, #+0]
??EXTI9_5_IRQHandler_3:
        B.N      ??EXTI9_5_IRQHandler_3
??EXTI9_5_IRQHandler_0:
        cpsie i
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226:
        DC32     first_resu

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_1:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_2:
        DC32     0x38d1b718

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_3:
        DC32     card+0x9D4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_4:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_5:
        DC32     logo_tick2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_6:
        DC32     logo_tick1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_7:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_8:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_9:
        DC32     default_preview_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_10:
        DC32     continue_print_error_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_11:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_12:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_13:
        DC32     mksTmp

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_14:
        DC32     SD_Path

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_15:
        DC32     mks_pft_name

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_16:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_17:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_18:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_19:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_20:
        DC32     _ZN7Planner15flow_percentageE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_21:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_22:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_23:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_24:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_25:
        DC32     0x40010414

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_26:
        DC32     0x422381a8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable226_27:
        DC32     0x42210180

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
`?<Constant "clear">`:
        DC8 "clear"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strchrPci
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function _Z6strchrPci
          CFI FunCall __iar_Strchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strchr(char *, int)
_Z6strchrPci:
        B.W      __iar_Strchr
          CFI EndBlock cfiBlock139

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z7strrchrPci
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function _Z7strrchrPci
          CFI FunCall __iar_Strrchr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strrchr(char *, int)
_Z7strrchrPci:
        B.W      __iar_Strrchr
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z6strstrPcPKc
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function _Z6strstrPcPKc
          CFI FunCall __iar_Strstr
        THUMB
// __intrinsic __nounwind __interwork __softfp char *strstr(char *, char const *)
_Z6strstrPcPKc:
        B.W      __iar_Strstr
          CFI EndBlock cfiBlock141

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17serial_echopair_PPKcb
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function _Z17serial_echopair_PPKcb
          CFI FunCall _Z17serial_echopair_PPKci
        THUMB
// __interwork __softfp void serial_echopair_P(char const *, bool)
_Z17serial_echopair_PPKcb:
        B.W      _Z17serial_echopair_PPKci
          CFI EndBlock cfiBlock142

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        B.N      ??serialprintPGM_0
??serialprintPGM_1:
        UXTB     R1,R1
        LDR.N    R0,??serialprintPGM_2
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??serialprintPGM_0:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??serialprintPGM_1
        POP      {R4,PC}          ;; return
        DATA
??serialprintPGM_2:
        DC32     Serial3
          CFI EndBlock cfiBlock143

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsRunningv
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function _Z9IsRunningv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsRunning()
_Z9IsRunningv:
        LDR.N    R0,??IsRunning_0
        LDRB     R0,[R0, #+4]
        BX       LR               ;; return
        Nop      
        DATA
??IsRunning_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock144

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9IsStoppedv
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function _Z9IsStoppedv
          CFI NoCalls
        THUMB
// __interwork __softfp bool IsStopped()
_Z9IsStoppedv:
        LDR.N    R0,??IsStopped_0
        LDRB     R0,[R0, #+4]
        EOR      R0,R0,#0x1
        BX       LR               ;; return
        Nop      
        DATA
??IsStopped_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock145

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19refresh_cmd_timeoutv
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function _Z19refresh_cmd_timeoutv
        THUMB
// __interwork __softfp void refresh_cmd_timeout()
_Z19refresh_cmd_timeoutv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??refresh_cmd_timeout_0
        STR      R0,[R1, #+92]
        POP      {R0,PC}          ;; return
        DATA
??refresh_cmd_timeout_0:
        DC32     axis_homed
          CFI EndBlock cfiBlock146

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_current_from_destinationv
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function _Z28set_current_from_destinationv
        THUMB
// __interwork __softfp void set_current_from_destination()
_Z28set_current_from_destinationv:
        LDR.N    R0,??set_current_from_destination_0
        MOVS     R2,#+16
        ADD      R1,R0,#+24
        ADDS     R0,R0,#+8
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_current_from_destination_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock147

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28set_destination_from_currentv
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function _Z28set_destination_from_currentv
        THUMB
// __interwork __softfp void set_destination_from_current()
_Z28set_destination_from_currentv:
        LDR.N    R0,??set_destination_from_current_0
        MOVS     R2,#+16
        ADD      R1,R0,#+8
        ADDS     R0,R0,#+24
          CFI FunCall memcpy
        B.W      memcpy
        Nop      
        DATA
??set_destination_from_current_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z34position_is_reachable_IS_KINEMATICRKfS0_
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function _Z34position_is_reachable_IS_KINEMATICRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_IS_KINEMATIC(float const &, float const &)
_Z34position_is_reachable_IS_KINEMATICRKfS0_:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R5,R0
        MOV      R4,R1
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0
        LDRSH    R1,[R0, #+88]
        LSLS     R2,R1,#+30
        BPL.N    ??position_is_reachable_IS_KINEMATIC_1
        LDR      R8,[R0, #+84]
        MOV      R9,#+2
        MOV      R6,#+1065353216
        MOV      R7,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_2
??position_is_reachable_IS_KINEMATIC_3:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_2:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_4
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??position_is_reachable_IS_KINEMATIC_4:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_3
        LDR      R8,[R5, #+0]
        MOV      R9,#+2
        MOV      R5,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_5
??position_is_reachable_IS_KINEMATIC_6:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_5:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_7
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_IS_KINEMATIC_7:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_6
        LDR      R4,[R4, #+0]
        MOV      R8,#+2
        B.N      ??position_is_reachable_IS_KINEMATIC_8
??position_is_reachable_IS_KINEMATIC_9:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??position_is_reachable_IS_KINEMATIC_8:
        LSLS     R0,R8,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_10
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_10:
        LSRS     R8,R8,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_9
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??position_is_reachable_IS_KINEMATIC_11
        MOVS     R0,#+1
        B.N      ??position_is_reachable_IS_KINEMATIC_12
??position_is_reachable_IS_KINEMATIC_11:
        MOVS     R0,#+0
        B.N      ??position_is_reachable_IS_KINEMATIC_12
??position_is_reachable_IS_KINEMATIC_1:
        MOV      R0,#+768
        TST      R1,R0
        BEQ.N    ??position_is_reachable_IS_KINEMATIC_12
        LDR.W    R8,??position_is_reachable_IS_KINEMATIC_0+0x4  ;; 0x43960000
        MOV      R9,#+2
        MOV      R6,#+1065353216
        MOV      R7,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_13
??position_is_reachable_IS_KINEMATIC_14:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_13:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_15
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??position_is_reachable_IS_KINEMATIC_15:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_14
        LDR      R1,[R5, #+0]
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0x8  ;; 0xc2c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        MOV      R9,#+2
        MOV      R5,R6
        B.N      ??position_is_reachable_IS_KINEMATIC_16
??position_is_reachable_IS_KINEMATIC_17:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_16:
        LSLS     R0,R9,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_18
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_IS_KINEMATIC_18:
        LSRS     R9,R9,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_17
        LDR      R1,[R4, #+0]
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0xC  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        MOV      R8,#+2
        B.N      ??position_is_reachable_IS_KINEMATIC_19
??position_is_reachable_IS_KINEMATIC_20:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??position_is_reachable_IS_KINEMATIC_19:
        LSLS     R0,R8,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_21
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_21:
        LSRS     R8,R8,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_20
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??position_is_reachable_IS_KINEMATIC_22
        MOVS     R0,#+1
        B.N      ??position_is_reachable_IS_KINEMATIC_12
??position_is_reachable_IS_KINEMATIC_22:
        MOVS     R0,#+0
??position_is_reachable_IS_KINEMATIC_12:
        POP      {R1,R4-R9,PC}    ;; return
        Nop      
        DATA
??position_is_reachable_IS_KINEMATIC_0:
        DC32     mksCfg
        DC32     0x43960000
        DC32     0xc2c80000
        DC32     0x42600000
          CFI EndBlock cfiBlock149

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
_Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??position_is_reachable_by_probe_IS_KINEMATIC_0
        LDR.N    R6,??position_is_reachable_by_probe_IS_KINEMATIC_1
        LDR      R0,[R4, #+0]
        LDR      R1,[R6, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+0]
        LDR      R1,[R6, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        POP      {R1,R2,R4-R6,PC}
??position_is_reachable_by_probe_IS_KINEMATIC_0:
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
        Nop      
        DATA
??position_is_reachable_by_probe_IS_KINEMATIC_1:
        DC32     mksCfg
          CFI EndBlock cfiBlock150

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z34position_is_reachable_IS_CARTESIANRKfS0_
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function _Z34position_is_reachable_IS_CARTESIANRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_IS_CARTESIAN(float const &, float const &)
_Z34position_is_reachable_IS_CARTESIANRKfS0_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R11,R1
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R8,??position_is_reachable_IS_CARTESIAN_0  ;; 0xd2f1a9fc
        LDR.W    R9,??position_is_reachable_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
        LDR.W    R10,??position_is_reachable_IS_CARTESIAN_0+0x8
        LDR      R0,[R10, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        MOV      R6,R8
        LDR.N    R7,??position_is_reachable_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
        LDR      R0,[R10, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R11, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R10, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R10, #+24]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        MOVS     R0,#+1
        B.N      ??position_is_reachable_IS_CARTESIAN_2
??position_is_reachable_IS_CARTESIAN_1:
        MOVS     R0,#+0
??position_is_reachable_IS_CARTESIAN_2:
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??position_is_reachable_IS_CARTESIAN_0:
        DC32     0xd2f1a9fc
        DC32     0xbf50624d
        DC32     mksCfg
        DC32     0x3f50624d
          CFI EndBlock cfiBlock151

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
_Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R11,R1
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR.W    R8,??position_is_reachable_by_probe_IS_CARTESIAN_0  ;; 0xd2f1a9fc
        LDR.W    R9,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x4  ;; 0xbf50624d
        LDR.W    R10,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x8
        LDR      R0,[R10, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        MOV      R6,R8
        LDR.N    R7,??position_is_reachable_by_probe_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
        LDR      R0,[R10, #+4]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R11, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R10, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R10, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R6
        MOV      R3,R7
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        MOVS     R0,#+1
        B.N      ??position_is_reachable_by_probe_IS_CARTESIAN_2
??position_is_reachable_by_probe_IS_CARTESIAN_1:
        MOVS     R0,#+0
??position_is_reachable_by_probe_IS_CARTESIAN_2:
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??position_is_reachable_by_probe_IS_CARTESIAN_0:
        DC32     0xd2f1a9fc
        DC32     0xbf50624d
        DC32     mksTmp
        DC32     0x3f50624d
          CFI EndBlock cfiBlock152

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10lcd_updatev
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function _Z10lcd_updatev
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_update()
_Z10lcd_updatev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock153

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z8lcd_initv
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function _Z8lcd_initv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_init()
_Z8lcd_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock154

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_hasstatusv
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function _Z13lcd_hasstatusv
          CFI NoCalls
        THUMB
// __interwork __softfp bool lcd_hasstatus()
_Z13lcd_hasstatusv:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock155

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13lcd_setstatusPKcb
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function _Z13lcd_setstatusPKcb
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatus(char const *, bool)
_Z13lcd_setstatusPKcb:
        BX       LR               ;; return
          CFI EndBlock cfiBlock156

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z16lcd_setstatusPGMPKca
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function _Z16lcd_setstatusPGMPKca
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setstatusPGM(char const *, int8_t)
_Z16lcd_setstatusPGMPKca:
        BX       LR               ;; return
          CFI EndBlock cfiBlock157

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_setalertstatusPGMPKc
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function _Z21lcd_setalertstatusPGMPKc
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_setalertstatusPGM(char const *)
_Z21lcd_setalertstatusPGMPKc:
        BX       LR               ;; return
          CFI EndBlock cfiBlock158

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21lcd_reset_alert_levelv
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function _Z21lcd_reset_alert_levelv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_reset_alert_level()
_Z21lcd_reset_alert_levelv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11lcd_refreshv
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function _Z11lcd_refreshv
          CFI NoCalls
        THUMB
// __interwork __softfp void lcd_refresh()
_Z11lcd_refreshv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock160

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner16refresh_e_factorEh
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function _ZN7Planner16refresh_e_factorEh
        THUMB
// __interwork __softfp void Planner::refresh_e_factor(uint8_t)
_ZN7Planner16refresh_e_factorEh:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R6,R0
        LDR.N    R0,??refresh_e_factor_0
        LDRSH    R0,[R0, R6, LSL #+1]
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??refresh_e_factor_0+0x4  ;; 0x47ae147b
        LDR.N    R3,??refresh_e_factor_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
        LDR.N    R0,??refresh_e_factor_0+0xC
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??refresh_e_factor_0+0x10
        STR      R0,[R1, R6, LSL #+2]
        POP      {R4-R6,PC}       ;; return
        DATA
??refresh_e_factor_0:
        DC32     _ZN7Planner15flow_percentageE
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     _ZN7Planner21volumetric_multiplierE
        DC32     _ZN7Planner8e_factorE
          CFI EndBlock cfiBlock161

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17set_filament_sizeEhRKf
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function _ZN7Planner17set_filament_sizeEhRKf
        THUMB
// __interwork __softfp void Planner::set_filament_size(uint8_t, float const &)
_ZN7Planner17set_filament_sizeEhRKf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R2,??set_filament_size_0
        LDR      R1,[R1, #+0]
        STR      R1,[R2, R0, LSL #+2]
        MOVS     R3,#+0
        MOV      R1,R3
        B.N      ??set_filament_size_1
??set_filament_size_2:
        LDR      R0,[R2, R3, LSL #+2]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??set_filament_size_3
        LDR.N    R0,??set_filament_size_0+0x4  ;; 0x40400000
        STR      R0,[R2, R3, LSL #+2]
??set_filament_size_3:
        ADDS     R3,R3,#+1
??set_filament_size_1:
        CMP      R3,#+2
        BCC.N    ??set_filament_size_2
        POP      {R0,PC}          ;; return
        DATA
??set_filament_size_0:
        DC32     _ZN7Planner13filament_sizeE
        DC32     0x40400000
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17force_fade_recalcEv
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function _ZN7Planner17force_fade_recalcEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Planner::force_fade_recalc()
_ZN7Planner17force_fade_recalcEv:
        LDR.N    R0,??force_fade_recalc_0  ;; 0xc479fff0
        LDR.N    R1,??force_fade_recalc_0+0x4
        STR      R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??force_fade_recalc_0:
        DC32     0xc479fff0
        DC32     _ZN7Planner11last_fade_zE
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner17set_z_fade_heightERKf
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function _ZN7Planner17set_z_fade_heightERKf
        THUMB
// __interwork __softfp void Planner::set_z_fade_height(float const &)
_ZN7Planner17set_z_fade_heightERKf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR      R0,[R0, #+0]
        LDR.N    R2,??set_z_fade_height_6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??set_z_fade_height_7
        STR      R0,[R2, #+0]
        B.N      ??set_z_fade_height_8
??set_z_fade_height_7:
        MOV      R0,R1
        STR      R0,[R2, #+0]
??set_z_fade_height_8:
        LDR      R2,[R2, #+0]
        MOV      R0,R2
        LDR.N    R1,??set_z_fade_height_6+0x4  ;; 0xb58637bd
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??set_z_fade_height_9
        LDR.N    R1,??set_z_fade_height_6+0x8  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??set_z_fade_height_9
        MOVS     R0,#+0
        LDR.N    R1,??set_z_fade_height_6+0xC
        STR      R0,[R1, #+0]
        B.N      ??set_z_fade_height_10
??set_z_fade_height_9:
        MOV      R0,#+1065353216
        MOV      R1,R2
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.N    R1,??set_z_fade_height_6+0xC
        STR      R0,[R1, #+0]
??set_z_fade_height_10:
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner17force_fade_recalcEv
        B.W      _ZN7Planner17force_fade_recalcEv
        DATA
??set_z_fade_height_6:
        DC32     _ZN7Planner13z_fade_heightE
        DC32     0xb58637bd
        DC32     0x358637be
        DC32     _ZN7Planner21inverse_z_fade_heightE
          CFI EndBlock cfiBlock164

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner20leveling_active_at_zERKf
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function _ZN7Planner20leveling_active_at_zERKf
        THUMB
// __interwork __softfp bool Planner::leveling_active_at_z(float const &)
_ZN7Planner20leveling_active_at_zERKf:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOV      R2,R0
        LDR.N    R0,??leveling_active_at_z_0
        LDR      R3,[R0, #+0]
        MOV      R0,R3
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??leveling_active_at_z_1
        LDR      R0,[R2, #+0]
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??leveling_active_at_z_2
??leveling_active_at_z_1:
        MOVS     R0,#+1
        POP      {R1,PC}
??leveling_active_at_z_2:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        DATA
??leveling_active_at_z_0:
        DC32     _ZN7Planner13z_fade_heightE
          CFI EndBlock cfiBlock165

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner14apply_levelingERA3_f
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function _ZN7Planner14apply_levelingERA3_f
        THUMB
// __interwork __softfp void Planner::apply_leveling(float (&)[3])
_ZN7Planner14apply_levelingERA3_f:
        ADD      R2,R0,#+8
        ADDS     R1,R0,#+4
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        B.W      _ZN7Planner14apply_levelingERfS0_S0_
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner11buffer_lineEfffRKfS1_h
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function _ZN7Planner11buffer_lineEfffRKfS1_h
        THUMB
// __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
_ZN7Planner11buffer_lineEfffRKfS1_h:
        PUSH     {R0-R2,R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R4,R3
        LDR      R5,[SP, #+32]
        LDR.N    R0,??buffer_line_0
        LDRB     R1,[R0, #+64]
        MOVS     R2,#+46
        TST      R1,R2
        BEQ.N    ??buffer_line_1
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BNE.N    ??buffer_line_1
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??buffer_line_1:
        LDR      R0,[SP, #+36]
        STR      R0,[SP, #+4]
        STR      R5,[SP, #+0]
        MOV      R3,R4
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??buffer_line_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock167

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        THUMB
// __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
_ZN7Planner21buffer_line_kinematicERA4_KfRS0_h:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R4,R0
        MOV      R5,R1
        MOV      R6,R2
        LDR      R0,[R4, #+0]
        STR      R0,[SP, #+8]
        ADD      R0,SP,#+8
        LDR      R1,[R4, #+4]
        STR      R1,[R0, #+4]
        LDR      R1,[R4, #+8]
        STR      R1,[R0, #+8]
        LDR.N    R7,??buffer_line_kinematic_0
        LDRB     R0,[R7, #+64]
        MOVS     R1,#+46
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_1
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingERA3_f
        BL       _ZN7Planner14apply_levelingERA3_f
??buffer_line_kinematic_1:
        ADD      R0,R7,#+64
        LDRSH    R0,[R0, #+24]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_2
        CMP      R0,#+256
        ADD      R0,SP,#+8
        BNE.N    ??buffer_line_kinematic_3
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??buffer_line_kinematic_4
??buffer_line_kinematic_3:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??buffer_line_kinematic_4:
        LDR.N    R1,??buffer_line_kinematic_0+0x4
        LDRB     R0,[R1, #+328]
        CMP      R0,#+1
        BNE.N    ??buffer_line_kinematic_5
        LDR      R0,[R4, #+8]
        LDR      R1,[R1, #+664]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??buffer_line_kinematic_5
        LDR      R1,[R4, #+12]
        LDR.N    R0,??buffer_line_kinematic_0+0x8
        ADD      R0,R0,R6, LSL #+2
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall lroundf
        BL       lroundf
        LDR.N    R1,??buffer_line_kinematic_0+0xC
        STR      R0,[R1, #+12]
        B.N      ??buffer_line_kinematic_6
??buffer_line_kinematic_5:
        LDR.N    R0,??buffer_line_kinematic_0+0x10
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,R0,#+88
        ADD      R1,R0,#+84
        ADDS     R0,R0,#+80
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        B.N      ??buffer_line_kinematic_6
??buffer_line_kinematic_2:
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
??buffer_line_kinematic_6:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        Nop      
        DATA
??buffer_line_kinematic_0:
        DC32     mksCfg
        DC32     gCfgItems
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     _ZN7Planner8positionE
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner15set_position_mmEfffRKf
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function _ZN7Planner15set_position_mmEfffRKf
        THUMB
// __interwork __softfp void Planner::set_position_mm(float, float, float, float const &)
_ZN7Planner15set_position_mmEfffRKf:
        PUSH     {R0-R2,R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+20
        SUB      SP,SP,#+4
          CFI CFA R13+24
        MOV      R4,R3
        LDR.N    R0,??set_position_mm_0
        LDRB     R1,[R0, #+64]
        MOVS     R2,#+46
        TST      R1,R2
        BEQ.N    ??set_position_mm_1
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BNE.N    ??set_position_mm_1
        ADD      R2,SP,#+12
        ADD      R1,SP,#+8
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??set_position_mm_1:
        MOV      R3,R4
        ADD      R2,SP,#+12
        ADD      R1,SP,#+8
        ADD      R0,SP,#+4
          CFI FunCall _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        POP      {R0-R4,PC}       ;; return
        Nop      
        DATA
??set_position_mm_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Planner17set_e_position_mmERKf
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function _ZN7Planner17set_e_position_mmERKf
        THUMB
// __interwork __softfp void Planner::set_e_position_mm(float const &)
_ZN7Planner17set_e_position_mmERKf:
        MOV      R1,R0
        MOVS     R0,#+3
          CFI FunCall _ZN7Planner15set_position_mmE8AxisEnumRKf
        B.W      _ZN7Planner15set_position_mmE8AxisEnumRKf
          CFI EndBlock cfiBlock170

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner13blocks_queuedEv
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function _ZN7Planner13blocks_queuedEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool Planner::blocks_queued()
_ZN7Planner13blocks_queuedEv:
        LDR.N    R0,??blocks_queued_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??blocks_queued_0+0x4
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BEQ.N    ??blocks_queued_1
        MOVS     R0,#+1
        BX       LR
??blocks_queued_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??blocks_queued_0:
        DC32     _ZN7Planner17block_buffer_headE
        DC32     _ZN7Planner17block_buffer_tailE
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN7Stepper25get_axis_position_degreesE8AxisEnum
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function _ZN7Stepper25get_axis_position_degreesE8AxisEnum
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        THUMB
// __interwork __softfp float Stepper::get_axis_position_degrees(AxisEnum)
_ZN7Stepper25get_axis_position_degreesE8AxisEnum:
        B.W      _ZN7Stepper20get_axis_position_mmE8AxisEnum
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Stepper17set_homing_flag_zEb
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function _ZN7Stepper17set_homing_flag_zEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Stepper::set_homing_flag_z(bool)
_ZN7Stepper17set_homing_flag_zEb:
        LDR.N    R1,??set_homing_flag_z_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??set_homing_flag_z_0:
        DC32     _ZN7Stepper17performing_homingE
          CFI EndBlock cfiBlock173

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Stepper10set_z_lockEb
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function _ZN7Stepper10set_z_lockEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Stepper::set_z_lock(bool)
_ZN7Stepper10set_z_lockEb:
        LDR.N    R1,??set_z_lock_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??set_z_lock_0:
        DC32     _ZN7Stepper14locked_z_motorE
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Stepper11set_z2_lockEb
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function _ZN7Stepper11set_z2_lockEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Stepper::set_z2_lock(bool)
_ZN7Stepper11set_z2_lockEb:
        LDR.N    R1,??set_z2_lock_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??set_z2_lock_0:
        DC32     _ZN7Stepper15locked_z2_motorE
          CFI EndBlock cfiBlock175

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops15enable_globallyEb
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function _ZN8Endstops15enable_globallyEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_globally(bool)
_ZN8Endstops15enable_globallyEb:
        LDR.N    R1,??enable_globally_0
        STRB     R0,[R1, #+0]
        LDR.N    R1,??enable_globally_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_globally_0:
        DC32     _ZN8Endstops7enabledE
        DC32     _ZN8Endstops16enabled_globallyE
          CFI EndBlock cfiBlock176

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops6enableEb
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function _ZN8Endstops6enableEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable(bool)
_ZN8Endstops6enableEb:
        LDR.N    R1,??enable_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_0:
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock177

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops10not_homingEv
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function _ZN8Endstops10not_homingEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::not_homing()
_ZN8Endstops10not_homingEv:
        LDR.N    R0,??not_homing_0
        LDRB     R0,[R0, #+0]
        LDR.N    R1,??not_homing_0+0x4
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??not_homing_0:
        DC32     _ZN8Endstops16enabled_globallyE
        DC32     _ZN8Endstops7enabledE
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14hit_on_purposeEv
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function _ZN8Endstops14hit_on_purposeEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::hit_on_purpose()
_ZN8Endstops14hit_on_purposeEv:
        MOVS     R0,#+0
        LDR.N    R1,??hit_on_purpose_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        DATA
??hit_on_purpose_0:
        DC32     _ZN8Endstops16endstop_hit_bitsE
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN8Endstops14enable_z_probeEb
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function _ZN8Endstops14enable_z_probeEb
          CFI NoCalls
        THUMB
// __interwork __softfp void Endstops::enable_z_probe(bool)
_ZN8Endstops14enable_z_probeEb:
        LDR.N    R1,??enable_z_probe_0
        STRB     R0,[R1, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??enable_z_probe_0:
        DC32     _ZN8Endstops15z_probe_enabledE
          CFI EndBlock cfiBlock180

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature16tooColdToExtrudeEh
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function _ZN11Temperature16tooColdToExtrudeEh
        THUMB
// __interwork __softfp bool Temperature::tooColdToExtrude(uint8_t)
_ZN11Temperature16tooColdToExtrudeEh:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??tooColdToExtrude_0
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??tooColdToExtrude_1
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}
??tooColdToExtrude_1:
        LDR.N    R0,??tooColdToExtrude_0+0x4
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R5,R1
        MOV      R0,R4
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??tooColdToExtrude_2
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}
??tooColdToExtrude_2:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
        DATA
??tooColdToExtrude_0:
        DC32     _ZN11Temperature18allow_cold_extrudeE
        DC32     _ZN11Temperature16extrude_min_tempE
          CFI EndBlock cfiBlock181

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature9degHotendEh
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function _ZN11Temperature9degHotendEh
          CFI NoCalls
        THUMB
// __interwork __softfp float Temperature::degHotend(uint8_t)
_ZN11Temperature9degHotendEh:
        LDR.N    R1,??degHotend_0
        LDR      R0,[R1, R0, LSL #+2]
        BX       LR               ;; return
        DATA
??degHotend_0:
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock182

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature6degBedEv
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function _ZN11Temperature6degBedEv
          CFI NoCalls
        THUMB
// __interwork __softfp float Temperature::degBed()
_ZN11Temperature6degBedEv:
        LDR.N    R0,??degBed_0
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
        Nop      
        DATA
??degBed_0:
        DC32     _ZN11Temperature23current_temperature_bedE
          CFI EndBlock cfiBlock183

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15degTargetHotendEh
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function _ZN11Temperature15degTargetHotendEh
        THUMB
// __interwork __softfp float Temperature::degTargetHotend(uint8_t)
_ZN11Temperature15degTargetHotendEh:
        LDR.N    R1,??degTargetHotend_0
        LDR      R0,[R1, R0, LSL #+2]
          CFI FunCall __aeabi_i2f
        B.W      __aeabi_i2f
        Nop      
        DATA
??degTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock184

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12degTargetBedEv
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function _ZN11Temperature12degTargetBedEv
        THUMB
// __interwork __softfp float Temperature::degTargetBed()
_ZN11Temperature12degTargetBedEv:
        LDR.N    R0,??degTargetBed_0
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        B.W      __aeabi_i2f
        Nop      
        DATA
??degTargetBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock185

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15setTargetHotendEfh
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function _ZN11Temperature15setTargetHotendEfh
        THUMB
// __interwork __softfp void Temperature::setTargetHotend(float, uint8_t)
_ZN11Temperature15setTargetHotendEfh:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.N    R1,??setTargetHotend_0
        STR      R0,[R1, R4, LSL #+2]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        B.W      _ZN11Temperature21start_watching_heaterEh
        DATA
??setTargetHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12setTargetBedEf
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function _ZN11Temperature12setTargetBedEf
        THUMB
// __interwork __softfp void Temperature::setTargetBed(float)
_ZN11Temperature12setTargetBedEf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??setTargetBed_0
        LDRSH    R5,[R0, #+50]
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??setTargetBed_1
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
??setTargetBed_1:
        LDR.N    R0,??setTargetBed_0+0x4
        STRH     R5,[R0, #+0]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature18start_watching_bedEv
        B.W      _ZN11Temperature18start_watching_bedEv
        DATA
??setTargetBed_0:
        DC32     mksCfg
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock187

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature15isCoolingHotendEh
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function _ZN11Temperature15isCoolingHotendEh
        THUMB
// __interwork __softfp bool Temperature::isCoolingHotend(uint8_t)
_ZN11Temperature15isCoolingHotendEh:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
        LDR.N    R0,??isCoolingHotend_0
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R1,??isCoolingHotend_0+0x4
        LDR      R1,[R1, R4, LSL #+2]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??isCoolingHotend_1
        MOVS     R0,#+1
        POP      {R4,PC}
??isCoolingHotend_1:
        MOVS     R0,#+0
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??isCoolingHotend_0:
        DC32     _ZN11Temperature18target_temperatureE
        DC32     _ZN11Temperature19current_temperatureE
          CFI EndBlock cfiBlock188

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12isCoolingBedEv
          CFI Block cfiBlock189 Using cfiCommon0
          CFI Function _ZN11Temperature12isCoolingBedEv
        THUMB
// __interwork __softfp bool Temperature::isCoolingBed()
_ZN11Temperature12isCoolingBedEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??isCoolingBed_0
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R1,??isCoolingBed_0+0x4
        LDR      R1,[R1, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??isCoolingBed_1
        MOVS     R0,#+1
        POP      {R1,PC}
??isCoolingBed_1:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
        Nop      
        DATA
??isCoolingBed_0:
        DC32     _ZN11Temperature22target_temperature_bedE
        DC32     _ZN11Temperature23current_temperature_bedE
          CFI EndBlock cfiBlock189

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11Temperature9updatePIDEv
          CFI Block cfiBlock190 Using cfiCommon0
          CFI Function _ZN11Temperature9updatePIDEv
          CFI NoCalls
        THUMB
// __interwork __softfp void Temperature::updatePID()
_ZN11Temperature9updatePIDEv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock190

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature24set_auto_report_intervalEh
          CFI Block cfiBlock191 Using cfiCommon0
          CFI Function _ZN11Temperature24set_auto_report_intervalEh
        THUMB
// __interwork __softfp void Temperature::set_auto_report_interval(uint8_t)
_ZN11Temperature24set_auto_report_intervalEh:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        CMP      R4,#+61
        BLT.N    ??set_auto_report_interval_0
        MOVS     R4,#+60
??set_auto_report_interval_0:
        LDR.N    R0,??set_auto_report_interval_1
        STRB     R4,[R0, #+0]
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R1,#+1000
        MLA      R0,R1,R4,R0
        LDR.N    R1,??set_auto_report_interval_1+0x4
        STR      R0,[R1, #+0]
        POP      {R4,PC}          ;; return
        DATA
??set_auto_report_interval_1:
        DC32     _ZN11Temperature25auto_report_temp_intervalE
        DC32     _ZN11Temperature19next_temp_report_msE
          CFI EndBlock cfiBlock191

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader10isFileOpenEv
          CFI Block cfiBlock192 Using cfiCommon0
          CFI Function _ZN10CardReader10isFileOpenEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::isFileOpen()
_ZN10CardReader10isFileOpenEv:
        LDR      R0,[R0, #+512]
        CMP      R0,#+0
        BEQ.N    ??isFileOpen_0
        MOVS     R0,#+1
        BX       LR
??isFileOpen_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock192

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3eofEv
          CFI Block cfiBlock193 Using cfiCommon0
          CFI Function _ZN10CardReader3eofEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool CardReader::eof()
_ZN10CardReader3eofEv:
        LDR      R1,[R0, #+1120]
        LDR      R0,[R0, #+1116]
        CMP      R1,R0
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR               ;; return
          CFI EndBlock cfiBlock193

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader3getEv
          CFI Block cfiBlock194 Using cfiCommon0
          CFI Function _ZN10CardReader3getEv
        THUMB
// __interwork __softfp int16_t CardReader::get()
_ZN10CardReader3getEv:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        MOV      R4,R0
        ADD      R3,SP,#+4
        MOVS     R2,#+1
        ADD      R1,SP,#+0
          CFI FunCall f_read
        BL       f_read
        CMP      R0,#+0
        BEQ.N    ??get_0
        MOV      R0,#-1
        STRB     R0,[SP, #+0]
        B.N      ??get_1
??get_0:
        LDR      R0,[R4, #+1120]
        LDR      R1,[SP, #+4]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+1120]
??get_1:
        LDRSB    R0,[SP, #+0]
        POP      {R1,R2,R4,PC}    ;; return
          CFI EndBlock cfiBlock194

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10CardReader8setIndexEl
          CFI Block cfiBlock195 Using cfiCommon0
          CFI Function _ZN10CardReader8setIndexEl
        THUMB
// __interwork __softfp void CardReader::setIndex(long)
_ZN10CardReader8setIndexEl:
        STR      R1,[R0, #+1120]
          CFI FunCall f_lseek
        B.W      f_lseek
          CFI EndBlock cfiBlock195

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN10duration_tC1ERKj
          CFI Block cfiBlock196 Using cfiCommon0
          CFI Function _ZN10duration_tC1ERKj
          CFI NoCalls
        THUMB
// __code __interwork __softfp duration_t::duration_t(uint32_t const &)
_ZN10duration_tC1ERKj:
        LDR      R1,[R1, #+0]
        STR      R1,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock196

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4yearEv
          CFI Block cfiBlock197 Using cfiCommon0
          CFI Function _ZNK10duration_t4yearEv
        THUMB
// __interwork __softfp uint8_t duration_t::year() const
_ZNK10duration_t4yearEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R0,R0,R1
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock197

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t3dayEv
          CFI Block cfiBlock198 Using cfiCommon0
          CFI Function _ZNK10duration_t3dayEv
        THUMB
// __interwork __softfp uint16_t duration_t::day() const
_ZNK10duration_t3dayEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R0,R0,R1
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock198

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t4hourEv
          CFI Block cfiBlock199 Using cfiCommon0
          CFI Function _ZNK10duration_t4hourEv
        THUMB
// __interwork __softfp uint32_t duration_t::hour() const
_ZNK10duration_t4hourEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock199

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6minuteEv
          CFI Block cfiBlock200 Using cfiCommon0
          CFI Function _ZNK10duration_t6minuteEv
        THUMB
// __interwork __softfp uint32_t duration_t::minute() const
_ZNK10duration_t6minuteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOVS     R1,#+60
        UDIV     R0,R0,R1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock200

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZNK10duration_t6secondEv
          CFI Block cfiBlock201 Using cfiCommon0
          CFI Function _ZNK10duration_t6secondEv
          CFI NoCalls
        THUMB
// __interwork __softfp uint32_t duration_t::second() const
_ZNK10duration_t6secondEv:
        LDR      R0,[R0, #+0]
        BX       LR               ;; return
          CFI EndBlock cfiBlock201

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZNK10duration_t8toStringEPc
          CFI Block cfiBlock202 Using cfiCommon0
          CFI Function _ZNK10duration_t8toStringEPc
        THUMB
// __interwork __softfp void duration_t::toString(char *) const
_ZNK10duration_t8toStringEPc:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R7,R0
        MOV      R4,R1
          CFI FunCall _ZNK10duration_t4yearEv
        BL       _ZNK10duration_t4yearEv
        MOV      R5,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t3dayEv
        BL       _ZNK10duration_t3dayEv
        MOVW     R1,#+365
        SDIV     R1,R0,R1
        MOVW     R2,#+365
        MLS      R6,R2,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t4hourEv
        BL       _ZNK10duration_t4hourEv
        MOVS     R1,#+24
        UDIV     R1,R0,R1
        ADD      R2,R1,R1, LSL #+1
        SUB      R8,R0,R2, LSL #+3
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6minuteEv
        BL       _ZNK10duration_t6minuteEv
        MOV      R9,#+60
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R10,R9,R1,R0
        MOV      R0,R7
          CFI FunCall _ZNK10duration_t6secondEv
        BL       _ZNK10duration_t6secondEv
        MOV      R1,R9
        UDIV     R1,R0,R1
        MLS      R2,R9,R1,R0
        CMP      R5,#+0
        BEQ.N    ??toString_0
        STR      R2,[SP, #+8]
        STR      R10,[SP, #+4]
        STR      R8,[SP, #+0]
        MOV      R3,R6
        MOV      R2,R5
        LDR.N    R1,??toString_1
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_0:
        CMP      R6,#+0
        BEQ.N    ??toString_3
        STR      R2,[SP, #+4]
        STR      R10,[SP, #+0]
        MOV      R3,R8
        MOV      R2,R6
        LDR.N    R1,??toString_1+0x4
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_3:
        CMP      R8,#+0
        BEQ.N    ??toString_4
        STR      R2,[SP, #+0]
        MOV      R3,R10
        MOV      R2,R8
        LDR.N    R1,??toString_1+0x8
        MOV      R0,R4
          CFI FunCall sprintf
        BL       sprintf
        B.N      ??toString_2
??toString_4:
        CMP      R10,#+0
        BEQ.N    ??toString_5
        MOV      R3,R2
        MOV      R2,R10
        LDR.N    R1,??toString_1+0xC
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_5:
        LDR.N    R1,??toString_1+0x10
        MOV      R0,R4
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??toString_2:
        POP      {R0-R10,PC}      ;; return
        Nop      
        DATA
??toString_1:
        DC32     _ZZNK10duration_t8toStringEPcEs
        DC32     _ZZNK10duration_t8toStringEPcEs_0
        DC32     _ZZNK10duration_t8toStringEPcEs_1
        DC32     _ZZNK10duration_t8toStringEPcEs_2
        DC32     _ZZNK10duration_t8toStringEPcEs_3
          CFI EndBlock cfiBlock202

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser4seenEc
          CFI Block cfiBlock203 Using cfiCommon0
          CFI Function _ZN11GCodeParser4seenEc
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::seen(char)
_ZN11GCodeParser4seenEc:
        SUB      R1,R0,#+65
        UXTB     R1,R1
        CMP      R1,#+26
        BCC.N    ??seen_0
        MOVS     R0,#+0
        BX       LR
??seen_0:
        ASRS     R0,R1,#+3
        LDR.N    R2,??seen_1
        LDRB     R0,[R0, R2]
        AND      R2,R1,#0x7
        LSRS     R0,R0,R2
        ANDS     R0,R0,#0x1
        BEQ.N    ??seen_2
        LDR.N    R2,??seen_1+0x4
        LDRB     R1,[R1, R2]
        LDR.N    R2,??seen_1+0x8
        CMP      R1,#+0
        BEQ.N    ??seen_3
        LDR.N    R3,??seen_1+0xC
        LDR      R3,[R3, #+0]
        ADDS     R1,R1,R3
        STR      R1,[R2, #+0]
        BX       LR
??seen_3:
        MOVS     R1,#+0
        STR      R1,[R2, #+0]
??seen_2:
        BX       LR               ;; return
        Nop      
        DATA
??seen_1:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
          CFI EndBlock cfiBlock203

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser9has_valueEv
          CFI Block cfiBlock204 Using cfiCommon0
          CFI Function _ZN11GCodeParser9has_valueEv
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::has_value()
_ZN11GCodeParser9has_valueEv:
        LDR.N    R0,??has_value_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??has_value_1
        MOVS     R0,#+1
        BX       LR
??has_value_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??has_value_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock204

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7seenvalEc
          CFI Block cfiBlock205 Using cfiCommon0
          CFI Function _ZN11GCodeParser7seenvalEc
        THUMB
// __interwork __softfp bool GCodeParser::seenval(char)
_ZN11GCodeParser7seenvalEc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??seenval_0
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser9has_valueEv
        B.W      _ZN11GCodeParser9has_valueEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??seenval_0:
        MOVS     R0,#+0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock205

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_floatEv
          CFI Block cfiBlock206 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_float()
_ZN11GCodeParser11value_floatEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R2,??value_float_0
        LDR      R0,[R2, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_float_1
        MOV      R4,R0
        B.N      ??value_float_2
??value_float_3:
        ADDS     R4,R4,#+1
??value_float_2:
        LDRSB    R5,[R4, #+0]
        CMP      R5,#+0
        BEQ.N    ??value_float_4
        CMP      R5,#+32
        BNE.N    ??value_float_5
??value_float_4:
        MOVS     R1,#+0
          CFI FunCall strtod
        BL       strtod
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_d2f
        B.W      __aeabi_d2f
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??value_float_5:
        CMP      R5,#+69
        BEQ.N    ??value_float_6
        CMP      R5,#+101
        BNE.N    ??value_float_3
??value_float_6:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        MOV      R1,R0
        LDR      R0,[R2, #+0]
          CFI FunCall strtod
        BL       strtod
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STRB     R5,[R4, #+0]
        POP      {R1,R4,R5,PC}
??value_float_1:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
        Nop      
        DATA
??value_float_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock206

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser10value_longEv
          CFI Block cfiBlock207 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_longEv
        THUMB
// __interwork __softfp int32_t GCodeParser::value_long()
_ZN11GCodeParser10value_longEv:
        LDR.N    R0,??value_long_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_long_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtol
        B.W      strtol
??value_long_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_long_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock207

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_ulongEv
          CFI Block cfiBlock208 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp uint32_t GCodeParser::value_ulong()
_ZN11GCodeParser11value_ulongEv:
        LDR.N    R0,??value_ulong_0
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??value_ulong_1
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall strtoul
        B.W      strtoul
??value_ulong_1:
        MOVS     R0,#+0
        BX       LR               ;; return
        DATA
??value_ulong_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock208

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_millisEv
          CFI Block cfiBlock209 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_millisEv
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis()
_ZN11GCodeParser12value_millisEv:
        B.W      _ZN11GCodeParser11value_ulongEv
          CFI EndBlock cfiBlock209

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser25value_millis_from_secondsEv
          CFI Block cfiBlock210 Using cfiCommon0
          CFI Function _ZN11GCodeParser25value_millis_from_secondsEv
        THUMB
// __interwork __softfp millis_t GCodeParser::value_millis_from_seconds()
_ZN11GCodeParser25value_millis_from_secondsEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??value_millis_from_seconds_0  ;; 0x447a0000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_f2uiz
        B.W      __aeabi_f2uiz
        DATA
??value_millis_from_seconds_0:
        DC32     0x447a0000
          CFI EndBlock cfiBlock210

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9value_intEv
          CFI Block cfiBlock211 Using cfiCommon0
          CFI Function _ZN11GCodeParser9value_intEv
        THUMB
// __interwork __softfp int16_t GCodeParser::value_int()
_ZN11GCodeParser9value_intEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        SXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock211

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser12value_ushortEv
          CFI Block cfiBlock212 Using cfiCommon0
          CFI Function _ZN11GCodeParser12value_ushortEv
        THUMB
// __interwork __softfp uint16_t GCodeParser::value_ushort()
_ZN11GCodeParser12value_ushortEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        UXTH     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock212

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_byteEv
          CFI Block cfiBlock213 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_byteEv
        THUMB
// __interwork __softfp uint8_t GCodeParser::value_byte()
_ZN11GCodeParser10value_byteEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+0
        BPL.N    ??value_byte_0
        MOVS     R0,#+0
        B.N      ??value_byte_1
??value_byte_0:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        CMP      R0,#+255
        BLE.N    ??value_byte_2
        MOVS     R0,#+255
        B.N      ??value_byte_1
??value_byte_2:
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
??value_byte_1:
        UXTB     R0,R0
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock213

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10value_boolEv
          CFI Block cfiBlock214 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_boolEv
        THUMB
// __interwork __softfp bool GCodeParser::value_bool()
_ZN11GCodeParser10value_boolEv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser9has_valueEv
        BL       _ZN11GCodeParser9has_valueEv
        CMP      R0,#+0
        BEQ.N    ??value_bool_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        POP      {R1,PC}
??value_bool_0:
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
          CFI EndBlock cfiBlock214

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser18value_linear_unitsEv
          CFI Block cfiBlock215 Using cfiCommon0
          CFI Function _ZN11GCodeParser18value_linear_unitsEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_linear_units()
_ZN11GCodeParser18value_linear_unitsEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock215

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI Block cfiBlock216 Using cfiCommon0
          CFI Function _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_axis_units(AxisEnum)
_ZN11GCodeParser16value_axis_unitsE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock216

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI Block cfiBlock217 Using cfiCommon0
          CFI Function _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_per_axis_unit(AxisEnum)
_ZN11GCodeParser19value_per_axis_unitE8AxisEnum:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock217

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser13value_celsiusEv
          CFI Block cfiBlock218 Using cfiCommon0
          CFI Function _ZN11GCodeParser13value_celsiusEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_celsius()
_ZN11GCodeParser13value_celsiusEv:
        B.W      _ZN11GCodeParser11value_floatEv
          CFI EndBlock cfiBlock218

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser14value_feedrateEv
          CFI Block cfiBlock219 Using cfiCommon0
          CFI Function _ZN11GCodeParser14value_feedrateEv
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        THUMB
// __interwork __softfp float GCodeParser::value_feedrate()
_ZN11GCodeParser14value_feedrateEv:
        B.W      _ZN11GCodeParser18value_linear_unitsEv
          CFI EndBlock cfiBlock219

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7boolvalEc
          CFI Block cfiBlock220 Using cfiCommon0
          CFI Function _ZN11GCodeParser7boolvalEc
        THUMB
// __interwork __softfp bool GCodeParser::boolval(char)
_ZN11GCodeParser7boolvalEc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??boolval_0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        B.W      _ZN11GCodeParser10value_boolEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??boolval_0:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11GCodeParser4seenEc
        B.W      _ZN11GCodeParser4seenEc
          CFI EndBlock cfiBlock220

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser7bytevalEch
          CFI Block cfiBlock221 Using cfiCommon0
          CFI Function _ZN11GCodeParser7bytevalEch
        THUMB
// __interwork __softfp uint8_t GCodeParser::byteval(char, uint8_t)
_ZN11GCodeParser7bytevalEch:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??byteval_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
??byteval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock221

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser6intvalEcs
          CFI Block cfiBlock222 Using cfiCommon0
          CFI Function _ZN11GCodeParser6intvalEcs
        THUMB
// __interwork __softfp int16_t GCodeParser::intval(char, int16_t)
_ZN11GCodeParser6intvalEcs:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??intval_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
??intval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock222

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9ushortvalEct
          CFI Block cfiBlock223 Using cfiCommon0
          CFI Function _ZN11GCodeParser9ushortvalEct
        THUMB
// __interwork __softfp uint16_t GCodeParser::ushortval(char, uint16_t)
_ZN11GCodeParser9ushortvalEct:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??ushortval_0
          CFI FunCall _ZN11GCodeParser12value_ushortEv
        BL       _ZN11GCodeParser12value_ushortEv
        MOV      R4,R0
??ushortval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock223

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser9linearvalEcf
          CFI Block cfiBlock224 Using cfiCommon0
          CFI Function _ZN11GCodeParser9linearvalEcf
        THUMB
// __interwork __softfp float GCodeParser::linearval(char, float)
_ZN11GCodeParser9linearvalEcf:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??linearval_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R4,R0
??linearval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock224

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN11GCodeParser10celsiusvalEcf
          CFI Block cfiBlock225 Using cfiCommon0
          CFI Function _ZN11GCodeParser10celsiusvalEcf
        THUMB
// __interwork __softfp float GCodeParser::celsiusval(char, float)
_ZN11GCodeParser10celsiusvalEcf:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??celsiusval_0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R4,R0
??celsiusval_0:
        MOV      R0,R4
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock225

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z21incremental_LSF_resetP15linear_fit_data
          CFI Block cfiBlock226 Using cfiCommon0
          CFI Function _Z21incremental_LSF_resetP15linear_fit_data
        THUMB
// __interwork __softfp void incremental_LSF_reset(linear_fit_data *)
_Z21incremental_LSF_resetP15linear_fit_data:
        MOVS     R2,#+60
        MOVS     R1,#+0
          CFI FunCall memset
        B.W      memset
          CFI EndBlock cfiBlock226

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
          CFI Block cfiBlock227 Using cfiCommon0
          CFI Function _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        THUMB
// __interwork __softfp void incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
_Z15incremental_LSFP15linear_fit_dataRKfS2_S2_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R7,R1
        MOV      R6,R2
        MOV      R8,R3
        LDR      R1,[R5, #+0]
        LDR      R0,[R7, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+0]
        LDR      R1,[R5, #+4]
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+4]
        LDR      R1,[R5, #+8]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+8]
        LDR      R11,[R7, #+0]
        MOV      R9,#+2
        MOV      R4,#+1065353216
        MOV      R10,R4
        B.N      ??incremental_LSF_0
??incremental_LSF_1:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??incremental_LSF_0:
        LSLS     R0,R9,#+31
        BPL.N    ??incremental_LSF_2
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_2:
        LSRS     R9,R9,#+1
        BNE.N    ??incremental_LSF_1
        LDR      R0,[R5, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+12]
        LDR      R11,[R6, #+0]
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??incremental_LSF_3
??incremental_LSF_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??incremental_LSF_3:
        LSLS     R0,R9,#+31
        BPL.N    ??incremental_LSF_5
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_5:
        LSRS     R9,R9,#+1
        BNE.N    ??incremental_LSF_4
        LDR      R0,[R5, #+16]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+16]
        LDR      R10,[R8, #+0]
        MOV      R9,#+2
        B.N      ??incremental_LSF_6
??incremental_LSF_7:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_6:
        LSLS     R0,R9,#+31
        BPL.N    ??incremental_LSF_8
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??incremental_LSF_8:
        LSRS     R9,R9,#+1
        BNE.N    ??incremental_LSF_7
        LDR      R0,[R5, #+20]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+20]
        LDR      R1,[R7, #+0]
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+24]
        LDR      R1,[R7, #+0]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+28]
        LDR      R1,[R6, #+0]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+32]
        LDR      R0,[R5, #+36]
        LDR      R1,[R7, #+0]
        BIC      R1,R1,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??incremental_LSF_9
        LDR      R0,[R7, #+0]
        BIC      R0,R0,#0x80000000
??incremental_LSF_9:
        STR      R0,[R5, #+36]
        LDR      R0,[R5, #+40]
        LDR      R1,[R6, #+0]
        BIC      R1,R1,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??incremental_LSF_10
        LDR      R0,[R6, #+0]
        BIC      R0,R0,#0x80000000
??incremental_LSF_10:
        STR      R0,[R5, #+40]
        LDR      R1,[R5, #+56]
        MOV      R0,#+1065353216
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+56]
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock227

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling18mesh_index_to_xposEh
          CFI Block cfiBlock228 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling18mesh_index_to_xposEh
        THUMB
// __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
_ZN20unified_bed_leveling18mesh_index_to_xposEh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        LDR.N    R7,??mesh_index_to_xpos_0
        LDRB     R6,[R7, #+96]
        ADD      R0,R7,#+8
        LDRH     R1,[R0, #+80]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??mesh_index_to_xpos_1
        CMP      R5,R6
        BCS.N    ??mesh_index_to_xpos_2
        LDR.N    R0,??mesh_index_to_xpos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_xpos_3
??mesh_index_to_xpos_2:
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        LDR.N    R4,??mesh_index_to_xpos_0+0x8
        LDR      R0,[R4, #+0]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        LDR      R0,[R4, #+4]
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_xpos_1:
        CMP      R5,R6
        BCS.N    ??mesh_index_to_xpos_4
        LDR.N    R0,??mesh_index_to_xpos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_xpos_3
??mesh_index_to_xpos_4:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        ADD      R0,R7,#+96
        LDR      R11,[R0, #+12]
        LDR      R0,[R7, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mesh_index_to_xpos_5
        STR      R4,[SP, #+0]
        B.N      ??mesh_index_to_xpos_6
??mesh_index_to_xpos_5:
        STR      R7,[SP, #+0]
??mesh_index_to_xpos_6:
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_xpos_7
        MOV      R9,R1
??mesh_index_to_xpos_7:
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_xpos_8
        MOV      R4,R7
??mesh_index_to_xpos_8:
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+0]
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_xpos_3:
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??mesh_index_to_xpos_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE
        DC32     mksTmp
          CFI EndBlock cfiBlock228

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling18mesh_index_to_yposEh
          CFI Block cfiBlock229 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling18mesh_index_to_yposEh
        THUMB
// __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
_ZN20unified_bed_leveling18mesh_index_to_yposEh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        LDR.N    R7,??mesh_index_to_ypos_0
        LDRB     R6,[R7, #+97]
        ADD      R0,R7,#+12
        LDRH     R1,[R0, #+76]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??mesh_index_to_ypos_1
        CMP      R5,R6
        BCS.N    ??mesh_index_to_ypos_2
        LDR.N    R0,??mesh_index_to_ypos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_ypos_3
??mesh_index_to_ypos_2:
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        LDR.N    R4,??mesh_index_to_ypos_0+0x8
        LDR      R0,[R4, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        LDR      R0,[R4, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_ypos_1:
        CMP      R5,R6
        BCS.N    ??mesh_index_to_ypos_4
        LDR.N    R0,??mesh_index_to_ypos_0+0x4
        LDR      R0,[R0, R5, LSL #+2]
        B.N      ??mesh_index_to_ypos_3
??mesh_index_to_ypos_4:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        LDRB     R0,[R7, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R11,[R7, #+112]
        LDR      R0,[R7, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mesh_index_to_ypos_5
        STR      R4,[SP, #+0]
        B.N      ??mesh_index_to_ypos_6
??mesh_index_to_ypos_5:
        STR      R7,[SP, #+0]
??mesh_index_to_ypos_6:
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_ypos_7
        MOV      R9,R1
??mesh_index_to_ypos_7:
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??mesh_index_to_ypos_8
        MOV      R4,R7
??mesh_index_to_ypos_8:
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R6,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+0]
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??mesh_index_to_ypos_3:
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??mesh_index_to_ypos_0:
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
        DC32     mksTmp
          CFI EndBlock cfiBlock229

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling13mesh_is_validEv
          CFI Block cfiBlock230 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling13mesh_is_validEv
        THUMB
// __interwork __softfp bool unified_bed_leveling::mesh_is_valid()
_ZN20unified_bed_leveling13mesh_is_validEv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R2,??mesh_is_valid_0
        LDR      R3,[R2, #+4]
        LDR      R4,[R2, #+0]
        MOV      R0,R4
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R3
        LDR      R1,[R2, #+8]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        LDR      R3,[R2, #+52]
        LDR      R5,[R2, #+48]
        MOV      R0,R5
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R3
        LDR      R1,[R2, #+56]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        LDR      R3,[R2, #+100]
        LDR      R6,[R2, #+96]
        MOV      R0,R6
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R3
        LDR      R1,[R2, #+104]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??mesh_is_valid_1
        MOV      R0,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??mesh_is_valid_2
??mesh_is_valid_1:
        MOV      R0,R4
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??mesh_is_valid_2
        MOVS     R0,#+1
        POP      {R4-R6,PC}
??mesh_is_valid_2:
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
        DATA
??mesh_is_valid_0:
        DC32     _ZN20unified_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock230

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z13gcode_G29_UBLv
          CFI Block cfiBlock231 Using cfiCommon0
          CFI Function _Z13gcode_G29_UBLv
          CFI FunCall _ZN20unified_bed_leveling13gcode_G29_UBLEv
        THUMB
// __interwork __softfp void gcode_G29_UBL()
_Z13gcode_G29_UBLv:
        B.W      _ZN20unified_bed_leveling13gcode_G29_UBLEv
          CFI EndBlock cfiBlock231

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling5set_zEaaRKf
          CFI Block cfiBlock232 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling5set_zEaaRKf
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_z(int8_t, int8_t, float const &)
_ZN17mesh_bed_leveling5set_zEaaRKf:
        ADD      R3,R0,R0, LSL #+1
        LDR.N    R0,??set_z_0
        ADD      R0,R0,R3, LSL #+4
        LDR      R2,[R2, #+0]
        STR      R2,[R0, R1, LSL #+2]
        BX       LR               ;; return
        Nop      
        DATA
??set_z_0:
        DC32     _ZN17mesh_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock232

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling6zigzagEaRaS0_
          CFI Block cfiBlock233 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling6zigzagEaRaS0_
          CFI NoCalls
        THUMB
// __interwork __softfp void mesh_bed_leveling::zigzag(int8_t, int8_t &, int8_t &)
_ZN17mesh_bed_leveling6zigzagEaRaS0_:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R3,??zigzag_0
        LDRB     R4,[R3, #+96]
        SDIV     R5,R0,R4
        MLS      R4,R4,R5,R0
        STRB     R4,[R1, #+0]
        LDRB     R4,[R3, #+96]
        SDIV     R0,R0,R4
        STRB     R0,[R2, #+0]
        LDRB     R0,[R2, #+0]
        LSLS     R0,R0,#+31
        BPL.N    ??zigzag_1
        LDRSB    R0,[R3, #+96]
        SUBS     R0,R0,#+1
        LDRB     R2,[R1, #+0]
        SUBS     R0,R0,R2
        STRB     R0,[R1, #+0]
??zigzag_1:
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
        Nop      
        DATA
??zigzag_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock233

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
          CFI Block cfiBlock234 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        THUMB
// __interwork __softfp void mesh_bed_leveling::set_zigzag_z(int8_t, float const &)
_ZN17mesh_bed_leveling12set_zigzag_zEaRKf:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOV      R4,R1
        ADD      R2,SP,#+0
        ADD      R1,SP,#+1
          CFI FunCall _ZN17mesh_bed_leveling6zigzagEaRaS0_
        BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
        MOV      R2,R4
        LDRSB    R1,[SP, #+0]
        LDRSB    R0,[SP, #+1]
          CFI FunCall _ZN17mesh_bed_leveling5set_zEaaRKf
        BL       _ZN17mesh_bed_leveling5set_zEaaRKf
        POP      {R0,R1,R4,PC}    ;; return
          CFI EndBlock cfiBlock234

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_xERKf
          CFI Block cfiBlock235 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
_ZN17mesh_bed_leveling12cell_index_xERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R6,??cell_index_x_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        ADD      R0,R6,#+8
        LDRH     R1,[R0, #+80]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??cell_index_x_1
        LDR.W    R8,??cell_index_x_0+0x4
        LDR      R0,[R8, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R8, #+4]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??cell_index_x_2
??cell_index_x_1:
        LDR      R9,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        ADD      R0,R6,#+96
        LDR      R10,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??cell_index_x_3
        STR      R8,[SP, #+0]
        B.N      ??cell_index_x_4
??cell_index_x_3:
        STR      R5,[SP, #+0]
??cell_index_x_4:
        MOV      R0,#+1073741824
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_x_5
        MOV      R7,R1
??cell_index_x_5:
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_x_6
        MOV      R8,R5
??cell_index_x_6:
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??cell_index_x_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BPL.N    ??cell_index_x_7
        MOVS     R0,#+0
        B.N      ??cell_index_x_8
??cell_index_x_7:
        LDRB     R2,[R6, #+96]
        SUBS     R3,R2,#+2
        CMP      R3,R1
        BGE.N    ??cell_index_x_8
        SUBS     R0,R2,#+2
??cell_index_x_8:
        SXTB     R0,R0
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??cell_index_x_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3ff00000
          CFI EndBlock cfiBlock235

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_yERKf
          CFI Block cfiBlock236 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
_ZN17mesh_bed_leveling12cell_index_yERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
        LDR.N    R6,??cell_index_y_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R7,R0
        ADD      R0,R6,#+12
        LDRH     R1,[R0, #+76]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??cell_index_y_1
        LDR.W    R8,??cell_index_y_0+0x4
        LDR      R0,[R8, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R8, #+12]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??cell_index_y_2
??cell_index_y_1:
        LDR      R9,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R10,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??cell_index_y_3
        STR      R8,[SP, #+0]
        B.N      ??cell_index_y_4
??cell_index_y_3:
        STR      R5,[SP, #+0]
??cell_index_y_4:
        MOV      R0,#+1073741824
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_y_5
        MOV      R7,R1
??cell_index_y_5:
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??cell_index_y_6
        MOV      R8,R5
??cell_index_y_6:
        LDR      R0,[R4, #+0]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??cell_index_y_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BPL.N    ??cell_index_y_7
        MOVS     R0,#+0
        B.N      ??cell_index_y_8
??cell_index_y_7:
        LDRB     R2,[R6, #+97]
        SUBS     R3,R2,#+2
        CMP      R3,R1
        BGE.N    ??cell_index_y_8
        SUBS     R0,R2,#+2
??cell_index_y_8:
        SXTB     R0,R0
        POP      {R1,R4-R11,PC}   ;; return
        Nop      
        DATA
??cell_index_y_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3ff00000
          CFI EndBlock cfiBlock236

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_xERKf
          CFI Block cfiBlock237 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
_ZN17mesh_bed_leveling13probe_index_xERKf:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R7,R0
        LDR.N    R6,??probe_index_x_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R9,R0
        ADD      R0,R6,#+8
        LDRH     R1,[R0, #+80]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??probe_index_x_1
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR.N    R4,??probe_index_x_0+0x4
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R4, #+4]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3fe00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??probe_index_x_2
??probe_index_x_1:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        ADD      R0,R6,#+96
        LDR      R11,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_x_3
        STR      R4,[SP, #+8]
        B.N      ??probe_index_x_4
??probe_index_x_3:
        STR      R5,[SP, #+8]
??probe_index_x_4:
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R2,R0
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_x_5
        MOV      R8,R10
        B.N      ??probe_index_x_6
??probe_index_x_5:
        MOV      R8,R2
??probe_index_x_6:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_x_7
        MOV      R9,R4
        B.N      ??probe_index_x_8
??probe_index_x_7:
        MOV      R9,R5
??probe_index_x_8:
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_x_9
        MOV      R10,R2
??probe_index_x_9:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_x_10
        MOV      R4,R5
??probe_index_x_10:
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR      R0,[R7, #+0]
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_x_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??probe_index_x_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BMI.N    ??probe_index_x_11
        LDRB     R2,[R6, #+96]
        SUBS     R2,R2,#+1
        CMP      R2,R1
        BGE.N    ??probe_index_x_12
??probe_index_x_11:
        MOV      R0,#-1
??probe_index_x_12:
        POP      {R1-R11,PC}      ;; return
        Nop      
        DATA
??probe_index_x_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock237

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_yERKf
          CFI Block cfiBlock238 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
_ZN17mesh_bed_leveling13probe_index_yERKf:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R7,R0
        LDR.N    R6,??probe_index_y_0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R9,R0
        ADD      R0,R6,#+12
        LDRSH    R1,[R0, #+76]
        MOVW     R2,#+770
        CMP      R1,R2
        BNE.N    ??probe_index_y_1
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR.N    R4,??probe_index_y_0+0x4
        LDR      R0,[R4, #+8]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3fe00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        B.N      ??probe_index_y_2
??probe_index_y_1:
        LDR      R8,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R11,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_y_3
        STR      R4,[SP, #+8]
        B.N      ??probe_index_y_4
??probe_index_y_3:
        STR      R5,[SP, #+8]
??probe_index_y_4:
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R2,R0
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_y_5
        MOV      R8,R10
        B.N      ??probe_index_y_6
??probe_index_y_5:
        MOV      R8,R2
??probe_index_y_6:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_index_y_7
        MOV      R9,R4
        B.N      ??probe_index_y_8
??probe_index_y_7:
        MOV      R9,R5
??probe_index_y_8:
        MOV      R0,R10
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_y_9
        MOV      R10,R2
??probe_index_y_9:
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??probe_index_y_10
        MOV      R4,R5
??probe_index_y_10:
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR      R0,[R7, #+0]
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_y_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
??probe_index_y_2:
        SXTB     R0,R0
        MOVS     R1,R0
        BMI.N    ??probe_index_y_11
        LDRB     R2,[R6, #+97]
        SUBS     R2,R2,#+1
        CMP      R2,R1
        BGE.N    ??probe_index_y_12
??probe_index_y_11:
        MOV      R0,#-1
??probe_index_y_12:
        POP      {R1-R11,PC}      ;; return
        Nop      
        DATA
??probe_index_y_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock238

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z20sync_plan_position_ev
          CFI Block cfiBlock239 Using cfiCommon0
          CFI Function _Z20sync_plan_position_ev
        THUMB
_Z20sync_plan_position_ev:
        LDR.N    R0,??sync_plan_position_e_0
          CFI FunCall _ZN7Planner17set_e_position_mmERKf
        B.W      _ZN7Planner17set_e_position_mmERKf
        Nop      
        DATA
??sync_plan_position_e_0:
        DC32     mks_heating_busy+0x14
          CFI EndBlock cfiBlock239

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28sync_plan_position_kinematicv
          CFI Block cfiBlock240 Using cfiCommon0
          CFI Function _Z28sync_plan_position_kinematicv
        THUMB
_Z28sync_plan_position_kinematicv:
        LDR.N    R0,??sync_plan_position_kinematic_0
          CFI FunCall _ZN7Planner25set_position_mm_kinematicERA4_Kf
        B.W      _ZN7Planner25set_position_mm_kinematicERA4_Kf
        Nop      
        DATA
??sync_plan_position_kinematic_0:
        DC32     mks_heating_busy+0x8
          CFI EndBlock cfiBlock240

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_commit_commandb
          CFI Block cfiBlock241 Using cfiCommon0
          CFI Function _Z15_commit_commandb
          CFI NoCalls
        THUMB
_Z15_commit_commandb:
        LDR.N    R1,??_commit_command_0
        LDRB     R2,[R1, #+8]
        ADDS     R3,R2,R1
        STRB     R0,[R3, #+24]
        ADDS     R0,R2,#+1
        STRB     R0,[R1, #+8]
        UXTB     R0,R0
        CMP      R0,#+4
        BLT.N    ??_commit_command_1
        MOVS     R0,#+0
        STRB     R0,[R1, #+8]
??_commit_command_1:
        LDR.N    R0,??_commit_command_0+0x4
        LDRB     R1,[R0, #+2]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+2]
        BX       LR               ;; return
        DATA
??_commit_command_0:
        DC32     filament_loading_time_flg
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock241

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_enqueuecommandPKcb
          CFI Block cfiBlock242 Using cfiCommon0
          CFI Function _Z15_enqueuecommandPKcb
        THUMB
_Z15_enqueuecommandPKcb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R1
        LDRSB    R1,[R0, #+0]
        CMP      R1,#+59
        BEQ.N    ??_enqueuecommand_0
        LDR.N    R1,??_enqueuecommand_1
        LDRB     R1,[R1, #+2]
        CMP      R1,#+4
        BLT.N    ??_enqueuecommand_2
??_enqueuecommand_0:
        MOVS     R0,#+0
        POP      {R4,PC}
??_enqueuecommand_2:
        MOV      R1,R0
        LDR.N    R0,??_enqueuecommand_1+0x4
        LDRB     R0,[R0, #+8]
        ADD      R2,R0,R0, LSL #+1
        LDR.N    R0,??_enqueuecommand_1+0x8
        ADD      R0,R0,R2, LSL #+5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R4
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??_enqueuecommand_1:
        DC32     mks_heating_busy
        DC32     filament_loading_time_flg
        DC32     command_queue
          CFI EndBlock cfiBlock242

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_serial_commandsv
          CFI Block cfiBlock243 Using cfiCommon0
          CFI Function _Z19get_serial_commandsv
        THUMB
_Z19get_serial_commandsv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
        LDR.N    R4,??get_serial_commands_0
        LDRB     R0,[R4, #+2]
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x4
          CFI FunCall _ZN10USARTClass9availableEv
        BL       _ZN10USARTClass9availableEv
        CMP      R0,#+0
        BNE.W    ??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x8
        LDR      R1,[R0, #+0]
        SUBS     R1,R6,R1
        SUBS     R1,R1,#+1000
        BMI.W    ??get_serial_commands_1
        LDR.N    R5,??get_serial_commands_0+0xC
        LDRB     R1,[R5, #+8]
        CMP      R1,#+6
        BGE.N    ??get_serial_commands_2
        ADDS     R1,R1,#+1
        STRB     R1,[R5, #+8]
??get_serial_commands_2:
        STR      R6,[R0, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_3:
        ADDS     R7,R7,#+1
??get_serial_commands_4:
        LDRSB    R0,[R7, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_serial_commands_3
        CMP      R0,#+78
        BNE.N    ??get_serial_commands_5
        MOV      R9,R7
        B.N      ??get_serial_commands_6
??get_serial_commands_5:
        MOV      R9,#+0
??get_serial_commands_6:
        CMP      R9,#+0
        BEQ.N    ??get_serial_commands_7
        LDR.N    R1,??get_serial_commands_0+0x10
        MOV      R0,R7
          CFI FunCall _Z6strstrPcPKc
        BL       _Z6strstrPcPKc
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_8
        MOV      R8,#+1
        B.N      ??get_serial_commands_9
??get_serial_commands_8:
        MOV      R8,#+0
??get_serial_commands_9:
        CMP      R8,#+0
        BEQ.N    ??get_serial_commands_10
        MOVS     R1,#+78
        ADDS     R0,R7,#+4
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_10
        MOV      R9,R0
??get_serial_commands_10:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,R9,#+1
          CFI FunCall strtol
        BL       strtol
        STR      R0,[R5, #+40]
        LDR      R1,[R5, #+44]
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_11
        CMP      R8,#+0
        BNE.N    ??get_serial_commands_11
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x14
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_11:
        MOVS     R1,#+42
        MOV      R0,R7
          CFI FunCall _Z7strrchrPci
        BL       _Z7strrchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_12
        MOV      R8,#+0
        SUBS     R1,R0,R7
        B.N      ??get_serial_commands_13
??get_serial_commands_14:
        SUBS     R1,R1,#+1
        UXTB     R1,R1
        LDRSB    R2,[R1, R7]
        EOR      R8,R2,R8
??get_serial_commands_13:
        UXTB     R1,R1
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_14
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        UXTB     R8,R8
        CMP      R0,R8
        BEQ.N    ??get_serial_commands_15
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x18
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_15:
        LDR      R0,[R5, #+40]
        STR      R0,[R5, #+44]
??get_serial_commands_7:
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R1,#+71
        MOV      R0,R7
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_serial_commands_16
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_serial_commands_16
        LDR.N    R0,??get_serial_commands_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_serial_commands_0+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_serial_commands_16:
        LDR.N    R1,??get_serial_commands_0+0x24
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_17
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
??get_serial_commands_17:
        LDR.N    R1,??get_serial_commands_0+0x28
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_18
        LDR.N    R0,??get_serial_commands_0+0x2C
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_serial_commands_18:
        LDR.N    R1,??get_serial_commands_0+0x30
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_serial_commands_19
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_serial_commands_19:
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_serial_commands_1:
        LDRB     R0,[R4, #+2]
        CMP      R0,#+4
        BGE.N    ??get_serial_commands_20
        LDR.N    R6,??get_serial_commands_0+0x4
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_20
        SXTB     R0,R0
        LDR.N    R5,??get_serial_commands_0+0xC
        MOVS     R1,#+0
        STRH     R1,[R5, #+8]
        CMP      R0,#+10
        BEQ.N    ??get_serial_commands_21
        CMP      R0,#+13
        BNE.N    ??get_serial_commands_22
??get_serial_commands_21:
        MOV      R0,R1
        LDR.N    R1,??get_serial_commands_0+0x34
        STRB     R0,[R1, #+0]
        LDR      R1,[R5, #+52]
        CMP      R1,#+0
        BEQ.N    ??get_serial_commands_1
        LDR.N    R6,??get_serial_commands_0+0x38
        STRB     R0,[R1, R6]
        STR      R0,[R5, #+52]
        MOV      R7,R6
        B.N      ??get_serial_commands_4
??get_serial_commands_12:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x3C
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_22:
        LDR      R1,[R5, #+52]
        CMP      R1,#+95
        BGE.N    ??get_serial_commands_1
        CMP      R0,#+92
        BNE.N    ??get_serial_commands_23
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_1
        LDR.N    R1,??get_serial_commands_0+0x34
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_serial_commands_1
        LDR      R1,[R5, #+52]
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R5, #+52]
        B.N      ??get_serial_commands_1
??get_serial_commands_23:
        LDR.N    R2,??get_serial_commands_0+0x34
        CMP      R0,#+59
        BNE.N    ??get_serial_commands_24
        MOVS     R3,#+1
        STRB     R3,[R2, #+0]
??get_serial_commands_24:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.N    ??get_serial_commands_1
        LDR.N    R2,??get_serial_commands_0+0x38
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R5, #+52]
        B.N      ??get_serial_commands_1
??get_serial_commands_20:
        POP      {R0,R4-R9,PC}    ;; return
        Nop      
        DATA
??get_serial_commands_0:
        DC32     mks_heating_busy
        DC32     Serial3
        DC32     _ZZ19get_serial_commandsvE14last_wait_time
        DC32     axis_relative_modes
        DC32     _ZZ19get_serial_commandsvEs
        DC32     _ZZ19get_serial_commandsvEs_0
        DC32     _ZZ19get_serial_commandsvEs_1
        DC32     _ZZ19get_serial_commandsvEs_3
        DC32     _ZZ19get_serial_commandsvEs_4
        DC32     _ZZ19get_serial_commandsvEs_5
        DC32     _ZZ19get_serial_commandsvEs_6
        DC32     _ZZ19get_serial_commandsvEs_7
        DC32     _ZZ19get_serial_commandsvEs_8
        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
        DC32     _ZZ19get_serial_commandsvEs_2
          CFI EndBlock cfiBlock243

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_sdcard_commandsv
          CFI Block cfiBlock244 Using cfiCommon0
          CFI Function _Z19get_sdcard_commandsv
        THUMB
_Z19get_sdcard_commandsv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R4,??get_sdcard_commands_0
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BEQ.W    ??get_sdcard_commands_1
        LDR.N    R5,??get_sdcard_commands_0+0x4
        LDRB     R0,[R5, #+2]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_2
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x8
        STRB     R0,[R1, #+0]
??get_sdcard_commands_2:
        MOVS     R6,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R9,R0
        LDR.N    R7,??get_sdcard_commands_0+0x8
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_4:
        CMN      R10,#+1
        BNE.N    ??get_sdcard_commands_5
        LDR.N    R0,??get_sdcard_commands_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_sdcard_commands_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall SD_Init
        BL       SD_Init
        MOV      R0,R4
          CFI FunCall _ZN10CardReader6initsdEv
        BL       _ZN10CardReader6initsdEv
        LDR.N    R1,??get_sdcard_commands_0+0x14
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10reopenfileEPc
        BL       _ZN10CardReader10reopenfileEPc
        CMP      R0,#+0
        BEQ.N    ??get_sdcard_commands_6
        LDR      R1,[R4, #+1120]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??get_sdcard_commands_6:
        LDR.W    R10,??get_sdcard_commands_0+0x18
        MOVS     R2,#+96
        MOVS     R1,#+0
        LDRB     R0,[R10, #+8]
        ADD      R3,R0,R0, LSL #+1
        LDR.N    R0,??get_sdcard_commands_0+0x1C
        ADD      R0,R0,R3, LSL #+5
          CFI FunCall memset
        BL       memset
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
        LDR.N    R0,??get_sdcard_commands_0+0x20
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+16
        BEQ.N    ??get_sdcard_commands_7
          CFI FunCall GUI_RefreshPage
        BL       GUI_RefreshPage
??get_sdcard_commands_7:
        LDRB     R0,[R10, #+5]
        CMP      R0,#+1
        BEQ.N    ??get_sdcard_commands_8
        MOVS     R1,#+36
        MOVS     R0,#+2
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
??get_sdcard_commands_8:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        MOVS     R0,#+1
        STRB     R0,[R10, #+9]
        LDRB     R0,[R10, #+10]
        ADDS     R0,R0,#+1
        STRB     R0,[R10, #+10]
??get_sdcard_commands_5:
        CMP      R8,#+35
        BNE.N    ??get_sdcard_commands_9
        MOVS     R0,#+1
        STRB     R0,[R7, #+0]
??get_sdcard_commands_9:
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x24
        STRB     R0,[R1, #+0]
        UXTH     R6,R6
        CMP      R6,#+0
        BEQ.N    ??get_sdcard_commands_3
        LDR.N    R0,??get_sdcard_commands_0+0x18
        LDRB     R0,[R0, #+8]
        ADD      R1,R0,R0, LSL #+1
        LDR.N    R0,??get_sdcard_commands_0+0x1C
        ADD      R0,R0,R1, LSL #+5
        MOVS     R1,#+0
        STRB     R1,[R6, R0]
        MOV      R6,R1
        MOV      R0,R1
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
??get_sdcard_commands_3:
        LDRB     R0,[R5, #+2]
        CMP      R0,#+4
        BGE.N    ??get_sdcard_commands_1
        LDRB     R0,[R7, #+0]
        ORRS     R0,R0,R9
        BNE.N    ??get_sdcard_commands_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader3getEv
        BL       _ZN10CardReader3getEv
        MOV      R10,R0
        MOV      R8,R10
        SXTB     R8,R8
        MOV      R0,R4
          CFI FunCall _ZN10CardReader3eofEv
        BL       _ZN10CardReader3eofEv
        MOV      R9,R0
        CMP      R9,#+0
        BNE.N    ??get_sdcard_commands_10
        CMN      R10,#+1
        BEQ.N    ??get_sdcard_commands_10
        CMP      R8,#+10
        BEQ.N    ??get_sdcard_commands_10
        CMP      R8,#+13
        BEQ.N    ??get_sdcard_commands_10
        CMP      R8,#+35
        BEQ.N    ??get_sdcard_commands_11
        CMP      R8,#+58
        BNE.N    ??get_sdcard_commands_12
??get_sdcard_commands_11:
        LDR.N    R0,??get_sdcard_commands_0+0x24
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??get_sdcard_commands_12
??get_sdcard_commands_10:
        CMP      R9,#+0
        BEQ.W    ??get_sdcard_commands_4
        LDR.N    R0,??get_sdcard_commands_0+0x28
        MOVS     R1,#+0
        STRB     R1,[R0, #+328]
        STR      R1,[R0, #+664]
        STRB     R1,[R0, #+341]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BEQ.N    ??get_sdcard_commands_13
        MOVS     R6,#+0
        B.N      ??get_sdcard_commands_5
??get_sdcard_commands_13:
        LDR.N    R0,??get_sdcard_commands_0+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14checkautostartEb
        BL       _ZN10CardReader14checkautostartEb
        B.N      ??get_sdcard_commands_5
??get_sdcard_commands_12:
        UXTH     R6,R6
        MOV      R0,R6
        CMP      R0,#+95
        BGE.N    ??get_sdcard_commands_3
        LDR.N    R1,??get_sdcard_commands_0+0x24
        CMP      R8,#+59
        BNE.N    ??get_sdcard_commands_14
        MOVS     R2,#+1
        STRB     R2,[R1, #+0]
??get_sdcard_commands_14:
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_sdcard_commands_3
        LDR.N    R1,??get_sdcard_commands_0+0x18
        LDRB     R1,[R1, #+8]
        ADD      R2,R1,R1, LSL #+1
        LDR.N    R1,??get_sdcard_commands_0+0x1C
        ADD      R1,R1,R2, LSL #+5
        STRB     R8,[R0, R1]
        ADDS     R6,R6,#+1
        CMP      R8,#+90
        BNE.N    ??get_sdcard_commands_3
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        SUBS     R0,R0,#+3
        STR      R0,[R4, #+2724]
        ADDW     R0,R4,#+2724
        LDR      R1,[R4, #+2724]
        STR      R1,[R0, #+4]
        LDR.N    R1,??get_sdcard_commands_0+0x28
        LDRB     R1,[R1, #+415]
        CMP      R1,#+1
        BEQ.N    ??get_sdcard_commands_3
        MOVS     R1,#+1
        STRB     R1,[R0, #+16]
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_1:
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??get_sdcard_commands_0:
        DC32     card
        DC32     mks_heating_busy
        DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
        DC32     errormagic
        DC32     _ZZ19get_sdcard_commandsvEs_0
        DC32     curFileName
        DC32     filament_loading_time_flg
        DC32     command_queue
        DC32     wifi_link_state
        DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
        DC32     gCfgItems
        DC32     _ZZ19get_sdcard_commandsvEs
          CFI EndBlock cfiBlock244

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z17get_wifi_commandsv
          CFI Block cfiBlock245 Using cfiCommon0
          CFI Function _Z17get_wifi_commandsv
        THUMB
_Z17get_wifi_commandsv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??get_wifi_commands_0
        LDRB     R0,[R4, #+8]
        CMP      R0,#+6
        BLT.N    ??get_wifi_commands_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+9]
        LDR.N    R5,??get_wifi_commands_0+0x4
        B.N      ??get_wifi_commands_2
??get_wifi_commands_3:
        ADDS     R7,R7,#+1
??get_wifi_commands_4:
        LDRSB    R0,[R7, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_wifi_commands_3
          CFI FunCall _Z9IsStoppedv
        BL       _Z9IsStoppedv
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R1,#+71
        MOV      R0,R7
          CFI FunCall _Z6strchrPci
        BL       _Z6strchrPci
        CMP      R0,#+0
        BEQ.N    ??get_wifi_commands_5
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall strtol
        BL       strtol
        CMP      R0,#+3
        BHI.N    ??get_wifi_commands_5
        LDR.N    R0,??get_wifi_commands_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??get_wifi_commands_0+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??get_wifi_commands_5:
        LDR.N    R1,??get_wifi_commands_0+0x10
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_6
        MOVS     R0,#+0
        STRB     R0,[R5, #+4]
??get_wifi_commands_6:
        LDR.N    R1,??get_wifi_commands_0+0x14
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_7
        LDR.N    R0,??get_wifi_commands_0+0x18
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_wifi_commands_7:
        LDR.N    R1,??get_wifi_commands_0+0x1C
        MOV      R0,R7
          CFI FunCall strcmp
        BL       strcmp
        CMP      R0,#+0
        BNE.N    ??get_wifi_commands_8
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
??get_wifi_commands_8:
        MOVS     R1,#+1
        MOV      R0,R6
          CFI FunCall _Z15_enqueuecommandPKcb
        BL       _Z15_enqueuecommandPKcb
??get_wifi_commands_2:
        LDRB     R0,[R5, #+2]
        CMP      R0,#+4
        BGE.N    ??get_wifi_commands_9
        LDR.N    R1,??get_wifi_commands_0+0x20
        LDR      R2,[R1, #+96]
        LDR      R0,[R1, #+100]
        CMP      R2,R0
        BEQ.N    ??get_wifi_commands_9
        LDRSB    R0,[R2, R1]
        ADDS     R2,R2,#+1
        MOVS     R3,#+96
        UDIV     R3,R2,R3
        ADD      R6,R3,R3, LSL #+1
        SUB      R2,R2,R6, LSL #+5
        STR      R2,[R1, #+96]
        CMP      R0,#+10
        BEQ.N    ??get_wifi_commands_10
        CMP      R0,#+13
        BNE.N    ??get_wifi_commands_11
??get_wifi_commands_10:
        MOVS     R0,#+0
        LDR.N    R1,??get_wifi_commands_0+0x24
        STRB     R0,[R1, #+0]
        LDR      R1,[R4, #+56]
        CMP      R1,#+0
        BEQ.N    ??get_wifi_commands_2
        LDR.N    R6,??get_wifi_commands_0+0x28
        STRB     R0,[R1, R6]
        STR      R0,[R4, #+56]
        MOV      R7,R6
        B.N      ??get_wifi_commands_4
??get_wifi_commands_11:
        LDR      R1,[R4, #+56]
        CMP      R1,#+95
        BGE.N    ??get_wifi_commands_2
        LDR.N    R2,??get_wifi_commands_0+0x24
        CMP      R0,#+59
        BNE.N    ??get_wifi_commands_12
        MOVS     R3,#+1
        STRB     R3,[R2, #+0]
??get_wifi_commands_12:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.N    ??get_wifi_commands_2
        LDR.N    R2,??get_wifi_commands_0+0x28
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R4, #+56]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+9]
??get_wifi_commands_9:
        POP      {R0,R4-R7,PC}    ;; return
        Nop      
        DATA
??get_wifi_commands_0:
        DC32     axis_relative_modes
        DC32     mks_heating_busy
        DC32     _ZZ17get_wifi_commandsvEs
        DC32     _ZZ17get_wifi_commandsvEs_0
        DC32     _ZZ17get_wifi_commandsvEs_1
        DC32     _ZZ17get_wifi_commandsvEs_2
        DC32     _ZZ17get_wifi_commandsvEs_3
        DC32     _ZZ17get_wifi_commandsvEs_4
        DC32     espGcodeFifo
        DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
        DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
          CFI EndBlock cfiBlock245

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z24get_homing_bump_feedrate8AxisEnum
          CFI Block cfiBlock246 Using cfiCommon0
          CFI Function _Z24get_homing_bump_feedrate8AxisEnum
        THUMB
_Z24get_homing_bump_feedrate8AxisEnum:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+20
          CFI CFA R13+32
        MOV      R4,R0
        ADD      R0,SP,#+0
        LDR.N    R1,??get_homing_bump_feedrate_0
        LDRSH    R1,[R1, #+88]
        CMP      R1,#+2
        BNE.N    ??get_homing_bump_feedrate_1
        MOVS     R1,#+10
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        STR      R1,[R0, #+8]
        B.N      ??get_homing_bump_feedrate_2
??get_homing_bump_feedrate_1:
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        MOVS     R1,#+4
        STR      R1,[R0, #+8]
??get_homing_bump_feedrate_2:
        LDRB     R5,[R0, R4, LSL #+2]
        CMP      R5,#+0
        BNE.N    ??get_homing_bump_feedrate_3
        MOVS     R5,#+10
        LDR.N    R0,??get_homing_bump_feedrate_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??get_homing_bump_feedrate_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??get_homing_bump_feedrate_3:
        MOV      R0,R5
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR.N    R0,??get_homing_bump_feedrate_0+0xC
        ADD      R0,R0,R4, LSL #+2
        LDR      R0,[R0, #+40]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        DATA
??get_homing_bump_feedrate_0:
        DC32     mksCfg
        DC32     echomagic
        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock246

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z31buffer_line_to_current_positionv
          CFI Block cfiBlock247 Using cfiCommon0
          CFI Function _Z31buffer_line_to_current_positionv
        THUMB
_Z31buffer_line_to_current_positionv:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+12
          CFI CFA R13+16
        LDR.N    R0,??buffer_line_to_current_position_0
        LDRB     R1,[R0, #+3]
        STR      R1,[SP, #+4]
        ADD      R1,R0,#+92
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+20
        LDR      R2,[R0, #+16]
        LDR      R1,[R0, #+12]
        LDR      R0,[R0, #+8]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0-R2,PC}       ;; return
        DATA
??buffer_line_to_current_position_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock247

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26buffer_line_to_destinationf
          CFI Block cfiBlock248 Using cfiCommon0
          CFI Function _Z26buffer_line_to_destinationf
        THUMB
_Z26buffer_line_to_destinationf:
        PUSH     {R0,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        LDR.N    R0,??buffer_line_to_destination_0
        LDRB     R1,[R0, #+3]
        STR      R1,[SP, #+4]
        ADD      R1,SP,#+8
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+36
        LDR      R2,[R0, #+32]
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        POP      {R0-R2,PC}       ;; return
        Nop      
        DATA
??buffer_line_to_destination_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock248

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14do_probe_raisef
          CFI Block cfiBlock249 Using cfiCommon0
          CFI Function _Z14do_probe_raisef
        THUMB
_Z14do_probe_raisef:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        STR      R0,[SP, #+0]
        LDR.N    R4,??do_probe_raise_0
        LDR      R2,[R4, #+112]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_probe_raise_1
        LDR      R0,[SP, #+0]
        MOV      R1,R2
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
??do_probe_raise_1:
        LDR      R0,[R4, #+16]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_probe_raise_2
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??do_probe_raise_2:
        POP      {R0,R1,R4,PC}    ;; return
        DATA
??do_probe_raise_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock249

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z11gcode_G0_G1v
          CFI Block cfiBlock250 Using cfiCommon0
          CFI Function _Z11gcode_G0_G1v
        THUMB
_Z11gcode_G0_G1v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock250

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z17gcode_G0_G1_SCARAb
          CFI Block cfiBlock251 Using cfiCommon0
          CFI Function _Z17gcode_G0_G1_SCARAb
        THUMB
_Z17gcode_G0_G1_SCARAb:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.N    ??gcode_G0_G1_SCARA_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        CMP      R4,#+0
        BEQ.N    ??gcode_G0_G1_SCARA_1
        MOVS     R0,#+0
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.W      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_SCARA_1:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_G0_G1_SCARA_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock251

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_G2_G3b
          CFI Block cfiBlock252 Using cfiCommon0
          CFI Function _Z11gcode_G2_G3b
        THUMB
_Z11gcode_G2_G3b:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+32
          CFI CFA R13+72
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        ADD      R0,SP,#+16
        MOVS     R1,#+0
        MOV      R2,R1
        STM      R0!,{R1,R2}
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R4,R0
        LDR.N    R0,??gcode_G2_G3_2
        LDR      R1,[R0, #+8]
        STR      R1,[SP, #+4]
        LDR      R1,[R0, #+12]
        STR      R1,[SP, #+0]
        LDR      R1,[R0, #+24]
        STR      R1,[SP, #+12]
        LDR      R0,[R0, #+28]
        STR      R0,[SP, #+8]
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_3
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_4
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_3
??gcode_G2_G3_4:
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G2_G3_5
        MOVS     R0,#+1
        B.N      ??gcode_G2_G3_6
??gcode_G2_G3_5:
        MOV      R0,R1
??gcode_G2_G3_6:
        MOV      R7,#+1065353216
        LDRB     R1,[SP, #+32]
        TEQ      R0,R1
        BEQ.N    ??gcode_G2_G3_7
        LDR.N    R6,??gcode_G2_G3_2+0x4  ;; 0xbf800000
        B.N      ??gcode_G2_G3_8
??gcode_G2_G3_7:
        MOV      R6,R7
??gcode_G2_G3_8:
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
        LDR      R8,[SP, #+28]
        MOV      R9,#+2
        MOV      R5,R7
        B.N      ??gcode_G2_G3_9
??gcode_G2_G3_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??gcode_G2_G3_9:
        LSLS     R0,R9,#+31
        BPL.N    ??gcode_G2_G3_11
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??gcode_G2_G3_11:
        LSRS     R9,R9,#+1
        BNE.N    ??gcode_G2_G3_10
        LDR      R8,[SP, #+24]
        MOV      R9,#+2
        MOV      R10,R7
        B.N      ??gcode_G2_G3_12
??gcode_G2_G3_13:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??gcode_G2_G3_12:
        LSLS     R0,R9,#+31
        BPL.N    ??gcode_G2_G3_14
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??gcode_G2_G3_14:
        LSRS     R9,R9,#+1
        BNE.N    ??gcode_G2_G3_13
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R10,R0
        MOVS     R5,#+2
        B.N      ??gcode_G2_G3_15
??gcode_G2_G3_16:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??gcode_G2_G3_15:
        LSLS     R0,R5,#+31
        BPL.N    ??gcode_G2_G3_17
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??gcode_G2_G3_17:
        LSRS     R5,R5,#+1
        BNE.N    ??gcode_G2_G3_16
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_G2_G3_2+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
        MOV      R11,#+2
        MOVS     R4,#+0
        LDR.N    R5,??gcode_G2_G3_2+0xC  ;; 0x3ff00000
        B.N      ??gcode_G2_G3_18
??gcode_G2_G3_19:
        MOV      R0,R8
        MOV      R1,R9
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R9,R1
??gcode_G2_G3_18:
        LSLS     R0,R11,#+31
        BPL.N    ??gcode_G2_G3_20
        MOV      R2,R8
        MOV      R3,R9
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R5,R1
??gcode_G2_G3_20:
        LSRS     R11,R11,#+1
        BNE.N    ??gcode_G2_G3_19
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall sqrt
        BL       sqrt
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        MOV      R5,#+1056964608
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
        LDR      R0,[SP, #+24]
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+16]
        LDR      R1,[SP, #+0]
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
        B.N      ??gcode_G2_G3_3
??gcode_G2_G3_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_21
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+16]
??gcode_G2_G3_21:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G2_G3_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+20]
??gcode_G2_G3_3:
        LDR      R0,[SP, #+16]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_22
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_G2_G3_23
??gcode_G2_G3_22:
        LDRB     R2,[SP, #+32]
        ADD      R1,SP,#+16
        LDR.N    R0,??gcode_G2_G3_2+0x10
          CFI FunCall _Z8plan_arcRA4_KfRA2_S_b
        BL       _Z8plan_arcRA4_KfRA2_S_b
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        B.N      ??gcode_G2_G3_0
??gcode_G2_G3_23:
        LDR.N    R0,??gcode_G2_G3_2+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G2_G3_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G2_G3_0:
        ADD      SP,SP,#+36
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??gcode_G2_G3_2:
        DC32     mks_heating_busy
        DC32     0xbf800000
        DC32     0x3fe00000
        DC32     0x3ff00000
        DC32     mks_heating_busy+0x18
        DC32     errormagic
        DC32     _ZZ11gcode_G2_G3bEs
          CFI EndBlock cfiBlock252

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z8gcode_G4v
          CFI Block cfiBlock253 Using cfiCommon0
          CFI Function _Z8gcode_G4v
        THUMB
_Z8gcode_G4v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R4,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_0
          CFI FunCall _ZN11GCodeParser12value_millisEv
        BL       _ZN11GCodeParser12value_millisEv
        MOV      R4,R0
??gcode_G4_0:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G4_1
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        MOV      R4,R0
??gcode_G4_1:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
          CFI FunCall _Z13lcd_hasstatusv
        BL       _Z13lcd_hasstatusv
        CMP      R0,#+0
        BNE.N    ??gcode_G4_2
        MOVS     R1,#+0
        LDR.N    R0,??gcode_G4_3
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_G4_2:
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z5dwellm
        B.W      _Z5dwellm
        Nop      
        DATA
??gcode_G4_3:
        DC32     _ZZ8gcode_G4vEs
          CFI EndBlock cfiBlock253

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10home_deltav
          CFI Block cfiBlock254 Using cfiCommon0
          CFI Function _Z10home_deltav
        THUMB
_Z10home_deltav:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??home_delta_0
        MOVS     R2,#+16
        MOVS     R1,#+0
        ADD      R0,R4,#+8
          CFI FunCall memset
        BL       memset
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        LDR      R0,[R4, #+120]
        LDR.N    R1,??home_delta_0+0x4  ;; 0x41200000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
        STR      R0,[R4, #+12]
        STR      R0,[R4, #+8]
        LDR      R0,[R4, #+40]
        STR      R0,[R4, #+92]
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.N    R0,??home_delta_0+0x8
        LDRSB    R0,[R0, #+0]
        MOVS     R1,#+112
        TST      R0,R1
        BNE.N    ??home_delta_1
        MOVS     R1,#+0
        LDR.N    R0,??home_delta_0+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        LDR.N    R0,??home_delta_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??home_delta_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+0
        POP      {R4,PC}
??home_delta_1:
          CFI FunCall _ZN8Endstops14hit_on_purposeEv
        BL       _ZN8Endstops14hit_on_purposeEv
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R4,#+0
        B.N      ??home_delta_2
??home_delta_3:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
        ADDS     R4,R4,#+1
??home_delta_2:
        CMP      R4,#+3
        BLT.N    ??home_delta_3
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        MOVS     R0,#+1
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??home_delta_0:
        DC32     mks_heating_busy
        DC32     0x41200000
        DC32     _ZN8Endstops16endstop_hit_bitsE
        DC32     _ZZ10home_deltavEs
        DC32     errormagic
        DC32     _ZZ10home_deltavEs_0
          CFI EndBlock cfiBlock254

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G28b
          CFI Block cfiBlock255 Using cfiCommon0
          CFI Function _Z9gcode_G28b
        THUMB
_Z9gcode_G28b:
        PUSH     {R1-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+48
        MOV      R8,R0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.N    R5,??gcode_G28_0
        ADDW     R0,R5,#+63
        STR      R0,[SP, #+0]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+16
        BNE.N    ??gcode_G28_1
        LDR.N    R1,??gcode_G28_0+0x4
        LDRB     R4,[R1, #+0]
??gcode_G28_1:
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??gcode_G28_2
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G28_2:
        LDR.N    R6,??gcode_G28_0+0x8
        LDRB     R0,[R6, #+3]
        STRB     R0,[SP, #+8]
        MOVS     R2,#+1
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops6enableEb
        BL       _ZN8Endstops6enableEb
        LDRSH    R0,[R5, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_G28_3
          CFI FunCall _Z10home_deltav
        BL       _Z10home_deltav
        B.N      ??gcode_G28_4
??gcode_G28_3:
        CMP      R8,#+0
        BNE.N    ??gcode_G28_5
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R11,R0
        B.N      ??gcode_G28_6
??gcode_G28_5:
        MOV      R11,#+1
??gcode_G28_6:
        CMP      R8,#+0
        BNE.N    ??gcode_G28_7
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R7,R0
        B.N      ??gcode_G28_8
??gcode_G28_7:
        MOVS     R7,#+1
??gcode_G28_8:
        CMP      R8,#+0
        BNE.N    ??gcode_G28_9
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R8,R0
        B.N      ??gcode_G28_10
??gcode_G28_9:
        MOV      R8,#+1
??gcode_G28_10:
        AND      R9,R7,R11
        ORR      R0,R7,R11
        ORR      R0,R8,R0
        EOR      R0,R0,#0x1
        AND      R1,R8,R9
        ORR      R10,R1,R0
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+1
        BLT.N    ??gcode_G28_11
        ORRS     R0,R8,R10
        BEQ.N    ??gcode_G28_11
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_11:
        ORR      R11,R11,R10
        ORRS     R0,R7,R11
        BEQ.N    ??gcode_G28_12
        LDR.N    R0,??gcode_G28_0+0xC
        LDRB     R0,[R0, #+2720]
        CMP      R0,#+171
        BNE.N    ??gcode_G28_13
        CMP      R0,#+172
        BEQ.N    ??gcode_G28_12
??gcode_G28_13:
        LDR.N    R1,??gcode_G28_0+0x10  ;; 0x40a00000
        STR      R1,[R6, #+32]
        LDR      R0,[R6, #+16]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G28_12
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,R6,#+32
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
??gcode_G28_12:
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G28_14
        ORRS     R0,R9,R10
        BEQ.N    ??gcode_G28_14
          CFI FunCall _Z13quick_home_xyv
        BL       _Z13quick_home_xyv
??gcode_G28_14:
        LDRH     R0,[R5, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G28_15
        ORRS     R0,R7,R10
        BEQ.N    ??gcode_G28_15
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_15:
        CMP      R11,#+0
        BEQ.N    ??gcode_G28_16
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_16:
        LDRB     R0,[R5, #+63]
        CMP      R0,#+0
        BNE.N    ??gcode_G28_17
        ORRS     R0,R7,R10
        BEQ.N    ??gcode_G28_17
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_17:
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??gcode_G28_18
        ORRS     R0,R8,R10
        BEQ.N    ??gcode_G28_18
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
??gcode_G28_18:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G28_4:
          CFI FunCall _ZN8Endstops10not_homingEv
        BL       _ZN8Endstops10not_homingEv
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+16
        BNE.N    ??gcode_G28_19
        MOV      R0,R4
        UXTB     R0,R0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G28_19:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
        MOVS     R2,#+1
        MOVS     R1,#+0
        LDRB     R0,[SP, #+8]
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
          CFI FunCall _Z11lcd_refreshv
        BL       _Z11lcd_refreshv
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        POP      {R0-R2,R4-R11,PC}  ;; return
        DATA
??gcode_G28_0:
        DC32     mksCfg
        DC32     _ZN7Planner15leveling_activeE
        DC32     mks_heating_busy
        DC32     card
        DC32     0x40a00000
          CFI EndBlock cfiBlock255

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_manual_goto_xyRKfS0_
          CFI Block cfiBlock256 Using cfiCommon0
          CFI Function _Z15_manual_goto_xyRKfS0_
        THUMB
_Z15_manual_goto_xyRKfS0_:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
        MOV      R4,R0
        MOV      R5,R1
        LDR.N    R6,??_manual_goto_xy_0
        LDR.N    R2,??_manual_goto_xy_0+0x4
        LDR      R0,[R2, #+104]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??_manual_goto_xy_1
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+8]
        MOV      R0,R1
        STR      R0,[SP, #+4]
        ADD      R3,SP,#+4
        ADDS     R2,R2,#+104
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_
        BL       _Z21do_blocking_move_to_zRKfS0_
        B.N      ??_manual_goto_xy_2
??_manual_goto_xy_1:
        MOV      R0,R1
        STR      R0,[SP, #+0]
        ADD      R2,SP,#+0
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
??_manual_goto_xy_2:
        LDR      R0,[R4, #+0]
        STR      R0,[R6, #+8]
        LDR      R0,[R5, #+0]
        STR      R0,[R6, #+12]
        MOVS     R0,#+0
        LDR.N    R1,??_manual_goto_xy_0+0x8
        STRB     R0,[R1, #+9]
        POP      {R0-R6,PC}       ;; return
        Nop      
        DATA
??_manual_goto_xy_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     axis_homed
          CFI EndBlock cfiBlock256

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z27gcode_G29_MESH_BED_LEVELINGv
          CFI Block cfiBlock257 Using cfiCommon0
          CFI Function _Z27gcode_G29_MESH_BED_LEVELINGv
        THUMB
_Z27gcode_G29_MESH_BED_LEVELINGv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOVS     R1,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        MOV      R4,R0
        SXTB     R4,R4
        CMP      R4,#+6
        BCC.N    ??gcode_G29_MESH_BED_LEVELING_1
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_1:
        MOV      R0,R4
        CMP      R0,#+5
        BHI.W    ??gcode_G29_MESH_BED_LEVELING_4
        TBB      [PC, R0]
        DATA
??gcode_G29_MESH_BED_LEVELING_0:
        DC8      0x3,0x1C,0x2B,0x7F
        DC8      0xD0,0xE1
          CFI FunCall _Z17leveling_is_validv
        THUMB
??gcode_G29_MESH_BED_LEVELING_5:
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_6
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_7
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x8
        B.N      ??gcode_G29_MESH_BED_LEVELING_8
??gcode_G29_MESH_BED_LEVELING_7:
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0xC
??gcode_G29_MESH_BED_LEVELING_8:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x10
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_6:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_9:
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        STR      R0,[R1, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x20
        LDRB     R0,[R0, #+9]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x24
        B.N      ??gcode_G29_MESH_BED_LEVELING_11
??gcode_G29_MESH_BED_LEVELING_10:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x28
??gcode_G29_MESH_BED_LEVELING_11:
          CFI FunCall _Z27enqueue_and_echo_commands_PPKc
        BL       _Z27enqueue_and_echo_commands_PPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_12:
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        LDR      R0,[R5, #+0]
        CMP      R0,#+0
        BPL.N    ??gcode_G29_MESH_BED_LEVELING_13
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_13:
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x30
        LDR.N    R7,??gcode_G29_MESH_BED_LEVELING_2+0x20
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_14
        LDRB     R0,[R7, #+8]
        STRB     R0,[R6, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_15
??gcode_G29_MESH_BED_LEVELING_14:
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x34
        SUBS     R0,R0,#+1
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        BL       _ZN17mesh_bed_leveling12set_zigzag_zEaRKf
        LDRB     R0,[R6, #+0]
        STRB     R0,[R7, #+8]
??gcode_G29_MESH_BED_LEVELING_15:
        LDR      R0,[R5, #+0]
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
        ADD      R8,R6,#+96
        LDRB     R1,[R6, #+96]
        LDRB     R2,[R8, #+1]
        MULS     R1,R2,R1
        CMP      R0,R1
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_16
        ADD      R2,SP,#+0
        ADD      R1,SP,#+1
        SXTB     R0,R0
          CFI FunCall _ZN17mesh_bed_leveling6zigzagEaRaS0_
        BL       _ZN17mesh_bed_leveling6zigzagEaRaS0_
        LDRSB    R0,[SP, #+0]
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x3C
        ADD      R1,R1,R0, LSL #+2
        LDRSB    R0,[SP, #+1]
        LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x40
        ADD      R0,R2,R0, LSL #+2
          CFI FunCall _Z15_manual_goto_xyRKfS0_
        BL       _Z15_manual_goto_xyRKfS0_
        MOVS     R0,#+0
        STRB     R0,[R7, #+8]
        LDR      R0,[R5, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_16:
        LDR      R0,[R6, #+16]
        LDR      R1,[R8, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x44
        STR      R0,[R1, #+16]
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOV      R0,#-1
        STR      R0,[R5, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x48
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x4C
        STRB     R0,[R1, #+0]
          CFI FunCall _Z13home_all_axesv
        BL       _Z13home_all_axesv
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MOVS     R0,#+0
        STRB     R0,[R7, #+9]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_17:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_18
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+1]
        LDRSB    R0,[SP, #+1]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_19
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
        LDRB     R1,[R6, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_20
??gcode_G29_MESH_BED_LEVELING_19:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x50
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_20:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_21
        MOVS     R1,#+89
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z16echo_not_enteredv
        BL       _Z16echo_not_enteredv
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_18:
        MOVS     R1,#+88
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z16echo_not_enteredv
        BL       _Z16echo_not_enteredv
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_21:
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+0]
        LDRSB    R0,[SP, #+0]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_22
        ADD      R1,R6,#+96
        LDRB     R1,[R1, #+1]
        SUBS     R1,R1,#+1
        CMP      R1,R0
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_23
??gcode_G29_MESH_BED_LEVELING_22:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_23:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDRSB    R1,[SP, #+0]
        LDRSB    R2,[SP, #+1]
        ADD      R3,R2,R2, LSL #+1
        LDR.N    R2,??gcode_G29_MESH_BED_LEVELING_2+0x58
        ADD      R2,R2,R3, LSL #+4
        STR      R0,[R2, R1, LSL #+2]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_25:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x5C
        STR      R0,[R1, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_4
??gcode_G29_MESH_BED_LEVELING_24:
        MOVS     R1,#+90
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z16echo_not_enteredv
        BL       _Z16echo_not_enteredv
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_26:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
??gcode_G29_MESH_BED_LEVELING_4:
        CMP      R4,#+1
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_27
        CMP      R4,#+2
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_28
??gcode_G29_MESH_BED_LEVELING_27:
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x38
        ADD      R8,R6,#+96
        LDRB     R0,[R6, #+96]
        LDRB     R1,[R8, #+1]
        MULS     R1,R1,R0
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        LDR      R0,[R5, #+0]
        CMP      R0,R1
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_29
        MOV      R1,R0
??gcode_G29_MESH_BED_LEVELING_29:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x60
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDRB     R0,[R6, #+96]
        LDRB     R1,[R8, #+1]
        MULS     R1,R1,R0
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x64
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_MESH_BED_LEVELING_28:
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_G29_MESH_BED_LEVELING_3:
        POP      {R0,R1,R4-R8,PC}  ;; return
        DATA
??gcode_G29_MESH_BED_LEVELING_2:
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        DC32     _ZN7Planner15leveling_activeE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        DC32     Serial3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        DC32     axis_homed
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        DC32     mks_heating_busy+0x10
        DC32     mksCfg
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     mks_heating_busy
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
        DC32     _ZN17mesh_bed_leveling8has_meshE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
        DC32     _ZN17mesh_bed_leveling8z_valuesE
        DC32     _ZN17mesh_bed_leveling8z_offsetE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
          CFI EndBlock cfiBlock257

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G29v
          CFI Block cfiBlock258 Using cfiCommon0
          CFI Function _Z9gcode_G29v
        THUMB
_Z9gcode_G29v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+812
          CFI CFA R13+848
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.W    ??gcode_G29_0
        MOVS     R0,#+0
        STR      R0,[SP, #+56]
        STR      R0,[SP, #+52]
        STR      R0,[SP, #+36]
        MOV      R6,R0
        STR      R0,[SP, #+20]
        STR      R0,[SP, #+8]
        STR      R0,[SP, #+72]
        STR      R0,[SP, #+28]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+96]
        STR      R0,[SP, #+48]
        LDR.W    R1,??gcode_G29_1+0x4
        STR      R1,[SP, #+32]
        LDRB     R1,[R1, #+1]
        STR      R1,[SP, #+16]
        MOV      R2,R6
        STRB     R2,[SP, #+12]
        MULS     R0,R1,R0
        LDR.W    R1,??gcode_G29_1
        LDRB     R1,[R1, #+64]
        MOVS     R2,#+6
        TST      R1,R2
        BNE.N    ??gcode_G29_2
        STR      R0,[SP, #+68]
??gcode_G29_2:
        ADD      R0,R0,R0, LSL #+1
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        STR      R0,[SP, #+44]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_3
        MOV      R0,R6
        LDR.W    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+4]
        LDR.W    R0,??gcode_G29_1+0xC
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_3:
        MOV      R0,R6
        B.N      ??gcode_G29_4
??gcode_G29_5:
        MOV      R1,R6
        LDR      R2,[SP, #+44]
        STR      R1,[R2, R0, LSL #+2]
        ADDS     R0,R0,#+1
??gcode_G29_4:
        LDR.W    R1,??gcode_G29_1
        LDRB     R1,[R1, #+96]
        LDR      R2,[SP, #+32]
        LDRB     R2,[R2, #+1]
        MULS     R1,R2,R1
        ADD      R2,R1,R1, LSL #+1
        ADDS     R2,R2,#+1
        CMP      R0,R2
        BLT.N    ??gcode_G29_5
        ADDS     R0,R1,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        STR      R0,[SP, #+64]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_6
        MOV      R0,R6
        LDR.W    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+4]
        LDR.W    R0,??gcode_G29_1+0x10
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_6:
        MOV      R0,R6
        B.N      ??gcode_G29_7
??gcode_G29_8:
        MOV      R1,R6
        LDR      R2,[SP, #+64]
        STR      R1,[R2, R0, LSL #+2]
        ADDS     R0,R0,#+1
??gcode_G29_7:
        LDR.W    R1,??gcode_G29_1
        LDRB     R1,[R1, #+96]
        LDR      R2,[SP, #+32]
        LDRB     R2,[R2, #+1]
        MULS     R1,R2,R1
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BLT.N    ??gcode_G29_8
        MOV      R3,R6
        LDR      R0,[SP, #+32]
        LDR      R2,[R0, #+64]
        LDR      R1,[R0, #+60]
        ADD      R0,SP,#+88
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOV      R3,R6
        LDR      R0,[SP, #+32]
        LDR      R2,[R0, #+72]
        LDR      R1,[R0, #+68]
        ADD      R0,SP,#+100
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        MOV      R3,R6
        LDR      R0,[SP, #+32]
        LDR      R2,[R0, #+80]
        LDR      R1,[R0, #+76]
        ADD      R0,SP,#+112
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDR.W    R0,??gcode_G29_1
        LDRB     R4,[R0, #+64]
        ANDS     R5,R4,#0x4
        BEQ.N    ??gcode_G29_9
        ADD      R0,SP,#+172
          CFI FunCall _Z21incremental_LSF_resetP15linear_fit_data
        BL       _Z21incremental_LSF_resetP15linear_fit_data
??gcode_G29_9:
        CMP      R5,#+0
        BEQ.N    ??gcode_G29_10
        MOV      R6,#-1
??gcode_G29_10:
        LDR.W    R0,??gcode_G29_1+0x14
        LDRB     R9,[R0, #+0]
        CMP      R4,#+8
        BNE.W    ??gcode_G29_11
        MOVS     R0,#+87
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_11
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BNE.N    ??gcode_G29_12
        LDR.W    R0,??gcode_G29_1+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_1+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_12:
        LDR.W    R4,??gcode_G29_1+0x20
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_13
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        B.N      ??gcode_G29_14
??gcode_G29_13:
        LDR      R5,[R4, #+16]
??gcode_G29_14:
        MOV      R0,R5
        LDR.W    R1,??gcode_G29_1+0x24  ;; 0xc1200000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_15
        LDR.W    R1,??gcode_G29_1+0x28  ;; 0x41200001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_16
??gcode_G29_15:
        LDR.W    R0,??gcode_G29_1+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_1+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_16:
        MVN      R6,#-2147483648
        MOV      R1,R6
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR      R1,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R1,R6
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOVS     R1,#+255
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        MOV      R7,R0
        SXTB     R7,R7
        MOVS     R1,#+255
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        MOV      R4,R0
        SXTB     R4,R4
        MOV      R0,R8
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_17
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_17
        LDR.W    R4,??gcode_G29_1+0x8
        LDR      R0,[R4, #+24]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R7,R0
        SXTB     R7,R7
        LDR      R0,[R4, #+28]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        MOV      R4,R0
        SXTB     R4,R4
        CMP      R7,#+0
        BPL.N    ??gcode_G29_18
        MOVS     R7,#+0
        B.N      ??gcode_G29_19
??gcode_G29_18:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+96]
        SUBS     R1,R0,#+1
        CMP      R1,R7
        BGE.N    ??gcode_G29_19
        SUBS     R7,R0,#+1
??gcode_G29_19:
        SXTB     R7,R7
        CMP      R4,#+0
        BPL.N    ??gcode_G29_20
        MOVS     R4,#+0
        B.N      ??gcode_G29_21
??gcode_G29_20:
        LDR      R0,[SP, #+32]
        LDRB     R0,[R0, #+1]
        SUBS     R1,R0,#+1
        CMP      R1,R4
        BGE.N    ??gcode_G29_21
        SUBS     R4,R0,#+1
??gcode_G29_21:
        SXTB     R4,R4
??gcode_G29_17:
        CMP      R7,#+0
        BMI.W    ??gcode_G29_0
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+96]
        SUBS     R0,R0,#+1
        CMP      R0,R7
        BLT.W    ??gcode_G29_0
        CMP      R4,#+0
        BMI.W    ??gcode_G29_0
        LDR      R0,[SP, #+32]
        LDRB     R0,[R0, #+1]
        CMP      R0,R4
        BLT.W    ??gcode_G29_0
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??gcode_G29_1+0x30
        ADD      R0,R1,R0, LSL #+4
        STR      R5,[R0, R4, LSL #+2]
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        CMP      R9,#+0
        BEQ.W    ??gcode_G29_0
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        B.W      ??gcode_G29_0
??gcode_G29_11:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_22
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        B.W      ??gcode_G29_0
??gcode_G29_22:
        MOVS     R1,#+0
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        STR      R0,[SP, #+40]
        CMP      R0,#+5
        BCC.N    ??gcode_G29_23
        LDR.W    R0,??gcode_G29_1+0x34
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_23:
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        STR      R0,[SP, #+60]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        LSLS     R1,R0,#+29
        BPL.N    ??gcode_G29_24
        LDR      R0,[SP, #+40]
        CMP      R0,#+3
        BGE.N    ??gcode_G29_25
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        STRB     R0,[SP, #+12]
        B.N      ??gcode_G29_26
??gcode_G29_25:
        MOVS     R0,#+1
        STRB     R0,[SP, #+12]
??gcode_G29_26:
        LDR.W    R0,??gcode_G29_1
        LDRB     R1,[R0, #+96]
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        UXTB     R0,R0
        STR      R0,[SP, #+48]
        LDR      R0,[SP, #+32]
        LDRB     R1,[R0, #+1]
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_27
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        ADD      R0,SP,#+16
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+48]
??gcode_G29_27:
        LDR      R0,[SP, #+48]
        CMP      R0,#+2
        BLT.N    ??gcode_G29_28
        LDR      R0,[SP, #+16]
        CMP      R0,#+2
        BGE.N    ??gcode_G29_29
??gcode_G29_28:
        LDR.W    R0,??gcode_G29_1+0x38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??gcode_G29_0
??gcode_G29_29:
        LDR      R0,[SP, #+48]
        LDR      R1,[SP, #+16]
        MULS     R0,R1,R0
        STR      R0,[SP, #+68]
        MOV      R8,#+0
        B.N      ??gcode_G29_30
??gcode_G29_24:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_30
        MOVS     R1,#+0
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        STR      R0,[SP, #+84]
??gcode_G29_30:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+12
        TST      R0,R1
        BEQ.W    ??gcode_G29_31
        LDR.W    R4,??gcode_G29_1+0x20
        LDR      R0,[SP, #+32]
        LDR      R1,[R0, #+20]
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR.W    R1,??gcode_G29_1+0x3C  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+116]
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_32
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+20]
        B.N      ??gcode_G29_33
??gcode_G29_32:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+40]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+20]
??gcode_G29_33:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_34
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
        B.N      ??gcode_G29_35
??gcode_G29_34:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+44]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
??gcode_G29_35:
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_36
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+8]
        B.N      ??gcode_G29_37
??gcode_G29_36:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+48]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+8]
??gcode_G29_37:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_38
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
        B.N      ??gcode_G29_39
??gcode_G29_38:
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+52]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R4,R0
??gcode_G29_39:
        LDR.W    R7,??gcode_G29_1+0x40
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R7, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_40
        SUB      R0,R5,#+10
        LDR      R1,[SP, #+20]
        CMP      R0,R1
        BGE.N    ??gcode_G29_41
??gcode_G29_40:
        MOVS     R0,#+1
        STRB     R0,[SP, #+0]
        B.N      ??gcode_G29_42
??gcode_G29_41:
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
??gcode_G29_42:
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_43
        LDR      R0,[SP, #+20]
        ADDS     R0,R0,#+10
        CMP      R5,R0
        BGE.N    ??gcode_G29_44
??gcode_G29_43:
        MOV      R10,#+1
        B.N      ??gcode_G29_45
??gcode_G29_44:
        MOV      R10,#+0
??gcode_G29_45:
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R7, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_46
        SUB      R0,R4,#+10
        LDR      R1,[SP, #+8]
        CMP      R0,R1
        BGE.N    ??gcode_G29_47
??gcode_G29_46:
        MOV      R11,#+1
        B.N      ??gcode_G29_48
??gcode_G29_47:
        MOV      R11,#+0
??gcode_G29_48:
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+12]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_49
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+10
        CMP      R4,R0
        BGE.N    ??gcode_G29_50
??gcode_G29_49:
        MOVS     R7,#+1
        B.N      ??gcode_G29_51
??gcode_G29_50:
        MOVS     R7,#+0
??gcode_G29_51:
        LDRB     R0,[SP, #+0]
        ORR      R0,R10,R0
        ORR      R0,R11,R0
        ORRS     R0,R7,R0
        BEQ.N    ??gcode_G29_52
        LDRB     R0,[SP, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_53
        LDR.W    R0,??gcode_G29_1+0x44
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_53:
        CMP      R10,#+0
        BEQ.N    ??gcode_G29_54
        LDR.W    R0,??gcode_G29_1+0x48
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_54:
        CMP      R11,#+0
        BEQ.N    ??gcode_G29_55
        LDR.W    R0,??gcode_G29_1+0x4C
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_55:
        CMP      R7,#+0
        BEQ.W    ??gcode_G29_0
        LDR.W    R0,??gcode_G29_1+0x50
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
        B.N      ??gcode_G29_0
??gcode_G29_52:
        LDR      R0,[SP, #+20]
        SUBS     R0,R5,R0
        LDR      R1,[SP, #+48]
        SUBS     R1,R1,#+1
        SDIV     R0,R0,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+72]
        LDR      R0,[SP, #+8]
        SUBS     R0,R4,R0
        LDR      R1,[SP, #+16]
        SUBS     R1,R1,#+1
        SDIV     R0,R0,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+28]
??gcode_G29_31:
        LDR      R0,[SP, #+40]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_56
        LDR.W    R0,??gcode_G29_1+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_57
        LDR.W    R0,??gcode_G29_1+0x58
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G29_57:
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_1+0x5C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_56:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_58
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.N      ??gcode_G29_0
??gcode_G29_58:
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_59
        LDR.W    R4,??gcode_G29_1+0x8
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_60
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_60
        LDR      R0,[SP, #+20]
        LDR      R1,[R4, #+24]
        CMP      R0,R1
        BNE.N    ??gcode_G29_60
        LDR      R0,[SP, #+8]
        LDR      R1,[R4, #+28]
        CMP      R0,R1
        BEQ.N    ??gcode_G29_59
??gcode_G29_60:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+16]
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+20]
        LDR      R0,[SP, #+20]
        STR      R0,[R4, #+24]
        LDR      R0,[SP, #+8]
        STR      R0,[R4, #+28]
        MOV      R9,#+0
??gcode_G29_59:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+2
        BNE.N    ??gcode_G29_61
        ADD      R4,SP,#+88
        MOVS     R0,#+0
        STR      R0,[R4, #+32]
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+8]
??gcode_G29_61:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        STRB     R0,[SP, #+5]
        MOVS     R0,#+0
        STR      R0,[SP, #+36]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+12
        TST      R0,R1
        BEQ.W    ??gcode_G29_62
        LDR      R0,[SP, #+16]
        AND      R0,R0,#0x1
        STRB     R0,[SP, #+4]
        MOVS     R0,#+0
        STR      R0,[SP, #+24]
        B.N      ??gcode_G29_63
??gcode_G29_64:
        LDR      R0,[SP, #+48]
        SUBS     R7,R0,#+1
        MOV      R0,#-1
        STR      R0,[SP, #+80]
        STR      R0,[SP, #+76]
??gcode_G29_65:
        LDRB     R0,[SP, #+4]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[SP, #+4]
        SXTB     R7,R7
        B.N      ??gcode_G29_66
??gcode_G29_67:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_68
        LDR      R4,[SP, #+24]
        ADD      R0,R7,R7, LSL #+1
        LDR.W    R1,??gcode_G29_1+0x30
        ADD      R5,R1,R0, LSL #+4
        LDR      R1,[SP, #+36]
        LDR      R0,[SP, #+84]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, R4, LSL #+2]
??gcode_G29_68:
        MOV      R9,#+0
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_G29_69:
        LDR      R0,[SP, #+76]
        ADDS     R7,R0,R7
        SXTB     R7,R7
??gcode_G29_66:
        LDR      R0,[SP, #+80]
        CMP      R7,R0
        BEQ.W    ??gcode_G29_70
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R4,R0
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R11,R0
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R4,R0
        ADD      R0,SP,#+24
        LDRB     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
        MOV      R0,R11
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R4,R1
        BCS.N    ??gcode_G29_71
        MOV      R5,R1
        B.N      ??gcode_G29_72
??gcode_G29_71:
        LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
??gcode_G29_72:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+56]
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_73
        MOV      R5,R1
        B.N      ??gcode_G29_74
??gcode_G29_73:
        LDR.W    R5,??gcode_G29_1+0x60  ;; 0x3fe00000
??gcode_G29_74:
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+52]
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        LSLS     R0,R0,#+29
        BPL.N    ??gcode_G29_75
        ADDS     R6,R6,#+1
        LDR      R0,[SP, #+24]
        ADD      R1,R7,R7, LSL #+1
        ADD      R2,SP,#+232
        ADD      R1,R2,R1, LSL #+4
        STR      R6,[R1, R0, LSL #+2]
??gcode_G29_75:
        LDR.W    R0,??gcode_G29_1
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??gcode_G29_76
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_69
??gcode_G29_76:
          CFI FunCall rand
        BL       rand
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        LDR      R3,[SP, #+40]
        UXTB     R3,R3
        LDRB     R2,[SP, #+5]
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??gcode_G29_77
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G29_70:
        LDR      R0,[SP, #+24]
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        STR      R0,[SP, #+24]
??gcode_G29_63:
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+16]
        CMP      R0,R1
        BGE.W    ??gcode_G29_78
        LDR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.W    ??gcode_G29_78
        LDRB     R0,[SP, #+4]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_64
        MOVS     R7,#+0
        ADD      R0,SP,#+48
        LDRSB    R0,[R0, #+0]
        STR      R0,[SP, #+80]
        MOVS     R0,#+1
        STR      R0,[SP, #+76]
        B.N      ??gcode_G29_65
??gcode_G29_77:
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        LSLS     R1,R0,#+29
        BPL.W    ??gcode_G29_67
        LDR      R1,[SP, #+36]
        MOV      R0,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[SP, #+36]
        LDR      R1,[SP, #+64]
        STR      R0,[R1, R6, LSL #+2]
        LDR      R0,[SP, #+56]
        LDR      R1,[SP, #+44]
        STR      R0,[R1, R6, LSL #+2]
        LDR      R0,[SP, #+44]
        ADD      R0,R0,R6, LSL #+2
        LDR      R1,[SP, #+52]
        LDR      R2,[SP, #+68]
        STR      R1,[R0, R2, LSL #+2]
        MOV      R1,#+1065353216
        LDR      R2,[SP, #+68]
        STR      R1,[R0, R2, LSL #+3]
        ADD      R3,SP,#+36
        ADD      R2,SP,#+52
        ADD      R1,SP,#+56
        ADD      R0,SP,#+172
          CFI FunCall _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        BL       _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        B.N      ??gcode_G29_68
??gcode_G29_62:
        LSLS     R0,R0,#+30
        BPL.W    ??gcode_G29_78
        MOVS     R4,#+0
        B.N      ??gcode_G29_79
??gcode_G29_80:
        LDR      R0,[SP, #+36]
        STR      R0,[R5, #+8]
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??gcode_G29_79:
        CMP      R4,#+3
        BGE.N    ??gcode_G29_81
        ADD      R0,R4,R4, LSL #+1
        LSLS     R0,R0,#+2
        ADD      R1,SP,#+88
        LDR      R1,[R0, R1]
        STR      R1,[SP, #+56]
        ADD      R1,SP,#+88
        ADDS     R5,R0,R1
        LDR      R0,[R5, #+4]
        STR      R0,[SP, #+52]
          CFI FunCall rand
        BL       rand
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        LDR      R3,[SP, #+40]
        UXTB     R3,R3
        LDRB     R2,[SP, #+5]
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??gcode_G29_80
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G29_81:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_78
        LDR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_78
        ADD      R4,SP,#+88
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+856
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+848
        ADD      R1,SP,#+112
        ADD      R0,SP,#+136
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+856
        MOV      R1,SP
        LDM      R0!,{R2,R3}
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+848
        ADD      R1,SP,#+88
        ADD      R0,SP,#+72
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,SP,#+136
        MOV      R2,SP
        LDM      R0!,{R1,R3}
        STM      R2!,{R1,R3}
        LDR      R3,[R0, #0]
        STR      R3,[R2, #+0]
        ADD      R0,SP,#+72
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_35crossES_S_
        BL       _ZN8vector_35crossES_S_
        ADD      R0,SP,#+124
        ADD      R1,SP,#+20
        LDM      R1!,{R2-R4}
        STM      R0!,{R2-R4}
        ADD      R1,SP,#+124
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_310get_normalEv
        BL       _ZN8vector_310get_normalEv
        ADD      R0,SP,#+0
        ADD      R1,SP,#+20
        LDM      R1!,{R2-R4}
        STM      R0!,{R2-R4}
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_82
        LDR.W    R5,??gcode_G29_1+0x64  ;; 0xbf800000
        MOV      R1,R2
        MOV      R0,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+0]
        LDR      R1,[SP, #+4]
        MOV      R0,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+4]
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+8]
??gcode_G29_82:
        ADD      R0,SP,#+0
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+136
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.W    R0,??gcode_G29_1+0x68
        ADD      R1,SP,#+136
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOV      R9,#+0
??gcode_G29_78:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_83
        MOV      R0,R9
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MVN      R0,#-2147483648
        STR      R0,[SP, #+36]
??gcode_G29_83:
        LDR      R0,[SP, #+36]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.W    ??gcode_G29_84
        LDR.W    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_85
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_86
          CFI FunCall _Z30extrapolate_unprobed_bed_levelv
        BL       _Z30extrapolate_unprobed_bed_levelv
??gcode_G29_86:
          CFI FunCall _Z28print_bilinear_leveling_gridv
        BL       _Z28print_bilinear_leveling_gridv
          CFI FunCall _Z17refresh_bed_levelv
        BL       _Z17refresh_bed_levelv
        B.N      ??gcode_G29_87
??gcode_G29_85:
        CMP      R0,#+4
        BNE.W    ??gcode_G29_87
        ADD      R0,SP,#+172
          CFI FunCall _Z22finish_incremental_LSFP15linear_fit_data
        BL       _Z22finish_incremental_LSFP15linear_fit_data
        LDR      R7,[SP, #+216]
        MOV      R11,R7
        EOR      R11,R11,#0x80000000
        LDR      R6,[SP, #+220]
        MOV      R5,R6
        EOR      R5,R5,#0x80000000
        LDR      R10,[SP, #+224]
        EOR      R10,R10,#0x80000000
        LDR      R0,[SP, #+68]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R0,[SP, #+40]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_88
        LDR.W    R0,??gcode_G29_1+0x6C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R4,??gcode_G29_1+0x5C
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        LDR.W    R0,??gcode_G29_1+0x70
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        LDR.W    R0,??gcode_G29_1+0x74
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+40]
        CMP      R0,#+3
        BLT.N    ??gcode_G29_88
        LDR.N    R0,??gcode_G29_1+0x78
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_88:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_89
        MOV      R3,#+1065353216
        MOV      R2,R6
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        ADD      R0,SP,#+0
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+124
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.N    R0,??gcode_G29_1+0x68
        ADD      R1,SP,#+124
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
??gcode_G29_89:
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_87
        LDR.N    R0,??gcode_G29_1+0x7C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R7,??gcode_G29_1+0x80  ;; 0x4479c000
        LDR      R0,[SP, #+16]
        SUB      R11,R0,#+1
        SXTB     R11,R11
        MOV      R10,R11
        B.N      ??gcode_G29_90
??gcode_G29_91:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_1+0x5C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        SUB      R10,R10,#+1
        SXTB     R10,R10
??gcode_G29_90:
        CMP      R10,#+0
        BMI.N    ??gcode_G29_92
        MOVS     R5,#+0
        B.N      ??gcode_G29_93
??gcode_G29_94:
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_95:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R5,R5,#+1
??gcode_G29_93:
        UXTB     R5,R5
        MOV      R0,R5
        LDR      R1,[SP, #+48]
        CMP      R0,R1
        BGE.N    ??gcode_G29_91
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,SP,#+232
        ADD      R0,R0,R1, LSL #+4
        LDR      R4,[R0, R10, LSL #+2]
        LDR      R0,[SP, #+64]
        LDR      R0,[R0, R4, LSL #+2]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        LDR      R0,[SP, #+44]
        LDR      R0,[R0, R4, LSL #+2]
        STR      R0,[SP, #+80]
        LDR      R0,[SP, #+68]
        LDR      R1,[SP, #+44]
        ADD      R1,R1,R4, LSL #+2
        LDR      R0,[R1, R0, LSL #+2]
        STR      R0,[SP, #+76]
        MOVS     R0,#+0
        STR      R0,[SP, #+72]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+76
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+80
        STR      R0,[SP, #+20]
        LDR.N    R1,??gcode_G29_1+0x68
        SUB      SP,SP,#+16
          CFI CFA R13+864
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+848
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[SP, #+64]
        LDR      R0,[R0, R4, LSL #+2]
        LDR      R1,[SP, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_96
        MOV      R7,R0
??gcode_G29_96:
        LDR.N    R4,??gcode_G29_1+0x5C
        MOV      R0,R6
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_94
        LDR.N    R0,??gcode_G29_1+0x84
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_95
??gcode_G29_92:
        LDR.N    R4,??gcode_G29_1+0x5C
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+40]
        CMP      R0,#+4
        BLT.N    ??gcode_G29_87
        LDR.N    R0,??gcode_G29_1+0x88
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R8,R11
        B.N      ??gcode_G29_97
??gcode_G29_98:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        SUB      R8,R8,#+1
        SXTB     R8,R8
??gcode_G29_97:
        CMP      R8,#+0
        BMI.N    ??gcode_G29_99
        MOVS     R5,#+0
        B.N      ??gcode_G29_100
??gcode_G29_101:
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_102:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R5,R5,#+1
??gcode_G29_100:
        UXTB     R5,R5
        MOV      R0,R5
        LDR      R1,[SP, #+48]
        CMP      R0,R1
        BGE.N    ??gcode_G29_98
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,SP,#+232
        ADD      R0,R0,R1, LSL #+4
        LDR      R6,[R0, R8, LSL #+2]
        LDR      R0,[SP, #+44]
        LDR      R0,[R0, R6, LSL #+2]
        STR      R0,[SP, #+80]
        LDR      R0,[SP, #+68]
        LDR      R1,[SP, #+44]
        ADD      R1,R1,R6, LSL #+2
        LDR      R0,[R1, R0, LSL #+2]
        STR      R0,[SP, #+76]
        MOVS     R0,#+0
        STR      R0,[SP, #+72]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+76
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+80
        STR      R0,[SP, #+20]
        LDR.N    R1,??gcode_G29_1+0x68
        SUB      SP,SP,#+16
          CFI CFA R13+864
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+848
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[SP, #+64]
        LDR      R0,[R0, R6, LSL #+2]
        LDR      R1,[SP, #+72]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_101
        LDR.N    R0,??gcode_G29_1+0x84
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_102
??gcode_G29_99:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_87:
        LDR.N    R0,??gcode_G29_1
        LDRB     R0,[R0, #+64]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??gcode_G29_103
        LDR      R0,[SP, #+40]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_104
        LDR.N    R1,??gcode_G29_1+0x8C
        LDR.N    R0,??gcode_G29_1+0x68
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
??gcode_G29_104:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_105
        LDR.N    R4,??gcode_G29_1+0x20
        MOVS     R2,#+12
        ADD      R1,R4,#+8
        ADD      R0,SP,#+0
          CFI FunCall memcpy
        BL       memcpy
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_1+0x14
        STRB     R0,[R1, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_1+0x14
        STRB     R0,[R1, #+0]
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+12]
        LDR      R1,[SP, #+56]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R5,??gcode_G29_1+0x90  ;; 0xb58637bd
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_106
        LDR.N    R6,??gcode_G29_1+0x94  ;; 0x358637be
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_106
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+16]
        LDR      R1,[SP, #+52]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_106
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_106
        LDR      R0,[R4, #+16]
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
??gcode_G29_106:
        MOVS     R2,#+12
        ADD      R1,SP,#+0
        ADD      R0,R4,#+8
          CFI FunCall memcpy
        BL       memcpy
        B.N      ??gcode_G29_105
??gcode_G29_103:
        CMP      R0,#+8
        BNE.N    ??gcode_G29_105
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_105
        LDR.N    R4,??gcode_G29_1+0x20
        ADD      R0,R4,#+8
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R1,R0
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+16]
??gcode_G29_105:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_107
        LDR.N    R0,??gcode_G29_1+0x14
        STRB     R9,[R0, #+0]
        B.N      ??gcode_G29_84
??gcode_G29_107:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_1+0x14
        STRB     R0,[R1, #+0]
??gcode_G29_84:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+6]
        LDR.N    R0,??gcode_G29_1+0x14
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_108
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G29_108:
        LDR      R0,[SP, #+64]
          CFI FunCall free
        BL       free
        LDR      R0,[SP, #+44]
          CFI FunCall free
        BL       free
??gcode_G29_0:
        ADD      SP,SP,#+812
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??gcode_G29_1:
        DC32     mksCfg
        DC32     mksCfg+0x60
        DC32     axis_relative_modes
        DC32     _ZZ9gcode_G29vEs
        DC32     _ZZ9gcode_G29vEs_0
        DC32     _ZN7Planner15leveling_activeE
        DC32     errormagic
        DC32     _ZZ9gcode_G29vEs_1
        DC32     mks_heating_busy
        DC32     0xc1200000
        DC32     0x41200001
        DC32     _ZZ9gcode_G29vEs_2
        DC32     z_values
        DC32     _ZZ9gcode_G29vEs_3
        DC32     _ZZ9gcode_G29vEs_4
        DC32     0x42700000
        DC32     mksTmp
        DC32     _ZZ9gcode_G29vEs_5
        DC32     _ZZ9gcode_G29vEs_6
        DC32     _ZZ9gcode_G29vEs_7
        DC32     _ZZ9gcode_G29vEs_8
        DC32     _ZZ9gcode_G29vEs_9
        DC32     _ZZ9gcode_G29vEs__10_
        DC32     Serial3
        DC32     0x3fe00000
        DC32     0xbf800000
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ9gcode_G29vEs__11_
        DC32     _ZZ9gcode_G29vEs__12_
        DC32     _ZZ9gcode_G29vEs__13_
        DC32     _ZZ9gcode_G29vEs__14_
        DC32     _ZZ9gcode_G29vEs__15_
        DC32     0x4479c000
        DC32     _ZZ9gcode_G29vEs__16_
        DC32     _ZZ9gcode_G29vEs__17_
        DC32     _ZZ9gcode_G29vEs__18_
        DC32     0xb58637bd
        DC32     0x358637be
          CFI EndBlock cfiBlock258

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G30v
          CFI Block cfiBlock259 Using cfiCommon0
          CFI Function _Z9gcode_G30v
        THUMB
_Z9gcode_G30v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
        LDR.N    R4,??gcode_G30_0
        ADD      R5,R4,#+64
        LDR.N    R6,??gcode_G30_0+0x4
        LDR      R1,[R6, #+8]
        LDR      R0,[R5, #+44]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        STR      R0,[SP, #+8]
        LDR      R1,[R6, #+12]
        LDR      R0,[R5, #+48]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        STR      R0,[SP, #+4]
        LDRH     R0,[R5, #+24]
        MOVW     R1,#+770
        TST      R0,R1
        BEQ.N    ??gcode_G30_1
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_2
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G30_2
??gcode_G30_1:
        LDRB     R0,[R4, #+64]
        MOVS     R1,#+62
        TST      R0,R1
        BEQ.N    ??gcode_G30_3
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G30_3:
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOVS     R1,#+1
        STR      R1,[SP, #+0]
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
        MOV      R6,R0
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G30_4
        LDR.N    R4,??gcode_G30_0+0x8  ;; 0x88e368f1
        LDR.N    R5,??gcode_G30_0+0xC  ;; 0x3ee4f8b5
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x10
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x14
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_G30_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G30_0+0x1C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G30_4:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_G30_2:
        POP      {R0-R6,PC}       ;; return
        DATA
??gcode_G30_0:
        DC32     mksCfg
        DC32     mks_heating_busy
        DC32     0x88e368f1
        DC32     0x3ee4f8b5
        DC32     _ZZ9gcode_G30vEs
        DC32     _ZZ9gcode_G30vEs_0
        DC32     _ZZ9gcode_G30vEs_1
        DC32     Serial3
          CFI EndBlock cfiBlock259

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G42v
          CFI Block cfiBlock260 Using cfiCommon0
          CFI Function _Z9gcode_G42v
        THUMB
_Z9gcode_G42v:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
          CFI FunCall _Z9IsRunningv
        BL       _Z9IsRunningv
        CMP      R0,#+0
        BEQ.W    ??gcode_G42_0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        MOVS     R4,R0
        BEQ.N    ??gcode_G42_1
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R5,R0
        SXTB     R5,R5
        B.N      ??gcode_G42_2
??gcode_G42_1:
        MOVS     R5,#+0
??gcode_G42_2:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        MOVS     R6,R0
        BEQ.N    ??gcode_G42_3
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R7,R0
        SXTB     R7,R7
        B.N      ??gcode_G42_4
??gcode_G42_3:
        MOVS     R7,#+0
??gcode_G42_4:
        LDR.W    R8,??gcode_G42_5
        CMP      R4,#+0
        BEQ.N    ??gcode_G42_6
        CMP      R5,#+0
        BMI.N    ??gcode_G42_7
        LDRB     R0,[R8, #+96]
        SUBS     R0,R0,#+1
        CMP      R0,R5
        BLT.N    ??gcode_G42_7
??gcode_G42_6:
        CMP      R6,#+0
        BEQ.N    ??gcode_G42_8
        CMP      R7,#+0
        BMI.N    ??gcode_G42_7
        ADD      R0,R8,#+96
        LDRB     R0,[R0, #+1]
        SUBS     R0,R0,#+1
        CMP      R0,R7
        BGE.N    ??gcode_G42_8
??gcode_G42_7:
        LDR.N    R0,??gcode_G42_5+0x4
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_8:
          CFI FunCall _Z28set_destination_from_currentv
        BL       _Z28set_destination_from_currentv
        LDR.W    R9,??gcode_G42_5+0x8
        CMP      R4,#+0
        BEQ.N    ??gcode_G42_9
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G42_10
        LDR.N    R0,??gcode_G42_5+0xC
        LDR      R1,[R0, #+24]
        LDR      R0,[R0, #+16]
        MLA      R0,R0,R5,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R9, #+24]
??gcode_G42_10:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_G42_11
        MOV      R0,R5
        UXTB     R0,R0
          CFI FunCall _ZN20unified_bed_leveling18mesh_index_to_xposEh
        BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
        STR      R0,[R9, #+24]
??gcode_G42_11:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+26
        BPL.N    ??gcode_G42_9
        LDR.N    R0,??gcode_G42_5+0x10
        LDR      R0,[R0, R5, LSL #+2]
        STR      R0,[R9, #+24]
??gcode_G42_9:
        CMP      R6,#+0
        BEQ.N    ??gcode_G42_12
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G42_13
        LDR.N    R0,??gcode_G42_5+0xC
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+20]
        MLA      R0,R0,R7,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R9, #+28]
??gcode_G42_13:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_G42_14
        MOV      R0,R7
        UXTB     R0,R0
          CFI FunCall _ZN20unified_bed_leveling18mesh_index_to_yposEh
        BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
        STR      R0,[R9, #+28]
??gcode_G42_14:
        LDRB     R0,[R8, #+64]
        LSLS     R0,R0,#+26
        BPL.N    ??gcode_G42_12
        LDR.N    R0,??gcode_G42_5+0x14
        LDR      R0,[R0, R7, LSL #+2]
        STR      R0,[R9, #+28]
??gcode_G42_12:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G42_15
        CMP      R4,#+0
        BEQ.N    ??gcode_G42_16
        LDR      R0,[R9, #+24]
        ADD      R1,R8,#+96
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+24]
??gcode_G42_16:
        CMP      R6,#+0
        BEQ.N    ??gcode_G42_15
        LDR      R0,[R9, #+28]
        ADD      R1,R8,#+96
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+28]
??gcode_G42_15:
        MOVS     R1,#+0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_G42_17
        LDR.N    R1,??gcode_G42_5+0x18  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R9, #+92]
??gcode_G42_17:
        LDRH     R0,[R8, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G42_18
        MOVS     R0,#+0
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.W      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_18:
        POP      {R0,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z27prepare_move_to_destinationv
        B.W      _Z27prepare_move_to_destinationv
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_0:
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_G42_5:
        DC32     mksCfg
        DC32     _ZZ9gcode_G42vEs
        DC32     mks_heating_busy
        DC32     axis_relative_modes
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     0x42700000
          CFI EndBlock cfiBlock260

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G92v
          CFI Block cfiBlock261 Using cfiCommon0
          CFI Function _Z9gcode_G92v
        THUMB
_Z9gcode_G92v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOVS     R5,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R4,R0
        BNE.N    ??gcode_G92_0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_G92_0:
        MOV      R6,R5
        B.N      ??gcode_G92_1
??gcode_G92_2:
        LDR      R8,[R7, #+8]
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        STR      R0,[R7, #+8]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_3
        MOVS     R5,#+1
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R7, #+96]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+96]
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??gcode_G92_3:
        ADDS     R6,R6,#+1
??gcode_G92_1:
        CMP      R6,#+4
        BGE.N    ??gcode_G92_4
        LDR.N    R0,??gcode_G92_5
        LDRSB    R0,[R6, R0]
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_G92_3
        LDR.N    R0,??gcode_G92_5+0x4
        ADD      R7,R0,R6, LSL #+2
        LDR.N    R0,??gcode_G92_5+0x8
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G92_2
        MOV      R0,R6
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        STR      R0,[R7, #+8]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_3
        MOVS     R5,#+1
        B.N      ??gcode_G92_3
??gcode_G92_4:
        CMP      R5,#+0
        BEQ.N    ??gcode_G92_6
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??gcode_G92_7
??gcode_G92_6:
        CMP      R4,#+0
        BEQ.N    ??gcode_G92_7
          CFI FunCall _Z20sync_plan_position_ev
        BL       _Z20sync_plan_position_ev
??gcode_G92_7:
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        DATA
??gcode_G92_5:
        DC32     axis_codes
        DC32     mks_heating_busy
        DC32     mksCfg
          CFI EndBlock cfiBlock261

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M17v
          CFI Block cfiBlock262 Using cfiCommon0
          CFI Function _Z9gcode_M17v
        THUMB
_Z9gcode_M17v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M17_0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19enable_all_steppersv
        B.W      _Z19enable_all_steppersv
        Nop      
        DATA
??gcode_M17_0:
        DC32     _ZZ9gcode_M17vEs
          CFI EndBlock cfiBlock262

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M20v
          CFI Block cfiBlock263 Using cfiCommon0
          CFI Function _Z9gcode_M20v
        THUMB
_Z9gcode_M20v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M20_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M20_0+0x4
          CFI FunCall _ZN10CardReader2lsEv
        BL       _ZN10CardReader2lsEv
        LDR.N    R0,??gcode_M20_0+0x8
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        DATA
??gcode_M20_0:
        DC32     _ZZ9gcode_M20vEs
        DC32     card
        DC32     _ZZ9gcode_M20vEs_0
          CFI EndBlock cfiBlock263

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M22v
          CFI Block cfiBlock264 Using cfiCommon0
          CFI Function _Z9gcode_M22v
        THUMB
_Z9gcode_M22v:
        LDR.N    R0,??gcode_M22_0
          CFI FunCall _ZN10CardReader7releaseEv
        B.W      _ZN10CardReader7releaseEv
        Nop      
        DATA
??gcode_M22_0:
        DC32     card
          CFI EndBlock cfiBlock264

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M23v
          CFI Block cfiBlock265 Using cfiCommon0
          CFI Function _Z9gcode_M23v
        THUMB
_Z9gcode_M23v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M23_0
        LDR      R1,[R0, #+0]
        B.N      ??gcode_M23_1
??gcode_M23_2:
        CMP      R2,#+32
        BNE.N    ??gcode_M23_3
        MOVS     R2,#+0
        STRB     R2,[R1, #+0]
??gcode_M23_3:
        ADDS     R1,R1,#+1
??gcode_M23_1:
        LDRSB    R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??gcode_M23_2
        LDR.N    R4,??gcode_M23_0+0x4
        MOVS     R3,#+1
        MOV      R2,R3
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        ADDW     R1,R4,#+2516
        LDR.N    R0,??gcode_M23_0+0x8
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall strcpy
        B.W      strcpy
        Nop      
        DATA
??gcode_M23_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
        DC32     curFileName
          CFI EndBlock cfiBlock265

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M24v
          CFI Block cfiBlock266 Using cfiCommon0
          CFI Function _Z9gcode_M24v
        THUMB
_Z9gcode_M24v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
          CFI FunCall mks_resumePrint
        BL       mks_resumePrint
        LDR.N    R4,??gcode_M24_0
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+171
        BEQ.N    ??gcode_M24_1
        CMP      R0,#+172
        BEQ.N    ??gcode_M24_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        ADDW     R0,R4,#+3436
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M24_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M24_0:
        DC32     card
          CFI EndBlock cfiBlock266

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M25v
          CFI Block cfiBlock267 Using cfiCommon0
          CFI Function _Z9gcode_M25v
        THUMB
_Z9gcode_M25v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M25_0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
        ADDW     R0,R4,#+3436
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+169
        STRB     R0,[R4, #+2720]
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M25_0:
        DC32     card
          CFI EndBlock cfiBlock267

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M998v
          CFI Block cfiBlock268 Using cfiCommon0
          CFI Function _Z10gcode_M998v
        THUMB
_Z10gcode_M998v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M998_0
        LDRB     R0,[R4, #+2720]
        CMP      R0,#+172
        BEQ.N    ??gcode_M998_1
        MOVS     R0,#+166
        STRB     R0,[R4, #+2720]
        LDR.N    R0,??gcode_M998_0+0x4
        LDRB     R0,[R0, #+415]
        CMP      R0,#+1
        BEQ.N    ??gcode_M998_2
        MOVS     R2,#+1
        ADD      R1,R4,#+2720
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??gcode_M998_2:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader11stopSDPrintEv
        BL       _ZN10CardReader11stopSDPrintEv
          CFI FunCall _Z19clear_command_queuev
        BL       _Z19clear_command_queuev
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        ADDW     R0,R4,#+3436
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        B.N      ??gcode_M998_3
??gcode_M998_4:
        MOVS     R0,#+0
        STR      R0,[R1, #+108]
        LDR.N    R1,??gcode_M998_0+0x8  ;; 0x40000440
        STR      R0,[R1, #+0]
        MOVS     R0,#+1
??gcode_M998_3:
        LDR.N    R1,??gcode_M998_0+0xC
        CMP      R0,#+0
        BEQ.N    ??gcode_M998_4
        MOVS     R0,#+0
        STRB     R0,[R1, #+4]
??gcode_M998_1:
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M998_0:
        DC32     card
        DC32     gCfgItems
        DC32     0x40000440
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock268

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M26v
          CFI Block cfiBlock269 Using cfiCommon0
          CFI Function _Z9gcode_M26v
        THUMB
_Z9gcode_M26v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M26_0
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M26_1
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader8setIndexEl
        B.W      _ZN10CardReader8setIndexEl
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M26_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M26_0:
        DC32     card
          CFI EndBlock cfiBlock269

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M27v
          CFI Block cfiBlock270 Using cfiCommon0
          CFI Function _Z9gcode_M27v
        THUMB
_Z9gcode_M27v:
        LDR.N    R0,??gcode_M27_0
          CFI FunCall _ZN10CardReader9getStatusEv
        B.W      _ZN10CardReader9getStatusEv
        Nop      
        DATA
??gcode_M27_0:
        DC32     card
          CFI EndBlock cfiBlock270

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M28v
          CFI Block cfiBlock271 Using cfiCommon0
          CFI Function _Z9gcode_M28v
        THUMB
_Z9gcode_M28v:
        MOVS     R3,#+1
        MOVS     R2,#+0
        LDR.N    R0,??gcode_M28_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M28_0+0x4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        B.W      _ZN10CardReader8openFileEPcbb
        Nop      
        DATA
??gcode_M28_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock271

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z9gcode_M29v
          CFI Block cfiBlock272 Using cfiCommon0
          CFI Function _Z9gcode_M29v
          CFI NoCalls
        THUMB
_Z9gcode_M29v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock272

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M30v
          CFI Block cfiBlock273 Using cfiCommon0
          CFI Function _Z9gcode_M30v
        THUMB
_Z9gcode_M30v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M30_0
        LDRB     R0,[R4, #+2491]
        CMP      R0,#+0
        BEQ.N    ??gcode_M30_1
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        LDR.N    R0,??gcode_M30_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10CardReader10removeFileEPc
        B.W      _ZN10CardReader10removeFileEPc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M30_1:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M30_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock273

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M31v
          CFI Block cfiBlock274 Using cfiCommon0
          CFI Function _Z9gcode_M31v
        THUMB
_Z9gcode_M31v:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        SUB      SP,SP,#+36
          CFI CFA R13+40
        LDR.N    R0,??gcode_M31_0
          CFI FunCall _ZN9Stopwatch8durationEv
        BL       _ZN9Stopwatch8durationEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _ZN10duration_tC1ERKj
        BL       _ZN10duration_tC1ERKj
        ADD      R1,SP,#+8
          CFI FunCall _ZNK10duration_t8toStringEPc
        BL       _ZNK10duration_t8toStringEPc
        MOVS     R1,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z13lcd_setstatusPKcb
        BL       _Z13lcd_setstatusPKcb
        LDR.N    R0,??gcode_M31_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      R1,SP,#+8
        LDR.N    R0,??gcode_M31_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M31_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      SP,SP,#+36
          CFI CFA R13+4
        POP      {PC}             ;; return
        DATA
??gcode_M31_0:
        DC32     card+0xD6C
        DC32     echomagic
        DC32     _ZZ9gcode_M31vEs
        DC32     Serial3
          CFI EndBlock cfiBlock274

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M32v
          CFI Block cfiBlock275 Using cfiCommon0
          CFI Function _Z9gcode_M32v
        THUMB
_Z9gcode_M32v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M32_0
        LDRB     R0,[R4, #+2488]
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_1
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_M32_1:
        ADDW     R0,R4,#+2488
        LDRB     R1,[R0, #+3]
        LDRB     R0,[R0, #+4]
        ORRS     R0,R0,R1
        BEQ.N    ??gcode_M32_2
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R5,R0
        MOV      R3,R5
        MOVS     R2,#+1
        LDR.N    R0,??gcode_M32_0+0x4
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M32_3
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8setIndexEl
        BL       _ZN10CardReader8setIndexEl
??gcode_M32_3:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        CMP      R5,#+0
        BNE.N    ??gcode_M32_2
        ADDW     R0,R4,#+3436
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M32_2:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M32_0:
        DC32     card
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock275

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M928v
          CFI Block cfiBlock276 Using cfiCommon0
          CFI Function _Z10gcode_M928v
        THUMB
_Z10gcode_M928v:
        LDR.N    R0,??gcode_M928_0
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M928_0+0x4
          CFI FunCall _ZN10CardReader11openLogFileEPc
        B.W      _ZN10CardReader11openLogFileEPc
        Nop      
        DATA
??gcode_M928_0:
        DC32     _ZN11GCodeParser10string_argE
        DC32     card
          CFI EndBlock cfiBlock276

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M42v
          CFI Block cfiBlock277 Using cfiCommon0
          CFI Function _Z9gcode_M42v
        THUMB
_Z9gcode_M42v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOVS     R5,R0
        BMI.N    ??gcode_M42_0
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BEQ.N    ??gcode_M42_1
        LDR.N    R0,??gcode_M42_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M42_2+0x4
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M42_1:
        CMP      R5,#+0
        MOV      R2,R4
        SXTB     R2,R2
        BMI.N    ??gcode_M42_3
        LDR.N    R0,??gcode_M42_2+0x8
        LDRH     R1,[R0, R5, LSL #+1]
        LDR.N    R0,??gcode_M42_2+0xC
        LDR      R0,[R0, R5, LSL #+2]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        B.N      ??gcode_M42_4
??gcode_M42_3:
        MOVS     R1,#+0
        MOV      R0,R1
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
??gcode_M42_4:
        CMP      R5,#+17
        BNE.N    ??gcode_M42_0
        LDR.N    R0,??gcode_M42_2+0x10
        STR      R4,[R0, #+108]
??gcode_M42_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M42_2:
        DC32     errormagic
        DC32     _ZZ9gcode_M42vEs
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock277

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M49v
          CFI Block cfiBlock278 Using cfiCommon0
          CFI Function _Z9gcode_M49v
        THUMB
_Z9gcode_M49v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M49_0
        LDRB     R0,[R4, #+0]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[R4, #+0]
        LDR.N    R0,??gcode_M49_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M49_1
        LDR.N    R0,??gcode_M49_0+0x8
        B.N      ??gcode_M49_2
??gcode_M49_1:
        LDR.N    R0,??gcode_M49_0+0xC
??gcode_M49_2:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M49_0:
        DC32     g26_debug_flag
        DC32     _ZZ9gcode_M49vEs
        DC32     _ZZ9gcode_M49vEs_0
        DC32     _ZZ9gcode_M49vEs_1
          CFI EndBlock cfiBlock278

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M75v
          CFI Block cfiBlock279 Using cfiCommon0
          CFI Function _Z9gcode_M75v
        THUMB
_Z9gcode_M75v:
        LDR.N    R0,??gcode_M75_0
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
        Nop      
        DATA
??gcode_M75_0:
        DC32     card+0xD6C
          CFI EndBlock cfiBlock279

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M76v
          CFI Block cfiBlock280 Using cfiCommon0
          CFI Function _Z9gcode_M76v
        THUMB
_Z9gcode_M76v:
        LDR.N    R0,??gcode_M76_0
          CFI FunCall _ZN9Stopwatch5pauseEv
        B.W      _ZN9Stopwatch5pauseEv
        Nop      
        DATA
??gcode_M76_0:
        DC32     card+0xD6C
          CFI EndBlock cfiBlock280

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M77v
          CFI Block cfiBlock281 Using cfiCommon0
          CFI Function _Z9gcode_M77v
        THUMB
_Z9gcode_M77v:
        LDR.N    R0,??gcode_M77_0
          CFI FunCall _ZN9Stopwatch4stopEv
        B.W      _ZN9Stopwatch4stopEv
        Nop      
        DATA
??gcode_M77_0:
        DC32     card+0xD6C
          CFI EndBlock cfiBlock281

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M104v
          CFI Block cfiBlock282 Using cfiCommon0
          CFI Function _Z10gcode_M104v
        THUMB
_Z10gcode_M104v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+104
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M104_1
        LDR.N    R4,??gcode_M104_2
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M104_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M104_3
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDRB     R1,[R4, #+5]
        MOV      R5,R1
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M104_2+0x4
        LDR      R1,[R0, #+44]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M104_4
        LDR.N    R0,??gcode_M104_2+0x8
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_4:
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R5,R0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M104_3
        LDRB     R0,[R4, #+5]
        CMP      R0,#+4
        BHI.N    ??gcode_M104_3
        TBB      [PC, R0]
        DATA
??gcode_M104_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M104_5:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x10
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_6:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M104_3
??gcode_M104_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M104_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M104_3:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        B.W      _ZN7Planner18autotemp_M104_M109Ev
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M104_1:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M104_2:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     card+0xD6C
        DC32     _ZZ10gcode_M104vEs
        DC32     _ZZ10gcode_M104vEs_0
        DC32     _ZZ10gcode_M104vEs_1
        DC32     _ZZ10gcode_M104vEs_2
        DC32     _ZZ10gcode_M104vEs_3
        DC32     _ZZ10gcode_M104vEs_4
          CFI EndBlock cfiBlock282

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M105v
          CFI Block cfiBlock283 Using cfiCommon0
          CFI Function _Z10gcode_M105v
        THUMB
_Z10gcode_M105v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+105
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M105_0
        LDR.N    R0,??gcode_M105_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M105_1+0x4
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M105_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M105_1:
        DC32     _ZZ10gcode_M105vEs
        DC32     Serial3
          CFI EndBlock cfiBlock283

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M155v
          CFI Block cfiBlock284 Using cfiCommon0
          CFI Function _Z10gcode_M155v
        THUMB
_Z10gcode_M155v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M155_0
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R1,R0
        LDR.N    R0,??gcode_M155_1
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature24set_auto_report_intervalEh
        B.W      _ZN11Temperature24set_auto_report_intervalEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M155_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M155_1:
        DC32     thermalManager
          CFI EndBlock cfiBlock284

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M106v
          CFI Block cfiBlock285 Using cfiCommon0
          CFI Function _Z10gcode_M106v
        THUMB
_Z10gcode_M106v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+0
        BNE.N    ??gcode_M106_0
        MOVS     R1,#+255
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        MOVS     R1,#+255
        CMP      R0,#+255
        BGT.N    ??gcode_M106_1
        MOV      R1,R0
??gcode_M106_1:
        LDR.N    R2,??gcode_M106_2
        STR      R1,[R2, #+108]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.N    R1,??gcode_M106_2+0x4  ;; 0x40000440
        STR      R0,[R1, #+0]
??gcode_M106_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M106_2:
        DC32     mks_heating_busy
        DC32     0x40000440
          CFI EndBlock cfiBlock285

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M107v
          CFI Block cfiBlock286 Using cfiCommon0
          CFI Function _Z10gcode_M107v
        THUMB
_Z10gcode_M107v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser9ushortvalEct
        BL       _ZN11GCodeParser9ushortvalEct
        CMP      R0,#+0
        BNE.N    ??gcode_M107_0
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M107_1
        STR      R0,[R1, #+108]
        LDR.N    R1,??gcode_M107_1+0x4  ;; 0x40000440
        STR      R0,[R1, #+0]
??gcode_M107_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M107_1:
        DC32     mks_heating_busy
        DC32     0x40000440
          CFI EndBlock cfiBlock286

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M108v
          CFI Block cfiBlock287 Using cfiCommon0
          CFI Function _Z10gcode_M108v
          CFI NoCalls
        THUMB
_Z10gcode_M108v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M108_0
        STRB     R0,[R1, #+4]
        BX       LR               ;; return
        DATA
??gcode_M108_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock287

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M112v
          CFI Block cfiBlock288 Using cfiCommon0
          CFI Function _Z10gcode_M112v
        THUMB
_Z10gcode_M112v:
        LDR.N    R0,??gcode_M112_0
          CFI FunCall _Z4killPKc
        B.W      _Z4killPKc
        Nop      
        DATA
??gcode_M112_0:
        DC32     _ZZ10gcode_M112vEs
          CFI EndBlock cfiBlock288

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M410v
          CFI Block cfiBlock289 Using cfiCommon0
          CFI Function _Z10gcode_M410v
          CFI FunCall _Z17quickstop_stepperv
        THUMB
_Z10gcode_M410v:
        B.W      _Z17quickstop_stepperv
          CFI EndBlock cfiBlock289

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M109v
          CFI Block cfiBlock290 Using cfiCommon0
          CFI Function _Z10gcode_M109v
        THUMB
_Z10gcode_M109v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        MOVS     R0,#+109
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??gcode_M109_1
        LDR.N    R4,??gcode_M109_2
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M109_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        STR      R0,[SP, #+4]
        CMP      R0,#+0
        BNE.N    ??gcode_M109_3
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M109_1
??gcode_M109_3:
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDRB     R1,[R4, #+5]
        MOV      R5,R1
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _ZN11Temperature15setTargetHotendEfh
        BL       _ZN11Temperature15setTargetHotendEfh
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R5,R0
        LDR.N    R6,??gcode_M109_2+0x4
        LDR.N    R0,??gcode_M109_2+0x8
        LDR      R1,[R0, #+44]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        MOV      R0,R6
        BHI.N    ??gcode_M109_4
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0xC
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_5
??gcode_M109_4:
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M109_5:
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R5,R0
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_6
        LDRB     R0,[R4, #+5]
        CMP      R0,#+4
        BHI.N    ??gcode_M109_6
        TBB      [PC, R0]
        DATA
??gcode_M109_0:
        DC8      0x3,0x8,0xD,0x12
        DC8      0x17,0x0
        THUMB
??gcode_M109_7:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x10
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_8:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x14
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_9:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x18
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_10:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        B.N      ??gcode_M109_6
??gcode_M109_11:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x20
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M109_6:
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        BL       _ZN7Planner18autotemp_M104_M109Ev
        MOVS     R5,#+0
        LDR.W    R8,??gcode_M109_2+0x24  ;; 0xbf800000
        LDR.N    R6,??gcode_M109_2+0x28  ;; 0x461c3c00
        MOV      R7,R5
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
        MOV      R0,R5
        STR      R0,[SP, #+0]
        MOV      R9,R0
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        BL       _ZN11Temperature21start_watching_heaterEh
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
??gcode_M109_12:
        LDRB     R10,[R4, #+5]
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M109_13
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15isCoolingHotendEh
        BL       _ZN11Temperature15isCoolingHotendEh
        MOV      R7,R0
        MOV      R0,R10
          CFI FunCall _ZN11Temperature15degTargetHotendEh
        BL       _ZN11Temperature15degTargetHotendEh
        MOV      R8,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R7
        UXTB     R0,R0
        TST      R0,R1
        BNE.N    ??gcode_M109_14
??gcode_M109_13:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        SUBS     R0,R10,R0
        BMI.N    ??gcode_M109_15
        ADD      R0,R10,#+1000
        STR      R0,[SP, #+0]
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.N    R0,??gcode_M109_2+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R11,??gcode_M109_2+0x30
        CMP      R5,#+0
        BEQ.N    ??gcode_M109_16
        MOVS     R2,#+10
        MOVW     R0,#+10000
        SUB      R0,R0,R10
        ADDS     R0,R5,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M109_17
??gcode_M109_16:
        MOVS     R1,#+63
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_17:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_15:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
        LDRB     R0,[R4, #+5]
          CFI FunCall _ZN11Temperature9degHotendEh
        BL       _ZN11Temperature9degHotendEh
        MOV      R11,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CMP      R5,#+0
        BNE.N    ??gcode_M109_18
        MOV      R1,#+1065353216
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_19
        MOV      R5,R10
        B.N      ??gcode_M109_19
??gcode_M109_18:
        LDR.N    R1,??gcode_M109_2+0x34  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M109_19
        MOV      R5,R10
??gcode_M109_19:
        CMP      R7,#+0
        BEQ.N    ??gcode_M109_20
        CMP      R9,#+0
        BEQ.N    ??gcode_M109_21
        SUBS     R0,R10,R9
        BMI.N    ??gcode_M109_20
??gcode_M109_21:
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M109_14
        ADD      R9,R10,#+59904
        ADD      R9,R9,#+96
        MOV      R6,R11
??gcode_M109_20:
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_14
        CMP      R5,#+0
        BEQ.N    ??gcode_M109_12
        SUB      R0,R10,R5
        LDR.N    R1,??gcode_M109_2+0x38  ;; 0xffffd8f0
        ADDS     R0,R1,R0
        BMI.N    ??gcode_M109_12
??gcode_M109_14:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M109_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M109_2+0x3C
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        B.W      _Z16lcd_setstatusPGMPKca
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M109_1:
        POP      {R0-R2,R4-R11,PC}  ;; return
        DATA
??gcode_M109_2:
        DC32     mks_heating_busy
        DC32     card+0xD6C
        DC32     mksCfg
        DC32     _ZZ10gcode_M109vEs
        DC32     _ZZ10gcode_M109vEs_0
        DC32     _ZZ10gcode_M109vEs_1
        DC32     _ZZ10gcode_M109vEs_2
        DC32     _ZZ10gcode_M109vEs_3
        DC32     _ZZ10gcode_M109vEs_4
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     _ZZ10gcode_M109vEs_5
        DC32     Serial3
        DC32     0x40000001
        DC32     0xffffd8f0
        DC32     _ZZ10gcode_M109vEs_6
          CFI EndBlock cfiBlock290

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M190v
          CFI Block cfiBlock291 Using cfiCommon0
          CFI Function _Z10gcode_M190v
        THUMB
_Z10gcode_M190v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        LDR.N    R4,??gcode_M190_0
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M190_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M190_0+0x4
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        STR      R0,[SP, #+4]
        CMP      R0,#+0
        BNE.N    ??gcode_M190_2
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M190_1
??gcode_M190_2:
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall _ZN11Temperature12setTargetBedEf
        BL       _ZN11Temperature12setTargetBedEf
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        LDR.N    R1,??gcode_M190_0+0x8  ;; 0x40a00001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M190_3
        LDR.N    R0,??gcode_M190_0+0xC
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M190_3:
        MOVS     R5,#+0
        LDR.W    R8,??gcode_M190_0+0x10  ;; 0xbf800000
        LDR.N    R6,??gcode_M190_0+0x14  ;; 0x461c3c00
        MOV      R7,R5
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
        MOV      R0,R5
        STR      R0,[SP, #+0]
        MOV      R9,R0
        LDRB     R0,[R4, #+3]
        STRB     R0,[R4, #+5]
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
??gcode_M190_4:
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M190_5
          CFI FunCall _ZN11Temperature12isCoolingBedEv
        BL       _ZN11Temperature12isCoolingBedEv
        MOV      R7,R0
          CFI FunCall _ZN11Temperature12degTargetBedEv
        BL       _ZN11Temperature12degTargetBedEv
        MOV      R8,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R7
        UXTB     R0,R0
        TST      R0,R1
        BNE.N    ??gcode_M190_6
??gcode_M190_5:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        SUBS     R0,R10,R0
        BMI.N    ??gcode_M190_7
        ADD      R0,R10,#+1000
        STR      R0,[SP, #+0]
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.N    R0,??gcode_M190_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R11,??gcode_M190_0+0x1C
        CMP      R5,#+0
        BEQ.N    ??gcode_M190_8
        MOVS     R2,#+10
        MOVW     R0,#+10000
        SUB      R0,R0,R10
        ADDS     R0,R5,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M190_9
??gcode_M190_8:
        MOVS     R1,#+63
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_9:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_7:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall _Z19refresh_cmd_timeoutv
        BL       _Z19refresh_cmd_timeoutv
          CFI FunCall _ZN11Temperature6degBedEv
        BL       _ZN11Temperature6degBedEv
        MOV      R11,R0
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CMP      R5,#+0
        BNE.N    ??gcode_M190_10
        MOV      R1,#+1065353216
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M190_11
        MOV      R5,R10
        B.N      ??gcode_M190_11
??gcode_M190_10:
        LDR.N    R1,??gcode_M190_0+0x20  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M190_11
        MOV      R5,R10
??gcode_M190_11:
        CMP      R7,#+0
        BEQ.N    ??gcode_M190_12
        CMP      R9,#+0
        BEQ.N    ??gcode_M190_13
        SUBS     R0,R10,R9
        BMI.N    ??gcode_M190_12
??gcode_M190_13:
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M190_6
        ADD      R9,R10,#+59904
        ADD      R9,R9,#+96
        MOV      R6,R11
??gcode_M190_12:
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_6
        CMP      R5,#+0
        BEQ.N    ??gcode_M190_4
        SUB      R0,R10,R5
        LDR.N    R1,??gcode_M190_0+0x24  ;; 0xffffd8f0
        ADDS     R0,R1,R0
        BMI.N    ??gcode_M190_4
??gcode_M190_6:
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_1
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M190_0+0x28
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16lcd_setstatusPGMPKca
        B.W      _Z16lcd_setstatusPGMPKca
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M190_1:
        POP      {R0-R2,R4-R11,PC}  ;; return
        Nop      
        DATA
??gcode_M190_0:
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M190vEs
        DC32     0x40a00001
        DC32     card+0xD6C
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     _ZZ10gcode_M190vEs_0
        DC32     Serial3
        DC32     0x40000001
        DC32     0xffffd8f0
        DC32     _ZZ10gcode_M190vEs_1
          CFI EndBlock cfiBlock291

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M110v
          CFI Block cfiBlock292 Using cfiCommon0
          CFI Function _Z10gcode_M110v
        THUMB
_Z10gcode_M110v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+78
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M110_0
          CFI FunCall _ZN11GCodeParser10value_longEv
        BL       _ZN11GCodeParser10value_longEv
        LDR.N    R1,??gcode_M110_1
        STR      R0,[R1, #+44]
??gcode_M110_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M110_1:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock292

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M111v
          CFI Block cfiBlock293 Using cfiCommon0
          CFI Function _Z10gcode_M111v
        THUMB
_Z10gcode_M111v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M111_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_1
        MOVS     R1,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        STRB     R0,[R4, #+1]
??gcode_M111_1:
        LDR.N    R0,??gcode_M111_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M111_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+1]
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_2
        MOVS     R6,#+0
        MOV      R5,R6
??gcode_M111_3:
        CMP      R5,#+5
        BCS.N    ??gcode_M111_4
        LDRB     R0,[R4, #+1]
        MOVS     R1,#+1
        LSLS     R1,R1,R5
        TST      R0,R1
        BEQ.N    ??gcode_M111_5
        MOV      R0,R6
        ADDS     R6,R0,#+1
        UXTB     R0,R0
        CMP      R0,#+0
        BEQ.N    ??gcode_M111_6
        MOVS     R1,#+44
        LDR.N    R0,??gcode_M111_0+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M111_6:
        LDR.N    R0,??gcode_M111_0+0x10
        ADD      R0,R0,R5, LSL #+2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_5:
        ADDS     R5,R5,#+1
        B.N      ??gcode_M111_3
??gcode_M111_2:
        LDR.N    R0,??gcode_M111_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M111_4:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M111_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M111_0:
        DC32     mks_heating_busy
        DC32     echomagic
        DC32     _ZZ10gcode_M111vEs_4
        DC32     Serial3
        DC32     _ZZ10gcode_M111vE13debug_strings
        DC32     _ZZ10gcode_M111vEs_5
          CFI EndBlock cfiBlock293

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M113v
          CFI Block cfiBlock294 Using cfiCommon0
          CFI Function _Z10gcode_M113v
        THUMB
_Z10gcode_M113v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??gcode_M113_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M113_1
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        STRB     R0,[R4, #+7]
        CMP      R0,#+61
        BLT.N    ??gcode_M113_2
        MOVS     R0,#+60
        STRB     R0,[R4, #+7]
        POP      {R4,PC}
??gcode_M113_1:
        LDR.N    R0,??gcode_M113_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R1,[R4, #+7]
        LDR.N    R0,??gcode_M113_0+0x8
          CFI FunCall _Z17serial_echopair_PPKcm
        BL       _Z17serial_echopair_PPKcm
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M113_0+0xC
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M113_2:
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??gcode_M113_0:
        DC32     axis_relative_modes
        DC32     echomagic
        DC32     _ZZ10gcode_M113vEs
        DC32     Serial3
          CFI EndBlock cfiBlock294

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M140v
          CFI Block cfiBlock295 Using cfiCommon0
          CFI Function _Z10gcode_M140v
        THUMB
_Z10gcode_M140v:
        LDR.N    R0,??gcode_M140_0
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M140_1
        BX       LR
??gcode_M140_1:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M140_2
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12setTargetBedEf
        B.W      _ZN11Temperature12setTargetBedEf
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M140_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M140_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock295

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M81v
          CFI Block cfiBlock296 Using cfiCommon0
          CFI Function _Z9gcode_M81v
        THUMB
_Z9gcode_M81v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        BL       _ZN7Stepper18finish_and_disableEv
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M81_0
        B.N      ??gcode_M81_1
??gcode_M81_2:
        MOVS     R0,#+0
        STR      R0,[R1, #+108]
        MOVS     R0,#+1
??gcode_M81_1:
        CMP      R0,#+0
        BEQ.N    ??gcode_M81_2
        MOV      R0,#+1000
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
        Nop      
        DATA
??gcode_M81_0:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock296

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M82v
          CFI Block cfiBlock297 Using cfiCommon0
          CFI Function _Z9gcode_M82v
          CFI NoCalls
        THUMB
_Z9gcode_M82v:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M82_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M82_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock297

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M83v
          CFI Block cfiBlock298 Using cfiCommon0
          CFI Function _Z9gcode_M83v
          CFI NoCalls
        THUMB
_Z9gcode_M83v:
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M83_0
        STRB     R0,[R1, #+3]
        BX       LR               ;; return
        DATA
??gcode_M83_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock298

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13gcode_M18_M84v
          CFI Block cfiBlock299 Using cfiCommon0
          CFI Function _Z13gcode_M18_M84v
        THUMB
_Z13gcode_M18_M84v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M18_M84_1
        STR      R0,[R1, #+100]
        POP      {R4-R6,PC}
??gcode_M18_M84_0:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M18_M84_2
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M18_M84_3
??gcode_M18_M84_2:
        MOVS     R0,#+0
??gcode_M18_M84_3:
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        B.W      _ZN7Stepper18finish_and_disableEv
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M18_M84_4:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_5
        LDR.N    R0,??gcode_M18_M84_1+0x4
        LDRB     R0,[R0, #+260]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDR.N    R0,??gcode_M18_M84_1+0x8
        LDRH     R1,[R0, #+4]
        LDR.N    R0,??gcode_M18_M84_1+0xC
        LDR      R0,[R0, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1
        STRB     R0,[R1, #+4]
??gcode_M18_M84_5:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_6
        LDR.N    R0,??gcode_M18_M84_1+0x10
        LDRB     R0,[R0, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDR.N    R0,??gcode_M18_M84_1+0x8
        LDRH     R1,[R0, #+14]
        LDR.N    R0,??gcode_M18_M84_1+0xC
        LDR      R0,[R0, #+28]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1
        STRB     R0,[R1, #+5]
??gcode_M18_M84_6:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_7
        LDR.N    R4,??gcode_M18_M84_1+0x10
        LDRB     R0,[R4, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR.N    R5,??gcode_M18_M84_1+0xC
        LDR.N    R6,??gcode_M18_M84_1+0x8
        SXTB     R2,R2
        LDRH     R1,[R6, #+24]
        LDR      R0,[R5, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R4, #+2]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
        LDRH     R1,[R6, #+40]
        LDR      R0,[R5, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M18_M84_1
        STRB     R0,[R1, #+6]
??gcode_M18_M84_7:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_8
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.W      _Z18disable_e_steppersv
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M18_M84_8:
        POP      {R4-R6,PC}       ;; return
        Nop      
        DATA
??gcode_M18_M84_1:
        DC32     axis_homed
        DC32     mksCfg
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     mksCfg+0x104
          CFI EndBlock cfiBlock299

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M85v
          CFI Block cfiBlock300 Using cfiCommon0
          CFI Function _Z9gcode_M85v
        THUMB
_Z9gcode_M85v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M85_0
          CFI FunCall _ZN11GCodeParser25value_millis_from_secondsEv
        BL       _ZN11GCodeParser25value_millis_from_secondsEv
        LDR.N    R1,??gcode_M85_1
        STR      R0,[R1, #+96]
??gcode_M85_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M85_1:
        DC32     axis_homed
          CFI EndBlock cfiBlock300

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M92v
          CFI Block cfiBlock301 Using cfiCommon0
          CFI Function _Z9gcode_M92v
        THUMB
_Z9gcode_M92v:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOVS     R0,#+92
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M92_0
        MOVS     R4,#+0
        B.N      ??gcode_M92_1
??gcode_M92_2:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        STR      R0,[R7, R4, LSL #+2]
??gcode_M92_3:
        ADDS     R4,R4,#+1
??gcode_M92_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M92_4
        LDR.N    R0,??gcode_M92_5
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M92_3
        LDR.N    R7,??gcode_M92_5+0x4
        CMP      R4,#+3
        BNE.N    ??gcode_M92_2
        LDR.N    R6,??gcode_M92_5+0x8
        LDRSB    R0,[R6, #+5]
        ADDS     R0,R0,#+3
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        BL       _ZN11GCodeParser19value_per_axis_unitE8AxisEnum
        MOV      R5,R0
        LDRB     R6,[R6, #+5]
        ADD      R7,R7,R6, LSL #+2
        LDR.N    R1,??gcode_M92_5+0xC  ;; 0x41a00000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M92_6
        LDR      R0,[R7, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR.W    R9,??gcode_M92_5+0x10
        LDR      R0,[R9, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R9, #+12]
        LDR.N    R0,??gcode_M92_5+0x14
        ADD      R9,R0,R6, LSL #+2
        LDR      R0,[R9, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R9, #+12]
        LDR.N    R0,??gcode_M92_5+0x18
        ADD      R6,R0,R6, LSL #+2
        LDR      R0,[R6, #+12]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        STR      R0,[R6, #+12]
??gcode_M92_6:
        STR      R5,[R7, #+12]
        B.N      ??gcode_M92_3
??gcode_M92_4:
        POP      {R0,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19refresh_positioningEv
        B.W      _ZN7Planner19refresh_positioningEv
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M92_0:
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_M92_5:
        DC32     axis_codes
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     mks_heating_busy
        DC32     0x41a00000
        DC32     _ZN7Planner8max_jerkE
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
          CFI EndBlock cfiBlock301

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M114v
          CFI Block cfiBlock302 Using cfiCommon0
          CFI Function _Z10gcode_M114v
        THUMB
_Z10gcode_M114v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
          CFI EndBlock cfiBlock302

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M115v
          CFI Block cfiBlock303 Using cfiCommon0
          CFI Function _Z10gcode_M115v
        THUMB
_Z10gcode_M115v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M115_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x4
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x8
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0xC
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x10
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x14
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x18
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x1C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x20
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.N    R0,??gcode_M115_0+0x24
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x28
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x2C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x30
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x34
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M115_0+0x38
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z8cap_linePKcb
        B.W      _Z8cap_linePKcb
        DATA
??gcode_M115_0:
        DC32     _ZZ10gcode_M115vEs
        DC32     _ZZ10gcode_M115vEs_0
        DC32     _ZZ10gcode_M115vEs_1
        DC32     _ZZ10gcode_M115vEs_2
        DC32     _ZZ10gcode_M115vEs_3
        DC32     _ZZ10gcode_M115vEs_4
        DC32     _ZZ10gcode_M115vEs_5
        DC32     _ZZ10gcode_M115vEs_6
        DC32     _ZZ10gcode_M115vEs_7
        DC32     _ZZ10gcode_M115vEs_8
        DC32     _ZZ10gcode_M115vEs_9
        DC32     _ZZ10gcode_M115vEs__10_
        DC32     _ZZ10gcode_M115vEs__11_
        DC32     _ZZ10gcode_M115vEs__12_
        DC32     _ZZ10gcode_M115vEs__13_
          CFI EndBlock cfiBlock303

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M117v
          CFI Block cfiBlock304 Using cfiCommon0
          CFI Function _Z10gcode_M117v
        THUMB
_Z10gcode_M117v:
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M117_0
        LDR      R0,[R0, #+0]
          CFI FunCall _Z13lcd_setstatusPKcb
        B.W      _Z13lcd_setstatusPKcb
        Nop      
        DATA
??gcode_M117_0:
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock304

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M118v
          CFI Block cfiBlock305 Using cfiCommon0
          CFI Function _Z10gcode_M118v
        THUMB
_Z10gcode_M118v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_0
        LDR.N    R0,??gcode_M118_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_0:
        MOVS     R0,#+65
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M118_2
        LDR.N    R0,??gcode_M118_1+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M118_2:
        LDR.N    R4,??gcode_M118_1+0x8
        LDR.N    R0,??gcode_M118_1+0xC
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M118_1:
        DC32     echomagic
        DC32     _ZZ10gcode_M118vEs
        DC32     Serial3
        DC32     _ZN11GCodeParser10string_argE
          CFI EndBlock cfiBlock305

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M119v
          CFI Block cfiBlock306 Using cfiCommon0
          CFI Function _Z10gcode_M119v
          CFI FunCall _ZN8Endstops4M119Ev
        THUMB
_Z10gcode_M119v:
        B.W      _ZN8Endstops4M119Ev
          CFI EndBlock cfiBlock306

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M120v
          CFI Block cfiBlock307 Using cfiCommon0
          CFI Function _Z10gcode_M120v
        THUMB
_Z10gcode_M120v:
        MOVS     R0,#+1
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock307

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M121v
          CFI Block cfiBlock308 Using cfiCommon0
          CFI Function _Z10gcode_M121v
        THUMB
_Z10gcode_M121v:
        MOVS     R0,#+0
          CFI FunCall _ZN8Endstops15enable_globallyEb
        B.W      _ZN8Endstops15enable_globallyEb
          CFI EndBlock cfiBlock308

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M200v
          CFI Block cfiBlock309 Using cfiCommon0
          CFI Function _Z10gcode_M200v
        THUMB
_Z10gcode_M200v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        SUB      SP,SP,#+8
          CFI CFA R13+16
        MOVS     R0,#+200
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M200_0
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
        LDR.N    R4,??gcode_M200_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M200_3
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        B.N      ??gcode_M200_4
??gcode_M200_3:
        MOV      R0,R1
        STRB     R0,[R4, #+0]
??gcode_M200_4:
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M200_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        LDR.N    R0,??gcode_M200_2+0x4
        LDRB     R0,[R0, #+5]
          CFI FunCall _ZN7Planner17set_filament_sizeEhRKf
        BL       _ZN7Planner17set_filament_sizeEhRKf
??gcode_M200_1:
          CFI FunCall _ZN7Planner32calculate_volumetric_multipliersEv
        BL       _ZN7Planner32calculate_volumetric_multipliersEv
??gcode_M200_0:
        POP      {R0,R1,R4,PC}    ;; return
        DATA
??gcode_M200_2:
        DC32     _ZN11GCodeParser18volumetric_enabledE
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock309

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M201v
          CFI Block cfiBlock310 Using cfiCommon0
          CFI Function _Z10gcode_M201v
        THUMB
_Z10gcode_M201v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+201
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M201_0
        MOVS     R4,#+0
        B.N      ??gcode_M201_1
??gcode_M201_2:
        MOVS     R0,#+0
??gcode_M201_3:
        ADDS     R5,R0,R4
        UXTB     R5,R5
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        LDR.N    R1,??gcode_M201_4
        STR      R0,[R1, R5, LSL #+2]
??gcode_M201_5:
        ADDS     R4,R4,#+1
??gcode_M201_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M201_6
        LDR.N    R0,??gcode_M201_4+0x4
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M201_5
        CMP      R4,#+3
        BNE.N    ??gcode_M201_2
        LDR.N    R0,??gcode_M201_4+0x8
        LDRB     R0,[R0, #+5]
        B.N      ??gcode_M201_3
??gcode_M201_6:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner24reset_acceleration_ratesEv
        B.W      _ZN7Planner24reset_acceleration_ratesEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M201_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M201_4:
        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
        DC32     axis_codes
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock310

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M203v
          CFI Block cfiBlock311 Using cfiCommon0
          CFI Function _Z10gcode_M203v
        THUMB
_Z10gcode_M203v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+203
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M203_0
        MOVS     R4,#+0
        B.N      ??gcode_M203_1
??gcode_M203_2:
        MOVS     R0,#+0
??gcode_M203_3:
        ADDS     R5,R0,R4
        UXTB     R5,R5
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        BL       _ZN11GCodeParser16value_axis_unitsE8AxisEnum
        LDR.N    R1,??gcode_M203_4
        STR      R0,[R1, R5, LSL #+2]
??gcode_M203_5:
        ADDS     R4,R4,#+1
??gcode_M203_1:
        CMP      R4,#+4
        BGE.N    ??gcode_M203_0
        LDR.N    R0,??gcode_M203_4+0x4
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M203_5
        CMP      R4,#+3
        BNE.N    ??gcode_M203_2
        LDR.N    R0,??gcode_M203_4+0x8
        LDRB     R0,[R0, #+5]
        B.N      ??gcode_M203_3
??gcode_M203_0:
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??gcode_M203_4:
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     axis_codes
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock311

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M204v
          CFI Block cfiBlock312 Using cfiCommon0
          CFI Function _Z10gcode_M204v
        THUMB
_Z10gcode_M204v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1
        STR      R0,[R1, #+0]
        LDR.N    R1,??gcode_M204_1+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_0:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x10
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_2:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1+0x14
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M204_3:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M204_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M204_1+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.N    R0,??gcode_M204_1+0x1C
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M204_1+0xC
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M204_4:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M204_1:
        DC32     _ZN7Planner12accelerationE
        DC32     _ZN7Planner19travel_accelerationE
        DC32     _ZZ10gcode_M204vEs
        DC32     Serial3
        DC32     _ZZ10gcode_M204vEs_0
        DC32     _ZN7Planner20retract_accelerationE
        DC32     _ZZ10gcode_M204vEs_1
        DC32     _ZZ10gcode_M204vEs_2
          CFI EndBlock cfiBlock312

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M205v
          CFI Block cfiBlock313 Using cfiCommon0
          CFI Function _Z10gcode_M205v
        THUMB
_Z10gcode_M205v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1
        STR      R0,[R1, #+0]
??gcode_M205_0:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0x4
        STR      R0,[R1, #+0]
??gcode_M205_2:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_3
          CFI FunCall _ZN11GCodeParser11value_ulongEv
        BL       _ZN11GCodeParser11value_ulongEv
        LDR.N    R1,??gcode_M205_1+0x8
        STR      R0,[R1, #+0]
??gcode_M205_3:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+0]
??gcode_M205_4:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_5
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+4]
??gcode_M205_5:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_6
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+8]
??gcode_M205_6:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M205_7
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M205_1+0xC
        STR      R0,[R1, #+12]
??gcode_M205_7:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M205_1:
        DC32     _ZN7Planner17min_feedrate_mm_sE
        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
        DC32     _ZN7Planner19min_segment_time_usE
        DC32     _ZN7Planner8max_jerkE
          CFI EndBlock cfiBlock313

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M206v
          CFI Block cfiBlock314 Using cfiCommon0
          CFI Function _Z10gcode_M206v
        THUMB
_Z10gcode_M206v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??gcode_M206_0
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M206_1
        MOVS     R5,#+0
        B.N      ??gcode_M206_2
??gcode_M206_3:
        LDR.N    R0,??gcode_M206_0+0x4
        LDRSB    R0,[R5, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_4
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R1,R0
        MOV      R0,R5
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_4:
        ADDS     R5,R5,#+1
??gcode_M206_2:
        CMP      R5,#+3
        BLT.N    ??gcode_M206_3
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        BNE.N    ??gcode_M206_5
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R1,R0
        MOVS     R0,#+0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_6:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M206_5
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R1,R0
        MOVS     R0,#+1
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
??gcode_M206_5:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M206_1:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M206_0:
        DC32     mksCfg
        DC32     axis_codes
          CFI EndBlock cfiBlock314

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M665v
          CFI Block cfiBlock315 Using cfiCommon0
          CFI Function _Z10gcode_M665v
        THUMB
_Z10gcode_M665v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+72
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_0
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M665_1
        STR      R0,[R1, #+120]
??gcode_M665_0:
        LDR.N    R4,??gcode_M665_1+0x4
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[R4, #+108]
??gcode_M665_2:
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[R4, #+104]
??gcode_M665_3:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+116]
??gcode_M665_4:
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_5
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+112]
??gcode_M665_5:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+48]
??gcode_M665_6:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_7
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+52]
??gcode_M665_7:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M665_8
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R4, #+56]
??gcode_M665_8:
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21recalc_delta_settingsv
        B.W      _Z21recalc_delta_settingsv
        Nop      
        DATA
??gcode_M665_1:
        DC32     mks_heating_busy
        DC32     axis_homed
          CFI EndBlock cfiBlock315

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M666v
          CFI Block cfiBlock316 Using cfiCommon0
          CFI Function _Z10gcode_M666v
        THUMB
_Z10gcode_M666v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R4,#+0
        B.N      ??gcode_M666_0
??gcode_M666_1:
        LDR.N    R0,??gcode_M666_2
        LDRSB    R0,[R4, R0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M666_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M666_2+0x4
        LDRSB    R0,[R0, #+7]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BHI.N    ??gcode_M666_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M666_2+0x8
        ADD      R1,R1,R4, LSL #+2
        STR      R0,[R1, #+4]
??gcode_M666_3:
        ADDS     R4,R4,#+1
??gcode_M666_0:
        CMP      R4,#+3
        BLT.N    ??gcode_M666_1
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M666_2:
        DC32     axis_codes
        DC32     mksCfg
        DC32     z_endstop_adj
          CFI EndBlock cfiBlock316

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15gcode_M666_dualv
          CFI Block cfiBlock317 Using cfiCommon0
          CFI Function _Z15gcode_M666_dualv
        THUMB
_Z15gcode_M666_dualv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M666_dual_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M666_dual_0+0x4
        LDRB     R0,[R0, #+258]
        CMP      R0,#+1
        BNE.N    ??gcode_M666_dual_1
        LDR.N    R4,??gcode_M666_dual_0+0x8
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M666_dual_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[R4, #+0]
??gcode_M666_dual_2:
        LDR      R1,[R4, #+0]
        LDR.N    R0,??gcode_M666_dual_0+0xC
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
??gcode_M666_dual_1:
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M666_dual_0+0x10
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M666_dual_0:
        DC32     _ZZ15gcode_M666_dualvEs
        DC32     mksCfg
        DC32     z_endstop_adj
        DC32     _ZZ15gcode_M666_dualvEs_0
        DC32     Serial3
          CFI EndBlock cfiBlock317

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M211v
          CFI Block cfiBlock318 Using cfiCommon0
          CFI Function _Z10gcode_M211v
        THUMB
_Z10gcode_M211v:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.N    R0,??gcode_M211_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M211_0+0x4
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_1
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        STRB     R0,[R4, #+8]
??gcode_M211_1:
        LDR.N    R0,??gcode_M211_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+8]
        CMP      R0,#+0
        BEQ.N    ??gcode_M211_2
        LDR.N    R0,??gcode_M211_0+0xC
        B.N      ??gcode_M211_3
??gcode_M211_2:
        LDR.N    R0,??gcode_M211_0+0x10
??gcode_M211_3:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M211_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??gcode_M211_0+0x18
        LDR.N    R6,??gcode_M211_0+0x1C
        LDR      R1,[R6, #+68]
        LDR      R0,[R6, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R7,??gcode_M211_0+0x20
        LDR      R1,[R6, #+72]
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.W    R8,??gcode_M211_0+0x24
        LDR      R1,[R6, #+76]
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M211_0+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R1,[R4, #+36]
        LDR      R0,[R6, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R4, #+40]
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R4, #+44]
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M211_0+0x2C
        POP      {R4-R8,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M211_0:
        DC32     echomagic
        DC32     axis_homed
        DC32     _ZZ10gcode_M211vEs
        DC32     _ZZ10gcode_M211vEs_0
        DC32     _ZZ10gcode_M211vEs_1
        DC32     _ZZ10gcode_M211vEs_2
        DC32     _ZZ10gcode_M211vEs_3
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M211vEs_4
        DC32     _ZZ10gcode_M211vEs_5
        DC32     _ZZ10gcode_M211vEs_6
        DC32     Serial3
          CFI EndBlock cfiBlock318

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M218v
          CFI Block cfiBlock319 Using cfiCommon0
          CFI Function _Z10gcode_M218v
        THUMB
_Z10gcode_M218v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVS     R0,#+218
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M218_0
        LDR.N    R4,??gcode_M218_1
        LDRB     R0,[R4, #+5]
        CMP      R0,#+0
        BEQ.N    ??gcode_M218_0
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M218_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDRB     R1,[R4, #+5]
        LDR.N    R2,??gcode_M218_1+0x4
        STR      R0,[R2, R1, LSL #+2]
??gcode_M218_2:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M218_3
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDRB     R1,[R4, #+5]
        LDR.N    R2,??gcode_M218_1+0x4
        ADD      R1,R2,R1, LSL #+2
        STR      R0,[R1, #+8]
??gcode_M218_3:
        LDR.N    R0,??gcode_M218_1+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M218_1+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R4,#+0
        LDR.N    R5,??gcode_M218_1+0x10
        LDR.N    R6,??gcode_M218_1+0x4
        B.N      ??gcode_M218_4
??gcode_M218_5:
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R6, R4, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+44
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        ADD      R0,R6,R4, LSL #+2
        LDR      R0,[R0, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R4,R4,#+1
        SXTB     R4,R4
??gcode_M218_4:
        LDR.N    R0,??gcode_M218_1+0x14
        LDRB     R0,[R0, #+247]
        CMP      R4,R0
        BLT.N    ??gcode_M218_5
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M218_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
        Nop      
        DATA
??gcode_M218_1:
        DC32     mks_heating_busy
        DC32     hotend_offset
        DC32     echomagic
        DC32     _ZZ10gcode_M218vEs
        DC32     Serial3
        DC32     mksCfg
          CFI EndBlock cfiBlock319

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M220v
          CFI Block cfiBlock320 Using cfiCommon0
          CFI Function _Z10gcode_M220v
        THUMB
_Z10gcode_M220v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M220_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M220_1
        STRH     R0,[R1, #+6]
??gcode_M220_0:
        POP      {R0,PC}          ;; return
        Nop      
        DATA
??gcode_M220_1:
        DC32     mks_heating_busy
          CFI EndBlock cfiBlock320

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M221v
          CFI Block cfiBlock321 Using cfiCommon0
          CFI Function _Z10gcode_M221v
        THUMB
_Z10gcode_M221v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+221
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M221_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M221_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        LDR.N    R1,??gcode_M221_1
        LDRB     R1,[R1, #+5]
        LDR.N    R2,??gcode_M221_1+0x4
        STRH     R0,[R2, R1, LSL #+1]
        MOV      R0,R1
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner16refresh_e_factorEh
        B.W      _ZN7Planner16refresh_e_factorEh
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M221_0:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M221_1:
        DC32     mks_heating_busy
        DC32     _ZN7Planner15flow_percentageE
          CFI EndBlock cfiBlock321

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M226v
          CFI Block cfiBlock322 Using cfiCommon0
          CFI Function _Z10gcode_M226v
        THUMB
_Z10gcode_M226v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M226_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R4,R0
        MOV      R1,#-1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        ADDS     R0,R5,#+1
        CMP      R0,#+3
        BCS.N    ??gcode_M226_0
        CMP      R4,#+0
        BMI.N    ??gcode_M226_0
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z16pin_is_protecteda
        BL       _Z16pin_is_protecteda
        CMP      R0,#+0
        BNE.N    ??gcode_M226_0
        MOVS     R6,#+0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        CMP      R5,#+1
        BEQ.N    ??gcode_M226_1
        CMP      R5,#-1
        BEQ.N    ??gcode_M226_2
        B.N      ??gcode_M226_3
??gcode_M226_1:
        MOVS     R6,#+1
        B.N      ??gcode_M226_3
??gcode_M226_2:
        CMP      R4,#+0
        BPL.N    ??gcode_M226_3
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        MOV      R6,R0
        B.N      ??gcode_M226_3
??gcode_M226_5:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_M226_3:
        CMP      R4,#+0
        BMI.N    ??gcode_M226_6
        LDR.N    R0,??gcode_M226_4
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??gcode_M226_4+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        B.N      ??gcode_M226_7
??gcode_M226_6:
        MOV      R0,R6
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
??gcode_M226_7:
        CMP      R0,#+0
        BNE.N    ??gcode_M226_5
??gcode_M226_0:
        POP      {R4-R6,PC}       ;; return
        DATA
??gcode_M226_4:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
          CFI EndBlock cfiBlock322

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M280v
          CFI Block cfiBlock323 Using cfiCommon0
          CFI Function _Z10gcode_M280v
        THUMB
_Z10gcode_M280v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M280_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOVS     R4,R0
        BNE.N    ??gcode_M280_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M280_2
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        CMP      R0,#+10
        BEQ.N    ??gcode_M280_3
        CMP      R0,#+60
        BEQ.N    ??gcode_M280_4
        CMP      R0,#+90
        BEQ.N    ??gcode_M280_5
        CMP      R0,#+120
        BEQ.N    ??gcode_M280_6
        B.N      ??gcode_M280_7
??gcode_M280_3:
        MOV      R0,#+350
        B.N      ??gcode_M280_8
??gcode_M280_5:
        MOVW     R0,#+750
        B.N      ??gcode_M280_8
??gcode_M280_6:
        MOV      R0,#+900
        B.N      ??gcode_M280_8
??gcode_M280_4:
        MOV      R0,#+600
        B.N      ??gcode_M280_8
??gcode_M280_7:
        MOVW     R0,#+1100
??gcode_M280_8:
        LDR.N    R1,??gcode_M280_9  ;; 0x40012c34
        STR      R0,[R1, #+0]
        POP      {R4,PC}
??gcode_M280_2:
        LDR.N    R0,??gcode_M280_9+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M280_9+0x8
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M280_9+0xC
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M280_1:
        LDR.N    R0,??gcode_M280_9+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R1,R4
        LDR.N    R0,??gcode_M280_9+0x14
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M280_9+0xC
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M280_0:
        POP      {R4,PC}          ;; return
        DATA
??gcode_M280_9:
        DC32     0x40012c34
        DC32     echomagic
        DC32     _ZZ10gcode_M280vEs
        DC32     _ZZ10gcode_M280vEs_0
        DC32     errormagic
        DC32     _ZZ10gcode_M280vEs_1
          CFI EndBlock cfiBlock323

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M301v
          CFI Block cfiBlock324 Using cfiCommon0
          CFI Function _Z10gcode_M301v
        THUMB
_Z10gcode_M301v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7bytevalEch
        BL       _ZN11GCodeParser7bytevalEch
        CMP      R0,#+2
        BGE.N    ??gcode_M301_0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_1
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_M301_2
        STR      R0,[R1, #+0]
??gcode_M301_1:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M301_2+0xC
        STR      R0,[R1, #+0]
??gcode_M301_3:
        LDR.N    R4,??gcode_M301_2+0x10
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M301_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M301_4:
          CFI FunCall _ZN11Temperature9updatePIDEv
        BL       _ZN11Temperature9updatePIDEv
        LDR.N    R0,??gcode_M301_2+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M301_2
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M301_2+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M301_2+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M301_2+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M301_2+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M301_2+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M301_2+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M301_2+0x24
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M301_0:
        LDR.N    R0,??gcode_M301_2+0x28
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??gcode_M301_2+0x24
        LDR.N    R1,??gcode_M301_2+0x2C
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M301_2:
        DC32     _ZN11Temperature2KpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature2KiE
        DC32     _ZN11Temperature2KdE
        DC32     echomagic
        DC32     _ZZ10gcode_M301vEs
        DC32     _ZZ10gcode_M301vEs_0
        DC32     _ZZ10gcode_M301vEs_1
        DC32     Serial3
        DC32     errormagic
        DC32     _ZZ10gcode_M301vEs_2
          CFI EndBlock cfiBlock324

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M304v
          CFI Block cfiBlock325 Using cfiCommon0
          CFI Function _Z10gcode_M304v
        THUMB
_Z10gcode_M304v:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_0
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_M304_1
        STR      R0,[R1, #+0]
??gcode_M304_0:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_2
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??gcode_M304_1+0xC
        STR      R0,[R1, #+0]
??gcode_M304_2:
        LDR.N    R4,??gcode_M304_1+0x10
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M304_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+0]
??gcode_M304_3:
        LDR.N    R0,??gcode_M304_1+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M304_1
        LDR      R1,[R0, #+0]
        LDR.N    R0,??gcode_M304_1+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??gcode_M304_1+0xC
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M304_1+0x1C
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??gcode_M304_1+0x4  ;; 0x88e368f1
        LDR.N    R3,??gcode_M304_1+0x8  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.N    R0,??gcode_M304_1+0x20
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M304_1+0x24
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??gcode_M304_1:
        DC32     _ZN11Temperature5bedKpE
        DC32     0x88e368f1
        DC32     0x3fc4f8b5
        DC32     _ZN11Temperature5bedKiE
        DC32     _ZN11Temperature5bedKdE
        DC32     echomagic
        DC32     _ZZ10gcode_M304vEs
        DC32     _ZZ10gcode_M304vEs_0
        DC32     _ZZ10gcode_M304vEs_1
        DC32     Serial3
          CFI EndBlock cfiBlock325

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M302v
          CFI Block cfiBlock326 Using cfiCommon0
          CFI Function _Z10gcode_M302v
        THUMB
_Z10gcode_M302v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R4,R0
        BEQ.N    ??gcode_M302_0
        LDR.N    R5,??gcode_M302_1
          CFI FunCall _ZN11GCodeParser13value_celsiusEv
        BL       _ZN11GCodeParser13value_celsiusEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRH     R0,[R5, #+0]
        LDRSH    R0,[R5, #+0]
        SUBS     R1,R0,#+1
        SBCS     R1,R1,R1
        LSRS     R1,R1,#+31
        LDR.N    R0,??gcode_M302_1+0x4
        STRB     R1,[R0, #+0]
??gcode_M302_0:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_2
        LDR.N    R4,??gcode_M302_1+0x4
        LDR.N    R0,??gcode_M302_1
        LDRSH    R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_3
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        STRB     R0,[R4, #+0]
        POP      {R0,R4,R5,PC}
??gcode_M302_3:
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
        POP      {R0,R4,R5,PC}
??gcode_M302_2:
        CMP      R4,#+0
        BNE.N    ??gcode_M302_4
        LDR.N    R0,??gcode_M302_1+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M302_1+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??gcode_M302_5
        LDR.N    R1,??gcode_M302_1+0xC
        B.N      ??gcode_M302_6
??gcode_M302_5:
        LDR.N    R1,??gcode_M302_1+0x10
??gcode_M302_6:
        LDR.N    R0,??gcode_M302_1+0x14
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R0,??gcode_M302_1
        LDRSH    R1,[R0, #+0]
        LDR.N    R0,??gcode_M302_1+0x18
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M302_1+0x1C
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M302_4:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M302_1:
        DC32     _ZN11Temperature16extrude_min_tempE
        DC32     _ZN11Temperature18allow_cold_extrudeE
        DC32     echomagic
        DC32     _ZZ10gcode_M302vEs_0
        DC32     _ZZ10gcode_M302vEs_1
        DC32     _ZZ10gcode_M302vEs
        DC32     _ZZ10gcode_M302vEs_2
        DC32     _ZZ10gcode_M302vEs_3
          CFI EndBlock cfiBlock326

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M303v
          CFI Block cfiBlock327 Using cfiCommon0
          CFI Function _Z10gcode_M303v
        THUMB
_Z10gcode_M303v:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R0,??gcode_M303_0
        LDRB     R1,[R0, #+52]
        CMP      R1,#+0
        BNE.N    ??gcode_M303_1
        LDRB     R0,[R0, #+53]
        CMP      R0,#+0
        BEQ.N    ??gcode_M303_2
??gcode_M303_1:
        MOVS     R1,#+0
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R4,R0
        MOVS     R1,#+5
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        MOVS     R0,#+85
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R6,R0
        CMP      R4,#+0
        BPL.N    ??gcode_M303_3
        MOVS     R0,#+70
        B.N      ??gcode_M303_4
??gcode_M303_3:
        MOVS     R0,#+150
??gcode_M303_4:
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser10celsiusvalEcf
        BL       _ZN11GCodeParser10celsiusvalEcf
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        CMP      R4,#+2
        BCS.N    ??gcode_M303_5
        LDR.N    R1,??gcode_M303_0+0x4
        STRB     R4,[R1, #+5]
??gcode_M303_5:
        MOV      R2,R5
        SXTB     R2,R2
        MOV      R1,R4
        SXTB     R1,R1
        MOV      R4,R1
        MOV      R5,R2
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R3,R6
        MOV      R2,R5
        MOV      R1,R4
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12PID_autotuneEfaab
        B.W      _ZN11Temperature12PID_autotuneEfaab
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M303_2:
        LDR.N    R0,??gcode_M303_0+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M303_0+0xC
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M303_0:
        DC32     mksCfg
        DC32     mks_heating_busy
        DC32     errormagic
        DC32     _ZZ10gcode_M303vEs
          CFI EndBlock cfiBlock327

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M360v
          CFI Block cfiBlock328 Using cfiCommon0
          CFI Function _Z10gcode_M360v
        THUMB
_Z10gcode_M360v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M360_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+120
        MOVS     R0,#+0
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M360_0:
        DC32     _ZZ10gcode_M360vEs
          CFI EndBlock cfiBlock328

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M361v
          CFI Block cfiBlock329 Using cfiCommon0
          CFI Function _Z10gcode_M361v
        THUMB
_Z10gcode_M361v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M361_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+130
        MOVS     R0,#+90
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M361_0:
        DC32     _ZZ10gcode_M361vEs
          CFI EndBlock cfiBlock329

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M362v
          CFI Block cfiBlock330 Using cfiCommon0
          CFI Function _Z10gcode_M362v
        THUMB
_Z10gcode_M362v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M362_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+180
        MOVS     R0,#+60
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M362_0:
        DC32     _ZZ10gcode_M362vEs
          CFI EndBlock cfiBlock330

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M363v
          CFI Block cfiBlock331 Using cfiCommon0
          CFI Function _Z10gcode_M363v
        THUMB
_Z10gcode_M363v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M363_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+90
        MOVS     R0,#+50
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M363_0:
        DC32     _ZZ10gcode_M363vEs
          CFI EndBlock cfiBlock331

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M364v
          CFI Block cfiBlock332 Using cfiCommon0
          CFI Function _Z10gcode_M364v
        THUMB
_Z10gcode_M364v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M364_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+135
        MOVS     R0,#+45
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z17SCARA_move_to_calhh
        B.W      _Z17SCARA_move_to_calhh
        DATA
??gcode_M364_0:
        DC32     _ZZ10gcode_M364vEs
          CFI EndBlock cfiBlock332

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M400v
          CFI Block cfiBlock333 Using cfiCommon0
          CFI Function _Z10gcode_M400v
          CFI FunCall _ZN7Stepper11synchronizeEv
        THUMB
_Z10gcode_M400v:
        B.W      _ZN7Stepper11synchronizeEv
          CFI EndBlock cfiBlock333

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M401v
          CFI Block cfiBlock334 Using cfiCommon0
          CFI Function _Z10gcode_M401v
        THUMB
_Z10gcode_M401v:
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI EndBlock cfiBlock334

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M402v
          CFI Block cfiBlock335 Using cfiCommon0
          CFI Function _Z10gcode_M402v
        THUMB
_Z10gcode_M402v:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        B.W      _Z18set_probe_deployedb
          CFI EndBlock cfiBlock335

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M420v
          CFI Block cfiBlock336 Using cfiCommon0
          CFI Function _Z10gcode_M420v
        THUMB
_Z10gcode_M420v:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        SUB      SP,SP,#+20
          CFI CFA R13+40
        LDR.N    R4,??gcode_M420_0
        LDR      R0,[R4, #+8]
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+12]
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+16]
        STR      R0,[SP, #+12]
        LDR.N    R6,??gcode_M420_0+0x4
        LDRB     R0,[R6, #+64]
        CMP      R0,#+16
        BNE.N    ??gcode_M420_1
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_2
          CFI FunCall _ZN11GCodeParser9has_valueEv
        BL       _ZN11GCodeParser9has_valueEv
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_3
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R5,R0
        B.N      ??gcode_M420_4
??gcode_M420_3:
        LDR.N    R0,??gcode_M420_0+0x8
        LDRSB    R5,[R0, #+0]
??gcode_M420_4:
          CFI FunCall _ZN14MarlinSettings15calc_num_meshesEv
        BL       _ZN14MarlinSettings15calc_num_meshesEv
        SXTH     R0,R0
        CMP      R0,#+0
        BNE.N    ??gcode_M420_5
        LDR.N    R0,??gcode_M420_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M420_6
??gcode_M420_5:
        SUBS     R7,R0,#+1
        SXTB     R5,R5
        MOVS     R0,R5
        BMI.N    ??gcode_M420_7
        CMP      R7,R0
        BGE.N    ??gcode_M420_8
??gcode_M420_7:
        LDR.N    R0,??gcode_M420_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R1,R7
        LDR.N    R0,??gcode_M420_0+0x14
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M420_0+0x18
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_M420_6
??gcode_M420_8:
        MOVS     R1,#+0
          CFI FunCall _ZN14MarlinSettings9load_meshEaPv
        BL       _ZN14MarlinSettings9load_meshEaPv
        LDR.N    R0,??gcode_M420_0+0x8
        STRB     R5,[R0, #+0]
??gcode_M420_2:
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BNE.N    ??gcode_M420_9
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_1
??gcode_M420_9:
        MOVS     R0,#+0
          CFI FunCall _ZN20unified_bed_leveling11display_mapEi
        BL       _ZN20unified_bed_leveling11display_mapEi
        ADD      R0,R4,#+132
          CFI FunCall _ZN20unified_bed_leveling13mesh_is_validEv
        BL       _ZN20unified_bed_leveling13mesh_is_validEv
        MOV      R1,R0
        LDR.N    R0,??gcode_M420_0+0x1C
          CFI FunCall _Z17serial_echopair_PPKcb
        BL       _Z17serial_echopair_PPKcb
        LDR.N    R5,??gcode_M420_0+0x18
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R0,??gcode_M420_0+0x8
        LDRSB    R1,[R0, #+0]
        LDR.N    R0,??gcode_M420_0+0x20
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M420_1:
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_10
        LDRB     R5,[R6, #+64]
        MOVS     R0,#+6
        TST      R5,R0
        BEQ.N    ??gcode_M420_11
        LDR.N    R1,??gcode_M420_0+0x24
        LDR.N    R0,??gcode_M420_0+0x28
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
        B.N      ??gcode_M420_10
??gcode_M420_11:
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_10
        CMP      R5,#+8
        BNE.N    ??gcode_M420_12
          CFI FunCall _Z28print_bilinear_leveling_gridv
        BL       _Z28print_bilinear_leveling_gridv
        B.N      ??gcode_M420_10
??gcode_M420_12:
        CMP      R5,#+32
        BNE.N    ??gcode_M420_10
        LDR.N    R0,??gcode_M420_0+0x2C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
??gcode_M420_10:
        LDRSH    R0,[R6, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M420_13
        LDRB     R0,[R6, #+64]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_M420_13
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_13
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        MOVS     R1,#+0
          CFI FunCall _Z17set_z_fade_heightfb
        BL       _Z17set_z_fade_heightfb
??gcode_M420_13:
        MOVS     R5,#+0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_14
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        MOV      R5,R0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_M420_14:
        LDR.N    R0,??gcode_M420_0+0x30
        LDRB     R6,[R0, #+0]
        EOR      R0,R6,#0x1
        MOV      R1,R5
        TST      R1,R0
        BEQ.N    ??gcode_M420_15
        LDR.N    R0,??gcode_M420_0+0x34
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x38
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_15:
        LDR.N    R7,??gcode_M420_0+0x3C
        MOV      R0,R7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R6,#+0
        BEQ.N    ??gcode_M420_16
        LDR.N    R1,??gcode_M420_0+0x40
        B.N      ??gcode_M420_17
??gcode_M420_16:
        LDR.N    R1,??gcode_M420_0+0x44
??gcode_M420_17:
        LDR.N    R0,??gcode_M420_0+0x48
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R5,??gcode_M420_0+0x18
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOV      R0,R7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x4C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x50
        LDR      R0,[R0, #+0]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_M420_18
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_M420_19
??gcode_M420_18:
        LDR.N    R0,??gcode_M420_0+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_19:
        MOVS     R2,#+12
        ADD      R1,R4,#+8
        ADD      R0,SP,#+4
          CFI FunCall memcmp
        BL       memcmp
        CMP      R0,#+0
        BEQ.N    ??gcode_M420_6
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_M420_6:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        Nop      
        DATA
??gcode_M420_0:
        DC32     mks_heating_busy
        DC32     mksCfg
        DC32     _ZN20unified_bed_leveling12storage_slotE
        DC32     _ZZ10gcode_M420vEs
        DC32     _ZZ10gcode_M420vEs_0
        DC32     _ZZ10gcode_M420vEs_1
        DC32     Serial3
        DC32     _ZZ10gcode_M420vEs_2
        DC32     _ZZ10gcode_M420vEs_3
        DC32     _ZZ10gcode_M420vEs_4
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ10gcode_M420vEs_5
        DC32     _ZN7Planner15leveling_activeE
        DC32     errormagic
        DC32     _ZZ10gcode_M420vEs_6
        DC32     echomagic
        DC32     _ZZ10gcode_M420vEs_8
        DC32     _ZZ10gcode_M420vEs_9
        DC32     _ZZ10gcode_M420vEs_7
        DC32     _ZZ10gcode_M420vEs__10_
        DC32     _ZN7Planner13z_fade_heightE
        DC32     _ZZ10gcode_M420vEs__11_
          CFI EndBlock cfiBlock336

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28gcode_M421_MESH_BED_LEVELINGv
          CFI Block cfiBlock337 Using cfiCommon0
          CFI Function _Z28gcode_M421_MESH_BED_LEVELINGv
        THUMB
_Z28gcode_M421_MESH_BED_LEVELINGv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R4,R0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOVS     R5,R0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_0
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R6,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_1
??gcode_M421_MESH_BED_LEVELING_0:
        CMP      R4,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_2
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_xERKf
        BL       _ZN17mesh_bed_leveling13probe_index_xERKf
        MOV      R6,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_1
??gcode_M421_MESH_BED_LEVELING_2:
        MOV      R6,#-1
??gcode_M421_MESH_BED_LEVELING_1:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R7,R0
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R8,R0
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
          CFI FunCall _ZN11GCodeParser9value_intEv
        BL       _ZN11GCodeParser9value_intEv
        MOV      R9,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_4
??gcode_M421_MESH_BED_LEVELING_3:
        CMP      R7,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_yERKf
        BL       _ZN17mesh_bed_leveling13probe_index_yERKf
        MOV      R9,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_4
??gcode_M421_MESH_BED_LEVELING_5:
        MOV      R9,#-1
??gcode_M421_MESH_BED_LEVELING_4:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R11,R0
        CMP      R11,#+0
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_6
        MOVS     R0,#+81
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R10,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_7
??gcode_M421_MESH_BED_LEVELING_6:
        MOV      R10,#+0
??gcode_M421_MESH_BED_LEVELING_7:
        AND      R0,R8,R5
        AND      R1,R7,R4
        ADDS     R0,R1,R0
        CMP      R0,#+1
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_8
        ORRS     R0,R10,R11
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_9
??gcode_M421_MESH_BED_LEVELING_8:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M421_MESH_BED_LEVELING_11
??gcode_M421_MESH_BED_LEVELING_9:
        SXTB     R6,R6
        MOVS     R4,R6
        BMI.N    ??gcode_M421_MESH_BED_LEVELING_12
        SXTB     R9,R9
        MOV      R5,R9
        CMP      R5,#+0
        BPL.N    ??gcode_M421_MESH_BED_LEVELING_13
??gcode_M421_MESH_BED_LEVELING_12:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_10+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_M421_MESH_BED_LEVELING_11
??gcode_M421_MESH_BED_LEVELING_13:
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        CMP      R10,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_14
        ADD      R1,R4,R4, LSL #+1
        LDR.N    R2,??gcode_M421_MESH_BED_LEVELING_10+0xC
        ADD      R1,R2,R1, LSL #+4
        LDR      R1,[R1, R5, LSL #+2]
        B.N      ??gcode_M421_MESH_BED_LEVELING_15
??gcode_M421_MESH_BED_LEVELING_14:
        MOVS     R1,#+0
??gcode_M421_MESH_BED_LEVELING_15:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+0]
        ADD      R2,SP,#+0
        MOV      R1,R9
        MOV      R0,R6
          CFI FunCall _ZN17mesh_bed_leveling5set_zEaaRKf
        BL       _ZN17mesh_bed_leveling5set_zEaaRKf
??gcode_M421_MESH_BED_LEVELING_11:
        POP      {R0,R4-R11,PC}   ;; return
        DATA
??gcode_M421_MESH_BED_LEVELING_10:
        DC32     errormagic
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        DC32     _ZN17mesh_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock337

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
          CFI Block cfiBlock338 Using cfiCommon0
          CFI Function _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        THUMB
_Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R1,#-1
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R6,R0
        SXTB     R6,R6
        MOV      R1,#-1
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R4,R0
        SXTB     R4,R4
        MOV      R7,R6
        MVNS     R7,R7
        MOV      R8,R4
        MVN      R8,R8
        LSR      R8,R8,#+31
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R9,R0
        CMP      R9,#+0
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0
        MOVS     R0,#+81
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R5,R0
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0:
        MOVS     R5,#+0
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1:
        AND      R0,R8,R7, LSR #+31
        ORR      R1,R5,R9
        TST      R0,R1
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x4
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2:
        CMP      R6,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x8
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R6
        BLT.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        CMP      R4,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        LDRB     R0,[R0, #+97]
        SUBS     R0,R0,#+1
        CMP      R0,R4
        BGE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0xC
        POP      {R1,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5:
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        ADD      R1,R6,R6, LSL #+1
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3+0x10
        ADD      R6,R2,R1, LSL #+4
        CMP      R5,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6
        LDR      R1,[R6, R4, LSL #+2]
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6:
        MOVS     R1,#+0
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, R4, LSL #+2]
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3:
        DC32     errormagic
        DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
        DC32     mksCfg
        DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
        DC32     z_values
          CFI EndBlock cfiBlock338

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
          CFI Block cfiBlock339 Using cfiCommon0
          CFI Function _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        THUMB
_Z32gcode_M421_AUTO_BED_LEVELING_UBLv:
        PUSH     {R0-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+48
        MOV      R1,#-1
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R10,R0
        SXTB     R10,R10
        MOV      R1,#-1
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser6intvalEcs
        BL       _ZN11GCodeParser6intvalEcs
        MOV      R5,R0
        SXTB     R5,R5
        MOV      R6,R10
        MVNS     R6,R6
        MOV      R7,R5
        MVNS     R7,R7
        LSRS     R7,R7,#+31
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R8,R0
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R9,R0
        CMP      R9,#+0
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_0
        MOVS     R0,#+81
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R4,R0
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_1
??gcode_M421_AUTO_BED_LEVELING_UBL_0:
        MOVS     R4,#+0
??gcode_M421_AUTO_BED_LEVELING_UBL_1:
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_2
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3
        MOVS     R1,#+0
        STR      R1,[SP, #+4]
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+12
        ADD      R2,R0,#+8
        MOVS     R1,#+1
        ADD      R0,SP,#+8
          CFI FunCall _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        BL       _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        LDRSB    R10,[SP, #+8]
        LDRSB    R5,[SP, #+9]
??gcode_M421_AUTO_BED_LEVELING_UBL_2:
        AND      R0,R7,R6, LSR #+31
        ADD      R0,R0,R8
        CMP      R0,#+1
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_4
        ORRS     R0,R4,R9
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_5
??gcode_M421_AUTO_BED_LEVELING_UBL_4:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x8
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M421_AUTO_BED_LEVELING_UBL_5:
        CMP      R10,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0xC
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R10
        BLT.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
        CMP      R5,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_6
        LDRB     R0,[R0, #+97]
        SUBS     R0,R0,#+1
        CMP      R0,R5
        BGE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_7
??gcode_M421_AUTO_BED_LEVELING_UBL_6:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x10
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+48
??gcode_M421_AUTO_BED_LEVELING_UBL_7:
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        ADD      R1,R10,R10, LSL #+1
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_3+0x14
        ADD      R6,R2,R1, LSL #+4
        CMP      R4,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_8
        LDR      R1,[R6, R5, LSL #+2]
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_9
??gcode_M421_AUTO_BED_LEVELING_UBL_8:
        MOVS     R1,#+0
??gcode_M421_AUTO_BED_LEVELING_UBL_9:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, R5, LSL #+2]
        POP      {R0-R10,PC}      ;; return
        Nop      
        DATA
??gcode_M421_AUTO_BED_LEVELING_UBL_3:
        DC32     mks_heating_busy
        DC32     errormagic
        DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
        DC32     mksCfg
        DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
        DC32     _ZN20unified_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock339

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M428v
          CFI Block cfiBlock340 Using cfiCommon0
          CFI Function _Z10gcode_M428v
        THUMB
_Z10gcode_M428v:
        LDR.N    R0,??gcode_M428_0
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_M428_1
        BX       LR
??gcode_M428_1:
        PUSH     {R1-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+32
        MOVS     R2,#+1
        MOV      R1,R2
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.N    ??gcode_M428_2
        MOVS     R4,#+0
        ADD      R6,SP,#+0
        LDR.N    R7,??gcode_M428_0+0x4  ;; 0xc1a00000
        B.N      ??gcode_M428_3
??gcode_M428_4:
        ADDS     R4,R4,#+1
        UXTB     R4,R4
??gcode_M428_3:
        CMP      R4,#+3
        BGE.N    ??gcode_M428_5
        LDR.N    R0,??gcode_M428_0+0x8
        ADD      R0,R0,R4, LSL #+2
        LDR      R5,[R0, #+8]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z13base_home_pos8AxisEnum
        BL       _Z13base_home_pos8AxisEnum
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R6, R4, LSL #+2]
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_6
        LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M428_7
??gcode_M428_6:
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z8home_dir8AxisEnum
        BL       _Z8home_dir8AxisEnum
        CMP      R0,#+1
        BLT.N    ??gcode_M428_7
        EOR      R5,R5,#0x80000000
        STR      R5,[R6, R4, LSL #+2]
??gcode_M428_7:
        LDR      R0,[R6, R4, LSL #+2]
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_8
        LDR.N    R1,??gcode_M428_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M428_4
??gcode_M428_8:
        LDR.N    R0,??gcode_M428_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x18
          CFI FunCall _Z21lcd_setalertstatusPGMPKc
        BL       _Z21lcd_setalertstatusPGMPKc
        POP      {R0-R2,R4-R7,PC}
??gcode_M428_5:
        MOVS     R4,#+0
        B.N      ??gcode_M428_9
??gcode_M428_10:
        ADD      R0,SP,#+0
        LDR      R1,[R0, R4, LSL #+2]
        MOV      R0,R4
        SXTB     R0,R0
          CFI FunCall _Z15set_home_offset8AxisEnumf
        BL       _Z15set_home_offset8AxisEnumf
        ADDS     R4,R4,#+1
??gcode_M428_9:
        CMP      R4,#+3
        BLT.N    ??gcode_M428_10
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M428_0+0x1C
          CFI FunCall _Z16lcd_setstatusPGMPKca
        BL       _Z16lcd_setstatusPGMPKca
??gcode_M428_2:
        POP      {R0-R2,R4-R7,PC}  ;; return
        DATA
??gcode_M428_0:
        DC32     mksCfg
        DC32     0xc1a00000
        DC32     mks_heating_busy
        DC32     0x41a00001
        DC32     errormagic
        DC32     _ZZ10gcode_M428vEs
        DC32     _ZZ10gcode_M428vEs_0
        DC32     _ZZ10gcode_M428vEs_1
          CFI EndBlock cfiBlock340

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M500v
          CFI Block cfiBlock341 Using cfiCommon0
          CFI Function _Z10gcode_M500v
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
_Z10gcode_M500v:
        B.W      _ZN14MarlinSettings4saveEv
          CFI EndBlock cfiBlock341

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M501v
          CFI Block cfiBlock342 Using cfiCommon0
          CFI Function _Z10gcode_M501v
          CFI FunCall _ZN14MarlinSettings4loadEv
        THUMB
_Z10gcode_M501v:
        B.W      _ZN14MarlinSettings4loadEv
          CFI EndBlock cfiBlock342

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M502v
          CFI Block cfiBlock343 Using cfiCommon0
          CFI Function _Z10gcode_M502v
          CFI FunCall _ZN14MarlinSettings5resetEv
        THUMB
_Z10gcode_M502v:
        B.W      _ZN14MarlinSettings5resetEv
          CFI EndBlock cfiBlock343

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M503v
          CFI Block cfiBlock344 Using cfiCommon0
          CFI Function _Z10gcode_M503v
        THUMB
_Z10gcode_M503v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M503_0
          CFI FunCall _ZN11GCodeParser10value_boolEv
        BL       _ZN11GCodeParser10value_boolEv
        AND      R0,R0,#0x1
        EOR      R0,R0,#0x1
        B.N      ??gcode_M503_1
??gcode_M503_0:
        MOVS     R0,#+0
??gcode_M503_1:
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN14MarlinSettings6reportEb
        B.W      _ZN14MarlinSettings6reportEb
          CFI EndBlock cfiBlock344

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M851v
          CFI Block cfiBlock345 Using cfiCommon0
          CFI Function _Z10gcode_M851v
        THUMB
_Z10gcode_M851v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M851_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M851_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M851_1
          CFI FunCall _ZN11GCodeParser18value_linear_unitsEv
        BL       _ZN11GCodeParser18value_linear_unitsEv
        LDR.N    R1,??gcode_M851_0+0x8  ;; 0xc1a00000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M851_2
        LDR.N    R1,??gcode_M851_0+0xC  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M851_3
??gcode_M851_2:
        LDR.N    R0,??gcode_M851_0+0x10
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M851_3:
        LDR.N    R1,??gcode_M851_0+0x14
        STR      R0,[R1, #+112]
??gcode_M851_1:
        LDR.N    R0,??gcode_M851_0+0x14
        LDR      R1,[R0, #+112]
        LDR.N    R0,??gcode_M851_0+0x18
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        LDR.N    R0,??gcode_M851_0+0x1C
        POP      {R2,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        DATA
??gcode_M851_0:
        DC32     echomagic
        DC32     _ZZ10gcode_M851vEs
        DC32     0xc1a00000
        DC32     0x41a00001
        DC32     _ZZ10gcode_M851vEs_0
        DC32     mks_heating_busy
        DC32     _ZZ10gcode_M851vEs_1
        DC32     Serial3
          CFI EndBlock cfiBlock345

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z10gcode_M907v
          CFI Block cfiBlock346 Using cfiCommon0
          CFI Function _Z10gcode_M907v
          CFI NoCalls
        THUMB
_Z10gcode_M907v:
        BX       LR               ;; return
          CFI EndBlock cfiBlock346

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M355v
          CFI Block cfiBlock347 Using cfiCommon0
          CFI Function _Z10gcode_M355v
        THUMB
_Z10gcode_M355v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??gcode_M355_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M355_0+0x4
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
        Nop      
        DATA
??gcode_M355_0:
        DC32     errormagic
        DC32     _ZZ10gcode_M355vEs
          CFI EndBlock cfiBlock347

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M999v
          CFI Block cfiBlock348 Using cfiCommon0
          CFI Function _Z10gcode_M999v
        THUMB
_Z10gcode_M999v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M999_0
        STRB     R0,[R1, #+4]
          CFI FunCall _Z21lcd_reset_alert_levelv
        BL       _Z21lcd_reset_alert_levelv
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        CMP      R0,#+0
        BNE.N    ??gcode_M999_1
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z24FlushSerialRequestResendv
        B.W      _Z24FlushSerialRequestResendv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M999_1:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M999_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock348

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z22invalid_extruder_errorh
          CFI Block cfiBlock349 Using cfiCommon0
          CFI Function _Z22invalid_extruder_errorh
        THUMB
_Z22invalid_extruder_errorh:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??invalid_extruder_error_0
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R5,??invalid_extruder_error_0+0x4
        MOVS     R1,#+84
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R1,??invalid_extruder_error_0+0x8
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
        Nop      
        DATA
??invalid_extruder_error_0:
        DC32     echomagic
        DC32     Serial3
        DC32     _ZZ22invalid_extruder_errorhEs
          CFI EndBlock cfiBlock349

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z7gcode_Th
          CFI Block cfiBlock350 Using cfiCommon0
          CFI Function _Z7gcode_Th
        THUMB
_Z7gcode_Th:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??gcode_T_0
        LDRB     R0,[R0, #+3]
        CMP      R4,R0
        BEQ.N    ??gcode_T_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7boolvalEc
        BL       _ZN11GCodeParser7boolvalEc
        MOV      R5,R0
        B.N      ??gcode_T_2
??gcode_T_1:
        MOVS     R5,#+1
??gcode_T_2:
        MOVS     R1,#+0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser9linearvalEcf
        BL       _ZN11GCodeParser9linearvalEcf
        LDR.N    R1,??gcode_T_0+0x4  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R0
        MOV      R2,R5
        MOV      R0,R4
        POP      {R3-R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z11tool_changehfb
        B.W      _Z11tool_changehfb
        DATA
??gcode_T_0:
        DC32     mks_heating_busy
        DC32     0x42700000
          CFI EndBlock cfiBlock350

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z25prepare_kinematic_move_toRA4_Kf
          CFI Block cfiBlock351 Using cfiCommon0
          CFI Function _Z25prepare_kinematic_move_toRA4_Kf
        THUMB
_Z25prepare_kinematic_move_toRA4_Kf:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        SUB      SP,SP,#+48
          CFI CFA R13+88
        LDR.W    R4,??prepare_kinematic_move_to_0
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
        LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+0]
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+4]
        LDR      R1,[R4, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_kinematic_move_to_1
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??prepare_kinematic_move_to_2
??prepare_kinematic_move_to_1:
        LDR.W    R0,??prepare_kinematic_move_to_0+0xC
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        LDR      R0,[SP, #+48]
        BEQ.N    ??prepare_kinematic_move_to_3
        ADDS     R1,R0,#+4
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??prepare_kinematic_move_to_4
        B.N      ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_3:
        ADDS     R1,R0,#+4
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_4:
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+8]
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+12]
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R6,R9
        MOV      R8,#+2
        MOV      R5,#+1065353216
        B.N      ??prepare_kinematic_move_to_6
??prepare_kinematic_move_to_7:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_6:
        LSLS     R0,R8,#+31
        BPL.N    ??prepare_kinematic_move_to_8
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??prepare_kinematic_move_to_8:
        LSRS     R8,R8,#+1
        BNE.N    ??prepare_kinematic_move_to_7
        MOV      R8,R7
        MOV      R10,#+2
        MOV      R6,#+1065353216
        B.N      ??prepare_kinematic_move_to_9
??prepare_kinematic_move_to_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_9:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_11
        MOV      R0,R6
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_11:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_10
        LDR      R11,[SP, #+4]
        MOV      R8,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_12
??prepare_kinematic_move_to_13:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_12:
        LSLS     R0,R8,#+31
        BPL.N    ??prepare_kinematic_move_to_14
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_14:
        LSRS     R8,R8,#+1
        BNE.N    ??prepare_kinematic_move_to_13
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
        LDR.N    R1,??prepare_kinematic_move_to_0+0x10  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_15
        LDR      R0,[SP, #+0]
        BIC      R8,R0,#0x80000000
??prepare_kinematic_move_to_15:
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_16
??prepare_kinematic_move_to_5:
        MOVS     R0,#+1
        B.N      ??prepare_kinematic_move_to_17
??prepare_kinematic_move_to_16:
        LDR.N    R5,??prepare_kinematic_move_to_0+0x14
        LDR      R1,[SP, #+8]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[R5, #+116]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
        LDR.N    R0,??prepare_kinematic_move_to_0+0xC
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??prepare_kinematic_move_to_18
        MOV      R0,#+1082130432
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        UXTH     R6,R6
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_18
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
??prepare_kinematic_move_to_18:
        UXTH     R6,R6
        CMP      R6,#+0
        BNE.N    ??prepare_kinematic_move_to_19
        MOVS     R6,#+1
??prepare_kinematic_move_to_19:
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,#+1065353216
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+28]
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+32]
        LDR      R0,[SP, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+36]
        LDR      R0,[SP, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+40]
        MOVS     R2,#+16
        ADD      R1,R4,#+8
        ADD      R0,SP,#+12
          CFI FunCall memcpy
        BL       memcpy
        B.N      ??prepare_kinematic_move_to_20
??prepare_kinematic_move_to_21:
        LDRB     R0,[R4, #+3]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+24
        LDR      R2,[R4, #+88]
        LDR      R1,[R4, #+84]
        LDR      R0,[R4, #+80]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
??prepare_kinematic_move_to_20:
        SUBS     R6,R6,#+1
        UXTH     R6,R6
        CMP      R6,#+0
        BEQ.W    ??prepare_kinematic_move_to_2
        LDR.N    R7,??prepare_kinematic_move_to_0+0x18
        LDR.N    R0,??prepare_kinematic_move_to_0+0x1C
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        BNE.N    ??prepare_kinematic_move_to_22
        MOVS     R1,#+1
        STRB     R1,[R0, #+0]
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDS     R0,R0,#+200
        STR      R0,[R7, #+0]
??prepare_kinematic_move_to_22:
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR      R1,[R7, #+0]
        SUBS     R0,R0,R1
        BMI.N    ??prepare_kinematic_move_to_23
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDS     R0,R0,#+200
        STR      R0,[R7, #+0]
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??prepare_kinematic_move_to_23:
        MOV      R8,#+0
        ADD      R7,SP,#+12
        B.N      ??prepare_kinematic_move_to_24
??prepare_kinematic_move_to_25:
        LDR      R0,[R7, R8, LSL #+2]
        ADD      R1,SP,#+28
        LDR      R1,[R1, R8, LSL #+2]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, R8, LSL #+2]
        ADD      R8,R8,#+1
??prepare_kinematic_move_to_24:
        CMP      R8,#+4
        BLT.N    ??prepare_kinematic_move_to_25
        LDR.N    R0,??prepare_kinematic_move_to_0+0xC
        LDRB     R0,[R0, #+88]
        LSLS     R0,R0,#+30
        BPL.W    ??prepare_kinematic_move_to_26
        LDR      R0,[R5, #+12]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R9,#+2
        MOV      R8,#+1065353216
        B.N      ??prepare_kinematic_move_to_27
??prepare_kinematic_move_to_28:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??prepare_kinematic_move_to_27:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_29
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_29:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_28
        ADD      R7,SP,#+12
        LDR      R0,[R5, #+16]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_30
??prepare_kinematic_move_to_31:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_30:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_32
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_32:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_31
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+80]
        LDR      R0,[R5, #+20]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??prepare_kinematic_move_to_33
??prepare_kinematic_move_to_34:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_33:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_35
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_35:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_34
        LDR      R0,[R5, #+24]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_36
??prepare_kinematic_move_to_37:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_36:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_38
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_38:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_37
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+84]
        LDR      R0,[R5, #+28]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,#+1065353216
        B.N      ??prepare_kinematic_move_to_39
??prepare_kinematic_move_to_40:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_39:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_41
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_41:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_40
        LDR      R0,[R5, #+32]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,#+1065353216
        B.N      ??prepare_kinematic_move_to_42
??prepare_kinematic_move_to_43:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_42:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_44
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_44:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_43
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+88]
        B.N      ??prepare_kinematic_move_to_45
??prepare_kinematic_move_to_26:
        ADD      R0,SP,#+12
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??prepare_kinematic_move_to_45:
        ADD      R0,SP,#+12
          CFI FunCall _Z12ADJUST_DELTAPKf
        BL       _Z12ADJUST_DELTAPKf
        LDR.N    R2,??prepare_kinematic_move_to_0+0x20
        LDRB     R0,[R2, #+328]
        CMP      R0,#+1
        BNE.W    ??prepare_kinematic_move_to_21
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+8]
        LDR      R1,[R2, #+664]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.W    ??prepare_kinematic_move_to_21
        ADD      R4,R2,#+328
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
        LDR      R1,[SP, #+24]
        LDR.N    R0,??prepare_kinematic_move_to_0+0x24
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall lroundf
        BL       lroundf
        STR      R0,[R4, #+8]
        MOVS     R0,#+0
        B.N      ??prepare_kinematic_move_to_17
??prepare_kinematic_move_to_2:
        LDRB     R2,[R4, #+3]
        ADD      R1,SP,#+8
        LDR      R0,[SP, #+48]
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        MOVS     R0,#+0
??prepare_kinematic_move_to_17:
        ADD      SP,SP,#+52
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??prepare_kinematic_move_to_0:
        DC32     mks_heating_busy
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     mksCfg
        DC32     0x358637be
        DC32     axis_homed
        DC32     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        DC32     _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        DC32     gCfgItems
        DC32     _ZN7Planner17axis_steps_per_mmE
          CFI EndBlock cfiBlock351

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37prepare_move_to_destination_cartesianv
          CFI Block cfiBlock352 Using cfiCommon0
          CFI Function _Z37prepare_move_to_destination_cartesianv
        THUMB
_Z37prepare_move_to_destination_cartesianv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        LDR.N    R4,??prepare_move_to_destination_cartesian_0
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_1
        ADD      R0,R4,#+32
          CFI FunCall _ZN7Planner20leveling_active_at_zERKf
        BL       _ZN7Planner20leveling_active_at_zERKf
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_cartesian_1
        LDR.N    R0,??prepare_move_to_destination_cartesian_0+0x8
        LDRB     R2,[R0, #+64]
        CMP      R2,#+16
        BNE.N    ??prepare_move_to_destination_cartesian_2
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        LDRB     R1,[R4, #+3]
        ADD      R0,SP,#+0
          CFI FunCall _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        BL       _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_2:
        LDR      R0,[R4, #+8]
        LDR      R1,[R4, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_move_to_destination_cartesian_3
        LDR      R0,[R4, #+12]
        LDR      R1,[R4, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_cartesian_1
??prepare_move_to_destination_cartesian_3:
        CMP      R2,#+32
        BNE.N    ??prepare_move_to_destination_cartesian_4
        MOVS     R2,#+255
        MOV      R1,R2
        MOV      R5,R1
        MOV      R6,R2
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R6
        MOV      R1,R5
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
        B.N      ??prepare_move_to_destination_cartesian_5
??prepare_move_to_destination_cartesian_4:
        CMP      R2,#+8
        BNE.N    ??prepare_move_to_destination_cartesian_5
        MOVW     R1,#+65535
        MOV      R2,R1
        MOV      R5,R2
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R5
        MOV      R1,R5
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
??prepare_move_to_destination_cartesian_5:
        MOVS     R0,#+1
        POP      {R1,R2,R4-R6,PC}
??prepare_move_to_destination_cartesian_1:
        LDRSH    R0,[R4, #+6]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+92]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R2,??prepare_move_to_destination_cartesian_0+0xC  ;; 0x47ae147b
        LDR.N    R3,??prepare_move_to_destination_cartesian_0+0x10  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
        MOVS     R0,#+0
        POP      {R1,R2,R4-R6,PC}  ;; return
        DATA
??prepare_move_to_destination_cartesian_0:
        DC32     mks_heating_busy
        DC32     _ZN7Planner15leveling_activeE
        DC32     mksCfg
        DC32     0x47ae147b
        DC32     0x3f847ae1
          CFI EndBlock cfiBlock352

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 16398 
// 
//  4 854 bytes in section .bss
//    385 bytes in section .data
//      4 bytes in section .init_array
//  3 815 bytes in section .rodata
// 51 908 bytes in section .text
// 
// 28 640 bytes of CODE  memory (+ 23 272 bytes shared)
//    288 bytes of CONST memory (+  3 527 bytes shared)
//  5 029 bytes of DATA  memory (+    210 bytes shared)
//
//Errors: none
//Warnings: 164
