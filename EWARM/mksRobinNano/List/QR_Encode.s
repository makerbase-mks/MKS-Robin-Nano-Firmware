///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       13/Apr/2020  09:25:16
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\QR_Encode.c
//    Command line =  
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\QR_Encode.c
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
//        -lA
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
//        --diag_suppress Pa050 -o
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
//        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed
//        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
//        -Oh --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\CMSIS\Include\"
//    List file    =  
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\QR_Encode.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1

        EXTERN __aeabi_memclr4
        EXTERN __aeabi_memmove
        EXTERN strlen

        PUBLIC AlphabetToBinaly
        PUBLIC ChineseToBinaly
        PUBLIC CountPenalty
        PUBLIC EncodeData
        PUBLIC EncodeSourceData
        PUBLIC FormatModule
        PUBLIC GetBitLength
        PUBLIC GetEncodeVersion
        PUBLIC GetRSCodeWord
        PUBLIC IsAlphabetData
        PUBLIC IsChineseData
        PUBLIC IsKanjiData
        PUBLIC IsNumeralData
        PUBLIC KanjiToBinaly
        PUBLIC Print_2DCode
        PUBLIC QR_VersonInfo
        PUBLIC SetAlignmentPattern
        PUBLIC SetBitStream
        PUBLIC SetCodeWordPattern
        PUBLIC SetFinderPattern
        PUBLIC SetFormatInfoPattern
        PUBLIC SetFunctionModule
        PUBLIC SetMaskingPattern
        PUBLIC SetVersionPattern
        PUBLIC byExpToInt
        PUBLIC byIntToExp
        PUBLIC byRSExp
        PUBLIC byRSExp10
        PUBLIC byRSExp13
        PUBLIC byRSExp15
        PUBLIC byRSExp16
        PUBLIC byRSExp17
        PUBLIC byRSExp18
        PUBLIC byRSExp20
        PUBLIC byRSExp22
        PUBLIC byRSExp24
        PUBLIC byRSExp26
        PUBLIC byRSExp28
        PUBLIC byRSExp30
        PUBLIC byRSExp32
        PUBLIC byRSExp34
        PUBLIC byRSExp36
        PUBLIC byRSExp38
        PUBLIC byRSExp40
        PUBLIC byRSExp42
        PUBLIC byRSExp44
        PUBLIC byRSExp46
        PUBLIC byRSExp48
        PUBLIC byRSExp50
        PUBLIC byRSExp52
        PUBLIC byRSExp54
        PUBLIC byRSExp56
        PUBLIC byRSExp58
        PUBLIC byRSExp60
        PUBLIC byRSExp62
        PUBLIC byRSExp64
        PUBLIC byRSExp66
        PUBLIC byRSExp68
        PUBLIC byRSExp7
        PUBLIC m_bAutoExtent
        PUBLIC m_byAllCodeWord
        PUBLIC m_byBlockMode
        PUBLIC m_byDataCodeWord
        PUBLIC m_byModuleData
        PUBLIC m_byRSWork
        PUBLIC m_nBlockLength
        PUBLIC m_nLevel
        PUBLIC m_nMaskingNo
        PUBLIC m_nSymbleSize
        PUBLIC m_nVersion
        PUBLIC m_ncAllCodeWord
        PUBLIC m_ncDataBlock
        PUBLIC m_ncDataCodeWordBit
        PUBLIC nIndicatorLen8Bit
        PUBLIC nIndicatorLenAlphabet
        PUBLIC nIndicatorLenKanji
        PUBLIC nIndicatorLenNumeral
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\User\ui\QRENCODE\QR_Encode.c
//    1 #include "string.h"
//    2 #include <integer.h>
//    3 //#include "stm32f40x.h"
//    4 #include "stm32f1xx.h"
//    5 
//    6 typedef signed char bool;
//    7 
//    8 #include "QR_Encode.h"
//    9 //二维码生成原理详见 http://coolshell.cn/articles/10590.html#jtss-tsina
//   10 
//   11 
//   12 
//   13 //P28 表9 QR码符号各版本的纠错特效
//   14 const QR_VERSIONINFO QR_VersonInfo[] = {{0}, // Ver.0
//   15 										 { 1, // Ver.1
//   16 										    26,   19,   16,   13,    9,
//   17 										   0,   0,   0,   0,   0,   0,   0,
//   18 										   1,  26,  19,
//   19 										   1,  26,  16,
//   20 										   1,  26,  13,
//   21 										   1,  26,   9,
//   22 										   0,   0,   0,
//   23 										   0,   0,   0,
//   24 										   0,   0,   0,
//   25 										   0,   0,   0},
//   26 										 { 2, // Ver.2
//   27 										    44,   34,   28,   22,   16,
//   28 										   1,  18,   0,   0,   0,   0,   0,
//   29 										   1,  44,  34,
//   30 										   1,  44,  28,
//   31 										   1,  44,  22,
//   32 										   1,  44,  16,
//   33 										   0,   0,   0,
//   34 										   0,   0,   0,
//   35 										   0,   0,   0,
//   36 										   0,   0,   0},
//   37 										 { 3, // Ver.3
//   38 										    70,   55,   44,   34,   26,
//   39 										   1,  22,   0,   0,   0,   0,   0,
//   40 										   1,  70,  55,
//   41 										   1,  70,  44,
//   42 										   2,  35,  17,
//   43 										   2,  35,  13,
//   44 										   0,   0,   0,
//   45 										   0,   0,   0,
//   46 										   0,   0,   0,
//   47 										   0,   0,   0},
//   48 										 { 4, // Ver.4
//   49 										   100,   80,   64,   48,   36,
//   50 										   1,  26,   0,   0,   0,   0,   0,
//   51 										   1, 100,  80,
//   52 										   2,  50,  32,
//   53 										   2,  50,  24,
//   54 										   4,  25,   9,
//   55 										   0,   0,   0,
//   56 										   0,   0,   0,
//   57 										   0,   0,   0,
//   58 										   0,   0,   0},
//   59 										 { 5, // Ver.5
//   60 										   134,  108,   86,   62,   46,
//   61 										   1,  30,   0,   0,   0,   0,   0,
//   62 										   1, 134, 108,
//   63 										   2,  67,  43,
//   64 										   2,  33,  15,
//   65 										   2,  33,  11,
//   66 										   0,   0,   0,
//   67 										   0,   0,   0,
//   68 										   2,  34,  16,
//   69 										   2,  34,  12},
//   70 										 { 6, // Ver.6
//   71 										   172,  136,  108,   76,   60,
//   72 										   1,  34,   0,   0,   0,   0,   0,
//   73 										   2,  86,  68,
//   74 										   4,  43,  27,
//   75 										   4,  43,  19,
//   76 										   4,  43,  15,
//   77 										   0,   0,   0,
//   78 										   0,   0,   0,
//   79 										   0,   0,   0,
//   80 										   0,   0,   0},
//   81 										 { 7, // Ver.7
//   82 										   196,  156,  124,   88,   66,
//   83 										   2,  22,  38,   0,   0,   0,   0,
//   84 										   2,  98,  78,
//   85 										   4,  49,  31,
//   86 										   2,  32,  14,
//   87 										   4,  39,  13,
//   88 										   0,   0,   0,
//   89 										   0,   0,   0,
//   90 										   4,  33,  15,
//   91 										   1,  40,  14},
//   92 										 { 8, // Ver.8
//   93 										   242,  194,  154,  110,   86,
//   94 										   2,  24,  42,   0,   0,   0,   0,
//   95 										   2, 121,  97,
//   96 										   2,  60,  38,
//   97 										   4,  40,  18,
//   98 										   4,  40,  14,
//   99 										   0,   0,   0,
//  100 										   2,  61,  39,
//  101 										   2,  41,  19,
//  102 										   2,  41,  15},
//  103 										 { 9, // Ver.9
//  104 										   292,  232,  182,  132,  100,
//  105 										   2,  26,  46,   0,   0,   0,   0,
//  106 										   2, 146, 116,
//  107 										   3,  58,  36,
//  108 										   4,  36,  16,
//  109 										   4,  36,  12,
//  110 										   0,   0,   0,
//  111 										   2,  59,  37,
//  112 										   4,  37,  17,
//  113 										   4,  37,  13},
//  114 										 {10, // Ver.10
//  115 										   346,  274,  216,  154,  122,
//  116 										   2,  28,  50,   0,   0,   0,   0,
//  117 										   2,  86,  68,
//  118 										   4,  69,  43,
//  119 										   6,  43,  19,
//  120 										   6,  43,  15,
//  121 										   2,  87,  69,
//  122 										   1,  70,  44,
//  123 										   2,  44,  20,
//  124 										   2,  44,  16},
//  125 										 {11, // Ver.11
//  126 										   404,  324,  254,  180,  140,
//  127 										   2,  30,  54,   0,   0,   0,   0,
//  128 										   4, 101,  81,
//  129 										   1,  80,  50,
//  130 										   4,  50,  22,
//  131 										   3,  36,  12,
//  132 										   0,   0,   0,
//  133 										   4,  81,  51,
//  134 										   4,  51,  23,
//  135 										   8,  37,  13},
//  136 										 {12, // Ver.12
//  137 										   466,  370,  290,  206,  158,
//  138 										   2,  32,  58,   0,   0,   0,   0,
//  139 										   2, 116,  92,
//  140 										   6,  58,  36,
//  141 										   4,  46,  20,
//  142 										   7,  42,  14,
//  143 										   2, 117,  93,
//  144 										   2,  59,  37,
//  145 										   6,  47,  21,
//  146 										   4,  43,  15},
//  147 										 {13, // Ver.13
//  148 										   532,  428,  334,  244,  180,
//  149 										   2,  34,  62,   0,   0,   0,   0,
//  150 										   4, 133, 107,
//  151 										   8,  59,  37,
//  152 										   8,  44,  20,
//  153 										  12,  33,  11,
//  154 										   0,   0,   0,
//  155 										   1,  60,  38,
//  156 										   4,  45,  21,
//  157 										   4,  34,  12},
//  158 										 {14, // Ver.14
//  159 										   581,  461,  365,  261,  197,
//  160 										   3,  26,  46,  66,   0,   0,   0,
//  161 										   3, 145, 115,
//  162 										   4,  64,  40,
//  163 										  11,  36,  16,
//  164 										  11,  36,  12,
//  165 										   1, 146, 116,
//  166 										   5,  65,  41,
//  167 										   5,  37,  17,
//  168 										   5,  37,  13},
//  169 										 {15, // Ver.15
//  170 										   655,  523,  415,  295,  223,
//  171 										   3,  26,  48,  70,   0,   0,   0,
//  172 										   5, 109,  87,
//  173 										   5,  65,  41,
//  174 										   5,  54,  24,
//  175 										  11,  36,  12,
//  176 										   1, 110,  88,
//  177 										   5,  66,  42,
//  178 										   7,  55,  25,
//  179 										   7,  37,  13},
//  180 										 {16, // Ver.16
//  181 										   733,  589,  453,  325,  253,
//  182 										   3,  26,  50,  74,   0,   0,   0,
//  183 										   5, 122,  98,
//  184 										   7,  73,  45,
//  185 										  15,  43,  19,
//  186 										   3,  45,  15,
//  187 										   1, 123,  99,
//  188 										   3,  74,  46,
//  189 										   2,  44,  20,
//  190 										  13,  46,  16},
//  191 										 {17, // Ver.17
//  192 										   815,  647,  507,  367,  283,
//  193 										   3,  30,  54,  78,   0,   0,   0,
//  194 										   1, 135, 107,
//  195 										  10,  74,  46,
//  196 										   1,  50,  22,
//  197 										   2,  42,  14,
//  198 										   5, 136, 108,
//  199 										   1,  75,  47,
//  200 										  15,  51,  23,
//  201 										  17,  43,  15},
//  202 										 {18, // Ver.18
//  203 										   901,  721,  563,  397,  313,
//  204 										   3,  30,  56,  82,   0,   0,   0,
//  205 										   5, 150, 120,
//  206 										   9,  69,  43,
//  207 										  17,  50,  22,
//  208 										   2,  42,  14,
//  209 										   1, 151, 121,
//  210 										   4,  70,  44,
//  211 										   1,  51,  23,
//  212 										  19,  43,  15},
//  213 										 {19, // Ver.19
//  214 										   991,  795,  627,  445,  341,
//  215 										   3,  30,  58,  86,   0,   0,   0,
//  216 										   3, 141, 113,
//  217 										   3,  70,  44,
//  218 										  17,  47,  21,
//  219 										   9,  39,  13,
//  220 										   4, 142, 114,
//  221 										  11,  71,  45,
//  222 										   4,  48,  22,
//  223 										  16,  40,  14},
//  224 										 {20, // Ver.20
//  225 										  1085,  861,  669,  485,  385,
//  226 										   3,  34,  62,  90,   0,   0,   0,
//  227 										   3, 135, 107,
//  228 										   3,  67,  41,
//  229 										  15,  54,  24,
//  230 										  15,  43,  15,
//  231 										   5, 136, 108,
//  232 										  13,  68,  42,
//  233 										   5,  55,  25,
//  234 										  10,  44,  16},
//  235 										 {21, // Ver.21
//  236 										  1156,  932,  714,  512,  406,
//  237 										   4,  28,  50,  72,  94,   0,   0,
//  238 										   4, 144, 116,
//  239 										  17,  68,  42,
//  240 										  17,  50,  22,
//  241 										  19,  46,  16,
//  242 										   4, 145, 117,
//  243 										   0,   0,   0,
//  244 										   6,  51,  23,
//  245 										   6,  47,  17},
//  246 										 {22, // Ver.22
//  247 										  1258, 1006,  782,  568,  442,
//  248 										   4,  26,  50,  74,  98,   0,   0,
//  249 										   2, 139, 111,
//  250 										  17,  74,  46,
//  251 										   7,  54,  24,
//  252 										  34,  37,  13,
//  253 										   7, 140, 112,
//  254 										   0,   0,   0,
//  255 										  16,  55,  25,
//  256 										   0,   0,   0},
//  257 										 {23, // Ver.23
//  258 										  1364, 1094,  860,  614,  464,
//  259 										   4,  30,  54,  78, 102,   0,   0,
//  260 										   4, 151, 121,
//  261 										   4,  75,  47,
//  262 										  11,  54,  24,
//  263 										  16,  45,  15,
//  264 										   5, 152, 122,
//  265 										  14,  76,  48,
//  266 										  14,  55,  25,
//  267 										  14,  46,  16},
//  268 										 {24, // Ver.24
//  269 										  1474, 1174,  914,  664,  514,
//  270 										   4,  28,  54,  80, 106,   0,   0,
//  271 										   6, 147, 117,
//  272 										   6,  73,  45,
//  273 										  11,  54,  24,
//  274 										  30,  46,  16,
//  275 										   4, 148, 118,
//  276 										  14,  74,  46,
//  277 										  16,  55,  25,
//  278 										   2,  47,  17},
//  279 										 {25, // Ver.25
//  280 										  1588, 1276, 1000,  718,  538,
//  281 										   4,  32,  58,  84, 110,   0,   0,
//  282 										   8, 132, 106,
//  283 										   8,  75,  47,
//  284 										   7,  54,  24,
//  285 										  22,  45,  15,
//  286 										   4, 133, 107,
//  287 										  13,  76,  48,
//  288 										  22,  55,  25,
//  289 										  13,  46,  16},
//  290 										 {26, // Ver.26
//  291 										  1706, 1370, 1062,  754,  596,
//  292 										   4,  30,  58,  86, 114,   0,   0,
//  293 										  10, 142, 114,
//  294 										  19,  74,  46,
//  295 										  28,  50,  22,
//  296 										  33,  46,  16,
//  297 										   2, 143, 115,
//  298 										   4,  75,  47,
//  299 										   6,  51,  23,
//  300 										   4,  47,  17},
//  301 										 {27, // Ver.27
//  302 										  1828, 1468, 1128,  808,  628,
//  303 										   4,  34,  62,  90, 118,   0,   0,
//  304 										   8, 152, 122,
//  305 										  22,  73,  45,
//  306 										   8,  53,  23,
//  307 										  12,  45,  15,
//  308 										   4, 153, 123,
//  309 										   3,  74,  46,
//  310 										  26,  54,  24,
//  311 										  28,  46,  16},
//  312 										 {28, // Ver.28
//  313 										  1921, 1531, 1193,  871,  661,
//  314 										   5,  26,  50,  74,  98, 122,   0,
//  315 										   3, 147, 117,
//  316 										   3,  73,  45,
//  317 										   4,  54,  24,
//  318 										  11,  45,  15,
//  319 										  10, 148, 118,
//  320 										  23,  74,  46,
//  321 										  31,  55,  25,
//  322 										  31,  46,  16},
//  323 										 {29, // Ver.29
//  324 										  2051, 1631, 1267,  911,  701,
//  325 										   5,  30,  54,  78, 102, 126,   0,
//  326 										   7, 146, 116,
//  327 										  21,  73,  45,
//  328 										   1,  53,  23,
//  329 										  19,  45,  15,
//  330 										   7, 147, 117,
//  331 										   7,  74,  46,
//  332 										  37,  54,  24,
//  333 										  26,  46,  16},
//  334 										 {30, // Ver.30
//  335 										  2185, 1735, 1373,  985,  745,
//  336 										   5,  26,  52,  78, 104, 130,   0,
//  337 										   5, 145, 115,
//  338 										  19,  75,  47,
//  339 										  15,  54,  24,
//  340 										  23,  45,  15,
//  341 										  10, 146, 116,
//  342 										  10,  76,  48,
//  343 										  25,  55,  25,
//  344 										  25,  46,  16},
//  345 										 {31, // Ver.31
//  346 										  2323, 1843, 1455, 1033,  793,
//  347 										   5,  30,  56,  82, 108, 134,   0,
//  348 										  13, 145, 115,
//  349 										   2,  74,  46,
//  350 										  42,  54,  24,
//  351 										  23,  45,  15,
//  352 										   3, 146, 116,
//  353 										  29,  75,  47,
//  354 										   1,  55,  25,
//  355 										  28,  46,  16},
//  356 										 {32, // Ver.32
//  357 										  2465, 1955, 1541, 1115,  845,
//  358 										   5,  34,  60,  86, 112, 138,   0,
//  359 										  17, 145, 115,
//  360 										  10,  74,  46,
//  361 										  10,  54,  24,
//  362 										  19,  45,  15,
//  363 										   0,   0,   0,
//  364 										  23,  75,  47,
//  365 										  35,  55,  25,
//  366 										  35,  46,  16},
//  367 										 {33, // Ver.33
//  368 										  2611, 2071, 1631, 1171,  901,
//  369 										   5,  30,  58,  86, 114, 142,   0,
//  370 										  17, 145, 115,
//  371 										  14,  74,  46,
//  372 										  29,  54,  24,
//  373 										  11,  45,  15,
//  374 										   1, 146, 116,
//  375 										  21,  75,  47,
//  376 										  19,  55,  25,
//  377 										  46,  46,  16},
//  378 										 {34, // Ver.34
//  379 										  2761, 2191, 1725, 1231,  961,
//  380 										   5,  34,  62,  90, 118, 146,   0,
//  381 										  13, 145, 115,
//  382 										  14,  74,  46,
//  383 										  44,  54,  24,
//  384 										  59,  46,  16,
//  385 										   6, 146, 116,
//  386 										  23,  75,  47,
//  387 										   7,  55,  25,
//  388 										   1,  47,  17},
//  389 										 {35, // Ver.35
//  390 										  2876, 2306, 1812, 1286,  986,
//  391 										   6,  30,  54,  78, 102, 126, 150,
//  392 										  12, 151, 121,
//  393 										  12,  75,  47,
//  394 										  39,  54,  24,
//  395 										  22,  45,  15,
//  396 										   7, 152, 122,
//  397 										  26,  76,  48,
//  398 										  14,  55,  25,
//  399 										  41,  46,  16},
//  400 										 {36, // Ver.36
//  401 										  3034, 2434, 1914, 1354, 1054,
//  402 										   6,  24,  50,  76, 102, 128, 154,
//  403 										   6, 151, 121,
//  404 										   6,  75,  47,
//  405 										  46,  54,  24,
//  406 										   2,  45,  15,
//  407 										  14, 152, 122,
//  408 										  34,  76,  48,
//  409 										  10,  55,  25,
//  410 										  64,  46,  16},
//  411 										 {37, // Ver.37
//  412 										  3196, 2566, 1992, 1426, 1096,
//  413 										   6,  28,  54,  80, 106, 132, 158,
//  414 										  17, 152, 122,
//  415 										  29,  74,  46,
//  416 										  49,  54,  24,
//  417 										  24,  45,  15,
//  418 										   4, 153, 123,
//  419 										  14,  75,  47,
//  420 										  10,  55,  25,
//  421 										  46,  46,  16},
//  422 										 {38, // Ver.38
//  423 										  3362, 2702, 2102, 1502, 1142,
//  424 										   6,  32,  58,  84, 110, 136, 162,
//  425 										   4, 152, 122,
//  426 										  13,  74,  46,
//  427 										  48,  54,  24,
//  428 										  42,  45,  15,
//  429 										  18, 153, 123,
//  430 										  32,  75,  47,
//  431 										  14,  55,  25,
//  432 										  32,  46,  16},
//  433 										 {39, // Ver.39
//  434 										  3532, 2812, 2216, 1582, 1222,
//  435 										   6,  26,  54,  82, 110, 138, 166,
//  436 										  20, 147, 117,
//  437 										  40,  75,  47,
//  438 										  43,  54,  24,
//  439 										  10,  45,  15,
//  440 										   4, 148, 118,
//  441 										   7,  76,  48,
//  442 										  22,  55,  25,
//  443 										  67,  46,  16},
//  444 										 {40, // Ver.40
//  445 										  3706, 2956, 2334, 1666, 1276,
//  446 										   6,  30,  58,  86, 114, 142, 170,
//  447 										  19, 148, 118,
//  448 										  18,  75,  47,
//  449 										  34,  54,  24,
//  450 										  20,  45,  15,
//  451 										   6, 149, 119,
//  452 										  31,  76,  48,
//  453 										  34,  55,  25,
//  454 										  61,  46,  16}
//  455 										 
//  456 										  
//  457 };
//  458 
//  459 // GF(2^8) 指数2系数――本源多项式
//  460 /////////////////////////////////////////////////////////////////////////////
//  461 const BYTE byExpToInt[] = {  1,   2,   4,   8,  16,  32,  64, 128,  29,  58, 116, 232, 205, 135,  19,  38,
//  462 							 76, 152,  45,  90, 180, 117, 234, 201, 143,   3,   6,  12,  24,  48,  96, 192,
//  463 							157,  39,  78, 156,  37,  74, 148,  53, 106, 212, 181, 119, 238, 193, 159,  35,
//  464 							 70, 140,   5,  10,  20,  40,  80, 160,  93, 186, 105, 210, 185, 111, 222, 161,
//  465 							 95, 190,  97, 194, 153,  47,  94, 188, 101, 202, 137,  15,  30,  60, 120, 240,
//  466 							253, 231, 211, 187, 107, 214, 177, 127, 254, 225, 223, 163,  91, 182, 113, 226,
//  467 							217, 175,  67, 134,  17,  34,  68, 136,  13,  26,  52, 104, 208, 189, 103, 206,
//  468 							129,  31,  62, 124, 248, 237, 199, 147,  59, 118, 236, 197, 151,  51, 102, 204,
//  469 							133,  23,  46,  92, 184, 109, 218, 169,  79, 158,  33,  66, 132,  21,  42,  84,
//  470 							168,  77, 154,  41,  82, 164,  85, 170,  73, 146,  57, 114, 228, 213, 183, 115,
//  471 							230, 209, 191,  99, 198, 145,  63, 126, 252, 229, 215, 179, 123, 246, 241, 255,
//  472 							227, 219, 171,  75, 150,  49,  98, 196, 149,  55, 110, 220, 165,  87, 174,  65,
//  473 							130,  25,  50, 100, 200, 141,   7,  14,  28,  56, 112, 224, 221, 167,  83, 166,
//  474 							 81, 162,  89, 178, 121, 242, 249, 239, 195, 155,  43,  86, 172,  69, 138,   9,
//  475 							 18,  36,  72, 144,  61, 122, 244, 245, 247, 243, 251, 235, 203, 139,  11,  22,
//  476 							 44,  88, 176, 125, 250, 233, 207, 131,  27,  54, 108, 216, 173,  71, 142,   1};
//  477 // GF(2^8) 系数2指数――本源多项式 
//  478 /////////////////////////////////////////////////////////////////////////////
//  479 const BYTE byIntToExp[] = {  0,   0,   1,  25,   2,  50,  26, 198,   3, 223,  51, 238,  27, 104, 199,  75,
//  480 							  4, 100, 224,  14,  52, 141, 239, 129,  28, 193, 105, 248, 200,   8,  76, 113,
//  481 							  5, 138, 101,  47, 225,  36,  15,  33,  53, 147, 142, 218, 240,  18, 130,  69,
//  482 							 29, 181, 194, 125, 106,  39, 249, 185, 201, 154,   9, 120,  77, 228, 114, 166,
//  483 							  6, 191, 139,  98, 102, 221,  48, 253, 226, 152,  37, 179,  16, 145,  34, 136,
//  484 							 54, 208, 148, 206, 143, 150, 219, 189, 241, 210,  19,  92, 131,  56,  70,  64,
//  485 							 30,  66, 182, 163, 195,  72, 126, 110, 107,  58,  40,  84, 250, 133, 186,  61,
//  486 							202,  94, 155, 159,  10,  21, 121,  43,  78, 212, 229, 172, 115, 243, 167,  87,
//  487 							  7, 112, 192, 247, 140, 128,  99,  13, 103,  74, 222, 237,  49, 197, 254,  24,
//  488 							227, 165, 153, 119,  38, 184, 180, 124,  17,  68, 146, 217,  35,  32, 137,  46,
//  489 							 55,  63, 209,  91, 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190,  97,
//  490 							242,  86, 211, 171,  20,  42,  93, 158, 132,  60,  57,  83,  71, 109,  65, 162,
//  491 							 31,  45,  67, 216, 183, 123, 164, 118, 196,  23,  73, 236, 127,  12, 111, 246,
//  492 							108, 161,  59,  82,  41, 157,  85, 170, 251,  96, 134, 177, 187, 204,  62,  90,
//  493 							203,  89,  95, 176, 156, 169, 160,  81,  11, 245,  22, 235, 122, 117,  44, 215,
//  494 							 79, 174, 213, 233, 230, 231, 173, 232, 116, 214, 244, 234, 168,  80,  88, 175};
//  495 
//  496 //纠错码字的生成多项式 //P53 附录A
//  497 //这是加罗瓦域2^8以    100011101         表示主模块多项式：
//  498 //X^8+X^4+X^3+X^2+1
//  499 /////////////////////////////////////////////////////////////////////////////

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  500 const BYTE byRSExp7[]  = {87, 229, 146, 149, 238, 102,  21};
byRSExp7:
        DC8 87, 229, 146, 149, 238, 102, 21, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  501 const BYTE byRSExp10[] = {251,  67,  46,  61, 118,  70,  64,  94,  32,  45};
byRSExp10:
        DC8 251, 67, 46, 61, 118, 70, 64, 94, 32, 45, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  502 const BYTE byRSExp13[] = { 74, 152, 176, 100,  86, 100, 106, 104, 130, 218, 206, 140,  78};
byRSExp13:
        DC8 74, 152, 176, 100, 86, 100, 106, 104, 130, 218, 206, 140, 78
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  503 const BYTE byRSExp15[] = {  8, 183,  61,  91, 202,  37,  51,  58,  58, 237, 140, 124,   5,  99, 105};
byRSExp15:
        DC8 8, 183, 61, 91, 202, 37, 51, 58, 58, 237, 140, 124, 5, 99, 105, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  504 const BYTE byRSExp16[] = {120, 104, 107, 109, 102, 161,  76,   3,  91, 191, 147, 169, 182, 194, 225, 120};
byRSExp16:
        DC8 120, 104, 107, 109, 102, 161, 76, 3, 91, 191, 147, 169, 182, 194
        DC8 225, 120

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  505 const BYTE byRSExp17[] = { 43, 139, 206,  78,  43, 239, 123, 206, 214, 147,  24,  99, 150,  39, 243, 163, 136};
byRSExp17:
        DC8 43, 139, 206, 78, 43, 239, 123, 206, 214, 147, 24, 99, 150, 39, 243
        DC8 163, 136, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  506 const BYTE byRSExp18[] = {215, 234, 158,  94, 184,  97, 118, 170,  79, 187, 152, 148, 252, 179,   5,  98,  96, 153};
byRSExp18:
        DC8 215, 234, 158, 94, 184, 97, 118, 170, 79, 187, 152, 148, 252, 179
        DC8 5, 98, 96, 153, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  507 const BYTE byRSExp20[] = { 17,  60,  79,  50,  61, 163,  26, 187, 202, 180, 221, 225,  83, 239, 156, 164, 212, 212, 188, 190};
byRSExp20:
        DC8 17, 60, 79, 50, 61, 163, 26, 187, 202, 180, 221, 225, 83, 239, 156
        DC8 164, 212, 212, 188, 190

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  508 const BYTE byRSExp22[] = {210, 171, 247, 242,  93, 230,  14, 109, 221,  53, 200,  74,   8, 172,  98,  80, 219, 134, 160, 105,
byRSExp22:
        DC8 210, 171, 247, 242, 93, 230, 14, 109, 221, 53, 200, 74, 8, 172, 98
        DC8 80, 219, 134, 160, 105, 165, 231, 0, 0
//  509 						   165, 231};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  510 const BYTE byRSExp24[] = {229, 121, 135,  48, 211, 117, 251, 126, 159, 180, 169, 152, 192, 226, 228, 218, 111,   0, 117, 232,
byRSExp24:
        DC8 229, 121, 135, 48, 211, 117, 251, 126, 159, 180, 169, 152, 192, 226
        DC8 228, 218, 111, 0, 117, 232, 87, 96, 227, 21
//  511 						    87,  96, 227,  21};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  512 const BYTE byRSExp26[] = {173, 125, 158,   2, 103, 182, 118,  17, 145, 201, 111,  28, 165,  53, 161,  21, 245, 142,  13, 102,
byRSExp26:
        DC8 173, 125, 158, 2, 103, 182, 118, 17, 145, 201, 111, 28, 165, 53
        DC8 161, 21, 245, 142, 13, 102, 48, 227, 153, 145, 218, 70, 0, 0
//  513 						    48, 227, 153, 145, 218,  70};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  514 const BYTE byRSExp28[] = {168, 223, 200, 104, 224, 234, 108, 180, 110, 190, 195, 147, 205,  27, 232, 201,  21,  43, 245,  87,
byRSExp28:
        DC8 168, 223, 200, 104, 224, 234, 108, 180, 110, 190, 195, 147, 205, 27
        DC8 232, 201, 21, 43, 245, 87, 42, 195, 212, 119, 242, 37, 9, 123
//  515 						    42, 195, 212, 119, 242,  37,   9, 123};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  516 const BYTE byRSExp30[] = { 41, 173, 145, 152, 216,  31, 179, 182,  50,  48, 110,  86, 239,  96, 222, 125,  42, 173, 226, 193,
byRSExp30:
        DC8 41, 173, 145, 152, 216, 31, 179, 182, 50, 48, 110, 86, 239, 96, 222
        DC8 125, 42, 173, 226, 193, 224, 130, 156, 37, 251, 216, 238, 40, 192
        DC8 180, 0, 0
//  517 						   224, 130, 156,  37, 251, 216, 238,  40, 192, 180};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  518 const BYTE byRSExp32[] = { 10,   6, 106, 190, 249, 167,   4,  67, 209, 138, 138,  32, 242, 123,  89,  27, 120, 185,  80, 156,
byRSExp32:
        DC8 10, 6, 106, 190, 249, 167, 4, 67, 209, 138, 138, 32, 242, 123, 89
        DC8 27, 120, 185, 80, 156, 38, 69, 171, 60, 28, 222, 80, 52, 254, 185
        DC8 220, 241
//  519 						    38,  69, 171,  60,  28, 222,  80,  52, 254, 185, 220, 241};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  520 const BYTE byRSExp34[] = {111,  77, 146,  94,  26,  21, 108,  19, 105,  94, 113, 193,  86, 140, 163, 125,  58, 158, 229, 239,
byRSExp34:
        DC8 111, 77, 146, 94, 26, 21, 108, 19, 105, 94, 113, 193, 86, 140, 163
        DC8 125, 58, 158, 229, 239, 218, 103, 56, 70, 114, 61, 183, 129, 167
        DC8 13, 98, 62, 129, 51, 0, 0
//  521 						   218, 103,  56,  70, 114,  61, 183, 129, 167,  13,  98,  62, 129,  51};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  522 const BYTE byRSExp36[] = {200, 183,  98,  16, 172,  31, 246, 234,  60, 152, 115,   0, 167, 152, 113, 248, 238, 107,  18,  63,
byRSExp36:
        DC8 200, 183, 98, 16, 172, 31, 246, 234, 60, 152, 115, 0, 167, 152, 113
        DC8 248, 238, 107, 18, 63, 218, 37, 87, 210, 105, 177, 120, 74, 121
        DC8 196, 117, 251, 113, 233, 30, 120
//  523 						   218,  37,  87, 210, 105, 177, 120,  74, 121, 196, 117, 251, 113, 233,  30, 120};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  524 const BYTE byRSExp38[] = {159,  34,  38, 228, 230,  59, 243,  95,  49, 218, 176, 164,  20,  65,  45, 111,  39,  81,  49, 118,
byRSExp38:
        DC8 159, 34, 38, 228, 230, 59, 243, 95, 49, 218, 176, 164, 20, 65, 45
        DC8 111, 39, 81, 49, 118, 113, 222, 193, 250, 242, 168, 217, 41, 164
        DC8 247, 177, 30, 238, 18, 120, 153, 60, 193, 0, 0
//  525 						   113, 222, 193, 250, 242, 168, 217,  41, 164, 247, 177,  30, 238,  18, 120, 153,  60, 193};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  526 const BYTE byRSExp40[] = { 59, 116,  79, 161, 252,  98, 128, 205, 128, 161, 247,  57, 163,  56, 235, 106,  53,  26, 187, 174,
byRSExp40:
        DC8 59, 116, 79, 161, 252, 98, 128, 205, 128, 161, 247, 57, 163, 56
        DC8 235, 106, 53, 26, 187, 174, 226, 104, 170, 7, 175, 35, 181, 114, 88
        DC8 41, 47, 163, 125, 134, 72, 20, 232, 53, 35, 15
//  527 						   226, 104, 170,   7, 175,  35, 181, 114,  88,  41,  47, 163, 125, 134,  72,  20, 232,  53,  35,  15};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  528 const BYTE byRSExp42[] = {250, 103, 221, 230,  25,  18, 137, 231,   0,   3,  58, 242, 221, 191, 110,  84, 230,   8, 188, 106,
byRSExp42:
        DC8 250, 103, 221, 230, 25, 18, 137, 231, 0, 3, 58, 242, 221, 191, 110
        DC8 84, 230, 8, 188, 106, 96, 147, 15, 131, 139, 34, 101, 223, 39, 101
        DC8 213, 199, 237, 254, 201, 123, 171, 162, 194, 117, 50, 96, 0, 0
//  529 						    96, 147,  15, 131, 139,  34, 101, 223,  39, 101, 213, 199, 237, 254, 201, 123, 171, 162, 194, 117,
//  530 						    50,  96};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  531 const BYTE byRSExp44[] = {190,   7,  61, 121,  71, 246,  69,  55, 168, 188,  89, 243, 191,  25,  72, 123,   9, 145,  14, 247,
byRSExp44:
        DC8 190, 7, 61, 121, 71, 246, 69, 55, 168, 188, 89, 243, 191, 25, 72
        DC8 123, 9, 145, 14, 247, 1, 238, 44, 78, 143, 62, 224, 126, 118, 114
        DC8 68, 163, 52, 194, 217, 147, 204, 169, 37, 130, 113, 102, 73, 181
//  532 						     1, 238,  44,  78, 143,  62, 224, 126, 118, 114,  68, 163,  52, 194, 217, 147, 204, 169,  37, 130,
//  533 						   113, 102,  73, 181};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  534 const BYTE byRSExp46[] = {112,  94,  88, 112, 253, 224, 202, 115, 187,  99,  89,   5,  54, 113, 129,  44,  58,  16, 135, 216,
byRSExp46:
        DC8 112, 94, 88, 112, 253, 224, 202, 115, 187, 99, 89, 5, 54, 113, 129
        DC8 44, 58, 16, 135, 216, 169, 211, 36, 1, 4, 96, 60, 241, 73, 104, 234
        DC8 8, 249, 245, 119, 174, 52, 25, 157, 224, 43, 202, 223, 19, 82, 15
        DC8 0, 0
//  535 						   169, 211,  36,   1,   4,  96,  60, 241,  73, 104, 234,   8, 249, 245, 119, 174,  52,  25, 157, 224,
//  536 						    43, 202, 223,  19,  82,  15};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  537 const BYTE byRSExp48[] = {228,  25, 196, 130, 211, 146,  60,  24, 251,  90,  39, 102, 240,  61, 178,  63,  46, 123, 115,  18,
byRSExp48:
        DC8 228, 25, 196, 130, 211, 146, 60, 24, 251, 90, 39, 102, 240, 61, 178
        DC8 63, 46, 123, 115, 18, 221, 111, 135, 160, 182, 205, 107, 206, 95
        DC8 150, 120, 184, 91, 21, 247, 156, 140, 238, 191, 11, 94, 227, 84, 50
        DC8 163, 39, 34, 108
//  538 						   221, 111, 135, 160, 182, 205, 107, 206,  95, 150, 120, 184,  91,  21, 247, 156, 140, 238, 191,  11,
//  539 						    94, 227,  84,  50, 163,  39,  34, 108};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  540 const BYTE byRSExp50[] = {232, 125, 157, 161, 164,   9, 118,  46, 209,  99, 203, 193,  35,   3, 209, 111, 195, 242, 203, 225,
byRSExp50:
        DC8 232, 125, 157, 161, 164, 9, 118, 46, 209, 99, 203, 193, 35, 3, 209
        DC8 111, 195, 242, 203, 225, 46, 13, 32, 160, 126, 209, 130, 160, 242
        DC8 215, 242, 75, 77, 42, 189, 32, 113, 65, 124, 69, 228, 114, 235, 175
        DC8 124, 170, 215, 232, 133, 205, 0, 0
//  541 						    46,  13,  32, 160, 126, 209, 130, 160, 242, 215, 242,  75,  77,  42, 189,  32, 113,  65, 124,  69,
//  542 						   228, 114, 235, 175, 124, 170, 215, 232, 133, 205};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  543 const BYTE byRSExp52[] = {116,  50,  86, 186,  50, 220, 251,  89, 192,  46,  86, 127, 124,  19, 184, 233, 151, 215,  22,  14,
byRSExp52:
        DC8 116, 50, 86, 186, 50, 220, 251, 89, 192, 46, 86, 127, 124, 19, 184
        DC8 233, 151, 215, 22, 14, 59, 145, 37, 242, 203, 134, 254, 89, 190, 94
        DC8 59, 65, 124, 113, 100, 233, 235, 121, 22, 76, 86, 97, 39, 242, 200
        DC8 220, 101, 33, 239, 254, 116, 51
//  544 						    59, 145,  37, 242, 203, 134, 254,  89, 190,  94,  59,  65, 124, 113, 100, 233, 235, 121,  22,  76,
//  545 						    86,  97,  39, 242, 200, 220, 101,  33, 239, 254, 116,  51};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  546 const BYTE byRSExp54[] = {183,  26, 201,  87, 210, 221, 113,  21,  46,  65,  45,  50, 238, 184, 249, 225, 102,  58, 209, 218,
byRSExp54:
        DC8 183, 26, 201, 87, 210, 221, 113, 21, 46, 65, 45, 50, 238, 184, 249
        DC8 225, 102, 58, 209, 218, 109, 165, 26, 95, 184, 192, 52, 245, 35
        DC8 254, 238, 175, 172, 79, 123, 25, 122, 43, 120, 108, 215, 80, 128
        DC8 201, 235, 8, 153, 59, 101, 31, 198, 76, 31, 156, 0, 0
//  547 						   109, 165,  26,  95, 184, 192,  52, 245,  35, 254, 238, 175, 172,  79, 123,  25, 122,  43, 120, 108,
//  548 						   215,  80, 128, 201, 235,   8, 153,  59, 101,  31, 198,  76,  31, 156};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  549 const BYTE byRSExp56[] = {106, 120, 107, 157, 164, 216, 112, 116,   2,  91, 248, 163,  36, 201, 202, 229,   6, 144, 254, 155,
byRSExp56:
        DC8 106, 120, 107, 157, 164, 216, 112, 116, 2, 91, 248, 163, 36, 201
        DC8 202, 229, 6, 144, 254, 155, 135, 208, 170, 209, 12, 139, 127, 142
        DC8 182, 249, 177, 174, 190, 28, 10, 85, 239, 184, 101, 124, 152, 206
        DC8 96, 23, 163, 61, 27, 196, 247, 151, 154, 202, 207, 20, 61, 10
//  550 						   135, 208, 170, 209,  12, 139, 127, 142, 182, 249, 177, 174, 190,  28,  10,  85, 239, 184, 101, 124,
//  551 						   152, 206,  96,  23, 163,  61,  27, 196, 247, 151, 154, 202, 207,  20,  61,  10};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  552 const BYTE byRSExp58[] = { 82, 116,  26, 247,  66,  27,  62, 107, 252, 182, 200, 185, 235,  55, 251, 242, 210, 144, 154, 237,
byRSExp58:
        DC8 82, 116, 26, 247, 66, 27, 62, 107, 252, 182, 200, 185, 235, 55, 251
        DC8 242, 210, 144, 154, 237, 176, 141, 192, 248, 152, 249, 206, 85, 253
        DC8 142, 65, 165, 125, 23, 24, 30, 122, 240, 214, 6, 129, 218, 29, 145
        DC8 127, 134, 206, 245, 117, 29, 41, 63, 159, 142, 233, 125, 148, 123
        DC8 0, 0
//  553 						   176, 141, 192, 248, 152, 249, 206,  85, 253, 142,  65, 165, 125,  23,  24,  30, 122, 240, 214,   6,
//  554 						   129, 218,  29, 145, 127, 134, 206, 245, 117,  29,  41,  63, 159, 142, 233, 125, 148, 123};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  555 const BYTE byRSExp60[] = {107, 140,  26,  12,   9, 141, 243, 197, 226, 197, 219,  45, 211, 101, 219, 120,  28, 181, 127,   6,
byRSExp60:
        DC8 107, 140, 26, 12, 9, 141, 243, 197, 226, 197, 219, 45, 211, 101
        DC8 219, 120, 28, 181, 127, 6, 100, 247, 2, 205, 198, 57, 115, 219, 101
        DC8 109, 160, 82, 37, 38, 238, 49, 160, 209, 121, 86, 11, 124, 30, 181
        DC8 84, 25, 194, 87, 65, 102, 190, 220, 70, 27, 209, 16, 89, 7, 33, 240
//  556 						   100, 247,   2, 205, 198,  57, 115, 219, 101, 109, 160,  82,  37,  38, 238,  49, 160, 209, 121,  86,
//  557 						    11, 124,  30, 181,  84,  25, 194,  87,  65, 102, 190, 220,  70,  27, 209,  16,  89,   7,  33, 240};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  558 const BYTE byRSExp62[] = { 65, 202, 113,  98,  71, 223, 248, 118, 214,  94,   0, 122,  37,  23,   2, 228,  58, 121,   7, 105,
byRSExp62:
        DC8 65, 202, 113, 98, 71, 223, 248, 118, 214, 94, 0, 122, 37, 23, 2
        DC8 228, 58, 121, 7, 105, 135, 78, 243, 118, 70, 76, 223, 89, 72, 50
        DC8 70, 111, 194, 17, 212, 126, 181, 35, 221, 117, 235, 11, 229, 149
        DC8 147, 123, 213, 40, 115, 6, 200, 100, 26, 246, 182, 218, 127, 215
        DC8 36, 186, 110, 106, 0, 0
//  559 						   135,  78, 243, 118,  70,  76, 223,  89,  72,  50,  70, 111, 194,  17, 212, 126, 181,  35, 221, 117,
//  560 						   235,  11, 229, 149, 147, 123, 213,  40, 115,   6, 200, 100,  26, 246, 182, 218, 127, 215,  36, 186,
//  561 						   110, 106};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  562 const BYTE byRSExp64[] = { 45,  51, 175,   9,   7, 158, 159,  49,  68, 119,  92, 123, 177, 204, 187, 254, 200,  78, 141, 149,
byRSExp64:
        DC8 45, 51, 175, 9, 7, 158, 159, 49, 68, 119, 92, 123, 177, 204, 187
        DC8 254, 200, 78, 141, 149, 119, 26, 127, 53, 160, 93, 199, 212, 29, 24
        DC8 145, 156, 208, 150, 218, 209, 4, 216, 91, 47, 184, 146, 47, 140
        DC8 195, 195, 125, 242, 238, 63, 99, 108, 140, 230, 242, 31, 204, 11
        DC8 178, 243, 217, 156, 213, 231
//  563 						   119,  26, 127,  53, 160,  93, 199, 212,  29,  24, 145, 156, 208, 150, 218, 209,   4, 216,  91,  47,
//  564 						   184, 146,  47, 140, 195, 195, 125, 242, 238,  63,  99, 108, 140, 230, 242,  31, 204,  11, 178, 243,
//  565 						   217, 156, 213, 231};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  566 const BYTE byRSExp66[] = {  5, 118, 222, 180, 136, 136, 162,  51,  46, 117,  13, 215,  81,  17, 139, 247, 197, 171,  95, 173,
byRSExp66:
        DC8 5, 118, 222, 180, 136, 136, 162, 51, 46, 117, 13, 215, 81, 17, 139
        DC8 247, 197, 171, 95, 173, 65, 137, 178, 68, 111, 95, 101, 41, 72, 214
        DC8 169, 197, 95, 7, 44, 154, 77, 111, 236, 40, 121, 143, 63, 87, 80
        DC8 253, 240, 126, 217, 77, 34, 232, 106, 50, 168, 82, 76, 146, 67, 106
        DC8 171, 25, 132, 93, 45, 105, 0, 0
//  567 						    65, 137, 178,  68, 111,  95, 101,  41,  72, 214, 169, 197,  95,   7,  44, 154,  77, 111, 236,  40,
//  568 						   121, 143,  63,  87,  80, 253, 240, 126, 217,  77,  34, 232, 106,  50, 168,  82,  76, 146,  67, 106,
//  569 						   171,  25, 132,  93,  45, 105};

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
//  570 const BYTE byRSExp68[] = {247, 159, 223,  33, 224,  93,  77,  70,  90, 160,  32, 254,  43, 150,  84, 101, 190, 205, 133,  52,
byRSExp68:
        DC8 247, 159, 223, 33, 224, 93, 77, 70, 90, 160, 32, 254, 43, 150, 84
        DC8 101, 190, 205, 133, 52, 60, 202, 165, 220, 203, 151, 93, 84, 15, 84
        DC8 253, 173, 160, 89, 227, 52, 199, 97, 95, 231, 52, 177, 41, 125, 137
        DC8 241, 166, 225, 118, 2, 54, 32, 82, 215, 175, 198, 43, 238, 235, 27
        DC8 101, 184, 127, 3, 5, 8, 163, 238
//  571 						    60, 202, 165, 220, 203, 151,  93,  84,  15,  84, 253, 173, 160,  89, 227,  52, 199,  97,  95, 231,
//  572 						    52, 177,  41, 125, 137, 241, 166, 225, 118,   2,  54,  32,  82, 215, 175, 198,  43, 238, 235,  27,
//  573 						   101, 184, 127,   3,   5,   8, 163, 238};
//  574 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  575 const BYTE *byRSExp[] = {NULL,      NULL,      NULL,      NULL,      NULL,      NULL,      NULL,      byRSExp7,  NULL,      NULL,
byRSExp:
        DATA
        DC32 0H, 0H, 0H, 0H, 0H, 0H, 0H, byRSExp7, 0H, 0H, byRSExp10, 0H, 0H
        DC32 byRSExp13, 0H, byRSExp15, byRSExp16, byRSExp17, byRSExp18, 0H
        DC32 byRSExp20, 0H, byRSExp22, 0H, byRSExp24, 0H, byRSExp26, 0H
        DC32 byRSExp28, 0H, byRSExp30, 0H, byRSExp32, 0H, byRSExp34, 0H
        DC32 byRSExp36, 0H, byRSExp38, 0H, byRSExp40, 0H, byRSExp42, 0H
        DC32 byRSExp44, 0H, byRSExp46, 0H, byRSExp48, 0H, byRSExp50, 0H
        DC32 byRSExp52, 0H, byRSExp54, 0H, byRSExp56, 0H, byRSExp58, 0H
        DC32 byRSExp60, 0H, byRSExp62, 0H, byRSExp64, 0H, byRSExp66, 0H
        DC32 byRSExp68
//  576 							byRSExp10, NULL,      NULL,      byRSExp13, NULL,      byRSExp15, byRSExp16, byRSExp17, byRSExp18, NULL,
//  577 							byRSExp20, NULL,      byRSExp22, NULL,      byRSExp24, NULL,      byRSExp26, NULL,      byRSExp28, NULL,
//  578 							byRSExp30, NULL,      byRSExp32, NULL,      byRSExp34, NULL,      byRSExp36, NULL,      byRSExp38, NULL,
//  579 							byRSExp40, NULL,      byRSExp42, NULL,      byRSExp44, NULL,      byRSExp46, NULL,      byRSExp48, NULL,
//  580 							byRSExp50, NULL,      byRSExp52, NULL,      byRSExp54, NULL,      byRSExp56, NULL,      byRSExp58, NULL,
//  581 							byRSExp60, NULL,      byRSExp62, NULL,      byRSExp64, NULL,      byRSExp66, NULL,      byRSExp68};
//  582 
//  583 const BYTE nIndicatorLenNumeral[]  = {10, 12, 14};
//  584 const BYTE nIndicatorLenAlphabet[] = { 9, 11, 13};
//  585 const BYTE nIndicatorLen8Bit[]	   = { 8, 16, 16};
//  586 const BYTE nIndicatorLenKanji[]	   = { 8, 10, 12};
//  587 
//  588 int m_nSymbleSize;

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  589 BYTE m_byModuleData[MAX_MODULESIZE][MAX_MODULESIZE];
m_byModuleData:
        DS8 444
//  590 
//  591 int m_ncDataCodeWordBit;

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  592 BYTE m_byDataCodeWord[MAX_DATACODEWORD];
m_byDataCodeWord:
        DS8 400
//  593 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  594 int m_ncDataBlock;
//  595 BYTE m_byBlockMode[MAX_DATACODEWORD];
m_byBlockMode:
        DS8 400
//  596 BYTE m_nBlockLength[MAX_DATACODEWORD];
m_nBlockLength:
        DS8 400
m_ncDataBlock:
        DS8 4
//  597 
//  598 int m_ncAllCodeWord; 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  599 BYTE m_byAllCodeWord[MAX_ALLCODEWORD]; 
m_byAllCodeWord:
        DS8 400

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
//  600 BYTE m_byRSWork[MAX_CODEBLOCK];
m_byRSWork:
        DS8 156
//  601 
//  602 int m_nLevel;	
//  603 int m_nVersion;	

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  604 bool m_bAutoExtent;	
m_bAutoExtent:
        DS8 1
//  605 int m_nMaskingNo;
//  606 
//  607 //编码数据
//  608 //lpsSource 源数据

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function EncodeData
        THUMB
//  609 bool EncodeData(char *lpsSource)
//  610 {
EncodeData:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
//  611 	int i, j, nVersion=1, bAutoExtent=1, ncSource;
//  612 	int ncLength, nEncodeVersion, ncDataCodeWord, ncTerminater;
//  613 	BYTE byPaddingCode = 0xec;
//  614 	int nDataCwIndex = 0, ncBlock1, ncBlock2, ncBlockSum; 
//  615 	int nBlockNo = 0, ncDataCw1, ncDataCw2;
        LDR.W    R1,??DataTable40
        MOVS     R4,#+0
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOV      R5,R0
        MOVS     R6,#+0
        STR      R4,[R1, #+20]
//  616 	int ncRSCw1, ncRSCw2;
//  617 
//  618 	ncSource = 0;
//  619 	m_nLevel = 0;
//  620 	m_nMaskingNo = 0;
        STR      R4,[R1, #+28]
//  621 
//  622 	ncLength = ncSource > 0 ? ncSource : strlen(lpsSource);//计算要编码的数据的长度
          CFI FunCall strlen
        BL       strlen
//  623 	//uprintf("ncLength = %d\n",ncLength);
//  624 	if (ncLength == 0)
        CBZ.N    R0,??EncodeData_0
//  625 		return FALSE; 
//  626 
//  627 	nEncodeVersion = GetEncodeVersion(nVersion, lpsSource, ncLength);//计算编码数据需要的版本
        MOV      R2,R0
        MOV      R1,R5
        MOVS     R0,#+1
          CFI FunCall GetEncodeVersion
        BL       GetEncodeVersion
//  628 	//uprintf("nEncodeVersion = %d\n",nEncodeVersion);
//  629 	if (nEncodeVersion == 0)
        CBNZ.N   R0,??EncodeData_1
//  630 		return FALSE; 
??EncodeData_0:
        MOVS     R0,#+0
        B.N      ?Subroutine0
//  631 
//  632 	if (nVersion == 0)
//  633 	{
//  634 		m_nVersion = nEncodeVersion;
//  635 	}
//  636 	else
//  637 	{
//  638 		if (nEncodeVersion <= nVersion)
??EncodeData_1:
        CMP      R0,#+2
        IT       LT 
//  639 		{
//  640 			m_nVersion = nVersion;
        MOVLT    R0,#+1
//  641 		}
//  642 		else
//  643 		{
//  644 			if (bAutoExtent)
//  645 				m_nVersion = nEncodeVersion; 
        LDR.W    R1,??DataTable40
//  646 			else
//  647 				return FALSE; 
//  648 		}
//  649 	}
//  650 	//uprintf("m_nVersion = %d\n",m_nVersion);
//  651 	
//  652 	ncDataCodeWord = QR_VersonInfo[m_nVersion].ncDataCodeWord[m_nLevel];
        LDR.W    R8,??DataTable40_1
        STR      R0,[R1, #+24]
        MOVS     R5,#+74
        LDR      R0,[R1, #+24]
        MLA      R7,R5,R0,R8
        LDRH     R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  653 
//  654 	ncTerminater = min(4, (ncDataCodeWord * 8) - m_ncDataCodeWordBit);
        LDR      R0,[R1, #+12]
        LDR      R1,[SP, #+12]
        RSB      R2,R0,R1, LSL #+3
        CMP      R2,#+5
        ITE      GE 
        MOVGE    R2,#+4
//  655 
//  656 	if (ncTerminater > 0)
        CMPLT    R2,#+1
        BLT.N    ??EncodeData_2
//  657 		m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 0, ncTerminater);
        MOVS     R1,#+0
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR.W    R1,??DataTable40
        STR      R0,[R1, #+12]
//  658 
//  659 	for (i = (m_ncDataCodeWordBit + 7) / 8; i < ncDataCodeWord; ++i)
??EncodeData_2:
        LDR.W    R0,??DataTable40
        LDR      R0,[R0, #+12]
        ADDS     R0,R0,#+7
        ASRS     R1,R0,#+2
        ADD      R0,R0,R1, LSR #+29
        LDR      R1,[SP, #+12]
        ASRS     R0,R0,#+3
        CMP      R0,R1
        BGE.N    ??EncodeData_3
        LDR.W    R1,??DataTable41
        LDR      R2,[SP, #+12]
        ADDS     R1,R0,R1
        SUBS     R0,R2,R0
        MOVS     R2,#+236
        STRB     R2,[R1, #+0]
        B.N      ??EncodeData_4
//  660 	{
//  661 		m_byDataCodeWord[i] = byPaddingCode;
??EncodeData_5:
        STRB     R2,[R1, #+0]
//  662 
//  663 		byPaddingCode = (BYTE)(byPaddingCode == 0xec ? 0x11 : 0xec);
        CMP      R2,#+236
        BNE.N    ??EncodeData_6
??EncodeData_4:
        MOVS     R2,#+17
        B.N      ??EncodeData_7
??EncodeData_6:
        MOVS     R2,#+236
//  664 	}
??EncodeData_7:
        ADDS     R1,R1,#+1
        SUBS     R0,R0,#+1
        BNE.N    ??EncodeData_5
//  665 
//  666 	m_ncAllCodeWord = QR_VersonInfo[m_nVersion].ncAllCodeWord;
??EncodeData_3:
        LDRH     R1,[R7, #+2]
        LDR.W    R0,??DataTable40
//  667 	memset(m_byAllCodeWord, 0, m_ncAllCodeWord);
        LDR.W    R7,??DataTable41_1
        STR      R1,[R0, #+16]
        MOV      R0,R7
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
//  668 
//  669 	ncBlock1 = QR_VersonInfo[m_nVersion].RS_BlockInfo1[m_nLevel].ncRSBlock;
        LDR.W    R0,??DataTable40
        LDR      R0,[R0, #+20]
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R0,??DataTable40
        LDR      R0,[R0, #+24]
        MLA      R0,R5,R0,R8
        ADD      R0,R0,R1, LSL #+1
        LDRH     R5,[R0, #+26]
//  670 	ncBlock2 = QR_VersonInfo[m_nVersion].RS_BlockInfo2[m_nLevel].ncRSBlock;
        LDRH     R1,[R0, #+50]
        STR      R1,[SP, #+8]
//  671 	ncBlockSum = ncBlock1 + ncBlock2;
        ADDS     R1,R1,R5
        STR      R1,[SP, #+4]
//  672 
//  673 	ncDataCw1 = QR_VersonInfo[m_nVersion].RS_BlockInfo1[m_nLevel].ncDataCodeWord;
//  674 	ncDataCw2 = QR_VersonInfo[m_nVersion].RS_BlockInfo2[m_nLevel].ncDataCodeWord;
//  675 
//  676 	for (i = 0; i < ncBlock1; ++i)
        CMP      R5,#+1
        LDRH     R8,[R0, #+30]
        LDRH     R1,[R0, #+54]
        STR      R1,[SP, #+0]
        BLT.N    ??EncodeData_8
        MOV      R2,R5
        LDR.W    R9,??DataTable41
//  677 	{
//  678 		for (j = 0; j < ncDataCw1; ++j)
??EncodeData_9:
        MOVS     R1,#+0
        CMP      R8,#+1
        BLT.N    ??EncodeData_10
        ADD      R3,R4,R9
//  679 		{
//  680 			m_byAllCodeWord[(ncBlockSum * j) + nBlockNo] = m_byDataCodeWord[nDataCwIndex++];
??EncodeData_11:
        LDR      R12,[SP, #+4]
        LDRB     LR,[R3], #+1
        MLA      R12,R1,R12,R6
        ADDS     R4,R4,#+1
        STRB     LR,[R12, R7]
//  681 		}
        ADDS     R1,R1,#+1
        CMP      R1,R8
        BLT.N    ??EncodeData_11
//  682 
//  683 		++nBlockNo;
??EncodeData_10:
        ADDS     R6,R6,#+1
//  684 	}
        SUBS     R2,R2,#+1
        BNE.N    ??EncodeData_9
//  685 
//  686 	for (i = 0; i < ncBlock2; ++i)
??EncodeData_8:
        LDR      R1,[SP, #+8]
        CMP      R1,#+1
        BLT.N    ??EncodeData_12
        LDR      R1,[SP, #+4]
        LDR      R3,[SP, #+8]
        LDR.W    R9,??DataTable41
        MLA      R2,R8,R1,R7
//  687 	{
//  688 		for (j = 0; j < ncDataCw2; ++j)
??EncodeData_13:
        LDR      R12,[SP, #+0]
        MOVS     R1,#+0
        CMP      R12,#+1
        BLT.N    ??EncodeData_14
//  689 		{
//  690 			if (j < ncDataCw1)
??EncodeData_15:
        LDRB     R12,[R4, R9]
        ADDS     R4,R4,#+1
        CMP      R1,R8
        ITTTE    LT 
//  691 			{
//  692 				m_byAllCodeWord[(ncBlockSum * j) + nBlockNo] = m_byDataCodeWord[nDataCwIndex++];
        LDRLT    LR,[SP, #+4]
        MLALT    LR,R1,LR,R6
        STRBLT   R12,[LR, R7]
//  693 			}
//  694 			else
//  695 			{
//  696 				m_byAllCodeWord[(ncBlockSum * ncDataCw1) + i]  = m_byDataCodeWord[nDataCwIndex++];
        STRBGE   R12,[R2, #+0]
//  697 			}	
//  698 		}
        LDR      R12,[SP, #+0]
        ADDS     R1,R1,#+1
        CMP      R1,R12
        BLT.N    ??EncodeData_15
//  699 
//  700 		++nBlockNo;
??EncodeData_14:
        ADDS     R6,R6,#+1
//  701 	}
        ADDS     R2,R2,#+1
        SUBS     R3,R3,#+1
        BNE.N    ??EncodeData_13
//  702 
//  703 	ncRSCw1 = QR_VersonInfo[m_nVersion].RS_BlockInfo1[m_nLevel].ncAllCodeWord - ncDataCw1;
??EncodeData_12:
        LDRH     R1,[R0, #+28]
        SUB      R1,R1,R8
        STR      R1,[SP, #+20]
//  704 	ncRSCw2 = QR_VersonInfo[m_nVersion].RS_BlockInfo2[m_nLevel].ncAllCodeWord - ncDataCw2;
//  705 
//  706 	nDataCwIndex = 0;
        MOVS     R4,#+0
        LDRH     R0,[R0, #+52]
        LDR      R1,[SP, #+0]
        SUBS     R0,R0,R1
//  707 	nBlockNo = 0;
        MOVS     R6,#+0
        STR      R0,[SP, #+16]
//  708 
//  709 	for (i = 0; i < ncBlock1; ++i)
        CMP      R5,#+1
        BLT.N    ??EncodeData_16
        LDR      R10,[SP, #+12]
        LDR.W    R11,??DataTable41_2
        LDR.W    R9,??DataTable41
//  710 	{
//  711 		memset(m_byRSWork, 0, sizeof(m_byRSWork));
??EncodeData_17:
        MOVS     R1,#+153
        MOV      R0,R11
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
//  712 
//  713 		memmove(m_byRSWork, m_byDataCodeWord + nDataCwIndex, ncDataCw1);
        MOV      R2,R8
        ADD      R1,R4,R9
        MOV      R0,R11
          CFI FunCall __aeabi_memmove
        BL       __aeabi_memmove
//  714 
//  715 		GetRSCodeWord(m_byRSWork, ncDataCw1, ncRSCw1);
        LDR      R2,[SP, #+20]
        MOV      R1,R8
        MOV      R0,R11
          CFI FunCall GetRSCodeWord
        BL       GetRSCodeWord
//  716 
//  717 		for (j = 0; j < ncRSCw1; ++j)
        LDR      R0,[SP, #+20]
        MOVS     R1,#+0
        CMP      R0,#+1
        BLT.N    ??EncodeData_18
        MOV      R0,R11
//  718 		{
//  719 			m_byAllCodeWord[ncDataCodeWord + (ncBlockSum * j) + nBlockNo] = m_byRSWork[j];
??EncodeData_19:
        LDR      R2,[SP, #+4]
        LDRB     R3,[R0], #+1
        MLA      R2,R1,R2,R10
//  720 		}
        ADDS     R1,R1,#+1
        STRB     R3,[R2, R7]
        LDR      R2,[SP, #+20]
        CMP      R1,R2
        BLT.N    ??EncodeData_19
//  721 
//  722 		nDataCwIndex += ncDataCw1;
//  723 		++nBlockNo;
??EncodeData_18:
        ADDS     R6,R6,#+1
        ADD      R4,R8,R4
//  724 	}
        ADD      R10,R10,#+1
        SUBS     R5,R5,#+1
        BNE.N    ??EncodeData_17
//  725 
//  726 	for (i = 0; i < ncBlock2; ++i)
??EncodeData_16:
        LDR      R0,[SP, #+8]
        CMP      R0,#+1
        BLT.N    ??EncodeData_20
        LDR      R0,[SP, #+12]
        LDR.W    R11,??DataTable41_2
        LDR.W    R9,??DataTable41
        ADDS     R5,R6,R0
        LDR      R6,[SP, #+8]
//  727 	{
//  728 		memset(m_byRSWork, 0, sizeof(m_byRSWork));
??EncodeData_21:
        MOVS     R1,#+153
        MOV      R0,R11
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
//  729 
//  730 		memmove(m_byRSWork, m_byDataCodeWord + nDataCwIndex, ncDataCw2);
        LDR      R2,[SP, #+0]
        ADD      R1,R4,R9
        MOV      R0,R11
          CFI FunCall __aeabi_memmove
        BL       __aeabi_memmove
//  731 
//  732 		GetRSCodeWord(m_byRSWork, ncDataCw2, ncRSCw2);
        LDR      R2,[SP, #+16]
        LDR      R1,[SP, #+0]
        MOV      R0,R11
          CFI FunCall GetRSCodeWord
        BL       GetRSCodeWord
//  733 
//  734 		for (j = 0; j < ncRSCw2; ++j)
        LDR      R0,[SP, #+16]
        MOVS     R1,#+0
        CMP      R0,#+1
        BLT.N    ??EncodeData_22
        MOV      R0,R11
//  735 		{
//  736 			m_byAllCodeWord[ncDataCodeWord + (ncBlockSum * j) + nBlockNo] = m_byRSWork[j];
??EncodeData_23:
        LDR      R2,[SP, #+4]
        LDRB     R3,[R0], #+1
        MLA      R2,R1,R2,R5
//  737 		}
        ADDS     R1,R1,#+1
        STRB     R3,[R2, R7]
        LDR      R2,[SP, #+16]
        CMP      R1,R2
        BLT.N    ??EncodeData_23
//  738 
//  739 		nDataCwIndex += ncDataCw2;
??EncodeData_22:
        LDR      R0,[SP, #+0]
        ADDS     R4,R0,R4
//  740 		++nBlockNo;
//  741 	}
        ADDS     R5,R5,#+1
        SUBS     R6,R6,#+1
        BNE.N    ??EncodeData_21
//  742 
//  743 	m_nSymbleSize = m_nVersion * 4 + 17;
??EncodeData_20:
        LDR.W    R0,??DataTable40
        LDR.W    R1,??DataTable40
        LDR      R0,[R0, #+24]
        LSLS     R0,R0,#+2
        ADDS     R0,R0,#+17
        STR      R0,[R1, #+8]
//  744 
//  745 	FormatModule();
          CFI FunCall FormatModule
        BL       FormatModule
//  746 
//  747 	return TRUE;
        MOVS     R0,#+1
          CFI EndBlock cfiBlock0
        REQUIRE ?Subroutine0
        ;; // Fall through to label ?Subroutine0
//  748 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI NoFunction
          CFI NoCalls EncodeData
          CFI NoCalls EncodeSourceData
          CFI CFA R13+64
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine0:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock1
//  749 //每个版本长度字段的位数
//  750 //nVersion	版本
//  751 //lpsSource	源数据
//  752 //ncLength	长度
//  753 /*
//  754 Number of bits per length field
//  755 Encoding		Ver.1C9		10C26		27C40
//  756 Numeric			10			12			14
//  757 Alphanumeric	9			11			13
//  758 Byte			8			16			16
//  759 Kanji			8			10			12 
//  760 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function GetEncodeVersion
        THUMB
//  761 int GetEncodeVersion(int nVersion, char *lpsSource, int ncLength)
//  762 {
GetEncodeVersion:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        MOV      R4,R1
        MOV      R5,R2
//  763 	int nVerGroup = nVersion >= 27 ? QR_VRESION_L : (nVersion >= 10 ? QR_VRESION_M : QR_VRESION_S);
        CMP      R0,#+27
        IT       GE 
        MOVGE    R6,#+2
        BGE.N    ??GetEncodeVersion_0
        CMP      R0,#+10
        ITE      GE 
        MOVGE    R6,#+1
        MOVLT    R6,#+0
//  764 	int i, j;
//  765 
//  766 	for (i = nVerGroup; i <= QR_VRESION_L; ++i)
//  767 	{
//  768 		if (EncodeSourceData(lpsSource, ncLength, i))
??GetEncodeVersion_0:
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall EncodeSourceData
        BL       EncodeSourceData
        CMP      R0,#+0
        BEQ.N    ??GetEncodeVersion_1
//  769 		{
//  770 			if (i == QR_VRESION_S)
        CBNZ.N   R6,??GetEncodeVersion_2
//  771 			{
//  772 				for (j = 1; j <= 9; ++j)
        LDR.W    R2,??DataTable40
        LDR.W    R3,??DataTable40_1
        LDR      R1,[R2, #+20]
        ADD      R1,R3,R1, LSL #+1
        ADDW     R7,R1,#+78
        LDR      R1,[R2, #+12]
        MOVS     R0,#+1
        ADDS     R1,R1,#+7
//  773 				{
//  774 					if ((m_ncDataCodeWordBit + 7) / 8 <= QR_VersonInfo[j].ncDataCodeWord[m_nLevel])
??GetEncodeVersion_3:
        ASRS     R2,R1,#+2
        ADD      R2,R1,R2, LSR #+29
        ASRS     R3,R2,#+3
        LDRH     R2,[R7], #+74
        CMP      R2,R3
        ITTT     LT 
        ADDLT    R0,R0,#+1
        LDRHLT   R2,[R7], #+74
        CMPLT    R2,R3
        ITTT     LT 
        ADDLT    R0,R0,#+1
        LDRHLT   R2,[R7], #+74
        CMPLT    R2,R3
        BGE.N    ??GetEncodeVersion_4
//  775 						return j;
//  776 				}
        ADDS     R0,R0,#+1
        CMP      R0,#+10
        BLT.N    ??GetEncodeVersion_3
        B.N      ??GetEncodeVersion_1
//  777 			}
//  778 			else if (i == QR_VRESION_M)
??GetEncodeVersion_2:
        CMP      R6,#+1
        BNE.N    ??GetEncodeVersion_5
//  779 			{
//  780 				for (j = 10; j <= 26; ++j)
        LDR.W    R2,??DataTable40
//  781 				{
//  782 					if ((m_ncDataCodeWordBit + 7) / 8 <= QR_VersonInfo[j].ncDataCodeWord[m_nLevel])
        LDR.W    R7,??DataTable40_1
        LDR      R1,[R2, #+12]
        LDR      R2,[R2, #+20]
        ADD      R2,R7,R2, LSL #+1
        ADDS     R1,R1,#+7
        ASRS     R3,R1,#+2
        LDRH     R7,[R2, #+744]
        MOVS     R0,#+10
        ADD      R3,R1,R3, LSR #+29
        CMP      R7,R3, ASR #+3
        BGE.N    ??GetEncodeVersion_4
        MOVS     R0,#+11
        ADDW     R2,R2,#+818
??GetEncodeVersion_6:
        LDRH     R7,[R2], #+74
        CMP      R7,R3, ASR #+3
        ITTT     LT 
        ADDLT    R0,R0,#+1
        LDRHLT   R7,[R2], #+74
        CMPLT    R7,R3, ASR #+3
        BGE.N    ??GetEncodeVersion_4
//  783 						return j;
//  784 				}
        ADDS     R0,R0,#+1
        CMP      R0,#+27
        BLT.N    ??GetEncodeVersion_6
        B.N      ??GetEncodeVersion_1
//  785 			}
//  786 			else if (i == QR_VRESION_L)
??GetEncodeVersion_5:
        CMP      R6,#+2
        BNE.N    ??GetEncodeVersion_1
//  787 			{
//  788 				for (j = 27; j <= 40; ++j)
        LDR.W    R2,??DataTable40
        LDR.W    R3,??DataTable40_1
        LDR      R1,[R2, #+20]
        ADD      R1,R3,R1, LSL #+1
        ADDW     R7,R1,#+2002
        LDR      R1,[R2, #+12]
        MOVS     R0,#+27
        ADDS     R1,R1,#+7
//  789 				{
//  790 					if ((m_ncDataCodeWordBit + 7) / 8 <= QR_VersonInfo[j].ncDataCodeWord[m_nLevel])
??GetEncodeVersion_7:
        ASRS     R2,R1,#+2
        ADD      R2,R1,R2, LSR #+29
        ASRS     R3,R2,#+3
        LDRH     R2,[R7], #+74
        CMP      R2,R3
        ITTT     LT 
//  791 						return j;
        ADDLT    R0,R0,#+1
        LDRHLT   R2,[R7], #+74
        CMPLT    R2,R3
        BGE.N    ??GetEncodeVersion_4
//  792 				}
        ADDS     R0,R0,#+1
        CMP      R0,#+41
        BLT.N    ??GetEncodeVersion_7
//  793 			}
//  794 		}
//  795 	}
??GetEncodeVersion_1:
        ADDS     R6,R6,#+1
        CMP      R6,#+3
        BLT.N    ??GetEncodeVersion_0
//  796 	return 0;
        MOVS     R0,#+0
??GetEncodeVersion_4:
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock2
//  797 }
//  798 //模式指标，编码模式
//  799 //lpsSource 源数据
//  800 //ncLength	数据长度
//  801 //nVerGroup	版本组
//  802 //bool EncodeSourceData(char *lpsSource, int ncLength, int nVerGroup)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function EncodeSourceData
        THUMB
//  803 int EncodeSourceData(char *lpsSource, int ncLength, int nVerGroup)
//  804 {
EncodeSourceData:
        PUSH     {R0,R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+20
          CFI CFA R13+64
//  805 	int i, j;
//  806 	int ncSrcBits, ncDstBits;
//  807 	int nBlock = 0;
//  808 	int ncComplete = 0; 
//  809 	WORD wBinCode;
//  810 
//  811 	memset(m_nBlockLength, 0, sizeof(m_nBlockLength));
        LDR.W    R4,??DataTable44
        MOV      R6,R1
        MOVS     R5,#+0
        ADD      R0,R4,#+400
        STR      R5,[SP, #+4]
        STR      R0,[SP, #+16]
        MOV      R1,#+400
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
//  812 
//  813 	for (m_ncDataBlock = i = 0; i < ncLength; ++i)
        MOVS     R0,#+0
        STR      R0,[R4, #+800]
        SUBS     R1,R6,#+1
        B.N      ??EncodeSourceData_0
//  814 	{
//  815 		BYTE byMode;
//  816 
//  817 		if (i < ncLength - 1 && IsKanjiData(lpsSource[i], lpsSource[i + 1]))
//  818 			byMode = QR_MODE_KANJI;				//日文
//  819 		//else if(i < ncLength - 1 && IsChineseData(lpsSource[i], lpsSource[i + 1]))
//  820 			//byMode = QR_MODE_CHINESE;			//中文
//  821 		else if (IsNumeralData(lpsSource[i]))	
//  822 			byMode = QR_MODE_NUMERAL;			//数字
//  823 		else if (IsAlphabetData(lpsSource[i]))
//  824 			byMode = QR_MODE_ALPHABET;			//字符
??EncodeSourceData_1:
        MOVS     R2,#+1
//  825 		else
//  826 			byMode = QR_MODE_8BIT;				//字节
//  827 
//  828 		if (i == 0)
??EncodeSourceData_2:
        CBNZ.N   R0,??EncodeSourceData_3
//  829 			m_byBlockMode[0] = byMode;			//
        STRB     R2,[R4, #+0]
//  830 
//  831 		if (m_byBlockMode[m_ncDataBlock] != byMode)//如果前后两个数据的模式不一样
??EncodeSourceData_3:
        LDR      R3,[R4, #+800]
        LDRB     R7,[R3, R4]
        CMP      R7,R2
        BEQ.N    ??EncodeSourceData_4
//  832 			m_byBlockMode[++m_ncDataBlock] = byMode;
        ADDS     R3,R3,#+1
        STR      R3,[R4, #+800]
        STRB     R2,[R3, R4]
//  833 
//  834 		++m_nBlockLength[m_ncDataBlock];
??EncodeSourceData_4:
        LDR      R3,[R4, #+800]
        ADDS     R3,R3,R4
        LDRB     R7,[R3, #+400]
        ADDS     R7,R7,#+1
        STRB     R7,[R3, #+400]
//  835 
//  836 		if (byMode == QR_MODE_KANJI)//如果是日文模式，那么前后2个字节为一个汉字
        CMP      R2,#+3
        BNE.N    ??EncodeSourceData_5
//  837 		{
//  838 			++m_nBlockLength[m_ncDataBlock];
        ADDS     R2,R7,#+1
        STRB     R2,[R3, #+400]
//  839 			++i;
        ADDS     R0,R0,#+1
//  840 		}
??EncodeSourceData_5:
        ADDS     R0,R0,#+1
??EncodeSourceData_0:
        CMP      R0,R6
        BGE.N    ??EncodeSourceData_6
        LDR      R2,[SP, #+20]
        LDRSB    R2,[R0, R2]
        UXTB     R3,R2
        CMP      R0,R1
        BGE.N    ??EncodeSourceData_7
        LDR      R7,[SP, #+20]
        ADDS     R7,R0,R7
        SUB      LR,R3,#+129
        LDRB     R7,[R7, #+1]
        CMP      LR,#+31
        ITT      CS 
        SUBCS    LR,R3,#+224
        CMPCS    LR,#+12
        BCS.N    ??EncodeSourceData_7
        CMP      R7,#+64
        BLT.N    ??EncodeSourceData_7
        UXTB     R12,R2
        CMP      R12,#+159
        BNE.N    ??EncodeSourceData_8
        CMP      R7,#+253
        BLT.N    ??EncodeSourceData_9
??EncodeSourceData_7:
        SUB      R7,R3,#+48
        CMP      R7,#+10
        BCS.N    ??EncodeSourceData_10
        MOVS     R2,#+0
        B.N      ??EncodeSourceData_2
??EncodeSourceData_8:
        CMP      R12,#+235
        BNE.N    ??EncodeSourceData_9
        CMP      R7,#+192
        BGE.N    ??EncodeSourceData_7
??EncodeSourceData_9:
        MOVS     R2,#+3
        B.N      ??EncodeSourceData_2
??EncodeSourceData_10:
        SUBS     R3,R3,#+65
        CMP      R3,#+26
        BCC.N    ??EncodeSourceData_1
        UXTB     R2,R2
        CMP      R2,#+32
        IT       NE 
        CMPNE    R2,#+36
        BEQ.N    ??EncodeSourceData_1
        CMP      R2,#+37
        IT       NE 
        CMPNE    R2,#+42
        BEQ.N    ??EncodeSourceData_1
        CMP      R2,#+43
        IT       NE 
        CMPNE    R2,#+45
        BEQ.N    ??EncodeSourceData_1
        CMP      R2,#+46
        ITT      NE 
        CMPNE    R2,#+47
        CMPNE    R2,#+58
        BEQ.N    ??EncodeSourceData_1
        MOVS     R2,#+2
        B.N      ??EncodeSourceData_2
//  841 	}
//  842 
//  843 	++m_ncDataBlock;
??EncodeSourceData_6:
        LDR      R0,[R4, #+800]
        ADDS     R0,R0,#+1
??EncodeSourceData_11:
        STR      R0,[R4, #+800]
        B.N      ??EncodeSourceData_12
//  844 
//  845 	while (nBlock < m_ncDataBlock - 1)
//  846 	{
//  847 		int ncJoinFront, ncJoinBehind; 
//  848 		int nJoinPosition = 0; 
//  849 
//  850 		if ((m_byBlockMode[nBlock] == QR_MODE_NUMERAL  && m_byBlockMode[nBlock + 1] == QR_MODE_ALPHABET) ||
//  851 			(m_byBlockMode[nBlock] == QR_MODE_ALPHABET && m_byBlockMode[nBlock + 1] == QR_MODE_NUMERAL))
//  852 		{//如果前后2个数据块为字母和数字，可以合并成字母数字模式(字母模式包含了数字)  计算数据位流
//  853 			ncSrcBits = GetBitLength(m_byBlockMode[nBlock], m_nBlockLength[nBlock], nVerGroup) +
//  854 						GetBitLength(m_byBlockMode[nBlock + 1], m_nBlockLength[nBlock + 1], nVerGroup);
//  855 
//  856 			ncDstBits = GetBitLength(QR_MODE_ALPHABET, m_nBlockLength[nBlock] + m_nBlockLength[nBlock + 1], nVerGroup);
//  857 
//  858 			if (ncSrcBits > ncDstBits)
//  859 			{//如果合并前大于合并后长度
//  860 				if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_8BIT)
//  861 				{//判断之前的数据块是不是8bit模式，如果是的话合并数据(必须要有3个数据块以上判断)
//  862 					ncJoinFront = GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock - 1] + m_nBlockLength[nBlock], nVerGroup) +
//  863 								  GetBitLength(m_byBlockMode[nBlock + 1], m_nBlockLength[nBlock + 1], nVerGroup);
//  864 
//  865 					if (ncJoinFront > ncDstBits + GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock - 1], nVerGroup))
//  866 						ncJoinFront = 0; //如果合并后的数据超过长度 非法
//  867 				}
//  868 				else
//  869 					ncJoinFront = 0;//不满足合并的条件
//  870 
//  871 				if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_8BIT)
//  872 				{//如果后面的数据块为8bit模式，合并数据(必须要有3个数据块以上判断)
//  873 					ncJoinBehind = GetBitLength(m_byBlockMode[nBlock], m_nBlockLength[nBlock], nVerGroup) +
//  874 								   GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock + 1] + m_nBlockLength[nBlock + 2], nVerGroup);
//  875 
//  876 					if (ncJoinBehind > ncDstBits + GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock + 2], nVerGroup))
//  877 						ncJoinBehind = 0; //如果合并后的数据超过长度 非法
//  878 				}
//  879 				else
//  880 					ncJoinBehind = 0;//不满足合并的条件
//  881 
//  882 				if (ncJoinFront != 0 && ncJoinBehind != 0)//前后的数据块合并后都不为0
//  883 				{
//  884 					nJoinPosition = (ncJoinFront < ncJoinBehind) ? -1 : 1;//位置的标记，如果前面的小于后面的为-1；大于等于为1
//  885 				}
//  886 				else
//  887 				{//如果有一个或者都为0		如果前面不为0为-1；后面不为0为1  否则为0
//  888 					nJoinPosition = (ncJoinFront != 0) ? -1 : ((ncJoinBehind != 0) ? 1 : 0);
//  889 				}
//  890 
//  891 				if (nJoinPosition != 0)
//  892 				{//如果合并后的数据不为0
//  893 					if (nJoinPosition == -1)//前面有数据
//  894 					{
//  895 						m_nBlockLength[nBlock - 1] += m_nBlockLength[nBlock];
//  896 
//  897 						for (i = nBlock; i < m_ncDataBlock - 1; ++i)
//  898 						{
//  899 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  900 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  901 						}
//  902 					}
//  903 					else
//  904 					{//后面有数据
//  905 						m_byBlockMode[nBlock + 1] = QR_MODE_8BIT;//后面数据块为8BIT模式，将新的数据块模式定义成8BIT
//  906 						m_nBlockLength[nBlock + 1] += m_nBlockLength[nBlock + 2];//长度
//  907 
//  908 						for (i = nBlock + 2; i < m_ncDataBlock - 1; ++i)
//  909 						{
//  910 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  911 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  912 						}
//  913 					}
//  914 
//  915 					--m_ncDataBlock;
//  916 				}
//  917 				else
//  918 				{//合并后数据异常，或者不满足合并条件
//  919 					if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_ALPHABET)
//  920 					{//如果后面一块数据也是字母数字，合并数据
//  921 						m_nBlockLength[nBlock + 1] += m_nBlockLength[nBlock + 2];
//  922 
//  923 						for (i = nBlock + 2; i < m_ncDataBlock - 1; ++i)
//  924 						{
//  925 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  926 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  927 						}
//  928 
//  929 						--m_ncDataBlock;
//  930 					}
//  931 					//设置新数据块为字母数字
//  932 					m_byBlockMode[nBlock] = QR_MODE_ALPHABET;
//  933 					m_nBlockLength[nBlock] += m_nBlockLength[nBlock + 1];
//  934 
//  935 					for (i = nBlock + 1; i < m_ncDataBlock - 1; ++i)
//  936 					{
//  937 						m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  938 						m_nBlockLength[i] = m_nBlockLength[i + 1];
//  939 					}
//  940 
//  941 					--m_ncDataBlock;
//  942 					//如果前面一块数据也是字母数字，合并数据
//  943 					if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_ALPHABET)
//  944 					{
//  945 						m_nBlockLength[nBlock - 1] += m_nBlockLength[nBlock];
//  946 
//  947 						for (i = nBlock; i < m_ncDataBlock - 1; ++i)
//  948 						{
//  949 							m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  950 							m_nBlockLength[i] = m_nBlockLength[i + 1];
//  951 						}
//  952 
//  953 						--m_ncDataBlock;
//  954 					}
//  955 				}
//  956 
//  957 				continue;
//  958 			}
//  959 		}
//  960 
//  961 		++nBlock; 
??EncodeSourceData_13:
        ADDS     R5,R5,#+1
??EncodeSourceData_12:
        LDR      R0,[R4, #+800]
        SUBS     R6,R0,#+1
        CMP      R5,R6
        BGE.W    ??EncodeSourceData_14
        LDRB     R0,[R5, R4]
        STRB     R0,[SP, #+0]
        CMP      R0,#+0
        ITTT     EQ 
        ADDEQ    R0,R5,R4
        LDRBEQ   R0,[R0, #+1]
        CMPEQ    R0,#+1
        BEQ.N    ??EncodeSourceData_15
        LDRB     R0,[SP, #+0]
        CMP      R0,#+1
        ITTT     EQ 
        ADDEQ    R0,R5,R4
        LDRBEQ   R0,[R0, #+1]
        CMPEQ    R0,#+0
        BNE.N    ??EncodeSourceData_13
??EncodeSourceData_15:
        ADDS     R0,R5,R4
        ADDW     R7,R0,#+399
        LDR      R2,[SP, #+24]
        LDRB     R1,[R7, #+1]
        LDRB     R0,[SP, #+0]
          CFI FunCall GetBitLength
        BL       GetBitLength
        LDRB     R8,[R7, #+2]
        LDR      R2,[SP, #+24]
        MOV      R11,R0
        ADDS     R0,R5,R4
        MOV      R1,R8
        LDRB     R0,[R0, #+1]
          CFI FunCall GetBitLength
        BL       GetBitLength
        LDR      R2,[SP, #+24]
        STR      R0,[SP, #+8]
        LDRB     R0,[R7, #+1]
        ADD      R1,R8,R0
        MOVS     R0,#+1
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R10,R0
        LDR      R0,[SP, #+8]
        ADD      R0,R0,R11
        CMP      R10,R0
        BGE.N    ??EncodeSourceData_13
        CMP      R5,#+1
        BLT.N    ??EncodeSourceData_16
        ADDS     R0,R5,R4
        LDRB     R0,[R0, #-1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_16
        ADDS     R0,R5,R4
        LDRB     R1,[R7, #+1]
        LDRB     R0,[R0, #+399]
        LDR      R2,[SP, #+24]
        ADDS     R1,R1,R0
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R11,R0
        ADDS     R0,R5,R4
        LDR      R2,[SP, #+24]
        LDRB     R0,[R0, #+1]
        MOV      R1,R8
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R11,R0,R11
        ADDS     R0,R5,R4
        LDRB     R1,[R0, #+399]
        LDR      R2,[SP, #+24]
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R0,R0,R10
        CMP      R0,R11
        BGE.N    ??EncodeSourceData_17
??EncodeSourceData_16:
        MOV      R11,#+0
??EncodeSourceData_17:
        LDR      R0,[R4, #+800]
        SUBS     R0,R0,#+2
        STR      R0,[SP, #+8]
        CMP      R5,R0
        BGE.N    ??EncodeSourceData_18
        ADDS     R0,R5,R4
        ADDS     R0,R0,#+1
        LDRB     R0,[R0, #+1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_18
        LDR      R2,[SP, #+24]
        LDRB     R1,[R7, #+1]
        LDRB     R0,[SP, #+0]
          CFI FunCall GetBitLength
        BL       GetBitLength
        LDR      R2,[SP, #+24]
        STR      R0,[SP, #+0]
        LDRB     R0,[R7, #+3]
        ADD      R1,R0,R8
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        LDR      R1,[SP, #+0]
        LDR      R2,[SP, #+24]
        ADD      R9,R0,R1
        LDRB     R1,[R7, #+3]
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R0,R0,R10
        CMP      R0,R9
        BGE.N    ??EncodeSourceData_19
??EncodeSourceData_18:
        CMP      R11,#+0
        BNE.N    ??EncodeSourceData_20
        LDR      R0,[SP, #+8]
        CMP      R5,R0
        BGE.N    ??EncodeSourceData_21
        ADDS     R0,R5,R4
        ADDS     R0,R0,#+1
        LDRB     R0,[R0, #+1]
        CMP      R0,#+1
        BNE.N    ??EncodeSourceData_21
        LDRB     R0,[R7, #+3]
        ADD      R0,R0,R8
        STRB     R0,[R7, #+2]
        ADDS     R0,R5,#+2
        CMP      R0,R6
        BGE.N    ??EncodeSourceData_22
        ADDS     R1,R0,R4
        ADDS     R0,R0,R4
        SUBS     R2,R6,R5
        ADD      R0,R0,#+400
        SUBS     R2,R2,#+2
??EncodeSourceData_23:
        SUBS     R2,R2,#+1
        LDRB     R3,[R1, #+1]
        STRB     R3,[R1], #+1
        LDRB     R3,[R0, #+1]
        STRB     R3,[R0], #+1
        BNE.N    ??EncodeSourceData_23
??EncodeSourceData_22:
        STR      R6,[R4, #+800]
??EncodeSourceData_21:
        MOVS     R0,#+1
        STRB     R0,[R5, R4]
        LDRB     R1,[R7, #+2]
        LDRB     R0,[R7, #+1]
        ADDS     R0,R1,R0
        STRB     R0,[R7, #+1]
        ADDS     R0,R5,#+1
        LDR      R2,[R4, #+800]
        SUBS     R1,R2,#+1
        CMP      R0,R1
        BGE.N    ??EncodeSourceData_24
        ADDS     R3,R0,R4
        ADDS     R0,R0,R4
        SUBS     R2,R2,R5
        ADD      R0,R0,#+400
        SUBS     R2,R2,#+2
??EncodeSourceData_25:
        SUBS     R2,R2,#+1
        LDRB     R6,[R3, #+1]
        STRB     R6,[R3], #+1
        LDRB     R6,[R0, #+1]
        STRB     R6,[R0], #+1
        BNE.N    ??EncodeSourceData_25
??EncodeSourceData_24:
        STR      R1,[R4, #+800]
        CMP      R5,#+1
        BLT.W    ??EncodeSourceData_12
        ADDS     R0,R5,R4
        LDRB     R0,[R0, #-1]
        CMP      R0,#+1
        BNE.W    ??EncodeSourceData_12
        ADDS     R0,R5,R4
        LDRB     R2,[R7, #+1]
        LDRB     R0,[R0, #+399]
        ADDS     R0,R2,R0
        ADDS     R2,R5,R4
        STRB     R0,[R2, #+399]
        SUBS     R0,R1,#+1
        CMP      R5,R0
        BGE.N    ??EncodeSourceData_26
        ADDS     R1,R5,R4
        ADD      R2,R2,#+400
        SUBS     R0,R0,R5
??EncodeSourceData_27:
        SUBS     R0,R0,#+1
        LDRB     R3,[R1, #+1]
        STRB     R3,[R1], #+1
        LDRB     R3,[R2, #+1]
        STRB     R3,[R2], #+1
        BNE.N    ??EncodeSourceData_27
??EncodeSourceData_26:
        LDR      R0,[R4, #+800]
        SUBS     R0,R0,#+1
        B.N      ??EncodeSourceData_11
??EncodeSourceData_19:
        CMP      R11,#+0
        BEQ.N    ??EncodeSourceData_28
        CMP      R9,#+0
        BEQ.N    ??EncodeSourceData_20
        CMP      R11,R9
        BGE.N    ??EncodeSourceData_29
??EncodeSourceData_20:
        ADDS     R0,R5,R4
        LDRB     R1,[R7, #+1]
        LDRB     R0,[R0, #+399]
        ADDS     R0,R1,R0
        ADDS     R1,R5,R4
        SUBS     R2,R6,R5
        STRB     R0,[R1, #+399]
        ADD      R1,R1,#+400
        ADDS     R0,R5,R4
??EncodeSourceData_30:
        SUBS     R2,R2,#+1
        LDRB     R3,[R0, #+1]
        STRB     R3,[R0], #+1
        LDRB     R3,[R1, #+1]
        STRB     R3,[R1], #+1
        BNE.N    ??EncodeSourceData_30
        B.N      ??EncodeSourceData_26
??EncodeSourceData_28:
        CMP      R9,#+0
        BEQ.N    ??EncodeSourceData_21
??EncodeSourceData_29:
        ADDS     R1,R5,R4
        MOVS     R0,#+2
        STRB     R0,[R1, #+1]
        LDRB     R0,[R7, #+3]
        ADD      R0,R0,R8
        STRB     R0,[R7, #+2]
        ADDS     R0,R5,#+2
        CMP      R0,R6
        BGE.N    ??EncodeSourceData_26
        ADDS     R1,R0,R4
        ADDS     R0,R0,R4
        SUBS     R2,R6,R5
        ADD      R0,R0,#+400
        SUBS     R2,R2,#+2
??EncodeSourceData_31:
        LDRB     R3,[R1, #+1]
        STRB     R3,[R1], #+1
        SUBS     R2,R2,#+1
        LDRB     R3,[R0, #+1]
        STRB     R3,[R0], #+1
        BNE.N    ??EncodeSourceData_31
        B.N      ??EncodeSourceData_26
//  962 	}
//  963 
//  964 	nBlock = 0;
??EncodeSourceData_14:
        MOVS     R6,#+0
        B.N      ??EncodeSourceData_32
//  965 
//  966 	while (nBlock < m_ncDataBlock - 1)
//  967 	{//合并2个部分数据
//  968 		ncSrcBits = GetBitLength(m_byBlockMode[nBlock], m_nBlockLength[nBlock], nVerGroup)
//  969 					+ GetBitLength(m_byBlockMode[nBlock + 1], m_nBlockLength[nBlock + 1], nVerGroup);
//  970 
//  971 		ncDstBits = GetBitLength(QR_MODE_8BIT, m_nBlockLength[nBlock] + m_nBlockLength[nBlock + 1], nVerGroup);
//  972 
//  973 		if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_8BIT)//前一数据块为BIT模式
//  974 			ncDstBits -= (4 + nIndicatorLen8Bit[nVerGroup]);
//  975 
//  976 		if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_8BIT)
//  977 			ncDstBits -= (4 + nIndicatorLen8Bit[nVerGroup]);
//  978 		
//  979 		if (ncSrcBits > ncDstBits)
//  980 		{//如果合并后数据增加，前一块数据是8bit数据
//  981 			if (nBlock >= 1 && m_byBlockMode[nBlock - 1] == QR_MODE_8BIT)
//  982 			{
//  983 				m_nBlockLength[nBlock - 1] += m_nBlockLength[nBlock];
//  984 
//  985 				for (i = nBlock; i < m_ncDataBlock - 1; ++i)
//  986 				{
//  987 					m_byBlockMode[i]  = m_byBlockMode[i + 1];
//  988 					m_nBlockLength[i] = m_nBlockLength[i + 1];
//  989 				}
//  990 
//  991 				--m_ncDataBlock;
//  992 				--nBlock;
//  993 			}
//  994 
//  995 			if (nBlock < m_ncDataBlock - 2 && m_byBlockMode[nBlock + 2] == QR_MODE_8BIT)
//  996 			{//数据块+2也是8bit
//  997 				m_nBlockLength[nBlock + 1] += m_nBlockLength[nBlock + 2];
//  998 
//  999 				for (i = nBlock + 2; i < m_ncDataBlock - 1; ++i)
// 1000 				{
// 1001 					m_byBlockMode[i]  = m_byBlockMode[i + 1];
// 1002 					m_nBlockLength[i] = m_nBlockLength[i + 1];
// 1003 				}
// 1004 
// 1005 				--m_ncDataBlock;
// 1006 			}
// 1007 			//设置新的数据块为8BIT模式
// 1008 			m_byBlockMode[nBlock] = QR_MODE_8BIT;
// 1009 			m_nBlockLength[nBlock] += m_nBlockLength[nBlock + 1];
// 1010 
// 1011 			for (i = nBlock + 1; i < m_ncDataBlock - 1; ++i)
// 1012 			{
// 1013 				m_byBlockMode[i]  = m_byBlockMode[i + 1];
// 1014 				m_nBlockLength[i] = m_nBlockLength[i + 1];
// 1015 			}
// 1016 
// 1017 			--m_ncDataBlock;
// 1018 
// 1019 			if (nBlock >= 1)
// 1020 				--nBlock;
// 1021 
// 1022 			continue;
// 1023 		}
// 1024 
// 1025 		++nBlock; 
??EncodeSourceData_33:
        ADDS     R6,R6,#+1
??EncodeSourceData_32:
        LDR      R7,[R4, #+800]
        SUB      R8,R7,#+1
        CMP      R6,R8
        BGE.W    ??EncodeSourceData_34
        ADDS     R0,R6,R4
        ADDW     R10,R0,#+399
        LDRB     R5,[R10, #+1]
        LDR      R2,[SP, #+24]
        LDRB     R0,[R6, R4]
        MOV      R1,R5
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R9,R0
        ADDS     R0,R6,R4
        LDRB     R10,[R10, #+2]
        LDR      R2,[SP, #+24]
        LDRB     R0,[R0, #+1]
        MOV      R1,R10
          CFI FunCall GetBitLength
        BL       GetBitLength
        ADD      R9,R0,R9
        LDR      R2,[SP, #+24]
        ADD      R1,R10,R5
        MOVS     R0,#+2
          CFI FunCall GetBitLength
        BL       GetBitLength
        MOV      R10,R0
        CMP      R6,#+1
        BLT.N    ??EncodeSourceData_35
        ADDS     R0,R6,R4
        LDRB     R0,[R0, #-1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_35
        LDR      R0,[SP, #+24]
        ADR.W    R1,nIndicatorLen8Bit
        LDRB     R0,[R0, R1]
        SUB      R0,R10,R0
        SUB      R10,R0,#+4
??EncodeSourceData_35:
        SUBS     R0,R7,#+2
        CMP      R6,R0
        BGE.N    ??EncodeSourceData_36
        ADDS     R0,R6,R4
        LDRB     R0,[R0, #+2]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_36
        LDR      R0,[SP, #+24]
        ADR.W    R1,nIndicatorLen8Bit
        LDRB     R0,[R0, R1]
        SUB      R0,R10,R0
        SUB      R10,R0,#+4
??EncodeSourceData_36:
        CMP      R10,R9
        BGE.N    ??EncodeSourceData_33
        CMP      R6,#+1
        BLT.N    ??EncodeSourceData_37
        ADDS     R0,R6,R4
        LDRB     R0,[R0, #-1]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_37
        ADDS     R0,R6,R4
        ADDS     R1,R6,R4
        LDRB     R0,[R0, #+399]
        ADDS     R0,R5,R0
        STRB     R0,[R1, #+399]
        ADD      R1,R1,#+400
        ADDS     R0,R6,R4
        SUB      R2,R8,R6
??EncodeSourceData_38:
        SUBS     R2,R2,#+1
        LDRB     R3,[R0, #+1]
        STRB     R3,[R0], #+1
        LDRB     R3,[R1, #+1]
        STRB     R3,[R1], #+1
        BNE.N    ??EncodeSourceData_38
        STR      R8,[R4, #+800]
        SUBS     R6,R6,#+1
??EncodeSourceData_37:
        LDR      R1,[R4, #+800]
        SUBS     R0,R1,#+2
        CMP      R6,R0
        BGE.N    ??EncodeSourceData_39
        ADDS     R0,R6,R4
        LDRB     R0,[R0, #+2]
        CMP      R0,#+2
        BNE.N    ??EncodeSourceData_39
        ADDS     R0,R6,R4
        ADD      R0,R0,#+400
        LDRB     R2,[R0, #+1]
        LDRB     R3,[R0, #+2]
        ADDS     R2,R3,R2
        STRB     R2,[R0, #+1]
        ADDS     R0,R6,#+2
        SUBS     R1,R1,#+1
        CMP      R0,R1
        BGE.N    ??EncodeSourceData_40
        ADDS     R2,R0,R4
        ADDS     R0,R0,R4
        SUBS     R3,R1,R6
        ADD      R0,R0,#+400
        SUBS     R3,R3,#+2
??EncodeSourceData_41:
        SUBS     R3,R3,#+1
        LDRB     R5,[R2, #+1]
        STRB     R5,[R2], #+1
        LDRB     R5,[R0, #+1]
        STRB     R5,[R0], #+1
        BNE.N    ??EncodeSourceData_41
??EncodeSourceData_40:
        STR      R1,[R4, #+800]
??EncodeSourceData_39:
        MOVS     R0,#+2
        STRB     R0,[R6, R4]
        ADDS     R1,R6,R4
        ADDS     R0,R6,R4
        ADD      R1,R1,#+400
        LDRB     R0,[R0, #+400]
        LDRB     R1,[R1, #+1]
        ADDS     R0,R1,R0
        ADDS     R1,R6,R4
        STRB     R0,[R1, #+400]
        ADDS     R0,R6,#+1
        LDR      R1,[R4, #+800]
        SUBS     R2,R1,#+1
        CMP      R0,R2
        BGE.N    ??EncodeSourceData_42
        ADDS     R3,R0,R4
        ADDS     R0,R0,R4
        SUBS     R1,R1,R6
        ADD      R0,R0,#+400
        SUBS     R1,R1,#+2
??EncodeSourceData_43:
        LDRB     R5,[R3, #+1]
        STRB     R5,[R3], #+1
        SUBS     R1,R1,#+1
        LDRB     R5,[R0, #+1]
        STRB     R5,[R0], #+1
        BNE.N    ??EncodeSourceData_43
??EncodeSourceData_42:
        STR      R2,[R4, #+800]
        CMP      R6,#+1
        BLT.W    ??EncodeSourceData_32
        SUBS     R6,R6,#+1
        B.N      ??EncodeSourceData_32
// 1026 	}
// 1027 
// 1028 	m_ncDataCodeWordBit = 0; 
??EncodeSourceData_34:
        LDR.W    R5,??DataTable40
// 1029 
// 1030 	memset(m_byDataCodeWord, 0, MAX_DATACODEWORD);
        LDR.W    R6,??DataTable41
        MOVS     R0,#+0
        STR      R0,[R5, #+12]
        MOV      R1,#+400
        MOV      R0,R6
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 1031 
// 1032 	for (i = 0; i < m_ncDataBlock && m_ncDataCodeWordBit != -1; ++i)
        MOVS     R0,#+0
        STR      R0,[SP, #+12]
        STR      R4,[SP, #+8]
        MOVS     R7,#+1
        LDR      R0,[SP, #+16]
        STR      R0,[SP, #+0]
        B.N      ??EncodeSourceData_44
// 1033 	{
// 1034 		if (m_byBlockMode[i] == QR_MODE_NUMERAL)
// 1035 		{//如果数据块是数字模式
// 1036 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 1, 4); 
// 1037 
// 1038 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)m_nBlockLength[i], nIndicatorLenNumeral[nVerGroup]);
// 1039 
// 1040 			for (j = 0; j < m_nBlockLength[i]; j += 3)
// 1041 			{
// 1042 				if (j < m_nBlockLength[i] - 2)
// 1043 				{
// 1044 					wBinCode = (WORD)(((lpsSource[ncComplete + j]	  - '0') * 100) +
// 1045 									  ((lpsSource[ncComplete + j + 1] - '0') * 10) +
// 1046 									   (lpsSource[ncComplete + j + 2] - '0'));
// 1047 
// 1048 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 10);
// 1049 				}
// 1050 				else if (j == m_nBlockLength[i] - 2)
// 1051 				{
// 1052 					wBinCode = (WORD)(((lpsSource[ncComplete + j] - '0') * 10) +
// 1053 									   (lpsSource[ncComplete + j + 1] - '0'));
// 1054 
// 1055 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 7);
// 1056 				}
// 1057 				else if (j == m_nBlockLength[i] - 1)
// 1058 				{
// 1059 					wBinCode = (WORD)(lpsSource[ncComplete + j] - '0');
// 1060 
// 1061 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 4);
// 1062 				}
// 1063 			}
// 1064 
// 1065 			ncComplete += m_nBlockLength[i];
// 1066 		}
// 1067 
// 1068 		else if (m_byBlockMode[i] == QR_MODE_ALPHABET)
// 1069 		{
// 1070 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 2, 4);
// 1071 
// 1072 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)m_nBlockLength[i], nIndicatorLenAlphabet[nVerGroup]);
// 1073 
// 1074 			for (j = 0; j < m_nBlockLength[i]; j += 2)
// 1075 			{
// 1076 				if (j < m_nBlockLength[i] - 1)
// 1077 				{
// 1078 					wBinCode = (WORD)((AlphabetToBinaly(lpsSource[ncComplete + j]) * 45) +
// 1079 									   AlphabetToBinaly(lpsSource[ncComplete + j + 1]));
// 1080 
// 1081 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 11);
// 1082 				}
// 1083 				else
// 1084 				{
// 1085 					wBinCode = (WORD)AlphabetToBinaly(lpsSource[ncComplete + j]);
// 1086 
// 1087 					m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 6);
// 1088 				}
// 1089 			}
// 1090 
// 1091 			ncComplete += m_nBlockLength[i];
// 1092 		}
// 1093 
// 1094 		else if (m_byBlockMode[i] == QR_MODE_8BIT)
// 1095 		{
// 1096 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 4, 4);
// 1097 
// 1098 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)m_nBlockLength[i], nIndicatorLen8Bit[nVerGroup]);
// 1099 
// 1100 			for (j = 0; j < m_nBlockLength[i]; ++j)
// 1101 			{
// 1102 				m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)lpsSource[ncComplete + j], 8);
// 1103 			}
// 1104 
// 1105 			ncComplete += m_nBlockLength[i];
// 1106 		}
// 1107 		else// if(m_byBlockMode[i] == QR_MODE_KANJI)
// 1108 		{//日本模式
// 1109 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 8, 4);
// 1110 
// 1111 			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)(m_nBlockLength[i] / 2), nIndicatorLenKanji[nVerGroup]);
// 1112 
// 1113 			for (j = 0; j < m_nBlockLength[i] / 2; ++j)
// 1114 			{
// 1115 				WORD wBinCode = KanjiToBinaly((WORD)(((BYTE)lpsSource[ncComplete + (j * 2)] << 8) + (BYTE)lpsSource[ncComplete + (j * 2) + 1]));
// 1116 
// 1117 				m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 13);
// 1118 			}
// 1119 
// 1120 			ncComplete += m_nBlockLength[i];
??EncodeSourceData_45:
        LDR      R1,[SP, #+0]
        LDR      R0,[SP, #+4]
        ADDS     R1,R1,#+1
        STR      R1,[SP, #+0]
        SUBS     R1,R1,#+1
        LDRB     R1,[R1, #+0]
        ADDS     R0,R1,R0
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+12]
        ADDS     R0,R0,#+1
        STR      R0,[SP, #+12]
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[SP, #+8]
??EncodeSourceData_44:
        LDR      R1,[SP, #+12]
        LDR      R2,[R4, #+800]
        LDR      R0,[R5, #+12]
        CMP      R1,R2
        BGE.W    ??EncodeSourceData_46
        CMN      R0,#+1
        BEQ.W    ??EncodeSourceData_47
        LDR      R1,[SP, #+8]
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.W    ??EncodeSourceData_48
        MOVS     R2,#+4
        MOVS     R1,#+1
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLenNumeral
        LDRB     R2,[R1, R2]
        LDR      R1,[SP, #+0]
        LDRB     R1,[R1, #+0]
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R2,[SP, #+20]
        STR      R0,[R5, #+12]
        MOVS     R1,#+0
        LDR      R0,[SP, #+4]
        ADDS     R2,R0,R2
        B.N      ??EncodeSourceData_49
??EncodeSourceData_50:
        MOV      R9,#-1
??EncodeSourceData_51:
        STR      R9,[R5, #+12]
??EncodeSourceData_52:
        ADDS     R1,R1,#+3
        ADDS     R2,R2,#+3
??EncodeSourceData_49:
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+0]
        CMP      R1,R0
        BGE.N    ??EncodeSourceData_45
        SUBS     R3,R0,#+2
        CMP      R1,R3
        BGE.N    ??EncodeSourceData_53
        LDRSB    R12,[R2, #+1]
        LDRSB    R0,[R2, #+0]
        ADD      LR,R12,R12, LSL #+2
        MOVS     R3,#+100
        LSL      R12,LR,#+1
        MLA      R0,R3,R0,R12
        LDRSB    R3,[R2, #+2]
        LDR      R12,[R5, #+12]
        ADDS     R0,R3,R0
        MOVW     R3,#+5328
        SUBS     R3,R0,R3
        CMN      R12,#+1
        BEQ.N    ??EncodeSourceData_54
        ADD      LR,R12,#+10
        CMP      LR,#+3200
        BGT.N    ??EncodeSourceData_54
        MOV      R8,#+0
        MOV      R9,R12
??EncodeSourceData_55:
        RSB      R0,R8,#+9
        LSL      R10,R7,R0
        UXTH     R0,R3
        TST      R0,R10
        BEQ.N    ??EncodeSourceData_56
        ASR      R0,R9,#+2
        ADD      R0,R9,R0, LSR #+29
        ASRS     R0,R0,#+3
        ADD      R11,R8,R12
        SUB      R11,R11,R0, LSL #+3
        LDRB     R10,[R0, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R0, R6]
??EncodeSourceData_56:
        ADD      R8,R8,#+1
        ADD      R9,R9,#+1
        CMP      R8,#+10
        BLT.N    ??EncodeSourceData_55
        B.N      ??EncodeSourceData_57
??EncodeSourceData_54:
        MOV      LR,#-1
??EncodeSourceData_57:
        STR      LR,[R5, #+12]
        B.N      ??EncodeSourceData_52
??EncodeSourceData_53:
        BNE.N    ??EncodeSourceData_58
        LDRSB    R0,[R2, #+0]
        LDR      R12,[R5, #+12]
        ADD      R3,R0,R0, LSL #+2
        LDRSB    R0,[R2, R7]
        ADD      R0,R0,R3, LSL #+1
        SUB      R3,R0,#+528
        CMN      R12,#+1
        BEQ.N    ??EncodeSourceData_59
        ADD      LR,R12,#+7
        CMP      LR,#+3200
        BGT.N    ??EncodeSourceData_59
        MOV      R8,#+0
        MOV      R9,R12
??EncodeSourceData_60:
        RSB      R0,R8,#+6
        LSL      R10,R7,R0
        UXTH     R0,R3
        TST      R0,R10
        BEQ.N    ??EncodeSourceData_61
        ASR      R0,R9,#+2
        ADD      R0,R9,R0, LSR #+29
        ASRS     R0,R0,#+3
        ADD      R11,R8,R12
        SUB      R11,R11,R0, LSL #+3
        LDRB     R10,[R0, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R0, R6]
??EncodeSourceData_61:
        ADD      R8,R8,#+1
        ADD      R9,R9,#+1
        CMP      R8,#+7
        BLT.N    ??EncodeSourceData_60
        B.N      ??EncodeSourceData_57
??EncodeSourceData_59:
        MOV      LR,#-1
        B.N      ??EncodeSourceData_57
??EncodeSourceData_58:
        SUBS     R0,R0,#+1
        CMP      R1,R0
        BNE.W    ??EncodeSourceData_52
        LDRSB    R0,[R2, #+0]
        LDR      R12,[R5, #+12]
        SUB      R3,R0,#+48
        CMN      R12,#+1
        BEQ.W    ??EncodeSourceData_50
        ADD      R9,R12,#+4
        CMP      R9,#+3200
        BGT.W    ??EncodeSourceData_50
        MOV      LR,#+0
        MOV      R8,R12
??EncodeSourceData_62:
        RSB      R0,LR,#+3
        LSL      R10,R7,R0
        UXTH     R0,R3
        TST      R0,R10
        BEQ.N    ??EncodeSourceData_63
        ASR      R0,R8,#+2
        ADD      R0,R8,R0, LSR #+29
        ASRS     R0,R0,#+3
        ADD      R11,LR,R12
        SUB      R11,R11,R0, LSL #+3
        LDRB     R10,[R0, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R0, R6]
??EncodeSourceData_63:
        ADD      LR,LR,#+1
        ADD      R8,R8,#+1
        CMP      LR,#+4
        BLT.N    ??EncodeSourceData_62
        B.N      ??EncodeSourceData_51
??EncodeSourceData_48:
        CMP      R1,#+1
        BNE.W    ??EncodeSourceData_64
        MOVS     R2,#+4
        MOVS     R1,#+2
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLenAlphabet
        LDRB     R2,[R1, R2]
        LDR      R1,[SP, #+0]
        LDRB     R1,[R1, #+0]
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R2,[SP, #+20]
        STR      R0,[R5, #+12]
        MOVS     R1,#+0
        LDR      R0,[SP, #+4]
        ADDS     R3,R0,R2
        B.N      ??EncodeSourceData_65
??EncodeSourceData_66:
        MOV      R0,#-1
??EncodeSourceData_67:
        STR      R0,[R5, #+12]
        ADDS     R1,R1,#+2
        ADDS     R3,R3,#+2
??EncodeSourceData_65:
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+0]
        CMP      R1,R0
        BGE.W    ??EncodeSourceData_45
        LDRSB    R2,[R3, #+0]
        SUBS     R0,R0,#+1
        CMP      R1,R0
        UXTB     R2,R2
        SUB      R0,R2,#+48
        BGE.W    ??EncodeSourceData_68
        CMP      R0,#+10
        BCC.N    ??EncodeSourceData_69
        SUB      R0,R2,#+65
        CMP      R0,#+26
        IT       CC 
        SUBCC    R0,R2,#+55
        BCC.N    ??EncodeSourceData_69
        CMP      R2,#+32
        IT       EQ 
        MOVEQ    R0,#+36
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+36
        IT       EQ 
        MOVEQ    R0,#+37
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+37
        IT       EQ 
        MOVEQ    R0,#+38
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+42
        IT       EQ 
        MOVEQ    R0,#+39
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+43
        IT       EQ 
        MOVEQ    R0,#+40
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+45
        IT       EQ 
        MOVEQ    R0,#+41
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+46
        IT       EQ 
        MOVEQ    R0,#+42
        BEQ.N    ??EncodeSourceData_69
        CMP      R2,#+47
        ITE      EQ 
        MOVEQ    R0,#+43
        MOVNE    R0,#+44
??EncodeSourceData_69:
        LDRB     R2,[R3, #+1]
        SUB      LR,R2,#+48
        CMP      LR,#+10
        IT       CC 
        SUBCC    R2,R2,#+48
        BCC.N    ??EncodeSourceData_70
        SUB      R12,R2,#+65
        CMP      R12,#+26
        IT       CC 
        SUBCC    R2,R2,#+55
        BCC.N    ??EncodeSourceData_70
        CMP      R2,#+32
        IT       EQ 
        MOVEQ    R2,#+36
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+36
        IT       EQ 
        MOVEQ    R2,#+37
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+37
        IT       EQ 
        MOVEQ    R2,#+38
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+42
        IT       EQ 
        MOVEQ    R2,#+39
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+43
        IT       EQ 
        MOVEQ    R2,#+40
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+45
        IT       EQ 
        MOVEQ    R2,#+41
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+46
        IT       EQ 
        MOVEQ    R2,#+42
        BEQ.N    ??EncodeSourceData_70
        CMP      R2,#+47
        ITE      EQ 
        MOVEQ    R2,#+43
        MOVNE    R2,#+44
??EncodeSourceData_70:
        LDR      LR,[R5, #+12]
        UXTB     R0,R0
        MOV      R12,#+45
        UXTB     R2,R2
        MLA      R12,R12,R0,R2
        CMN      LR,#+1
        BEQ.N    ??EncodeSourceData_66
        ADD      R0,LR,#+11
        CMP      R0,#+3200
        BGT.N    ??EncodeSourceData_66
        MOV      R8,#+0
        MOV      R9,LR
??EncodeSourceData_71:
        RSB      R2,R8,#+10
        LSL      R10,R7,R2
        UXTH     R2,R12
        TST      R2,R10
        BEQ.N    ??EncodeSourceData_72
        ASR      R2,R9,#+2
        ADD      R2,R9,R2, LSR #+29
        ASRS     R2,R2,#+3
        ADD      R11,R8,LR
        SUB      R11,R11,R2, LSL #+3
        LDRB     R10,[R2, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R2, R6]
??EncodeSourceData_72:
        ADD      R8,R8,#+1
        ADD      R9,R9,#+1
        CMP      R8,#+11
        BLT.N    ??EncodeSourceData_71
        B.N      ??EncodeSourceData_67
??EncodeSourceData_68:
        CMP      R0,#+10
        IT       CC 
        SUBCC    R9,R2,#+48
        BCC.N    ??EncodeSourceData_73
        SUB      R0,R2,#+65
        CMP      R0,#+26
        IT       CC 
        SUBCC    R9,R2,#+55
        BCC.N    ??EncodeSourceData_73
        CMP      R2,#+32
        IT       EQ 
        MOVEQ    R9,#+36
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+36
        IT       EQ 
        MOVEQ    R9,#+37
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+37
        IT       EQ 
        MOVEQ    R9,#+38
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+42
        IT       EQ 
        MOVEQ    R9,#+39
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+43
        IT       EQ 
        MOVEQ    R9,#+40
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+45
        IT       EQ 
        MOVEQ    R9,#+41
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+46
        IT       EQ 
        MOVEQ    R9,#+42
        BEQ.N    ??EncodeSourceData_73
        CMP      R2,#+47
        ITE      EQ 
        MOVEQ    R9,#+43
        MOVNE    R9,#+44
??EncodeSourceData_73:
        LDR      R12,[R5, #+12]
        UXTB     R9,R9
        CMN      R12,#+1
        BEQ.W    ??EncodeSourceData_66
        ADD      R0,R12,#+6
        CMP      R0,#+3200
        BGT.W    ??EncodeSourceData_66
        MOV      LR,#+0
        MOV      R8,R12
??EncodeSourceData_74:
        RSB      R2,LR,#+5
        LSL      R2,R7,R2
        TST      R9,R2
        BEQ.N    ??EncodeSourceData_75
        ASR      R2,R8,#+2
        ADD      R2,R8,R2, LSR #+29
        ASRS     R2,R2,#+3
        ADD      R11,LR,R12
        SUB      R11,R11,R2, LSL #+3
        LDRB     R10,[R2, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R2, R6]
??EncodeSourceData_75:
        ADD      LR,LR,#+1
        ADD      R8,R8,#+1
        CMP      LR,#+6
        BLT.N    ??EncodeSourceData_74
        B.N      ??EncodeSourceData_67
??EncodeSourceData_64:
        CMP      R1,#+2
        BNE.N    ??EncodeSourceData_76
        MOVS     R2,#+4
        MOVS     R1,#+4
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLen8Bit
        LDRB     R2,[R1, R2]
        LDR      R1,[SP, #+0]
        LDRB     R1,[R1, #+0]
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R2,[SP, #+20]
        STR      R0,[R5, #+12]
        MOVS     R1,#+0
        LDR      R0,[SP, #+4]
        ADDS     R2,R0,R2
        B.N      ??EncodeSourceData_77
??EncodeSourceData_78:
        MOV      R9,#-1
??EncodeSourceData_79:
        STR      R9,[R5, #+12]
        ADDS     R1,R1,#+1
        ADDS     R2,R2,#+1
??EncodeSourceData_77:
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+0]
        CMP      R1,R0
        BGE.W    ??EncodeSourceData_45
        LDR      R12,[R5, #+12]
        LDRSB    R3,[R2, #+0]
        CMN      R12,#+1
        BEQ.N    ??EncodeSourceData_78
        ADD      R9,R12,#+8
        CMP      R9,#+3200
        BGT.N    ??EncodeSourceData_78
        MOV      LR,#+0
        MOV      R8,R12
??EncodeSourceData_80:
        RSB      R0,LR,#+7
        LSL      R10,R7,R0
        UXTH     R0,R3
        TST      R0,R10
        BEQ.N    ??EncodeSourceData_81
        ASR      R0,R8,#+2
        ADD      R0,R8,R0, LSR #+29
        ASRS     R0,R0,#+3
        ADD      R11,LR,R12
        SUB      R11,R11,R0, LSL #+3
        LDRB     R10,[R0, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R0, R6]
??EncodeSourceData_81:
        ADD      LR,LR,#+1
        ADD      R8,R8,#+1
        CMP      LR,#+8
        BLT.N    ??EncodeSourceData_80
        B.N      ??EncodeSourceData_79
??EncodeSourceData_76:
        MOVS     R2,#+4
        MOVS     R1,#+8
          CFI FunCall SetBitStream
        BL       SetBitStream
        LDR      R1,[SP, #+24]
        ADR.W    R2,nIndicatorLenKanji
        LDRB     R2,[R1, R2]
        LDR      R1,[SP, #+0]
        LDRB     R1,[R1, #+0]
        LSRS     R1,R1,#+1
          CFI FunCall SetBitStream
        BL       SetBitStream
        STR      R0,[R5, #+12]
        MOVS     R1,#+0
        LDR      R0,[SP, #+4]
        LDR      R2,[SP, #+20]
        ADDS     R2,R0,R2
        B.N      ??EncodeSourceData_82
??EncodeSourceData_83:
        MOV      R9,#-1
??EncodeSourceData_84:
        STR      R9,[R5, #+12]
        ADDS     R1,R1,#+1
        ADDS     R2,R2,#+2
??EncodeSourceData_82:
        LDR      R0,[SP, #+0]
        LDRB     R0,[R0, #+0]
        CMP      R1,R0, LSR #+1
        BGE.W    ??EncodeSourceData_45
        LDRSB    R0,[R2, #+0]
        LDRSB    R3,[R2, R7]
        UXTB     R0,R0
        UXTB     R3,R3
        ADD      R0,R3,R0, LSL #+8
        UXTH     R0,R0
        LDR.W    R3,??DataTable52  ;; 0xffff7ec0
        ADDS     R3,R3,R0
        MOVW     R12,#+7869
        CMP      R3,R12
        ITTE     CC 
        ADDCC    R0,R0,#+32256
        ADDCC    R0,R0,#+192
        ADDCS    R0,R0,#+16064
        UXTH     R0,R0
        LSRS     R3,R0,#+8
        ADD      R12,R3,R3, LSL #+1
        UXTB     R0,R0
        ADD      R3,R0,R12, LSL #+6
        LDR      R12,[R5, #+12]
        CMN      R12,#+1
        BEQ.N    ??EncodeSourceData_83
        ADD      R9,R12,#+13
        CMP      R9,#+3200
        BGT.N    ??EncodeSourceData_83
        MOV      LR,#+0
        MOV      R8,R12
??EncodeSourceData_85:
        RSB      R0,LR,#+12
        LSL      R10,R7,R0
        UXTH     R0,R3
        TST      R0,R10
        BEQ.N    ??EncodeSourceData_86
        ASR      R0,R8,#+2
        ADD      R0,R8,R0, LSR #+29
        ASRS     R0,R0,#+3
        ADD      R11,LR,R12
        SUB      R11,R11,R0, LSL #+3
        LDRB     R10,[R0, R6]
        RSB      R11,R11,#+7
        LSL      R11,R7,R11
        ORR      R10,R11,R10
        STRB     R10,[R0, R6]
??EncodeSourceData_86:
        ADD      LR,LR,#+1
        ADD      R8,R8,#+1
        CMP      LR,#+13
        BLT.N    ??EncodeSourceData_85
        B.N      ??EncodeSourceData_84
// 1121 		}
// 1122 //		else
// 1123 //		{//中文模式
// 1124 //			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, 8, 4);
// 1125 
// 1126 //			m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, (WORD)(m_nBlockLength[i] / 2), nIndicatorLenKanji[nVerGroup]);
// 1127 
// 1128 //			for (j = 0; j < m_nBlockLength[i] / 2; ++j)
// 1129 //			{
// 1130 //				WORD wBinCode = ChineseToBinaly((WORD)(((BYTE)lpsSource[ncComplete + (j * 2)] << 8) + (BYTE)lpsSource[ncComplete + (j * 2) + 1]));
// 1131 
// 1132 //				m_ncDataCodeWordBit = SetBitStream(m_ncDataCodeWordBit, wBinCode, 13);
// 1133 //			}
// 1134 
// 1135 //			ncComplete += m_nBlockLength[i];
// 1136 //		}
// 1137 	}
// 1138 
// 1139 	return (m_ncDataCodeWordBit != -1);
??EncodeSourceData_46:
        CMN      R0,#+1
        IT       NE 
        MOVNE    R0,#+1
        BNE.N    ??EncodeSourceData_87
??EncodeSourceData_47:
        MOVS     R0,#+0
??EncodeSourceData_87:
        B.W      ?Subroutine0
          CFI EndBlock cfiBlock3
// 1140 	//return TRUE;
// 1141 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40:
        DC32     ??byPattern

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable40_1:
        DC32     QR_VersonInfo
// 1142 //获取bit长度

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function GetBitLength
          CFI NoCalls
        THUMB
// 1143 int GetBitLength(BYTE nMode, int ncData, int nVerGroup)
// 1144 {
// 1145 	int ncBits = 0;
// 1146 
// 1147 	switch (nMode)
GetBitLength:
        CBZ.N    R0,??GetBitLength_0
        CMP      R0,#+2
        BEQ.N    ??GetBitLength_1
        BCC.N    ??GetBitLength_2
        B.N      ??GetBitLength_3
// 1148 	{
// 1149 	case QR_MODE_NUMERAL:
// 1150 		ncBits = 4 + nIndicatorLenNumeral[nVerGroup] + (10 * (ncData / 3));
??GetBitLength_0:
        MOVS     R0,#+3
        SDIV     R3,R1,R0
        ADR.W    R0,nIndicatorLenNumeral
        LDRB     R0,[R2, R0]
        ADD      R2,R3,R3, LSL #+2
        ADD      R0,R0,R2, LSL #+1
// 1151 		switch (ncData % 3)
        ADD      R2,R3,R3, LSL #+1
        ADDS     R0,R0,#+4
        SUBS     R1,R1,R2
        CMP      R1,#+1
        BEQ.N    ??GetBitLength_4
        CMP      R1,#+2
        BNE.N    ??GetBitLength_5
// 1152 		{
// 1153 			case 1:
// 1154 				ncBits += 4;
// 1155 				break;
// 1156 			case 2:
// 1157 				ncBits += 7;
        ADDS     R0,R0,#+7
// 1158 				break;
        BX       LR
// 1159 			default:
// 1160 				break;
// 1161 		}
// 1162 
// 1163 		break;
// 1164 
// 1165 	case QR_MODE_ALPHABET:
// 1166 		ncBits = 4 + nIndicatorLenAlphabet[nVerGroup] + (11 * (ncData / 2)) + (6 * (ncData % 2));
??GetBitLength_2:
        ADR.W    R3,nIndicatorLenAlphabet
        LDRB     R2,[R2, R3]
        ADD      R0,R1,R1, LSR #+31
        ASRS     R0,R0,#+1
        MOVS     R3,#+11
        MLA      R2,R3,R0,R2
        SUB      R0,R1,R0, LSL #+1
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,R2,R1, LSL #+1
        B.N      ??GetBitLength_4
// 1167 		break;
// 1168 
// 1169 	case QR_MODE_8BIT:
// 1170 		ncBits = 4 + nIndicatorLen8Bit[nVerGroup] + (8 * ncData);
??GetBitLength_1:
        ADR.W    R0,nIndicatorLen8Bit
        LDRB     R0,[R2, R0]
        ADD      R0,R0,R1, LSL #+3
        B.N      ??GetBitLength_4
// 1171 		break;
// 1172 
// 1173 	default:
// 1174 		//ncBits = 4 + nIndicatorLenKanji[nVerGroup] + (13 * (ncData / 2));//本程序写法？
// 1175 		ncBits = 4 + nIndicatorLenKanji[nVerGroup] + (13 * ncData);//文档算法
??GetBitLength_3:
        ADR.W    R0,nIndicatorLenKanji
        LDRB     R0,[R2, R0]
        MOVS     R2,#+13
        MLA      R0,R2,R1,R0
??GetBitLength_4:
        ADDS     R0,R0,#+4
// 1176 		break;
// 1177 	}
// 1178 
// 1179 	return ncBits;
??GetBitLength_5:
        BX       LR               ;; return
          CFI EndBlock cfiBlock4
// 1180 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLenNumeral:
        DC8 10, 12, 14, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLenAlphabet:
        DC8 9, 11, 13, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLen8Bit:
        DC8 8, 16, 16, 0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
nIndicatorLenKanji:
        DC8 8, 10, 12, 0
// 1181 //设置bit流

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function SetBitStream
          CFI NoCalls
        THUMB
// 1182 int SetBitStream(int nIndex, WORD wData, int ncData)
// 1183 {
SetBitStream:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 1184 	int i;
// 1185 
// 1186 	if (nIndex == -1 || nIndex + ncData > MAX_DATACODEWORD * 8)
        CMN      R0,#+1
        BEQ.N    ??SetBitStream_0
        ADDS     R3,R2,R0
        CMP      R3,#+3200
        BLE.N    ??SetBitStream_1
// 1187 		return -1;
??SetBitStream_0:
        MOV      R0,#-1
        POP      {R4-R8,PC}
// 1188 
// 1189 	for (i = 0; i < ncData; ++i)
??SetBitStream_1:
        MOVS     R5,#+0
        CMP      R2,#+1
        BLT.N    ??SetBitStream_2
        MOV      R6,R0
        LDR.W    R8,??DataTable41
        MOV      R12,#+1
// 1190 	{
// 1191 		if (wData & (1 << (ncData - i - 1)))
??SetBitStream_3:
        SUBS     R4,R2,R5
        SUBS     R4,R4,#+1
        LSL      LR,R12,R4
        TST      R1,LR
        BEQ.N    ??SetBitStream_4
// 1192 		{
// 1193 			m_byDataCodeWord[(nIndex + i) / 8] |= 1 << (7 - ((nIndex + i) % 8));
        ASRS     R4,R6,#+2
        ADD      R4,R6,R4, LSR #+29
        ASRS     R4,R4,#+3
        ADDS     R7,R5,R0
        SUB      R7,R7,R4, LSL #+3
        LDRB     LR,[R4, R8]
        RSB      R7,R7,#+7
        LSL      R7,R12,R7
        ORR      LR,R7,LR
        STRB     LR,[R4, R8]
// 1194 		}
// 1195 	}
??SetBitStream_4:
        ADDS     R5,R5,#+1
        ADDS     R6,R6,#+1
        CMP      R5,R2
        BLT.N    ??SetBitStream_3
// 1196 
// 1197 	return nIndex + ncData;
??SetBitStream_2:
        MOV      R0,R3
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock5
// 1198 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41:
        DC32     m_byDataCodeWord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_1:
        DC32     m_byAllCodeWord

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable41_2:
        DC32     m_byRSWork
// 1199 //是不是数字编码信息
// 1200 //是返回TRUE，否返回FALSE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function IsNumeralData
          CFI NoCalls
        THUMB
// 1201 bool IsNumeralData(unsigned char c)
// 1202 {
// 1203 	if (c >= '0' && c <= '9')
IsNumeralData:
        SUBS     R0,R0,#+48
        CMP      R0,#+10
        BCS.N    ??IsNumeralData_0
// 1204 		return TRUE;
        MOVS     R0,#+1
        BX       LR
// 1205 
// 1206 	return FALSE;
??IsNumeralData_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock6
// 1207 }
// 1208 //是否是字符编码信息
// 1209 //是返回TRUE，否返回FALSE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function IsAlphabetData
          CFI NoCalls
        THUMB
// 1210 bool IsAlphabetData(unsigned char c)
// 1211 {
// 1212 	if (c >= '0' && c <= '9')
IsAlphabetData:
        SUB      R2,R0,#+48
        CMP      R2,#+10
        ITT      CS 
// 1213 		return TRUE;
// 1214 
// 1215 	if (c >= 'A' && c <= 'Z')
        SUBCS    R1,R0,#+65
        CMPCS    R1,#+26
        BCC.N    ??IsAlphabetData_0
// 1216 		return TRUE;
// 1217 
// 1218 	if (c == ' ' || c == '$' || c == '%' || c == '*' || c == '+' || c == '-' || c == '.' || c == '/' || c == ':')
        CMP      R0,#+32
        IT       NE 
        CMPNE    R0,#+36
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+37
        IT       NE 
        CMPNE    R0,#+42
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+43
        IT       NE 
        CMPNE    R0,#+45
        BEQ.N    ??IsAlphabetData_0
        CMP      R0,#+46
        ITT      NE 
        CMPNE    R0,#+47
        CMPNE    R0,#+58
        BNE.N    ??IsAlphabetData_1
// 1219 		return TRUE;
??IsAlphabetData_0:
        MOVS     R0,#+1
        BX       LR
// 1220 
// 1221 	return FALSE;
??IsAlphabetData_1:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock7
// 1222 }
// 1223 //是否中文汉字信息
// 1224 //是返回TRUE，否返回FALSE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function IsKanjiData
          CFI NoCalls
        THUMB
// 1225 bool IsKanjiData(unsigned char c1, unsigned char c2)
// 1226 {
// 1227 
// 1228 	if (((c1 >= 0x81 && c1 <= 0x9f) || (c1 >= 0xe0 && c1 <= 0xeb)) && (c2 >= 0x40))
IsKanjiData:
        SUB      R3,R0,#+129
        CMP      R3,#+31
        ITT      CS 
        SUBCS    R2,R0,#+224
        CMPCS    R2,#+12
        BCS.N    ??IsKanjiData_0
        CMP      R1,#+64
        BLT.N    ??IsKanjiData_0
// 1229 	{
// 1230 		if ((c1 == 0x9f && c2 > 0xfc) || (c1 == 0xeb && c2 > 0xbf))
        CMP      R0,#+159
        BNE.N    ??IsKanjiData_1
        CMP      R1,#+253
        BLT.N    ??IsKanjiData_2
// 1231 			return FALSE;
// 1232 
// 1233 		return TRUE;
// 1234 	}
// 1235 	return FALSE;
??IsKanjiData_0:
        MOVS     R0,#+0
        BX       LR               ;; return
??IsKanjiData_1:
        CMP      R0,#+235
        BNE.N    ??IsKanjiData_2
        CMP      R1,#+192
        BGE.N    ??IsKanjiData_0
??IsKanjiData_2:
        MOVS     R0,#+1
        BX       LR
          CFI EndBlock cfiBlock8
// 1236 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function IsChineseData
          CFI NoCalls
        THUMB
// 1237 bool IsChineseData(unsigned char c1, unsigned char c2)
// 1238 {
// 1239 	//中文模式
// 1240 	if((c1 >= 0xa1 && c1 < 0xaa) || (c1 >= 0xb0 && c1 <= 0xfa))
IsChineseData:
        SUB      R2,R0,#+161
        CMP      R2,#+9
        ITT      CS 
        SUBCS    R0,R0,#+176
        CMPCS    R0,#+75
        BCS.N    ??IsChineseData_0
// 1241 	{
// 1242 		if(c2 >= 0xa1 && c2 <= 0xfe)	return TRUE;
        CMP      R1,#+161
        BLT.N    ??IsChineseData_0
        CMP      R1,#+255
        BEQ.N    ??IsChineseData_0
        MOVS     R0,#+1
        BX       LR
// 1243 	}
// 1244 	return FALSE;
??IsChineseData_0:
        MOVS     R0,#+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock9
// 1245 }
// 1246 
// 1247 
// 1248 //字母表信息转化

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function AlphabetToBinaly
          CFI NoCalls
        THUMB
// 1249 BYTE AlphabetToBinaly(unsigned char c)
// 1250 {
// 1251 	if (c >= '0' && c <= '9') return (unsigned char)(c - '0');
AlphabetToBinaly:
        SUB      R2,R0,#+48
        CMP      R2,#+10
        IT       CC 
        SUBCC    R0,R0,#+48
        BCC.N    ??AlphabetToBinaly_0
// 1252 
// 1253 	if (c >= 'A' && c <= 'Z') return (unsigned char)(c - 'A' + 10);
        SUB      R1,R0,#+65
        CMP      R1,#+26
        BCS.N    ??AlphabetToBinaly_1
        SUBS     R0,R0,#+55
??AlphabetToBinaly_0:
        UXTB     R0,R0
        BX       LR
// 1254 
// 1255 	if (c == ' ') return 36;
??AlphabetToBinaly_1:
        CMP      R0,#+32
        BNE.N    ??AlphabetToBinaly_2
        MOVS     R0,#+36
        BX       LR
// 1256 
// 1257 	if (c == '$') return 37;
??AlphabetToBinaly_2:
        CMP      R0,#+36
        BNE.N    ??AlphabetToBinaly_3
        MOVS     R0,#+37
        BX       LR
// 1258 
// 1259 	if (c == '%') return 38;
??AlphabetToBinaly_3:
        CMP      R0,#+37
        BNE.N    ??AlphabetToBinaly_4
        MOVS     R0,#+38
        BX       LR
// 1260 
// 1261 	if (c == '*') return 39;
??AlphabetToBinaly_4:
        CMP      R0,#+42
        BNE.N    ??AlphabetToBinaly_5
        MOVS     R0,#+39
        BX       LR
// 1262 
// 1263 	if (c == '+') return 40;
??AlphabetToBinaly_5:
        CMP      R0,#+43
        BNE.N    ??AlphabetToBinaly_6
        MOVS     R0,#+40
        BX       LR
// 1264 
// 1265 	if (c == '-') return 41;
??AlphabetToBinaly_6:
        CMP      R0,#+45
        BNE.N    ??AlphabetToBinaly_7
        MOVS     R0,#+41
        BX       LR
// 1266 
// 1267 	if (c == '.') return 42;
??AlphabetToBinaly_7:
        CMP      R0,#+46
        BNE.N    ??AlphabetToBinaly_8
        MOVS     R0,#+42
        BX       LR
// 1268 
// 1269 	if (c == '/') return 43;
??AlphabetToBinaly_8:
        CMP      R0,#+47
        BNE.N    ??AlphabetToBinaly_9
        MOVS     R0,#+43
        BX       LR
// 1270 
// 1271 	return 44;
??AlphabetToBinaly_9:
        MOVS     R0,#+44
        BX       LR               ;; return
          CFI EndBlock cfiBlock10
// 1272 }
// 1273 //日文中文信息转化
// 1274 //日文和汉字的编码会减去一个值。
// 1275 //如：在0X8140 to 0X9FFC中的字符会减去8140，
// 1276 //在0XE040到0XEBBF中的字符要减去0XC140，
// 1277 //然后把结果前两个16进制位拿出来乘以0XC0，
// 1278 //然后再加上后两个16进制位，最后转成13bit的编码。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function KanjiToBinaly
          CFI NoCalls
        THUMB
// 1279 WORD KanjiToBinaly(WORD wc)
// 1280 {
// 1281 	if (wc >= 0x8140 && wc <= 0x9ffc)
KanjiToBinaly:
        LDR.W    R1,??DataTable52  ;; 0xffff7ec0
        ADDS     R1,R1,R0
        MOVW     R2,#+7869
        CMP      R1,R2
        ITTE     CC 
// 1282 		wc -= 0x8140;
        ADDCC    R0,R0,#+32256
        ADDCC    R0,R0,#+192
// 1283 	else
// 1284 		wc -= 0xc140;
        ADDCS    R0,R0,#+16064
// 1285 
// 1286 	return (WORD)(((wc >> 8) * 0xc0) + (wc & 0x00ff));
        UXTH     R0,R0
        LSRS     R1,R0,#+8
        ADD      R2,R1,R1, LSL #+1
        UXTB     R0,R0
        ADD      R0,R0,R2, LSL #+6
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock11
// 1287 }
// 1288 /*
// 1289 二、中文汉字的与日文汉字转换步骤相似：
// 1290 1、对于第一字节为0xA1~0xAA之间,第二字节在0xA1~0xFE之间字符：
// 1291 a)第一字节减去0xA1；
// 1292 b)上一步结果乘以0x60;
// 1293 c）第二字节减去0xA1;
// 1294 d)将b)步骤的结果加上c步骤的结果;
// 1295 e)将结果转换为13位二进制串。
// 1296 1、对于第一字节为0xB0~0xFA之间,第二字节在0xA1~0xFE之间字符：
// 1297 a)第一字节减去0xA6；
// 1298 b)上一步结果乘以0x60;
// 1299 c）第二字节减去0xA1;
// 1300 d)将b)步骤的结果加上c步骤的结果;
// 1301 e)将结果转换为13位二进制串
// 1302 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function ChineseToBinaly
          CFI NoCalls
        THUMB
// 1303 WORD ChineseToBinaly(WORD wc)
// 1304 {
// 1305 	if(wc >= 0xa1a1 && wc <= 0xa9fe)
ChineseToBinaly:
        LSRS     R1,R0,#+8
        ADD      R2,R1,R1, LSL #+1
        UXTB     R1,R0
        ADD      R1,R1,R2, LSL #+5
        LDR.W    R2,??DataTable53  ;; 0xffff5e5f
        ADDS     R0,R2,R0
        MOVW     R2,#+2142
        CMP      R0,R2
        ITE      CC 
// 1306 	{
// 1307 		return (WORD)((((wc >> 8)-0xa1) * 0x60) + ((wc & 0x00ff)-0xa1));
        MOVWCC   R0,#+15617
// 1308 	}
// 1309 	if(wc >= 0xb0a1 && wc <= 0xf9fe)
// 1310 	{
// 1311 		return (WORD)((((wc >> 8)-0xa6) * 0x60) + ((wc & 0x00ff)-0xa1));
// 1312 	}
// 1313 	return (WORD)((((wc >> 8)-0xa6) * 0x60) + ((wc & 0x00ff)-0xa1));
        MOVWCS   R0,#+16097
        SUBS     R0,R1,R0
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock12
// 1314 }
// 1315 //纠错码

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function GetRSCodeWord
          CFI NoCalls
        THUMB
// 1316 void GetRSCodeWord(BYTE *lpbyRSWork, int ncDataCodeWord, int ncRSCodeWord)
// 1317 {
// 1318 	int i, j;
// 1319 
// 1320 	for (i = 0; i < ncDataCodeWord ; ++i)
GetRSCodeWord:
        CMP      R1,#+1
        BGE.N    ??GetRSCodeWord_0
        BX       LR
??GetRSCodeWord_0:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        ADDS     R4,R2,R1
        MOV      R3,R1
        SUBS     R4,R4,#+1
        ADR.W    R8,byExpToInt
        LDR.W    R9,??DataTable53_1
        ADR.W    R10,byIntToExp
// 1321 	{
// 1322 		if (lpbyRSWork[0] != 0)
??GetRSCodeWord_1:
        LDRB     R5,[R0, #+0]
        CMP      R5,#+0
        BEQ.N    ??GetRSCodeWord_2
// 1323 		{
// 1324 			BYTE nExpFirst = byIntToExp[lpbyRSWork[0]]; 
        LDRB     R12,[R5, R10]
// 1325 
// 1326 			for (j = 0; j < ncRSCodeWord; ++j)
        MOV      LR,#+0
        CMP      R2,#+1
        BLT.N    ??GetRSCodeWord_3
        MOV      R5,R0
// 1327 			{
// 1328 				BYTE nExpElement = (BYTE)(((int)(byRSExp[ncRSCodeWord][j] + nExpFirst)) % 255);
??GetRSCodeWord_4:
        LDR      R6,[R9, R2, LSL #+2]
// 1329 
// 1330 				lpbyRSWork[j] = (BYTE)(lpbyRSWork[j + 1] ^ byExpToInt[nExpElement]);
        LDRB     R7,[R5, #+1]
        LDRB     R6,[LR, R6]
        ADD      R6,R12,R6
        MOV      R11,#+255
        SDIV     R11,R6,R11
        ADD      R6,R11,R6
        UXTB     R6,R6
// 1331 			}
        ADD      LR,LR,#+1
        LDRB     R6,[R6, R8]
        EORS     R6,R6,R7
        STRB     R6,[R5], #+1
        CMP      LR,R2
        BLT.N    ??GetRSCodeWord_4
// 1332 
// 1333 			for (j = ncRSCodeWord; j < ncDataCodeWord + ncRSCodeWord - 1; ++j)
??GetRSCodeWord_3:
        ADDS     R5,R2,R1
        SUBS     R5,R5,#+1
        CMP      R2,R5
        BGE.N    ??GetRSCodeWord_5
        ADD      R12,R2,R0
        SUB      LR,R1,#+1
// 1334 				lpbyRSWork[j] = lpbyRSWork[j + 1];
??GetRSCodeWord_6:
        LDRB     R5,[R12, #+1]
        STRB     R5,[R12], #+1
        SUBS     LR,LR,#+1
        BNE.N    ??GetRSCodeWord_6
        B.N      ??GetRSCodeWord_5
// 1335 		}
// 1336 		else
// 1337 		{
// 1338 			for (j = 0; j < ncDataCodeWord + ncRSCodeWord - 1; ++j)
??GetRSCodeWord_2:
        CMP      R4,#+1
        BLT.N    ??GetRSCodeWord_5
        MOV      R12,R0
        MOV      LR,R4
// 1339 				lpbyRSWork[j] = lpbyRSWork[j + 1];
??GetRSCodeWord_7:
        LDRB     R5,[R12, #+1]
        STRB     R5,[R12], #+1
        SUBS     LR,LR,#+1
        BNE.N    ??GetRSCodeWord_7
// 1340 		}
// 1341 	}
??GetRSCodeWord_5:
        SUBS     R3,R3,#+1
        BNE.N    ??GetRSCodeWord_1
// 1342 }
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock13

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable44:
        DC32     m_byBlockMode

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
byExpToInt:
        DC8 1, 2, 4, 8, 16, 32, 64, 128, 29, 58, 116, 232, 205, 135, 19, 38, 76
        DC8 152, 45, 90, 180, 117, 234, 201, 143, 3, 6, 12, 24, 48, 96, 192
        DC8 157, 39, 78, 156, 37, 74, 148, 53, 106, 212, 181, 119, 238, 193
        DC8 159, 35, 70, 140, 5, 10, 20, 40, 80, 160, 93, 186, 105, 210, 185
        DC8 111, 222, 161, 95, 190, 97, 194, 153, 47, 94, 188, 101, 202, 137
        DC8 15, 30, 60, 120, 240, 253, 231, 211, 187, 107, 214, 177, 127, 254
        DC8 225, 223, 163, 91, 182, 113, 226, 217, 175, 67, 134, 17, 34, 68
        DC8 136, 13, 26, 52, 104, 208, 189, 103, 206, 129, 31, 62, 124, 248
        DC8 237, 199, 147, 59, 118, 236, 197, 151, 51, 102, 204, 133, 23, 46
        DC8 92, 184, 109, 218, 169, 79, 158, 33, 66, 132, 21, 42, 84, 168, 77
        DC8 154, 41, 82, 164, 85, 170, 73, 146, 57, 114, 228, 213, 183, 115
        DC8 230, 209, 191, 99, 198, 145, 63, 126, 252, 229, 215, 179, 123, 246
        DC8 241, 255, 227, 219, 171, 75, 150, 49, 98, 196, 149, 55, 110, 220
        DC8 165, 87, 174, 65, 130, 25, 50, 100, 200, 141, 7, 14, 28, 56, 112
        DC8 224, 221, 167, 83, 166, 81, 162, 89, 178, 121, 242, 249, 239, 195
        DC8 155, 43, 86, 172, 69, 138, 9, 18, 36, 72, 144, 61, 122, 244, 245
        DC8 247, 243, 251, 235, 203, 139, 11, 22, 44, 88, 176, 125, 250, 233
        DC8 207, 131, 27, 54, 108, 216, 173, 71, 142, 1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
byIntToExp:
        DC8 0, 0, 1, 25, 2, 50, 26, 198, 3, 223, 51, 238, 27, 104, 199, 75, 4
        DC8 100, 224, 14, 52, 141, 239, 129, 28, 193, 105, 248, 200, 8, 76, 113
        DC8 5, 138, 101, 47, 225, 36, 15, 33, 53, 147, 142, 218, 240, 18, 130
        DC8 69, 29, 181, 194, 125, 106, 39, 249, 185, 201, 154, 9, 120, 77, 228
        DC8 114, 166, 6, 191, 139, 98, 102, 221, 48, 253, 226, 152, 37, 179, 16
        DC8 145, 34, 136, 54, 208, 148, 206, 143, 150, 219, 189, 241, 210, 19
        DC8 92, 131, 56, 70, 64, 30, 66, 182, 163, 195, 72, 126, 110, 107, 58
        DC8 40, 84, 250, 133, 186, 61, 202, 94, 155, 159, 10, 21, 121, 43, 78
        DC8 212, 229, 172, 115, 243, 167, 87, 7, 112, 192, 247, 140, 128, 99
        DC8 13, 103, 74, 222, 237, 49, 197, 254, 24, 227, 165, 153, 119, 38
        DC8 184, 180, 124, 17, 68, 146, 217, 35, 32, 137, 46, 55, 63, 209, 91
        DC8 149, 188, 207, 205, 144, 135, 151, 178, 220, 252, 190, 97, 242, 86
        DC8 211, 171, 20, 42, 93, 158, 132, 60, 57, 83, 71, 109, 65, 162, 31
        DC8 45, 67, 216, 183, 123, 164, 118, 196, 23, 73, 236, 127, 12, 111
        DC8 246, 108, 161, 59, 82, 41, 157, 85, 170, 251, 96, 134, 177, 187
        DC8 204, 62, 90, 203, 89, 95, 176, 156, 169, 160, 81, 11, 245, 22, 235
        DC8 122, 117, 44, 215, 79, 174, 213, 233, 230, 231, 173, 232, 116, 214
        DC8 244, 234, 168, 80, 88, 175
// 1343 //格式化数据存放，存在于所有的尺寸中，
// 1344 //详见http://coolshell.cn/articles/10590.html#jtss-tsina

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function FormatModule
        THUMB
// 1345 void FormatModule(void)
// 1346 {
FormatModule:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 1347 	int i, j;
// 1348 	int nMinPenalty, nPenalty;
// 1349 
// 1350 	memset(m_byModuleData, 0, sizeof(m_byModuleData));
        LDR.W    R4,??DataTable53_2
        MOVW     R1,#+441
        MOV      R0,R4
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
// 1351 
// 1352 	SetFunctionModule();	//首先把回字图案花在三个角上
          CFI FunCall SetFunctionModule
        BL       SetFunctionModule
// 1353 
// 1354 	SetCodeWordPattern();	//
          CFI FunCall SetCodeWordPattern
        BL       SetCodeWordPattern
// 1355 
// 1356 	if (m_nMaskingNo == -1)
        LDR.W    R5,??DataTable53_3
        LDR      R0,[R5, #+28]
        CMN      R0,#+1
        BNE.N    ??FormatModule_0
// 1357 	{
// 1358 		m_nMaskingNo = 0;
        MOVS     R6,#+0
// 1359 
// 1360 		SetMaskingPattern(m_nMaskingNo); 
        MOVS     R0,#+0
          CFI FunCall SetMaskingPattern
        BL       SetMaskingPattern
// 1361 		SetFormatInfoPattern(m_nMaskingNo); 
        MOV      R0,R6
          CFI FunCall SetFormatInfoPattern
        BL       SetFormatInfoPattern
// 1362 
// 1363 		nMinPenalty = CountPenalty();
          CFI FunCall CountPenalty
        BL       CountPenalty
        MOV      R8,R0
// 1364 
// 1365 		for (i = 1; i <= 7; ++i)
        MOVS     R7,#+1
// 1366 		{
// 1367 			SetMaskingPattern(i); 
??FormatModule_1:
        MOV      R0,R7
          CFI FunCall SetMaskingPattern
        BL       SetMaskingPattern
// 1368 			SetFormatInfoPattern(i); 
        MOV      R0,R7
          CFI FunCall SetFormatInfoPattern
        BL       SetFormatInfoPattern
// 1369 
// 1370 			nPenalty = CountPenalty();
          CFI FunCall CountPenalty
        BL       CountPenalty
// 1371 
// 1372 			if (nPenalty < nMinPenalty)
        CMP      R0,R8
        ITT      LT 
// 1373 			{
// 1374 				nMinPenalty = nPenalty;
        MOVLT    R8,R0
// 1375 				m_nMaskingNo = i;
        MOVLT    R6,R7
// 1376 			}
// 1377 		}
        ADDS     R7,R7,#+1
        STR      R6,[R5, #+28]
        CMP      R7,#+8
        BLT.N    ??FormatModule_1
// 1378 	}
// 1379 
// 1380 	SetMaskingPattern(m_nMaskingNo); 
??FormatModule_0:
        LDR      R0,[R5, #+28]
          CFI FunCall SetMaskingPattern
        BL       SetMaskingPattern
// 1381 	SetFormatInfoPattern(m_nMaskingNo); 
        LDR      R0,[R5, #+28]
          CFI FunCall SetFormatInfoPattern
        BL       SetFormatInfoPattern
// 1382 
// 1383 	for (i = 0; i < m_nSymbleSize; ++i)
        LDR      R0,[R5, #+8]
        CMP      R0,#+1
        BLT.N    ??FormatModule_2
        MOV      R1,R0
??FormatModule_3:
        MOV      R2,R4
        MOV      R3,R0
// 1384 	{
// 1385 		for (j = 0; j < m_nSymbleSize; ++j)
// 1386 		{
// 1387 			m_byModuleData[i][j] = (BYTE)((m_byModuleData[i][j] & 0x11) != 0);
??FormatModule_4:
        LDRB     R5,[R2, #+0]
        AND      R6,R5,#0x11
        SUBS     R5,R6,#+1
        SBCS     R5,R5,R5
        MVNS     R5,R5
        LSRS     R5,R5,#+31
        STRB     R5,[R2], #+1
// 1388 		}
        SUBS     R3,R3,#+1
        BNE.N    ??FormatModule_4
// 1389 	}
        ADDW     R4,R4,#+21
        SUBS     R1,R1,#+1
        BNE.N    ??FormatModule_3
// 1390 }
??FormatModule_2:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock14
// 1391 //设置功能性模块信息
// 1392 //Position Detection Pattern	用于标记二维码举行大小
// 1393 //Separators for Postion Detection Patterns	三个就可以标记一个矩形
// 1394 //Timing Patterns也是用于定位的。原因是二维码有40种尺寸，尺寸过大了后需要有根标准线，不然扫描的时候可能会扫歪了
// 1395 //Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function SetFunctionModule
        THUMB
// 1396 void SetFunctionModule(void)
// 1397 {
SetFunctionModule:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
// 1398 	int i, j;
// 1399 
// 1400 	SetFinderPattern(0, 0);					//三个回字坐标
        MOVS     R1,#+0
        MOVS     R0,#+0
          CFI FunCall SetFinderPattern
        BL       SetFinderPattern
        LDR.W    R0,??DataTable53_3
        LDR      R0,[R0, #+8]
        SUBS     R4,R0,#+7
        MOVS     R1,#+0
        MOV      R0,R4
// 1401 	SetFinderPattern(m_nSymbleSize - 7, 0);	
          CFI FunCall SetFinderPattern
        BL       SetFinderPattern
// 1402 	SetFinderPattern(0, m_nSymbleSize - 7);	
        MOV      R1,R4
        MOVS     R0,#+0
          CFI FunCall SetFinderPattern
        BL       SetFinderPattern
// 1403 
// 1404 	for (i = 0; i < 8; ++i)
        LDR.W    R0,??DataTable53_3
        LDR.W    R4,??DataTable53_2
        LDR      R0,[R0, #+8]
        MOVS     R2,#+21
        MLA      R0,R2,R0,R4
        LDR.W    R2,??DataTable53_3
        LDR      R2,[R2, #+8]
        ADDS     R2,R2,R4
        ADDW     R1,R4,#+147
        SUB      R3,R0,#+168
        ADDW     R5,R2,#+139
        ADDW     R6,R4,#+7
        SUB      R7,R0,#+161
        SUB      R12,R2,#+8
        MOV      LR,#+4
        MOV      R8,#+32
// 1405 	{
// 1406 		m_byModuleData[i][7] = m_byModuleData[7][i] = '\x20';
??SetFunctionModule_0:
        STRB     R8,[R1], #+1
        STRB     R8,[R6], #+21
// 1407 		m_byModuleData[m_nSymbleSize - 8][i] = m_byModuleData[m_nSymbleSize - 8 + i][7] = '\x20';
        STRB     R8,[R7], #+21
        STRB     R8,[R3], #+1
// 1408 		m_byModuleData[i][m_nSymbleSize - 8] = m_byModuleData[7][m_nSymbleSize - 8 + i] = '\x20';
        STRB     R8,[R5], #+1
        STRB     R8,[R12], #+21
        STRB     R8,[R1], #+1
        STRB     R8,[R6], #+21
        STRB     R8,[R7], #+21
        STRB     R8,[R3], #+1
        STRB     R8,[R5], #+1
        STRB     R8,[R12], #+21
// 1409 	}
        SUBS     LR,LR,#+1
        BNE.N    ??SetFunctionModule_0
// 1410 
// 1411 	for (i = 0; i < 9; ++i)
        ADD      R1,R4,#+168
        ADD      R3,R4,#+8
        MOVS     R5,#+3
        MOVS     R6,#+32
// 1412 	{
// 1413 		m_byModuleData[i][8] = m_byModuleData[8][i] = '\x20';
??SetFunctionModule_1:
        STRB     R8,[R1], #+1
        STRB     R8,[R3], #+21
        STRB     R8,[R1], #+1
        STRB     R8,[R3], #+21
        STRB     R8,[R1], #+1
        STRB     R8,[R3], #+21
// 1414 	}
        SUBS     R5,R5,#+1
        BNE.N    ??SetFunctionModule_1
// 1415 
// 1416 	for (i = 0; i < 8; ++i)
// 1417 	{
// 1418 		m_byModuleData[m_nSymbleSize - 8 + i][8] = m_byModuleData[8][m_nSymbleSize - 8 + i] = '\x20';
        STRB     R8,[R2, #+160]
        ADD      R1,R2,#+160
        STRB     R8,[R0, #-160]
        STRB     R8,[R1, #+1]
        STRB     R8,[R0, #-139]
        STRB     R8,[R1, #+2]
        STRB     R8,[R0, #-118]
        STRB     R8,[R1, #+3]
        STRB     R8,[R0, #-97]
        STRB     R8,[R1, #+4]
        STRB     R8,[R0, #-76]
        STRB     R8,[R1, #+5]
        STRB     R8,[R0, #-55]
        STRB     R8,[R1, #+6]
        STRB     R8,[R0, #-34]
        STRB     R8,[R1, #+7]
        STRB     R8,[R0, #-13]
// 1419 	}
// 1420 
// 1421 	SetVersionPattern();	//版本信息
          CFI FunCall SetVersionPattern
        BL       SetVersionPattern
// 1422 
// 1423 	for (i = 0; i < QR_VersonInfo[m_nVersion].ncAlignPoint; ++i)
        MOVS     R1,#+0
        LDR.W    R0,??DataTable53_3
        ADR.W    R3,QR_VersonInfo
        LDR      R0,[R0, #+24]
        MOVS     R2,#+74
        MLA      R0,R2,R0,R3
        STR      R0,[SP, #+0]
        ADDW     R3,R0,#+14
        MOVS     R2,#+1
        B.N      ??SetFunctionModule_2
??SetFunctionModule_3:
        ADDS     R1,R1,#+1
        ADDS     R3,R3,#+2
??SetFunctionModule_2:
        LDR      R0,[SP, #+0]
        LDRH     R0,[R0, #+12]
        STR      R0,[SP, #+4]
        CMP      R1,R0
        BGE.W    ??SetFunctionModule_4
// 1424 	{
// 1425 		SetAlignmentPattern(QR_VersonInfo[m_nVersion].nAlignPoint[i], 6);//小回字
        LDRH     R5,[R3, #+0]
        MOVS     R0,#+21
        MLA      R0,R0,R5,R4
        LDRB     R0,[R0, #+6]
        LSLS     R0,R0,#+26
        BMI.N    ??SetFunctionModule_5
        SUBS     R5,R5,#+2
        MOVS     R6,#+0
        LDR.W    R7,??DataTable53_3
??SetFunctionModule_6:
        MOVS     R0,#+21
        ADD      LR,R6,R4
        MLA      R0,R0,R5,LR
        MOV      R12,#+0
        ADD      LR,R0,#+4
??SetFunctionModule_7:
        LDRB     R0,[R7, #+0]
        RSB      R8,R12,#+4
        LSL      R8,R2,R8
        TST      R0,R8
        ITE      NE 
        MOVNE    R0,#+48
        MOVEQ    R0,#+32
        ADD      R12,R12,#+1
        STRB     R0,[LR], #+21
        CMP      R12,#+5
        BLT.N    ??SetFunctionModule_7
        ADDS     R6,R6,#+1
        ADDS     R7,R7,#+1
        CMP      R6,#+5
        BLT.N    ??SetFunctionModule_6
// 1426 		SetAlignmentPattern(6, QR_VersonInfo[m_nVersion].nAlignPoint[i]);
??SetFunctionModule_5:
        LDRH     R0,[R3, #+0]
        ADDS     R5,R0,R4
        LDRB     R5,[R5, #+126]
        LSLS     R5,R5,#+26
        BMI.N    ??SetFunctionModule_8
        ADDS     R0,R0,R4
        ADDW     R5,R0,#+82
        LDR.W    R6,??DataTable53_3
        MOVS     R7,#+5
??SetFunctionModule_9:
        MOV      R12,#+0
??SetFunctionModule_10:
        LDRB     R0,[R6, #+0]
        RSB      LR,R12,#+4
        LSL      LR,R2,LR
        TST      R0,LR
        ITE      NE 
        MOVNE    R0,#+48
        MOVEQ    R0,#+32
        ADD      R12,R12,#+1
        STRB     R0,[R5], #+21
        CMP      R12,#+5
        BLT.N    ??SetFunctionModule_10
        ADDS     R6,R6,#+1
        SUBS     R5,R5,#+104
        SUBS     R7,R7,#+1
        BNE.N    ??SetFunctionModule_9
// 1427 
// 1428 		for (j = 0; j < QR_VersonInfo[m_nVersion].ncAlignPoint; ++j)
??SetFunctionModule_8:
        LDR      R0,[SP, #+0]
        MOVS     R5,#+0
        ADDW     R6,R0,#+14
        B.N      ??SetFunctionModule_11
// 1429 		{
??SetFunctionModule_12:
        ADD      R9,R9,#+1
        STRB     R0,[R10], #+21
        CMP      R9,#+5
        BLT.N    ??SetFunctionModule_13
        ADD      LR,LR,#+1
        ADD      R8,R8,#+1
        CMP      LR,#+5
        BLT.N    ??SetFunctionModule_14
// 1430 			SetAlignmentPattern(QR_VersonInfo[m_nVersion].nAlignPoint[i], QR_VersonInfo[m_nVersion].nAlignPoint[j]);
??SetFunctionModule_15:
        ADDS     R5,R5,#+1
        ADDS     R6,R6,#+2
??SetFunctionModule_11:
        LDR      R0,[SP, #+4]
        CMP      R5,R0
        BGE.N    ??SetFunctionModule_3
        LDRH     R7,[R3, #+0]
        LDRH     R12,[R6, #+0]
        MOVS     R0,#+21
        MLA      R0,R0,R7,R4
        LDRB     R0,[R12, R0]
        LSLS     R0,R0,#+26
        BMI.N    ??SetFunctionModule_15
        SUBS     R7,R7,#+2
        SUB      R12,R12,#+2
        MOV      LR,#+0
        LDR.W    R8,??DataTable53_3
??SetFunctionModule_14:
        ADD      R10,LR,R12
        MOVS     R0,#+21
        ADD      R10,R10,R4
        MOV      R9,#+0
        MLA      R10,R0,R7,R10
??SetFunctionModule_13:
        LDRB     R0,[R8, #+0]
        RSB      R11,R9,#+4
        LSL      R11,R2,R11
        TST      R0,R11
        ITE      NE 
        MOVNE    R0,#+48
        MOVEQ    R0,#+32
        B.N      ??SetFunctionModule_12
// 1431 		}
// 1432 	}
// 1433 
// 1434 	for (i = 8; i <= m_nSymbleSize - 9; ++i)
??SetFunctionModule_4:
        LDR.W    R1,??DataTable53_3
        LDR      R1,[R1, #+8]
        MOVS     R0,#+8
        SUBS     R1,R1,#+9
        CMP      R1,#+8
        BLT.N    ??SetFunctionModule_16
        ADDW     R2,R4,#+134
        ADDW     R3,R4,#+174
// 1435 	{
// 1436 		m_byModuleData[i][6] = (i % 2) == 0 ? '\x30' : '\x20';
??SetFunctionModule_17:
        ADD      R4,R0,R0, LSR #+31
        ASRS     R4,R4,#+1
        SUBS     R4,R0,R4, LSL #+1
        ITE      EQ 
        MOVEQ    R4,#+48
        MOVNE    R4,#+32
        STRB     R4,[R3, #+0]
// 1437 		m_byModuleData[6][i] = (i % 2) == 0 ? '\x30' : '\x20';
// 1438 	}
        ADDS     R0,R0,#+1
        STRB     R4,[R2], #+1
        ADDW     R3,R3,#+21
        CMP      R1,R0
        BGE.N    ??SetFunctionModule_17
// 1439 }
??SetFunctionModule_16:
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock15
// 1440 //设置大回字信息
// 1441 // O X X X X X X X
// 1442 // O X O O O O O X
// 1443 // O X O X X X O X
// 1444 // O X O X X X O X
// 1445 // O X O X X X O X
// 1446 // O X O O O O O X
// 1447 // O X X X X X X X

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function SetFinderPattern
          CFI NoCalls
        THUMB
// 1448 void SetFinderPattern(int x, int y)
// 1449 {
SetFinderPattern:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 1450 	static BYTE byPattern[] = {0x7f,  
// 1451 							   0x41,  
// 1452 							   0x5d,  
// 1453 							   0x5d, 
// 1454 							   0x5d, 
// 1455 							   0x41,  
// 1456 							   0x7f}; 
// 1457 	int i, j;
// 1458 
// 1459 	for (i = 0; i < 7; ++i)
        MOVS     R3,#+0
        LDR.W    R4,??DataTable53_4
        LDR.W    R8,??DataTable53_2
        MOVS     R5,#+1
        MOVS     R6,#+21
// 1460 	{
// 1461 		for (j = 0; j < 7; ++j)
??SetFinderPattern_0:
        ADDS     R2,R3,R1
        ADD      R2,R2,R8
        MOV      R12,#+0
        MLA      LR,R6,R0,R2
// 1462 		{
// 1463 			m_byModuleData[x + j][y + i] = (byPattern[i] & (1 << (6 - j))) ? '\x30' : '\x20'; 
??SetFinderPattern_1:
        LDRB     R2,[R4, #+0]
        RSB      R7,R12,#+6
        LSL      R7,R5,R7
        TST      R2,R7
        ITE      NE 
        MOVNE    R2,#+48
        MOVEQ    R2,#+32
// 1464 		}
        ADD      R12,R12,#+1
        STRB     R2,[LR], #+21
        CMP      R12,#+7
        BLT.N    ??SetFinderPattern_1
// 1465 	}
        ADDS     R3,R3,#+1
        ADDS     R4,R4,#+1
        CMP      R3,#+7
        BLT.N    ??SetFinderPattern_0
// 1466 }
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock16
// 1467 //设置小回字信息
// 1468 //Alignment Patterns 只有Version 2以上（包括Version2）的二维码需要这个东东，同样是为了定位用的。
// 1469 //Alignment Patterns是除了3个大的回字，较小的回字
// 1470 // O O O X X X X X
// 1471 // O O O X O O O X
// 1472 // O O O X O X O X
// 1473 // O O O X O O O X
// 1474 // O O O X X X X X

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function SetAlignmentPattern
          CFI NoCalls
        THUMB
// 1475 void SetAlignmentPattern(int x, int y)
// 1476 {
SetAlignmentPattern:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 1477 	static BYTE byPattern[] = {0x1f,  
// 1478 							   0x11,  
// 1479 							   0x15, 
// 1480 							   0x11,  
// 1481 							   0x1f}; 
// 1482 	int i, j;
// 1483 
// 1484 	if (m_byModuleData[x][y] & 0x20)
        MOVS     R3,#+21
        LDR.W    R8,??DataTable53_2
        MLA      R2,R3,R0,R8
        LDRB     R2,[R1, R2]
        LSLS     R2,R2,#+26
        BMI.N    ??SetAlignmentPattern_0
// 1485 		return; 
// 1486 
// 1487 	x -= 2; y -= 2; 
        SUBS     R0,R0,#+2
        SUBS     R1,R1,#+2
// 1488 
// 1489 	for (i = 0; i < 5; ++i)
        MOVS     R5,#+0
        LDR.W    R6,??DataTable53_3
        MOVS     R7,#+1
// 1490 	{
// 1491 		for (j = 0; j < 5; ++j)
??SetAlignmentPattern_1:
        ADDS     R2,R5,R1
        ADD      R2,R2,R8
        MOV      R12,#+0
        MLA      LR,R3,R0,R2
// 1492 		{
// 1493 			m_byModuleData[x + j][y + i] = (byPattern[i] & (1 << (4 - j))) ? '\x30' : '\x20'; 
??SetAlignmentPattern_2:
        LDRB     R2,[R6, #+0]
        RSB      R4,R12,#+4
        LSL      R4,R7,R4
        TST      R2,R4
        ITE      NE 
        MOVNE    R2,#+48
        MOVEQ    R2,#+32
// 1494 		}
        ADD      R12,R12,#+1
        STRB     R2,[LR], #+21
        CMP      R12,#+5
        BLT.N    ??SetAlignmentPattern_2
// 1495 	}
        ADDS     R5,R5,#+1
        ADDS     R6,R6,#+1
        CMP      R5,#+5
        BLT.N    ??SetAlignmentPattern_1
// 1496 }
??SetAlignmentPattern_0:
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock17

        SECTION `.data`:DATA:REORDER:NOROOT(2)
??byPattern:
        DATA
        DC8 31, 17, 21, 17, 31, 0, 0, 0
m_nSymbleSize:
        DC8 0, 0, 0, 0
m_ncDataCodeWordBit:
        DC8 0, 0, 0, 0
m_ncAllCodeWord:
        DC8 0, 0, 0, 0
m_nLevel:
        DC8 0, 0, 0, 0
m_nVersion:
        DC8 0, 0, 0, 0
m_nMaskingNo:
        DC8 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
??byPattern_1:
        DATA
        DC8 127, 65, 93, 93, 93, 65, 127, 0
// 1497 //设置版本，在 >= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function SetVersionPattern
          CFI NoCalls
        THUMB
// 1498 void SetVersionPattern(void)
// 1499 {
// 1500 	int i, j;
// 1501 	int nVerData;
// 1502 
// 1503 	if (m_nVersion <= 6)//在 >= Version 7以上，需要预留两块3 x 6的区域存放一些版本信息。
SetVersionPattern:
        LDR.W    R3,??DataTable53_3
        LDR      R0,[R3, #+24]
        CMP      R0,#+7
        BGE.N    ??SetVersionPattern_0
        BX       LR
// 1504 		return;
// 1505 
// 1506 	nVerData = m_nVersion << 12;
??SetVersionPattern_0:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        LSLS     R1,R0,#+12
// 1507 
// 1508 	for (i = 0; i < 6; ++i)
        MOVS     R2,#+0
        MOVW     R4,#+7973
// 1509 	{
// 1510 		if (nVerData & (1 << (17 - i)))
??SetVersionPattern_1:
        RSB      R5,R2,#+17
        ASR      R5,R1,R5
        LSLS     R5,R5,#+31
        BPL.N    ??SetVersionPattern_2
// 1511 		{
// 1512 			nVerData ^= (0x1f25 << (5 - i));
        RSB      R5,R2,#+5
        LSL      R5,R4,R5
        EORS     R1,R5,R1
// 1513 		}
// 1514 	}
??SetVersionPattern_2:
        ADDS     R2,R2,#+1
        CMP      R2,#+6
        BLT.N    ??SetVersionPattern_1
// 1515 
// 1516 	nVerData += m_nVersion << 12;
// 1517 
// 1518 	for (i = 0; i < 6; ++i)
        LDR      R3,[R3, #+8]
        LDR.W    R4,??DataTable53_2
        ADD      R0,R1,R0, LSL #+12
        ADDS     R5,R3,R4
        MOVS     R1,#+0
        MOVS     R2,#+0
        SUBS     R5,R5,#+11
        MOVS     R6,#+21
// 1519 	{
// 1520 		for (j = 0; j < 3; ++j)
??SetVersionPattern_3:
        ADDS     R7,R1,R4
        MLA      R7,R6,R3,R7
        SUBS     R7,R7,#+231
        MOV      R12,#+3
// 1521 		{
// 1522 			m_byModuleData[m_nSymbleSize - 11 + j][i] = m_byModuleData[i][m_nSymbleSize - 11 + j] =
// 1523 			(nVerData & (1 << (i * 3 + j))) ? '\x30' : '\x20';
??SetVersionPattern_4:
        ASR      LR,R0,R2
        LSLS     LR,LR,#+31
        ITE      MI 
        MOVMI    LR,#+48
        MOVPL    LR,#+32
        STRB     LR,[R5], #+1
// 1524 		}
        ADDS     R2,R2,#+1
        STRB     LR,[R7], #+21
        SUBS     R12,R12,#+1
        BNE.N    ??SetVersionPattern_4
// 1525 	}
        ADDS     R1,R1,#+1
        ADDW     R5,R5,#+18
        CMP      R1,#+6
        BLT.N    ??SetVersionPattern_3
// 1526 }
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock18
// 1527 //如果你以为我们可以开始画图，你就错了。
// 1528 //二维码的混乱技术还没有玩完，它还要把数据码和纠错码的各个codewords交替放在一起。
// 1529 //如何交替呢，规则如下：
// 1530 //对于数据码：把每个块的第一个codewords先拿出来按顺度排列好，
// 1531 //然后再取第一块的第二个，如此类推。如：上述示例中的Data Codewords如下

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function SetCodeWordPattern
          CFI NoCalls
        THUMB
// 1532 void SetCodeWordPattern(void)
// 1533 {
SetCodeWordPattern:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
// 1534 	int x = m_nSymbleSize;
        LDR.W    R0,??DataTable53_3
        LDR      R1,[R0, #+8]
// 1535 	int y = m_nSymbleSize - 1;
// 1536 
// 1537 	int nCoef_x = 1; 
// 1538 	int nCoef_y = 1; 
// 1539 
// 1540 	int i, j;
// 1541 
// 1542 	for (i = 0; i < m_ncAllCodeWord; ++i)
        LDR      R5,[R0, #+16]
        SUBS     R2,R1,#+1
        MOVS     R3,#+1
        MOV      R6,R1
        MOV      R4,R2
        MOV      R8,R3
        CMP      R5,#+1
        BLT.N    ??SetCodeWordPattern_0
        LDR.W    R7,??DataTable53_5
        MOV      R12,R3
// 1543 	{
// 1544 		for (j = 0; j < 8; ++j)
??SetCodeWordPattern_1:
        MOV      LR,#+0
// 1545 		{
// 1546 			do
// 1547 			{
// 1548 				x += nCoef_x;
??SetCodeWordPattern_2:
        ADDS     R6,R3,R6
// 1549 				nCoef_x *= -1;
        RSBS     R3,R3,#+0
// 1550 
// 1551 				if (nCoef_x < 0)
        BPL.N    ??SetCodeWordPattern_3
// 1552 				{
// 1553 					y += nCoef_y;
        ADDS     R4,R8,R4
// 1554 
// 1555 					if (y < 0 || y == m_nSymbleSize)
        BMI.N    ??SetCodeWordPattern_4
        CMP      R4,R1
        BNE.N    ??SetCodeWordPattern_3
// 1556 					{
// 1557 						y = (y < 0) ? 0 : m_nSymbleSize - 1;
??SetCodeWordPattern_4:
        CMP      R4,#+0
        ITE      MI 
        MOVMI    R4,#+0
        MOVPL    R4,R2
// 1558 						nCoef_y *= -1;
// 1559 
// 1560 						x -= 2;
        SUBS     R6,R6,#+2
        RSB      R8,R8,#+0
// 1561 
// 1562 						if (x == 6) 
        CMP      R6,#+6
        IT       EQ 
// 1563 							--x;
        MOVEQ    R6,#+5
// 1564 					}
// 1565 				}
// 1566 			}
// 1567 			while (m_byModuleData[x][y] & 0x20); 
??SetCodeWordPattern_3:
        MOVS     R0,#+21
        LDR.W    R9,??DataTable53_2
        MLA      R9,R0,R6,R9
        LDRB     R0,[R4, R9]
        LSLS     R0,R0,#+26
        BMI.N    ??SetCodeWordPattern_2
// 1568 
// 1569 			m_byModuleData[x][y] = (m_byAllCodeWord[i] & (1 << (7 - j))) ? '\x02' : '\x00';
        LDRB     R0,[R7, #+0]
        RSB      R10,LR,#+7
        LSL      R10,R12,R10
        TST      R0,R10
        ITE      NE 
        MOVNE    R0,#+2
        MOVEQ    R0,#+0
        STRB     R0,[R4, R9]
// 1570 		}
        ADD      LR,LR,#+1
        CMP      LR,#+8
        BLT.N    ??SetCodeWordPattern_2
// 1571 	}
        ADDS     R7,R7,#+1
        SUBS     R5,R5,#+1
        BNE.N    ??SetCodeWordPattern_1
// 1572 }
??SetCodeWordPattern_0:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock19
// 1573 //设置遮蔽信息

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI Function SetMaskingPattern
          CFI NoCalls
        THUMB
// 1574 void SetMaskingPattern(int nPatternNo)
// 1575 {
// 1576 	int i, j;
// 1577 	bool bMask;
// 1578 	for (i = 0; i < m_nSymbleSize; ++i)
SetMaskingPattern:
        LDR.W    R2,??DataTable53_3
        LDR      R2,[R2, #+8]
        MOVS     R1,#+0
        CMP      R2,#+1
        BGE.N    ??SetMaskingPattern_1
        BX       LR
??SetMaskingPattern_1:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        LDR.W    R3,??DataTable53_2
        MOVS     R4,#+0
        B.N      ??SetMaskingPattern_2
??SetMaskingPattern_3:
        MOVS     R4,#+0
??SetMaskingPattern_2:
        ADD      R6,R1,R1, LSR #+31
        ASR      R9,R6,#+1
        MOV      R5,R1
        ADD      R8,R1,R3
        SUB      R12,R1,R9, LSL #+1
// 1579 	{
// 1580 		for (j = 0; j < m_nSymbleSize; ++j)
// 1581 		{
// 1582 			if (! (m_byModuleData[j][i] & 0x20)) 
??SetMaskingPattern_4:
        LDRB     LR,[R8, #+0]
        LSLS     R6,LR,#+26
        BMI.N    ??SetMaskingPattern_5
// 1583 			{
// 1584 				switch (nPatternNo)
        CMP      R0,#+6
        BHI.N    ??SetMaskingPattern_6
        TBB      [PC, R0]
        DATA
??SetMaskingPattern_0:
        DC8      0x4,0x9,0xC,0x13
        DC8      0x1A,0x22,0x31,0x0
        THUMB
// 1585 				{
// 1586 				case 0:
// 1587 					bMask = ((i + j) % 2 == 0)?TRUE:FALSE;
??SetMaskingPattern_7:
        ADD      R7,R5,R5, LSR #+31
        ADDS     R6,R4,R1
        ASRS     R7,R7,#+1
        B.N      ??SetMaskingPattern_8
// 1588 					break;
// 1589 
// 1590 				case 1:
// 1591 					bMask = (i % 2 == 0)?TRUE:FALSE;
??SetMaskingPattern_9:
        SUBS     R7,R12,#+1
        B.N      ??SetMaskingPattern_10
// 1592 					break;
// 1593 
// 1594 				case 2:
// 1595 					bMask = (j % 3 == 0)?TRUE:FALSE;
??SetMaskingPattern_11:
        MOVS     R6,#+3
        SDIV     R6,R4,R6
        ADD      R6,R6,R6, LSL #+1
        SUBS     R6,R4,R6
        B.N      ??SetMaskingPattern_12
// 1596 					break;
// 1597 
// 1598 				case 3:
// 1599 					bMask = ((i + j) % 3 == 0)?TRUE:FALSE;
??SetMaskingPattern_13:
        MOVS     R6,#+3
        SDIV     R6,R5,R6
        ADD      R6,R6,R6, LSL #+1
        SUBS     R6,R5,R6
        B.N      ??SetMaskingPattern_12
??SetMaskingPattern_14:
        MOVS     R6,#+3
        SDIV     R6,R4,R6
        ADD      R6,R6,R9
        ADD      R7,R6,R6, LSR #+31
        ASRS     R7,R7,#+1
        B.N      ??SetMaskingPattern_8
// 1600 					break;
// 1601 
// 1602 				case 4:
// 1603 					bMask = (((i / 2) + (j / 3)) % 2 == 0)?TRUE:FALSE;
// 1604 					break;
// 1605 
// 1606 				case 5:
// 1607 					bMask = (((i * j) % 2) + ((i * j) % 3) == 0)?TRUE:FALSE;
??SetMaskingPattern_15:
        MUL      R6,R4,R1
        ADD      R7,R6,R6, LSR #+31
        SUB      R7,R6,R7, ASR #+1
        MOV      R10,#+3
        SDIV     R6,R6,R10
        ADD      R6,R6,R6, LSL #+1
        RSB      R6,R6,R7, LSL #+1
        B.N      ??SetMaskingPattern_12
// 1608 					break;
// 1609 
// 1610 				case 6:
// 1611 					bMask = ((((i * j) % 2) + ((i * j) % 3)) % 2 == 0)?TRUE:FALSE;
??SetMaskingPattern_16:
        MUL      R6,R4,R1
        ADD      R7,R6,R6, LSR #+31
        SUB      R11,R6,R7, ASR #+1
        MOVS     R7,#+3
        SDIV     R7,R6,R7
        ADD      R7,R7,R7, LSL #+1
        RSB      R10,R7,R11, LSL #+1
        ADD      R6,R10,R10, LSR #+31
        SUB      R6,R11,R6, ASR #+1
        RSB      R7,R7,R6, LSL #+1
        SUBS     R7,R7,#+1
        B.N      ??SetMaskingPattern_10
// 1612 					break;
// 1613 
// 1614 				default: 
// 1615 					bMask = ((((i * j) % 3) + ((i + j) % 2)) % 2 == 0)?TRUE:FALSE;
??SetMaskingPattern_6:
        MUL      R6,R4,R1
        MOVS     R7,#+3
        SDIV     R7,R6,R7
        ADD      R7,R7,R7, LSL #+1
        SUBS     R6,R6,R7
        ADDS     R6,R1,R6
        ADD      R7,R5,R5, LSR #+31
        ADDS     R6,R4,R6
        ASRS     R7,R7,#+1
        SUB      R10,R6,R7, LSL #+1
        ADD      R10,R10,R10, LSR #+31
        ADD      R7,R7,R10, ASR #+1
??SetMaskingPattern_8:
        SUB      R6,R6,R7, LSL #+1
??SetMaskingPattern_12:
        SUBS     R7,R6,#+1
??SetMaskingPattern_10:
        SBCS     R7,R7,R7
// 1616 					break;
// 1617 				}
// 1618 
// 1619 				m_byModuleData[j][i] = (BYTE)((m_byModuleData[j][i] & 0xfe) | (((m_byModuleData[j][i] & 0x02) > 1) ^ bMask));
        AND      R6,LR,#0x2
        CMP      R6,#+2
        ITE      GE 
        MOVGE    R6,#+1
        MOVLT    R6,#+0
        AND      LR,LR,#0xFE
        EORS     R6,R6,R7, LSR #+31
        ORR      LR,R6,LR
        STRB     LR,[R8, #+0]
// 1620 			}
// 1621 		}
??SetMaskingPattern_5:
        ADDS     R4,R4,#+1
        ADDS     R5,R5,#+1
        ADDW     R8,R8,#+21
        CMP      R4,R2
        BLT.W    ??SetMaskingPattern_4
// 1622 	}
        ADDS     R1,R1,#+1
        CMP      R1,R2
        BLT.W    ??SetMaskingPattern_3
// 1623 }
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock20
// 1624 //设置格式化信息 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function SetFormatInfoPattern
          CFI NoCalls
        THUMB
// 1625 void SetFormatInfoPattern(int nPatternNo)
// 1626 {
SetFormatInfoPattern:
        PUSH     {R4,R5}
          CFI R5 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 1627 	int nFormatInfo;
// 1628 	int i;
// 1629 	int nFormatData;
// 1630 
// 1631 	switch (m_nLevel)
        LDR.W    R1,??DataTable53_3
        LDR      R2,[R1, #+20]
        CBZ.N    R2,??SetFormatInfoPattern_0
        CMP      R2,#+2
        BEQ.N    ??SetFormatInfoPattern_1
        ITE      CC 
// 1632 	{
// 1633 	case QR_LEVEL_M:
// 1634 		nFormatInfo = 0x00; 
        MOVCC    R2,#+0
// 1635 		break;
// 1636 
// 1637 	case QR_LEVEL_L:
// 1638 		nFormatInfo = 0x08; 
// 1639 		break;
// 1640 
// 1641 	case QR_LEVEL_Q:
// 1642 		nFormatInfo = 0x18; 
// 1643 		break;
// 1644 
// 1645 	default: 
// 1646 		nFormatInfo = 0x10; 
        MOVCS    R2,#+16
        B.N      ??SetFormatInfoPattern_2
??SetFormatInfoPattern_0:
        MOVS     R2,#+8
        B.N      ??SetFormatInfoPattern_2
??SetFormatInfoPattern_1:
        MOVS     R2,#+24
// 1647 		break;
// 1648 	}
// 1649 
// 1650 	nFormatInfo += nPatternNo;
??SetFormatInfoPattern_2:
        ADDS     R0,R0,R2
// 1651 
// 1652 	nFormatData = nFormatInfo << 10;
        LSLS     R2,R0,#+10
// 1653 
// 1654 	for (i = 0; i < 5; ++i)
        MOVS     R3,#+0
        MOVW     R4,#+1335
// 1655 	{
// 1656 		if (nFormatData & (1 << (14 - i)))
??SetFormatInfoPattern_3:
        RSB      R5,R3,#+14
        ASR      R5,R2,R5
        LSLS     R5,R5,#+31
        BPL.N    ??SetFormatInfoPattern_4
// 1657 		{
// 1658 			nFormatData ^= (0x0537 << (4 - i)); 
        RSB      R5,R3,#+4
        LSL      R5,R4,R5
        EORS     R2,R5,R2
// 1659 		}
// 1660 	}
??SetFormatInfoPattern_4:
        ADDS     R3,R3,#+1
        CMP      R3,#+5
        BLT.N    ??SetFormatInfoPattern_3
// 1661 
// 1662 	nFormatData += nFormatInfo << 10;
// 1663 
// 1664 	nFormatData ^= 0x5412;
        ADD      R0,R2,R0, LSL #+10
        EOR      R0,R0,#0x5400
// 1665 
// 1666 	for (i = 0; i <= 5; ++i)
        LDR.W    R2,??DataTable53_2
        EOR      R0,R0,#0x12
        MOVS     R3,#+0
        ADD      R4,R2,#+168
// 1667 		m_byModuleData[8][i] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_5:
        ASR      R5,R0,R3
        LSLS     R5,R5,#+31
        ITE      MI 
        MOVMI    R5,#+48
        MOVPL    R5,#+32
        STRB     R5,[R4, #+0]
        ADDS     R3,R3,#+1
        ASR      R5,R0,R3
        LSLS     R5,R5,#+31
        ITE      MI 
        MOVMI    R5,#+48
        MOVPL    R5,#+32
        STRB     R5,[R4, #+1]
        ADDS     R3,R3,#+1
        ADDS     R4,R4,#+2
        CMP      R3,#+6
        BLT.N    ??SetFormatInfoPattern_5
// 1668 
// 1669 	m_byModuleData[8][7] = (nFormatData & (1 << 6)) ? '\x30' : '\x20';
        LSLS     R3,R0,#+25
        ITE      MI 
        MOVMI    R3,#+48
        MOVPL    R3,#+32
        ADDW     R4,R2,#+155
        STRB     R3,[R4, #+20]
// 1670 	m_byModuleData[8][8] = (nFormatData & (1 << 7)) ? '\x30' : '\x20';
        LSLS     R3,R0,#+24
        ITE      MI 
        MOVMI    R3,#+48
        MOVPL    R3,#+32
        STRB     R3,[R4, #+21]
// 1671 	m_byModuleData[7][8] = (nFormatData & (1 << 8)) ? '\x30' : '\x20';
        LSLS     R3,R0,#+23
        ITE      MI 
        MOVMI    R3,#+48
        MOVPL    R3,#+32
        STRB     R3,[R2, #+155]
// 1672 
// 1673 	for (i = 9; i <= 14; ++i)
        ADD      R4,R2,#+92
        MOVS     R3,#+9
// 1674 		m_byModuleData[14 - i][8] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_6:
        ASR      R5,R0,R3
        LSLS     R5,R5,#+31
        ITE      MI 
        MOVMI    R5,#+48
        MOVPL    R5,#+32
        STRB     R5,[R4, #+21]
        ADDS     R3,R3,#+1
        ASR      R5,R0,R3
        LSLS     R5,R5,#+31
        ITE      MI 
        MOVMI    R5,#+48
        MOVPL    R5,#+32
        ADDS     R3,R3,#+1
        STRB     R5,[R4], #-42
        CMP      R3,#+15
        BLT.N    ??SetFormatInfoPattern_6
// 1675 
// 1676 	for (i = 0; i <= 7; ++i)
        LDR      R1,[R1, #+8]
        MOVS     R4,#+21
        MLA      R4,R4,R1,R2
        MOVS     R3,#+0
        SUBS     R4,R4,#+34
// 1677 		m_byModuleData[m_nSymbleSize - 1 - i][8] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_7:
        ASR      R5,R0,R3
        LSLS     R5,R5,#+31
        ITE      MI 
        MOVMI    R5,#+48
        MOVPL    R5,#+32
        STRB     R5,[R4, #+21]
        ADDS     R3,R3,#+1
        ASR      R5,R0,R3
        LSLS     R5,R5,#+31
        ITE      MI 
        MOVMI    R5,#+48
        MOVPL    R5,#+32
        ADDS     R3,R3,#+1
        STRB     R5,[R4], #-42
        CMP      R3,#+8
        BLT.N    ??SetFormatInfoPattern_7
// 1678 
// 1679 	m_byModuleData[8][m_nSymbleSize - 8] = '\x30';
        ADDS     R1,R1,R2
        MOVS     R2,#+48
        STRB     R2,[R1, #+160]
// 1680 
// 1681 	for (i = 8; i <= 14; ++i)
        ADDW     R1,R1,#+161
        MOVS     R2,#+8
// 1682 		m_byModuleData[8][m_nSymbleSize - 15 + i] = (nFormatData & (1 << i)) ? '\x30' : '\x20';
??SetFormatInfoPattern_8:
        ASR      R3,R0,R2
        LSLS     R3,R3,#+31
        ITE      MI 
        MOVMI    R3,#+48
        MOVPL    R3,#+32
        ADDS     R2,R2,#+1
        STRB     R3,[R1], #+1
        CMP      R2,#+15
        BLT.N    ??SetFormatInfoPattern_8
// 1683 }
        POP      {R4,R5}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI CFA R13+0
        BX       LR               ;; return
          CFI EndBlock cfiBlock21

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable52:
        DC32     0xffff7ec0
// 1684 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function CountPenalty
          CFI NoCalls
        THUMB
// 1685 int CountPenalty(void)
// 1686 {
CountPenalty:
        PUSH     {R2-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
// 1687 	int nPenalty = 0;
// 1688 	int i, j, k;
// 1689 	int nCount = 0, s_nCount;
        LDR.W    R1,??DataTable53_3
        LDR      R1,[R1, #+8]
        MOVS     R2,#+0
        MOVS     R0,#+0
        CMP      R1,#+1
        BLT.N    ??CountPenalty_0
        LDR.W    R12,??DataTable53_2
        MOV      R3,R12
        MOV      R8,R1
        SUBS     R5,R1,#+4
// 1690 
// 1691 	for (i = 0; i < m_nSymbleSize; ++i)
// 1692 	{
// 1693 		for (j = 0; j < m_nSymbleSize - 4; ++j)
??CountPenalty_1:
        MOVS     R4,#+0
        B.N      ??CountPenalty_2
// 1694 		{
// 1695 			int nCount = 1;
// 1696 
// 1697 			for (k = j + 1; k < m_nSymbleSize; k++)
// 1698 			{
// 1699 				if (((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i][k] & 0x11) == 0))
// 1700 					++nCount;
??CountPenalty_3:
        ADDS     R7,R7,#+1
        ADDS     R6,R6,#+1
??CountPenalty_4:
        CMP      R6,R1
        BGE.N    ??CountPenalty_5
        LDRB     R9,[R4, R3]
        AND      R10,R9,#0x11
        SUBS     R9,R10,#+1
        LDRB     R10,[LR], #+1
        SBC      R9,R9,R9
        AND      R11,R10,#0x11
        SUBS     R10,R11,#+1
        LSR      R9,R9,#+31
        SBC      R10,R10,R10
        CMP      R9,R10, LSR #+31
        BEQ.N    ??CountPenalty_3
// 1701 				else
// 1702 					break;
// 1703 			}
// 1704 
// 1705 			if (nCount >= 5)
??CountPenalty_5:
        CMP      R7,#+5
        ITT      GE 
// 1706 			{
// 1707 				nPenalty += 3 + (nCount - 5);
        SUBGE    R4,R7,#+2
        ADDGE    R2,R4,R2
// 1708 			}
// 1709 
// 1710 			j = k - 1;
        MOV      R4,R6
??CountPenalty_2:
        CMP      R4,R5
        BGE.N    ??CountPenalty_6
        ADDS     R6,R4,#+1
        MOVS     R7,#+1
        ADD      LR,R6,R3
        B.N      ??CountPenalty_4
// 1711 		}
// 1712 	}
??CountPenalty_6:
        ADDW     R3,R3,#+21
        SUBS     R8,R8,#+1
        BNE.N    ??CountPenalty_1
        MOVS     R3,#+0
        MOV      R8,#+21
// 1713 
// 1714 	for (i = 0; i < m_nSymbleSize; ++i)
// 1715 	{
// 1716 		for (j = 0; j < m_nSymbleSize - 4; ++j)
??CountPenalty_7:
        MOVS     R4,#+0
        B.N      ??CountPenalty_8
// 1717 		{
// 1718 			int nCount = 1;
// 1719 
// 1720 			for (k = j + 1; k < m_nSymbleSize; k++)
// 1721 			{
// 1722 				if (((m_byModuleData[j][i] & 0x11) == 0) == ((m_byModuleData[k][i] & 0x11) == 0))
// 1723 					++nCount;
??CountPenalty_9:
        ADDS     R7,R7,#+1
        ADDS     R6,R6,#+1
??CountPenalty_10:
        CMP      R6,R1
        BGE.N    ??CountPenalty_11
        ADD      R9,R3,R12
        LDRB     R9,[R4, R9]
        AND      R10,R9,#0x11
        SUBS     R9,R10,#+1
        LDRB     R10,[LR], #+21
        SBC      R9,R9,R9
        AND      R11,R10,#0x11
        SUBS     R10,R11,#+1
        LSR      R9,R9,#+31
        SBC      R10,R10,R10
        CMP      R9,R10, LSR #+31
        BEQ.N    ??CountPenalty_9
// 1724 				else
// 1725 					break;
// 1726 			}
// 1727 
// 1728 			if (nCount >= 5)
??CountPenalty_11:
        CMP      R7,#+5
        ITT      GE 
// 1729 			{
// 1730 				nPenalty += 3 + (nCount - 5);
        SUBGE    R4,R7,#+2
        ADDGE    R2,R4,R2
// 1731 			}
// 1732 
// 1733 			j = k - 1;
        MOV      R4,R6
??CountPenalty_8:
        CMP      R4,R5
        BGE.N    ??CountPenalty_12
        ADDS     R6,R4,#+1
        ADD      LR,R3,R12
        MOVS     R7,#+1
        MLA      LR,R8,R6,LR
        MUL      R4,R8,R4
        B.N      ??CountPenalty_10
// 1734 		}
// 1735 	}
??CountPenalty_12:
        ADDS     R3,R3,#+1
        CMP      R3,R1
        BLT.N    ??CountPenalty_7
// 1736 
// 1737 	for (i = 0; i < m_nSymbleSize - 1; ++i)
??CountPenalty_0:
        SUBS     R3,R1,#+1
        CMP      R3,#+1
        BLT.N    ??CountPenalty_13
        LDR.N    R4,??DataTable53_2
        MOV      R5,R3
??CountPenalty_14:
        MOV      R6,R4
        ADDW     R8,R4,#+21
        MOV      R12,R3
// 1738 	{
// 1739 		for (j = 0; j < m_nSymbleSize - 1; ++j)
// 1740 		{
// 1741 			if ((((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i + 1][j]		& 0x11) == 0)) &&
// 1742 				(((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i]	[j + 1] & 0x11) == 0)) &&
// 1743 				(((m_byModuleData[i][j] & 0x11) == 0) == ((m_byModuleData[i + 1][j + 1] & 0x11) == 0)))
??CountPenalty_15:
        LDRB     LR,[R6, #+0]
        AND      R7,LR,#0x11
        SUBS     LR,R7,#+1
        LDRB     R7,[R8, #+0]
        SBC      LR,LR,LR
        AND      R9,R7,#0x11
        SUBS     R7,R9,#+1
        LSR      LR,LR,#+31
        SBCS     R7,R7,R7
        CMP      LR,R7, LSR #+31
        BNE.N    ??CountPenalty_16
        LDRB     R7,[R6, #+1]
        AND      R9,R7,#0x11
        SUBS     R7,R9,#+1
        SBCS     R7,R7,R7
        CMP      LR,R7, LSR #+31
        BNE.N    ??CountPenalty_16
        LDRB     R7,[R8, #+1]
        AND      R9,R7,#0x11
        SUBS     R7,R9,#+1
        SBCS     R7,R7,R7
        CMP      LR,R7, LSR #+31
        IT       EQ 
// 1744 			{
// 1745 				nPenalty += 3;
        ADDEQ    R2,R2,#+3
// 1746 			}
// 1747 		}
??CountPenalty_16:
        ADDS     R6,R6,#+1
        ADD      R8,R8,#+1
        SUBS     R12,R12,#+1
        BNE.N    ??CountPenalty_15
// 1748 	}
        ADDW     R4,R4,#+21
        SUBS     R5,R5,#+1
        BNE.N    ??CountPenalty_14
// 1749 
// 1750 	for (i = 0; i < m_nSymbleSize; ++i)
??CountPenalty_13:
        CMP      R1,#+1
        BLT.W    ??CountPenalty_17
        SUB      R5,R1,#+10
        STR      R5,[SP, #+4]
        MOV      R3,R1
        LDR.W    R12,??DataTable53_2
        SUB      R5,R1,#+9
        MOV      R8,R12
        STR      R5,[SP, #+0]
        SUB      R10,R1,#+8
        SUB      R9,R1,#+7
        SUBS     R7,R1,#+6
// 1751 	{
// 1752 		for (j = 0; j < m_nSymbleSize - 6; ++j)
??CountPenalty_18:
        MOVS     R4,#+0
        CMP      R7,#+1
        BLT.N    ??CountPenalty_19
        MOV      R5,R8
        B.N      ??CountPenalty_20
// 1753 		{
// 1754 			if (((j == 0) ||				 (! (m_byModuleData[i][j - 1] & 0x11))) && //   V{O
// 1755 											 (   m_byModuleData[i][j]     & 0x11)   && //  - 1
// 1756 											 (! (m_byModuleData[i][j + 1] & 0x11))  && //  - 1
// 1757 											 (   m_byModuleData[i][j + 2] & 0x11)   && //  
// 1758 											 (   m_byModuleData[i][j + 3] & 0x11)   && //  3
// 1759 											 (   m_byModuleData[i][j + 4] & 0x11)   && //  
// 1760 											 (! (m_byModuleData[i][j + 5] & 0x11))  && //  - 1
// 1761 											 (   m_byModuleData[i][j + 6] & 0x11)   && //  - 1
// 1762 				((j == m_nSymbleSize - 7) || (! (m_byModuleData[i][j + 7] & 0x11))))   //   V{O
??CountPenalty_21:
        CMP      R4,#+0
        ITT      NE 
        LDRBNE   R6,[R5, #-1]
        TSTNE    R6,LR
        BNE.N    ??CountPenalty_22
??CountPenalty_20:
        LDRB     R6,[R5, #+0]
        MOV      LR,#+17
        TST      R6,LR
        BEQ.N    ??CountPenalty_22
        LDRB     R6,[R5, #+1]
        TST      R6,LR
        BNE.N    ??CountPenalty_22
        LDRB     R6,[R5, #+2]
        TST      R6,LR
        ITTTT    NE 
        LDRBNE   R6,[R5, #+3]
        TSTNE    R6,LR
        LDRBNE   R6,[R5, #+4]
        TSTNE    R6,LR
        BEQ.N    ??CountPenalty_22
        LDRB     R6,[R5, #+5]
        TST      R6,LR
        BNE.N    ??CountPenalty_22
        LDRB     R6,[R5, #+6]
        TST      R6,LR
        BEQ.N    ??CountPenalty_22
        CMP      R4,R9
        ITT      NE 
        LDRBNE   R6,[R5, #+7]
        TSTNE    R6,LR
        BNE.N    ??CountPenalty_22
// 1763 			{
// 1764 				if (((j < 2 || ! (m_byModuleData[i][j - 2] & 0x11)) && 
// 1765 					 (j < 3 || ! (m_byModuleData[i][j - 3] & 0x11)) &&
// 1766 					 (j < 4 || ! (m_byModuleData[i][j - 4] & 0x11))) ||
// 1767 					((j >= m_nSymbleSize - 8  || ! (m_byModuleData[i][j + 8]  & 0x11)) &&
// 1768 					 (j >= m_nSymbleSize - 9  || ! (m_byModuleData[i][j + 9]  & 0x11)) &&
// 1769 					 (j >= m_nSymbleSize - 10 || ! (m_byModuleData[i][j + 10] & 0x11))))
        CMP      R4,#+2
        BLT.N    ??CountPenalty_23
        LDRB     R6,[R5, #-2]
        TST      R6,LR
        BNE.N    ??CountPenalty_24
??CountPenalty_23:
        CMP      R4,#+3
        BLT.N    ??CountPenalty_25
        LDRB     R6,[R5, #-3]
        TST      R6,LR
        BNE.N    ??CountPenalty_24
??CountPenalty_25:
        CMP      R4,#+4
        BLT.N    ??CountPenalty_26
        LDRB     R6,[R5, #-4]
        TST      R6,LR
        BEQ.N    ??CountPenalty_26
??CountPenalty_24:
        CMP      R4,R10
        BGE.N    ??CountPenalty_27
        LDRB     R6,[R5, #+8]
        TST      R6,LR
        BNE.N    ??CountPenalty_22
??CountPenalty_27:
        LDR      R6,[SP, #+0]
        CMP      R4,R6
        BGE.N    ??CountPenalty_28
        LDRB     R6,[R5, #+9]
        TST      R6,LR
        BNE.N    ??CountPenalty_22
??CountPenalty_28:
        LDR      R6,[SP, #+4]
        CMP      R4,R6
        BGE.N    ??CountPenalty_26
        LDRB     R6,[R5, #+10]
        TST      R6,LR
        BNE.N    ??CountPenalty_22
// 1770 				{
// 1771 					nPenalty += 40;
??CountPenalty_26:
        ADDS     R2,R2,#+40
// 1772 				}
// 1773 			}
// 1774 		}
??CountPenalty_22:
        ADDS     R4,R4,#+1
        ADDS     R5,R5,#+1
        CMP      R4,R7
        BLT.N    ??CountPenalty_21
// 1775 	}
??CountPenalty_19:
        ADDW     R8,R8,#+21
        SUBS     R3,R3,#+1
        BNE.N    ??CountPenalty_18
        SUB      R5,R1,#+10
        STR      R5,[SP, #+4]
        SUB      LR,R12,#+84
        SUB      R5,R1,#+9
        STR      R5,[SP, #+0]
        MOV      R11,#+17
// 1776 
// 1777 	for (i = 0; i < m_nSymbleSize; ++i)
// 1778 	{
// 1779 		for (j = 0; j < m_nSymbleSize - 6; ++j)
??CountPenalty_29:
        MOVS     R4,#+0
        CMP      R7,#+1
        BLT.N    ??CountPenalty_30
        MOV      R5,LR
        ADD      R6,R3,R12
        B.N      ??CountPenalty_31
// 1780 		{
// 1781 			if (((j == 0) ||				 (! (m_byModuleData[j - 1][i] & 0x11))) && //   V{O
// 1782 											 (   m_byModuleData[j]    [i] & 0x11)   && //  - 1
// 1783 											 (! (m_byModuleData[j + 1][i] & 0x11))  && //  - 1
// 1784 											 (   m_byModuleData[j + 2][i] & 0x11)   && //  
// 1785 											 (   m_byModuleData[j + 3][i] & 0x11)   && //  3
// 1786 											 (   m_byModuleData[j + 4][i] & 0x11)   && //  
// 1787 											 (! (m_byModuleData[j + 5][i] & 0x11))  && //  - 1
// 1788 											 (   m_byModuleData[j + 6][i] & 0x11)   && //  - 1
// 1789 				((j == m_nSymbleSize - 7) || (! (m_byModuleData[j + 7][i] & 0x11))))   //   V{O
??CountPenalty_32:
        CMP      R4,#+0
        ITT      NE 
        LDRBNE   R8,[R5, #+63]
        TSTNE    R8,R11
        BNE.N    ??CountPenalty_33
??CountPenalty_31:
        LDRB     R8,[R6, #+0]
        TST      R8,R11
        BEQ.N    ??CountPenalty_33
        LDRB     R8,[R5, #+105]
        TST      R8,R11
        BNE.N    ??CountPenalty_33
        LDRB     R8,[R5, #+126]
        TST      R8,R11
        ITTTT    NE 
        LDRBNE   R8,[R5, #+147]
        TSTNE    R8,R11
        LDRBNE   R8,[R5, #+168]
        TSTNE    R8,R11
        BEQ.N    ??CountPenalty_33
        LDRB     R8,[R5, #+189]
        TST      R8,R11
        BNE.N    ??CountPenalty_33
        LDRB     R8,[R5, #+210]
        TST      R8,R11
        BEQ.N    ??CountPenalty_33
        CMP      R4,R9
        ITT      NE 
        LDRBNE   R8,[R5, #+231]
        TSTNE    R8,R11
        BNE.N    ??CountPenalty_33
// 1790 			{
// 1791 				if (((j < 2 || ! (m_byModuleData[j - 2][i] & 0x11)) && 
// 1792 					 (j < 3 || ! (m_byModuleData[j - 3][i] & 0x11)) &&
// 1793 					 (j < 4 || ! (m_byModuleData[j - 4][i] & 0x11))) ||
// 1794 					((j >= m_nSymbleSize - 8  || ! (m_byModuleData[j + 8][i]  & 0x11)) &&
// 1795 					 (j >= m_nSymbleSize - 9  || ! (m_byModuleData[j + 9][i]  & 0x11)) &&
// 1796 					 (j >= m_nSymbleSize - 10 || ! (m_byModuleData[j + 10][i] & 0x11))))
        CMP      R4,#+2
        BLT.N    ??CountPenalty_34
        LDRB     R8,[R5, #+42]
        TST      R8,R11
        BNE.N    ??CountPenalty_35
??CountPenalty_34:
        CMP      R4,#+3
        BLT.N    ??CountPenalty_36
        LDRB     R8,[R5, #+21]
        TST      R8,R11
        BNE.N    ??CountPenalty_35
??CountPenalty_36:
        CMP      R4,#+4
        BLT.N    ??CountPenalty_37
        LDRB     R8,[R5, #+0]
        TST      R8,R11
        BEQ.N    ??CountPenalty_37
??CountPenalty_35:
        CMP      R4,R10
        BGE.N    ??CountPenalty_38
        LDRB     R8,[R5, #+252]
        TST      R8,R11
        BNE.N    ??CountPenalty_33
??CountPenalty_38:
        LDR      R8,[SP, #+0]
        CMP      R4,R8
        BGE.N    ??CountPenalty_39
        LDRB     R8,[R5, #+273]
        TST      R8,R11
        BNE.N    ??CountPenalty_33
??CountPenalty_39:
        LDR      R8,[SP, #+4]
        CMP      R4,R8
        BGE.N    ??CountPenalty_37
        LDRB     R8,[R5, #+294]
        TST      R8,R11
        BNE.N    ??CountPenalty_33
// 1797 				{
// 1798 					nPenalty += 40;
??CountPenalty_37:
        ADDS     R2,R2,#+40
// 1799 				}
// 1800 			}
// 1801 		}
??CountPenalty_33:
        ADDS     R4,R4,#+1
        ADDW     R6,R6,#+21
        ADDW     R5,R5,#+21
        CMP      R4,R7
        BLT.N    ??CountPenalty_32
// 1802 	}
??CountPenalty_30:
        ADDS     R3,R3,#+1
        ADD      LR,LR,#+1
        CMP      R3,R1
        BLT.N    ??CountPenalty_29
        MOV      R4,R1
??CountPenalty_40:
        MOV      R5,R12
        MOV      R6,R1
// 1803 
// 1804 	for (i = 0; i < m_nSymbleSize; ++i)
// 1805 	{
// 1806 		for (j = 0; j < m_nSymbleSize; ++j)
// 1807 		{
// 1808 			if (! (m_byModuleData[i][j] & 0x11))
??CountPenalty_41:
        LDRB     R3,[R5, #+0]
        TST      R3,R11
        IT       EQ 
// 1809 			{
// 1810 				++nCount;
        ADDEQ    R0,R0,#+1
// 1811 			}
// 1812 		}
        ADDS     R5,R5,#+1
        SUBS     R6,R6,#+1
        BNE.N    ??CountPenalty_41
// 1813 	}
        ADDW     R12,R12,#+21
        SUBS     R4,R4,#+1
        BNE.N    ??CountPenalty_40
// 1814 	
// 1815 	if( (50 - ((nCount * 100) / (m_nSymbleSize * m_nSymbleSize))) > 0)
??CountPenalty_17:
        MOVS     R3,#+100
        MULS     R0,R3,R0
        MULS     R1,R1,R1
        SDIV     R0,R0,R1
        RSB      R1,R0,#+50
        CMP      R1,#+1
        IT       LT 
// 1816 		s_nCount = 50 - ((nCount * 100) / (m_nSymbleSize * m_nSymbleSize));
// 1817 	else
// 1818 		s_nCount = 0 - (50 - ((nCount * 100) / (m_nSymbleSize * m_nSymbleSize)));
        SUBLT    R1,R0,#+50
// 1819 	nPenalty += (s_nCount / 5) * 10;
// 1820 
// 1821 	return nPenalty;
        MOVS     R0,#+5
        SDIV     R0,R1,R0
        ADD      R1,R0,R0, LSL #+2
        ADD      R0,R2,R1, LSL #+1
        POP      {R1,R2,R4-R11,PC}  ;; return
          CFI EndBlock cfiBlock22
// 1822 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53:
        DC32     0xffff5e5f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53_1:
        DC32     byRSExp

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53_2:
        DC32     m_byModuleData

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53_3:
        DC32     ??byPattern

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53_4:
        DC32     ??byPattern_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable53_5:
        DC32     m_byAllCodeWord
// 1823 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function Print_2DCode
          CFI NoCalls
        THUMB
// 1824 void Print_2DCode(void)
// 1825 {
// 1826 	int i,j,k,x,y,z,size,mod;
// 1827 	BYTE bit_h,bit_v,print_num;//print_buff[1024];
// 1828 	BYTE print_buff[256];
// 1829 
// 1830 //--	SendCmd(3, 0x1b, 0x4a, 25);
// 1831 	
// 1832 	bit_h = 4;
// 1833 	bit_v = 2;
// 1834 
// 1835 	size = m_nSymbleSize/bit_v;
// 1836 	mod = m_nSymbleSize%bit_v;
// 1837 
// 1838 	print_num = bit_h * m_nSymbleSize;
// 1839 	
// 1840 	for(i=0; i<size; i++)
// 1841 	{	
// 1842 		print_buff[0] = 0x1b;
// 1843 		print_buff[1] = 0x2a;
// 1844 		print_buff[2] = print_num;
// 1845 		print_buff[3] = 0x00;
// 1846 		x = 4;
// 1847 	
// 1848 		for(j=0;j<m_nSymbleSize;j++)
// 1849 		{	
// 1850 			k = i*bit_v;			
// 1851 			if(m_byModuleData[j][k] == 1 && m_byModuleData[j][k+1] == 1)
// 1852 			{
// 1853 				print_buff[x] = 0xFF;
// 1854 				x++;
// 1855 			}
// 1856 			else if(m_byModuleData[j][k] == 1 && m_byModuleData[j][k+1] == 0)
// 1857 			{
// 1858 				print_buff[x] = 0xF0;
// 1859 				x++;
// 1860 			}
// 1861 			else if(m_byModuleData[j][k] == 0 && m_byModuleData[j][k+1] == 1)
// 1862 			{
// 1863 				print_buff[x] = 0x0F;
// 1864 				x++;
// 1865 			}
// 1866 			else
// 1867 			{
// 1868 				print_buff[x] = 0x00;
// 1869 				x++;
// 1870 			}
// 1871 			k = k+2;
// 1872 				
// 1873 			for(y=0; y<(bit_h-1); y++)
// 1874 			{  
// 1875 				print_buff[x] = print_buff[x-1];
// 1876 				x++;
// 1877 			}
// 1878 		}
// 1879 		
// 1880 		for(z=0;z<(print_num+4);z++);
// 1881 //--		ser_send_char(1,print_buff[z]);
// 1882 		
// 1883 //--		SendCmd(3, 0x1b, 0x4a, 0);	
// 1884 	}
// 1885 	
// 1886 	if(mod !=0)
// 1887 	{
// 1888 		print_buff[0] = 0x1b;
// 1889 		print_buff[1] = 0x2a;
// 1890 		print_buff[2] = print_num;
// 1891 		print_buff[3] = 0x00;
// 1892 		x = 4;
// 1893 		
// 1894 		for(j=0;j<m_nSymbleSize;j++)
// 1895 		{
// 1896 			i = size * bit_v;				
// 1897 			if(m_byModuleData[j][i] == 1)
// 1898 			{
// 1899 				print_buff[x] = 0xF0;
// 1900 				x++;
// 1901 			}
// 1902 			else
// 1903 			{
// 1904 				print_buff[x] = 0x00;
// 1905 				x++;
// 1906 			}	
// 1907 				
// 1908 			for(y=0; y<(bit_h-1); y++)
// 1909 			{
// 1910 				print_buff[x] = print_buff[x-1];
// 1911 				x++;	
// 1912 			}
// 1913 		}
// 1914 
// 1915 		for(z=0;z<(print_num+4);z++);
// 1916 //--		ser_send_char(1,print_buff[z]);
// 1917 		
// 1918 //--		SendCmd(3, 0x1b, 0x4a, 0);
// 1919 	}
// 1920 
// 1921 //--	SendCmd(3, 0x1b, 0x4a, 25);
// 1922 }
Print_2DCode:
        BX       LR               ;; return
          CFI EndBlock cfiBlock23

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
QR_VersonInfo:
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 26, 19, 16, 13, 9
        DC16 0, 0, 0, 0, 0, 0, 0, 1, 26, 19, 1, 26, 16, 1, 26, 13, 1, 26, 9, 0
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 44, 34, 28, 22, 16, 1, 18, 0
        DC16 0, 0, 0, 0, 1, 44, 34, 1, 44, 28, 1, 44, 22, 1, 44, 16, 0, 0, 0, 0
        DC16 0, 0, 0, 0, 0, 0, 0, 0, 3, 70, 55, 44, 34, 26, 1, 22, 0, 0, 0, 0
        DC16 0, 1, 70, 55, 1, 70, 44, 2, 35, 17, 2, 35, 13, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 0, 0, 0, 4, 100, 80, 64, 48, 36, 1, 26, 0, 0, 0, 0, 0, 1
        DC16 100, 80, 2, 50, 32, 2, 50, 24, 4, 25, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 0, 5, 134, 108, 86, 62, 46, 1, 30, 0, 0, 0, 0, 0, 1, 134
        DC16 108, 2, 67, 43, 2, 33, 15, 2, 33, 11, 0, 0, 0, 0, 0, 0, 2, 34, 16
        DC16 2, 34, 12, 6, 172, 136, 108, 76, 60, 1, 34, 0, 0, 0, 0, 0, 2, 86
        DC16 68, 4, 43, 27, 4, 43, 19, 4, 43, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC16 0, 0, 7, 196, 156, 124, 88, 66, 2, 22, 38, 0, 0, 0, 0, 2, 98, 78
        DC16 4, 49, 31, 2, 32, 14, 4, 39, 13, 0, 0, 0, 0, 0, 0, 4, 33, 15, 1
        DC16 40, 14, 8, 242, 194, 154, 110, 86, 2, 24, 42, 0, 0, 0, 0, 2, 121
        DC16 97, 2, 60, 38, 4, 40, 18, 4, 40, 14, 0, 0, 0, 2, 61, 39, 2, 41, 19
        DC16 2, 41, 15, 9, 292, 232, 182, 132, 100, 2, 26, 46, 0, 0, 0, 0, 2
        DC16 146, 116, 3, 58, 36, 4, 36, 16, 4, 36, 12, 0, 0, 0, 2, 59, 37, 4
        DC16 37, 17, 4, 37, 13, 10, 346, 274, 216, 154, 122, 2, 28, 50, 0, 0, 0
        DC16 0, 2, 86, 68, 4, 69, 43, 6, 43, 19, 6, 43, 15, 2, 87, 69, 1, 70
        DC16 44, 2, 44, 20, 2, 44, 16, 11, 404, 324, 254, 180, 140, 2, 30, 54
        DC16 0, 0, 0, 0, 4, 101, 81, 1, 80, 50, 4, 50, 22, 3, 36, 12, 0, 0, 0
        DC16 4, 81, 51, 4, 51, 23, 8, 37, 13, 12, 466, 370, 290, 206, 158, 2
        DC16 32, 58, 0, 0, 0, 0, 2, 116, 92, 6, 58, 36, 4, 46, 20, 7, 42, 14, 2
        DC16 117, 93, 2, 59, 37, 6, 47, 21, 4, 43, 15, 13, 532, 428, 334, 244
        DC16 180, 2, 34, 62, 0, 0, 0, 0, 4, 133, 107, 8, 59, 37, 8, 44, 20, 12
        DC16 33, 11, 0, 0, 0, 1, 60, 38, 4, 45, 21, 4, 34, 12, 14, 581, 461
        DC16 365, 261, 197, 3, 26, 46, 66, 0, 0, 0, 3, 145, 115, 4, 64, 40, 11
        DC16 36, 16, 11, 36, 12, 1, 146, 116, 5, 65, 41, 5, 37, 17, 5, 37, 13
        DC16 15, 655, 523, 415, 295, 223, 3, 26, 48, 70, 0, 0, 0, 5, 109, 87, 5
        DC16 65, 41, 5, 54, 24, 11, 36, 12, 1, 110, 88, 5, 66, 42, 7, 55, 25, 7
        DC16 37, 13, 16, 733, 589, 453, 325, 253, 3, 26, 50, 74, 0, 0, 0, 5
        DC16 122, 98, 7, 73, 45, 15, 43, 19, 3, 45, 15, 1, 123, 99, 3, 74, 46
        DC16 2, 44, 20, 13, 46, 16, 17, 815, 647, 507, 367, 283, 3, 30, 54, 78
        DC16 0, 0, 0, 1, 135, 107, 10, 74, 46, 1, 50, 22, 2, 42, 14, 5, 136
        DC16 108, 1, 75, 47, 15, 51, 23, 17, 43, 15, 18, 901, 721, 563, 397
        DC16 313, 3, 30, 56, 82, 0, 0, 0, 5, 150, 120, 9, 69, 43, 17, 50, 22, 2
        DC16 42, 14, 1, 151, 121, 4, 70, 44, 1, 51, 23, 19, 43, 15, 19, 991
        DC16 795, 627, 445, 341, 3, 30, 58, 86, 0, 0, 0, 3, 141, 113, 3, 70, 44
        DC16 17, 47, 21, 9, 39, 13, 4, 142, 114, 11, 71, 45, 4, 48, 22, 16, 40
        DC16 14, 20, 1085, 861, 669, 485, 385, 3, 34, 62, 90, 0, 0, 0, 3, 135
        DC16 107, 3, 67, 41, 15, 54, 24, 15, 43, 15, 5, 136, 108, 13, 68, 42, 5
        DC16 55, 25, 10, 44, 16, 21, 1156, 932, 714, 512, 406, 4, 28, 50, 72
        DC16 94, 0, 0, 4, 144, 116, 17, 68, 42, 17, 50, 22, 19, 46, 16, 4, 145
        DC16 117, 0, 0, 0, 6, 51, 23, 6, 47, 17, 22, 1258, 1006, 782, 568, 442
        DC16 4, 26, 50, 74, 98, 0, 0, 2, 139, 111, 17, 74, 46, 7, 54, 24, 34
        DC16 37, 13, 7, 140, 112, 0, 0, 0, 16, 55, 25, 0, 0, 0, 23, 1364, 1094
        DC16 860, 614, 464, 4, 30, 54, 78, 102, 0, 0, 4, 151, 121, 4, 75, 47
        DC16 11, 54, 24, 16, 45, 15, 5, 152, 122, 14, 76, 48, 14, 55, 25, 14
        DC16 46, 16, 24, 1474, 1174, 914, 664, 514, 4, 28, 54, 80, 106, 0, 0, 6
        DC16 147, 117, 6, 73, 45, 11, 54, 24, 30, 46, 16, 4, 148, 118, 14, 74
        DC16 46, 16, 55, 25, 2, 47, 17, 25, 1588, 1276, 1000, 718, 538, 4, 32
        DC16 58, 84, 110, 0, 0, 8, 132, 106, 8, 75, 47, 7, 54, 24, 22, 45, 15
        DC16 4, 133, 107, 13, 76, 48, 22, 55, 25, 13, 46, 16, 26, 1706, 1370
        DC16 1062, 754, 596, 4, 30, 58, 86, 114, 0, 0, 10, 142, 114, 19, 74, 46
        DC16 28, 50, 22, 33, 46, 16, 2, 143, 115, 4, 75, 47, 6, 51, 23, 4, 47
        DC16 17, 27, 1828, 1468, 1128, 808, 628, 4, 34, 62, 90, 118, 0, 0, 8
        DC16 152, 122, 22, 73, 45, 8, 53, 23, 12, 45, 15, 4, 153, 123, 3, 74
        DC16 46, 26, 54, 24, 28, 46, 16, 28, 1921, 1531, 1193, 871, 661, 5, 26
        DC16 50, 74, 98, 122, 0, 3, 147, 117, 3, 73, 45, 4, 54, 24, 11, 45, 15
        DC16 10, 148, 118, 23, 74, 46, 31, 55, 25, 31, 46, 16, 29, 2051, 1631
        DC16 1267, 911, 701, 5, 30, 54, 78, 102, 126, 0, 7, 146, 116, 21, 73
        DC16 45, 1, 53, 23, 19, 45, 15, 7, 147, 117, 7, 74, 46, 37, 54, 24, 26
        DC16 46, 16, 30, 2185, 1735, 1373, 985, 745, 5, 26, 52, 78, 104, 130, 0
        DC16 5, 145, 115, 19, 75, 47, 15, 54, 24, 23, 45, 15, 10, 146, 116, 10
        DC16 76, 48, 25, 55, 25, 25, 46, 16, 31, 2323, 1843, 1455, 1033, 793, 5
        DC16 30, 56, 82, 108, 134, 0, 13, 145, 115, 2, 74, 46, 42, 54, 24, 23
        DC16 45, 15, 3, 146, 116, 29, 75, 47, 1, 55, 25, 28, 46, 16, 32, 2465
        DC16 1955, 1541, 1115, 845, 5, 34, 60, 86, 112, 138, 0, 17, 145, 115
        DC16 10, 74, 46, 10, 54, 24, 19, 45, 15, 0, 0, 0, 23, 75, 47, 35, 55
        DC16 25, 35, 46, 16, 33, 2611, 2071, 1631, 1171, 901, 5, 30, 58, 86
        DC16 114, 142, 0, 17, 145, 115, 14, 74, 46, 29, 54, 24, 11, 45, 15, 1
        DC16 146, 116, 21, 75, 47, 19, 55, 25, 46, 46, 16, 34, 2761, 2191, 1725
        DC16 1231, 961, 5, 34, 62, 90, 118, 146, 0, 13, 145, 115, 14, 74, 46
        DC16 44, 54, 24, 59, 46, 16, 6, 146, 116, 23, 75, 47, 7, 55, 25, 1, 47
        DC16 17, 35, 2876, 2306, 1812, 1286, 986, 6, 30, 54, 78, 102, 126, 150
        DC16 12, 151, 121, 12, 75, 47, 39, 54, 24, 22, 45, 15, 7, 152, 122, 26
        DC16 76, 48, 14, 55, 25, 41, 46, 16, 36, 3034, 2434, 1914, 1354, 1054
        DC16 6, 24, 50, 76, 102, 128, 154, 6, 151, 121, 6, 75, 47, 46, 54, 24
        DC16 2, 45, 15, 14, 152, 122, 34, 76, 48, 10, 55, 25, 64, 46, 16, 37
        DC16 3196, 2566, 1992, 1426, 1096, 6, 28, 54, 80, 106, 132, 158, 17
        DC16 152, 122, 29, 74, 46, 49, 54, 24, 24, 45, 15, 4, 153, 123, 14, 75
        DC16 47, 10, 55, 25, 46, 46, 16, 38, 3362, 2702, 2102, 1502, 1142, 6
        DC16 32, 58, 84, 110, 136, 162, 4, 152, 122, 13, 74, 46, 48, 54, 24, 42
        DC16 45, 15, 18, 153, 123, 32, 75, 47, 14, 55, 25, 32, 46, 16, 39, 3532
        DC16 2812, 2216, 1582, 1222, 6, 26, 54, 82, 110, 138, 166, 20, 147, 117
        DC16 40, 75, 47, 43, 54, 24, 10, 45, 15, 4, 148, 118, 7, 76, 48, 22, 55
        DC16 25, 67, 46, 16, 40, 3706, 2956, 2334, 1666, 1276, 6, 30, 58, 86
        DC16 114, 142, 170, 19, 148, 118, 18, 75, 47, 34, 54, 24, 20, 45, 15, 6
        DC16 149, 119, 31, 76, 48, 34, 55, 25, 61, 46, 16
        DC8 0, 0

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 
//  2 205 bytes in section .bss
//    316 bytes in section .data
//  1 232 bytes in section .rodata
// 10 468 bytes in section .text
// 
// 10 468 bytes of CODE  memory
//  1 232 bytes of CONST memory
//  2 521 bytes of DATA  memory
//
//Errors: none
//Warnings: none
