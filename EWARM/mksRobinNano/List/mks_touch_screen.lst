###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        14/Feb/2020  17:05:43
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c
#    Command line =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        -lA
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\
#        --no_unroll --no_inline --no_tbaa --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/CMSIS/Include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/variant\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Drivers/libstmf4/include\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/Multi_language\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM/../User/ui/QRENCODE\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\GUI\
#        -I
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\..\Middlewares\Third_Party\Marlin\
#        -Om --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/List\mks_touch_screen.lst
#    Object file  =  
#        E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\EWARM\mksRobinNano/Obj\mks_touch_screen.o
#
###############################################################################

E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c
      1          /******************** (C) COPYRIGHT 2009 www.armjishu.com ************************
      2          * File Name          : ARMJISHU_TouchScreen_ADS7843.c
      3          * Author             : www.armjishu.com Team
      4          * Version            : V3.0.1
      5          * Date               : 03/20/2010
      6          * Description        : 
      7                                  ADS7843_CS   is PB1
      8                                  ADS7843_INT  is PC1
      9          *******************************************************************************/
     10          #include "mks_touch_screen.h"
     11          //#include "stm32f10x.h"
     12          #include "stm32f1xx.h" //skyblue 2006-12-13
     13          #include <stdio.h>
     14          //#include "stm32f10x_exti.h"   //skyblue 2006-12-13
     15          #include "stm32f1xx_it.h"
     16          #include "ili9320.h"
     17          //#include "stm32f10x_tim.h"    //skyblue 2006-12-13
     18          #include "tim.h"
     19          #include "stm32f10x_spi.h"

  #define IS_SPI_DIRECTION_MODE(MODE) (((MODE) == SPI_Direction_2Lines_FullDuplex) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",132  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DIRECTION_MODE" (declared
          at line 466 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_MODE(MODE) (((MODE) == SPI_Mode_Master) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",146  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_MODE" (declared at line
          459 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_DATASIZE(DATASIZE) (((DATASIZE) == SPI_DataSize_16b) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",158  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_DATASIZE" (declared at
          line 488 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPOL(CPOL) (((CPOL) == SPI_CPOL_Low) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",170  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPOL" (declared at line
          496 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CPHA(CPHA) (((CPHA) == SPI_CPHA_1Edge) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",182  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CPHA" (declared at line
          504 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_NSS(NSS) (((NSS) == SPI_NSS_Soft) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",194  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_NSS" (declared at line
          512 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_BAUDRATE_PRESCALER(PRESCALER) (((PRESCALER) == SPI_BaudRatePrescaler_2) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",212  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_BAUDRATE_PRESCALER"
          (declared at line 521 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_FIRST_BIT(BIT) (((BIT) == SPI_FirstBit_MSB) || \
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",230  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_FIRST_BIT" (declared at
          line 535 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_CRCERR                 ((uint16_t)0x0010)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",408  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_CRCERR" (declared at
          line 308 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define SPI_FLAG_MODF                   ((uint16_t)0x0020)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",409  Warning[Pe047]: 
          incompatible redefinition of macro "SPI_FLAG_MODF" (declared at line
          309 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")

  #define IS_SPI_CRC_POLYNOMIAL(POLYNOMIAL) ((POLYNOMIAL) >= 0x1)
          ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\STM32F10x_StdPeriph_Driver\inc\stm32f10x_spi.h",425  Warning[Pe047]: 
          incompatible redefinition of macro "IS_SPI_CRC_POLYNOMIAL" (declared
          at line 558 of
          "E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4
          _source\Drivers\STM32F1xx_HAL_Driver\Inc\stm32f1xx_hal_spi.h")
     20          #include "spi_flash.h"

  #else defined(MKS_ROBIN_NANO)
        ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Drivers\BSP\Components\w25qxx\spi_flash.h",40  Warning[Pe014]: 
          extra text after expected end of preprocessing directive
     21          //#include "Marlin.h"
     22          #include "mks_fastio.h"
     23          
     24          extern u16 DeviceCode;
     25          
     26          /*#define  EVENT_FIFO_DEPTH	20
     27          typedef struct
     28          {	
     29          	TOUCH_EVENT event[EVENT_FIFO_DEPTH];
     30          	int8_t  r_idx;
     31          	int8_t  w_idx;
     32          	
     33          } EVENT_FIFO;
     34          
     35          static EVENT_FIFO  touch_event_fifo;*/
     36          

   \                                 In section .bss, align 4
     37          static int16_t x_touch,  y_touch;
   \                     x_touch:
   \   00000000                      DS8 2
   \   00000002                      DS8 2
   \   00000004                      DS8 4
     38          
     39          static int32_t touch_time = 0;
     40          
     41          static uint8_t lastTouchState = PEN_UP;
     42          
     43          //static TOUCH_EVENT  TouchEvent;
     44          
     45          #define  times  4
     46          
     47          extern u16 DeviceCode;
     48          extern uint8_t display_hold;
     49          extern uint32_t display_hold_cnt;
     50          extern uint8_t display_hold_release;
     51          
     52          
     53          // A/D 通道选择命令字和工作寄存器
     54          #define	CHX 	0x90//0x90 	//通道Y+的选择控制字	//0x94
     55          #define	CHY 	0xD0//0xd0	//通道X+的选择控制字	//0xD4
     56          
     57          //#define ADS7843_WrCmd  SPI1_SendByte
     58          //#define ADS7843_Read   SPI1_RecvByte
     59          

   \                                 In section .text, align 2, keep-with-next
     60          void ADS7843_CS_config(void)
     61          {
     62          #if 0   //skyblue 2016-12-13  
     63            GPIO_InitTypeDef GPIO_InitStructure;
     64            /* Enable GPIOB, GPIOC and AFIO clock */
     65            RCC_APB2PeriphClockCmd(RCC_ADS7843_CS , ENABLE);  //RCC_APB2Periph_AFIO
     66            
     67            /* LEDs pins configuration */
     68            GPIO_InitStructure.GPIO_Pin = GPIO_ADS7843_CS;
     69            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     70            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
     71            GPIO_Init(GPIO_ADS7843_CS_PORT, &GPIO_InitStructure);
     72          #endif    //skyblue 2016-12-13  
     73          }
   \                     ADS7843_CS_config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
     74          
     75          static void ADS7843_INT_config(void)
     76          {
     77            #if 0   //skyblue 2016-12-13  
     78            GPIO_InitTypeDef GPIO_InitStructure;
     79            /* Enable GPIOB, GPIOC and AFIO clock */
     80            RCC_APB2PeriphClockCmd(RCC_ADS7843_INT , ENABLE);  //RCC_APB2Periph_AFIO
     81            
     82            /* LEDs pins configuration */
     83            GPIO_InitStructure.GPIO_Pin = GPIO_ADS7843_INT;
     84            //GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
     85            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
     86            GPIO_Init(GPIO_ADS7843_INT_PORT, &GPIO_InitStructure);
     87            #endif    //skyblue 2016-12-13  
     88          }
     89          
     90          static void ADS7843_INT_EXIT_Init(void)
     91          {
     92           #if 0   //skyblue 2016-12-13  
     93              EXTI_InitTypeDef EXTI_InitStructure;
     94          
     95              /* Connect Button EXTI Line to Button GPIO Pin */
     96              GPIO_EXTILineConfig(GPIO_ADS7843_EXTI_PORT_SOURCE, GPIO_ADS7843_EXTI_PIN_SOURCE);  
     97          
     98              /* Configure Button EXTI line */
     99              EXTI_InitStructure.EXTI_Line = GPIO_ADS7843_EXTI_LINE;
    100              EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    101              EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Falling;  
    102              EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    103              EXTI_Init(&EXTI_InitStructure);
    104          #endif    //skyblue 2016-12-13  
    105          }
    106          
    107          
    108          /*******************************************************************************
    109          * Function Name  : InterruptConfig
    110          * Description    : Configures the used IRQ Channels and sets their priority.NVIC_Configuration
    111          * Input          : None
    112          * Output         : None
    113          * Return         : None
    114          *******************************************************************************/
    115          static void ADS7843_InterruptConfig(void)
    116          { 
    117           #if 0   //skyblue 2016-12-13   
    118            NVIC_InitTypeDef NVIC_InitStructure;
    119            
    120            /* Set the Vector Table base address at 0x08000000 */
    121            NVIC_SetVectorTable(NVIC_VectTab_FLASH, 0x0000);
    122            
    123            /* Configure the Priority Group to 2 bits */
    124            NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);
    125          
    126            /* Enable the EXTI5 Interrupt */
    127            NVIC_InitStructure.NVIC_IRQChannel = GPIO_ADS7843_EXTI_IRQn;
    128            NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    129            NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    130            NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    131            NVIC_Init(&NVIC_InitStructure);
    132          #endif    //skyblue 2016-12-13    
    133          }
    134          
    135          
    136          static void LCD_BIG_POINT(u16 xScreen, u16 yScreen)
    137           {
    138             ili9320_SetPoint(xScreen, yScreen, Magenta);
    139             ili9320_SetPoint(xScreen-1, yScreen, Magenta);
    140             ili9320_SetPoint(xScreen+1, yScreen, Magenta);
    141             ili9320_SetPoint(xScreen, yScreen-1, Magenta);
    142             ili9320_SetPoint(xScreen, yScreen+1, Magenta);
    143             ili9320_SetPoint(xScreen-1, yScreen-1, Magenta);
    144             ili9320_SetPoint(xScreen-1, yScreen+1, Magenta);
    145             ili9320_SetPoint(xScreen+1, yScreen-1, Magenta);
    146             ili9320_SetPoint(xScreen+1, yScreen+1, Magenta);
    147          
    148            }
    149          
    150          /*=====================================================================*/

   \                                 In section .text, align 2, keep-with-next
    151          u16 _AD2Y(u16 adx) //240
    152          {
    153            u16 sx=0;
    154            int r = adx - 200;
    155            r *= 240;
    156            sx=r / (4000 - 280);
   \                     _AD2Y: (+1)
   \   00000000   0x38C8             SUBS     R0,R0,#+200
   \   00000002   0xEBC0 0x1100      RSB      R1,R0,R0, LSL #+4
   \   00000006   0x0108             LSLS     R0,R1,#+4
   \   00000008   0xF640 0x6188      MOVW     R1,#+3720
   \   0000000C   0xFB90 0xF0F1      SDIV     R0,R0,R1
    157            if (sx<=0 || sx>240)
   \   00000010   0xB280             UXTH     R0,R0
   \   00000012   0x2800             CMP      R0,#+0
   \   00000014   0xD001             BEQ.N    ??_AD2Y_0
   \   00000016   0x28F1             CMP      R0,#+241
   \   00000018   0xDB00             BLT.N    ??_AD2Y_1
    158              return 0;
   \                     ??_AD2Y_0: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
    159            return sx;
   \                     ??_AD2Y_1: (+1)
   \   0000001C   0x4770             BX       LR               ;; return
    160          }
    161          
    162          

   \                                 In section .text, align 2, keep-with-next
    163          u16 _AD2X(u16 ady) //320
    164          {
    165            u16 sy=0;
    166            int r = ady - 260;
    167            r *= 320;
    168            sy=r/(3960 - 360);
   \                     _AD2X: (+1)
   \   00000000   0xF5A0 0x7082      SUB      R0,R0,#+260
   \   00000004   0xEB00 0x0180      ADD      R1,R0,R0, LSL #+2
   \   00000008   0x0188             LSLS     R0,R1,#+6
   \   0000000A   0xF44F 0x6161      MOV      R1,#+3600
   \   0000000E   0xFB90 0xF0F1      SDIV     R0,R0,R1
    169            if (sy<=0 || sy>320)
   \   00000012   0xB280             UXTH     R0,R0
   \   00000014   0x2800             CMP      R0,#+0
   \   00000016   0xD002             BEQ.N    ??_AD2X_0
   \   00000018   0xF5B0 0x7FA0      CMP      R0,#+320
   \   0000001C   0xDD00             BLE.N    ??_AD2X_1
    170              return 0;
   \                     ??_AD2X_0: (+1)
   \   0000001E   0x2000             MOVS     R0,#+0
    171            return sy;
   \                     ??_AD2X_1: (+1)
   \   00000020   0x4770             BX       LR               ;; return
    172          }
    173          
    174          
    175          
    176          
    177          
    178          
    179          /*=====================================================================*/
    180          /*=====================================================================*/
    181          /*=====================================================================*/
    182          /*=====================================================================*/
    183          // A/D 通道选择命令字和工作寄存器
    184          //#define	CHX 	0x90 	//通道Y+的选择控制字	//0x94
    185          //#define	CHY 	0xd0	//通道X+的选择控制字	//0xD4
    186          
    187          
    188          
    189          //读ADS7843的IO控制口
    190          	
    191          /*=====================================================================*/
    192          

   \                                 In section .text, align 2, keep-with-next
    193          void ADS7843_Init(void)
    194          {
    195           #if 0   //skyblue 2016-12-13    
    196              ADS7843_CS_config();     // 使能LCD
    197              ADS7843_CS_HIGH() ;     // 关闭LCD
    198              SPI1_Config();
    199              SPI1_Init_For_Byte();
    200              SPI1_MOSI_HIGH();
    201              SPI1_SCK_LOW();
    202             // ADS7843_INT_config();
    203             // ADS7843_INT_EXIT_Init();
    204             // ADS7843_InterruptConfig();
    205          
    206          	// touch_event_fifo.r_idx = 0;
    207            //  touch_event_fifo.w_idx = 0;
    208            //  memset(touch_event_fifo.event, 0, sizeof(touch_event_fifo.event));
    209          
    210             lastTouchState = PEN_UP;
    211          #endif    //skyblue 2016-12-13      
    212          }
   \                     ADS7843_Init: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    213          /*=====================================================================*/
    214          /*=====================================================================*/
    215          
    216          

   \                                 In section .text, align 2, keep-with-next
    217          void SPI1_Config(void)
    218          {
    219           #if 0   //skyblue 2016-12-13  
    220            GPIO_InitTypeDef GPIO_InitStructure;
    221              
    222            // Set as Output push-pull - SCK and MOSI
    223            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);
    224            
    225            GPIO_InitStructure.GPIO_Pin = SPI1_SCK | SPI1_MOSI;
    226            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    227            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    228            GPIO_Init(SPI1_PORT, &GPIO_InitStructure);
    229            
    230            //SPI_MISO
    231            GPIO_InitStructure.GPIO_Pin = SPI1_MISO;
    232            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    233            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
    234            GPIO_Init(SPI1_PORT, &GPIO_InitStructure);
    235          #endif    //skyblue 2016-12-13    
    236          
    237          }
   \                     SPI1_Config: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    238          
    239          /*=====================================================================*/

   \                                 In section .text, align 2, keep-with-next
    240          void SPI1_Init_For_Byte(void)
    241          {
    242          
    243          }
   \                     SPI1_Init_For_Byte: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    244          
    245          /*=====================================================================*/
    246          static void ADS7843_SPI_Start( void )
    247          {
    248           #if 0   //skyblue 2016-12-13   
    249              ADS7843_CS_HIGH();
    250              SPI1_MOSI_HIGH();
    251              SPI1_SCK_LOW();
    252              ADS7843_CS_LOW();	      		//芯片允许
    253          #endif    //skyblue 2016-12-13     
    254          }
    255          
    256          /*=====================================================================*/
    257          static void SPI_MOSI(u8 data)
    258          {
    259           #if 0   //skyblue 2016-12-13    
    260              if(data)
    261                  SPI1_MOSI_HIGH();
    262              else
    263                  SPI1_MOSI_LOW();
    264          #endif    //skyblue 2016-12-13     
    265          }
    266          
    267          /*=====================================================================*/
    268          /*
    269          #define ShortDelayTime 1
    270          #define LongDelayTime (ShortDelayTime*2)
    271          SPI1_Delay_Short()
    272          {
    273              __IO uint32_t nCount;
    274              
    275              for( nCount= 0; nCount < ShortDelayTime; nCount++ );
    276          }
    277          */
    278          /*=====================================================================*/
    279          
    280          
    281          /*=====================================================================*/
    282          static void ADS7843_WrCmd(u8 cmd)
    283          {
    284          #if 0   //skyblue 2016-12-13    
    285              u8 buf, i;
    286          
    287              for( i = 0; i < 8; i++ )
    288              {
    289                  buf = (cmd >> (7-i)) & 0x1 ;	//MSB在前,LSB在后
    290                  SPI_MOSI(buf);	 	//时钟上升沿锁存DIN
    291                  SPI1_SCK_HIGH();			//时钟脉冲，一共8个
    292                  SPI1_SCK_LOW();			//开始发送命令字
    293              }
    294          #endif    //skyblue 2016-12-13 	
    295          }
    296          
    297          /*=====================================================================*/
    298          static u16 ADS7843_Read(void)
    299          {
    300          #if 0   //skyblue 2016-12-13    
    301          	u16 buf = 0 ;
    302          	u8 i;
    303          
    304              SPI1_SCK_HIGH(); //wait busy
    305          	SPI1_SCK_LOW();	
    306          	for( i = 0; i < 12; i++ )
    307          	{
    308          		buf = buf << 1 ;
    309          		SPI1_SCK_HIGH();
    310          		if ( SPI1_MISO_READ() )	
    311          		{
    312          			buf = buf + 1 ;
    313          		}
    314          		SPI1_SCK_LOW();			
    315          	}
    316          
    317          	for( i = 0; i < 3; i++ )
    318          	{
    319          		SPI1_SCK_HIGH();
    320          		SPI1_SCK_LOW();			
    321          	}
    322              
    323          	return( buf ) ;
    324          #endif    //skyblue 2016-12-13 	        
    325          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "ADS7843_Read"
    326          
    327          /*=====================================================================*/
    328          

   \                                 In section .text, align 2, keep-with-next
    329          static void ADS7843_Rd_Addata(u16 *X_Addata,u16 *Y_Addata)
    330          {
   \                     ADS7843_Rd_Addata: (+1)
   \   00000000   0xB5F0             PUSH     {R4-R7,LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
   \   00000004   0x4604             MOV      R4,R0
   \   00000006   0x460D             MOV      R5,R1
    331          
    332          	u16		i,j,k,x_addata[times],y_addata[times];
    333              int result;
                         ^
Warning[Pe550]: variable "result" was set but never used
    334          
    335                  
    336          	for(i=0;i<times;i++)					//采样4次.
   \   00000008   0x2600             MOVS     R6,#+0
   \   0000000A   0x....             LDR.N    R7,??DataTable1  ;; 0x4221019c
   \   0000000C   0xE01A             B.N      ??ADS7843_Rd_Addata_0
    337          	{
    338          	#if 0
    339          	    ADS7843_SPI_Start();
    340          		ADS7843_WrCmd( CHX ) ;
    341          		y_addata[i] = ADS7843_Read() ;
    342                  ADS7843_CS_HIGH(); 
    343          
    344          	    ADS7843_SPI_Start();
    345          		ADS7843_WrCmd( CHY ) ;
    346          		x_addata[i] = ADS7843_Read() ;
    347                  ADS7843_CS_HIGH(); 
    348          	#else
    349                      SPI2_SetSpeed(SPI_BaudRatePrescaler_64);
   \                     ??ADS7843_Rd_Addata_1: (+1)
   \   0000000E   0x2028             MOVS     R0,#+40
   \   00000010   0x.... 0x....      BL       SPI2_SetSpeed
    350                      ADS7843_CS = 0;
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x6038             STR      R0,[R7, #+0]
    351                      SPI2_ReadWriteByte(CHX);
   \   00000018   0x2090             MOVS     R0,#+144
   \   0000001A   0x.... 0x....      BL       SPI2_ReadWriteByte
    352                      y_addata[i] = SPI2_ReadWrite2Bytes();
   \   0000001E   0x.... 0x....      BL       SPI2_ReadWrite2Bytes
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
    353                      SPI2_ReadWriteByte(CHY);
   \   00000028   0x20D0             MOVS     R0,#+208
   \   0000002A   0x.... 0x....      BL       SPI2_ReadWriteByte
    354                      x_addata[i] = SPI2_ReadWrite2Bytes(); 
   \   0000002E   0x.... 0x....      BL       SPI2_ReadWrite2Bytes
   \   00000032   0xA902             ADD      R1,SP,#+8
   \   00000034   0xF821 0x0016      STRH     R0,[R1, R6, LSL #+1]
    355                      ADS7843_CS = 1;
   \   00000038   0x2001             MOVS     R0,#+1
   \   0000003A   0x6038             STR      R0,[R7, #+0]
    356                      SPI2_SetSpeed(SPI_BaudRatePrescaler_4);
   \   0000003C   0x2008             MOVS     R0,#+8
   \   0000003E   0x.... 0x....      BL       SPI2_SetSpeed
    357                  
    358          /*        
    359          	SPI2_SetSpeed(SPI_BaudRatePrescaler_64);
    360          				ADS7843_CS_LOW();
    361          	
    362          				SPI2_ReadWriteByte(CHX);
    363          				y_addata[i] = SPI2_ReadWrite2Bytes();
    364                  ADS7843_CS_HIGH(); 
    365          
    366          	    	ADS7843_CS_LOW();
    367          				SPI2_ReadWriteByte(CHY);
    368          				x_addata[i] = SPI2_ReadWrite2Bytes(); 
    369                  ADS7843_CS_HIGH(); 
    370          	SPI2_SetSpeed(SPI_BaudRatePrescaler_2);
    371          */        
    372          	#endif
    373          	}
   \   00000042   0x1C76             ADDS     R6,R6,#+1
   \                     ??ADS7843_Rd_Addata_0: (+1)
   \   00000044   0x2E04             CMP      R6,#+4
   \   00000046   0xDBE2             BLT.N    ??ADS7843_Rd_Addata_1
    374          
    375          	result = x_addata[0];
    376          	for(i=0;i<times;i++)					
   \   00000048   0x2000             MOVS     R0,#+0
   \   0000004A   0xA902             ADD      R1,SP,#+8
   \   0000004C   0xE00E             B.N      ??ADS7843_Rd_Addata_2
    377          	{
    378          		for(j = i + 1; j < times; j++)
    379          		{
    380          			if(x_addata[j] > x_addata[i])
   \                     ??ADS7843_Rd_Addata_3: (+1)
   \   0000004E   0xF831 0x2013      LDRH     R2,[R1, R3, LSL #+1]
   \   00000052   0xF831 0x6010      LDRH     R6,[R1, R0, LSL #+1]
   \   00000056   0x4296             CMP      R6,R2
   \   00000058   0xD203             BCS.N    ??ADS7843_Rd_Addata_4
    381          			{
    382          				k = x_addata[j];
    383          				x_addata[j] = x_addata[i];
   \   0000005A   0xF821 0x6013      STRH     R6,[R1, R3, LSL #+1]
    384          				x_addata[i] = k;
   \   0000005E   0xF821 0x2010      STRH     R2,[R1, R0, LSL #+1]
    385          			}
    386          		}
   \                     ??ADS7843_Rd_Addata_4: (+1)
   \   00000062   0x1C5B             ADDS     R3,R3,#+1
   \   00000064   0xB29B             UXTH     R3,R3
   \                     ??ADS7843_Rd_Addata_5: (+1)
   \   00000066   0x2B04             CMP      R3,#+4
   \   00000068   0xDBF1             BLT.N    ??ADS7843_Rd_Addata_3
   \   0000006A   0x4638             MOV      R0,R7
   \                     ??ADS7843_Rd_Addata_2: (+1)
   \   0000006C   0x2804             CMP      R0,#+4
   \   0000006E   0xDA03             BGE.N    ??ADS7843_Rd_Addata_6
   \   00000070   0x1C47             ADDS     R7,R0,#+1
   \   00000072   0xB2BF             UXTH     R7,R7
   \   00000074   0x463B             MOV      R3,R7
   \   00000076   0xE7F6             B.N      ??ADS7843_Rd_Addata_5
    387          	}
    388          	if(x_addata[times / 2 -1] - x_addata[times / 2 ] > 50)
   \                     ??ADS7843_Rd_Addata_6: (+1)
   \   00000078   0x8888             LDRH     R0,[R1, #+4]
   \   0000007A   0x8849             LDRH     R1,[R1, #+2]
   \   0000007C   0x1A0A             SUBS     R2,R1,R0
   \   0000007E   0x2A33             CMP      R2,#+51
   \   00000080   0xDA21             BGE.N    ??ADS7843_Rd_Addata_7
    389          	{
    390                      *X_Addata = 0;
    391                      *Y_Addata = 0;
    392                      return ;
    393                  }
    394          
    395          	*X_Addata = (x_addata[times / 2 -1] + x_addata[times / 2 ]) /2;
   \   00000082   0x1840             ADDS     R0,R0,R1
   \   00000084   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   00000088   0x1040             ASRS     R0,R0,#+1
   \   0000008A   0x8020             STRH     R0,[R4, #+0]
    396          
    397          	
    398          	result = y_addata[0];
    399          	for(i=0;i<times;i++)					
   \   0000008C   0x2000             MOVS     R0,#+0
   \   0000008E   0xA900             ADD      R1,SP,#+0
   \   00000090   0xE00E             B.N      ??ADS7843_Rd_Addata_8
    400          	{
    401          		for(j = i + 1; j < times; j++)
    402          		{
    403          			if(y_addata[j] > y_addata[i])
   \                     ??ADS7843_Rd_Addata_9: (+1)
   \   00000092   0xF831 0x2013      LDRH     R2,[R1, R3, LSL #+1]
   \   00000096   0xF831 0x6010      LDRH     R6,[R1, R0, LSL #+1]
   \   0000009A   0x4296             CMP      R6,R2
   \   0000009C   0xD203             BCS.N    ??ADS7843_Rd_Addata_10
    404          			{
    405          				k = y_addata[j];
    406          				y_addata[j] = y_addata[i];
   \   0000009E   0xF821 0x6013      STRH     R6,[R1, R3, LSL #+1]
    407          				y_addata[i] = k;
   \   000000A2   0xF821 0x2010      STRH     R2,[R1, R0, LSL #+1]
    408          			}
    409          		}
   \                     ??ADS7843_Rd_Addata_10: (+1)
   \   000000A6   0x1C5B             ADDS     R3,R3,#+1
   \   000000A8   0xB29B             UXTH     R3,R3
   \                     ??ADS7843_Rd_Addata_11: (+1)
   \   000000AA   0x2B04             CMP      R3,#+4
   \   000000AC   0xDBF1             BLT.N    ??ADS7843_Rd_Addata_9
   \   000000AE   0x4638             MOV      R0,R7
   \                     ??ADS7843_Rd_Addata_8: (+1)
   \   000000B0   0x2804             CMP      R0,#+4
   \   000000B2   0xDA03             BGE.N    ??ADS7843_Rd_Addata_12
   \   000000B4   0x1C47             ADDS     R7,R0,#+1
   \   000000B6   0xB2BF             UXTH     R7,R7
   \   000000B8   0x463B             MOV      R3,R7
   \   000000BA   0xE7F6             B.N      ??ADS7843_Rd_Addata_11
    410          	}
    411          
    412          	
    413          	if(y_addata[times / 2 -1] - y_addata[times / 2 ] > 50)
   \                     ??ADS7843_Rd_Addata_12: (+1)
   \   000000BC   0x8888             LDRH     R0,[R1, #+4]
   \   000000BE   0x8849             LDRH     R1,[R1, #+2]
   \   000000C0   0x1A0A             SUBS     R2,R1,R0
   \   000000C2   0x2A33             CMP      R2,#+51
   \   000000C4   0xDB03             BLT.N    ??ADS7843_Rd_Addata_13
    414          	{
    415                      *X_Addata = 0;
   \                     ??ADS7843_Rd_Addata_7: (+1)
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x8020             STRH     R0,[R4, #+0]
    416                      *Y_Addata = 0;
   \   000000CA   0x8028             STRH     R0,[R5, #+0]
    417                      return ;
   \   000000CC   0xE004             B.N      ??ADS7843_Rd_Addata_14
    418                  }
    419          
    420          	*Y_Addata = (y_addata[times / 2 -1] + y_addata[times / 2 ]) /2;
   \                     ??ADS7843_Rd_Addata_13: (+1)
   \   000000CE   0x1840             ADDS     R0,R0,R1
   \   000000D0   0xEB00 0x70D0      ADD      R0,R0,R0, LSR #+31
   \   000000D4   0x1040             ASRS     R0,R0,#+1
   \   000000D6   0x8028             STRH     R0,[R5, #+0]
    421          	
    422          	
    423          }
   \                     ??ADS7843_Rd_Addata_14: (+1)
   \   000000D8   0xB005             ADD      SP,SP,#+20
   \   000000DA   0xBDF0             POP      {R4-R7,PC}       ;; return
    424          
    425          /*=====================================================================*/
    426          /*=====================================================================*/
    427          /*=====================================================================*/

   \                                 In section .text, align 2, keep-with-next
    428          u16 distence(u16 data1,u16 data2)
    429          {
    430              if((data1 > data2) && (data1 > data2 + 10))
   \                     distence: (+1)
   \   00000000   0x4281             CMP      R1,R0
   \   00000002   0xD204             BCS.N    ??distence_0
   \   00000004   0x310A             ADDS     R1,R1,#+10
   \   00000006   0x4281             CMP      R1,R0
   \   00000008   0xDA01             BGE.N    ??distence_0
    431              {
    432                  return 0;
    433              }
    434          
    435              if((data2 > data2) && (data2 > data2 + 10))
    436              {
    437                  return 0;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x4770             BX       LR
    438              }
    439          
    440              return 1;    
   \                     ??distence_0: (+1)
   \   0000000E   0x2001             MOVS     R0,#+1
   \   00000010   0x4770             BX       LR               ;; return
    441          }
    442          
    443          /*=====================================================================*/
    444          extern uint32_t TSC_Value_X;
    445          extern uint32_t TSC_Value_Y;

   \                                 In section .text, align 2, keep-with-next
    446          void ARMJISHU_TouchScreen_ADS7843(void)
    447          {
    448          #if 0   //skyblue 2016-12-13    
    449            u16 xdata, ydata;
    450            u32 xScreen, yScreen;
    451          
    452              static u16 sDataX,sDataY;
    453              
    454           // printf("\n\r ARMJISHU_TouchScreen_ADS7843 \n\r");
    455            ADS7843_Rd_Addata(&xdata, &ydata);
    456            xScreen = _AD2X(ydata);
    457            yScreen = _AD2Y(xdata);
    458          
    459             //xScreen = 320 - ((ydata*320)>>12);
    460             //yScreen = (xdata*240)>>12;
    461          
    462           
    463            //printf("\n\r (0x%x, 0x%x), (%d, %d)", xdata, ydata, xScreen, yScreen);
    464            if((xScreen>1)&&(yScreen>1)&&(xScreen<320-1)&&(yScreen<240-1))
    465            {
    466                 printf("\n\r%d,%d", xScreen, yScreen);
    467                if((GPIO_ADS7843_INT_VALID) && distence(sDataX,xScreen) && distence(sDataY,yScreen))
    468                  {
    469          //             LCD_BIG_POINT(xScreen, yScreen);
    470          //			 printf("\n\r%d,%d", xScreen, yScreen);
    471          		        TSC_Value_X = xScreen;
    472          				if(DeviceCode==0x9325)
    473          					TSC_Value_Y = 240-yScreen;
    474          				else
    475          					TSC_Value_Y = yScreen;
    476                  }
    477                sDataX = xScreen;
    478                sDataY = yScreen;
    479            }
    480          #endif    //skyblue 2016-12-13     
    481          }
   \                     ARMJISHU_TouchScreen_ADS7843: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    482          
    483          #define ADC_VALID_OFFSET	10
    484          

   \                                 In section .text, align 2, keep-with-next
    485          static uint8_t	TOUCH_PressValid(uint16_t _usX, uint16_t _usY)
    486          {
    487          	if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
    488          		|| (_usX >= 4095 - ADC_VALID_OFFSET)
    489          		|| (_usY >= 4095 - ADC_VALID_OFFSET))
   \                     TOUCH_PressValid: (+1)
   \   00000000   0x280B             CMP      R0,#+11
   \   00000002   0xDB07             BLT.N    ??TOUCH_PressValid_0
   \   00000004   0x290B             CMP      R1,#+11
   \   00000006   0xDB05             BLT.N    ??TOUCH_PressValid_0
   \   00000008   0xF640 0x72F5      MOVW     R2,#+4085
   \   0000000C   0x4290             CMP      R0,R2
   \   0000000E   0xDA01             BGE.N    ??TOUCH_PressValid_0
   \   00000010   0x4291             CMP      R1,R2
   \   00000012   0xDB01             BLT.N    ??TOUCH_PressValid_1
    490          	{
    491          		return 0;
   \                     ??TOUCH_PressValid_0: (+1)
   \   00000014   0x2000             MOVS     R0,#+0
   \   00000016   0x4770             BX       LR
    492          	}
    493          	else
    494          	{
    495          		return 1;
   \                     ??TOUCH_PressValid_1: (+1)
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4770             BX       LR               ;; return
    496          	}
    497          }
    498          
    499          #if 1
    500          

   \                                 In section .text, align 2, keep-with-next
    501          void getTouchEvent(TOUCH_EVENT *pTouchEvent)
    502          {
   \                     getTouchEvent: (+1)
   \   00000000   0xE92D 0x43F8      PUSH     {R3-R9,LR}
   \   00000004   0x4604             MOV      R4,R0
    503          	uint32_t tmpTime, diffTime = 0;
    504          	int16_t x, y;
    505          	
    506          	tmpTime = getTick();
   \   00000006   0x.... 0x....      BL       getTick
   \   0000000A   0x4605             MOV      R5,R0
    507          
    508          	diffTime = getTickDiff(tmpTime, touch_time);
    509          
    510          	if(diffTime > 20)
   \   0000000C   0x....             LDR.N    R6,??DataTable1_1
   \   0000000E   0x6871             LDR      R1,[R6, #+4]
   \   00000010   0x.... 0x....      BL       getTickDiff
   \   00000014   0x2815             CMP      R0,#+21
   \   00000016   0xD339             BCC.N    ??getTouchEvent_0
    511          	{
    512          		x = x_touch;
   \   00000018   0xF9B6 0x7000      LDRSH    R7,[R6, #+0]
    513          		y = y_touch;
   \   0000001C   0xF9B6 0x8002      LDRSH    R8,[R6, #+2]
    514          			
    515          		ADS7843_Rd_Addata(&x_touch, &y_touch);
                 		                  ^
Warning[Pe167]: argument of type "int16_t *" is incompatible with parameter of
          type "u16 *"

  		ADS7843_Rd_Addata(&x_touch, &y_touch);
  		                            ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",515  Warning[Pe167]: 
          argument of type "int16_t *" is incompatible with parameter of type
          "u16 *"
   \   00000020   0x1CB1             ADDS     R1,R6,#+2
   \   00000022   0x4630             MOV      R0,R6
   \   00000024   0x.... 0x....      BL       ADS7843_Rd_Addata
    516          		if(TOUCH_PressValid(x_touch, y_touch))
   \   00000028   0xF9B6 0x9000      LDRSH    R9,[R6, #+0]
   \   0000002C   0x8871             LDRH     R1,[R6, #+2]
   \   0000002E   0x4648             MOV      R0,R9
   \   00000030   0xB280             UXTH     R0,R0
   \   00000032   0x.... 0x....      BL       TOUCH_PressValid
   \   00000036   0x2800             CMP      R0,#+0
   \   00000038   0xD026             BEQ.N    ??getTouchEvent_1
    517          		{	
    518          			display_hold_cnt=0;
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x....             LDR.N    R1,??DataTable1_2
   \   0000003E   0x6008             STR      R0,[R1, #+0]
    519          			if(display_hold==1)
   \   00000040   0x....             LDR.N    R0,??DataTable1_3
   \   00000042   0x7800             LDRB     R0,[R0, #+0]
   \   00000044   0x2801             CMP      R0,#+1
   \   00000046   0xD103             BNE.N    ??getTouchEvent_2
    520          			{
    521          				display_hold_release=1;
   \   00000048   0x2001             MOVS     R0,#+1
   \   0000004A   0x....             LDR.N    R1,??DataTable1_4
   \   0000004C   0x7008             STRB     R0,[R1, #+0]
    522          				return;
   \   0000004E   0xE01D             B.N      ??getTouchEvent_0
    523          			}
    524          			
    525          			if(abs(x - x_touch) > 50 || abs(y-y_touch) > 50)
                 			   ^
Warning[Pe223]: function "abs" declared implicitly

  static void ADS7843_INT_EXIT_Init(void)
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",90  Warning[Pe177]: 
          function "ADS7843_INT_EXIT_Init" was declared but never referenced

  static void ADS7843_INT_config(void)
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",75  Warning[Pe177]: 
          function "ADS7843_INT_config" was declared but never referenced

  static void ADS7843_InterruptConfig(void)
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",115  Warning[Pe177]: 
          function "ADS7843_InterruptConfig" was declared but never referenced

  static uint8_t lastTouchState = PEN_UP;
                 ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",41  Warning[Pe177]: 
          variable "lastTouchState" was declared but never referenced

  static void LCD_BIG_POINT(u16 xScreen, u16 yScreen)
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",136  Warning[Pe177]: 
          function "LCD_BIG_POINT" was declared but never referenced

  static void ADS7843_SPI_Start( void )
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",246  Warning[Pe177]: 
          function "ADS7843_SPI_Start" was declared but never referenced

  static void SPI_MOSI(u8 data)
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",257  Warning[Pe177]: 
          function "SPI_MOSI" was declared but never referenced

  static void ADS7843_WrCmd(u8 cmd)
              ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",282  Warning[Pe177]: 
          function "ADS7843_WrCmd" was declared but never referenced

  static u16 ADS7843_Read(void)
             ^
"E:\code\Robin_Nano_SVN\branches\robin_nano35源码\robin_nano35_v1.0.4_source\Src\mks_touch_screen.c",298  Warning[Pe177]: 
          function "ADS7843_Read" was declared but never referenced
   \                     ??getTouchEvent_2: (+1)
   \   00000050   0xEBA7 0x0009      SUB      R0,R7,R9
   \   00000054   0x.... 0x....      BL       abs
   \   00000058   0x2833             CMP      R0,#+51
   \   0000005A   0xDA17             BGE.N    ??getTouchEvent_0
   \   0000005C   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   00000060   0xEBA8 0x0000      SUB      R0,R8,R0
   \   00000064   0x.... 0x....      BL       abs
   \   00000068   0x2833             CMP      R0,#+51
   \   0000006A   0xDA0F             BGE.N    ??getTouchEvent_0
    526          			{
    527          				//pTouchEvent->state = PEN_NONE;
    528          				return;
    529          			}
    530          		
    531          			pTouchEvent->x  = (x + x_touch) >> 1;
   \   0000006C   0xF9B6 0x0000      LDRSH    R0,[R6, #+0]
   \   00000070   0x19C0             ADDS     R0,R0,R7
   \   00000072   0x1040             ASRS     R0,R0,#+1
   \   00000074   0x8020             STRH     R0,[R4, #+0]
    532          			pTouchEvent->y = (y + y_touch) >> 1;
   \   00000076   0xF9B6 0x0002      LDRSH    R0,[R6, #+2]
   \   0000007A   0x4440             ADD      R0,R0,R8
   \   0000007C   0x1040             ASRS     R0,R0,#+1
   \   0000007E   0x8060             STRH     R0,[R4, #+2]
    533          			pTouchEvent->state = PEN_DOWN;
   \   00000080   0x2001             MOVS     R0,#+1
   \   00000082   0x7120             STRB     R0,[R4, #+4]
    534          			
    535          			touch_time = tmpTime;
   \   00000084   0x6075             STR      R5,[R6, #+4]
   \   00000086   0xE001             B.N      ??getTouchEvent_0
    536          
    537          
    538          		}
    539          		else
    540          		{
    541          			pTouchEvent->state = PEN_UP;
   \                     ??getTouchEvent_1: (+1)
   \   00000088   0x2002             MOVS     R0,#+2
   \   0000008A   0x7120             STRB     R0,[R4, #+4]
    542          		}
    543          	}
    544          	else
    545          	{
    546          		//pTouchEvent->state = PEN_NONE;
    547          	}
    548          	
    549          
    550          	#if 0
    551          			
    552          	tmpTime = getTick();
    553          
    554          	diffTime = getTickDiff(tmpTime, touch_time);
    555          		
    556          	//if(diffTime > 10 && diffTime < 2000)	//按下时间限制在10ms到2s
    557          	if(diffTime > 20)
    558          	{
    559          		x = x_touch;
    560          		y = y_touch;
    561          
    562          		ADS7843_Rd_Addata(&x_touch, &y_touch);
    563          	//	x_touch = ADS_Read_X();
    564          	//	y_touch = ADS_Read_Y();
    565          
    566          		
    567          		if(TOUCH_PressValid(x_touch, y_touch))
    568          		{
    569          			//if(x - x_touch >50 || x_touch - x >50 || y - y_touch >50 || y_touch - y >50)
    570          			if(abs(x - x_touch) > 50 || abs(y-y_touch) > 50)
    571          			{
    572          				return 0;
    573          			}
    574          		
    575          			TouchEvent.x  = (x + x_touch) >> 1;
    576          			TouchEvent.y = (y + y_touch) >> 1;
    577          			
    578          			touch_time = tmpTime;
    579          		}
    580          		else
    581          			return 0;
    582          
    583          	}
    584          	else
    585          	{
    586          		return 0;
    587          	}
    588          	
    589          	return &TouchEvent;
    590          #endif
    591          }
   \                     ??getTouchEvent_0: (+1)
   \   0000008C   0xE8BD 0x83F1      POP      {R0,R4-R9,PC}    ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1:
   \   00000000   0x4221019C         DC32     0x4221019c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_1:
   \   00000000   0x........         DC32     x_touch

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_2:
   \   00000000   0x........         DC32     display_hold_cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_3:
   \   00000000   0x........         DC32     display_hold

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable1_4:
   \   00000000   0x........         DC32     display_hold_release
    592          #else
    593          TOUCH_EVENT *getTouchEvent()
    594          {
    595          	uint32_t tmpTime, diffTime = 0;
    596          	int16_t x, y;
    597          
    598          	
    599          	//tan 20160830
    600          	ADS7843_Init();
    601          
    602          	tmpTime = getTick();
    603          
    604          	diffTime = getTickDiff(tmpTime, touch_time);
    605          		
    606          	//if(diffTime > 10 && diffTime < 2000)	//涓堕撮跺10ms2s
    607          	if(diffTime > 20)
    608          	{
    609          		x = x_touch;
    610          		y = y_touch;
    611          
    612          		ADS7843_Rd_Addata(&x_touch, &y_touch);
    613          	//	x_touch = ADS_Read_X();
    614          	//	y_touch = ADS_Read_Y();
    615          
    616          		touch_time = tmpTime;
    617          		
    618          		//if(x - x_touch >50 || x_touch - x >50 || y - y_touch >50 || y_touch - y >50)
    619          		if(abs(x - x_touch) > 50 || abs(y-y_touch) > 50)
    620          		{
    621          			return 0;
    622          		}
    623          
    624          		TouchEvent.x  = (x + x_touch) >> 1;
    625          		TouchEvent.y = (y + y_touch) >> 1;
    626          
    627          	}
    628          	else
    629          	{
    630          		return 0;
    631          	}
    632          	
    633          	return &TouchEvent;
    634          
    635          }
    636          #endif
    637          /*=====================================================================*/
    638          /*=====================================================================*/
    639          /*=====================================================================*/
    640          /*=====================================================================*/
    641          /*=====================================================================*/
    642          /*=====================================================================*/
    643          /*=====================================================================*/
    644          /*=====================================================================*/
    645          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   ADS7843_CS_config
       0   ADS7843_Init
      40   ADS7843_Rd_Addata
        40   -> SPI2_ReadWrite2Bytes
        40   -> SPI2_ReadWriteByte
        40   -> SPI2_SetSpeed
       0   ARMJISHU_TouchScreen_ADS7843
       0   SPI1_Config
       0   SPI1_Init_For_Byte
       0   TOUCH_PressValid
       0   _AD2X
       0   _AD2Y
       0   distence
      32   getTouchEvent
        32   -> ADS7843_Rd_Addata
        32   -> TOUCH_PressValid
        32   -> abs
        32   -> getTick
        32   -> getTickDiff


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       2  ADS7843_CS_config
       2  ADS7843_Init
     220  ADS7843_Rd_Addata
       2  ARMJISHU_TouchScreen_ADS7843
       2  SPI1_Config
       2  SPI1_Init_For_Byte
      28  TOUCH_PressValid
      34  _AD2X
      30  _AD2Y
      18  distence
     144  getTouchEvent
       8  x_touch
          y_touch
          touch_time

 
   8 bytes in section .bss
 504 bytes in section .text
 
 504 bytes of CODE memory
   8 bytes of DATA memory

Errors: none
Warnings: 26
