###############################################################################
#
# IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM        13/Apr/2020  09:23:54
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\BSP\Components\at24cxx\at24cxx.cpp
#    Command line =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\BSP\Components\at24cxx\at24cxx.cpp
#        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
#        MKS_ROBIN_NANO -D TFT35 -lC
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        -lA
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
#        --diag_suppress Pa050 -o
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
#        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed --fpu=None
#        --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Full.h" -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
#        -I
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
#        -Oh --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\at24cxx.lst
#    Object file  =  
#        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\at24cxx.o
#
###############################################################################

D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Drivers\BSP\Components\at24cxx\at24cxx.cpp
      1          
      2          #include "at24cxx.h"
      3          #include "sys.h"
      4          /*--------------------------MKS EEPROM-------------------------*/
      5          

   \                                 In section .bss, align 2
      6          volatile u16 delayCnt;	
   \                     delayCnt:
   \   00000000                      DS8 2
      7          //#include "stm32f10x.h"
      8           
      9          
     10          //IO方向设置
     11           
     12          #define SDA_IN()  {GPIOB->CRL&=0X0FFFFFFF;GPIOB->CRL|=(u32)8<<28;}
     13          #define SDA_OUT() {GPIOB->CRL&=0X0FFFFFFF;GPIOB->CRL|=(u32)3<<28;}
     14          
     15          //IO操作函数	 
     16          #define IIC_SCL    PBout(6) //SCL
     17          #define IIC_SDA    PBout(7) //SDA	 
     18          #define READ_SDA   PBin(7)  //输入SDA 
     19          /*
     20          static u8  fac_us=0;							//us延时倍乘数			   
     21          static u16 fac_ms=0;							//ms延时倍乘数,在ucos下,代表每个节拍的ms数
     22          
     23          void delay_init()
     24          {
     25          	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8);	//选择外部时钟  HCLK/8
     26          	fac_us=SystemCoreClock/8000000;				//为系统时钟的1/8  
     27          	fac_ms=(u16)fac_us*1000;					//非OS下,代表每个ms需要的systick时钟数   
     28          
     29          }		
     30          */

   \                                 In section .text, align 2, keep-with-next
     31          void delay_us(uint32_t nus)
     32          {
   \                     _Z8delay_usj: (+1)
   \   00000000   0xB158             CBZ.N    R0,??delay_us_0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable8
     33                while(nus--)
     34                {
     35                  delayCnt = 5;  //10,8,6 -ok          
   \                     ??delay_us_1: (+1)
   \   00000006   0x2205             MOVS     R2,#+5
   \   00000008   0x800A             STRH     R2,[R1, #+0]
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
     36                  while(delayCnt--);
   \                     ??delay_us_2: (+1)
   \   0000000C   0x880A             LDRH     R2,[R1, #+0]
   \   0000000E   0x1E53             SUBS     R3,R2,#+1
   \   00000010   0x800B             STRH     R3,[R1, #+0]
   \   00000012   0x2A00             CMP      R2,#+0
   \   00000014   0xD1FA             BNE.N    ??delay_us_2
     37                }
   \   00000016   0x2800             CMP      R0,#+0
   \   00000018   0xD1F5             BNE.N    ??delay_us_1
     38           /*
     39          	u32 temp;	    	 
     40          	SysTick->LOAD=nus*fac_us; 					//时间加载	  		 
     41          	SysTick->VAL=0x00;        					//清空计数器
     42          	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;	//开始倒数	  
     43          	do
     44          	{
     45          		temp=SysTick->CTRL;
     46          	}while((temp&0x01)&&!(temp&(1<<16)));		//等待时间到达   
     47          	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;	//关闭计数器
     48          	SysTick->VAL =0X00;      		        //清空计数器	 
     49             */     
     50          }
   \                     ??delay_us_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
     51          //延时nms
     52          //注意nms的范围
     53          //SysTick->LOAD为24位寄存器,所以,最大延时为:
     54          //nms<=0xffffff*8*1000/SYSCLK
     55          //SYSCLK单位为Hz,nms单位为ms
     56          //对72M条件下,nms<=1864 

   \                                 In section .text, align 2, keep-with-next
     57          void delay_ms(uint16_t nms)
     58          {	 
   \                     _Z8delay_mst: (+1)
   \   00000000   0xB168             CBZ.N    R0,??delay_ms_0
   \   00000002   0x....             LDR.N    R1,??DataTable8
   \   00000004   0xF241 0x3288      MOVW     R2,#+5000
     59          
     60                while(nms--)
     61                {
     62                  delayCnt = 5000;        //10000,8000,6000 -ok          
   \                     ??delay_ms_1: (+1)
   \   00000008   0x800A             STRH     R2,[R1, #+0]
   \   0000000A   0x1E40             SUBS     R0,R0,#+1
     63                  while(delayCnt--);
   \                     ??delay_ms_2: (+1)
   \   0000000C   0x880B             LDRH     R3,[R1, #+0]
   \   0000000E   0xF1A3 0x0C01      SUB      R12,R3,#+1
   \   00000012   0xF8A1 0xC000      STRH     R12,[R1, #+0]
   \   00000016   0x2B00             CMP      R3,#+0
   \   00000018   0xD1F8             BNE.N    ??delay_ms_2
     64                }
   \   0000001A   0x2800             CMP      R0,#+0
   \   0000001C   0xD1F4             BNE.N    ??delay_ms_1
     65            
     66          	/*u32 temp;		   
     67          	SysTick->LOAD=(u32)nms*fac_ms;				//时间加载(SysTick->LOAD为24bit)
     68          	SysTick->VAL =0x00;							//清空计数器
     69          	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk ;	//开始倒数  
     70          	do
     71          	{
     72          		temp=SysTick->CTRL;
     73          	}while((temp&0x01)&&!(temp&(1<<16)));		//等待时间到达   
     74          	SysTick->CTRL&=~SysTick_CTRL_ENABLE_Msk;	//关闭计数器
     75          	SysTick->VAL =0X00;       					//清空计数器	
     76          */
     77          }
   \                     ??delay_ms_0: (+1)
   \   0000001E   0x4770             BX       LR               ;; return
     78          //初始化IIC接口

   \                                 In section .text, align 2, keep-with-next
     79          void AT24CXX_Init(void)
   \                     AT24CXX_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x....             B.N      ?Subroutine0

   \                                 In section .text, align 2, keep-with-next
     80          {
   \                     ?Subroutine0: (+1)
   \   00000000   0xB084             SUB      SP,SP,#+16
     81                  //delay_init();
     82          	IIC_Init();
   \   00000002   0x20C0             MOVS     R0,#+192
   \   00000004   0x9000             STR      R0,[SP, #+0]
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x9001             STR      R0,[SP, #+4]
   \   0000000A   0x9003             STR      R0,[SP, #+12]
   \   0000000C   0xA900             ADD      R1,SP,#+0
   \   0000000E   0x....             LDR.N    R4,??DataTable8_1  ;; 0x40010c00
   \   00000010   0x4620             MOV      R0,R4
   \   00000012   0x.... 0x....      BL       HAL_GPIO_Init
   \   00000016   0x2201             MOVS     R2,#+1
   \   00000018   0x21C0             MOVS     R1,#+192
   \   0000001A   0x4620             MOV      R0,R4
   \   0000001C   0x.... 0x....      BL       HAL_GPIO_WritePin
     83          }
   \   00000020   0xB004             ADD      SP,SP,#+16
   \   00000022   0xBD10             POP      {R4,PC}          ;; return
     84          //在AT24CXX指定地址读出一个数据
     85          //ReadAddr:开始读数的地址  
     86          //返回值  :读到的数据

   \                                 In section .text, align 2, keep-with-next
     87          uint8_t AT24CXX_ReadOneByte(uint16_t ReadAddr)
     88          {				  
   \                     AT24CXX_ReadOneByte: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x4604             MOV      R4,R0
     89          	uint8_t temp=0;		  	    																 
     90              IIC_Start();  
   \   00000004   0x.... 0x....      BL       IIC_Start
     91          	if(EE_TYPE>AT24C16)
     92          	{
     93          		IIC_Send_Byte(0XA0);	   //发送写命令
     94          		IIC_Wait_Ack();
     95          		IIC_Send_Byte(ReadAddr>>8);//发送高地址
     96          		IIC_Wait_Ack();		 
     97          	}else IIC_Send_Byte(0XA0+((ReadAddr/256)<<1));   //发送器件地址0XA0,写数据 	 
   \   00000008   0x0A20             LSRS     R0,R4,#+8
   \   0000000A   0x0040             LSLS     R0,R0,#+1
   \   0000000C   0x30A0             ADDS     R0,R0,#+160
   \   0000000E   0xB2C0             UXTB     R0,R0
   \   00000010   0x.... 0x....      BL       IIC_Send_Byte
     98          
     99          	IIC_Wait_Ack(); 
   \   00000014   0x.... 0x....      BL       IIC_Wait_Ack
    100              IIC_Send_Byte(ReadAddr%256);   //发送低地址
   \   00000018   0xB2E0             UXTB     R0,R4
   \   0000001A   0x.... 0x....      BL       IIC_Send_Byte
    101          	IIC_Wait_Ack();	    
   \   0000001E   0x.... 0x....      BL       IIC_Wait_Ack
    102          	IIC_Start();  	 	   
   \   00000022   0x.... 0x....      BL       IIC_Start
    103          	IIC_Send_Byte(0XA1);           //进入接收模式			   
   \   00000026   0x20A1             MOVS     R0,#+161
   \   00000028   0x.... 0x....      BL       IIC_Send_Byte
    104          	IIC_Wait_Ack();	 
   \   0000002C   0x.... 0x....      BL       IIC_Wait_Ack
    105              temp=IIC_Read_Byte(0);		   
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x.... 0x....      BL       IIC_Read_Byte
   \   00000036   0x4604             MOV      R4,R0
    106              IIC_Stop();//产生一个停止条件	    
   \   00000038   0x.... 0x....      BL       IIC_Stop
    107          	return temp;
   \   0000003C   0x4620             MOV      R0,R4
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    108          }
    109          //在AT24CXX指定地址写入一个数据
    110          //WriteAddr  :写入数据的目的地址    
    111          //DataToWrite:要写入的数据

   \                                 In section .text, align 2, keep-with-next
    112          void AT24CXX_WriteOneByte(uint16_t WriteAddr,uint8_t DataToWrite)
    113          {				   	  	    																 
   \                     AT24CXX_WriteOneByte: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
    114              IIC_Start();  
   \   00000006   0x.... 0x....      BL       IIC_Start
    115          	if(EE_TYPE>AT24C16)
    116          	{
    117          		IIC_Send_Byte(0XA0);	    //发送写命令
    118          		IIC_Wait_Ack();
    119          		IIC_Send_Byte(WriteAddr>>8);//发送高地址
    120           	}else
    121          	{
    122          		IIC_Send_Byte(0XA0+((WriteAddr/256)<<1));   //发送器件地址0XA0,写数据 
   \   0000000A   0x0A20             LSRS     R0,R4,#+8
   \   0000000C   0x0040             LSLS     R0,R0,#+1
   \   0000000E   0x30A0             ADDS     R0,R0,#+160
   \   00000010   0xB2C0             UXTB     R0,R0
   \   00000012   0x.... 0x....      BL       IIC_Send_Byte
    123          	}	 
    124          	IIC_Wait_Ack();	   
   \   00000016   0x.... 0x....      BL       IIC_Wait_Ack
    125              IIC_Send_Byte(WriteAddr%256);   //发送低地址
   \   0000001A   0xB2E0             UXTB     R0,R4
   \   0000001C   0x.... 0x....      BL       IIC_Send_Byte
    126          	IIC_Wait_Ack(); 	 										  		   
   \   00000020   0x.... 0x....      BL       IIC_Wait_Ack
    127          	IIC_Send_Byte(DataToWrite);     //发送字节							   
   \   00000024   0x4628             MOV      R0,R5
   \   00000026   0x.... 0x....      BL       IIC_Send_Byte
    128          	IIC_Wait_Ack();  		    	   
   \   0000002A   0x.... 0x....      BL       IIC_Wait_Ack
    129              IIC_Stop();//产生一个停止条件 
   \   0000002E   0x.... 0x....      BL       IIC_Stop
    130          	//delay_ms(10);	 
    131          	delay_ms(5);	 //5-ok;3-ok;2-ok;1-bad;
   \   00000032   0xE8BD 0x4032      POP      {R1,R4,R5,LR}
   \   00000036   0x2005             MOVS     R0,#+5
   \   00000038   0x....             B.N      _Z8delay_mst
    132          }
    133          //在AT24CXX里面的指定地址开始写入长度为Len的数据
    134          //该函数用于写入16bit或者32bit的数据.
    135          //WriteAddr  :开始写入的地址  
    136          //DataToWrite:数据数组首地址
    137          //Len        :要写入数据的长度2,4

   \                                 In section .text, align 2, keep-with-next
    138          void AT24CXX_WriteLenByte(uint16_t WriteAddr,uint32_t DataToWrite,uint8_t Len)
    139          {  	
   \                     AT24CXX_WriteLenByte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    140          	uint8_t t;
    141          	for(t=0;t<Len;t++)
   \   00000008   0xD00A             BEQ.N    ??AT24CXX_WriteLenByte_0
   \   0000000A   0x2700             MOVS     R7,#+0
    142          	{
    143          		AT24CXX_WriteOneByte(WriteAddr+t,(DataToWrite>>(8*t))&0xff);
   \                     ??AT24CXX_WriteLenByte_1: (+1)
   \   0000000C   0xFA25 0xF107      LSR      R1,R5,R7
   \   00000010   0xB2C9             UXTB     R1,R1
   \   00000012   0xB2A0             UXTH     R0,R4
   \   00000014   0x.... 0x....      BL       AT24CXX_WriteOneByte
    144          	}												    
   \   00000018   0x3708             ADDS     R7,R7,#+8
   \   0000001A   0x1C64             ADDS     R4,R4,#+1
   \   0000001C   0x1E76             SUBS     R6,R6,#+1
   \   0000001E   0xD1F5             BNE.N    ??AT24CXX_WriteLenByte_1
    145          }
   \                     ??AT24CXX_WriteLenByte_0: (+1)
   \   00000020   0xBDF1             POP      {R0,R4-R7,PC}    ;; return
    146          
    147          //在AT24CXX里面的指定地址开始读出长度为Len的数据
    148          //该函数用于读出16bit或者32bit的数据.
    149          //ReadAddr   :开始读出的地址 
    150          //返回值     :数据
    151          //Len        :要读出数据的长度2,4

   \                                 In section .text, align 2, keep-with-next
    152          uint32_t AT24CXX_ReadLenByte(uint16_t ReadAddr,uint8_t Len)
    153          {  	
   \                     AT24CXX_ReadLenByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x460C             MOV      R4,R1
    154          	uint8_t t;
    155          	uint32_t temp=0;
   \   00000004   0x2500             MOVS     R5,#+0
    156          	for(t=0;t<Len;t++)
   \   00000006   0xB14C             CBZ.N    R4,??AT24CXX_ReadLenByte_0
   \   00000008   0x1820             ADDS     R0,R4,R0
   \   0000000A   0x1E46             SUBS     R6,R0,#+1
    157          	{
    158          		temp<<=8;
    159          		temp+=AT24CXX_ReadOneByte(ReadAddr+Len-t-1); 	 				   
   \                     ??AT24CXX_ReadLenByte_1: (+1)
   \   0000000C   0xB2B0             UXTH     R0,R6
   \   0000000E   0x.... 0x....      BL       AT24CXX_ReadOneByte
    160          	}
   \   00000012   0x1E76             SUBS     R6,R6,#+1
   \   00000014   0xEB00 0x2505      ADD      R5,R0,R5, LSL #+8
   \   00000018   0x1E64             SUBS     R4,R4,#+1
   \   0000001A   0xD1F7             BNE.N    ??AT24CXX_ReadLenByte_1
    161          	return temp;												    
   \                     ??AT24CXX_ReadLenByte_0: (+1)
   \   0000001C   0x4628             MOV      R0,R5
   \   0000001E   0xBD70             POP      {R4-R6,PC}       ;; return
    162          }
    163          //检查AT24CXX是否正常
    164          //这里用了24XX的最后一个地址(255)来存储标志字.
    165          //如果用其他24C系列,这个地址要修改
    166          //返回1:检测失败
    167          //返回0:检测成功

   \                                 In section .text, align 2, keep-with-next
    168          uint8_t AT24CXX_Check(void)
    169          {
   \                     AT24CXX_Check: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    170          	uint8_t temp;
    171          	temp=AT24CXX_ReadOneByte(255);//避免每次开机都写AT24CXX			   
    172          	if(temp==0X55)return 0;		   
   \   00000002   0x20FF             MOVS     R0,#+255
   \   00000004   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   00000008   0x2855             CMP      R0,#+85
   \   0000000A   0xD01A             BEQ.N    ??AT24CXX_Check_0
    173          	else//排除第一次初始化的情况
    174          	{
    175          		AT24CXX_WriteOneByte(255,0X55);
   \   0000000C   0x.... 0x....      BL       IIC_Start
   \   00000010   0x20A0             MOVS     R0,#+160
   \   00000012   0x.... 0x....      BL       IIC_Send_Byte
   \   00000016   0x.... 0x....      BL       IIC_Wait_Ack
   \   0000001A   0x20FF             MOVS     R0,#+255
   \   0000001C   0x.... 0x....      BL       IIC_Send_Byte
   \   00000020   0x.... 0x....      BL       IIC_Wait_Ack
   \   00000024   0x2055             MOVS     R0,#+85
   \   00000026   0x.... 0x....      BL       IIC_Send_Byte
   \   0000002A   0x.... 0x....      BL       IIC_Wait_Ack
   \   0000002E   0x.... 0x....      BL       IIC_Stop
   \   00000032   0x2005             MOVS     R0,#+5
   \   00000034   0x.... 0x....      BL       _Z8delay_mst
    176          	    temp=AT24CXX_ReadOneByte(255);	  
    177          		if(temp==0X55)return 0;
   \   00000038   0x20FF             MOVS     R0,#+255
   \   0000003A   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   0000003E   0x2855             CMP      R0,#+85
   \   00000040   0xD101             BNE.N    ??AT24CXX_Check_1
   \                     ??AT24CXX_Check_0: (+1)
   \   00000042   0x2000             MOVS     R0,#+0
   \   00000044   0xBD02             POP      {R1,PC}
    178          	}
    179          	return 1;											  
   \                     ??AT24CXX_Check_1: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0xBD02             POP      {R1,PC}          ;; return
    180          }
    181          
    182          //在AT24CXX里面的指定地址开始读出指定个数的数据
    183          //ReadAddr :开始读出的地址 对24c02为0~255
    184          //pBuffer  :数据数组首地址
    185          //NumToRead:要读出数据的个数
    186          //HAL_StatusTypeDef AT24CXX_Read(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    187          //void AT24CXX_Read(uint16_t ReadAddr,uint8_t *pBuffer,uint16_t NumToRead)

   \                                 In section .text, align 2, keep-with-next
    188          void AT24CXX_Read(uint16_t ReadAddr,uint8_t *pBuffer,uint32_t NumToRead)
    189          
    190          {
   \                     AT24CXX_Read: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0xD007             BEQ.N    ??AT24CXX_Read_0
    191          	while(NumToRead)
    192          	{
    193          		*pBuffer++=AT24CXX_ReadOneByte(ReadAddr++);	
   \                     ??AT24CXX_Read_1: (+1)
   \   0000000A   0xB2A0             UXTH     R0,R4
   \   0000000C   0x.... 0x....      BL       AT24CXX_ReadOneByte
   \   00000010   0x1C64             ADDS     R4,R4,#+1
   \   00000012   0xF805 0x0B01      STRB     R0,[R5], #+1
    194          		NumToRead--;
   \   00000016   0x1E76             SUBS     R6,R6,#+1
    195          	}
   \   00000018   0xD1F7             BNE.N    ??AT24CXX_Read_1
    196          }  
   \                     ??AT24CXX_Read_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    197          //在AT24CXX里面的指定地址开始写入指定个数的数据
    198          //WriteAddr :开始写入的地址 对24c02为0~255
    199          //pBuffer   :数据数组首地址
    200          //NumToWrite:要写入数据的个数
    201          //HAL_StatusTypeDef AT24CXX_Write(uint16_t MemAddress, uint8_t* pBuffer, uint32_t BufferSize)
    202          //void AT24CXX_Write(u16 WriteAddr,u8 *pBuffer,u16 NumToWrite)

   \                                 In section .text, align 2, keep-with-next
    203          void AT24CXX_Write(uint16_t WriteAddr,uint8_t*pBuffer,uint32_t NumToWrite)
    204          
    205          {
   \                     AT24CXX_Write: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x4604             MOV      R4,R0
   \   00000004   0x460D             MOV      R5,R1
   \   00000006   0x0016             MOVS     R6,R2
   \   00000008   0xD007             BEQ.N    ??AT24CXX_Write_0
    206          	while(NumToWrite--)
    207          	{
    208          		AT24CXX_WriteOneByte(WriteAddr,*pBuffer);
   \                     ??AT24CXX_Write_1: (+1)
   \   0000000A   0xF815 0x1B01      LDRB     R1,[R5], #+1
   \   0000000E   0xB2A0             UXTH     R0,R4
   \   00000010   0x.... 0x....      BL       AT24CXX_WriteOneByte
    209          		WriteAddr++;
   \   00000014   0x1C64             ADDS     R4,R4,#+1
    210          		pBuffer++;
   \   00000016   0x1E76             SUBS     R6,R6,#+1
    211          	}
   \   00000018   0xD1F7             BNE.N    ??AT24CXX_Write_1
    212          }
   \                     ??AT24CXX_Write_0: (+1)
   \   0000001A   0xBD70             POP      {R4-R6,PC}       ;; return
    213          
    214          //初始化IIC

   \                                 In section .text, align 2, keep-with-next
    215          void IIC_Init(void)
   \                     IIC_Init: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002                      REQUIRE ?Subroutine0
   \   00000002                      ;; // Fall through to label ?Subroutine0
    216          {		
    217          	GPIO_InitTypeDef GPIO_InitStruct;
    218          
    219          	GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
    220          	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    221          	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
    222          	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    223          	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_SET);
    224          	
    225          }
    226          //产生IIC起始信号

   \                                 In section .text, align 2, keep-with-next
    227          void IIC_Start(void)
    228          {
   \                     IIC_Start: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    229          	SDA_OUT();     //sda线输出
   \   00000002   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   00000004   0x....             LDR.N    R4,??DataTable8_2  ;; 0x42218198
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x0109             LSLS     R1,R1,#+4
   \   0000000A   0x0909             LSRS     R1,R1,#+4
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000014   0x6001             STR      R1,[R0, #+0]
    230          	IIC_SDA=1;	  	  
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x6060             STR      R0,[R4, #+4]
    231          	IIC_SCL=1;
   \   0000001A   0x6020             STR      R0,[R4, #+0]
    232          	delay_us(4);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       _Z8delay_usj
    233           	IIC_SDA=0;//START:when CLK is high,DATA change form high to low 
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x6060             STR      R0,[R4, #+4]
    234          	delay_us(4);
   \   00000026   0x2004             MOVS     R0,#+4
   \   00000028   0x....             B.N      ??Subroutine2_0
    235          	IIC_SCL=0;//钳住I2C总线，准备发送或接收数据 
    236          }	  

   \                                 In section .text, align 2, keep-with-next
   \                     ??Subroutine2_0: (+1)
   \   00000000   0x.... 0x....      BL       _Z8delay_usj
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
   \   00000008   0xBD10             POP      {R4,PC}          ;; return
    237          //产生IIC停止信号

   \                                 In section .text, align 2, keep-with-next
    238          void IIC_Stop(void)
    239          {
   \                     IIC_Stop: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    240          	SDA_OUT();//sda线输出
   \   00000002   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   00000004   0x....             LDR.N    R4,??DataTable8_2  ;; 0x42218198
   \   00000006   0x6801             LDR      R1,[R0, #+0]
   \   00000008   0x0109             LSLS     R1,R1,#+4
   \   0000000A   0x0909             LSRS     R1,R1,#+4
   \   0000000C   0x6001             STR      R1,[R0, #+0]
   \   0000000E   0x6801             LDR      R1,[R0, #+0]
   \   00000010   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000014   0x6001             STR      R1,[R0, #+0]
    241          	IIC_SCL=0;
   \   00000016   0x2000             MOVS     R0,#+0
   \   00000018   0x6020             STR      R0,[R4, #+0]
    242          	IIC_SDA=0;//STOP:when CLK is high DATA change form low to high
   \   0000001A   0x6060             STR      R0,[R4, #+4]
    243           	delay_us(4);
   \   0000001C   0x2004             MOVS     R0,#+4
   \   0000001E   0x.... 0x....      BL       _Z8delay_usj
    244          	IIC_SCL=1; 
   \   00000022   0x2001             MOVS     R0,#+1
   \   00000024   0x6020             STR      R0,[R4, #+0]
    245          	IIC_SDA=1;//发送I2C总线结束信号
   \   00000026   0x6060             STR      R0,[R4, #+4]
    246          	delay_us(4);							   	
   \   00000028   0x2004             MOVS     R0,#+4
   \   0000002A   0xE8BD 0x4010      POP      {R4,LR}
   \   0000002E   0x....             B.N      _Z8delay_usj
    247          }
    248          //等待应答信号到来
    249          //返回值：1，接收应答失败
    250          //        0，接收应答成功

   \                                 In section .text, align 2, keep-with-next
    251          uint8_t IIC_Wait_Ack(void)
    252          {
   \                     IIC_Wait_Ack: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    253          	uint8_t ucErrTime=0;
    254          	SDA_IN();      //SDA设置为输入  
   \   00000002   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   00000004   0x6801             LDR      R1,[R0, #+0]
   \   00000006   0x0109             LSLS     R1,R1,#+4
   \   00000008   0x0909             LSRS     R1,R1,#+4
   \   0000000A   0x6001             STR      R1,[R0, #+0]
   \   0000000C   0x6801             LDR      R1,[R0, #+0]
   \   0000000E   0xF041 0x4100      ORR      R1,R1,#0x80000000
   \   00000012   0x6001             STR      R1,[R0, #+0]
    255          	IIC_SDA=1;delay_us(1);	   
   \   00000014   0x2001             MOVS     R0,#+1
   \   00000016   0x....             LDR.N    R1,??DataTable8_3  ;; 0x4221819c
   \   00000018   0x6008             STR      R0,[R1, #+0]
   \   0000001A   0x.... 0x....      BL       _Z8delay_usj
    256          	IIC_SCL=1;delay_us(1);	 
   \   0000001E   0x2001             MOVS     R0,#+1
   \   00000020   0x....             LDR.N    R4,??DataTable8_4  ;; 0x4221811c
   \   00000022   0x67E0             STR      R0,[R4, #+124]
   \   00000024   0x.... 0x....      BL       _Z8delay_usj
   \   00000028   0x20FB             MOVS     R0,#+251
    257          	while(READ_SDA)
   \                     ??IIC_Wait_Ack_0: (+1)
   \   0000002A   0x6821             LDR      R1,[R4, #+0]
   \   0000002C   0xB129             CBZ.N    R1,??IIC_Wait_Ack_1
    258          	{
    259          		ucErrTime++;
    260          		if(ucErrTime>250)
   \   0000002E   0x1E40             SUBS     R0,R0,#+1
   \   00000030   0xD1FB             BNE.N    ??IIC_Wait_Ack_0
    261          		{
    262          			IIC_Stop();
   \   00000032   0x.... 0x....      BL       IIC_Stop
    263          			return 1;
   \   00000036   0x2001             MOVS     R0,#+1
   \   00000038   0xBD10             POP      {R4,PC}
    264          		}
    265          	}
    266          	IIC_SCL=0;//时钟输出0 	   
   \                     ??IIC_Wait_Ack_1: (+1)
   \   0000003A   0x2000             MOVS     R0,#+0
   \   0000003C   0x67E0             STR      R0,[R4, #+124]
    267          	return 0;  
   \   0000003E   0xBD10             POP      {R4,PC}          ;; return
    268          } 
    269          //产生ACK应答

   \                                 In section .text, align 2, keep-with-next
    270          void IIC_Ack(void)
    271          {
   \                     IIC_Ack: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    272          	IIC_SCL=0;
   \   00000002   0x....             LDR.N    R4,??DataTable8_2  ;; 0x42218198
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    273          	SDA_OUT();
   \   00000008   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0109             LSLS     R1,R1,#+4
   \   0000000E   0x0909             LSRS     R1,R1,#+4
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000018   0x6001             STR      R1,[R0, #+0]
    274          	IIC_SDA=0;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x....             B.N      ?Subroutine1
    275          	delay_us(2);
    276          	IIC_SCL=1;
    277          	delay_us(2);
    278          	IIC_SCL=0;
    279          }

   \                                 In section .text, align 2, keep-with-next
   \                     ?Subroutine1: (+1)
   \   00000000   0x6060             STR      R0,[R4, #+4]
   \   00000002   0x2002             MOVS     R0,#+2
   \   00000004   0x.... 0x....      BL       _Z8delay_usj
   \   00000008   0x2001             MOVS     R0,#+1
   \   0000000A   0x6020             STR      R0,[R4, #+0]
   \   0000000C   0x2002             MOVS     R0,#+2
   \   0000000E                      REQUIRE ??Subroutine2_0
   \   0000000E                      ;; // Fall through to label ??Subroutine2_0
    280          //不产生ACK应答		    

   \                                 In section .text, align 2, keep-with-next
    281          void IIC_NAck(void)
    282          {
   \                     IIC_NAck: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
    283          	IIC_SCL=0;
   \   00000002   0x....             LDR.N    R4,??DataTable8_2  ;; 0x42218198
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x6020             STR      R0,[R4, #+0]
    284          	SDA_OUT();
   \   00000008   0x....             LDR.N    R0,??DataTable8_1  ;; 0x40010c00
   \   0000000A   0x6801             LDR      R1,[R0, #+0]
   \   0000000C   0x0109             LSLS     R1,R1,#+4
   \   0000000E   0x0909             LSRS     R1,R1,#+4
   \   00000010   0x6001             STR      R1,[R0, #+0]
   \   00000012   0x6801             LDR      R1,[R0, #+0]
   \   00000014   0xF041 0x5140      ORR      R1,R1,#0x30000000
   \   00000018   0x6001             STR      R1,[R0, #+0]
    285          	IIC_SDA=1;
   \   0000001A   0x2001             MOVS     R0,#+1
   \   0000001C                      REQUIRE ?Subroutine1
   \   0000001C                      ;; // Fall through to label ?Subroutine1
    286          	delay_us(2);
    287          	IIC_SCL=1;
    288          	delay_us(2);
    289          	IIC_SCL=0;
    290          }					 				     
    291          //IIC发送一个字节
    292          //返回从机有无应答
    293          //1，有应答
    294          //0，无应答			  

   \                                 In section .text, align 2, keep-with-next
    295          void IIC_Send_Byte(uint8_t txd)
    296          {                        
   \                     IIC_Send_Byte: (+1)
   \   00000000   0xB470             PUSH     {R4-R6}
    297              uint8_t t;   
    298          	SDA_OUT(); 	    
   \   00000002   0x....             LDR.N    R1,??DataTable8_1  ;; 0x40010c00
   \   00000004   0x....             LDR.N    R3,??DataTable8
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0x0112             LSLS     R2,R2,#+4
   \   0000000A   0x0912             LSRS     R2,R2,#+4
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   \   0000000E   0x680A             LDR      R2,[R1, #+0]
   \   00000010   0xF042 0x5240      ORR      R2,R2,#0x30000000
   \   00000014   0x600A             STR      R2,[R1, #+0]
    299              IIC_SCL=0;//拉低时钟开始数据传输
   \   00000016   0x2200             MOVS     R2,#+0
   \   00000018   0x....             LDR.N    R1,??DataTable8_2  ;; 0x42218198
   \   0000001A   0x600A             STR      R2,[R1, #+0]
    300              for(t=0;t<8;t++)
   \   0000001C   0x2208             MOVS     R2,#+8
    301              {              
    302                  //IIC_SDA=(txd&0x80)>>7;
    303          		if((txd&0x80)>>7)
   \                     ??IIC_Send_Byte_0: (+1)
   \   0000001E   0xB2C0             UXTB     R0,R0
   \   00000020   0x09C4             LSRS     R4,R0,#+7
   \   00000022   0x1E65             SUBS     R5,R4,#+1
   \   00000024   0x41AD             SBCS     R5,R5,R5
   \   00000026   0x43ED             MVNS     R5,R5
   \   00000028   0x0FED             LSRS     R5,R5,#+31
   \   0000002A   0x604D             STR      R5,[R1, #+4]
    304          			IIC_SDA=1;
    305          		else
    306          			IIC_SDA=0;
    307          		txd<<=1; 	  
   \   0000002C   0x0040             LSLS     R0,R0,#+1
    308          		delay_us(2);   //对TEA5767这三个延时都是必须的
   \   0000002E   0x2402             MOVS     R4,#+2
   \                     ??IIC_Send_Byte_1: (+1)
   \   00000030   0x2505             MOVS     R5,#+5
   \   00000032   0x801D             STRH     R5,[R3, #+0]
   \   00000034   0x1E64             SUBS     R4,R4,#+1
   \                     ??IIC_Send_Byte_2: (+1)
   \   00000036   0x881D             LDRH     R5,[R3, #+0]
   \   00000038   0x1E6E             SUBS     R6,R5,#+1
   \   0000003A   0x801E             STRH     R6,[R3, #+0]
   \   0000003C   0x2D00             CMP      R5,#+0
   \   0000003E   0xD1FA             BNE.N    ??IIC_Send_Byte_2
   \   00000040   0x2C00             CMP      R4,#+0
   \   00000042   0xD1F5             BNE.N    ??IIC_Send_Byte_1
    309          		IIC_SCL=1;
   \   00000044   0x2401             MOVS     R4,#+1
   \   00000046   0x600C             STR      R4,[R1, #+0]
    310          		delay_us(2); 
   \   00000048   0x2402             MOVS     R4,#+2
   \                     ??IIC_Send_Byte_3: (+1)
   \   0000004A   0x2505             MOVS     R5,#+5
   \   0000004C   0x801D             STRH     R5,[R3, #+0]
   \   0000004E   0x1E64             SUBS     R4,R4,#+1
   \                     ??IIC_Send_Byte_4: (+1)
   \   00000050   0x881D             LDRH     R5,[R3, #+0]
   \   00000052   0x1E6E             SUBS     R6,R5,#+1
   \   00000054   0x801E             STRH     R6,[R3, #+0]
   \   00000056   0x2D00             CMP      R5,#+0
   \   00000058   0xD1FA             BNE.N    ??IIC_Send_Byte_4
   \   0000005A   0x2C00             CMP      R4,#+0
   \   0000005C   0xD1F5             BNE.N    ??IIC_Send_Byte_3
    311          		IIC_SCL=0;	
   \   0000005E   0x600C             STR      R4,[R1, #+0]
    312          		delay_us(2);
   \   00000060   0x2402             MOVS     R4,#+2
   \                     ??IIC_Send_Byte_5: (+1)
   \   00000062   0x2505             MOVS     R5,#+5
   \   00000064   0x801D             STRH     R5,[R3, #+0]
   \   00000066   0x1E64             SUBS     R4,R4,#+1
   \                     ??IIC_Send_Byte_6: (+1)
   \   00000068   0x881D             LDRH     R5,[R3, #+0]
   \   0000006A   0x1E6E             SUBS     R6,R5,#+1
   \   0000006C   0x801E             STRH     R6,[R3, #+0]
   \   0000006E   0x2D00             CMP      R5,#+0
   \   00000070   0xD1FA             BNE.N    ??IIC_Send_Byte_6
   \   00000072   0x2C00             CMP      R4,#+0
   \   00000074   0xD1F5             BNE.N    ??IIC_Send_Byte_5
    313              }	 
   \   00000076   0x1E52             SUBS     R2,R2,#+1
   \   00000078   0xD1D1             BNE.N    ??IIC_Send_Byte_0
    314          } 	    
   \   0000007A   0xBC70             POP      {R4-R6}
   \   0000007C   0x4770             BX       LR               ;; return
    315          //读1个字节，ack=1时，发送ACK，ack=0，发送nACK   

   \                                 In section .text, align 2, keep-with-next
    316          uint8_t IIC_Read_Byte(unsigned char ack)
    317          {
   \                     IIC_Read_Byte: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
    318          	unsigned char i,receive=0;
    319          	SDA_IN();//SDA设置为输入
   \   00000002   0x....             LDR.N    R1,??DataTable8_1  ;; 0x40010c00
   \   00000004   0x....             LDR.N    R3,??DataTable8
   \   00000006   0x680A             LDR      R2,[R1, #+0]
   \   00000008   0x0112             LSLS     R2,R2,#+4
   \   0000000A   0x0912             LSRS     R2,R2,#+4
   \   0000000C   0x600A             STR      R2,[R1, #+0]
   \   0000000E   0x2400             MOVS     R4,#+0
   \   00000010   0x680A             LDR      R2,[R1, #+0]
   \   00000012   0xF042 0x4200      ORR      R2,R2,#0x80000000
   \   00000016   0x600A             STR      R2,[R1, #+0]
    320              for(i=0;i<8;i++ )
   \   00000018   0x2108             MOVS     R1,#+8
   \   0000001A   0x....             LDR.N    R2,??DataTable8_4  ;; 0x4221811c
    321          	{
    322                  IIC_SCL=0; 
   \                     ??IIC_Read_Byte_0: (+1)
   \   0000001C   0x2500             MOVS     R5,#+0
   \   0000001E   0x67D5             STR      R5,[R2, #+124]
    323                  delay_us(2);
   \   00000020   0x2502             MOVS     R5,#+2
   \                     ??IIC_Read_Byte_1: (+1)
   \   00000022   0x2605             MOVS     R6,#+5
   \   00000024   0x801E             STRH     R6,[R3, #+0]
   \   00000026   0x1E6D             SUBS     R5,R5,#+1
   \                     ??IIC_Read_Byte_2: (+1)
   \   00000028   0x881E             LDRH     R6,[R3, #+0]
   \   0000002A   0x1E77             SUBS     R7,R6,#+1
   \   0000002C   0x801F             STRH     R7,[R3, #+0]
   \   0000002E   0x2E00             CMP      R6,#+0
   \   00000030   0xD1FA             BNE.N    ??IIC_Read_Byte_2
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD1F5             BNE.N    ??IIC_Read_Byte_1
    324          		IIC_SCL=1;
   \   00000036   0x2501             MOVS     R5,#+1
   \   00000038   0x67D5             STR      R5,[R2, #+124]
    325                  receive<<=1;
   \   0000003A   0x0064             LSLS     R4,R4,#+1
    326                  if(READ_SDA)receive++;   
   \   0000003C   0x6815             LDR      R5,[R2, #+0]
   \   0000003E   0xB105             CBZ.N    R5,??IIC_Read_Byte_3
   \   00000040   0x1C64             ADDS     R4,R4,#+1
    327          		delay_us(1); 
   \                     ??IIC_Read_Byte_3: (+1)
   \   00000042   0x2505             MOVS     R5,#+5
   \   00000044   0x801D             STRH     R5,[R3, #+0]
   \                     ??IIC_Read_Byte_4: (+1)
   \   00000046   0x881D             LDRH     R5,[R3, #+0]
   \   00000048   0x1E6E             SUBS     R6,R5,#+1
   \   0000004A   0x801E             STRH     R6,[R3, #+0]
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD1FA             BNE.N    ??IIC_Read_Byte_4
    328              }					 
   \   00000050   0x1E49             SUBS     R1,R1,#+1
   \   00000052   0xD1E3             BNE.N    ??IIC_Read_Byte_0
    329              if (!ack)
   \   00000054   0xB910             CBNZ.N   R0,??IIC_Read_Byte_5
    330                  IIC_NAck();//发送nACK
   \   00000056   0x.... 0x....      BL       IIC_NAck
   \   0000005A   0xE001             B.N      ??IIC_Read_Byte_6
    331              else
    332                  IIC_Ack(); //发送ACK   
   \                     ??IIC_Read_Byte_5: (+1)
   \   0000005C   0x.... 0x....      BL       IIC_Ack
    333              return receive;
   \                     ??IIC_Read_Byte_6: (+1)
   \   00000060   0xB2E0             UXTB     R0,R4
   \   00000062   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    334          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     delayCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x40010C00         DC32     0x40010c00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x42218198         DC32     0x42218198

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x4221819C         DC32     0x4221819c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x4221811C         DC32     0x4221811c
    335          
    336          /*--------------------------MKS EEPROM-------------------------*/
    337          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   AT24CXX_Check
         8   -> AT24CXX_ReadOneByte
         8   -> IIC_Send_Byte
         8   -> IIC_Start
         8   -> IIC_Stop
         8   -> IIC_Wait_Ack
         8   -> delay_ms(uint16_t)
       8   AT24CXX_Init
        24   -> HAL_GPIO_Init
        24   -> HAL_GPIO_WritePin
      16   AT24CXX_Read
        16   -> AT24CXX_ReadOneByte
      16   AT24CXX_ReadLenByte
        16   -> AT24CXX_ReadOneByte
       8   AT24CXX_ReadOneByte
         8   -> IIC_Read_Byte
         8   -> IIC_Send_Byte
         8   -> IIC_Start
         8   -> IIC_Stop
         8   -> IIC_Wait_Ack
      16   AT24CXX_Write
        16   -> AT24CXX_WriteOneByte
      24   AT24CXX_WriteLenByte
        24   -> AT24CXX_WriteOneByte
      16   AT24CXX_WriteOneByte
        16   -> IIC_Send_Byte
        16   -> IIC_Start
        16   -> IIC_Stop
        16   -> IIC_Wait_Ack
         0   -> delay_ms(uint16_t)
       8   IIC_Ack
         8   -> delay_us(uint32_t)
       0   IIC_Init
        24   -> HAL_GPIO_Init
        24   -> HAL_GPIO_WritePin
       8   IIC_NAck
         8   -> delay_us(uint32_t)
      24   IIC_Read_Byte
        24   -> IIC_Ack
        24   -> IIC_NAck
      12   IIC_Send_Byte
       8   IIC_Start
         8   -> delay_us(uint32_t)
       8   IIC_Stop
         0   -> delay_us(uint32_t)
         8   -> delay_us(uint32_t)
       8   IIC_Wait_Ack
         8   -> IIC_Stop
         8   -> delay_us(uint32_t)
       0   delay_ms(uint16_t)
       0   delay_us(uint32_t)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
      10  ??Subroutine2_0
      36  ?Subroutine0
      14  ?Subroutine1
      74  AT24CXX_Check
       4  AT24CXX_Init
      28  AT24CXX_Read
      32  AT24CXX_ReadLenByte
      64  AT24CXX_ReadOneByte
      28  AT24CXX_Write
      34  AT24CXX_WriteLenByte
      58  AT24CXX_WriteOneByte
      30  IIC_Ack
       2  IIC_Init
      28  IIC_NAck
     100  IIC_Read_Byte
     126  IIC_Send_Byte
      42  IIC_Start
      48  IIC_Stop
      64  IIC_Wait_Ack
       2  delayCnt
      32  delay_ms(uint16_t)
      28  delay_us(uint32_t)

 
   2 bytes in section .bss
 902 bytes in section .text
 
 902 bytes of CODE memory
   2 bytes of DATA memory

Errors: none
Warnings: none
