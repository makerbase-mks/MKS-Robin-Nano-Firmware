///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.10.1.6676/W32 for ARM       13/Apr/2020  10:56:54
// Copyright 1999-2014 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    Command line =  
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//        -D USE_HAL_DRIVER -D STM32F103xE -D STM32F10X_HD -D USE_HAL_LIB -D
//        MKS_ROBIN_NANO -D TFT35 -lC
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
//        -lA
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\
//        --diag_suppress Pa050 -o
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/Obj\
//        --debug --endian=little --cpu=Cortex-M3 -e --char_is_signed
//        --fpu=None --dlib_config "C:\Program Files (x86)\IAR Systems\Embedded
//        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Src\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F1xx_HAL_Driver/Inc/Legacy\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src/drivers\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Core/Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/ST/STM32_USB_Host_Library/Class/MSC/Inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Device/ST/STM32F1xx/Include\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/FatFs/src\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/Third_Party/Marlin\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/CMSIS/Include\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/variant\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/at24cxx\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/w25qxx\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/BSP/Components/lcd\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/STM32F10x_StdPeriph_Driver/inc\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Drivers/libstmf4/include\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../Middlewares/arduino/stm32/cores/arduino\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/Multi_language\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM/../User/ui/QRENCODE\
//        -I
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\..\Middlewares\GUI\
//        -Oh --eec++ -I "C:\Program Files (x86)\IAR Systems\Embedded Workbench
//        7.0\arm\CMSIS\Include\"
//    List file    =  
//        D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\EWARM\mksRobinNano/List\Marlin_main.s
//
///////////////////////////////////////////////////////////////////////////////

        RTMODEL "__CPP_Language", "EC++"
        RTMODEL "__SystemLibrary", "DLib"
        RTMODEL "__dlib_file_descriptor", "1"
        RTMODEL "__dlib_full_locale_support", "1"
        RTMODEL "__iar_require _Printf", "floats,int_specials,widths"
        AAPCS BASE,INTERWORK
        PRESERVE8
        REQUIRE8

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN AT24CXX_Read
        EXTERN BMP_PIC_X
        EXTERN BMP_PIC_Y
        EXTERN BUTTON_SetDefaultFont
        EXTERN GUI_DispStringAt
        EXTERN GUI_Exec
        EXTERN GUI_FontHZ16
        EXTERN GUI_FontHZ_fontHz14
        EXTERN GUI_Init
        EXTERN GUI_RefreshPage
        EXTERN GUI_SetBkColor
        EXTERN GUI_SetColor
        EXTERN GUI_SetFont
        EXTERN GUI_TOUCH_Exec
        EXTERN GUI_UC_SetEncodeNone
        EXTERN GUI_UC_SetEncodeUTF8
        EXTERN HAL_Delay
        EXTERN HAL_GPIO_ReadPin
        EXTERN HAL_GPIO_WritePin
        EXTERN HAL_GetTick
        EXTERN IsChooseAutoShutdown
        EXTERN SD_Init
        EXTERN SD_Path
        EXTERN Serial3
        EXTERN TEXT_SetDefaultFont
        EXTERN _Z10safe_delaym
        EXTERN _Z12wifi_loopingv
        EXTERN _Z14mksBeeperAlarmv
        EXTERN _Z17serial_echopair_PPKcS0_
        EXTERN _Z17serial_echopair_PPKcd
        EXTERN _Z17serial_echopair_PPKcf
        EXTERN _Z17serial_echopair_PPKci
        EXTERN _Z17serial_echopair_PPKcm
        EXTERN _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        EXTERN _Z21Close_machine_displayv
        EXTERN _Z22finish_incremental_LSFP15linear_fit_data
        EXTERN _Z23PowerOff_Filament_Checkv
        EXTERN _Z9gcode_G26v
        EXTERN _ZN10CardReader10removeFileEPc
        EXTERN _ZN10CardReader10reopenfileEPc
        EXTERN _ZN10CardReader11openLogFileEPc
        EXTERN _ZN10CardReader11stopSDPrintEv
        EXTERN _ZN10CardReader12checkFilesysEh
        EXTERN _ZN10CardReader12pauseSDPrintEv
        EXTERN _ZN10CardReader13write_commandEPc
        EXTERN _ZN10CardReader14checkautostartEb
        EXTERN _ZN10CardReader14startFileprintEv
        EXTERN _ZN10CardReader19printingHasFinishedEv
        EXTERN _ZN10CardReader2lsEv
        EXTERN _ZN10CardReader6initsdEv
        EXTERN _ZN10CardReader7releaseEv
        EXTERN _ZN10CardReader8getsdposEv
        EXTERN _ZN10CardReader8openFileEPcbb
        EXTERN _ZN10CardReader9closefileEb
        EXTERN _ZN10CardReader9getStatusEv
        EXTERN _ZN10CardReaderC1Ev
        EXTERN _ZN10USARTClass11MoremenuCmdEv
        EXTERN _ZN10USARTClass4readEv
        EXTERN _ZN10USARTClass5flushEv
        EXTERN _ZN10USARTClass5writeEh
        EXTERN _ZN10USARTClass9availableEv
        EXTERN _ZN10matrix_3x314create_look_atE8vector_3
        EXTERN _ZN10matrix_3x315set_to_identityEv
        EXTERN _ZN10matrix_3x35debugEPKc
        EXTERN _ZN10matrix_3x39transposeES_
        EXTERN _ZN11GCodeParser10string_argE
        EXTERN _ZN11GCodeParser11command_ptrE
        EXTERN _ZN11GCodeParser14command_letterE
        EXTERN _ZN11GCodeParser18volumetric_enabledE
        EXTERN _ZN11GCodeParser21unknown_command_errorEv
        EXTERN _ZN11GCodeParser5paramE
        EXTERN _ZN11GCodeParser5parseEPc
        EXTERN _ZN11GCodeParser7codenumE
        EXTERN _ZN11GCodeParser8codebitsE
        EXTERN _ZN11GCodeParser9value_ptrE
        EXTERN _ZN11Temperature12PID_autotuneEfaab
        EXTERN _ZN11Temperature13babystepsTodoE
        EXTERN _ZN11Temperature13manage_heaterEv
        EXTERN _ZN11Temperature16extrude_min_tempE
        EXTERN _ZN11Temperature18allow_cold_extrudeE
        EXTERN _ZN11Temperature18print_heaterstatesEv
        EXTERN _ZN11Temperature18start_watching_bedEv
        EXTERN _ZN11Temperature18target_temperatureE
        EXTERN _ZN11Temperature19current_temperatureE
        EXTERN _ZN11Temperature19disable_all_heatersEv
        EXTERN _ZN11Temperature19next_temp_report_msE
        EXTERN _ZN11Temperature21start_watching_heaterEh
        EXTERN _ZN11Temperature22target_temperature_bedE
        EXTERN _ZN11Temperature23current_temperature_bedE
        EXTERN _ZN11Temperature24auto_report_temperaturesEv
        EXTERN _ZN11Temperature25auto_report_temp_intervalE
        EXTERN _ZN11Temperature2KdE
        EXTERN _ZN11Temperature2KiE
        EXTERN _ZN11Temperature2KpE
        EXTERN _ZN11Temperature4initEv
        EXTERN _ZN11Temperature5bedKdE
        EXTERN _ZN11Temperature5bedKiE
        EXTERN _ZN11Temperature5bedKpE
        EXTERN _ZN14MarlinSettings15calc_num_meshesEv
        EXTERN _ZN14MarlinSettings4loadEv
        EXTERN _ZN14MarlinSettings4saveEv
        EXTERN _ZN14MarlinSettings5resetEv
        EXTERN _ZN14MarlinSettings6reportEb
        EXTERN _ZN14MarlinSettings9load_meshEaPv
        EXTERN _ZN17mesh_bed_leveling13index_to_xposE
        EXTERN _ZN17mesh_bed_leveling13index_to_yposE
        EXTERN _ZN17mesh_bed_leveling5resetEv
        EXTERN _ZN17mesh_bed_leveling8has_meshE
        EXTERN _ZN17mesh_bed_leveling8z_offsetE
        EXTERN _ZN17mesh_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_leveling11display_mapEi
        EXTERN _ZN20unified_bed_leveling12storage_slotE
        EXTERN _ZN20unified_bed_leveling13gcode_G29_UBLEv
        EXTERN _ZN20unified_bed_leveling19_mesh_index_to_xposE
        EXTERN _ZN20unified_bed_leveling19_mesh_index_to_yposE
        EXTERN _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        EXTERN _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        EXTERN _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        EXTERN _ZN20unified_bed_leveling5resetEv
        EXTERN _ZN20unified_bed_leveling8z_valuesE
        EXTERN _ZN20unified_bed_levelingC1Ev
        EXTERN _ZN5Print5printEPKc
        EXTERN _ZN5Print5printEdi
        EXTERN _ZN5Print5printEhi
        EXTERN _ZN5Print5printEii
        EXTERN _ZN5Print5printEli
        EXTERN _ZN7Planner11last_fade_zE
        EXTERN _ZN7Planner12accelerationE
        EXTERN _ZN7Planner13filament_sizeE
        EXTERN _ZN7Planner13z_fade_heightE
        EXTERN _ZN7Planner14apply_levelingERfS0_S0_
        EXTERN _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        EXTERN _ZN7Planner15flow_percentageE
        EXTERN _ZN7Planner15leveling_activeE
        EXTERN _ZN7Planner15set_position_mmE8AxisEnumRKf
        EXTERN _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        EXTERN _ZN7Planner16bed_level_matrixE
        EXTERN _ZN7Planner16unapply_levelingEPf
        EXTERN _ZN7Planner17axis_steps_per_mmE
        EXTERN _ZN7Planner17block_buffer_headE
        EXTERN _ZN7Planner17block_buffer_tailE
        EXTERN _ZN7Planner17max_feedrate_mm_sE
        EXTERN _ZN7Planner17min_feedrate_mm_sE
        EXTERN _ZN7Planner18autotemp_M104_M109Ev
        EXTERN _ZN7Planner19check_axes_activityEv
        EXTERN _ZN7Planner19min_segment_time_usE
        EXTERN _ZN7Planner19refresh_positioningEv
        EXTERN _ZN7Planner19travel_accelerationE
        EXTERN _ZN7Planner20retract_accelerationE
        EXTERN _ZN7Planner21inverse_z_fade_heightE
        EXTERN _ZN7Planner21volumetric_multiplierE
        EXTERN _ZN7Planner24min_travel_feedrate_mm_sE
        EXTERN _ZN7Planner24reset_acceleration_ratesEv
        EXTERN _ZN7Planner25set_position_mm_kinematicERA4_Kf
        EXTERN _ZN7Planner26max_acceleration_mm_per_s2E
        EXTERN _ZN7Planner29max_acceleration_steps_per_s2E
        EXTERN _ZN7Planner32calculate_volumetric_multipliersEv
        EXTERN _ZN7Planner8e_factorE
        EXTERN _ZN7Planner8max_jerkE
        EXTERN _ZN7Planner8positionE
        EXTERN _ZN7Stepper10quick_stopEv
        EXTERN _ZN7Stepper11synchronizeEv
        EXTERN _ZN7Stepper14locked_z_motorE
        EXTERN _ZN7Stepper15locked_z2_motorE
        EXTERN _ZN7Stepper16report_positionsEv
        EXTERN _ZN7Stepper17performing_homingE
        EXTERN _ZN7Stepper18finish_and_disableEv
        EXTERN _ZN7Stepper20get_axis_position_mmE8AxisEnum
        EXTERN _ZN7Stepper4initEv
        EXTERN _ZN8Endstops12report_stateEv
        EXTERN _ZN8Endstops15z_probe_enabledE
        EXTERN _ZN8Endstops16enabled_globallyE
        EXTERN _ZN8Endstops16endstop_hit_bitsE
        EXTERN _ZN8Endstops4M119Ev
        EXTERN _ZN8Endstops7enabledE
        EXTERN _ZN8vector_310get_normalEv
        EXTERN _ZN8vector_314apply_rotationE10matrix_3x3
        EXTERN _ZN8vector_35crossES_S_
        EXTERN _ZN8vector_3C1Efff
        EXTERN _ZN8vector_3miES_
        EXTERN _ZN9Stopwatch4stopEv
        EXTERN _ZN9Stopwatch5pauseEv
        EXTERN _ZN9Stopwatch5startEv
        EXTERN _ZN9Stopwatch7getTimeEPmS0_S0_
        EXTERN _ZN9Stopwatch8durationEv
        EXTERN _ZN9StopwatchC1Ev
        EXTERN __aeabi_cdrcmple
        EXTERN __aeabi_cfcmpeq
        EXTERN __aeabi_cfcmple
        EXTERN __aeabi_cfrcmple
        EXTERN __aeabi_d2f
        EXTERN __aeabi_d2iz
        EXTERN __aeabi_d2uiz
        EXTERN __aeabi_dadd
        EXTERN __aeabi_ddiv
        EXTERN __aeabi_dmul
        EXTERN __aeabi_dsub
        EXTERN __aeabi_f2d
        EXTERN __aeabi_f2iz
        EXTERN __aeabi_f2uiz
        EXTERN __aeabi_fadd
        EXTERN __aeabi_fdiv
        EXTERN __aeabi_fmul
        EXTERN __aeabi_fsub
        EXTERN __aeabi_i2d
        EXTERN __aeabi_i2f
        EXTERN __aeabi_memclr
        EXTERN __aeabi_memclr4
        EXTERN __aeabi_memcpy
        EXTERN __aeabi_memcpy4
        EXTERN __aeabi_memset
        EXTERN __aeabi_memset4
        EXTERN __aeabi_ui2d
        EXTERN __aeabi_ui2f
        EXTERN __iar_FDtest
        EXTERN __iar_FSin
        EXTERN __iar_Sin
        EXTERN __iar_Stod
        EXTERN __iar_Stolx
        EXTERN __iar_Stoul
        EXTERN __iar_Strchr
        EXTERN __iar_Strrchr
        EXTERN __iar_Strstr
        EXTERN atan2f
        EXTERN clear_cur_ui
        EXTERN curFileName
        EXTERN default_preview_flg
        EXTERN disp_pre_gcode
        EXTERN disp_state_stack
        EXTERN draw_dialog
        EXTERN draw_printing
        EXTERN draw_ready_print
        EXTERN draw_return_ui
        EXTERN echomagic
        EXTERN epr_read_data
        EXTERN epr_write_data
        EXTERN errormagic
        EXTERN espGcodeFifo
        EXTERN f_close
        EXTERN f_lseek
        EXTERN f_open
        EXTERN f_printf
        EXTERN f_read
        EXTERN filament_det1_cnt
        EXTERN filament_det1_flg
        EXTERN filament_det1_high_cnt
        EXTERN filament_det1_high_flg
        EXTERN filament_det1_low_cnt
        EXTERN filament_det1_low_flg
        EXTERN filament_det2_cnt
        EXTERN filament_det2_flg
        EXTERN filament_det2_high_cnt
        EXTERN filament_det2_high_flg
        EXTERN filament_det2_low_cnt
        EXTERN filament_det2_low_flg
        EXTERN filament_rate
        EXTERN flash_preview_begin
        EXTERN floor
        EXTERN floorf
        EXTERN free
        EXTERN from_flash_pic
        EXTERN gArrayGpioPin
        EXTERN gArrayGpioPort
        EXTERN gCfgItems
        EXTERN getTick
        EXTERN getTickDiff
        EXTERN gui_view_init
        EXTERN ipPara
        EXTERN key_value_calc
        EXTERN leveling_first_time
        EXTERN logo_tick1
        EXTERN logo_tick2
        EXTERN lroundf
        EXTERN malloc
        EXTERN memcmp
        EXTERN mksCfg
        EXTERN mksTmp
        EXTERN parser
        EXTERN pause_resum
        EXTERN poweroff_det_cnt
        EXTERN poweroff_det_flg
        EXTERN poweroff_det_high_cnt
        EXTERN poweroff_det_high_flg
        EXTERN poweroff_det_low_cnt
        EXTERN poweroff_det_low_flg
        EXTERN preview_gcode_prehandle
        EXTERN print_time
        EXTERN rand
        EXTERN reset_file_info
        EXTERN reset_print_time
        EXTERN sprintf
        EXTERN sqrt
        EXTERN sqrtf
        EXTERN start_print_time
        EXTERN stop_print_time
        EXTERN strcat
        EXTERN strcmp
        EXTERN strcpy
        EXTERN strncpy
        EXTERN temperature_change_frequency
        EXTERN thermalManager
        EXTERN tips_disp
        EXTERN wifiPara
        EXTERN wifi_check_time
        EXTERN wifi_link_state

        PUBLIC EXTI9_5_IRQHandler
        PUBLIC L1
        PUBLIC L2
        PUBLIC Running
        PUBLIC TimeIncrease
        PUBLIC _Z10freeMemoryv
        PUBLIC _Z10gcode_M104v
        PUBLIC _Z10gcode_M109v
        PUBLIC _Z10gcode_M140v
        PUBLIC _Z10gcode_M190v
        PUBLIC _Z10gcode_M290v
        PUBLIC _Z10gcode_M420v
        PUBLIC _Z10gcode_M428v
        PUBLIC _Z10lcd_reInitv
        PUBLIC _Z10ok_to_sendv
        PUBLIC _Z10servo_initv
        PUBLIC _Z11gcode_G2_G3b
        PUBLIC _Z11tool_changehfb
        PUBLIC _Z12ADJUST_DELTAPKf
        PUBLIC _Z13gcode_M18_M84v
        PUBLIC _Z13home_all_axesv
        PUBLIC _Z13home_z_safelyv
        PUBLIC _Z13setup_killpinv
        PUBLIC _Z14host_keepalivev
        PUBLIC _Z14mks_WriteToEprv
        PUBLIC _Z14serialprintPGMPKc
        PUBLIC _Z15_commit_commandb
        PUBLIC _Z15bltouch_commandi
        PUBLIC _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        PUBLIC _Z15mbl_mesh_reportv
        PUBLIC _Z15mks_setFeedratev
        PUBLIC _Z15reset_bed_levelv
        PUBLIC _Z15setup_powerholdv
        PUBLIC _Z16display_sd_errorv
        PUBLIC _Z16echo_not_enteredv
        PUBLIC _Z16gcode_line_errorPKcb
        PUBLIC _Z16mks_get_commandsv
        PUBLIC _Z17SCARA_move_to_calhh
        PUBLIC _Z17bilinear_z_offsetPKf
        PUBLIC _Z17get_wifi_commandsv
        PUBLIC _Z17leveling_is_validv
        PUBLIC _Z17manage_inactivityb
        PUBLIC _Z17mkstft_ui_set_eprv
        PUBLIC _Z17quickstop_stepperv
        PUBLIC _Z17refresh_bed_levelv
        PUBLIC _Z17set_z_fade_heightfb
        PUBLIC _Z17temper_error_killv
        PUBLIC _Z18axis_unhomed_errorbbb
        PUBLIC _Z18disable_e_steppersv
        PUBLIC _Z18inverse_kinematicsPKf
        PUBLIC _Z18mks_ResetPositionZf
        PUBLIC _Z18mks_leveling_moveZf
        PUBLIC _Z18mks_moveZ_relativef
        PUBLIC _Z18mks_setTemperaturev
        PUBLIC _Z18out_of_range_errorPKc
        PUBLIC _Z18set_probe_deployedb
        PUBLIC _Z18sync_plan_positionv
        PUBLIC _Z19clear_command_queuev
        PUBLIC _Z19do_blocking_move_toRKfS0_S0_S0_
        PUBLIC _Z19enable_all_steppersv
        PUBLIC _Z19get_sdcard_commandsv
        PUBLIC _Z19get_serial_commandsv
        PUBLIC _Z19mks_leveling_moveXYff
        PUBLIC _Z20SysTick_Handler_Userv
        PUBLIC _Z20disable_all_steppersv
        PUBLIC _Z20display_temper_errorv
        PUBLIC _Z20process_next_commandv
        PUBLIC _Z20set_bltouch_deployedb
        PUBLIC _Z21do_blocking_move_to_xRKfS0_
        PUBLIC _Z21do_blocking_move_to_zRKfS0_
        PUBLIC _Z21gcode_get_destinationv
        PUBLIC _Z21mks_WriteToEpr_pwroffv
        PUBLIC _Z21recalc_delta_settingsv
        PUBLIC _Z21soft_endstop_min_initv
        PUBLIC _Z22do_blocking_move_to_xyRKfS0_S0_
        PUBLIC _Z22get_available_commandsv
        PUBLIC _Z22mks_ReadFromEpr_pwroffv
        PUBLIC _Z22process_parsed_commandv
        PUBLIC _Z23report_current_positionv
        PUBLIC _Z24FlushSerialRequestResendv
        PUBLIC _Z24enqueue_and_echo_commandPKcb
        PUBLIC _Z24forward_kinematics_DELTAPf
        PUBLIC _Z24forward_kinematics_DELTAfff
        PUBLIC _Z24forward_kinematics_SCARARKfS0_
        PUBLIC _Z24mesh_line_to_destinationfhh
        PUBLIC _Z24set_bed_leveling_enabledb
        PUBLIC _Z24update_software_endstops8AxisEnum
        PUBLIC _Z25prepare_kinematic_move_toRA4_Kf
        PUBLIC _Z26buffer_line_to_destinationf
        PUBLIC _Z26clamp_to_software_endstopsPf
        PUBLIC _Z27enqueue_and_echo_commands_PPKc
        PUBLIC _Z27gcode_G29_MESH_BED_LEVELINGv
        PUBLIC _Z27get_cartesian_from_steppersv
        PUBLIC _Z27prepare_move_to_destinationv
        PUBLIC _Z28SYNC_PLAN_POSITION_KINEMATICv
        PUBLIC _Z28bilinear_line_to_destinationftt
        PUBLIC _Z28delta_safe_distance_from_topv
        PUBLIC _Z28gcode_M421_MESH_BED_LEVELINGv
        PUBLIC _Z31buffer_line_to_current_positionv
        PUBLIC _Z31inverse_kinematics_MORGAN_SCARAPKf
        PUBLIC _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        PUBLIC _Z32get_target_extruder_from_commandt
        PUBLIC _Z34position_is_reachable_IS_CARTESIANRKfS0_
        PUBLIC _Z34position_is_reachable_IS_KINEMATICRKfS0_
        PUBLIC _Z34set_current_from_steppers_for_axis8AxisEnum
        PUBLIC _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        PUBLIC _Z42prepare_uninterpolated_move_to_destinationf
        PUBLIC _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        PUBLIC _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        PUBLIC _Z4idlev
        PUBLIC _Z4killPKc
        PUBLIC _Z4stopv
        PUBLIC _Z5dwellm
        PUBLIC _Z6Beeperj
        PUBLIC _Z7mks_G28Pc
        PUBLIC _Z7pft_getv
        PUBLIC _Z7suicidev
        PUBLIC _Z8plan_arcRA4_KfRA2_S_b
        PUBLIC _Z8probe_ptRKfS0_bhb
        PUBLIC _Z9gcode_G28b
        PUBLIC _Z9gcode_G29v
        PUBLIC _Z9gcode_G42v
        PUBLIC _Z9gcode_G92v
        PUBLIC _Z9gcode_M24v
        PUBLIC _Z9gcode_M92v
        PUBLIC _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        PUBLIC _ZN11GCodeParser10value_byteEv
        PUBLIC _ZN11GCodeParser11value_floatEv
        PUBLIC _ZN11GCodeParser4seenEc
        PUBLIC _ZN11GCodeParser7seenvalEc
        PUBLIC _ZN11Temperature12setTargetBedEf
        PUBLIC _ZN11Temperature13babystep_axisE8AxisEnums
        PUBLIC _ZN17mesh_bed_leveling12cell_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling12cell_index_yERKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_xERKf
        PUBLIC _ZN17mesh_bed_leveling13probe_index_yERKf
        PUBLIC _ZN20unified_bed_leveling18mesh_index_to_xposEh
        PUBLIC _ZN20unified_bed_leveling18mesh_index_to_yposEh
        PUBLIC _ZN7Planner11buffer_lineEfffRKfS1_h
        PUBLIC _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        PUBLIC _ZNK10duration_t8toStringEPc
        PUBLIC _ZTI5Print
        PUBLIC _ZZ10gcode_M105vEs
        PUBLIC _ZZ10gcode_M109vEs_5
        PUBLIC _ZZ10gcode_M111vE11str_debug_1
        PUBLIC _ZZ10gcode_M111vE11str_debug_2
        PUBLIC _ZZ10gcode_M111vE11str_debug_4
        PUBLIC _ZZ10gcode_M111vE11str_debug_8
        PUBLIC _ZZ10gcode_M111vE12str_debug_16
        PUBLIC _ZZ10gcode_M111vE13debug_strings
        PUBLIC _ZZ10gcode_M111vEs_4
        PUBLIC _ZZ10gcode_M111vEs_5
        PUBLIC _ZZ10gcode_M112vEs
        PUBLIC _ZZ10gcode_M113vEs
        PUBLIC _ZZ10gcode_M115vEs
        PUBLIC _ZZ10gcode_M115vEs_0
        PUBLIC _ZZ10gcode_M115vEs_1
        PUBLIC _ZZ10gcode_M115vEs_2
        PUBLIC _ZZ10gcode_M115vEs_3
        PUBLIC _ZZ10gcode_M115vEs_4
        PUBLIC _ZZ10gcode_M115vEs_5
        PUBLIC _ZZ10gcode_M115vEs_6
        PUBLIC _ZZ10gcode_M115vEs_7
        PUBLIC _ZZ10gcode_M115vEs_8
        PUBLIC _ZZ10gcode_M115vEs_9
        PUBLIC _ZZ10gcode_M115vEs__10_
        PUBLIC _ZZ10gcode_M115vEs__11_
        PUBLIC _ZZ10gcode_M115vEs__12_
        PUBLIC _ZZ10gcode_M115vEs__13_
        PUBLIC _ZZ10gcode_M118vEs
        PUBLIC _ZZ10gcode_M190vEs_0
        PUBLIC _ZZ10gcode_M204vEs
        PUBLIC _ZZ10gcode_M204vEs_0
        PUBLIC _ZZ10gcode_M204vEs_1
        PUBLIC _ZZ10gcode_M204vEs_2
        PUBLIC _ZZ10gcode_M211vEs
        PUBLIC _ZZ10gcode_M211vEs_0
        PUBLIC _ZZ10gcode_M211vEs_1
        PUBLIC _ZZ10gcode_M211vEs_2
        PUBLIC _ZZ10gcode_M211vEs_3
        PUBLIC _ZZ10gcode_M211vEs_4
        PUBLIC _ZZ10gcode_M211vEs_5
        PUBLIC _ZZ10gcode_M211vEs_6
        PUBLIC _ZZ10gcode_M218vEs
        PUBLIC _ZZ10gcode_M280vEs
        PUBLIC _ZZ10gcode_M280vEs_0
        PUBLIC _ZZ10gcode_M280vEs_1
        PUBLIC _ZZ10gcode_M301vEs
        PUBLIC _ZZ10gcode_M301vEs_0
        PUBLIC _ZZ10gcode_M301vEs_1
        PUBLIC _ZZ10gcode_M301vEs_2
        PUBLIC _ZZ10gcode_M302vEs
        PUBLIC _ZZ10gcode_M302vEs_0
        PUBLIC _ZZ10gcode_M302vEs_1
        PUBLIC _ZZ10gcode_M302vEs_2
        PUBLIC _ZZ10gcode_M302vEs_3
        PUBLIC _ZZ10gcode_M303vEs
        PUBLIC _ZZ10gcode_M304vEs
        PUBLIC _ZZ10gcode_M304vEs_0
        PUBLIC _ZZ10gcode_M304vEs_1
        PUBLIC _ZZ10gcode_M355vEs
        PUBLIC _ZZ10gcode_M360vEs
        PUBLIC _ZZ10gcode_M361vEs
        PUBLIC _ZZ10gcode_M362vEs
        PUBLIC _ZZ10gcode_M363vEs
        PUBLIC _ZZ10gcode_M364vEs
        PUBLIC _ZZ10gcode_M420vEs
        PUBLIC _ZZ10gcode_M420vEs_0
        PUBLIC _ZZ10gcode_M420vEs_1
        PUBLIC _ZZ10gcode_M420vEs_2
        PUBLIC _ZZ10gcode_M420vEs_3
        PUBLIC _ZZ10gcode_M420vEs_4
        PUBLIC _ZZ10gcode_M420vEs_5
        PUBLIC _ZZ10gcode_M420vEs_6
        PUBLIC _ZZ10gcode_M420vEs_7
        PUBLIC _ZZ10gcode_M420vEs_8
        PUBLIC _ZZ10gcode_M420vEs_9
        PUBLIC _ZZ10gcode_M420vEs__10_
        PUBLIC _ZZ10gcode_M420vEs__11_
        PUBLIC _ZZ10gcode_M428vEs
        PUBLIC _ZZ10gcode_M851vEs
        PUBLIC _ZZ10gcode_M851vEs_0
        PUBLIC _ZZ10gcode_M851vEs_1
        PUBLIC _ZZ10home_deltavEs_0
        PUBLIC _ZZ11gcode_G2_G3bEs
        PUBLIC _ZZ13home_z_safelyvEs
        PUBLIC _ZZ13home_z_safelyvEs_0
        PUBLIC _ZZ15gcode_M666_dualvEs
        PUBLIC _ZZ15gcode_M666_dualvEs_0
        PUBLIC _ZZ17get_wifi_commandsvE16wifi_line_buffer
        PUBLIC _ZZ17get_wifi_commandsvE17wifi_comment_mode
        PUBLIC _ZZ17get_wifi_commandsvEs
        PUBLIC _ZZ17get_wifi_commandsvEs_1
        PUBLIC _ZZ17get_wifi_commandsvEs_2
        PUBLIC _ZZ17get_wifi_commandsvEs_3
        PUBLIC _ZZ17get_wifi_commandsvEs_4
        PUBLIC _ZZ18mod_zprobe_zoffsetRKfEs
        PUBLIC _ZZ19get_sdcard_commandsvE14stop_buffering
        PUBLIC _ZZ19get_sdcard_commandsvE15sd_comment_mode
        PUBLIC _ZZ19get_sdcard_commandsvEs
        PUBLIC _ZZ19get_sdcard_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvE14last_wait_time
        PUBLIC _ZZ19get_serial_commandsvE18serial_line_buffer
        PUBLIC _ZZ19get_serial_commandsvE19serial_comment_mode
        PUBLIC _ZZ19get_serial_commandsvEs
        PUBLIC _ZZ19get_serial_commandsvEs_0
        PUBLIC _ZZ19get_serial_commandsvEs_1
        PUBLIC _ZZ19get_serial_commandsvEs_2
        PUBLIC _ZZ19get_serial_commandsvEs_3
        PUBLIC _ZZ19get_serial_commandsvEs_5
        PUBLIC _ZZ19get_serial_commandsvEs_6
        PUBLIC _ZZ19get_serial_commandsvEs_7
        PUBLIC _ZZ19get_serial_commandsvEs_8
        PUBLIC _ZZ22invalid_extruder_errorhEs
        PUBLIC _ZZ24get_homing_bump_feedrate8AxisEnumEs
        PUBLIC _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
        PUBLIC _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        PUBLIC _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        PUBLIC _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
        PUBLIC _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
        PUBLIC _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
        PUBLIC _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
        PUBLIC _ZZ9gcode_G29vEs
        PUBLIC _ZZ9gcode_G29vEs_0
        PUBLIC _ZZ9gcode_G29vEs_1
        PUBLIC _ZZ9gcode_G29vEs_2
        PUBLIC _ZZ9gcode_G29vEs_3
        PUBLIC _ZZ9gcode_G29vEs_4
        PUBLIC _ZZ9gcode_G29vEs_5
        PUBLIC _ZZ9gcode_G29vEs_6
        PUBLIC _ZZ9gcode_G29vEs_7
        PUBLIC _ZZ9gcode_G29vEs_8
        PUBLIC _ZZ9gcode_G29vEs_9
        PUBLIC _ZZ9gcode_G29vEs__10_
        PUBLIC _ZZ9gcode_G29vEs__11_
        PUBLIC _ZZ9gcode_G29vEs__12_
        PUBLIC _ZZ9gcode_G29vEs__13_
        PUBLIC _ZZ9gcode_G29vEs__14_
        PUBLIC _ZZ9gcode_G29vEs__15_
        PUBLIC _ZZ9gcode_G29vEs__16_
        PUBLIC _ZZ9gcode_G29vEs__17_
        PUBLIC _ZZ9gcode_G29vEs__18_
        PUBLIC _ZZ9gcode_G30vEs
        PUBLIC _ZZ9gcode_G30vEs_0
        PUBLIC _ZZ9gcode_G30vEs_1
        PUBLIC _ZZ9gcode_G42vEs
        PUBLIC _ZZ9gcode_M20vEs
        PUBLIC _ZZ9gcode_M20vEs_0
        PUBLIC _ZZ9gcode_M31vEs
        PUBLIC _ZZ9gcode_M42vEs
        PUBLIC _ZZ9gcode_M49vEs
        PUBLIC _ZZ9gcode_M49vEs_0
        PUBLIC _ZZ9gcode_M49vEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs
        PUBLIC _ZZNK10duration_t8toStringEPcEs_0
        PUBLIC _ZZNK10duration_t8toStringEPcEs_1
        PUBLIC _ZZNK10duration_t8toStringEPcEs_2
        PUBLIC _ZZNK10duration_t8toStringEPcEs_3
        PUBLIC active_extruder
        PUBLIC axis_homed
        PUBLIC axis_known_position
        PUBLIC axis_relative_modes
        PUBLIC base_home_pos_P
        PUBLIC base_max_pos_P
        PUBLIC base_min_pos_P
        PUBLIC beep_cnt
        PUBLIC beep_flg
        PUBLIC bilinear_grid_factor
        PUBLIC bilinear_grid_spacing
        PUBLIC bilinear_start
        PUBLIC busy_state
        PUBLIC button_disp_pause_state
        PUBLIC card
        PUBLIC cartes
        PUBLIC cloud_refresh_flg
        PUBLIC commands_in_queue
        PUBLIC continue_print_error_flg
        PUBLIC current_position
        PUBLIC delta
        PUBLIC delta_calibration_radius
        PUBLIC delta_clip_start_height
        PUBLIC delta_diagonal_rod
        PUBLIC delta_diagonal_rod_2_tower
        PUBLIC delta_endstop_adj
        PUBLIC delta_height
        PUBLIC delta_radius
        PUBLIC delta_segments_per_second
        PUBLIC delta_tower
        PUBLIC delta_tower_angle_trim
        PUBLIC destination
        PUBLIC display_hold
        PUBLIC display_hold_cnt
        PUBLIC display_hold_release
        PUBLIC excute_m290
        PUBLIC excute_m500
        PUBLIC fanSpeeds
        PUBLIC feedrate_mm_s
        PUBLIC feedrate_percentage
        PUBLIC filament_heat_completed_load
        PUBLIC filament_heat_completed_unload
        PUBLIC filament_loading_completed
        PUBLIC filament_loading_time_cnt
        PUBLIC filament_loading_time_flg
        PUBLIC filament_unloading_completed
        PUBLIC filament_unloading_time_cnt
        PUBLIC filament_unloading_time_flg
        PUBLIC from_wifi_flag
        PUBLIC g26_debug_flag
        PUBLIC has_adjust_speed
        PUBLIC home_bump_mm_P
        PUBLIC home_dir_P
        PUBLIC home_offset
        PUBLIC homing_feedrate_mm_s
        PUBLIC host_keepalive_interval
        PUBLIC hotend_offset
        PUBLIC kill_c
        PUBLIC lcd_wait_for_move
        PUBLIC loop
        PUBLIC loop_start
        PUBLIC marlin_debug_flags
        PUBLIC max_length_P
        PUBLIC mksReprint
        PUBLIC mks_PrintStatePolling
        PUBLIC mks_ReadFromEpr
        PUBLIC mks_ReadFromFile
        PUBLIC mks_WriteToFile
        PUBLIC mks_adjust_extrude_speed
        PUBLIC mks_clearDir
        PUBLIC mks_clearFile
        PUBLIC mks_contiuePrintDelta
        PUBLIC mks_contiuePrintPause
        PUBLIC mks_contiuePrintPwdwn
        PUBLIC mks_contiuePrint_UI
        PUBLIC mks_getPositionXYZE
        PUBLIC mks_heating_busy
        PUBLIC mks_initPrint
        PUBLIC mks_manual_leveling
        PUBLIC mks_moveXY
        PUBLIC mks_moveZ
        PUBLIC mks_pausePrint
        PUBLIC mks_pft_name
        PUBLIC mks_preExtrude
        PUBLIC mks_rePrintCheck
        PUBLIC mks_resumePrint
        PUBLIC mks_resume_extrude_speed
        PUBLIC mks_saveFileName
        PUBLIC mks_setPositionZ
        PUBLIC mkstft_ui_init
        PUBLIC mkstft_ui_load
        PUBLIC position_shift
        PUBLIC preview_no_display
        PUBLIC previous_cmd_ms
        PUBLIC print_finish_close_machine
        PUBLIC print_finish_start_timer
        PUBLIC print_finish_timer_count
        PUBLIC print_job_timer
        PUBLIC printing_rate_update_flag
        PUBLIC resume_printed_time
        PUBLIC rgb888_2_rgb565
        PUBLIC saved_feedrate_percentage
        PUBLIC sd_read_cnt
        PUBLIC sd_read_error_flg
        PUBLIC serial_wait_tick
        PUBLIC setup
        PUBLIC soft_endstop_max
        PUBLIC soft_endstop_min
        PUBLIC soft_endstop_radius
        PUBLIC soft_endstop_radius_2
        PUBLIC soft_endstops_enabled
        PUBLIC t1
        PUBLIC t12
        PUBLIC t2
        PUBLIC target_extruder
        PUBLIC temper_error_flg
        PUBLIC temper_error_type
        PUBLIC ubl
        PUBLIC wait_for_heatup
        PUBLIC waiting_wifi_time
        PUBLIC wifi_init_flg
        PUBLIC wifi_init_state
        PUBLIC wifi_loop_cycle
        PUBLIC wifi_refresh_flg
        PUBLIC workspace_offset
        PUBLIC xy_probe_feedrate_mm_s
        PUBLIC z_endstop_adj
        PUBLIC z_high_count
        PUBLIC z_values
        PUBLIC zprobe_zoffset
        
          CFI Names cfiNames0
          CFI StackFrame CFA R13 DATA
          CFI Resource R0:32, R1:32, R2:32, R3:32, R4:32, R5:32, R6:32, R7:32
          CFI Resource R8:32, R9:32, R10:32, R11:32, R12:32, R13:32, R14:32
          CFI EndNames cfiNames0
        
          CFI Common cfiCommon0 Using cfiNames0
          CFI CodeAlign 2
          CFI DataAlign 4
          CFI ReturnAddress R14 CODE
          CFI CFA R13+0
          CFI R0 Undefined
          CFI R1 Undefined
          CFI R2 Undefined
          CFI R3 Undefined
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R12 Undefined
          CFI R14 SameValue
          CFI EndCommon cfiCommon0
        
// D:\MKS-Robin-Nano-Firmware-v2.x.x\MKS-Robin-Nano-Firmware\Middlewares\Third_Party\Marlin\Marlin_main.cpp
//    1 /**
//    2  * Marlin 3D Printer Firmware
//    3  * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
//    4  *
//    5  * Based on Sprinter and grbl.
//    6  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
//    7  *
//    8  * This program is free software: you can redistribute it and/or modify
//    9  * it under the terms of the GNU General Public License as published by
//   10  * the Free Software Foundation, either version 3 of the License, or
//   11  * (at your option) any later version.
//   12  *
//   13  * This program is distributed in the hope that it will be useful,
//   14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
//   15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//   16  * GNU General Public License for more details.
//   17  *
//   18  * You should have received a copy of the GNU General Public License
//   19  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
//   20  *
//   21  */
//   22 
//   23 /**
//   24  * About Marlin
//   25  *
//   26  * This firmware is a mashup between Sprinter and grbl.
//   27  *  - https://github.com/kliment/Sprinter
//   28  *  - https://github.com/simen/grbl/tree
//   29  */
//   30 
//   31 /**
//   32  * -----------------
//   33  * G-Codes in Marlin
//   34  * -----------------
//   35  *
//   36  * Helpful G-code references:
//   37  *  - http://linuxcnc.org/handbook/gcode/g-code.html
//   38  *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
//   39  *
//   40  * Help to document Marlin's G-codes online:
//   41  *  - http://reprap.org/wiki/G-code
//   42  *  - https://github.com/MarlinFirmware/MarlinDocumentation
//   43  *
//   44  * -----------------
//   45  *
//   46  * "G" Codes
//   47  *
//   48  * G0   -> G1
//   49  * G1   - Coordinated Movement X Y Z E
//   50  * G2   - CW ARC
//   51  * G3   - CCW ARC
//   52  * G4   - Dwell S<seconds> or P<milliseconds>
//   53  * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
//   54  * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
//   55  * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
//   56  * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
//   57  * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
//   58  * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
//   59  * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
//   60  * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
//   61  * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
//   62  * G26  - Mesh Validation Pattern (Requires G26_MESH_VALIDATION)
//   63  * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
//   64  * G28  - Home one or more axes
//   65  * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
//   66  * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
//   67  * G31  - Dock sled (Z_PROBE_SLED only)
//   68  * G32  - Undock sled (Z_PROBE_SLED only)
//   69  * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
//   70  * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
//   71  * G42  - Coordinated move to a mesh point (Requires MESH_BED_LEVELING, AUTO_BED_LEVELING_BLINEAR, or AUTO_BED_LEVELING_UBL)
//   72  * G90  - Use Absolute Coordinates
//   73  * G91  - Use Relative Coordinates
//   74  * G92  - Set current position to coordinates given
//   75  *
//   76  * "M" Codes
//   77  *
//   78  * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
//   79  * M1   -> M0
//   80  * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
//   81  * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
//   82  * M5   - Turn laser/spindle off
//   83  * M17  - Enable/Power all stepper motors
//   84  * M18  - Disable all stepper motors; same as M84
//   85  * M20  - List SD card. (Requires SDSUPPORT)
//   86  * M21  - Init SD card. (Requires SDSUPPORT)
//   87  * M22  - Release SD card. (Requires SDSUPPORT)
//   88  * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
//   89  * M24  - Start/resume SD print. (Requires SDSUPPORT)
//   90  * M25  - Pause SD print. (Requires SDSUPPORT)
//   91  * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
//   92  * M27  - Report SD print status. (Requires SDSUPPORT)
//   93  * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
//   94  * M29  - Stop SD write. (Requires SDSUPPORT)
//   95  * M30  - Delete file from SD: "M30 /path/file.gco"
//   96  * M31  - Report time since last M109 or SD card start to serial.
//   97  * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
//   98  *        Use P to run other files as sub-programs: "M32 P !filename#"
//   99  *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
//  100  * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
//  101  * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
//  102  * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
//  103  * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
//  104  * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
//  105  * M75  - Start the print job timer.
//  106  * M76  - Pause the print job timer.
//  107  * M77  - Stop the print job timer.
//  108  * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
//  109  * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
//  110  * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
//  111  * M82  - Set E codes absolute (default).
//  112  * M83  - Set E codes relative while in Absolute (G90) mode.
//  113  * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
//  114  *        duration after which steppers should turn off. S0 disables the timeout.
//  115  * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
//  116  * M92  - Set planner.axis_steps_per_mm for one or more axes.
//  117  * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
//  118  * M104 - Set extruder target temp.
//  119  * M105 - Report current temperatures.
//  120  * M106 - Set print fan speed.
//  121  * M107 - Print fan off.
//  122  * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
//  123  * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
//  124  *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
//  125  *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
//  126  * M110 - Set the current line number. (Used by host printing)
//  127  * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
//  128  * M112 - Emergency stop.
//  129  * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
//  130  * M114 - Report current position.
//  131  * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
//  132  * M117 - Display a message on the controller screen. (Requires an LCD)
//  133  * M118 - Display a message in the host console.
//  134  * M119 - Report endstops status.
//  135  * M120 - Enable endstops detection.
//  136  * M121 - Disable endstops detection.
//  137  * M122 - Debug stepper (Requires HAVE_TMC2130)
//  138  * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
//  139  * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
//  140  * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
//  141  * M128 - EtoP Open. (Requires BARICUDA)
//  142  * M129 - EtoP Closed. (Requires BARICUDA)
//  143  * M140 - Set bed target temp. S<temp>
//  144  * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
//  145  * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
//  146  * M150 - Set Status LED Color as R<red> U<green> B<blue> P<bright>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, NEOPIXEL_LED, or PCA9632).
//  147  * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
//  148  * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
//  149  * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
//  150  * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
//  151  * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
//  152  *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
//  153  * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
//  154  * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
//  155  * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
//  156  * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
//  157  * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
//  158  * M205 - Set advanced settings. Current units apply:
//  159             S<print> T<travel> minimum speeds
//  160             B<minimum segment time>
//  161             X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
//  162  * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  163  * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
//  164  * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
//  165  * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
//  166           Every normal extrude-only move will be classified as retract depending on the direction.
//  167  * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
//  168  * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
//  169  * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
//  170  * M221 - Set Flow Percentage: "M221 S<percent>"
//  171  * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
//  172  * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
//  173  * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
//  174  * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
//  175  * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
//  176  * M280 - Set servo position absolute: "M280 P<index> S<angle|Âµs>". (Requires servos)
//  177  * M290 - Babystepping (Requires BABYSTEPPING)
//  178  * M300 - Play beep sound S<frequency Hz> P<duration ms>
//  179  * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
//  180  * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
//  181  * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
//  182  * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
//  183  * M350 - Set microstepping mode. (Requires digital microstepping pins.)
//  184  * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
//  185  * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
//  186  * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
//  187  * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
//  188  * M400 - Finish all moves.
//  189  * M401 - Lower Z probe. (Requires a probe)
//  190  * M402 - Raise Z probe. (Requires a probe)
//  191  * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
//  192  * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
//  193  * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
//  194  * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
//  195  * M410 - Quickstop. Abort all planned moves.
//  196  * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
//  197  * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
//  198  * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
//  199  * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
//  200  * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
//  201  * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
//  202  * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
//  203  * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
//  204  * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
//  205  * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
//  206  * M666 - Set delta endstop adjustment. (Requires DELTA)
//  207  * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
//  208  * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
//  209  * M852 - Set skew factors: "M852 [I<xy>] [J<xz>] [K<yz>]". (Requires SKEW_CORRECTION_GCODE, and SKEW_CORRECTION_FOR_Z for IJ)
//  210  * M860 - Report the position of position encoder modules.
//  211  * M861 - Report the status of position encoder modules.
//  212  * M862 - Perform an axis continuity test for position encoder modules.
//  213  * M863 - Perform steps-per-mm calibration for position encoder modules.
//  214  * M864 - Change position encoder module I2C address.
//  215  * M865 - Check position encoder module firmware version.
//  216  * M866 - Report or reset position encoder module error count.
//  217  * M867 - Enable/disable or toggle error correction for position encoder modules.
//  218  * M868 - Report or set position encoder module error correction threshold.
//  219  * M869 - Report position encoder module error.
//  220  * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
//  221  * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  222  * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
//  223  * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
//  224  * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
//  225  * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
//  226  * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  227  * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130 or HAVE_TMC2208)
//  228  * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
//  229  * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
//  230  *
//  231  * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
//  232  * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
//  233  * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
//  234  * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
//  235  * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
//  236  *
//  237  * ************ Custom codes - This can change to suit future G-code regulations
//  238  * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
//  239  * M998	- Stop SD print. (Requires SDSUPPORT)
//  240  * M999 - Restart after being stopped by error
//  241  *
//  242  * "T" Codes
//  243  *
//  244  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
//  245  *
//  246  */
//  247 
//  248 #include "Marlin.h"
//  249 
//  250 #include "ultralcd.h"
//  251 #include "planner.h"
//  252 #include "stepper.h"
//  253 #include "endstops.h"
//  254 #include "temperature.h"
//  255 #include "cardreader.h"
//  256 #include "configuration_store.h"
//  257 #include "language.h"
//  258 //#include "pins_arduino.h"
//  259 #include "math.h"
//  260 #include "nozzle.h"
//  261 #include "duration_t.h"
//  262 //#include "types.h"
//  263 #include "tim.h"
//  264 #include "gcode.h"
//  265 
//  266 #include "least_squares_fit.h"
//  267 #include "ubl.h"
//  268 
//  269 #include "mks_cfg.h"
//  270 #include "mks_reprint.h"
//  271 
//  272 #if 1
//  273 
//  274 #include "wifi_module.h"
//  275 
//  276 #include "gui.h"
//  277 
//  278 #include "draw_ready_print.h"
//  279 
//  280 #include "draw_ui.h"
//  281 #include "wifi_module.h"
//  282 #include "draw_printing.h"
//  283 #include "draw_pause_ui.h"
//  284 #include "sdio_sdcard.h"
//  285 #include "draw_keyboard.h"
//  286 #include "draw_Tips.h"
//  287 #include "ili9320.h"
//  288 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  289 volatile uint8_t temper_error_flg = 0;
temper_error_flg:
        DS8 1
//  290 volatile uint8_t temper_error_type = 0;
temper_error_type:
        DS8 1
//  291 

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
//  292 volatile uint8_t mks_heating_busy = 0;
mks_heating_busy:
        DS8 1
//  293 
//  294 extern void PowerOff_Filament_Check();
//  295 extern void display_temper_error();
//  296 extern void Close_machine_display();
//  297 
//  298 extern uint8_t IsChooseAutoShutdown;
//  299 
//  300 extern uint8_t temperature_change_frequency;
//  301 
//  302 static uint32_t temperature_change_frequency_cnt = 0;
//  303 static uint32_t After_finish_print_time = 0;
//  304 
//  305 uint8_t filament_loading_time_flg;
//  306 uint32_t filament_loading_time_cnt;
//  307 uint8_t filament_loading_completed;
//  308 uint8_t filament_unloading_time_flg;
//  309 uint32_t filament_unloading_time_cnt;
//  310 uint8_t filament_unloading_completed;
//  311 
//  312 uint8_t filament_heat_completed_load;
//  313 uint8_t filament_heat_completed_unload;
//  314 
//  315 extern uint32_t filament_rate;
//  316 
//  317 
//  318 volatile uint32_t TimeIncrease;
//  319 uint8_t volatile printing_rate_update_flag;
//  320 uint8_t preview_no_display;
//  321 extern PRINT_TIME  print_time;
//  322 
//  323 extern uint8_t from_flash_pic;
//  324 volatile uint8_t loop_start=0;
//  325 #endif
//  326 
//  327 
//  328 #if 0
//  329 #if HAS_ABL
//  330   #include "vector_3.h"
//  331   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
//  332     #include "least_squares_fit.h"
//  333   #endif
//  334 #elif ENABLED(MESH_BED_LEVELING)
//  335   #include "mesh_bed_leveling.h"
//  336 #endif
//  337 #endif
//  338 #include "vector_3.h"
//  339 //#include "qr_solve.h"
//  340 #include "mesh_bed_leveling.h"
//  341 
//  342 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  343   #include "planner_bezier.h"
//  344 #endif
//  345 
//  346 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
//  347   #include "buzzer.h"
//  348 #endif
//  349 
//  350 #if ENABLED(USE_WATCHDOG)
//  351   #include "watchdog.h"
//  352 #endif
//  353 
//  354 #if ENABLED(MAX7219_DEBUG)
//  355   #include "Max7219_Debug_LEDs.h"
//  356 #endif
//  357 
//  358 #if HAS_COLOR_LEDS
//  359   #include "leds.h"
//  360 #endif
//  361 
//  362 #if HAS_SERVOS
//  363   #include "servo.h"
//  364 #endif
//  365 
//  366 #if HAS_DIGIPOTSS
//  367   #include <SPI.h>
//  368 #endif
//  369 
//  370 #if ENABLED(DAC_STEPPER_CURRENT)
//  371   #include "stepper_dac.h"
//  372 #endif
//  373 
//  374 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  375   #include "twibus.h"
//  376 #endif
//  377 
//  378 #if ENABLED(I2C_POSITION_ENCODERS)
//  379   #include "I2CPositionEncoder.h"
//  380 #endif
//  381 
//  382 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
//  383   #include "endstop_interrupts.h"
//  384 #endif
//  385 
//  386 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  387   void gcode_M100();
//  388   void M100_dump_routine(const char * const title, const char *start, const char *end);
//  389 #endif
//  390 
//  391 #if ENABLED(G26_MESH_VALIDATION)
//  392   bool g26_debug_flag; // =false
//  393   void gcode_G26();
//  394 #endif
//  395 
//  396 #if ENABLED(SDSUPPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock0 Using cfiCommon0
          CFI Function __sti__routine
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
//  397   CardReader card;
        LDR.W    R0,??DataTable119_3
          CFI FunCall _ZN10CardReaderC1Ev
        BL       _ZN10CardReaderC1Ev
//  398 #endif
//  399 
//  400 #if ENABLED(EXPERIMENTAL_I2CBUS)
//  401   TWIBus i2c;
//  402 #endif
//  403 
//  404 #if ENABLED(G38_PROBE_TARGET)
//  405   bool G38_move = false,
//  406        G38_endstop_hit = false;
//  407 #endif
//  408 
//  409 #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
//  410   #include "ubl.h"
//  411   extern bool defer_return_to_status;
//  412   unified_bed_leveling ubl;
        LDR.W    R4,??DataTable119_4
        ADD      R0,R4,#+112
          CFI FunCall _ZN20unified_bed_levelingC1Ev
        BL       _ZN20unified_bed_levelingC1Ev
        LDR.W    R0,??DataTable119_5
          CFI FunCall _ZN9StopwatchC1Ev
        BL       _ZN9StopwatchC1Ev
        LDR.W    R5,??DataTable119_6
        LDR.W    R1,??DataTable119_7  ;; 0x42700000
        LDR      R0,[R5, #+116]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R6,??DataTable120  ;; 0x43160000
        STR      R0,[R4, #+100]
        MOVS     R7,#+2
        LDR      R0,[R5, #+28]
        STR      R0,[R4, #+104]
        MOV      R8,#+1065353216
        B.N      ??__sti__routine_0
??__sti__routine_1:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??__sti__routine_0:
        LSLS     R0,R7,#+31
        BPL.N    ??__sti__routine_2
        MOV      R0,R8
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??__sti__routine_2:
        LSRS     R7,R7,#+1
        BNE.N    ??__sti__routine_1
        MOV      R0,#+1073741824
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+108]
        MOVS     R0,#+2
??__sti__routine_3:
        LSRS     R0,R0,#+1
        BNE.N    ??__sti__routine_3
        LDR      R0,[R5, #+8]
        LDR      R1,[R5, #+8]
        STR      R0,[R4, #+20]
        LDR      R0,[R5, #+12]
        STR      R0,[R4, #+24]
        LDR      R0,[R5, #+16]
        STR      R0,[R4, #+28]
        LDR      R0,[R5, #+20]
        STR      R0,[R4, #+32]
        LDR      R0,[R5, #+24]
        STR      R0,[R4, #+36]
        LDR      R0,[R5, #+28]
        STR      R0,[R4, #+40]
        LDR      R0,[R5, #+80]
        STR      R0,[R4, #+52]
        LDR      R0,[R5, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R5, #+12]
        STR      R0,[R4, #+56]
        LDR      R0,[R5, #+24]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R5, #+16]
        STR      R0,[R4, #+60]
        LDR      R0,[R5, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+64]
        LDRB     R0,[R5, #+5]
        STRB     R0,[R4, #+0]
        LDRB     R0,[R5, #+6]
        STRB     R0,[R4, #+1]
        LDRB     R0,[R5, #+7]
        STRB     R0,[R4, #+2]
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock0
//  413 #endif
//  414 
//  415 #if ENABLED(CNC_COORDINATE_SYSTEMS)
//  416   int8_t active_coordinate_system = -1; // machine space
//  417   float coordinate_system[MAX_COORDINATE_SYSTEMS][XYZ];
//  418 #endif
//  419 
//  420 bool Running = true;
//  421 
//  422 uint8_t marlin_debug_flags = DEBUG_NONE;
//  423 
//  424 /**
//  425  * Cartesian Current Position
//  426  *   Used to track the native machine position as moves are queued.
//  427  *   Used by 'buffer_line_to_current_position' to do a move after changing it.
//  428  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
//  429  */
//  430 float current_position[XYZE] = { 0.0 };
//  431 
//  432 /**
//  433  * Cartesian Destination
//  434  *   The destination for a move, filled in by G-code movement commands,
//  435  *   and expected by functions like 'prepare_move_to_destination'.
//  436  *   Set with 'gcode_get_destination' or 'set_destination_from_current'.
//  437  */
//  438 float destination[XYZE] = { 0.0 };
//  439 
//  440 /**
//  441  * axis_homed
//  442  *   Flags that each linear axis was homed.
//  443  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
//  444  *
//  445  * axis_known_position
//  446  *   Flags that the position is known in each linear axis. Set when homed.
//  447  *   Cleared whenever a stepper powers off, potentially losing its position.
//  448  */
//  449 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
//  450 
//  451 /**
//  452  * GCode line number handling. Hosts may opt to include line numbers when
//  453  * sending commands to Marlin, and lines will be checked for sequentiality.
//  454  * M110 N<int> sets the current line number.
//  455  */
//  456 static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
//  457 
//  458 /**
//  459  * GCode Command Queue
//  460  * A simple ring buffer of BUFSIZE command strings.
//  461  *
//  462  * Commands are copied into this buffer by the command injectors
//  463  * (immediate, serial, sd card) and they are processed sequentially by
//  464  * the main loop. The process_next_command function parses the next
//  465  * command and hands off execution to individual handler functions.
//  466  */
//  467 uint8_t commands_in_queue = 0; // Count of commands in the queue
//  468 static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
//  469                cmd_queue_index_w = 0; // Ring buffer write position
//  470 #if ENABLED(M100_FREE_MEMORY_WATCHER)
//  471   char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
//  472 #else                                         // This can be collapsed back to the way it was soon.
//  473 static char command_queue[BUFSIZE][MAX_CMD_SIZE];
//  474 #endif
//  475 
//  476 /**
//  477  * Next Injected Command pointer. NULL if no commands are being injected.
//  478  * Used by Marlin internally to ensure that commands initiated from within
//  479  * are enqueued ahead of any pending serial or sd card commands.
//  480  */
//  481 static const char *injected_commands_P = NULL;
//  482 
//  483 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
//  484   TempUnit input_temp_units = TEMPUNIT_C;
//  485 #endif
//  486 
//  487 /**
//  488  * Feed rates are often configured with mm/m
//  489  * but the planner and stepper like mm/s units.
//  490  */
//  491  /*
//  492 static const float homing_feedrate_mm_s[] PROGMEM = {
//  493   #if ENABLED(DELTA)
//  494     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
//  495   #else
//  496     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
//  497   #endif
//  498   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
//  499 };
//  500 
//  501 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
//  502 */
//  503 
//  504 float  homing_feedrate_mm_s[4];
//  505 
//  506 float feedrate_mm_s = MMM_TO_MMS(1500.0);
//  507 static float saved_feedrate_mm_s;
//  508 int16_t feedrate_percentage = 100, saved_feedrate_percentage;
//  509 
//  510 // Initialized by settings.load()
//  511 bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
//  512 
//  513 #if HAS_WORKSPACE_OFFSET
//  514   #if HAS_POSITION_SHIFT
//  515     // The distance that XYZ has been offset by G92. Reset by G28.
//  516     float position_shift[XYZ] = { 0 };
//  517   #endif
//  518   #if HAS_HOME_OFFSET
//  519     // This offset is added to the configured home position.
//  520     // Set by M206, M428, or menu item. Saved to EEPROM.
//  521     float home_offset[XYZ] = { 0 };
//  522   #endif
//  523   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
//  524     // The above two are combined to save on computes
//  525     float workspace_offset[XYZ] = { 0 };
//  526   #endif
//  527 #endif
//  528 
//  529 // Software Endstops are based on the configured limits.
//  530 /*
//  531 float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
//  532       soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
//  533 */
//  534 float soft_endstop_min[XYZ],soft_endstop_max[XYZ];

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock1 Using cfiCommon0
          CFI Function _Z21soft_endstop_min_initv
        THUMB
//  535 void soft_endstop_min_init()
//  536 {
_Z21soft_endstop_min_initv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
//  537     if(MACHINETPYE & IS_KINEMATIC)
        LDR.W    R5,??DataTable119_6
        LDR.W    R4,??DataTable120_1
        LDRH     R1,[R5, #+88]
        LDR      R0,[R5, #+20]
        MOVW     R2,#+770
        TST      R1,R2
        BEQ.N    ??soft_endstop_min_init_0
//  538     {
//  539         soft_endstop_min[0]= X_MIN_BED_IS_KINEMATIC;
        MOV      R6,#-1090519040
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+72]
//  540         soft_endstop_min[1]= Y_MIN_BED_IS_KINEMATIC;
        MOV      R1,R6
        LDR      R0,[R5, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
//  541         soft_endstop_min[2]= Z_MIN_POS;
//  542 
//  543         soft_endstop_max[0] = X_MAX_BED_IS_KINEMATIC;
        LDR      R1,[R5, #+20]
        STR      R0,[R4, #+76]
        LDR      R0,[R5, #+16]
        STR      R0,[R4, #+80]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+84]
//  544         soft_endstop_max[1] = Y_MAX_BED_IS_KINEMATIC;
        MOV      R0,#+1056964608
        LDR      R1,[R5, #+24]
        B.N      ??soft_endstop_min_init_1
//  545         soft_endstop_max[2] = Z_MAX_POS;
//  546     }
//  547     else
//  548     {
//  549         soft_endstop_min[0]= X_MIN_BED_IS_CARTESIAN;
??soft_endstop_min_init_0:
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
//  550         soft_endstop_min[1]= Y_MIN_BED_IS_CARTESIAN;
        LDR      R1,[R5, #+24]
        STR      R0,[R4, #+72]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+76]
//  551         soft_endstop_min[2]= Z_MIN_POS;
        LDR      R0,[R5, #+16]
//  552 
//  553         soft_endstop_max[0] = X_MAX_BED_IS_CARTESIAN;
        LDR      R1,[R5, #+20]
        STR      R0,[R4, #+80]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+84]
//  554         soft_endstop_max[1] = Y_MAX_BED_IS_CARTESIAN;
        MOV      R0,#+1056964608
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,#+1073741824
??soft_endstop_min_init_1:
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+88]
//  555         soft_endstop_max[2] = Z_MAX_POS;
        LDR      R0,[R5, #+28]
        STR      R0,[R4, #+92]
//  556     }        
//  557 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock1
//  558 
//  559 #if HAS_SOFTWARE_ENDSTOPS
//  560   bool soft_endstops_enabled = true;
//  561   #if 1// IS_KINEMATIC
//  562     float soft_endstop_radius, soft_endstop_radius_2;
//  563   #endif
//  564 #endif
//  565 
//  566 #if FAN_COUNT > 0
//  567   int fanSpeeds[FAN_COUNT] = { 0 };
//  568   #if ENABLED(EXTRA_FAN_SPEED)
//  569     int16_t old_fanSpeeds[FAN_COUNT],
//  570             new_fanSpeeds[FAN_COUNT];
//  571   #endif
//  572   #if ENABLED(PROBING_FANS_OFF)
//  573     bool fans_paused = false;
//  574     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
//  575   #endif
//  576 #endif
//  577 
//  578 // The active extruder (tool). Set with T<extruder> command.
//  579 uint8_t active_extruder = 0;
//  580 
//  581 // Relative Mode. Enable with G91, disable with G90.
//  582 static bool relative_mode = false;
//  583 
//  584 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
//  585 volatile bool wait_for_heatup = true;
//  586 
//  587 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
//  588 #if HAS_RESUME_CONTINUE
//  589   volatile bool wait_for_user = false;
//  590 #endif
//  591 
//  592 const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
//  593 
//  594 // Number of characters read in the current line of serial input
//  595 static int serial_count = 0;
//  596 static int wifi_read_count = 0;
//  597 
//  598 // Inactivity shutdown
//  599 millis_t previous_cmd_ms = 0;
//  600 static millis_t max_inactive_time = 0;
//  601 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
//  602 
//  603 // Print Job Timer
//  604 #if ENABLED(PRINTCOUNTER)
//  605   PrintCounter print_job_timer = PrintCounter();
//  606 #else
//  607   Stopwatch print_job_timer = Stopwatch();
//  608 #endif
//  609 
//  610 // Buzzer - I2C on the LCD or a BEEPER_PIN
//  611 #if ENABLED(LCD_USE_I2C_BUZZER)
//  612   #define BUZZ(d,f) lcd_buzz(d, f)
//  613 #elif PIN_EXISTS(BEEPER)
//  614   Buzzer buzzer;
//  615   #define BUZZ(d,f) buzzer.tone(d, f)
//  616 #else
//  617   #define BUZZ(d,f) NOOP
//  618 #endif
//  619 
//  620 uint8_t target_extruder;
//  621 
//  622 #if HAS_BED_PROBE
//  623   float zprobe_zoffset; // Initialized by settings.load()
//  624 #endif
//  625 
//  626 #if 1//HAS_ABL
//  627   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
//  628   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
//  629 #elif defined(XY_PROBE_SPEED)
//  630   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
//  631 #else
//  632   #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
//  633 #endif
//  634 
//  635 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  636 /*
//  637   #if ENABLED(DELTA)
//  638     #define ADJUST_DELTA(V) \ 
//  639       if (planner.leveling_active) { \ 
//  640         const float zadj = bilinear_z_offset(V); \ 
//  641         delta[A_AXIS] += zadj; \ 
//  642         delta[B_AXIS] += zadj; \ 
//  643         delta[C_AXIS] += zadj; \ 
//  644       }
//  645   #else
//  646     #define ADJUST_DELTA(V) if (planner.leveling_active) { delta[Z_AXIS] += bilinear_z_offset(V); }
//  647   #endif
//  648   */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock2 Using cfiCommon0
          CFI Function _Z12ADJUST_DELTAPKf
        THUMB
//  649 void  ADJUST_DELTA(const float logical[XYZ])
//  650 {
_Z12ADJUST_DELTAPKf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
//  651 	float zadj;
//  652 
//  653 	if(MACHINETPYE == DELTA)
        LDR.W    R2,??DataTable119_6
        LDR.W    R1,??DataTable120_2
        LDRSH    R2,[R2, #+88]
        LDRB     R1,[R1, #+0]
        CMP      R2,#+2
        BNE.N    ??ADJUST_DELTA_0
//  654 		{
//  655       	if (planner.leveling_active) { 
        CBZ.N    R1,??ADJUST_DELTA_1
//  656        	 	zadj = bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
//  657         	delta[A_AXIS] += zadj; 
        LDR.W    R5,??DataTable121
        MOV      R4,R0
        LDR      R0,[R5, #+60]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+60]
//  658        		delta[B_AXIS] += zadj; 
        MOV      R1,R4
        LDR      R0,[R5, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+64]
//  659         	delta[C_AXIS] += zadj; 
        MOV      R1,R4
        LDR      R0,[R5, #+68]
        B.N      ??ADJUST_DELTA_2
//  660       		}
//  661 		}
//  662 		else
//  663 			{
//  664 			if (planner.leveling_active) 
??ADJUST_DELTA_0:
        CBZ.N    R1,??ADJUST_DELTA_1
//  665 				 delta[Z_AXIS] += bilinear_z_offset(logical); 
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        LDR.W    R5,??DataTable121
        LDR      R1,[R5, #+68]
??ADJUST_DELTA_2:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+68]
//  666 			}
//  667 }  
??ADJUST_DELTA_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock2

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_homed:
        DATA
        DC8 0, 0, 0, 0
axis_known_position:
        DC8 0, 0, 0, 0
g26_debug_flag:
        DC8 0
//  668 //#elif IS_KINEMATIC
//  669 //  #define ADJUST_DELTA(V) NOOP
//  670 #endif
//  671 
//  672 #if ENABLED(X_DUAL_ENDSTOPS)
//  673   float x_endstop_adj;                // Initialized by settings.load()
//  674 #endif
//  675 #if ENABLED(Y_DUAL_ENDSTOPS)
//  676   float y_endstop_adj;                // Initialized by settings.load()
//  677 #endif
//  678 #if 1//ENABLED(Z_DUAL_ENDSTOPS)
//  679   float z_endstop_adj;                // Initialized by settings.load()
//  680 #endif
//  681 
//  682 // Extruder offsets
//  683 #if HOTENDS > 1
//  684   float hotend_offset[XYZ][HOTENDS];  // Initialized by settings.load()
//  685 #endif
//  686 
//  687 #if HAS_Z_SERVO_ENDSTOP
//  688   const int z_servo_angle[2] = Z_SERVO_ANGLES;
//  689 #endif
//  690 
//  691 #if ENABLED(BARICUDA)
//  692   uint8_t baricuda_valve_pressure = 0,
//  693           baricuda_e_to_p_pressure = 0;
//  694 #endif
//  695 
//  696 #if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
//  697   bool autoretract_enabled,                 // M209 S - Autoretract switch
//  698        retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
//  699   float retract_length,                     // M207 S - G10 Retract length
//  700         retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
//  701         retract_zlift,                      // M207 Z - G10 Retract hop size
//  702         retract_recover_length,             // M208 S - G11 Recover length
//  703         retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
//  704         swap_retract_length,                // M207 W - G10 Swap Retract length
//  705         swap_retract_recover_length,        // M208 W - G11 Swap Recover length
//  706         swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
//  707   #if EXTRUDERS > 1
//  708     bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
//  709   #else
//  710     constexpr bool retracted_swap[1] = { false };
//  711   #endif
//  712 #endif // FWRETRACT
//  713 
//  714 #if HAS_POWER_SWITCH
//  715   bool powersupply_on =
//  716     #if ENABLED(PS_DEFAULT_OFF)
//  717       false
//  718     #else
//  719       true
//  720     #endif
//  721   ;
//  722 #endif
//  723 
//  724 #if 1//ENABLED(DELTA)
//  725 
//  726   float delta[ABC];
//  727 
//  728   // Initialized by settings.load()
//  729   float delta_height,
//  730         delta_endstop_adj[ABC] = { 0 },
//  731         delta_radius,
//  732         delta_tower_angle_trim[ABC],
//  733         delta_tower[ABC][2],
//  734         delta_diagonal_rod,
//  735         delta_calibration_radius,
//  736         delta_diagonal_rod_2_tower[ABC],
//  737         delta_segments_per_second,
//  738         delta_clip_start_height = Z_MAX_POS;
//  739 
//  740   float delta_safe_distance_from_top();
//  741 
//  742 #endif
//  743 
//  744 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
//  745   int bilinear_grid_spacing[2], bilinear_start[2];
//  746   float bilinear_grid_factor[2],
//  747         //z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
//  748         z_values[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
//  749 #endif
//  750 
//  751 #if 1//IS_SCARA
//  752   // Float constants for SCARA calculations
//  753   const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
//  754               L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
//  755               L2_2 = sq(float(L2));
//  756 
//  757   //float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
//  758   //      delta[ABC];
//  759 #endif
//  760 
//  761 float cartes[XYZ] = { 0 };
//  762 
//  763 #if ENABLED(FILAMENT_WIDTH_SENSOR)
//  764   bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
//  765   float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
//  766         filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
//  767   uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM;                 // Distance delay setting
//  768   int8_t measurement_delay[MAX_MEASUREMENT_DELAY + 1],          // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
//  769          filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
//  770 #endif
//  771 
//  772 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
//  773   static bool filament_ran_out = false;
//  774 #endif
//  775 
//  776 #if ENABLED(ADVANCED_PAUSE_FEATURE)
//  777   AdvancedPauseMenuResponse advanced_pause_menu_response;
//  778 #endif
//  779 
//  780 #if ENABLED(MIXING_EXTRUDER)
//  781   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
//  782   #if MIXING_VIRTUAL_TOOLS > 1
//  783     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
//  784   #endif
//  785 #endif
//  786 
//  787 static bool send_ok[BUFSIZE];
//  788 
//  789 #if HAS_SERVOS
//  790   Servo servo[NUM_SERVOS];
//  791   #define MOVE_SERVO(I, P) servo[I].move(P)
//  792   #if HAS_Z_SERVO_ENDSTOP
//  793     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
//  794     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
//  795   #endif
//  796 #endif
//  797 
//  798 #ifdef CHDK
//  799   millis_t chdkHigh = 0;
//  800   bool chdkActive = false;
//  801 #endif
//  802 
//  803 #if ENABLED(PID_EXTRUSION_SCALING)
//  804   int lpq_len = 20;
//  805 #endif
//  806 
//  807 #if ENABLED(HOST_KEEPALIVE_FEATURE)
//  808   MarlinBusyState busy_state = NOT_BUSY;
busy_state:
        DC8 0
//  809   static millis_t next_busy_signal_ms = 0;
//  810   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
host_keepalive_interval:
        DC8 2
        DC8 0
delta_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0
hotend_offset:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0
delta:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta_tower_angle_trim:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
delta_diagonal_rod_2_tower:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC32 0
z_endstop_adj:
        DC8 0, 0, 0, 0
delta_endstop_adj:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
delta_radius:
        DC8 0, 0, 0, 0
delta_diagonal_rod:
        DC8 0, 0, 0, 0
delta_calibration_radius:
        DC8 0, 0, 0, 0
delta_segments_per_second:
        DC8 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
//  811 #else
//  812   #define host_keepalive() NOOP
//  813 #endif
//  814 
//  815 #if ENABLED(I2C_POSITION_ENCODERS)
//  816   I2CPositionEncodersMgr I2CPEM;
//  817   uint8_t blockBufferIndexRef = 0;
//  818   millis_t lastUpdateMillis;
//  819 #endif
//  820 
//  821 #if ENABLED(CNC_WORKSPACE_PLANES)
//  822   static WorkspacePlane workspace_plane = PLANE_XY;
//  823 #endif
//  824 
//  825 //FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
//  826 //FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
//  827 static inline float pgm_read_any(const float *p) { return (*(const float *)(p)); }
//  828 static inline signed char pgm_read_any(const signed char *p) { return (*(const signed char *)(p)); }
//  829 /*P
//  830 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  831   static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  832   static inline type array(const AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \ 
//  833   typedef void __void_##CONFIG##__
//  834 */
//  835 #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \ 
//  836 	  type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \ 
//  837 	  static inline type array(AxisEnum axis) { return (array##_P[axis]); } 
//  838 
//  839 XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
//  840 XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
//  841 XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
//  842 XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
//  843 XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
//  844 XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
home_dir_P:
        DATA
        DC8 0, 0, 0, 0
homing_feedrate_mm_s:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
base_min_pos_P:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
base_max_pos_P:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
base_home_pos_P:
        DC32 0H, 0H, 0H
max_length_P:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
home_bump_mm_P:
        DC32 40A00000H, 40A00000H, 40A00000H
position_shift:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_radius:
        DC8 0, 0, 0, 0
soft_endstop_radius_2:
        DC8 0, 0, 0, 0
xy_probe_feedrate_mm_s:
        DC8 0, 0, 0, 0
delta_clip_start_height:
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
ubl:
        DC8 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
axis_relative_modes:
        DATA
        DC8 0, 0, 0, 0
Running:
        DC8 1
marlin_debug_flags:
        DC8 0
commands_in_queue:
        DC8 0
        DC8 0
        DC8 0
soft_endstops_enabled:
        DC8 1
active_extruder:
        DC8 0
        DC8 0
wait_for_heatup:
        DC8 1
target_extruder:
        DC8 0
feedrate_percentage:
        DC16 100
current_position:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
destination:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
home_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
workspace_offset:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_min:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
soft_endstop_max:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
cartes:
        DC32 0H
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0
feedrate_mm_s:
        DC32 41C80000H
fanSpeeds:
        DC32 0
previous_cmd_ms:
        DC32 0
zprobe_zoffset:
        DC8 0, 0, 0, 0
delta_height:
        DC8 0, 0, 0, 0
print_job_timer:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
stepper_inactive_time:
        DATA
        DC32 120000
//  845 
//  846 /**
//  847  * ***************************************************************************
//  848  * ******************************** FUNCTIONS ********************************
//  849  * ***************************************************************************
//  850  */
//  851 
//  852 void stop();
//  853 
//  854 void get_available_commands();
//  855 void process_next_command();
//  856 void process_parsed_command();
//  857 
//  858 void get_cartesian_from_steppers();
//  859 void set_current_from_steppers_for_axis(const AxisEnum axis);
//  860 
//  861 #if ENABLED(ARC_SUPPORT)
//  862   void plan_arc(const float (&cart)[XYZE], const float (&offset)[2], const bool clockwise);
//  863 #endif
//  864 
//  865 #if ENABLED(BEZIER_CURVE_SUPPORT)
//  866   void plan_cubic_move(const float (&offset)[4]);
//  867 #endif
//  868 
//  869 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
//  870 void report_current_position();
//  871 void report_current_position_detail();
//  872 
//  873 #if ENABLED(DEBUG_LEVELING_FEATURE)
//  874   void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
//  875     serialprintPGM(prefix);
//  876     SERIAL_CHAR('(');
//  877     SERIAL_ECHO(x);
//  878     SERIAL_ECHOPAIR(", ", y);
//  879     SERIAL_ECHOPAIR(", ", z);
//  880     SERIAL_CHAR(')');
//  881     if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
//  882   }
//  883 
//  884   void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
//  885     print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
//  886   }
//  887 
//  888   #if 1//HAS_ABL
//  889     void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
//  890       print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
//  891     }
//  892   #endif
//  893 
//  894   #define DEBUG_POS(SUFFIX,VAR) do { \ 
//  895     print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
//  896 #endif
//  897 
//  898 /**
//  899  * sync_plan_position
//  900  *
//  901  * Set the planner/stepper positions directly from current_position with
//  902  * no kinematic translation. Used for homing axes and cartesian/core syncing.
//  903  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock3 Using cfiCommon0
          CFI Function _Z18sync_plan_positionv
        THUMB
//  904 void sync_plan_position() {
_Z18sync_plan_positionv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
//  905   #if ENABLED(DEBUG_LEVELING_FEATURE)
//  906     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
//  907   #endif
//  908   planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
        LDR.W    R4,??DataTable120_1
        LDR      R0,[R4, #+24]
        SUB      SP,SP,#+16
          CFI CFA R13+24
        MOVS     R2,#+46
        STR      R0,[SP, #+8]
        LDR      R0,[R4, #+20]
        STR      R0,[SP, #+4]
        LDR      R0,[R4, #+16]
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable119_6
        LDRB     R1,[R0, #+66]
        TST      R1,R2
        BEQ.N    ??sync_plan_position_0
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BNE.N    ??sync_plan_position_0
        ADD      R2,SP,#+8
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??sync_plan_position_0:
        ADD      R3,R4,#+28
        ADD      R2,SP,#+8
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner16_set_position_mmERKfS1_S1_S1_
        BL       _ZN7Planner16_set_position_mmERKfS1_S1_S1_
//  909 }
        ADD      SP,SP,#+16
          CFI CFA R13+8
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock3
//  910 inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
//  911 
//  912 //#if IS_KINEMATIC
//  913 
//  914   inline void sync_plan_position_kinematic() {
//  915     #if ENABLED(DEBUG_LEVELING_FEATURE)
//  916       if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
//  917     #endif
//  918     planner.set_position_mm_kinematic(current_position);
//  919   }
//  920 //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
//  921 
//  922 //#else
//  923 
//  924 //  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
//  925 
//  926 //#endif
//  927 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock4 Using cfiCommon0
          CFI Function _Z28SYNC_PLAN_POSITION_KINEMATICv
        THUMB
//  928 void SYNC_PLAN_POSITION_KINEMATIC()
//  929 {
//  930 	if(MACHINETPYE & IS_KINEMATIC)
_Z28SYNC_PLAN_POSITION_KINEMATICv:
        LDR.W    R0,??DataTable119_6
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        ITT      NE 
//  931 		sync_plan_position_kinematic();
        LDRNE.W  R0,??DataTable122
          CFI FunCall _ZN7Planner25set_position_mm_kinematicERA4_Kf
        BNE.W    _ZN7Planner25set_position_mm_kinematicERA4_Kf
//  932 	else
//  933 		sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        B.N      _Z18sync_plan_positionv
          CFI EndBlock cfiBlock4
//  934 }
//  935 
//  936 #if 0//ENABLED(SDSUPPORT)
//  937   #include "SdFatUtil.h"
//  938   int freeMemory() { return SdFatUtil::FreeRam(); }
//  939 #else
//  940 /*
//  941 extern "C" {
//  942   extern char __bss_end;
//  943   extern char __heap_start;
//  944   extern void* __brkval;
//  945 
//  946   int freeMemory() {
//  947     int free_memory;
//  948     if ((int)__brkval == 0)
//  949       free_memory = ((int)&free_memory) - ((int)&__bss_end);
//  950     else
//  951       free_memory = ((int)&free_memory) - ((int)__brkval);
//  952     return free_memory;
//  953   }
//  954 }
//  955 */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock5 Using cfiCommon0
          CFI Function _Z10freeMemoryv
          CFI NoCalls
        THUMB
//  956 	int freeMemory() { return 4396; }	//No free ram management
_Z10freeMemoryv:
        MOVW     R0,#+4396
        BX       LR               ;; return
          CFI EndBlock cfiBlock5
//  957 
//  958 #endif // !SDSUPPORT
//  959 
//  960 #if ENABLED(DIGIPOT_I2C)
//  961   extern void digipot_i2c_set_current(uint8_t channel, float current);
//  962   extern void digipot_i2c_init();
//  963 #endif
//  964 
//  965 /**
//  966  * Inject the next "immediate" command, when possible, onto the front of the queue.
//  967  * Return true if any immediate commands remain to inject.
//  968  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock6 Using cfiCommon0
          CFI Function _Z25drain_injected_commands_Pv
        THUMB
//  969 static bool drain_injected_commands_P() {
_Z25drain_injected_commands_Pv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
//  970   if (injected_commands_P != NULL) {
        LDR.W    R4,??DataTable122_1
        LDR      R1,[R4, #+4]
        SUB      SP,SP,#+32
          CFI CFA R13+48
        CBZ.N    R1,??drain_injected_commands_P_0
//  971     size_t i = 0;
        MOVS     R5,#+0
//  972     char c, cmd[30];
//  973     //strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
//  974     strncpy(cmd, injected_commands_P, sizeof(cmd) - 1);	/*--mks--*/
        MOVS     R2,#+29
        ADD      R0,SP,#+0
          CFI FunCall strncpy
        BL       strncpy
//  975     cmd[sizeof(cmd) - 1] = '\0';
        ADD      R0,SP,#+0
        ADD      R1,SP,#+0
        STRB     R5,[R0, #+29]
        B.N      ??drain_injected_commands_P_1
//  976     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
??drain_injected_commands_P_2:
        ADDS     R5,R5,#+1
??drain_injected_commands_P_1:
        LDRSB    R6,[R1], #+1
        CMP      R6,#+0
        IT       NE 
        CMPNE    R6,#+10
        BNE.N    ??drain_injected_commands_P_2
//  977     cmd[i] = '\0';
        MOVS     R1,#+0
        STRB     R1,[R5, R0]
//  978     if (enqueue_and_echo_command(cmd))     // success?
          CFI FunCall _Z24enqueue_and_echo_commandPKcb
        BL       _Z24enqueue_and_echo_commandPKcb
        CBZ.N    R0,??drain_injected_commands_P_3
//  979       injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
        CBZ.N    R6,??drain_injected_commands_P_4
        LDR      R0,[R4, #+4]
        ADDS     R0,R5,R0
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+4]
//  980   }
//  981   return (injected_commands_P != NULL);    // return whether any more remain
??drain_injected_commands_P_3:
        LDR      R0,[R4, #+4]
        CBZ.N    R0,??drain_injected_commands_P_0
        MOVS     R0,#+1
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}
          CFI CFA R13+48
??drain_injected_commands_P_4:
        MOVS     R0,#+0
        STR      R0,[R4, #+4]
??drain_injected_commands_P_0:
        MOVS     R0,#+0
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock6
//  982 }
//  983 
//  984 /**
//  985  * Record one or many commands to run from program memory.
//  986  * Aborts the current queue, if any.
//  987  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
//  988  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock7 Using cfiCommon0
          CFI Function _Z27enqueue_and_echo_commands_PPKc
        THUMB
//  989 void enqueue_and_echo_commands_P(const char * const pgcode) {
//  990   injected_commands_P = pgcode;
_Z27enqueue_and_echo_commands_PPKc:
        LDR.W    R1,??DataTable122_1
        STR      R0,[R1, #+4]
//  991   drain_injected_commands_P(); // first command executed asap (when possible)
          CFI FunCall _Z25drain_injected_commands_Pv
        B.N      _Z25drain_injected_commands_Pv
          CFI EndBlock cfiBlock7
//  992 }
//  993 
//  994 /**
//  995  * Clear the Marlin command queue
//  996  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock8 Using cfiCommon0
          CFI Function _Z19clear_command_queuev
          CFI NoCalls
        THUMB
//  997 void clear_command_queue() {
//  998   cmd_queue_index_r = cmd_queue_index_w;
_Z19clear_command_queuev:
        LDR.W    R0,??DataTable120_1
        LDRB     R1,[R0, #+8]
        STRB     R1,[R0, #+7]
//  999   commands_in_queue = 0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+6]
// 1000 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock8
// 1001 
// 1002 /**
// 1003  * Once a new command is in the ring buffer, call this to commit it
// 1004  */
// 1005 inline void _commit_command(bool say_ok) {
// 1006   send_ok[cmd_queue_index_w] = say_ok;
// 1007   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
// 1008   commands_in_queue++;
// 1009 }
// 1010 
// 1011 /**
// 1012  * Copy a command from RAM into the main command buffer.
// 1013  * Return true if the command was successfully added.
// 1014  * Return false for a full buffer, or if the 'command' is a comment.
// 1015  */
// 1016 inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
// 1017   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
// 1018   strcpy(command_queue[cmd_queue_index_w], cmd);
// 1019   _commit_command(say_ok);
// 1020   return true;
// 1021 }
// 1022 
// 1023 /**
// 1024  * Enqueue with Serial Echo
// 1025  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock9 Using cfiCommon0
          CFI Function _Z24enqueue_and_echo_commandPKcb
        THUMB
// 1026 bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
_Z24enqueue_and_echo_commandPKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1027   if (_enqueuecommand(cmd, say_ok)) {
        LDRSB    R0,[R4, #+0]
        CMP      R0,#+59
        BEQ.N    ??enqueue_and_echo_command_0
        LDR.W    R0,??DataTable120_1
        LDRB     R1,[R0, #+6]
        CMP      R1,#+4
        BGE.N    ??enqueue_and_echo_command_0
        LDRB     R0,[R0, #+8]
        ADD      R2,R0,R0, LSL #+1
        LDR.W    R0,??DataTable121_1
        MOV      R1,R4
        ADD      R0,R0,R2, LSL #+5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
// 1028     SERIAL_ECHO_START();
        LDR.W    R0,??DataTable121_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1029     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
        MOV      R1,R4
        LDR.W    R0,??DataTable121_3
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
// 1030     SERIAL_CHAR('"');
        LDR.W    R4,??DataTable121_4
        MOVS     R1,#+34
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1031     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1032     return true;
        MOVS     R0,#+1
        POP      {R1,R4,R5,PC}
// 1033   }
// 1034   return false;
??enqueue_and_echo_command_0:
        MOVS     R0,#+0
        POP      {R1,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock9
// 1035 }
// 1036 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock10 Using cfiCommon0
          CFI Function _Z13setup_killpinv
          CFI NoCalls
        THUMB
// 1037 void setup_killpin() {
// 1038   #if HAS_KILL
// 1039     SET_INPUT_PULLUP(KILL_PIN);
// 1040   #endif
// 1041 }
_Z13setup_killpinv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock10
// 1042 
// 1043 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 1044 
// 1045   void setup_filrunoutpin() {
// 1046     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
// 1047       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
// 1048     #else
// 1049       SET_INPUT(FIL_RUNOUT_PIN);
// 1050     #endif
// 1051   }
// 1052 
// 1053 #endif
// 1054 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock11 Using cfiCommon0
          CFI Function _Z15setup_powerholdv
          CFI NoCalls
        THUMB
// 1055 void setup_powerhold() {
// 1056   #if HAS_SUICIDE
// 1057     OUT_WRITE(SUICIDE_PIN, HIGH);
// 1058   #endif
// 1059   #if HAS_POWER_SWITCH
// 1060     #if ENABLED(PS_DEFAULT_OFF)
// 1061       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 1062     #else
// 1063       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
// 1064     #endif
// 1065   #endif
// 1066 }
_Z15setup_powerholdv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock11
// 1067 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock12 Using cfiCommon0
          CFI Function _Z7suicidev
          CFI NoCalls
        THUMB
// 1068 void suicide() {
// 1069   #if HAS_SUICIDE
// 1070     OUT_WRITE(SUICIDE_PIN, LOW);
// 1071   #endif
// 1072 }
_Z7suicidev:
        BX       LR               ;; return
          CFI EndBlock cfiBlock12
// 1073 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock13 Using cfiCommon0
          CFI Function _Z10servo_initv
          CFI NoCalls
        THUMB
// 1074 void servo_init() {
// 1075   #if NUM_SERVOS >= 1 && HAS_SERVO_0
// 1076     servo[0].attach(SERVO0_PIN);
// 1077     servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
// 1078   #endif
// 1079   #if NUM_SERVOS >= 2 && HAS_SERVO_1
// 1080     servo[1].attach(SERVO1_PIN);
// 1081     servo[1].detach();
// 1082   #endif
// 1083   #if NUM_SERVOS >= 3 && HAS_SERVO_2
// 1084     servo[2].attach(SERVO2_PIN);
// 1085     servo[2].detach();
// 1086   #endif
// 1087   #if NUM_SERVOS >= 4 && HAS_SERVO_3
// 1088     servo[3].attach(SERVO3_PIN);
// 1089     servo[3].detach();
// 1090   #endif
// 1091 
// 1092   #if HAS_Z_SERVO_ENDSTOP
// 1093     /**
// 1094      * Set position of Z Servo Endstop
// 1095      *
// 1096      * The servo might be deployed and positioned too low to stow
// 1097      * when starting up the machine or rebooting the board.
// 1098      * There's no way to know where the nozzle is positioned until
// 1099      * homing has been done - no homing with z-probe without init!
// 1100      *
// 1101      */
// 1102     STOW_Z_SERVO();
// 1103   #endif
// 1104 }
_Z10servo_initv:
        BX       LR               ;; return
          CFI EndBlock cfiBlock13
// 1105 
// 1106 /**
// 1107  * Stepper Reset (RigidBoard, et.al.)
// 1108  */
// 1109 #if HAS_STEPPER_RESET
// 1110   void disableStepperDrivers() {
// 1111     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
// 1112   }
// 1113   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
// 1114 #endif
// 1115 
// 1116 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 1117 
// 1118   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
// 1119     i2c.receive(bytes);
// 1120   }
// 1121 
// 1122   void i2c_on_request() {          // just send dummy data for now
// 1123     i2c.reply("Hello World!\n");
// 1124   }
// 1125 
// 1126 #endif
// 1127 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock14 Using cfiCommon0
          CFI Function _Z16gcode_line_errorPKcb
        THUMB
// 1128 void gcode_line_error(const char* err, bool doFlush = true) {
_Z16gcode_line_errorPKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 1129   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable121_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1130   serialprintPGM(err);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1131   SERIAL_ERRORLN(gcode_LastN);
        LDR.W    R0,??DataTable120_1
        LDR.W    R4,??DataTable121_4
        LDR      R1,[R0, #+108]
        MOVS     R2,#+10
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1132   //Serial.println(gcode_N);
// 1133   if (doFlush) FlushSerialRequestResend();
        CBZ.N    R5,??gcode_line_error_0
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
// 1134   serial_count = 0;
??gcode_line_error_0:
        LDR.W    R1,??DataTable123
        MOVS     R0,#+0
        STR      R0,[R1, #+8]
// 1135 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock14
// 1136 
// 1137 uint8_t serial_wait_tick = 0; //use to calculate the serial wait ticks
// 1138 
// 1139 uint8_t from_wifi_flag = 0; // whether data comes from wifi model
// 1140 
// 1141 /**
// 1142  * Get all commands waiting on the serial port and queue them.
// 1143  * Exit when the buffer is full or when no more characters are
// 1144  * left on the serial port.
// 1145  */
// 1146 inline void get_serial_commands() {
// 1147   static char serial_line_buffer[MAX_CMD_SIZE];
// 1148   static bool serial_comment_mode = false;
// 1149   static millis_t last_wait_time = 0;
// 1150   const millis_t wait_ms = millis();
// 1151 
// 1152   // If the command buffer is empty for too long,
// 1153   // send "wait" to indicate Marlin is still waiting.
// 1154   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1155     static millis_t last_command_time = 0;
// 1156     const millis_t ms = millis();
// 1157     if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
// 1158       SERIAL_ECHOLNPGM(MSG_WAIT);
// 1159       last_command_time = ms;
// 1160     }
// 1161   #endif
// 1162 #if 1
// 1163   
// 1164 	  /*5s?¡§?2a2?|¨¬?????¡§2¡§oy?Y?¡§¡ã¡§¡§??a??¡§?D¡§¡éa?¡§2?????¨º??¡§|¡§o1¡§??wifi*/
// 1165 	 if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(wait_ms, last_wait_time + 1000)) {
// 1166 		if(serial_wait_tick <= 5)
// 1167 	  {
// 1168 		  serial_wait_tick ++;
// 1169 	  }
// 1170 		last_wait_time = wait_ms;
// 1171 	  }
// 1172 #endif
// 1173 
// 1174   /**
// 1175    * Loop while serial characters are incoming and the queue is not full
// 1176    */
// 1177   int c;
// 1178   while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
// 1179 
// 1180     char serial_char = c;
// 1181 	
// 1182 	serial_wait_tick = 0;
// 1183 	from_wifi_flag = 0;
// 1184 
// 1185     /**
// 1186      * If the character ends the line
// 1187      */
// 1188     if (serial_char == '\n' || serial_char == '\r') {
// 1189 
// 1190       serial_comment_mode = false;                      // end of line == end of comment
// 1191 
// 1192       if (!serial_count) continue;                      // Skip empty lines
// 1193 
// 1194       serial_line_buffer[serial_count] = 0;             // Terminate string
// 1195       serial_count = 0;                                 // Reset buffer
// 1196 
// 1197       char* command = serial_line_buffer;
// 1198 
// 1199       while (*command == ' ') command++;                // Skip leading spaces
// 1200       char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
// 1201 
// 1202       if (npos) {
// 1203 
// 1204         bool M110 = strstr_P(command, PSTR("M110")) != NULL;
// 1205 
// 1206         if (M110) {
// 1207           char* n2pos = strchr(command + 4, 'N');
// 1208           if (n2pos) npos = n2pos;
// 1209         }
// 1210 
// 1211         gcode_N = strtol(npos + 1, NULL, 10);
// 1212 
// 1213         if (gcode_N != gcode_LastN + 1 && !M110) {
// 1214           gcode_line_error(PSTR(MSG_ERR_LINE_NO));
// 1215           return;
// 1216         }
// 1217 
// 1218         char *apos = strrchr(command, '*');
// 1219         if (apos) {
// 1220           uint8_t checksum = 0, count = uint8_t(apos - command);
// 1221           while (count) checksum ^= command[--count];
// 1222           if (strtol(apos + 1, NULL, 10) != checksum) {
// 1223             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
// 1224             return;
// 1225           }
// 1226         }
// 1227         else {
// 1228           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
// 1229           return;
// 1230         }
// 1231 
// 1232         gcode_LastN = gcode_N;
// 1233       }
// 1234 
// 1235       // Movement commands alert when stopped
// 1236       if (IsStopped()) {
// 1237         char* gpos = strchr(command, 'G');
// 1238         if (gpos) {
// 1239           const int codenum = strtol(gpos + 1, NULL, 10);
// 1240           switch (codenum) {
// 1241             case 0:
// 1242             case 1:
// 1243             case 2:
// 1244             case 3:
// 1245               SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1246               LCD_MESSAGEPGM(MSG_STOPPED);
// 1247               break;
// 1248           }
// 1249         }
// 1250       }
// 1251 
// 1252       #if DISABLED(EMERGENCY_PARSER)
// 1253         // If command was e-stop process now
// 1254         if (strcmp(command, "M108") == 0) {
// 1255           wait_for_heatup = false;
// 1256           #if ENABLED(ULTIPANEL)
// 1257             wait_for_user = false;
// 1258           #endif
// 1259         }
// 1260         if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1261         if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1262       #endif
// 1263 
// 1264       #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1265         last_command_time = ms;
// 1266       #endif
// 1267 
// 1268       // Add the command to the queue
// 1269       _enqueuecommand(serial_line_buffer, true);
// 1270     }
// 1271     else if (serial_count >= MAX_CMD_SIZE - 1) {
// 1272       // Keep fetching, but ignore normal characters beyond the max length
// 1273       // The command will be injected when EOL is reached
// 1274     }
// 1275     else if (serial_char == '\\') {  // Handle escapes
// 1276       if ((c = MYSERIAL.read()) >= 0) {
// 1277         // if we have one more character, copy it over
// 1278         serial_char = c;
// 1279         if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1280       }
// 1281       // otherwise do nothing
// 1282     }
// 1283     else { // it's not a newline, carriage return or escape char
// 1284       if (serial_char == ';') serial_comment_mode = true;
// 1285       if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1286     }
// 1287 
// 1288   } // queue has space, serial has data
// 1289 }
// 1290 
// 1291 #if ENABLED(SDSUPPORT)
// 1292 
// 1293 uint8_t sd_read_error_flg=0;
// 1294 uint8_t sd_read_cnt=0;
// 1295 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock15 Using cfiCommon0
          CFI Function _Z16display_sd_errorv
        THUMB
// 1296 void display_sd_error()
// 1297 {
_Z16display_sd_errorv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
// 1298   char buf_sd_err[30]={0};
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        MOV      R4,R1
        STM      R0!,{R1-R4}
        STM      R0!,{R1-R4}
// 1299   
// 1300   if(sd_read_error_flg == 1)
        LDR.W    R4,??DataTable121_6
        LDRB     R0,[R4, #+6]
        CMP      R0,#+1
        BNE.N    ??display_sd_error_0
// 1301   {
// 1302       GUI_SetBkColor(gCfgItems.background_color);
        LDR.W    R5,??DataTable121_7
        LDR      R0,[R5, #+20]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 1303       GUI_SetColor(0X0000ff);//   o¨¬¨¦?¡Á?¨¬?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 1304       //memset(buf_sd_err,' ',sizeof(buf_sd_err)-1);
// 1305       //GUI_DispStringAt(buf_sd_err,250, TITLE_YPOS);
// 1306       sprintf(buf_sd_err,"sd:%d",sd_read_cnt);
        LDRB     R2,[R4, #+7]
        LDR.W    R1,??DataTable123_1
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
// 1307       GUI_DispStringAt(buf_sd_err,400, TITLE_YPOS);
        MOVS     R2,#+5
        MOV      R1,#+400
        ADD      R0,SP,#+0
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 1308       GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+20]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 1309       GUI_SetColor(gCfgItems.title_color);            
        LDR      R0,[R5, #+24]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 1310   }
// 1311 }
??display_sd_error_0:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock15
// 1312 
// 1313 
// 1314   /**
// 1315    * Get commands from the SD Card until the command buffer is full
// 1316    * or until the end of the file is reached. The special character '#'
// 1317    * can also interrupt buffering.
// 1318    */
// 1319   inline void get_sdcard_commands() {
// 1320     static bool stop_buffering = false,
// 1321                 sd_comment_mode = false;
// 1322 
// 1323     if (!card.sdprinting) return;
// 1324 
// 1325     /**
// 1326      * '#' stops reading from SD to the buffer prematurely, so procedural
// 1327      * macro calls are possible. If it occurs, stop_buffering is triggered
// 1328      * and the buffer is run dry; this character _can_ occur in serial com
// 1329      * due to checksums, however, no checksums are used in SD printing.
// 1330      */
// 1331 
// 1332     if (commands_in_queue == 0) stop_buffering = false;
// 1333 
// 1334     uint16_t sd_count = 0;
// 1335     bool card_eof = card.eof();
// 1336     while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
// 1337       const int16_t n = card.get();
// 1338       char sd_char = (char)n;
// 1339       card_eof = card.eof();
// 1340       if (card_eof || n == -1
// 1341           || sd_char == '\n' || sd_char == '\r'
// 1342           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
// 1343       ) {
// 1344         if (card_eof) {
// 1345           gCfgItems.breakpoint_reprint_flg = 0;
// 1346           gCfgItems.breakpoint_z_pos = 0;
// 1347           gCfgItems.breakpoint_flg=0;
// 1348 
// 1349           card.printingHasFinished();
// 1350 
// 1351           if (card.sdprinting)
// 1352             sd_count = 0; // If a sub-file was printing, continue from call point
// 1353           else {
// 1354             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
// 1355             #if ENABLED(PRINTER_EVENT_LEDS)
// 1356               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
// 1357               leds.set_green();
// 1358               #if HAS_RESUME_CONTINUE
// 1359                 enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
// 1360               #else
// 1361                 safe_delay(1000);
// 1362               #endif
// 1363               leds.set_off();
// 1364             #endif
// 1365             card.checkautostart(true);
// 1366 			
// 1367 			#if 1
// 1368 			
// 1369 			
// 1370 			//¡ä¨°¨ª¨º1??¨²?¡ê
// 1371 			//if((gCfgItems.print_finish_close_machine_flg == 1)&&(IsChooseAutoShutdown==1))
// 1372 			//    Close_machine_display();
// 1373 
// 1374             #endif 				
// 1375           }
// 1376         }
// 1377         else if (n == -1) {
// 1378           SERIAL_ERROR_START();
// 1379           SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
// 1380           //sd_count++;
// 1381           //card.cardOK=false;
// 1382           //commands_in_queue+=1;
// 1383           //sdpos_bak=card.sdpos;
// 1384           //card.sdprinting=false;
// 1385           SD_Init();
// 1386           card.initsd();
// 1387           if(card.reopenfile(curFileName))
// 1388           {
// 1389             card.setIndex(card.sdpos);
// 1390           }
// 1391           memset(command_queue[cmd_queue_index_w],0,sizeof(command_queue[cmd_queue_index_w]));
// 1392           //GUI_TOUCH_Exec(); 	  
// 1393           //GUI_Exec();
// 1394          #if 1
// 1395 	  thermalManager.manage_heater();
// 1396 	  
// 1397 	  display_temper_error();
// 1398 	  
// 1399 	  //wifi_looping();
// 1400 	  
// 1401 	  if(wifi_link_state != WIFI_TRANS_FILE)
// 1402 	  {
// 1403 		  GUI_RefreshPage();
// 1404 	  }
// 1405 	  #if defined(TFT70)
// 1406 	  disp_pre_gcode(3,40);
// 1407 	  #elif defined(TFT35)
// 1408 	  //#if defined(MKS_ROBIN2)
// 1409 	  if(preview_no_display != 1)
// 1410 	  {
// 1411 		  disp_pre_gcode(2,36);
// 1412 	  }
// 1413 	  //#endif
// 1414 	  #endif
// 1415 	  
// 1416 	  GUI_TOUCH_Exec(); 	  
// 1417 	  GUI_Exec(); 
// 1418 
// 1419 	#endif
// 1420 
// 1421           sd_read_error_flg=1;
// 1422           sd_read_cnt++;
// 1423         }
// 1424         if (sd_char == '#') stop_buffering = true;
// 1425 
// 1426         sd_comment_mode = false; // for new command
// 1427 
// 1428         if (!sd_count) continue; // skip empty lines (and comment lines)
// 1429 
// 1430         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
// 1431         sd_count = 0; // clear sd line buffer
// 1432 
// 1433         _commit_command(false);
// 1434       }
// 1435       else if (sd_count >= MAX_CMD_SIZE - 1) {
// 1436         /**
// 1437          * Keep fetching, but ignore normal characters beyond the max length
// 1438          * The command will be injected when EOL is reached
// 1439          */
// 1440       }
// 1441       else {
// 1442         if (sd_char == ';') sd_comment_mode = true;
// 1443         //if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1444         if (!sd_comment_mode) 
// 1445         {
// 1446 			command_queue[cmd_queue_index_w][sd_count++] = sd_char;
// 1447 			if(sd_char == 0x5a ) //"Z"
// 1448 			{
// 1449 				mksReprint.sdpos = card.getsdpos()-3;	//"¡¤?2?????"
// 1450 				#if 1
// 1451 				mksReprint.sdpos_bak = mksReprint.sdpos;//sdpos_bak¦Ì?¨¨Y??¦Ì?¡ê????¡ä¨º1¨®?
// 1452 				if(gCfgItems.pwroff_save_mode != 1)//sd?¡§¡À¡ê¡ä???¦Ì?¨ºy?Y
// 1453                 #endif
// 1454 					mksReprint.refresh = true;
// 1455 			}
// 1456         }        
// 1457       }
// 1458     }
// 1459   }
// 1460 
// 1461 #endif // SDSUPPORT
// 1462 #if 1
// 1463 inline void get_wifi_commands() {
// 1464   static char wifi_line_buffer[MAX_CMD_SIZE];
// 1465   static bool wifi_comment_mode = false;
// 1466 
// 1467   if(serial_wait_tick > 5)
// 1468   {
// 1469   	from_wifi_flag = 1;
// 1470 
// 1471 /**
// 1472 	   * Loop while serial characters are incoming and the queue is not full
// 1473 	   */
// 1474 	  while ((commands_in_queue < BUFSIZE) && (espGcodeFifo.r != espGcodeFifo.w)) {
// 1475 
// 1476 	    char wifi_char = espGcodeFifo.Buffer[espGcodeFifo.r];
// 1477 
// 1478 	    espGcodeFifo.r = (espGcodeFifo.r + 1) % WIFI_GCODE_BUFFER_SIZE;
// 1479 
// 1480 	    /**
// 1481 	     * If the character ends the line
// 1482 	     */
// 1483 	    if (wifi_char == '\n' || wifi_char == '\r') {
// 1484 
// 1485 	      wifi_comment_mode = false; // end of line == end of comment
// 1486 
// 1487 	      if (!wifi_read_count) continue; // skip empty lines
// 1488 
// 1489 	      wifi_line_buffer[wifi_read_count] = 0; // terminate string
// 1490 	      wifi_read_count = 0; //reset buffer
// 1491 
// 1492 	      char* command = wifi_line_buffer;
// 1493 
// 1494 	      while (*command == ' ') command++; // skip any leading spaces	    
// 1495 
// 1496 	      // Movement commands alert when stopped
// 1497 	      if (IsStopped()) {
// 1498 	        char* gpos = strchr(command, 'G');
// 1499 	        if (gpos) {
// 1500 	          const int codenum = strtol(gpos + 1, NULL, 10);
// 1501 	          switch (codenum) {
// 1502 	            case 0:
// 1503 	            case 1:
// 1504 	            case 2:
// 1505 	            case 3:
// 1506 	              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
// 1507 	              LCD_MESSAGEPGM(MSG_STOPPED);
// 1508 	              break;
// 1509 	          }
// 1510 	        }
// 1511 	      }
// 1512 
// 1513 	      #if DISABLED(EMERGENCY_PARSER)
// 1514 	        // If command was e-stop process now
// 1515 	        if (strcmp(command, "M108") == 0) {
// 1516 	          wait_for_heatup = false;
// 1517 	          #if ENABLED(ULTIPANEL)
// 1518 	            wait_for_user = false;
// 1519 	          #endif
// 1520 	        }
// 1521 	        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
// 1522 	        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
// 1523 	      #endif
// 1524 
// 1525 	      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
// 1526 	        last_command_time = ms;
// 1527 	      #endif
// 1528 
// 1529 	      // Add the command to the queue
// 1530 	      _enqueuecommand(wifi_line_buffer, true);
// 1531 	    }
// 1532 	    else if (wifi_read_count >= MAX_CMD_SIZE - 1) {
// 1533 	      // Keep fetching, but ignore normal characters beyond the max length
// 1534 	      // The command will be injected when EOL is reached
// 1535 	    }
// 1536 		/*
// 1537 	    else if (wifi_char == '\\') {  // Handle escapes
// 1538 	      if (MYSERIAL.available() > 0) {
// 1539 	        // if we have one more character, copy it over
// 1540 	        wifi_char = MYSERIAL.read();
// 1541 	        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
// 1542 	      }
// 1543 	      // otherwise do nothing
// 1544 	    }*/
// 1545 	    else { // it's not a newline, carriage return or escape char
// 1546 	      if (wifi_char == ';') wifi_comment_mode = true;
// 1547 	      if (!wifi_comment_mode) wifi_line_buffer[wifi_read_count++] = wifi_char;
// 1548 	    }
// 1549 
// 1550 	  }
// 1551     }// queue has space, serial has data
// 1552     else
// 1553     {
// 1554     	from_wifi_flag = 0;
// 1555     }
// 1556 }
// 1557 #endif
// 1558 
// 1559 /**
// 1560  * Add to the circular command queue the next command from:
// 1561  *  - The command-injection queue (injected_commands_P)
// 1562  *  - The active serial input (usually USB)
// 1563  *  - The SD card file being actively printed
// 1564  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock16 Using cfiCommon0
          CFI Function _Z22get_available_commandsv
        THUMB
// 1565 void get_available_commands() {
_Z22get_available_commandsv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 1566 
// 1567   // if any immediate commands remain, don't get other commands yet
// 1568   if (drain_injected_commands_P()) return;
          CFI FunCall _Z25drain_injected_commands_Pv
        BL       _Z25drain_injected_commands_Pv
        CBNZ.N   R0,??get_available_commands_0
// 1569 
// 1570   get_serial_commands();
          CFI FunCall _Z19get_serial_commandsv
        BL       _Z19get_serial_commandsv
// 1571   
// 1572 #if 1
// 1573 	get_wifi_commands();
          CFI FunCall _Z17get_wifi_commandsv
        BL       _Z17get_wifi_commandsv
// 1574 #endif
// 1575 
// 1576   #if ENABLED(SDSUPPORT)
// 1577     get_sdcard_commands();
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z19get_sdcard_commandsv
        B.W      _Z19get_sdcard_commandsv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??get_available_commands_0:
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock16
// 1578   #endif
// 1579 }
// 1580 
// 1581 /**
// 1582  * Set target_extruder from the T parameter or the active_extruder
// 1583  *
// 1584  * Returns TRUE if the target is invalid
// 1585  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock17 Using cfiCommon0
          CFI Function _Z32get_target_extruder_from_commandt
        THUMB
// 1586 bool get_target_extruder_from_command(const uint16_t code) {
_Z32get_target_extruder_from_commandt:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
// 1587   if (parser.seenval('T')) {
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??DataTable122_2
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??get_target_extruder_from_command_0
// 1588     const int8_t e = parser.value_byte();
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SXTB     R5,R0
// 1589     if (e >= EXTRUDERS) {
        CMP      R5,#+2
        BLT.N    ??get_target_extruder_from_command_1
// 1590       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable121_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 1591       SERIAL_CHAR('M');
        LDR.W    R6,??DataTable121_4
        MOVS     R1,#+77
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1592       SERIAL_ECHO(code);
        MOVS     R2,#+10
        MOV      R1,R4
        MOV      R0,R6
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 1593       SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
        MOV      R1,R5
        LDR.W    R0,??DataTable122_3
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 1594       return true;
        MOVS     R0,#+1
        POP      {R4-R6,PC}
// 1595     }
// 1596     target_extruder = e;
// 1597   }
// 1598   else
// 1599     target_extruder = active_extruder;
??get_target_extruder_from_command_0:
        LDR.W    R0,??DataTable120_1
        LDRB     R5,[R0, #+10]
??get_target_extruder_from_command_1:
        LDR.W    R0,??DataTable120_1
        STRB     R5,[R0, #+13]
// 1600 
// 1601   return false;
        MOVS     R0,#+0
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock17
// 1602 }
// 1603 
// 1604 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 1605   bool extruder_duplication_enabled = false; // Used in Dual X mode 2
// 1606 #endif
// 1607 
// 1608 #if ENABLED(DUAL_X_CARRIAGE)
// 1609 
// 1610   static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 1611 
// 1612   static float x_home_pos(const int extruder) {
// 1613     if (extruder == 0)
// 1614       return base_home_pos(X_AXIS);
// 1615     else
// 1616       /**
// 1617        * In dual carriage mode the extruder offset provides an override of the
// 1618        * second X-carriage position when homed - otherwise X2_HOME_POS is used.
// 1619        * This allows soft recalibration of the second extruder home position
// 1620        * without firmware reflash (through the M218 command).
// 1621        */
// 1622       return hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS;
// 1623   }
// 1624 
// 1625   static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
// 1626 
// 1627   static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
// 1628   static bool active_extruder_parked = false;        // used in mode 1 & 2
// 1629   static float raised_parked_position[XYZE];         // used in mode 1
// 1630   static millis_t delayed_move_time = 0;             // used in mode 1
// 1631   static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
// 1632   static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
// 1633 
// 1634 #endif // DUAL_X_CARRIAGE
// 1635 
// 1636 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
// 1637 
// 1638   /**
// 1639    * Software endstops can be used to monitor the open end of
// 1640    * an axis that has a hardware endstop on the other end. Or
// 1641    * they can prevent axes from moving past endstops and grinding.
// 1642    *
// 1643    * To keep doing their job as the coordinate system changes,
// 1644    * the software endstop positions must be refreshed to remain
// 1645    * at the same positions relative to the machine.
// 1646    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock18 Using cfiCommon0
          CFI Function _Z24update_software_endstops8AxisEnum
        THUMB
// 1647   void update_software_endstops(const AxisEnum axis) {
_Z24update_software_endstops8AxisEnum:
        PUSH     {R2-R7,R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+32
        MOV      R6,R0
// 1648     #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
// 1649       workspace_offset[axis] = home_offset[axis] + position_shift[axis];
        LDR.W    R9,??DataTable119_4
        LDR.W    R5,??DataTable120_1
        ADD      R7,R9,R6, LSL #+2
        ADD      R4,R5,R6, LSL #+2
        LDR      R0,[R7, #+80]
        LDR      R1,[R4, #+48]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
// 1650     #endif
// 1651 
// 1652     #if ENABLED(DUAL_X_CARRIAGE)
// 1653       if (axis == X_AXIS) {
// 1654 
// 1655         // In Dual X mode hotend_offset[X] is T1's home position
// 1656         float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
// 1657 
// 1658         if (active_extruder != 0) {
// 1659           // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
// 1660           soft_endstop_min[X_AXIS] = X2_MIN_POS;
// 1661           soft_endstop_max[X_AXIS] = dual_max_x;
// 1662         }
// 1663         else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
// 1664           // In Duplication Mode, T0 can move as far left as X_MIN_POS
// 1665           // but not so far to the right that T1 would move past the end
// 1666           soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS);
// 1667           soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset);
// 1668         }
// 1669         else {
// 1670           // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
// 1671           soft_endstop_min[axis] = base_min_pos(axis);
// 1672           soft_endstop_max[axis] = base_max_pos(axis);
// 1673         }
// 1674       }
// 1675 	#else
// 1676     if (MACHINETPYE == DELTA)//ENABLED(DELTA)
        LDR.W    R1,??DataTable119_6
        STR      R0,[R4, #+60]
        LDRSH    R1,[R1, #+88]
        LDR      R0,[R7, #+20]
        STR      R0,[R4, #+72]
        CMP      R1,#+2
        BNE.N    ??update_software_endstops_0
// 1677     {
// 1678       soft_endstop_min[axis] = base_min_pos(axis);
// 1679       soft_endstop_max[axis] = axis == Z_AXIS ? delta_height : base_max_pos(axis);
        CMP      R6,#+2
        ITE      NE 
// 1680     }
        LDRNE    R0,[R7, #+32]
        LDREQ    R0,[R5, #+128]
        STR      R0,[R4, #+84]
// 1681     else
// 1682     {
// 1683       soft_endstop_min[axis] = base_min_pos(axis);
// 1684       soft_endstop_max[axis] = base_max_pos(axis);
// 1685     }
// 1686     #endif
// 1687 
// 1688     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1689       if (DEBUGGING(LEVELING)) {
// 1690         SERIAL_ECHOPAIR("For ", axis_codes[axis]);
// 1691         #if HAS_HOME_OFFSET
// 1692           SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
// 1693         #endif
// 1694         #if HAS_POSITION_SHIFT
// 1695           SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
// 1696         #endif
// 1697         SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
// 1698         SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
// 1699       }
// 1700     #endif
// 1701 
// 1702     //#if ENABLED(DELTA)
// 1703     if(MACHINETPYE == DELTA)
// 1704     {
// 1705       switch(axis) {
        CBZ.N    R6,??update_software_endstops_1
        CMP      R6,#+2
        BEQ.N    ??update_software_endstops_2
        BCS.N    ??update_software_endstops_3
// 1706         case X_AXIS:
// 1707         case Y_AXIS:
// 1708           // Get a minimum radius for clamping
// 1709           soft_endstop_radius = MIN3(FABS(max(soft_endstop_min[X_AXIS], soft_endstop_min[Y_AXIS])), soft_endstop_max[X_AXIS], soft_endstop_max[Y_AXIS]);
??update_software_endstops_1:
        LDR      R1,[R5, #+72]
        LDR      R0,[R5, #+76]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R1,R0
        B.N      ??update_software_endstops_4
??update_software_endstops_0:
        LDR      R0,[R7, #+32]
        STR      R0,[R4, #+84]
// 1710           soft_endstop_radius_2 = sq(soft_endstop_radius);
// 1711           break;
// 1712         case Z_AXIS:
// 1713           delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
// 1714         default: break;
// 1715       }
// 1716     }
// 1717     //#endif
// 1718   }
        POP      {R0,R1,R4-R7,R9,PC}
??update_software_endstops_4:
        BIC      R0,R1,#0x80000000
        LDR      R2,[R5, #+84]
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_5
        LDR      R1,[R5, #+72]
        LDR      R0,[R5, #+76]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R1,R0
        BIC      R2,R1,#0x80000000
??update_software_endstops_5:
        LDR      R1,[R5, #+88]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_6
        LDR      R1,[R5, #+72]
        LDR      R0,[R5, #+76]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R1,R0
        BIC      R0,R1,#0x80000000
        LDR      R1,[R5, #+84]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??update_software_endstops_6
        LDR      R1,[R5, #+72]
        LDR      R0,[R5, #+76]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R1,R0
        BIC      R1,R1,#0x80000000
??update_software_endstops_6:
        STR      R1,[R9, #+92]
        MOV      R5,R1
        MOVS     R6,#+2
        MOV      R7,#+1065353216
        B.N      ??update_software_endstops_7
??update_software_endstops_8:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??update_software_endstops_7:
        LSLS     R0,R6,#+31
        BPL.N    ??update_software_endstops_9
        MOV      R0,R7
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??update_software_endstops_9:
        LSRS     R6,R6,#+1
        BNE.N    ??update_software_endstops_8
        STR      R7,[R9, #+96]
        POP      {R0,R1,R4-R7,R9,PC}
??update_software_endstops_2:
          CFI FunCall _Z28delta_safe_distance_from_topv
        BL       _Z28delta_safe_distance_from_topv
        MOV      R1,R0
        LDR      R0,[R5, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R9, #+104]
??update_software_endstops_3:
        POP      {R0,R1,R4-R7,R9,PC}  ;; return
          CFI EndBlock cfiBlock18
// 1719 
// 1720 #endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
// 1721 
// 1722 #if 1//HAS_M206_COMMAND
// 1723   /**
// 1724    * Change the home offset for an axis, update the current
// 1725    * position and the software endstops to retain the same
// 1726    * relative distance to the new home.
// 1727    *
// 1728    * Since this changes the current_position, code should
// 1729    * call sync_plan_position soon after this.
// 1730    */
// 1731   static void set_home_offset(const AxisEnum axis, const float v) {
// 1732 
// 1733   	if(MACHINETPYE == DELTA)	return;
// 1734 	
// 1735     home_offset[axis] = v;
// 1736     update_software_endstops(axis);
// 1737   }
// 1738 #endif // HAS_M206_COMMAND
// 1739 
// 1740 /**
// 1741  * Set an axis' current position to its home position (after homing).
// 1742  *
// 1743  * For Core and Cartesian robots this applies one-to-one when an
// 1744  * individual axis has been homed.
// 1745  *
// 1746  * DELTA should wait until all homing is done before setting the XYZ
// 1747  * current_position to home, because homing is a single operation.
// 1748  * In the case where the axis positions are already known and previously
// 1749  * homed, DELTA could home to X or Y individually by moving either one
// 1750  * to the center. However, homing Z always homes XY and Z.
// 1751  *
// 1752  * SCARA should wait until all XY homing is done before setting the XY
// 1753  * current_position to home, because neither X nor Y is at home until
// 1754  * both are at home. Z can however be homed individually.
// 1755  *
// 1756  * Callers must sync the planner position after calling this!
// 1757  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock19 Using cfiCommon0
          CFI Function _Z19set_axis_is_at_home8AxisEnum
        THUMB
// 1758 static void set_axis_is_at_home(const AxisEnum axis) {
_Z19set_axis_is_at_home8AxisEnum:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R7,R0
// 1759   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1760     if (DEBUGGING(LEVELING)) {
// 1761       SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
// 1762       SERIAL_CHAR(')');
// 1763       SERIAL_EOL();
// 1764     }
// 1765   #endif
// 1766 
// 1767   axis_known_position[axis] = axis_homed[axis] = true;
        LDR.W    R4,??DataTable121
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOVS     R0,#+1
        STRB     R0,[R7, R4]
        ADDS     R1,R7,R4
// 1768 
// 1769   #if HAS_POSITION_SHIFT
// 1770     position_shift[axis] = 0;
        LDR.W    R6,??DataTable119_4
        STRB     R0,[R1, #+4]
        ADD      R5,R6,R7, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R5, #+80]
// 1771     update_software_endstops(axis);
        MOV      R0,R7
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 1772   #endif
// 1773 
// 1774   #if ENABLED(DUAL_X_CARRIAGE)
// 1775     if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
// 1776       current_position[X_AXIS] = x_home_pos(active_extruder);
// 1777       return;
// 1778     }
// 1779   #endif
// 1780 
// 1781   //#if ENABLED(MORGAN_SCARA)
// 1782   if(MACHINETPYE&MORGAN_SCARA)
        LDR.W    R8,??DataTable119_6
        LDRSH    R0,[R8, #+88]
        LSLS     R1,R0,#+23
        BPL.N    ??set_axis_is_at_home_0
// 1783   	{
// 1784     /**
// 1785      * Morgan SCARA homes XY at the same time
// 1786      */
// 1787     if (axis == X_AXIS || axis == Y_AXIS) {
        CMP      R7,#+0
        IT       NE 
        CMPNE    R7,#+1
        BNE.N    ??set_axis_is_at_home_1
// 1788 
// 1789       float homeposition[XYZ] = {
// 1790         base_home_pos(X_AXIS),
        LDR      R0,[R6, #+44]
        STR      R0,[SP, #+0]
// 1791         base_home_pos(Y_AXIS),
        LDR      R0,[R6, #+48]
        STR      R0,[SP, #+4]
// 1792         base_home_pos(Z_AXIS)
        LDR      R0,[R6, #+52]
        STR      R0,[SP, #+8]
// 1793       };
// 1794 
// 1795       // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
// 1796       // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
// 1797 
// 1798       /**
// 1799        * Get Home position SCARA arm angles using inverse kinematics,
// 1800        * and calculate homing offset using forward kinematics
// 1801        */
// 1802       inverse_kinematics_MORGAN_SCARA(homeposition);
        ADD      R0,SP,#+0
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
// 1803       forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
        ADD      R1,R4,#+64
        ADD      R0,R4,#+60
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 1804 
// 1805       // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
// 1806       // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
// 1807 
// 1808       current_position[axis] = cartes[axis];
        LDR.W    R4,??DataTable120_1
        ADD      R1,R4,R7, LSL #+2
        LDR      R0,[R1, #+96]
        STR      R0,[R1, #+16]
// 1809 
// 1810       /**
// 1811        * SCARA home positions are based on configuration since the actual
// 1812        * limits are determined by the inverse kinematic transform.
// 1813        */
// 1814       soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
        LDR      R0,[R5, #+20]
        STR      R0,[R1, #+72]
// 1815       soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
// 1816     }
        LDR      R0,[R5, #+32]
        STR      R0,[R1, #+84]
        B.N      ??set_axis_is_at_home_2
// 1817     else
// 1818 	{
// 1819 	    current_position[axis] = base_home_pos(axis);
// 1820 	}		
// 1821   	}
??set_axis_is_at_home_1:
        LDR      R0,[R5, #+44]
        LDR.W    R1,??DataTable120_1
        ADD      R1,R1,R7, LSL #+2
        B.N      ??set_axis_is_at_home_3
// 1822   //#elif ENABLED(DELTA)
// 1823   else if(MACHINETPYE&DELTA)
??set_axis_is_at_home_0:
        LDR.W    R4,??DataTable120_1
        ADD      R1,R4,R7, LSL #+2
        LSLS     R0,R0,#+30
        BPL.N    ??set_axis_is_at_home_4
// 1824   {
// 1825     if (axis == Z_AXIS)
        CMP      R7,#+2
        IT       EQ 
// 1826       current_position[axis] = delta_height;
        LDREQ    R0,[R4, #+128]
        BEQ.N    ??set_axis_is_at_home_3
// 1827     else
// 1828   //#endif
// 1829   	{
// 1830     	current_position[axis] = base_home_pos(axis);
// 1831   	}
// 1832   }
        LDR      R0,[R5, #+44]
        STR      R0,[R1, #+16]
// 1833   else
// 1834   {
// 1835     	current_position[axis] = base_home_pos(axis);
// 1836   }    
// 1837   /**
// 1838    * Z Probe Z Homing? Account for the probe's Z offset.
// 1839    */
// 1840   #if HAS_BED_PROBE //&& Z_HOME_DIR < 0
// 1841   if(Z_HOME_DIR < 0)
// 1842   {
// 1843     if (axis == Z_AXIS) {
// 1844       #if HOMING_Z_WITH_PROBE
// 1845 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 1846 	  {
// 1847         current_position[Z_AXIS] -= zprobe_zoffset;
// 1848 
// 1849         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1850           if (DEBUGGING(LEVELING)) {
// 1851             SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
// 1852             SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
// 1853           }
// 1854         #endif
// 1855 	  }
// 1856 	  //else
// 1857 	  //{
// 1858 		  //if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");	  
// 1859 	  //}
// 1860       #elif ENABLED(DEBUG_LEVELING_FEATURE)
// 1861 
// 1862         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
// 1863 
// 1864       #endif
// 1865     }
// 1866   }
// 1867   #endif
// 1868 
// 1869   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1870     if (DEBUGGING(LEVELING)) {
// 1871       #if HAS_HOME_OFFSET
// 1872         SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
// 1873         SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
// 1874       #endif
// 1875       DEBUG_POS("", current_position);
// 1876       SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
// 1877       SERIAL_CHAR(')');
// 1878       SERIAL_EOL();
// 1879     }
// 1880   #endif
// 1881 
// 1882   #if ENABLED(I2C_POSITION_ENCODERS)
// 1883     I2CPEM.homed(axis);
// 1884   #endif
// 1885 }
        B.N      ?Subroutine0
??set_axis_is_at_home_4:
        LDR      R0,[R5, #+44]
??set_axis_is_at_home_3:
        STR      R0,[R1, #+16]
??set_axis_is_at_home_2:
        LDRSB    R0,[R8, #+7]
        CMP      R0,#+0
        BPL.N    ??set_axis_is_at_home_5
        CMP      R7,#+2
        ITT      EQ 
        LDRBEQ   R0,[R8, #+153]
        CMPEQ    R0,#+1
        BNE.N    ??set_axis_is_at_home_5
        LDR.W    R4,??DataTable120_1
        LDR      R0,[R4, #+24]
        LDR      R1,[R4, #+124]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+24]
          CFI EndBlock cfiBlock19
??set_axis_is_at_home_5:
        REQUIRE ?Subroutine0
        ;; // Fall through to label ?Subroutine0

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock20 Using cfiCommon0
          CFI NoFunction
          CFI NoCalls _Z19set_axis_is_at_home8AxisEnum
          CFI NoCalls _Z17set_z_fade_heightfb
          CFI CFA R13+40
          CFI R4 Frame(CFA, -24)
          CFI R5 Frame(CFA, -20)
          CFI R6 Frame(CFA, -16)
          CFI R7 Frame(CFA, -12)
          CFI R8 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine0:
        ADD      SP,SP,#+16
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock20
// 1886 
// 1887 /**
// 1888  * Some planner shorthand inline functions
// 1889  */
// 1890 inline float get_homing_bump_feedrate(const AxisEnum axis) {
// 1891   //static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
// 1892 	int  homing_bump_divisor[4];
// 1893 	if(MACHINETPYE == DELTA)
// 1894 	{
// 1895 		homing_bump_divisor[0] = 10;
// 1896 		homing_bump_divisor[1] = 10;
// 1897 		homing_bump_divisor[2] = 10;
// 1898 	}
// 1899 	else
// 1900 	{
// 1901 		homing_bump_divisor[0] = 2;
// 1902 		homing_bump_divisor[1] = 2;
// 1903 		homing_bump_divisor[2] = 4;
// 1904 	}  
// 1905   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
// 1906   if (hbd < 1) {
// 1907     hbd = 10;
// 1908     SERIAL_ECHO_START();
// 1909     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
// 1910   }
// 1911   //return homing_feedrate(axis) / hbd;
// 1912   return homing_feedrate_mm_s[axis] / hbd;
// 1913 }
// 1914 
// 1915 /**
// 1916  * Move the planner to the current position from wherever it last moved
// 1917  * (or from wherever it has been told it is located).
// 1918  */
// 1919 inline void buffer_line_to_current_position() {
// 1920   planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
// 1921 }
// 1922 
// 1923 /**
// 1924  * Move the planner to the position stored in the destination array, which is
// 1925  * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
// 1926  */
// 1927 inline void buffer_line_to_destination(const float fr_mm_s) {
// 1928   planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
// 1929 }
// 1930 
// 1931 #if 1//IS_KINEMATIC
// 1932   /**
// 1933    * Calculate delta, start a line, and set current_position to destination
// 1934    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock21 Using cfiCommon0
          CFI Function _Z42prepare_uninterpolated_move_to_destinationf
        THUMB
// 1935   void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
_Z42prepare_uninterpolated_move_to_destinationf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 1936     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1937       if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
// 1938     #endif
// 1939 
// 1940     refresh_cmd_timeout();
        LDR.W    R5,??DataTable120_1
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
// 1941 
// 1942     #if UBL_SEGMENTED
// 1943       // ubl segmented line will do z-only moves in single segment
// 1944       ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
// 1945     #else
// 1946       if ( current_position[X_AXIS] == destination[X_AXIS]
// 1947         && current_position[Y_AXIS] == destination[Y_AXIS]
// 1948         && current_position[Z_AXIS] == destination[Z_AXIS]
// 1949         && current_position[E_AXIS] == destination[E_AXIS]
// 1950       ) return;
        LDR      R1,[R5, #+32]
        STR      R0,[R5, #+120]
        LDR      R0,[R5, #+16]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+20]
        LDR      R1,[R5, #+36]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+24]
        LDR      R1,[R5, #+40]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_uninterpolated_move_to_destination_0
        LDR      R0,[R5, #+28]
        LDR      R1,[R5, #+44]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_uninterpolated_move_to_destination_1
// 1951 
// 1952       planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
??prepare_uninterpolated_move_to_destination_0:
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        IT       EQ 
        LDREQ    R4,[R5, #+112]
        LDRSH    R0,[R5, #+14]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable125  ;; 0x47ae147b
        LDR.W    R3,??DataTable128  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDRB     R2,[R5, #+10]
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R5,#+32
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 1953     #endif
// 1954 
// 1955     set_current_from_destination();
        ADD      R0,R5,#+32
        ADD      R1,R5,#+16
        LDM      R0!,{R2-R5}
        STM      R1!,{R2-R5}
// 1956   }
??prepare_uninterpolated_move_to_destination_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock21
// 1957 #endif // IS_KINEMATIC
// 1958 
// 1959 /**
// 1960  *  Plan a move to (X, Y, Z) and set the current_position
// 1961  *  The final current_position may not be the one that was requested
// 1962  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock22 Using cfiCommon0
          CFI Function _Z19do_blocking_move_toRKfS0_S0_S0_
        THUMB
// 1963 void do_blocking_move_to(const float &rx, const float &ry, const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z19do_blocking_move_toRKfS0_S0_S0_:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R7,R3
        MOV      R4,R0
// 1964   const float old_feedrate_mm_s = feedrate_mm_s;
// 1965 
// 1966   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1967     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, LOGICAL_X_POSITION(rx), LOGICAL_Y_POSITION(ry), LOGICAL_Z_POSITION(rz));
// 1968   #endif
// 1969 
// 1970   const float z_feedrate = fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[Z_AXIS];
        LDR      R10,[R7, #+0]
        LDR.W    R8,??DataTable120_1
        LDR      R9,[R8, #+112]
        MOV      R5,R1
        MOV      R0,R10
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        MOV      R6,R2
        ITT      EQ 
        LDREQ.W  R0,??DataTable119_4
        LDREQ    R10,[R0, #+12]
        LDR.W    R0,??DataTable119_6
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+2
        BNE.N    ??do_blocking_move_to_0
// 1971 
// 1972   //#if ENABLED(DELTA)
// 1973   if(MACHINETPYE == DELTA)
// 1974   {
// 1975     if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.W    ??do_blocking_move_to_1
// 1976 
// 1977     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
        LDR      R3,[R7, #+0]
        MOV      R0,R3
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        LDR.W    R2,??DataTable119_4
        IT       EQ 
        LDREQ    R3,[R2, #+100]
        STR      R3,[R8, #+112]
// 1978 
// 1979     set_destination_from_current();          // sync destination at the start
        ADD      R0,R8,#+16
        LDM      R0!,{R3,R7,R12,LR}
        ADD      R1,R8,#+32
        STM      R1!,{R3,R7,R12,LR}
// 1980 
// 1981     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1982       if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_from_current", destination);
// 1983     #endif
// 1984 
// 1985     // when in the danger zone
// 1986     if (current_position[Z_AXIS] > delta_clip_start_height) {
        LDR      R0,[R2, #+104]
        MOV      R1,R12
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_2
// 1987       if (rz > delta_clip_start_height) {   // staying in the danger zone
        LDR      R1,[R6, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_3
// 1988         destination[X_AXIS] = rx;           // move directly (uninterpolated)
        LDR      R0,[R4, #+0]
        STR      R0,[R8, #+32]
// 1989         destination[Y_AXIS] = ry;
        LDR      R0,[R5, #+0]
        STR      R0,[R8, #+36]
// 1990         destination[Z_AXIS] = rz;
        LDR      R0,[R6, #+0]
        STR      R0,[R8, #+40]
// 1991         prepare_uninterpolated_move_to_destination(); // set_current_from_destination
        MOVS     R0,#+0
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.N      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
// 1992         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 1993           if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
// 1994         #endif
// 1995         return;
// 1996       }
// 1997       destination[Z_AXIS] = delta_clip_start_height;
??do_blocking_move_to_3:
        STR      R0,[R8, #+40]
// 1998       prepare_uninterpolated_move_to_destination(); // set_current_from_destination
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 1999       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2000         if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
// 2001       #endif
// 2002     }
// 2003 
// 2004     if (rz > current_position[Z_AXIS]) {    // raising?
??do_blocking_move_to_2:
        LDR      R1,[R6, #+0]
        LDR      R0,[R8, #+24]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_4
// 2005       destination[Z_AXIS] = rz;
        STR      R1,[R8, #+40]
// 2006       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2007       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2008         if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
// 2009       #endif
// 2010     }
// 2011 
// 2012     destination[X_AXIS] = rx;
??do_blocking_move_to_4:
        LDR      R0,[R4, #+0]
        STR      R0,[R8, #+32]
// 2013     destination[Y_AXIS] = ry;
        LDR      R0,[R5, #+0]
        STR      R0,[R8, #+36]
// 2014     prepare_move_to_destination();         // set_current_from_destination
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 2015     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2016       if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
// 2017     #endif
// 2018 
// 2019     if (rz < current_position[Z_AXIS]) {    // lowering?
        LDR      R0,[R6, #+0]
        LDR      R1,[R8, #+24]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_5
        B.N      ??do_blocking_move_to_6
// 2020       destination[Z_AXIS] = rz;
// 2021       prepare_uninterpolated_move_to_destination(z_feedrate);   // set_current_from_destination
// 2022       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2023         if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
// 2024       #endif
// 2025     }
// 2026   }
// 2027   //#elif IS_SCARA
// 2028   else if(MACHINETPYE&IS_SCARA) {
??do_blocking_move_to_0:
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??do_blocking_move_to_7
// 2029 
// 2030     if (!position_is_reachable_IS_KINEMATIC(rx, ry)) return;
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??do_blocking_move_to_1
// 2031 
// 2032     set_destination_from_current();
        ADD      R0,R8,#+16
        LDM      R0!,{R2,R3,R12,LR}
        ADD      R1,R8,#+32
// 2033 
// 2034     // If Z needs to raise, do it before moving XY
// 2035     if (destination[Z_AXIS] < rz) {
        MOV      R0,R12
        STM      R1!,{R2,R3,R12,LR}
        LDR      R1,[R6, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_8
// 2036       destination[Z_AXIS] = rz;
        STR      R1,[R8, #+40]
// 2037       prepare_uninterpolated_move_to_destination(z_feedrate);
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2038     }
// 2039 
// 2040     destination[X_AXIS] = rx;
??do_blocking_move_to_8:
        LDR      R0,[R4, #+0]
        STR      R0,[R8, #+32]
// 2041     destination[Y_AXIS] = ry;
// 2042     prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
        MOVS     R1,#+0
        LDR      R0,[R5, #+0]
        STR      R0,[R8, #+36]
        LDR      R2,[R7, #+0]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        ITT      EQ 
        LDREQ.W  R0,??DataTable119_4
        LDREQ    R2,[R0, #+100]
        MOV      R0,R2
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
// 2043 
// 2044     // If Z needs to lower, do it after moving XY
// 2045     if (destination[Z_AXIS] > rz) {
        LDR      R0,[R6, #+0]
        LDR      R1,[R8, #+40]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_5
// 2046       destination[Z_AXIS] = rz;
??do_blocking_move_to_6:
        LDR      R0,[R6, #+0]
        STR      R0,[R8, #+40]
// 2047       prepare_uninterpolated_move_to_destination(z_feedrate);
        MOV      R0,R10
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
        B.N      ??do_blocking_move_to_5
// 2048     }
// 2049   }
// 2050   //#else
// 2051   else
// 2052   {
// 2053     // If Z needs to raise, do it before moving XY
// 2054     if (current_position[Z_AXIS] < rz) {
??do_blocking_move_to_7:
        LDR      R0,[R8, #+24]
        LDR      R1,[R6, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_9
// 2055       feedrate_mm_s = z_feedrate;
        STR      R10,[R8, #+112]
// 2056       current_position[Z_AXIS] = rz;
        LDR      R0,[R6, #+0]
        STR      R0,[R8, #+24]
// 2057       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2058     }
// 2059 
// 2060     feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
??do_blocking_move_to_9:
        MOVS     R1,#+0
        LDR      R2,[R7, #+0]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        ITT      EQ 
        LDREQ.N  R0,??DataTable119_4
        LDREQ    R2,[R0, #+100]
        STR      R2,[R8, #+112]
// 2061     current_position[X_AXIS] = rx;
        LDR      R0,[R4, #+0]
        STR      R0,[R8, #+16]
// 2062     current_position[Y_AXIS] = ry;
        LDR      R0,[R5, #+0]
        STR      R0,[R8, #+20]
// 2063     buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2064 
// 2065     // If Z needs to lower, do it after moving XY
// 2066     if (current_position[Z_AXIS] > rz) {
        LDR      R0,[R6, #+0]
        LDR      R1,[R8, #+24]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_blocking_move_to_5
// 2067       feedrate_mm_s = z_feedrate;
        STR      R10,[R8, #+112]
// 2068       current_position[Z_AXIS] = rz;
        LDR      R0,[R6, #+0]
        STR      R0,[R8, #+24]
// 2069       buffer_line_to_current_position();
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
// 2070     }
// 2071   }
// 2072   //#endif
// 2073 
// 2074   stepper.synchronize();
??do_blocking_move_to_5:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 2075 
// 2076   feedrate_mm_s = old_feedrate_mm_s;
        STR      R9,[R8, #+112]
// 2077 
// 2078   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2079     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
// 2080   #endif
// 2081 }
??do_blocking_move_to_1:
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock22

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock23 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_xRKfS0_
          CFI NoCalls
        THUMB
// 2082 void do_blocking_move_to_x(const float &rx, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_xRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2083   do_blocking_move_to(rx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
        LDR.W    R4,??DataTable120_1
        MOV      R3,R1
        ADD      R2,R4,#+24
        ADD      R1,R4,#+20
        B.N      ?Subroutine3
          CFI EndBlock cfiBlock23
// 2084 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock24 Using cfiCommon0
          CFI Function _Z21do_blocking_move_to_zRKfS0_
          CFI NoCalls
        THUMB
// 2085 void do_blocking_move_to_z(const float &rz, const float &fr_mm_s/*=0.0*/) {
_Z21do_blocking_move_to_zRKfS0_:
        PUSH     {R3,R4}
          CFI R4 Frame(CFA, -4)
          CFI CFA R13+8
// 2086   do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], rz, fr_mm_s);
        LDR.W    R4,??DataTable120_1
        MOV      R3,R1
        MOV      R2,R0
        ADD      R1,R4,#+20
        ADD      R0,R4,#+16
          CFI EndBlock cfiBlock24
        REQUIRE ?Subroutine3
        ;; // Fall through to label ?Subroutine3
// 2087 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock25 Using cfiCommon0
          CFI NoFunction
          CFI CFA R13+8
          CFI R4 Frame(CFA, -4)
        THUMB
?Subroutine3:
        ADD      SP,SP,#+4
          CFI CFA R13+4
        POP      {R4}
          CFI CFA R13+0
          CFI R4 SameValue
          CFI FunCall _Z21do_blocking_move_to_xRKfS0_ _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI FunCall _Z21do_blocking_move_to_zRKfS0_ _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock25

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock26 Using cfiCommon0
          CFI Function _Z22do_blocking_move_to_xyRKfS0_S0_
        THUMB
// 2088 void do_blocking_move_to_xy(const float &rx, const float &ry, const float &fr_mm_s/*=0.0*/) {
// 2089   do_blocking_move_to(rx, ry, current_position[Z_AXIS], fr_mm_s);
_Z22do_blocking_move_to_xyRKfS0_S0_:
        MOV      R3,R2
        LDR.W    R2,??DataTable129
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      _Z19do_blocking_move_toRKfS0_S0_S0_
          CFI EndBlock cfiBlock26
// 2090 }
// 2091 
// 2092 //
// 2093 // Prepare to do endstop or probe moves
// 2094 // with custom feedrates.
// 2095 //
// 2096 //  - Save current feedrates
// 2097 //  - Reset the rate multiplier
// 2098 //  - Reset the command timeout
// 2099 //  - Enable the endstops (for endstop moves)
// 2100 //

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock27 Using cfiCommon0
          CFI Function _Z31setup_for_endstop_or_probe_movev
          CFI NoCalls
        THUMB
// 2101 static void setup_for_endstop_or_probe_move() {
_Z31setup_for_endstop_or_probe_movev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 2102   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2103     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
// 2104   #endif
// 2105   saved_feedrate_mm_s = feedrate_mm_s;
        LDR.W    R4,??DataTable120_1
        LDR.W    R0,??DataTable129_1
        LDR      R1,[R4, #+112]
        STR      R1,[R0, #+4]
// 2106   saved_feedrate_percentage = feedrate_percentage;
        LDRH     R1,[R4, #+14]
        STRH     R1,[R0, #+0]
// 2107   feedrate_percentage = 100;
        MOVS     R0,#+100
        B.N      ?Subroutine1
          CFI EndBlock cfiBlock27
// 2108   refresh_cmd_timeout();
// 2109 }
// 2110 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock28 Using cfiCommon0
          CFI Function _Z36clean_up_after_endstop_or_probe_movev
          CFI NoCalls
        THUMB
// 2111 static void clean_up_after_endstop_or_probe_move() {
_Z36clean_up_after_endstop_or_probe_movev:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 2112   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2113     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
// 2114   #endif
// 2115   feedrate_mm_s = saved_feedrate_mm_s;
        LDR.W    R0,??DataTable129_1
        LDR.W    R4,??DataTable120_1
        LDR      R1,[R0, #+4]
// 2116   feedrate_percentage = saved_feedrate_percentage;
        LDRH     R0,[R0, #+0]
        STR      R1,[R4, #+112]
          CFI EndBlock cfiBlock28
        REQUIRE ?Subroutine1
        ;; // Fall through to label ?Subroutine1
// 2117   refresh_cmd_timeout();
// 2118 }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock29 Using cfiCommon0
          CFI NoFunction
          CFI CFA R13+8
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine1:
        STRH     R0,[R4, #+14]
          CFI FunCall _Z31setup_for_endstop_or_probe_movev HAL_GetTick
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R4, #+120]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock29
// 2119 
// 2120 #if HAS_BED_PROBE
// 2121   /**
// 2122    * Raise Z to a minimum height to make room for a probe to move
// 2123    */
// 2124   inline void do_probe_raise(const float z_raise) {
// 2125     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2126       if (DEBUGGING(LEVELING)) {
// 2127         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
// 2128         SERIAL_CHAR(')');
// 2129         SERIAL_EOL();
// 2130       }
// 2131     #endif
// 2132 
// 2133     float z_dest = z_raise;
// 2134     if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
// 2135 
// 2136     if (z_dest > current_position[Z_AXIS])
// 2137       do_blocking_move_to_z(z_dest);
// 2138   }
// 2139 
// 2140 #endif // HAS_BED_PROBE
// 2141 
// 2142 #if HAS_AXIS_UNHOMED_ERR
// 2143 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock30 Using cfiCommon0
          CFI Function _Z18axis_unhomed_errorbbb
        THUMB
// 2144   bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
_Z18axis_unhomed_errorbbb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 2145     #if ENABLED(HOME_AFTER_DEACTIVATE)
// 2146       const bool xx = x && !axis_known_position[X_AXIS],
// 2147                  yy = y && !axis_known_position[Y_AXIS],
// 2148                  zz = z && !axis_known_position[Z_AXIS];
// 2149     #else
// 2150       const bool xx = x && !axis_homed[X_AXIS],
        CMP      R0,#+0
        ITTTE    NE 
        LDRNE.W  R0,??DataTable121
        LDRBNE   R0,[R0, #+0]
        EORNE    R4,R0,#0x1
        MOVEQ    R4,#+0
// 2151                  yy = y && !axis_homed[Y_AXIS],
        CMP      R1,#+0
        ITTTE    NE 
        LDRNE.W  R0,??DataTable121
        LDRBNE   R0,[R0, #+1]
        EORNE    R5,R0,#0x1
        MOVEQ    R5,#+0
// 2152                  zz = z && !axis_homed[Z_AXIS];
        CMP      R2,#+0
        ITTTE    NE 
        LDRNE.W  R0,??DataTable121
        LDRBNE   R0,[R0, #+2]
        EORNE    R6,R0,#0x1
        MOVEQ    R6,#+0
// 2153     #endif
// 2154     if (xx || yy || zz) {
        ORR      R0,R5,R4
        ORRS     R0,R6,R0
        BEQ.N    ??axis_unhomed_error_0
// 2155       SERIAL_ECHO_START();
        LDR.W    R0,??DataTable121_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2156       SERIAL_ECHOPGM(MSG_HOME " ");
        LDR.W    R0,??DataTable129_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2157       if (xx) SERIAL_ECHOPGM(MSG_X);
        CBZ.N    R4,??axis_unhomed_error_1
        ADR.N    R0,??DataTable119  ;; "X"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2158       if (yy) SERIAL_ECHOPGM(MSG_Y);
??axis_unhomed_error_1:
        CBZ.N    R5,??axis_unhomed_error_2
        ADR.N    R0,??DataTable119_1  ;; "Y"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2159       if (zz) SERIAL_ECHOPGM(MSG_Z);
??axis_unhomed_error_2:
        CBZ.N    R6,??axis_unhomed_error_3
        ADR.N    R0,??DataTable119_2  ;; "Z"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2160       SERIAL_ECHOLNPGM(" " MSG_FIRST);
??axis_unhomed_error_3:
        LDR.W    R0,??DataTable129_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2161 
// 2162       #if ENABLED(ULTRA_LCD)
// 2163         lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
// 2164       #endif
// 2165       return true;
        MOVS     R0,#+1
// 2166     }
// 2167     return false;
??axis_unhomed_error_0:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock30
// 2168   }
// 2169 
// 2170 #endif // HAS_AXIS_UNHOMED_ERR
// 2171 
// 2172 #if ENABLED(Z_PROBE_SLED)
// 2173 
// 2174   #ifndef SLED_DOCKING_OFFSET
// 2175     #define SLED_DOCKING_OFFSET 0
// 2176   #endif
// 2177 
// 2178   /**
// 2179    * Method to dock/undock a sled designed by Charles Bell.
// 2180    *
// 2181    * stow[in]     If false, move to MAX_X and engage the solenoid
// 2182    *              If true, move to MAX_X and release the solenoid
// 2183    */
// 2184   static void dock_sled(bool stow) {
// 2185     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2186       if (DEBUGGING(LEVELING)) {
// 2187         SERIAL_ECHOPAIR("dock_sled(", stow);
// 2188         SERIAL_CHAR(')');
// 2189         SERIAL_EOL();
// 2190       }
// 2191     #endif
// 2192 
// 2193     // Dock sled a bit closer to ensure proper capturing
// 2194     do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
// 2195 
// 2196     #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
// 2197       WRITE(SOL1_PIN, !stow); // switch solenoid
// 2198     #endif
// 2199   }
// 2200 
// 2201 #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2202 
// 2203   FORCE_INLINE void do_blocking_move_to(const float (&raw)[XYZ], const float &fr_mm_s) {
// 2204     do_blocking_move_to(raw[X_AXIS], raw[Y_AXIS], raw[Z_AXIS], fr_mm_s);
// 2205   }
// 2206 
// 2207   void run_deploy_moves_script() {
// 2208     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
// 2209       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
// 2210         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
// 2211       #endif
// 2212       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
// 2213         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
// 2214       #endif
// 2215       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
// 2216         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
// 2217       #endif
// 2218       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
// 2219         #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
// 2220       #endif
// 2221       const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
// 2222       do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
// 2223     #endif
// 2224     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
// 2225       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
// 2226         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
// 2227       #endif
// 2228       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
// 2229         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
// 2230       #endif
// 2231       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
// 2232         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
// 2233       #endif
// 2234       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
// 2235         #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
// 2236       #endif
// 2237       const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
// 2238       do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
// 2239     #endif
// 2240     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
// 2241       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
// 2242         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
// 2243       #endif
// 2244       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
// 2245         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
// 2246       #endif
// 2247       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
// 2248         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
// 2249       #endif
// 2250       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
// 2251         #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
// 2252       #endif
// 2253       const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
// 2254       do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
// 2255     #endif
// 2256     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
// 2257       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
// 2258         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
// 2259       #endif
// 2260       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
// 2261         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
// 2262       #endif
// 2263       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
// 2264         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
// 2265       #endif
// 2266       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
// 2267         #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
// 2268       #endif
// 2269       const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
// 2270       do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
// 2271     #endif
// 2272     #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
// 2273       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
// 2274         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
// 2275       #endif
// 2276       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
// 2277         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
// 2278       #endif
// 2279       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
// 2280         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
// 2281       #endif
// 2282       #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
// 2283         #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
// 2284       #endif
// 2285       const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
// 2286       do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
// 2287     #endif
// 2288   }
// 2289 
// 2290   void run_stow_moves_script() {
// 2291     #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
// 2292       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
// 2293         #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
// 2294       #endif
// 2295       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
// 2296         #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
// 2297       #endif
// 2298       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
// 2299         #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
// 2300       #endif
// 2301       #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
// 2302         #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
// 2303       #endif
// 2304       const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
// 2305       do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
// 2306     #endif
// 2307     #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
// 2308       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
// 2309         #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
// 2310       #endif
// 2311       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
// 2312         #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
// 2313       #endif
// 2314       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
// 2315         #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
// 2316       #endif
// 2317       #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
// 2318         #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
// 2319       #endif
// 2320       const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
// 2321       do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
// 2322     #endif
// 2323     #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
// 2324       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
// 2325         #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
// 2326       #endif
// 2327       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
// 2328         #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
// 2329       #endif
// 2330       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
// 2331         #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
// 2332       #endif
// 2333       #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
// 2334         #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
// 2335       #endif
// 2336       const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
// 2337       do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
// 2338     #endif
// 2339     #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
// 2340       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
// 2341         #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
// 2342       #endif
// 2343       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
// 2344         #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
// 2345       #endif
// 2346       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
// 2347         #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
// 2348       #endif
// 2349       #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
// 2350         #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
// 2351       #endif
// 2352       const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
// 2353       do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
// 2354     #endif
// 2355     #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
// 2356       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
// 2357         #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
// 2358       #endif
// 2359       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
// 2360         #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
// 2361       #endif
// 2362       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
// 2363         #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
// 2364       #endif
// 2365       #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
// 2366         #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
// 2367       #endif
// 2368       const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
// 2369       do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
// 2370     #endif
// 2371   }
// 2372 
// 2373 #endif // Z_PROBE_ALLEN_KEY
// 2374 
// 2375 #if ENABLED(PROBING_FANS_OFF)
// 2376 
// 2377   void fans_pause(const bool p) {
// 2378     if (p != fans_paused) {
// 2379       fans_paused = p;
// 2380       if (p)
// 2381         for (uint8_t x = 0; x < FAN_COUNT; x++) {
// 2382           paused_fanSpeeds[x] = fanSpeeds[x];
// 2383           fanSpeeds[x] = 0;
// 2384         }
// 2385       else
// 2386         for (uint8_t x = 0; x < FAN_COUNT; x++)
// 2387           fanSpeeds[x] = paused_fanSpeeds[x];
// 2388     }
// 2389   }
// 2390 
// 2391 #endif // PROBING_FANS_OFF
// 2392 
// 2393 #if HAS_BED_PROBE
// 2394 
// 2395   // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
// 2396   #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
// 2397     #if 1 //ENABLED(Z_MIN_PROBE_ENDSTOP)
// 2398       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
// 2399     #else
// 2400       #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
// 2401     #endif
// 2402   #endif
// 2403 
// 2404   #if QUIET_PROBING
// 2405     void probing_pause(const bool p) {
// 2406       #if ENABLED(PROBING_HEATERS_OFF)
// 2407         thermalManager.pause(p);
// 2408       #endif
// 2409       #if ENABLED(PROBING_FANS_OFF)
// 2410         fans_pause(p);
// 2411       #endif
// 2412       if (p) safe_delay(
// 2413         #if DELAY_BEFORE_PROBING > 25
// 2414           DELAY_BEFORE_PROBING
// 2415         #else
// 2416           25
// 2417         #endif
// 2418       );
// 2419     }
// 2420   #endif // QUIET_PROBING
// 2421 
// 2422   //#if ENABLED(BLTOUCH)
// 2423 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock31 Using cfiCommon0
          CFI Function _Z15bltouch_commandi
        THUMB
// 2424     void bltouch_command(int angle) {
// 2425     #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
// 2426       //MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
// 2427       int mksAngle;
// 2428  	  switch(angle)
_Z15bltouch_commandi:
        CMP      R0,#+10
        BEQ.N    ??bltouch_command_0
        CMP      R0,#+60
        BEQ.N    ??bltouch_command_1
        CMP      R0,#+90
        BEQ.N    ??bltouch_command_2
        CMP      R0,#+120
        BEQ.N    ??bltouch_command_3
        B.N      ??bltouch_command_4
// 2429 	  {
// 2430 		 case 10:
// 2431 			 mksAngle = 647/2;
??bltouch_command_0:
        MOVW     R0,#+323
// 2432 			 break;
        B.N      ??bltouch_command_5
// 2433 		 case 90:
// 2434 			 mksAngle = 1500/2;
??bltouch_command_2:
        MOVW     R0,#+750
// 2435 			 break;
        B.N      ??bltouch_command_5
// 2436 		 case 120:
// 2437 			 mksAngle = 1782/2;
??bltouch_command_3:
        MOVW     R0,#+891
// 2438 			 break;
        B.N      ??bltouch_command_5
// 2439 		 case 160:
// 2440 			 mksAngle = 2194/2;
// 2441 			 break;
// 2442 		 case 60:
// 2443 			 mksAngle = 1162/2;
??bltouch_command_1:
        MOVW     R0,#+581
// 2444 			 break;
        B.N      ??bltouch_command_5
// 2445 		 default:
// 2446 			 mksAngle = 2194/2;
??bltouch_command_4:
        MOVW     R0,#+1097
// 2447 			 break;
// 2448 	  }
// 2449       MKS_TOUCH_TIM = mksAngle;	  
??bltouch_command_5:
        LDR.W    R1,??DataTable129_4  ;; 0x40012c34
        STR      R0,[R1, #+0]
// 2450       safe_delay(BLTOUCH_DELAY);
        MOVW     R0,#+375
          CFI FunCall _Z10safe_delaym
        B.W      _Z10safe_delaym
          CFI EndBlock cfiBlock31
// 2451       #endif
// 2452     }
// 2453 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock32 Using cfiCommon0
          CFI Function _Z20set_bltouch_deployedb
        THUMB
// 2454     bool set_bltouch_deployed(const bool deploy) {
_Z20set_bltouch_deployedb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 2455       if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
        LDR.N    R5,??DataTable119_6
        MOV      R4,R0
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??set_bltouch_deployed_0
// 2456 		{
// 2457 		if (deploy && (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) 
        CMP      R4,#+0
        BEQ.N    ??set_bltouch_deployed_1
        LDR.W    R6,??DataTable129_5
        LDR.W    R7,??DataTable129_6
        LDR      R0,[R6, #+52]
        LDRH     R1,[R7, #+26]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+59]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_2
// 2458 		  { 	 // If BL-Touch says it's triggered
// 2459 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2460 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
        MOVS     R0,#+10
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2461 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
        MOVS     R0,#+90
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2462 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
        MOVW     R0,#+1500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 2463 											 //  (Measured completion time was 0.65 seconds
// 2464 											 //   after reset, deploy, and stow sequence)
// 2465 		  if ((READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
        LDRH     R1,[R7, #+26]
        LDR      R0,[R6, #+52]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+59]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_2
        B.N      ??set_bltouch_deployed_3
// 2466 			SERIAL_ERROR_START();
// 2467 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
// 2468 			stop(); 						 // punt!
// 2469 		  	}
// 2470 			}
// 2471 		
// 2472 		}
// 2473 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
??set_bltouch_deployed_0:
        CMP      R0,#+2
        BNE.N    ??set_bltouch_deployed_4
// 2474 		{
// 2475 		if (deploy && (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) 
        CBZ.N    R4,??set_bltouch_deployed_1
        LDR.W    R6,??DataTable129_5
        LDR.W    R7,??DataTable129_6
        LDR      R0,[R6, #+56]
        LDRH     R1,[R7, #+28]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        ADDW     R5,R5,#+59
        LDRB     R1,[R5, #+4]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_2
// 2476 		  { 	 // If BL-Touch says it's triggered
// 2477 		  bltouch_command(BLTOUCH_RESET);	 //  try to reset it.
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2478 		  bltouch_command(BLTOUCH_DEPLOY);	 // Also needs to deploy and stow to
        MOVS     R0,#+10
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2479 		  bltouch_command(BLTOUCH_STOW);	 //  clear the triggered condition.
        MOVS     R0,#+90
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2480 		  safe_delay(1500); 				 // Wait for internal self-test to complete.
        MOVW     R0,#+1500
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 2481 											 //  (Measured completion time was 0.65 seconds
// 2482 											 //   after reset, deploy, and stow sequence)
// 2483 		  if ((READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)) { 			 // If it still claims to be triggered...
        LDRH     R1,[R7, #+28]
        LDR      R0,[R6, #+56]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        LDRB     R1,[R5, #+4]
        CMP      R0,R1
        BEQ.N    ??set_bltouch_deployed_2
// 2484 			SERIAL_ERROR_START();
??set_bltouch_deployed_3:
        LDR.W    R0,??DataTable121_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2485 			SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
        LDR.W    R0,??DataTable129_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2486 			stop(); 						 // punt!
          CFI FunCall _Z4stopv
        BL       _Z4stopv
// 2487 		  }
// 2488 		}
// 2489 		}
// 2490       //}
// 2491 
// 2492       bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
??set_bltouch_deployed_4:
        CBZ.N    R4,??set_bltouch_deployed_1
??set_bltouch_deployed_2:
        MOVS     R0,#+10
        B.N      ??set_bltouch_deployed_5
??set_bltouch_deployed_1:
        MOVS     R0,#+90
??set_bltouch_deployed_5:
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 2493 
// 2494       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2495         if (DEBUGGING(LEVELING)) {
// 2496           SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
// 2497           SERIAL_CHAR(')');
// 2498           SERIAL_EOL();
// 2499         }
// 2500       #endif
// 2501 
// 2502       return false;
        MOVS     R0,#+0
        POP      {R1,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock32
// 2503     }
// 2504 
// 2505   //#endif // BLTOUCH
// 2506 
// 2507   // returns false for ok and true for failure

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock33 Using cfiCommon0
          CFI Function _Z18set_probe_deployedb
        THUMB
// 2508   bool set_probe_deployed(bool deploy) {
_Z18set_probe_deployedb:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 2509 
// 2510     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2511       if (DEBUGGING(LEVELING)) {
// 2512         DEBUG_POS("set_probe_deployed", current_position);
// 2513         SERIAL_ECHOLNPAIR("deploy: ", deploy);
// 2514       }
// 2515     #endif
// 2516 
// 2517     if (endstops.z_probe_enabled == deploy) return false;
        LDR.W    R5,??DataTable129_8
        SUB      SP,SP,#+16
          CFI CFA R13+32
        MOV      R4,R0
        LDRB     R0,[R5, #+0]
        CMP      R0,R4
        BEQ.N    ??set_probe_deployed_0
// 2518 
// 2519     // Make room for probe
// 2520     //do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
// 2521     do_probe_raise(Z_CLEARANCE_DEPLOY_PROBE>Z_CLEARANCE_BETWEEN_PROBES ? Z_CLEARANCE_DEPLOY_PROBE : Z_CLEARANCE_BETWEEN_PROBES);
        LDR.N    R0,??DataTable119_6
        LDR      R1,[R0, #+100]
        LDR      R0,[R0, #+104]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R1,R0
        LDR.N    R6,??DataTable120_1
        LDR      R2,[R6, #+124]
        STR      R1,[SP, #+0]
        MOV      R0,R2
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??set_probe_deployed_1
        LDR      R0,[SP, #+0]
        MOV      R1,R2
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
??set_probe_deployed_1:
        LDR      R0,[R6, #+24]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??set_probe_deployed_2
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        ADD      R3,SP,#+4
        ADD      R2,SP,#+0
        ADD      R1,R6,#+20
        ADD      R0,R6,#+16
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2522 
// 2523     #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
// 2524       #if ENABLED(Z_PROBE_SLED)
// 2525         #define _AUE_ARGS true, false, false
// 2526       #else
// 2527         #define _AUE_ARGS
// 2528       #endif
// 2529       if (axis_unhomed_error(_AUE_ARGS)) {
// 2530         SERIAL_ERROR_START();
// 2531         SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
// 2532         stop();
// 2533         return true;
// 2534       }
// 2535     #endif
// 2536 
// 2537     const float oldXpos = current_position[X_AXIS],
??set_probe_deployed_2:
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+0]
// 2538                 oldYpos = current_position[Y_AXIS];
// 2539 
// 2540     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2541       bool _triggered_bool =false;
// 2542 	if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2543 		_triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2544 	else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2545 		_triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2546 
// 2547       // If endstop is already false, the Z probe is deployed
// 2548       if (_triggered_bool == deploy) {
// 2549       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
// 2550                                                        // Would a goto be less ugly?
// 2551         //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
// 2552                                                        // for a triggered when stowed manual probe.
// 2553 
// 2554         if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
// 2555                                                      // otherwise an Allen-Key probe can't be stowed.
// 2556     #endif
// 2557 
// 2558         #if ENABLED(SOLENOID_PROBE)
// 2559 
// 2560           #if HAS_SOLENOID_1
// 2561             WRITE(SOL1_PIN, deploy);
// 2562           #endif
// 2563 
// 2564         #elif ENABLED(Z_PROBE_SLED)
// 2565 
// 2566           dock_sled(!deploy);
// 2567 
// 2568         #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
// 2569 
// 2570           MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
// 2571 
// 2572         #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 2573 
// 2574           deploy ? run_deploy_moves_script() : run_stow_moves_script();
// 2575 
// 2576         #endif
// 2577 
// 2578     #ifdef _TRIGGERED_WHEN_STOWED_TEST
// 2579       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2580       
// 2581 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2582 		  _triggered_bool = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
// 2583 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
// 2584 		  _triggered_bool = (READ(Z_MAX_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
// 2585 
// 2586       //if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
// 2587       if (_triggered_bool == deploy) { 
// 2588 
// 2589         if (IsRunning()) {
// 2590           SERIAL_ERROR_START();
// 2591           SERIAL_ERRORLNPGM("Z-Probe failed");
// 2592           LCD_ALERTMESSAGEPGM("Err: ZPROBE");
// 2593         }
// 2594         stop();
// 2595         return true;
// 2596 
// 2597       } // _TRIGGERED_WHEN_STOWED_TEST == deploy
// 2598 
// 2599     #endif
// 2600 
// 2601     do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
        ADD      R3,SP,#+8
        LDR      R0,[R6, #+20]
        STR      R0,[SP, #+4]
        ADD      R2,R6,#+24
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2602     endstops.enable_z_probe(deploy);
        STRB     R4,[R5, #+0]
// 2603     return false;
??set_probe_deployed_0:
        MOVS     R0,#+0
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock33
// 2604   }
// 2605 
// 2606   /**
// 2607    * @brief Used by run_z_probe to do a single Z probe move.
// 2608    *
// 2609    * @param  z        Z destination
// 2610    * @param  fr_mm_s  Feedrate in mm/s
// 2611    * @return true to indicate an error
// 2612    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock34 Using cfiCommon0
          CFI Function _Z13do_probe_moveff
        THUMB
// 2613   static bool do_probe_move(const float z, const float fr_mm_m) {
_Z13do_probe_moveff:
        PUSH     {R0,R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 2614     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2615       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
// 2616     #endif
// 2617 
// 2618     // Deploy BLTouch at the start of any probe
// 2619     //#if ENABLED(BLTOUCH)
// 2620     if(MKSTOUCH == 1)
        LDR.N    R4,??DataTable119_6
        LDRB     R0,[R4, #+256]
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOV      R5,R1
        CMP      R0,#+1
        BNE.N    ??do_probe_move_0
// 2621       {if (set_bltouch_deployed(true)) return true;}
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        CBNZ.N   R0,??do_probe_move_1
// 2622     //#endif
// 2623 
// 2624     #if QUIET_PROBING
// 2625       probing_pause(true);
// 2626     #endif
// 2627 
// 2628     // Move down until probe triggered
// 2629     do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
??do_probe_move_0:
        MOV      R0,R5
        LDR.N    R1,??DataTable119_7  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.N    R5,??DataTable120_1
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,SP,#+8
        ADD      R1,R5,#+20
        ADD      R0,R5,#+16
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2630    /*
// 2631     // Check to see if the probe was triggered
// 2632     const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
// 2633       #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 2634         Z_MIN
// 2635       #else
// 2636         Z_MIN_PROBE
// 2637       #endif
// 2638     );
// 2639     */
// 2640       bool probe_triggered;
// 2641       if(Z_MIN_PROBE_PIN_MODE != Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN)
        LDRB     R0,[R4, #+153]
        LDR.W    R6,??DataTable131
        CMP      R0,#+2
        LDRSB    R0,[R6, #+0]
        UXTB     R0,R0
        ITE      NE 
// 2642       {
// 2643         probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN);
        LSRNE    R0,R0,#+2
// 2644       }
// 2645       else
// 2646       {
// 2647         probe_triggered = TEST(Endstops::endstop_hit_bits,Z_MIN_PROBE);
        LSREQ    R0,R0,#+3
        AND      R7,R0,#0x1
// 2648       }
// 2649 
// 2650     #if QUIET_PROBING
// 2651       probing_pause(false);
// 2652     #endif
// 2653 
// 2654     // Retract BLTouch immediately after a probe if it was triggered
// 2655     //#if ENABLED(BLTOUCH)
// 2656     if(MKSTOUCH == 1)
        LDRB     R0,[R4, #+256]
        CMP      R0,#+1
        BNE.N    ??do_probe_move_2
// 2657       {if (probe_triggered && set_bltouch_deployed(false)) return true;}
        CBZ.N    R7,??do_probe_move_2
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        CBZ.N    R0,??do_probe_move_2
??do_probe_move_1:
        MOVS     R0,#+1
        ADD      SP,SP,#+12
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+32
// 2658     //#endif
// 2659 
// 2660     // Clear endstop flags
// 2661     endstops.hit_on_purpose();
??do_probe_move_2:
        MOVS     R0,#+0
        STRB     R0,[R6, #+0]
// 2662 
// 2663     // Get Z where the steppers were interrupted
// 2664     set_current_from_steppers_for_axis(Z_AXIS);
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
        MOVS     R1,#+46
        LDRB     R0,[R4, #+66]
        TST      R0,R1
        ITT      NE 
        ADDNE    R0,R5,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
        LDR      R0,[R5, #+104]
        STR      R0,[R5, #+24]
// 2665 
// 2666     // Tell the planner where we actually are
// 2667     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 2668 
// 2669     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2670       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
// 2671     #endif
// 2672 
// 2673     return !probe_triggered;
        EOR      R0,R7,#0x1
        ADD      SP,SP,#+12
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock34
// 2674   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119:
        DC8      "X",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_1:
        DC8      "Y",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_2:
        DC8      "Z",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_3:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_4:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_5:
        DC32     axis_relative_modes+0x84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_6:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable119_7:
        DC32     0x42700000
// 2675 
// 2676   /**
// 2677    * @details Used by probe_pt to do a single Z probe at the current position.
// 2678    *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
// 2679    *
// 2680    * @return The raw Z position where the probe was triggered
// 2681    */
// 2682   static float run_z_probe() {
// 2683 
// 2684     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2685       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
// 2686     #endif
// 2687 
// 2688     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
// 2689     refresh_cmd_timeout();
// 2690 
// 2691     // Double-probing does a fast probe followed by a slow probe
// 2692     #if MULTIPLE_PROBING == 2
// 2693 
// 2694       // Do a first probe at the fast speed
// 2695       if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
// 2696 
// 2697       float first_probe_z = current_position[Z_AXIS];
// 2698 
// 2699       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2700         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
// 2701       #endif
// 2702 
// 2703       // move up to make clearance for the probe
// 2704       do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2705 
// 2706     #else
// 2707 
// 2708       // If the nozzle is above the travel height then
// 2709       // move down quickly before doing the slow probe
// 2710       float z = Z_CLEARANCE_DEPLOY_PROBE;
// 2711       if (zprobe_zoffset < 0) z -= zprobe_zoffset;
// 2712 
// 2713       if (z < current_position[Z_AXIS]) {
// 2714 
// 2715         // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
// 2716         if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
// 2717           do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2718       }
// 2719     #endif
// 2720 
// 2721     #if MULTIPLE_PROBING > 2
// 2722       float probes_total = 0;
// 2723       for (uint8_t p = MULTIPLE_PROBING + 1; --p;) {
// 2724     #endif
// 2725 
// 2726         // move down slowly to find bed
// 2727         if (do_probe_move(-10, Z_PROBE_SPEED_SLOW)) return NAN;
// 2728 
// 2729     #if MULTIPLE_PROBING > 2
// 2730         probes_total += current_position[Z_AXIS];
// 2731         if (p > 1) do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
// 2732       }
// 2733     #endif
// 2734 
// 2735     #if MULTIPLE_PROBING > 2
// 2736 
// 2737       // Return the average value of all probes
// 2738       return probes_total * (1.0 / (MULTIPLE_PROBING));
// 2739 
// 2740     #elif MULTIPLE_PROBING == 2
// 2741 
// 2742       const float z2 = current_position[Z_AXIS];
// 2743 
// 2744       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2745         if (DEBUGGING(LEVELING)) {
// 2746           SERIAL_ECHOPAIR("2nd Probe Z:", z2);
// 2747           SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - z2);
// 2748         }
// 2749       #endif
// 2750 
// 2751       // Return a weighted average of the fast and slow probes
// 2752       return (z2 * 3.0 + first_probe_z * 2.0) * 0.2;
// 2753 
// 2754     #else
// 2755 
// 2756       // Return the single probe result
// 2757       return current_position[Z_AXIS];
// 2758 
// 2759     #endif
// 2760 
// 2761     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2762       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
// 2763     #endif
// 2764   }
// 2765 
// 2766   /**
// 2767    * - Move to the given XY
// 2768    * - Deploy the probe, if not already deployed
// 2769    * - Probe the bed, get the Z position
// 2770    * - Depending on the 'stow' flag
// 2771    *   - Stow the probe, or
// 2772    *   - Raise to the BETWEEN height
// 2773    * - Return the probed Z position
// 2774    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock35 Using cfiCommon0
          CFI Function _Z8probe_ptRKfS0_bhb
        THUMB
// 2775   float probe_pt(const float &rx, const float &ry, const bool stow, const uint8_t verbose_level, const bool probe_relative=true) {
_Z8probe_ptRKfS0_bhb:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        MOV      R8,R0
        SUB      SP,SP,#+28
          CFI CFA R13+64
// 2776     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2777       if (DEBUGGING(LEVELING)) {
// 2778         SERIAL_ECHOPAIR(">>> probe_pt(", LOGICAL_X_POSITION(rx));
// 2779         SERIAL_ECHOPAIR(", ", LOGICAL_Y_POSITION(ry));
// 2780         SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
// 2781         SERIAL_ECHOLNPGM("stow)");
// 2782         DEBUG_POS("", current_position);
// 2783       }
// 2784     #endif
// 2785 
// 2786     // TODO: Adapt for SCARA, where the offset rotates
// 2787     float nx = rx, ny = ry;
        LDR      R0,[R8, #+0]
        STR      R0,[SP, #+8]
        MOV      R4,R1
// 2788     if (probe_relative) {
        LDR.W    R7,??DataTable130
        LDR      R0,[R4, #+0]
        LDRSH    R6,[R7, #+88]
        STR      R0,[SP, #+4]
        MOV      R10,R2
        LDR      R0,[SP, #+64]
        MOV      R9,R3
        MOVW     R1,#+770
        CBZ.N    R0,??probe_pt_0
// 2789       if(MACHINETPYE & IS_KINEMATIC)
        TST      R6,R1
        MOV      R1,R4
        MOV      R0,R8
        BEQ.N    ??probe_pt_1
// 2790       {
// 2791         if (!position_is_reachable_by_probe_IS_KINEMATIC(rx, ry)) return NAN;  // The given position is in terms of the probe
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CBNZ.N   R0,??probe_pt_2
        B.N      ??probe_pt_3
// 2792       }
// 2793       else
// 2794       {
// 2795         if (!position_is_reachable_by_probe_IS_CARTESIAN(rx, ry)) return NAN;  // The given position is in terms of the probe
??probe_pt_1:
          CFI FunCall _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        CBZ.N    R0,??probe_pt_3
// 2796       }
// 2797       nx -= (X_PROBE_OFFSET_FROM_EXTRUDER);                     // Get the nozzle position
??probe_pt_2:
        LDR      R0,[SP, #+8]
        LDR      R1,[R7, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
// 2798       ny -= (Y_PROBE_OFFSET_FROM_EXTRUDER);
        LDR      R1,[R7, #+112]
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
// 2799     }
// 2800     else
// 2801     {
// 2802         if(MACHINETPYE & IS_KINEMATIC)
// 2803         {
// 2804             if (!position_is_reachable_IS_KINEMATIC(nx, ny)) return NAN;        // The given position is in terms of the nozzle
// 2805         }
// 2806         else
// 2807         {
// 2808             if (!position_is_reachable_IS_CARTESIAN(nx, ny)) return NAN;        // The given position is in terms of the nozzle            
// 2809         }
// 2810      }
// 2811     //const 
// 2812         float nz;/* =
// 2813       #if ENABLED(DELTA)
// 2814         // Move below clip height or xy move will be aborted by do_blocking_move_to
// 2815         min(current_position[Z_AXIS], delta_clip_start_height)
// 2816       #else
// 2817         current_position[Z_AXIS]
// 2818       #endif
// 2819     ;
// 2820     */
// 2821     if(MACHINETPYE ==  DELTA)
??probe_pt_4:
        LDR.N    R5,??DataTable120_1
        LDR.W    R2,??DataTable130_1
        LDR      R0,[R5, #+24]
        CMP      R6,#+2
        BNE.N    ??probe_pt_5
// 2822     {
// 2823         nz = min(current_position[Z_AXIS], delta_clip_start_height);
        LDR      R1,[R2, #+104]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_pt_6
        B.N      ??probe_pt_5
// 2824     }
??probe_pt_0:
        TST      R6,R1
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
        BEQ.N    ??probe_pt_7
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_4
        B.N      ??probe_pt_3
??probe_pt_7:
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BNE.N    ??probe_pt_4
??probe_pt_3:
        MVN      R0,#-2147483648
        B.N      ?Subroutine4
??probe_pt_6:
        STR      R1,[SP, #+12]
        B.N      ??probe_pt_8
// 2825     else
// 2826     {
// 2827         nz = current_position[Z_AXIS];
??probe_pt_5:
        STR      R0,[SP, #+12]
// 2828     }
// 2829     const float old_feedrate_mm_s = feedrate_mm_s;
??probe_pt_8:
        LDR      R0,[R5, #+112]
        STR      R0,[SP, #+20]
// 2830     feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
// 2831 
// 2832     // Move the probe to the starting XYZ
// 2833     do_blocking_move_to(nx, ny, nz);
        ADD      R3,SP,#+0
        LDR      R0,[R2, #+100]
        STR      R0,[R5, #+112]
        ADD      R2,SP,#+12
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 2834 
// 2835     float measured_z = NAN;
        MVN      R11,#-2147483648
        MOV      R6,R11
// 2836     if (!DEPLOY_PROBE()) {
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CMP      R0,#+0
        BNE.N    ??probe_pt_9
// 2837       measured_z = run_z_probe() + zprobe_zoffset;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R5, #+120]
        MOVS     R1,#+0
        LDR      R3,[R5, #+124]
        LDR      R2,[R7, #+100]
        MOV      R0,R3
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_pt_10
        MOV      R0,R2
        MOV      R1,R3
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R2,R0
??probe_pt_10:
        LDR      R1,[R5, #+24]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??probe_pt_11
        LDR      R1,[R7, #+120]
          CFI FunCall _Z13do_probe_moveff
        BL       _Z13do_probe_moveff
        CBNZ.N   R0,??probe_pt_11
        LDR      R1,[R5, #+24]
        LDR      R0,[R7, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable132  ;; 0x42700000
        STR      R0,[SP, #+16]
        LDR      R0,[R7, #+120]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,SP,#+16
        ADD      R1,R5,#+20
        ADD      R0,R5,#+16
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
??probe_pt_11:
        LDR      R1,[R7, #+124]
        LDR.W    R0,??DataTable132_1  ;; 0xc1200000
          CFI FunCall _Z13do_probe_moveff
        BL       _Z13do_probe_moveff
        CMP      R0,#+0
        ITE      NE 
        MOVNE    R1,R11
        LDREQ    R1,[R5, #+24]
        LDR      R0,[R5, #+124]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
// 2838 
// 2839       if (!stow)
        CMP      R10,#+0
        BNE.N    ??probe_pt_12
// 2840         do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
        LDR      R1,[R5, #+24]
        LDR      R0,[R7, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable132  ;; 0x42700000
        STR      R0,[SP, #+16]
        LDR      R0,[R7, #+120]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,SP,#+16
        ADD      R1,R5,#+20
        ADD      R0,R5,#+16
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
        B.N      ??probe_pt_9
// 2841       else
// 2842         if (STOW_PROBE()) measured_z = NAN;
??probe_pt_12:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CBZ.N    R0,??probe_pt_9
        MOV      R6,R11
// 2843     }
// 2844 
// 2845     if (verbose_level > 2) {
??probe_pt_9:
        CMP      R9,#+3
        BLT.N    ??probe_pt_13
// 2846       SERIAL_PROTOCOLPGM("Bed X: ");
        LDR.W    R0,??DataTable132_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2847       SERIAL_PROTOCOL_F(LOGICAL_X_POSITION(rx), 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR      R1,[R8, #+0]
        LDR      R0,[R5, #+60]
        LDR.N    R7,??DataTable121_4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2848       SERIAL_PROTOCOLPGM(" Y: ");
        LDR.W    R0,??DataTable132_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2849       SERIAL_PROTOCOL_F(LOGICAL_Y_POSITION(ry), 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2850       SERIAL_PROTOCOLPGM(" Z: ");
        LDR.W    R0,??DataTable133
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2851       SERIAL_PROTOCOL_F(measured_z, 3);
        MOVS     R0,#+3
        STR      R0,[SP, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R7
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 2852       SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R7
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 2853     }
// 2854 
// 2855     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 2856       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
// 2857     #endif
// 2858 
// 2859     feedrate_mm_s = old_feedrate_mm_s;
??probe_pt_13:
        LDR      R0,[SP, #+20]
        STR      R0,[R5, #+112]
// 2860 
// 2861     if (isnan(measured_z)) {
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??probe_pt_14
// 2862       LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
// 2863       SERIAL_ERROR_START();
        LDR.N    R0,??DataTable121_5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2864       SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
        LDR.W    R0,??DataTable134
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 2865     }
// 2866 
// 2867     return measured_z;
??probe_pt_14:
        MOV      R0,R6
          CFI EndBlock cfiBlock35
        REQUIRE ?Subroutine4
        ;; // Fall through to label ?Subroutine4
// 2868   }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock36 Using cfiCommon0
          CFI NoFunction
          CFI NoCalls mks_getPositionXYZE
          CFI NoCalls _Z8probe_ptRKfS0_bhb
          CFI NoCalls _Z22process_parsed_commandv
          CFI CFA R13+64
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine4:
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock36
// 2869 
// 2870 #endif // HAS_BED_PROBE
// 2871 
// 2872 #if 1//HAS_LEVELING
// 2873 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock37 Using cfiCommon0
          CFI Function _Z17leveling_is_validv
          CFI NoCalls
        THUMB
// 2874   bool leveling_is_valid() {
_Z17leveling_is_validv:
        LDR.W    R0,??DataTable130
        LDRB     R0,[R0, #+66]
        CMP      R0,#+32
        BNE.N    ??leveling_is_valid_0
// 2875   /*
// 2876     return
// 2877       #if ENABLED(MESH_BED_LEVELING)
// 2878         mbl.has_mesh
// 2879       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2880         !!bilinear_grid_spacing[X_AXIS]
// 2881       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2882         true
// 2883       #else // 3POINT, LINEAR
// 2884         true
// 2885       #endif
// 2886     ;
// 2887     */
// 2888       if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 2889         return mbl.has_mesh;
        LDR.W    R0,??DataTable135
        LDRB     R0,[R0, #+0]
        BX       LR
// 2890       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??leveling_is_valid_0:
        CMP      R0,#+8
        BNE.N    ??leveling_is_valid_1
// 2891         return !!bilinear_grid_spacing[X_AXIS];
        LDR.W    R0,??DataTable137
        LDR      R0,[R0, #+8]
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        BX       LR
// 2892       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 2893         return true;
// 2894       else
// 2895         return true;
??leveling_is_valid_1:
        MOVS     R0,#+1
        BX       LR               ;; return
          CFI EndBlock cfiBlock37
// 2896   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable120_2:
        DC32     _ZN7Planner15leveling_activeE
// 2897 
// 2898   /**
// 2899    * Turn bed leveling on or off, fixing the current
// 2900    * position as-needed.
// 2901    *
// 2902    * Disable: Current position = physical position
// 2903    *  Enable: Current position = "unleveled" physical position
// 2904    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock38 Using cfiCommon0
          CFI Function _Z24set_bed_leveling_enabledb
        THUMB
// 2905   void set_bed_leveling_enabled(const bool enable/*=true*/) {
_Z24set_bed_leveling_enabledb:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
// 2906     bool can_change;
// 2907 /*
// 2908     #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2909       const bool can_change = (!enable || leveling_is_valid());
// 2910     #else
// 2911       constexpr bool can_change = true;
// 2912     #endif
// 2913 */
// 2914     if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
        LDR.W    R6,??DataTable130
        LDRB     R7,[R6, #+66]
        SUB      SP,SP,#+20
          CFI CFA R13+40
        MOV      R4,R0
        CMP      R7,#+8
        BNE.N    ??set_bed_leveling_enabled_0
// 2915         can_change = (!enable || leveling_is_valid());
// 2916     else
// 2917         can_change = true;
// 2918         
// 2919     if (can_change && enable != planner.leveling_active) {
        CBZ.N    R4,??set_bed_leveling_enabled_0
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
??set_bed_leveling_enabled_0:
        LDR.W    R5,??DataTable135_1
        LDRB     R0,[R5, #+0]
        CMP      R4,R0
        BEQ.N    ??set_bed_leveling_enabled_1
// 2920 
// 2921       //#if ENABLED(MESH_BED_LEVELING)
// 2922       if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
        CMP      R7,#+32
        BNE.N    ??set_bed_leveling_enabled_2
// 2923       {
// 2924         if (!enable)
        CBNZ.N   R4,??set_bed_leveling_enabled_3
// 2925           planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        LDR.W    R7,??DataTable137_1
        ADD      R2,R7,#+24
        ADD      R1,R7,#+20
        ADD      R0,R7,#+16
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
        MOVS     R0,#+0
        B.N      ??set_bed_leveling_enabled_4
// 2926 
// 2927         const bool enabling = enable && leveling_is_valid();
??set_bed_leveling_enabled_3:
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
// 2928         planner.leveling_active = enabling;
??set_bed_leveling_enabled_4:
        STRB     R0,[R5, #+0]
// 2929         if (enabling) planner.unapply_leveling(current_position);
        LDRB     R0,[R5, #+0]
        CMP      R0,#+0
        BEQ.N    ??set_bed_leveling_enabled_1
        LDR.N    R0,??DataTable122
        B.N      ??set_bed_leveling_enabled_5
// 2930       }
// 2931       //#elif ENABLED(AUTO_BED_LEVELING_UBL)
// 2932       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
??set_bed_leveling_enabled_2:
        CMP      R7,#+16
        BNE.N    ??set_bed_leveling_enabled_6
// 2933       {
// 2934         //#if PLANNER_LEVELING
// 2935         if(BED_LEVELING_METHOD&ABL_PLANAR)
        MOVS     R1,#+6
        TST      R7,R1
        BEQ.N    ??set_bed_leveling_enabled_7
// 2936         {
// 2937           if (planner.leveling_active) {                       // leveling from on to off
        LDR.W    R7,??DataTable137_1
        CBZ.N    R0,??set_bed_leveling_enabled_8
// 2938             // change unleveled current_position to physical current_position without moving steppers.
// 2939             planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
        ADD      R2,R7,#+24
        ADD      R1,R7,#+20
        ADD      R0,R7,#+16
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 2940             planner.leveling_active = false;                   // disable only AFTER calling apply_leveling
        MOVS     R0,#+0
        STRB     R0,[R5, #+0]
// 2941           }
// 2942           else {                                        // leveling from off to on
// 2943             planner.leveling_active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
// 2944             // change physical current_position to unleveled current_position without moving steppers.
// 2945             planner.unapply_leveling(current_position);
// 2946           }
// 2947         }
// 2948         //#else
// 2949         else
// 2950           planner.leveling_active = enable;                    // just flip the bit, current_position will be wrong until next move.
// 2951         //#endif
// 2952       }
// 2953       //#else // ABL
// 2954       else
// 2955       {
// 2956         //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 2957         if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
// 2958         {
// 2959           // Force bilinear_z_offset to re-calculate next time
// 2960           const float reset[XYZ] = { -9999.999, -9999.999, 0 };
// 2961           (void)bilinear_z_offset(reset);
// 2962         }
// 2963         //#endif
// 2964 
// 2965         // Enable or disable leveling compensation in the planner
// 2966         planner.leveling_active = enable;
// 2967 
// 2968         if (!enable)
// 2969             /*
// 2970           // When disabling just get the current position from the steppers.
// 2971           // This will yield the smallest error when first converted back to steps.
// 2972           set_current_from_steppers_for_axis(
// 2973             #if ABL_PLANAR
// 2974               ALL_AXES
// 2975             #else
// 2976               Z_AXIS
// 2977             #endif
// 2978           );
// 2979           */
// 2980         {
// 2981             if(BED_LEVELING_METHOD&ABL_PLANAR)
// 2982                 set_current_from_steppers_for_axis(ALL_AXES);
// 2983             else
// 2984                 set_current_from_steppers_for_axis(Z_AXIS);
// 2985         }
// 2986         else
// 2987           // When enabling, remove compensation from the current position,
// 2988           // so compensation will give the right stepper counts.
// 2989           planner.unapply_leveling(current_position);
// 2990 
// 2991         SYNC_PLAN_POSITION_KINEMATIC();
// 2992       }
// 2993       //#endif // ABL
// 2994     }
// 2995   }
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+40
??set_bed_leveling_enabled_8:
        MOVS     R0,#+1
        STRB     R0,[R5, #+0]
        ADD      R0,R7,#+16
??set_bed_leveling_enabled_5:
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+40
??set_bed_leveling_enabled_7:
        STRB     R4,[R5, #+0]
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+40
??set_bed_leveling_enabled_6:
        CMP      R7,#+8
        BNE.N    ??set_bed_leveling_enabled_9
        LDR.W    R1,??DataTable136
        LDM      R1!,{R2,R3,R7}
        ADD      R0,SP,#+0
        STM      R0!,{R2,R3,R7}
        ADD      R0,SP,#+0
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
??set_bed_leveling_enabled_9:
        STRB     R4,[R5, #+0]
        LDR.W    R7,??DataTable137_1
        CBNZ.N   R4,??set_bed_leveling_enabled_10
        LDRB     R0,[R6, #+66]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??set_bed_leveling_enabled_11
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
        LDRB     R0,[R6, #+66]
        MOVS     R1,#+46
        TST      R0,R1
        ITT      NE 
        ADDNE    R0,R7,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
        ADD      R0,R7,#+96
        LDM      R0!,{R2-R4}
        ADD      R1,R7,#+16
        STM      R1!,{R2-R4}
        B.N      ??set_bed_leveling_enabled_12
??set_bed_leveling_enabled_11:
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
        LDRB     R0,[R6, #+66]
        MOVS     R1,#+46
        TST      R0,R1
        ITT      NE 
        ADDNE    R0,R7,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
        LDR      R0,[R7, #+104]
        STR      R0,[R7, #+24]
        B.N      ??set_bed_leveling_enabled_12
??set_bed_leveling_enabled_10:
        ADD      R0,R7,#+16
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
??set_bed_leveling_enabled_12:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??set_bed_leveling_enabled_1:
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
          CFI EndBlock cfiBlock38

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_1:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_2:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_3:
        DC32     `?<Constant "enqueueing \\"">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_4:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_5:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_6:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable121_7:
        DC32     gCfgItems
// 2996 
// 2997   #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 2998 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock39 Using cfiCommon0
          CFI Function _Z17set_z_fade_heightfb
        THUMB
// 2999     void set_z_fade_height(const float zfh, const bool do_report/*=true*/) {
_Z17set_z_fade_heightfb:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
// 3000 
// 3001       if (planner.z_fade_height == zfh) return; // do nothing if no change
        LDR.W    R8,??DataTable137_2
        MOV      R7,R0
        MOV      R4,R1
        LDR      R0,[R8, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        SUB      SP,SP,#+16
          CFI CFA R13+40
        BEQ.N    ??set_z_fade_height_0
// 3002 
// 3003       const bool level_active = planner.leveling_active;
        LDR.W    R0,??DataTable135_1
// 3004 
// 3005       //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 3006       if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
        LDR.W    R5,??DataTable130
        LDRB     R6,[R0, #+0]
        LDRB     R0,[R5, #+66]
        CMP      R0,#+16
        BNE.N    ??set_z_fade_height_1
// 3007         if (level_active) set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
        CBZ.N    R6,??set_z_fade_height_1
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 3008       //#endif
// 3009 
// 3010       planner.set_z_fade_height(zfh);
??set_z_fade_height_1:
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        IT       CS 
        MOVCS    R7,#+0
        MOV      R0,R7
        LDR.W    R1,??DataTable137_3  ;; 0xb58637bd
        STR      R7,[R8, #+0]
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??set_z_fade_height_2
        LDR.W    R1,??DataTable137_4  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R0,#+0
        BCC.N    ??set_z_fade_height_3
??set_z_fade_height_2:
        MOV      R0,#+1065353216
        MOV      R1,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
??set_z_fade_height_3:
        LDR.W    R1,??DataTable137_5
        STR      R0,[R1, #+0]
// 3011 
// 3012       if (level_active) {
        CMP      R6,#+0
        LDR.W    R1,??DataTable138
        LDR.W    R0,??DataTable138_1  ;; 0xc479fff0
        STR      R0,[R1, #+0]
        BEQ.N    ??set_z_fade_height_0
// 3013         const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
        LDR.W    R6,??DataTable137_1
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+0]
        LDR      R0,[R6, #+20]
        STR      R0,[SP, #+4]
        LDR      R0,[R6, #+24]
        STR      R0,[SP, #+8]
// 3014         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 3015         if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
        LDRB     R0,[R5, #+66]
        CMP      R0,#+16
        BNE.N    ??set_z_fade_height_4
// 3016           set_bed_leveling_enabled(true);  // turn back on after changing fade height
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.N      ??set_z_fade_height_5
// 3017         //#else
// 3018         else
// 3019         {
// 3020         /*
// 3021           set_current_from_steppers_for_axis(
// 3022             #if ABL_PLANAR
// 3023               ALL_AXES
// 3024             #else
// 3025               Z_AXIS
// 3026             #endif
// 3027           );
// 3028             */
// 3029           if(BED_LEVELING_METHOD&ABL_PLANAR)
??set_z_fade_height_4:
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??set_z_fade_height_6
// 3030           {
// 3031             set_current_from_steppers_for_axis(ALL_AXES);
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
        LDRB     R0,[R5, #+66]
        MOVS     R1,#+46
        TST      R0,R1
        ITT      NE 
        ADDNE    R0,R6,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
        ADD      R0,R6,#+96
        LDM      R0!,{R2,R3,R5}
        ADD      R1,R6,#+16
        STM      R1!,{R2,R3,R5}
        B.N      ??set_z_fade_height_7
// 3032           }
// 3033           else
// 3034           {
// 3035             set_current_from_steppers_for_axis(Z_AXIS);
??set_z_fade_height_6:
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
        LDRB     R0,[R5, #+66]
        MOVS     R1,#+46
        TST      R0,R1
        ITT      NE 
        ADDNE    R0,R6,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
        LDR      R0,[R6, #+104]
        STR      R0,[R6, #+24]
// 3036           }
// 3037             
// 3038           SYNC_PLAN_POSITION_KINEMATIC();
??set_z_fade_height_7:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3039         }
// 3040         //#endif
// 3041         if (do_report && memcmp(oldpos, current_position, sizeof(oldpos)))
??set_z_fade_height_5:
        CBZ.N    R4,??set_z_fade_height_0
        MOVS     R2,#+12
        ADD      R1,R6,#+16
        ADD      R0,SP,#+0
          CFI FunCall memcmp
        BL       memcmp
        CBZ.N    R0,??set_z_fade_height_0
// 3042           report_current_position();
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
// 3043       }
// 3044     }
??set_z_fade_height_0:
        B.W      ?Subroutine0
          CFI EndBlock cfiBlock39

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122:
        DC32     axis_relative_modes+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122_1:
        DC32     lcd_wait_for_move

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122_2:
        DC32     _ZN11GCodeParser9value_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable122_3:
        DC32     `?<Constant " Invalid extruder ">`
// 3045 
// 3046   #endif // LEVELING_FADE_HEIGHT
// 3047 
// 3048   /**
// 3049    * Reset calibration results to zero.
// 3050    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock40 Using cfiCommon0
          CFI Function _Z15reset_bed_levelv
        THUMB
// 3051   void reset_bed_level() {
_Z15reset_bed_levelv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3052     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3053       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
// 3054     #endif
// 3055     set_bed_leveling_enabled(false);
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 3056     //#if ENABLED(MESH_BED_LEVELING)
// 3057     if(BED_LEVELING_METHOD==MESH_BED_LEVELING)
        LDR.W    R0,??DataTable130
        LDRB     R1,[R0, #+66]
        CMP      R1,#+32
        BNE.N    ??reset_bed_level_0
// 3058     {
// 3059       if (leveling_is_valid()) {
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CBZ.N    R0,??reset_bed_level_1
// 3060         mbl.reset();
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
// 3061         mbl.has_mesh = false;
        LDR.W    R1,??DataTable135
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        POP      {R0,R4,R5,PC}
// 3062       }
// 3063     }
// 3064     //#elif ENABLED(AUTO_BED_LEVELING_UBL)
// 3065     else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_UBL)
??reset_bed_level_0:
        CMP      R1,#+16
        ITT      EQ 
// 3066       ubl.reset();
        POPEQ    {R0,R4,R5,LR}
          CFI FunCall _ZN20unified_bed_leveling5resetEv
        BEQ.W    _ZN20unified_bed_leveling5resetEv
// 3067     //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3068     else if(BED_LEVELING_METHOD==AUTO_BED_LEVELING_BILINEAR)
        CMP      R1,#+8
        BNE.N    ??reset_bed_level_2
// 3069     {
// 3070       bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
// 3071       bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
        MOVS     R2,#+0
        LDR.W    R1,??DataTable137
        STR      R2,[R1, #+12]
// 3072       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
        ADDW     R0,R0,#+66
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+20]
        STR      R2,[R1, #+16]
        LDRB     R1,[R0, #+30]
        CBZ.N    R1,??reset_bed_level_1
        LDR.W    R2,??DataTable139_2
        MVN      R3,#-2147483648
// 3073         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
??reset_bed_level_3:
        LDRB     R4,[R0, #+31]
        CBZ.N    R4,??reset_bed_level_4
        MOV      R5,R2
// 3074           z_values[x][y] = NAN;
??reset_bed_level_5:
        STR      R3,[R5], #+4
        SUBS     R4,R4,#+1
        BNE.N    ??reset_bed_level_5
??reset_bed_level_4:
        ADDS     R2,R2,#+48
        SUBS     R1,R1,#+1
        BEQ.N    ??reset_bed_level_1
        B.N      ??reset_bed_level_3
// 3075     }
// 3076     //#elif ABL_PLANAR
// 3077     else if(BED_LEVELING_METHOD&ABL_PLANAR)
??reset_bed_level_2:
        MOVS     R0,#+6
        TST      R1,R0
        BEQ.N    ??reset_bed_level_1
// 3078       planner.bed_level_matrix.set_to_identity();
        POP      {R1,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        LDR.W    R0,??DataTable139_5
          CFI FunCall _ZN10matrix_3x315set_to_identityEv
        B.W      _ZN10matrix_3x315set_to_identityEv
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
// 3079     //#endif
// 3080   }
??reset_bed_level_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock40

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123:
        DC32     serial_wait_tick

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable123_1:
        DC32     `?<Constant "sd:%d">`
// 3081 
// 3082 #endif // HAS_LEVELING
// 3083 
// 3084 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
// 3085 
// 3086   /**
// 3087    * Enable to produce output in JSON format suitable
// 3088    * for SCAD or JavaScript mesh visualizers.
// 3089    *
// 3090    * Visualize meshes in OpenSCAD using the included script.
// 3091    *
// 3092    *   buildroot/shared/scripts/MarlinMesh.scad
// 3093    */
// 3094   //#define SCAD_MESH_OUTPUT
// 3095 
// 3096   /**
// 3097    * Print calibration results for plotting or manual frame adjustment.
// 3098    */
// 3099   //static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock41 Using cfiCommon0
          CFI Function _Z14print_2d_arrayhhhh
        THUMB
// 3100     static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, const uint8_t fn) {
_Z14print_2d_arrayhhhh:
        PUSH     {R0-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+52
        SUB      SP,SP,#+12
          CFI CFA R13+64
// 3101     #ifndef SCAD_MESH_OUTPUT
// 3102       for (uint8_t x = 0; x < sx; x++) {
        MOVS     R5,#+0
        LDR.W    R11,??DataTable139_6
        CBZ.N    R0,??print_2d_array_0
        MOV      R6,R0
// 3103         for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
??print_2d_array_1:
        MOVS     R7,#+0
        B.N      ??print_2d_array_2
// 3104           SERIAL_PROTOCOLCHAR(' ');
??print_2d_array_3:
        MOVS     R1,#+32
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADDS     R7,R7,#+1
??print_2d_array_2:
        CMP      R5,#+10
        ITE      LT 
        MOVLT    R0,#+1
        MOVGE    R0,#+0
        LDRB     R1,[SP, #+20]
        ADDS     R0,R0,R1
        UXTB     R7,R7
        ADDS     R0,R0,#+2
        CMP      R7,R0
        BLT.N    ??print_2d_array_3
// 3105         SERIAL_PROTOCOL((int)x);
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 3106       }
        ADDS     R5,R5,#+1
        CMP      R5,R6
        BLT.N    ??print_2d_array_1
// 3107       SERIAL_EOL();
??print_2d_array_0:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3108     #endif
// 3109     #ifdef SCAD_MESH_OUTPUT
// 3110       SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
// 3111     #endif
// 3112     for (uint8_t y = 0; y < sy; y++) {
        LDRB     R0,[SP, #+16]
        MOVS     R5,#+0
        CMP      R0,#+0
        BEQ.N    ??print_2d_array_4
        LDR.W    R0,??DataTable139_2
        LDR.W    R10,??DataTable139_8
        STR      R0,[SP, #+4]
        LDRB     R0,[SP, #+20]
        ADD      R9,R0,#+3
        B.N      ??print_2d_array_5
// 3113       #ifdef SCAD_MESH_OUTPUT
// 3114         SERIAL_PROTOCOLPGM(" [");           // open sub-array
// 3115       #else
// 3116         if (y < 10) SERIAL_PROTOCOLCHAR(' ');
??print_2d_array_6:
        CMP      R5,#+10
        BGE.N    ??print_2d_array_7
??print_2d_array_5:
        MOVS     R1,#+32
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3117         SERIAL_PROTOCOL((int)y);
??print_2d_array_7:
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 3118       #endif
// 3119       for (uint8_t x = 0; x < sx; x++) {
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.N    ??print_2d_array_8
        LDR      R6,[SP, #+4]
        MOV      R8,R10
        MOV      R7,R0
// 3120         SERIAL_PROTOCOLCHAR(' ');
??print_2d_array_9:
        MOVS     R1,#+32
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3121         //const float offset = fn(x, y);
// 3122         float offset;
// 3123 		switch(fn)
        LDRB     R0,[SP, #+24]
        CBZ.N    R0,??print_2d_array_10
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_11
        B.N      ??print_2d_array_12
// 3124 		{
// 3125 			case 0:	
// 3126 			if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
??print_2d_array_10:
        LDR.W    R0,??DataTable140
        LDRB     R0,[R0, #+66]
        CMP      R0,#+8
        BNE.N    ??print_2d_array_12
// 3127 				offset =z_values[x][y];
        LDR      R4,[R6, #+0]
        B.N      ??print_2d_array_12
// 3128 			break;
// 3129 			case 1:	
// 3130 			#if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3131 				offset =z_values_virt[x][y];	
// 3132 			#endif
// 3133 			break;
// 3134 			case 2:	
// 3135 				if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
??print_2d_array_11:
        LDR.W    R0,??DataTable140
        LDRB     R0,[R0, #+66]
        CMP      R0,#+32
        IT       EQ 
// 3136                    offset =mbl.z_values[x][y];		
        LDREQ    R4,[R8, #+0]
// 3137                           break;
// 3138 			default:		break;
// 3139 		}        
// 3140         if (!isnan(offset)) {
??print_2d_array_12:
        MOV      R0,R4
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??print_2d_array_13
// 3141           if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
        MOV      R0,R4
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??print_2d_array_14
        MOVS     R1,#+43
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3142           SERIAL_PROTOCOL_F(offset, precision);
??print_2d_array_14:
        LDRB     R0,[SP, #+20]
        STR      R0,[SP, #+0]
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R11
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        B.N      ??print_2d_array_15
// 3143         }
// 3144         else {
// 3145           #ifdef SCAD_MESH_OUTPUT
// 3146             for (uint8_t i = 3; i < precision + 3; i++)
// 3147               SERIAL_PROTOCOLCHAR(' ');
// 3148             SERIAL_PROTOCOLPGM("NAN");
// 3149           #else
// 3150             for (uint8_t i = 0; i < precision + 3; i++)
??print_2d_array_13:
        MOVS     R4,#+0
        B.N      ??print_2d_array_16
// 3151               SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
??print_2d_array_17:
        CBNZ.N   R4,??print_2d_array_18
??print_2d_array_16:
        MOVS     R1,#+32
        B.N      ??print_2d_array_19
??print_2d_array_18:
        MOVS     R1,#+61
??print_2d_array_19:
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADDS     R0,R4,#+1
        UXTB     R4,R0
        CMP      R4,R9
        BLT.N    ??print_2d_array_17
// 3152           #endif
// 3153         }
// 3154         #ifdef SCAD_MESH_OUTPUT
// 3155           if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
// 3156         #endif
// 3157       }
??print_2d_array_15:
        ADDS     R6,R6,#+48
        ADD      R8,R8,#+48
        SUBS     R7,R7,#+1
        BNE.N    ??print_2d_array_9
// 3158       #ifdef SCAD_MESH_OUTPUT
// 3159         SERIAL_PROTOCOLCHAR(' ');
// 3160         SERIAL_PROTOCOLCHAR(']');                     // close sub-array
// 3161         if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
// 3162       #endif
// 3163       SERIAL_EOL();
??print_2d_array_8:
        MOVS     R1,#+10
        MOV      R0,R11
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3164     }
        LDR      R0,[SP, #+4]
        ADDS     R0,R0,#+4
        STR      R0,[SP, #+4]
        ADDS     R5,R5,#+1
        LDRB     R0,[SP, #+16]
        ADD      R10,R10,#+4
        CMP      R5,R0
        BLT.N    ??print_2d_array_6
// 3165     #ifdef SCAD_MESH_OUTPUT
// 3166       SERIAL_PROTOCOLPGM("];");                       // close 2D array
// 3167     #endif
// 3168     SERIAL_EOL();
??print_2d_array_4:
        MOV      R0,R11
        ADD      SP,SP,#+28
          CFI CFA R13+36
        POP      {R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        B.W      ??Subroutine6_0
          CFI EndBlock cfiBlock41
// 3169   }
// 3170 
// 3171 #endif
// 3172 
// 3173 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 3174 
// 3175   /**
// 3176    * Extrapolate a single point from its neighbors
// 3177    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock42 Using cfiCommon0
          CFI Function _Z21extrapolate_one_pointhhaa
        THUMB
// 3178   static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
_Z21extrapolate_one_pointhhaa:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R10,R0
// 3179     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3180       if (DEBUGGING(LEVELING)) {
// 3181         SERIAL_ECHOPGM("Extrapolate [");
// 3182         if (x < 10) SERIAL_CHAR(' ');
// 3183         SERIAL_ECHO((int)x);
// 3184         SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
// 3185         SERIAL_CHAR(' ');
// 3186         if (y < 10) SERIAL_CHAR(' ');
// 3187         SERIAL_ECHO((int)y);
// 3188         SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
// 3189         SERIAL_CHAR(']');
// 3190       }
// 3191     #endif
// 3192     if (!isnan(z_values[x][y])) {
        LDR.W    R7,??DataTable139_2
        ADD      R0,R10,R10, LSL #+1
        MOV      R5,R1
        ADD      R8,R7,R0, LSL #+4
        MOV      R9,R5
        LDR      R0,[R8, R9, LSL #+2]
        MOV      R6,R2
        MOV      R4,R3
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??extrapolate_one_point_0
// 3193       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3194         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
// 3195       #endif
// 3196       return;  // Don't overwrite good values.
// 3197     }
// 3198     SERIAL_EOL();
        MOVS     R1,#+10
        LDR.W    R0,??DataTable139_6
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 3199 
// 3200     // Get X neighbors, Y neighbors, and XY neighbors
// 3201     const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
        ADD      R2,R6,R10
        UXTB     R2,R2
        ADDS     R0,R4,R5
        UXTB     R0,R0
        ADDS     R3,R6,R2
        UXTB     R3,R3
        ADDS     R1,R4,R0
// 3202     float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
        ADD      R6,R2,R2, LSL #+1
        ADD      R4,R3,R3, LSL #+1
        ADD      R2,R7,R6, LSL #+4
        ADD      R3,R7,R4, LSL #+4
        UXTB     R1,R1
        LDR      R7,[R3, R9, LSL #+2]
// 3203           b1 = z_values[x ][y1], b2 = z_values[x ][y2],
        LDR      R4,[R8, R0, LSL #+2]
// 3204           c1 = z_values[x1][y1], c2 = z_values[x2][y2];
        LDR      R10,[R2, R0, LSL #+2]
        LDR      R6,[R2, R9, LSL #+2]
        LDR      R5,[R8, R1, LSL #+2]
        LDR      R11,[R3, R1, LSL #+2]
// 3205 
// 3206     // Treat far unprobed points as zero, near as equal to far
// 3207     if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
        MOV      R0,R7
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R7,#+0
        MOV      R0,R6
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R6,R7
// 3208     if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
        MOV      R0,R5
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R5,#+0
        MOV      R0,R4
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R4,R5
// 3209     if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
        MOV      R0,R11
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R11,#+0
        MOV      R0,R10
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       EQ 
        MOVEQ    R10,R11
// 3210 
// 3211     const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
// 3212 
// 3213     // Take the average instead of the median
// 3214     z_values[x][y] = (a + b + c) / 3.0;
        MOV      R0,#+1073741824
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
        MOV      R0,#+1073741824
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable140_1  ;; 0x40400000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R8, R9, LSL #+2]
// 3215 
// 3216     // Median is robust (ignores outliers).
// 3217     // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
// 3218     //                                : ((c < b) ? b : (a < c) ? a : c);
// 3219   }
??extrapolate_one_point_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock42

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable125:
        DC32     0x47ae147b
// 3220 
// 3221   //Enable this if your SCARA uses 180Â° of total area
// 3222   //#define EXTRAPOLATE_FROM_EDGE
// 3223 
// 3224   #if ENABLED(EXTRAPOLATE_FROM_EDGE)
// 3225     #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
// 3226       #define HALF_IN_X
// 3227     #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
// 3228       #define HALF_IN_Y
// 3229     #endif
// 3230   #endif
// 3231 
// 3232   /**
// 3233    * Fill in the unprobed points (corners of circular print surface)
// 3234    * using linear extrapolation, away from the center.
// 3235    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock43 Using cfiCommon0
          CFI Function _Z30extrapolate_unprobed_bed_levelv
        THUMB
// 3236   static void extrapolate_unprobed_bed_level() {
_Z30extrapolate_unprobed_bed_levelv:
        PUSH     {R4-R9,R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
// 3237     #ifdef HALF_IN_X
// 3238       constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
// 3239     #else
// 3240       constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
        LDR.W    R1,??DataTable140
        LDRB     R0,[R1, #+96]
// 3241                         ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
// 3242                         xlen = ctrx1;
        ADDS     R1,R1,#+96
        SUBS     R2,R0,#+1
        ADD      R2,R2,R2, LSR #+31
        LDRB     R1,[R1, #+1]
        LSLS     R4,R2,#+23
        SUB      SP,SP,#+16
          CFI CFA R13+48
        SUBS     R2,R1,#+1
// 3243     #endif
// 3244 
// 3245     #ifdef HALF_IN_Y
// 3246       constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
// 3247     #else
// 3248       constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
// 3249                         ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
        LSRS     R1,R1,#+1
        LSRS     R4,R4,#+24
        STR      R1,[SP, #+4]
        STR      R4,[SP, #+0]
        ADD      R2,R2,R2, LSR #+31
// 3250                         ylen = ctry1;
// 3251     #endif
// 3252 
// 3253     for (uint8_t xo = 0; xo <= xlen; xo++)
        LDR      R1,[SP, #+0]
        LSLS     R2,R2,#+23
        MOVS     R7,#+0
        LSR      R8,R2,#+24
        CMP      R1,#+0
        BMI.N    ??extrapolate_unprobed_bed_level_0
        LSRS     R5,R0,#+1
// 3254       for (uint8_t yo = 0; yo <= ylen; yo++) {
??extrapolate_unprobed_bed_level_1:
        MOVS     R9,#+0
        BMI.N    ??extrapolate_unprobed_bed_level_2
        LDR      R6,[SP, #+4]
        MOV      R11,R8
// 3255         uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
// 3256         #ifndef HALF_IN_X
// 3257           const uint8_t x1 = ctrx1 - xo;
// 3258         #endif
// 3259         #ifndef HALF_IN_Y
// 3260           const uint8_t y1 = ctry1 - yo;
// 3261           #ifndef HALF_IN_X
// 3262             extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
??extrapolate_unprobed_bed_level_3:
        MOVS     R3,#+1
        MOVS     R2,#+1
        UXTB     R1,R11
        UXTB     R0,R4
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3263           #endif
// 3264           extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
        MOVS     R3,#+1
        MOV      R2,#-1
        UXTB     R1,R11
        UXTB     R0,R5
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3265         #endif
// 3266         #ifndef HALF_IN_X
// 3267           extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
        MOV      R3,#-1
        MOVS     R2,#+1
        UXTB     R1,R6
        UXTB     R0,R4
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3268         #endif
// 3269         extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
        MOV      R3,#-1
        MOV      R2,R3
        UXTB     R1,R6
        UXTB     R0,R5
          CFI FunCall _Z21extrapolate_one_pointhhaa
        BL       _Z21extrapolate_one_pointhhaa
// 3270       }
        ADD      R0,R9,#+1
        UXTB     R9,R0
        ADDS     R6,R6,#+1
        SUB      R11,R11,#+1
        CMP      R8,R9
        BGE.N    ??extrapolate_unprobed_bed_level_3
??extrapolate_unprobed_bed_level_2:
        ADDS     R7,R7,#+1
        LDR      R0,[SP, #+0]
        UXTB     R7,R7
        SUBS     R4,R4,#+1
        ADDS     R5,R5,#+1
        CMP      R0,R7
        BGE.N    ??extrapolate_unprobed_bed_level_1
// 3271 
// 3272   }
??extrapolate_unprobed_bed_level_0:
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R9,R11,PC}   ;; return
          CFI EndBlock cfiBlock43
// 3273 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock44 Using cfiCommon0
          CFI Function _Z28print_bilinear_leveling_gridv
        THUMB
// 3274   static void print_bilinear_leveling_grid() {
_Z28print_bilinear_leveling_gridv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 3275     SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
        LDR.W    R0,??DataTable140_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3276     /*
// 3277     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
// 3278       [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
// 3279     );
// 3280     */
// 3281     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,0);
        LDR.W    R0,??DataTable140
        LDRB     R1,[R0, #+97]
        LDRB     R0,[R0, #+96]
        POP      {R12,LR}
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R3,#+0
        MOVS     R2,#+3
          CFI FunCall _Z14print_2d_arrayhhhh
        B.N      _Z14print_2d_arrayhhhh
          CFI EndBlock cfiBlock44
// 3282   }
// 3283 
// 3284   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3285 
// 3286     #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3287     #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
// 3288     #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
// 3289     #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
// 3290     float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
// 3291     int bilinear_grid_spacing_virt[2] = { 0 };
// 3292     float bilinear_grid_factor_virt[2] = { 0 };
// 3293 
// 3294     static void print_bilinear_leveling_grid_virt() {
// 3295       SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
// 3296       /*
// 3297       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
// 3298         [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
// 3299       );
// 3300       */
// 3301       print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,1);
// 3302     }
// 3303 
// 3304     #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
// 3305     float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
// 3306       uint8_t ep = 0, ip = 1;
// 3307       if (!x || x == ABL_TEMP_POINTS_X - 1) {
// 3308         if (x) {
// 3309           ep = GRID_MAX_POINTS_X - 1;
// 3310           ip = GRID_MAX_POINTS_X - 2;
// 3311         }
// 3312         if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
// 3313           return LINEAR_EXTRAPOLATION(
// 3314             z_values[ep][y - 1],
// 3315             z_values[ip][y - 1]
// 3316           );
// 3317         else
// 3318           return LINEAR_EXTRAPOLATION(
// 3319             bed_level_virt_coord(ep + 1, y),
// 3320             bed_level_virt_coord(ip + 1, y)
// 3321           );
// 3322       }
// 3323       if (!y || y == ABL_TEMP_POINTS_Y - 1) {
// 3324         if (y) {
// 3325           ep = GRID_MAX_POINTS_Y - 1;
// 3326           ip = GRID_MAX_POINTS_Y - 2;
// 3327         }
// 3328         if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
// 3329           return LINEAR_EXTRAPOLATION(
// 3330             z_values[x - 1][ep],
// 3331             z_values[x - 1][ip]
// 3332           );
// 3333         else
// 3334           return LINEAR_EXTRAPOLATION(
// 3335             bed_level_virt_coord(x, ep + 1),
// 3336             bed_level_virt_coord(x, ip + 1)
// 3337           );
// 3338       }
// 3339       return z_values[x - 1][y - 1];
// 3340     }
// 3341 
// 3342     static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
// 3343       return (
// 3344           p[i-1] * -t * sq(1 - t)
// 3345         + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
// 3346         + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
// 3347         - p[i+2] * sq(t) * (1 - t)
// 3348       ) * 0.5;
// 3349     }
// 3350 
// 3351     static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
// 3352       float row[4], column[4];
// 3353       for (uint8_t i = 0; i < 4; i++) {
// 3354         for (uint8_t j = 0; j < 4; j++) {
// 3355           column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
// 3356         }
// 3357         row[i] = bed_level_virt_cmr(column, 1, ty);
// 3358       }
// 3359       return bed_level_virt_cmr(row, 1, tx);
// 3360     }
// 3361 
// 3362     void bed_level_virt_interpolate() {
// 3363       bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3364       bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
// 3365       bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
// 3366       bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
// 3367       for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
// 3368         for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
// 3369           for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
// 3370             for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
// 3371               if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
// 3372                 continue;
// 3373               z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
// 3374                 bed_level_virt_2cmr(
// 3375                   x + 1,
// 3376                   y + 1,
// 3377                   (float)tx / (BILINEAR_SUBDIVISIONS),
// 3378                   (float)ty / (BILINEAR_SUBDIVISIONS)
// 3379                 );
// 3380             }
// 3381     }
// 3382   #endif // ABL_BILINEAR_SUBDIVISION
// 3383 
// 3384   // Refresh after other values have been updated

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock45 Using cfiCommon0
          CFI Function _Z17refresh_bed_levelv
        THUMB
// 3385   void refresh_bed_level() {
_Z17refresh_bed_levelv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 3386     bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
        LDR.W    R4,??DataTable137
        LDR      R0,[R4, #+8]
        CBZ.N    R0,??refresh_bed_level_0
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable140_3  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
??refresh_bed_level_0:
        STR      R0,[R4, #+24]
// 3387     bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
        LDR      R0,[R4, #+12]
        CBZ.N    R0,??refresh_bed_level_1
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable140_3  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
??refresh_bed_level_1:
        STR      R0,[R4, #+28]
// 3388     #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 3389       bed_level_virt_interpolate();
// 3390     #endif
// 3391   }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock45

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable128:
        DC32     0x3f847ae1
// 3392 
// 3393 #endif // AUTO_BED_LEVELING_BILINEAR
// 3394 
// 3395 /**
// 3396  * Home an individual linear axis
// 3397  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock46 Using cfiCommon0
          CFI Function _Z14do_homing_move8AxisEnumff
        THUMB
// 3398 static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
_Z14do_homing_move8AxisEnumff:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
// 3399 
// 3400   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3401     if (DEBUGGING(LEVELING)) {
// 3402       SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
// 3403       SERIAL_ECHOPAIR(", ", distance);
// 3404       SERIAL_ECHOPAIR(", ", fr_mm_s);
// 3405       SERIAL_CHAR(')');
// 3406       SERIAL_EOL();
// 3407     }
// 3408   #endif
// 3409 
// 3410   //#if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
// 3411   #if HOMING_Z_WITH_PROBE
// 3412     //const 
// 3413     bool deploy_bltouch;
// 3414   if(MKSTOUCH == 1)
        LDR.W    R9,??DataTable130
        MOV      R5,R0
        LDRB     R0,[R9, #+256]
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R8,R1
        MOV      R7,R2
        CMP      R0,#+1
        BNE.N    ??do_homing_move_0
// 3415   {
// 3416   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)){	/*--mks cfg--*/
        LDRSB    R0,[R9, #+7]
        CMP      R0,#+0
        BPL.N    ??do_homing_move_0
        LDRB     R0,[R9, #+153]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_0
// 3417     deploy_bltouch = (axis == Z_AXIS && distance < 0);
        CMP      R5,#+2
        BNE.N    ??do_homing_move_1
        MOV      R0,R8
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??do_homing_move_1
        MOVS     R4,#+1
// 3418     if (deploy_bltouch) set_bltouch_deployed(true);
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
        B.N      ??do_homing_move_0
// 3419     }
// 3420   }
??do_homing_move_1:
        MOVS     R4,#+0
// 3421   #endif
// 3422 
// 3423   #if QUIET_PROBING
// 3424     if (axis == Z_AXIS) probing_pause(true);
// 3425   #endif
// 3426 
// 3427   // Tell the planner the axis is at 0
// 3428   current_position[axis] = 0;
??do_homing_move_0:
        LDR.W    R6,??DataTable137_1
        ADD      R10,R6,R5, LSL #+2
        MOVS     R0,#+0
        STR      R0,[R10, #+16]
// 3429 
// 3430   //#if IS_SCARA
// 3431   if(MACHINETPYE&IS_SCARA)
        MOV      R1,#+768
        LDRH     R0,[R9, #+88]
        TST      R0,R1
        BEQ.N    ??do_homing_move_2
// 3432   {
// 3433     SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 3434     current_position[axis] = distance;
        STR      R8,[R10, #+16]
// 3435     if(MACHINETPYE&IS_SCARA)
        MOV      R1,#+768
        LDRH     R0,[R9, #+88]
        TST      R0,R1
        ADD      R0,R6,#+16
        BEQ.N    ??do_homing_move_3
// 3436 		inverse_kinematics_MORGAN_SCARA(current_position);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??do_homing_move_4
// 3437 	else
// 3438         inverse_kinematics(current_position);
??do_homing_move_3:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 3439     planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
??do_homing_move_4:
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        IT       NE 
        STRNE    R7,[SP, #+8]
        BNE.N    ??do_homing_move_5
        LDR.W    R0,??DataTable130_1
        ADD      R0,R0,R5, LSL #+2
        LDR      R0,[R0, #+4]
        STR      R0,[SP, #+8]
??do_homing_move_5:
        ADD      R3,R6,#+28
        LDRB     R1,[R6, #+10]
        LDR.W    R0,??DataTable140_4
        LDR      R2,[R0, #+68]
        STR      R1,[SP, #+4]
        ADD      R1,SP,#+8
        STR      R1,[SP, #+0]
        LDR      R1,[R0, #+64]
        LDR      R0,[R0, #+60]
        B.N      ??do_homing_move_6
// 3440   }
// 3441   //#else
// 3442   else
// 3443   {
// 3444     sync_plan_position();
??do_homing_move_2:
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 3445     current_position[axis] = distance;
// 3446     planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate_mm_s[axis], active_extruder);
        MOV      R0,R7
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        STR      R8,[R10, #+16]
        IT       NE 
        STRNE    R7,[SP, #+8]
        BNE.N    ??do_homing_move_7
        LDR.N    R0,??DataTable130_1
        ADD      R0,R0,R5, LSL #+2
        LDR      R0,[R0, #+4]
        STR      R0,[SP, #+8]
??do_homing_move_7:
        ADD      R3,R6,#+28
        LDRB     R0,[R6, #+10]
        LDR      R2,[R6, #+24]
        LDR      R1,[R6, #+20]
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        LDR      R0,[R6, #+16]
??do_homing_move_6:
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
// 3447   }
// 3448   //#endif
// 3449 
// 3450   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 3451 
// 3452   #if QUIET_PROBING
// 3453     if (axis == Z_AXIS) probing_pause(false);
// 3454   #endif
// 3455 
// 3456   #if HOMING_Z_WITH_PROBE //&& ENABLED(BLTOUCH)
// 3457   if(MKSTOUCH == 1)
        LDRB     R0,[R9, #+256]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_8
// 3458   {
// 3459     if((Z_HOME_DIR < 0) &&  (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
        LDRSB    R0,[R9, #+7]
        CMP      R0,#+0
        BPL.N    ??do_homing_move_8
        LDRB     R0,[R9, #+153]
        CMP      R0,#+1
        BNE.N    ??do_homing_move_8
// 3460     {
// 3461         if (deploy_bltouch) set_bltouch_deployed(false);
        UXTB     R4,R4
        CBZ.N    R4,??do_homing_move_8
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 3462     }
// 3463   }
// 3464   #endif
// 3465 
// 3466   endstops.hit_on_purpose();
??do_homing_move_8:
        LDR.W    R1,??DataTable131
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
// 3467 
// 3468   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3469     if (DEBUGGING(LEVELING)) {
// 3470       SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
// 3471       SERIAL_CHAR(')');
// 3472       SERIAL_EOL();
// 3473     }
// 3474   #endif
// 3475 }
        B.W      ?Subroutine2
          CFI EndBlock cfiBlock46

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129:
        DC32     axis_relative_modes+0x18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_1:
        DC32     saved_feedrate_percentage

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_2:
        DC32     `?<Constant "Home ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_3:
        DC32     `?<Constant " first\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_4:
        DC32     0x40012c34

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_5:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_6:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_7:
        DC32     `?<Constant "STOP called because o...">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable129_8:
        DC32     _ZN8Endstops15z_probe_enabledE
// 3476 
// 3477 /**
// 3478  * TMC2130 specific sensorless homing using stallGuard2.
// 3479  * stallGuard2 only works when in spreadCycle mode.
// 3480  * spreadCycle and stealthChop are mutually exclusive.
// 3481  */
// 3482 #if ENABLED(SENSORLESS_HOMING)
// 3483   template<typename TMC>
// 3484   void tmc_sensorless_homing(TMC &st, bool enable=true) {
// 3485     #if ENABLED(STEALTHCHOP)
// 3486       if (enable) {
// 3487         st.coolstep_min_speed(1024UL * 1024UL - 1UL);
// 3488         st.stealthChop(0);
// 3489       }
// 3490       else {
// 3491         st.coolstep_min_speed(0);
// 3492         st.stealthChop(1);
// 3493       }
// 3494     #endif
// 3495 
// 3496     st.diag1_stall(enable ? 1 : 0);
// 3497   }
// 3498 #endif
// 3499 
// 3500 /**
// 3501  * Home an individual "raw axis" to its endstop.
// 3502  * This applies to XYZ on Cartesian and Core robots, and
// 3503  * to the individual ABC steppers on DELTA and SCARA.
// 3504  *
// 3505  * At the end of the procedure the axis is marked as
// 3506  * homed and the current position of that axis is updated.
// 3507  * Kinematic robots should wait till all axes are homed
// 3508  * before updating the current position.
// 3509  */
// 3510 
// 3511 #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
// 3512 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock47 Using cfiCommon0
          CFI Function _Z8homeaxis8AxisEnum
        THUMB
// 3513 static void homeaxis(const AxisEnum axis) {
_Z8homeaxis8AxisEnum:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
// 3514 
// 3515 #define CAN_HOME(A) \ 
// 3516     (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
// 3517 
// 3518   //#if IS_SCARA
// 3519   if(MACHINETPYE&IS_SCARA)
        LDR.W    R11,??DataTable130
        MOV      R9,R0
        LDRH     R0,[R11, #+88]
        MOV      R1,#+768
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOV      R5,R9
        TST      R0,R1
        BEQ.N    ??homeaxis_0
// 3520   {
// 3521     // Only Z homing (with probe) is permitted
// 3522     if (axis != Z_AXIS) { BUZZ(100, 880); return; }
        CMP      R5,#+2
        BEQ.N    ??homeaxis_1
// 3523   }
// 3524   //#else
// 3525   else
// 3526    {
// 3527     if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
// 3528    }
// 3529   //#endif
// 3530 
// 3531   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3532     if (DEBUGGING(LEVELING)) {
// 3533       SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
// 3534       SERIAL_CHAR(')');
// 3535       SERIAL_EOL();
// 3536     }
// 3537   #endif
// 3538 
// 3539   int axis_home_dir =
// 3540     #if ENABLED(DUAL_X_CARRIAGE)
// 3541       (axis == X_AXIS) ? x_home_dir(active_extruder) :
// 3542     #endif
// 3543     home_dir(axis);
// 3544 
// 3545   // Homing Z towards the bed? Deploy the Z probe or endstop.
// 3546   #if HOMING_Z_WITH_PROBE
// 3547   
// 3548   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
// 3549   {
// 3550     if (axis == Z_AXIS && DEPLOY_PROBE()) return;
// 3551   }
// 3552   #endif
// 3553 
// 3554   // Set flags for X, Y, Z motor locking
// 3555   #if ENABLED(X_DUAL_ENDSTOPS)
// 3556     if (axis == X_AXIS) stepper.set_homing_flag_x(true);
// 3557   #endif
// 3558   #if ENABLED(Y_DUAL_ENDSTOPS)
// 3559     if (axis == Y_AXIS) stepper.set_homing_flag_y(true);
// 3560   #endif
// 3561   #if 1//ENABLED(Z_DUAL_ENDSTOPS)
// 3562     if (axis == Z_AXIS) stepper.set_homing_flag_z(true);
// 3563   #endif
// 3564 
// 3565   // Disable stealthChop if used. Enable diag1 pin on driver.
// 3566   #if ENABLED(SENSORLESS_HOMING)
// 3567     #if ENABLED(X_IS_TMC2130)
// 3568       if (axis == X_AXIS) tmc_sensorless_homing(stepperX);
// 3569     #endif
// 3570     #if ENABLED(Y_IS_TMC2130)
// 3571       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY);
// 3572     #endif
// 3573   #endif
// 3574 
// 3575   // Fast move towards endstop until triggered
// 3576   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3577     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
// 3578   #endif
// 3579   do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
// 3580 
// 3581   // When homing Z with probe respect probe clearance
// 3582   /*
// 3583   const float bump = axis_home_dir * (
// 3584     #if HOMING_Z_WITH_PROBE
// 3585       (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
// 3586     #endif
// 3587     home_bump_mm(axis)
// 3588   );
// 3589   */
// 3590     float bump = 0;
// 3591     #if HOMING_Z_WITH_PROBE
// 3592         if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))    /*--mks cfg--*/
// 3593             bump = axis_home_dir*((axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :home_bump_mm(axis));
// 3594         else
// 3595             bump = axis_home_dir *home_bump_mm(axis);
// 3596     #else
// 3597         bump = axis_home_dir *home_bump_mm(axis);
// 3598     #endif
// 3599 
// 3600   // If a second homing move is configured...
// 3601   if (bump) {
// 3602     // Move away from the endstop by the axis HOME_BUMP_MM
// 3603     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3604       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
// 3605     #endif
// 3606     do_homing_move(axis, -bump);
// 3607 
// 3608     // Slow move towards endstop until triggered
// 3609     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3610       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
// 3611     #endif
// 3612     do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
// 3613   }
// 3614 
// 3615   /**
// 3616    * Home axes that have dual endstops... differently
// 3617    */
// 3618   #if 1//ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 3619     const bool pos_dir = axis_home_dir > 0;
// 3620     #if ENABLED(X_DUAL_ENDSTOPS)
// 3621       if (axis == X_AXIS) {
// 3622         const bool lock_x1 = pos_dir ? (x_endstop_adj > 0) : (x_endstop_adj < 0);
// 3623         const float adj = FABS(x_endstop_adj);
// 3624         if (lock_x1) stepper.set_x_lock(true); else stepper.set_x2_lock(true);
// 3625         do_homing_move(axis, pos_dir ? -adj : adj);
// 3626         if (lock_x1) stepper.set_x_lock(false); else stepper.set_x2_lock(false);
// 3627         stepper.set_homing_flag_x(false);
// 3628       }
// 3629     #endif
// 3630     #if ENABLED(Y_DUAL_ENDSTOPS)
// 3631       if (axis == Y_AXIS) {
// 3632         const bool lock_y1 = pos_dir ? (y_endstop_adj > 0) : (y_endstop_adj < 0);
// 3633         const float adj = FABS(y_endstop_adj);
// 3634         if (lock_y1) stepper.set_y_lock(true); else stepper.set_y2_lock(true);
// 3635         do_homing_move(axis, pos_dir ? -adj : adj);
// 3636         if (lock_y1) stepper.set_y_lock(false); else stepper.set_y2_lock(false);
// 3637         stepper.set_homing_flag_y(false);
// 3638       }
// 3639     #endif
// 3640     //#if ENABLED(Z_DUAL_ENDSTOPS)
// 3641     if(Z_DUAL_ENDSTOPS==1)
// 3642     {
// 3643       if (axis == Z_AXIS) {
// 3644         const bool lock_z1 = pos_dir ? (z_endstop_adj > 0) : (z_endstop_adj < 0);
// 3645         const float adj = FABS(z_endstop_adj);
// 3646         if (lock_z1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
// 3647         do_homing_move(axis, pos_dir ? -adj : adj);
// 3648         if (lock_z1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
// 3649         stepper.set_homing_flag_z(false);
// 3650       }
// 3651     }
// 3652     //#endif
// 3653   #endif
// 3654 
// 3655   //#if IS_SCARA
// 3656   if(MACHINETPYE&IS_SCARA)
// 3657   {
// 3658     set_axis_is_at_home(axis);
// 3659     SYNC_PLAN_POSITION_KINEMATIC();
// 3660   }
// 3661   //#elif ENABLED(DELTA)
// 3662   else if(MACHINETPYE == DELTA) {
// 3663 
// 3664     // Delta has already moved all three towers up in G28
// 3665     // so here it re-homes each tower in turn.
// 3666     // Delta homing treats the axes as normal linear axes.
// 3667 
// 3668     // retrace by the amount specified in delta_endstop_adj + additional 0.1mm in order to have minimum steps
// 3669     if (delta_endstop_adj[axis] * Z_HOME_DIR <= 0) {
// 3670       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3671         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("delta_endstop_adj:");
// 3672       #endif
// 3673       do_homing_move(axis, delta_endstop_adj[axis] - 0.1 * Z_HOME_DIR);
// 3674     }
// 3675   }
// 3676   //#else
// 3677   else
// 3678   {
// 3679     // For cartesian/core machines,
// 3680     // set the axis to its home position
// 3681     set_axis_is_at_home(axis);
// 3682     sync_plan_position();
// 3683 
// 3684     destination[axis] = current_position[axis];
// 3685 
// 3686     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3687       if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
// 3688     #endif
// 3689   }
// 3690   //#endif
// 3691 
// 3692   // Re-enable stealthChop if used. Disable diag1 pin on driver.
// 3693   #if ENABLED(SENSORLESS_HOMING)
// 3694     #if ENABLED(X_IS_TMC2130)
// 3695       if (axis == X_AXIS) tmc_sensorless_homing(stepperX, false);
// 3696     #endif
// 3697     #if ENABLED(Y_IS_TMC2130)
// 3698       if (axis == Y_AXIS) tmc_sensorless_homing(stepperY, false);
// 3699     #endif
// 3700   #endif
// 3701 
// 3702   // Put away the Z probe
// 3703   #if HOMING_Z_WITH_PROBE
// 3704   if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))	/*--mks cfg--*/
// 3705   {    
// 3706     if (axis == Z_AXIS && STOW_PROBE()) return;
// 3707    }
// 3708   #endif
// 3709 
// 3710   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 3711     if (DEBUGGING(LEVELING)) {
// 3712       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
// 3713       SERIAL_CHAR(')');
// 3714       SERIAL_EOL();
// 3715     }
// 3716   #endif
// 3717 } // homeaxis()
        B.N      ?Subroutine5
??homeaxis_0:
        CMP      R9,#+0
        BNE.N    ??homeaxis_2
        LDRSB    R0,[R11, #+5]
        CBNZ.N   R0,??homeaxis_1
??homeaxis_2:
        CMP      R5,#+1
        BNE.N    ??homeaxis_3
        ADD      R0,R11,#+5
        LDRSB    R0,[R0, R5]
        CMP      R0,#+0
        BEQ.W    ??homeaxis_4
??homeaxis_1:
        ADDW     R10,R11,#+5
        LDR.W    R8,??DataTable130_1
        LDRSB    R0,[R10, #+2]
        LDRSB    R7,[R5, R8]
        CMP      R0,#+0
        BPL.N    ??homeaxis_5
        LDRB     R0,[R11, #+153]
        CMP      R0,#+1
        IT       EQ 
        CMPEQ    R5,#+2
        BNE.N    ??homeaxis_5
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CBZ.N    R0,??homeaxis_6
        B.N      ?Subroutine5
??homeaxis_3:
        CMP      R5,#+2
        BNE.W    ??homeaxis_4
        ADD      R0,R11,#+5
        LDRSB    R0,[R0, R5]
        CMP      R0,#+0
        BNE.N    ??homeaxis_1
        B.N      ?Subroutine5
??homeaxis_5:
        CMP      R5,#+2
        BNE.N    ??homeaxis_7
??homeaxis_6:
        LDR.W    R1,??DataTable140_5
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
??homeaxis_7:
        ADD      R4,R8,R5, LSL #+2
        LDR      R0,[R4, #+56]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R3,??DataTable140_6  ;; 0x3ff80000
        MOVS     R2,#+0
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDRD     R2,R3,[SP, #+0]
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOVS     R2,#+0
        MOV      R0,R9
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
        LDRSB    R0,[R10, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_8
        LDRB     R0,[R11, #+153]
        CMP      R0,#+1
        BNE.N    ??homeaxis_8
        CMP      R5,#+2
        BNE.N    ??homeaxis_9
        ADD      R0,R11,#+88
        LDR      R6,[R0, #+16]
        LDR      R0,[R8, #+76]
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??homeaxis_10
        MOV      R6,R0
        B.N      ??homeaxis_10
??homeaxis_9:
        LDR      R6,[R4, #+68]
??homeaxis_10:
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R6
        B.N      ??homeaxis_11
??homeaxis_8:
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+68]
??homeaxis_11:
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        MOV      R8,R0
        BEQ.N    ??homeaxis_12
        MOVS     R2,#+0
        EOR      R1,R8,#0x80000000
        MOV      R0,R9
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
        LDRSH    R1,[R11, #+88]
        ADD      R0,SP,#+0
        CMP      R1,#+2
        BNE.N    ??homeaxis_13
        MOVS     R1,#+10
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        B.N      ??homeaxis_14
??homeaxis_13:
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
        STR      R1,[R0, #+4]
        MOVS     R1,#+4
??homeaxis_14:
        STR      R1,[R0, #+8]
        LDRB     R6,[R0, R5, LSL #+2]
        CBNZ.N   R6,??homeaxis_15
        LDR.W    R0,??DataTable140_7
        MOVS     R6,#+10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable140_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??homeaxis_15:
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R4,R0
        MOV      R0,#+1073741824
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R2,R4
        MOV      R0,R9
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
??homeaxis_12:
        CMP      R7,#+1
        ITE      GE 
        MOVGE    R2,#+1
        MOVLT    R2,#+0
        LDRB     R0,[R11, #+258]
        CMP      R0,#+1
        IT       EQ 
        CMPEQ    R5,#+2
        BNE.N    ??homeaxis_16
        LDR.W    R0,??DataTable140_4
        LDR      R0,[R0, #+100]
        CBZ.N    R2,??homeaxis_17
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        B.N      ??homeaxis_18
??homeaxis_17:
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
??homeaxis_18:
        ITE      CC 
        MOVCC    R7,#+1
        MOVCS    R7,#+0
        BIC      R1,R0,#0x80000000
        CMP      R7,#+0
        ITTEE    NE 
        MOVNE    R0,#+1
        LDRNE.W  R3,??DataTable140_9
        MOVEQ    R0,#+1
        LDREQ.W  R3,??DataTable140_10
        STRB     R0,[R3, #+0]
        CBZ.N    R2,??homeaxis_19
        EOR      R1,R1,#0x80000000
??homeaxis_19:
        MOVS     R2,#+0
        MOV      R0,R9
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
        CMP      R7,#+0
        ITTEE    NE 
        MOVNE    R0,#+0
        LDRNE.W  R1,??DataTable140_9
        MOVEQ    R0,#+0
        LDREQ.W  R1,??DataTable140_10
        STRB     R0,[R1, #+0]
        LDR.W    R1,??DataTable140_5
        STRB     R0,[R1, #+0]
??homeaxis_16:
        MOV      R1,#+768
        LDRSH    R0,[R11, #+88]
        TST      R0,R1
        BEQ.N    ??homeaxis_20
        MOV      R0,R9
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??homeaxis_21
??homeaxis_20:
        CMP      R0,#+2
        BNE.N    ??homeaxis_22
        LDR.W    R0,??DataTable140_4
        LDRSB    R7,[R10, #+2]
        ADD      R0,R0,R5, LSL #+2
        LDR      R4,[R0, #+104]
        MOV      R0,R7
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BHI.N    ??homeaxis_21
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R6,R0
        MOV      R4,R1
        MOV      R0,R7
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.W    R2,??DataTable140_11  ;; 0x9999999a
        LDR.W    R3,??DataTable140_12  ;; 0x3fb99999
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R6
        MOV      R1,R4
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R0
        MOVS     R2,#+0
        MOV      R0,R9
          CFI FunCall _Z14do_homing_move8AxisEnumff
        BL       _Z14do_homing_move8AxisEnumff
        B.N      ??homeaxis_21
??homeaxis_22:
        MOV      R0,R9
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        LDR.W    R0,??DataTable137_1
        ADD      R0,R0,R5, LSL #+2
        LDR      R1,[R0, #+16]
        STR      R1,[R0, #+32]
??homeaxis_21:
        LDRSB    R0,[R10, #+2]
        CMP      R0,#+0
        BPL.N    ??homeaxis_4
        LDRB     R0,[R11, #+153]
        CMP      R0,#+1
        ITTT     EQ 
        CMPEQ    R5,#+2
        MOVEQ    R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BLEQ     _Z18set_probe_deployedb
          CFI EndBlock cfiBlock47
??homeaxis_4:
        REQUIRE ?Subroutine5
        ;; // Fall through to label ?Subroutine5

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock48 Using cfiCommon0
          CFI NoFunction
          CFI NoCalls _Z16mks_get_commandsv
          CFI NoCalls _Z28bilinear_line_to_destinationftt
          CFI NoCalls _Z8homeaxis8AxisEnum
          CFI CFA R13+56
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine5:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock48
// 3718 
// 3719 #if ENABLED(FWRETRACT)
// 3720 
// 3721   /**
// 3722    * Retract or recover according to firmware settings
// 3723    *
// 3724    * This function handles retract/recover moves for G10 and G11,
// 3725    * plus auto-retract moves sent from G0/G1 when E-only moves are done.
// 3726    *
// 3727    * To simplify the logic, doubled retract/recover moves are ignored.
// 3728    *
// 3729    * Note: Z lift is done transparently to the planner. Aborting
// 3730    *       a print between G10 and G11 may corrupt the Z position.
// 3731    *
// 3732    * Note: Auto-retract will apply the set Z hop in addition to any Z hop
// 3733    *       included in the G-code. Use M207 Z0 to to prevent double hop.
// 3734    */
// 3735   void retract(const bool retracting
// 3736     #if EXTRUDERS > 1
// 3737       , bool swapping = false
// 3738     #endif
// 3739   ) {
// 3740 
// 3741     static float hop_amount = 0.0;  // Total amount lifted, for use in recover
// 3742 
// 3743     // Prevent two retracts or recovers in a row
// 3744     if (retracted[active_extruder] == retracting) return;
// 3745 
// 3746     // Prevent two swap-retract or recovers in a row
// 3747     #if EXTRUDERS > 1
// 3748       // Allow G10 S1 only after G10
// 3749       if (swapping && retracted_swap[active_extruder] == retracting) return;
// 3750       // G11 priority to recover the long retract if activated
// 3751       if (!retracting) swapping = retracted_swap[active_extruder];
// 3752     #else
// 3753       const bool swapping = false;
// 3754     #endif
// 3755 
// 3756     /* // debugging
// 3757       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3758       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3759       SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
// 3760       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3761         SERIAL_ECHOPAIR("retracted[", i);
// 3762         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3763         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3764         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3765       }
// 3766       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3767       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3768     //*/
// 3769 
// 3770     const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
// 3771     const float old_feedrate_mm_s = feedrate_mm_s;
// 3772 
// 3773     // The current position will be the destination for E and Z moves
// 3774     set_destination_from_current();
// 3775     stepper.synchronize();  // Wait for buffered moves to complete
// 3776 
// 3777     const float renormalize = 1.0 / planner.e_factor[active_extruder];
// 3778 
// 3779     if (retracting) {
// 3780       // Retract by moving from a faux E position back to the current E position
// 3781       feedrate_mm_s = retract_feedrate_mm_s;
// 3782       current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) * renormalize;
// 3783       sync_plan_position_e();
// 3784       prepare_move_to_destination();
// 3785 
// 3786       // Is a Z hop set, and has the hop not yet been done?
// 3787       if (has_zhop && !hop_amount) {
// 3788         hop_amount += retract_zlift;                        // Carriage is raised for retraction hop
// 3789         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3790         current_position[Z_AXIS] -= retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3791         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3792         prepare_move_to_destination();                      // Raise up to the old current pos
// 3793         feedrate_mm_s = retract_feedrate_mm_s;              // Restore feedrate
// 3794       }
// 3795     }
// 3796     else {
// 3797       // If a hop was done and Z hasn't changed, undo the Z hop
// 3798       if (hop_amount) {
// 3799         current_position[Z_AXIS] += retract_zlift;          // Pretend current pos is lower. Next move raises Z.
// 3800         SYNC_PLAN_POSITION_KINEMATIC();                     // Set the planner to the new position
// 3801         feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];  // Z feedrate to max
// 3802         prepare_move_to_destination();                      // Raise up to the old current pos
// 3803         hop_amount = 0.0;                                   // Clear hop
// 3804       }
// 3805 
// 3806       // A retract multiplier has been added here to get faster swap recovery
// 3807       feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
// 3808 
// 3809       const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
// 3810       current_position[E_AXIS] -= move_e * renormalize;
// 3811       sync_plan_position_e();
// 3812       prepare_move_to_destination();                        // Recover E
// 3813     }
// 3814 
// 3815     feedrate_mm_s = old_feedrate_mm_s;                      // Restore original feedrate
// 3816 
// 3817     retracted[active_extruder] = retracting;                // Active extruder now retracted / recovered
// 3818 
// 3819     // If swap retract/recover update the retracted_swap flag too
// 3820     #if EXTRUDERS > 1
// 3821       if (swapping) retracted_swap[active_extruder] = retracting;
// 3822     #endif
// 3823 
// 3824     /* // debugging
// 3825       SERIAL_ECHOLNPAIR("retracting ", retracting);
// 3826       SERIAL_ECHOLNPAIR("swapping ", swapping);
// 3827       SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
// 3828       for (uint8_t i = 0; i < EXTRUDERS; ++i) {
// 3829         SERIAL_ECHOPAIR("retracted[", i);
// 3830         SERIAL_ECHOLNPAIR("] ", retracted[i]);
// 3831         SERIAL_ECHOPAIR("retracted_swap[", i);
// 3832         SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
// 3833       }
// 3834       SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
// 3835       SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
// 3836     //*/
// 3837 
// 3838   }
// 3839 
// 3840 #endif // FWRETRACT
// 3841 
// 3842 #if ENABLED(MIXING_EXTRUDER)
// 3843 
// 3844   void normalize_mix() {
// 3845     float mix_total = 0.0;
// 3846     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
// 3847     // Scale all values if they don't add up to ~1.0
// 3848     if (!NEAR(mix_total, 1.0)) {
// 3849       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
// 3850       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
// 3851     }
// 3852   }
// 3853 
// 3854   #if ENABLED(DIRECT_MIXING_IN_G1)
// 3855     // Get mixing parameters from the GCode
// 3856     // The total "must" be 1.0 (but it will be normalized)
// 3857     // If no mix factors are given, the old mix is preserved
// 3858     void gcode_get_mix() {
// 3859       const char* mixing_codes = "ABCDHI";
// 3860       byte mix_bits = 0;
// 3861       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
// 3862         if (parser.seenval(mixing_codes[i])) {
// 3863           SBI(mix_bits, i);
// 3864           float v = parser.value_float();
// 3865           NOLESS(v, 0.0);
// 3866           mixing_factor[i] = RECIPROCAL(v);
// 3867         }
// 3868       }
// 3869       // If any mixing factors were included, clear the rest
// 3870       // If none were included, preserve the last mix
// 3871       if (mix_bits) {
// 3872         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 3873           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
// 3874         normalize_mix();
// 3875       }
// 3876     }
// 3877   #endif
// 3878 
// 3879 #endif
// 3880 
// 3881 /**
// 3882  * ***************************************************************************
// 3883  * ***************************** G-CODE HANDLING *****************************
// 3884  * ***************************************************************************
// 3885  */
// 3886 
// 3887 /**
// 3888  * Set XYZE destination and feedrate from the current GCode command
// 3889  *
// 3890  *  - Set destination from included axis codes
// 3891  *  - Set to current for missing axis codes
// 3892  *  - Set the feedrate, if included
// 3893  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock49 Using cfiCommon0
          CFI Function _Z21gcode_get_destinationv
        THUMB
// 3894 void gcode_get_destination() {
_Z21gcode_get_destinationv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
// 3895   LOOP_XYZE(i) {
        LDR.N    R5,??DataTable137_1
        LDR.W    R8,??DataTable140_13
        MOV      R6,R5
        ADD      R7,R5,#+16
        ADD      R4,R5,#+32
        MOV      R9,#+4
// 3896     if (parser.seen(axis_codes[i])) {
??gcode_get_destination_0:
        LDRSB    R0,[R8, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??gcode_get_destination_1
// 3897       const float v = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRB     R1,[R6, #+0]
        LDRB     R2,[R5, #+11]
        ORRS     R1,R2,R1
        IT       NE 
        LDRNE    R1,[R7, #+0]
// 3898       //destination[i] = i == E_AXIS ? v : LOGICAL_TO_NATIVE(v, i);
// 3899       destination[i] = v;
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        B.N      ??gcode_get_destination_2
// 3900     }
// 3901     else
// 3902       destination[i] = current_position[i];
??gcode_get_destination_1:
        LDR      R0,[R7, #+0]
// 3903   }
??gcode_get_destination_2:
        ADDS     R7,R7,#+4
        ADDS     R6,R6,#+1
        STR      R0,[R4], #+4
        ADD      R8,R8,#+1
        SUBS     R9,R9,#+1
        BNE.N    ??gcode_get_destination_0
// 3904 
// 3905   if (parser.linearval('F') > 0.0)
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_get_destination_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_get_destination_3
// 3906     feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??DataTable132  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R5, #+112]
// 3907 
// 3908   #if ENABLED(PRINTCOUNTER)
// 3909     if (!DEBUGGING(DRYRUN))
// 3910       print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
// 3911   #endif
// 3912 
// 3913   // Get ABCDHI mixing factors
// 3914   #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
// 3915     gcode_get_mix();
// 3916   #endif
// 3917 }
??gcode_get_destination_3:
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock49

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable130:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable130_1:
        DC32     home_dir_P
// 3918 
// 3919 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 3920 
// 3921   /**
// 3922    * Output a "busy" message at regular intervals
// 3923    * while the machine is not accepting commands.
// 3924    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock50 Using cfiCommon0
          CFI Function _Z14host_keepalivev
        THUMB
// 3925   void host_keepalive() {
_Z14host_keepalivev:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 3926     const millis_t ms = millis();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
// 3927     if (host_keepalive_interval && busy_state != NOT_BUSY) {
        LDR.W    R5,??DataTable140_4
        MOV      R4,R0
        LDRB     R0,[R5, #+10]
        CMP      R0,#+0
        ITT      NE 
        LDRSBNE  R0,[R5, #+9]
        CMPNE    R0,#+0
        BEQ.N    ??host_keepalive_0
// 3928       if (PENDING(ms, next_busy_signal_ms)) return;
        LDR.W    R1,??DataTable140_14
        LDR      R1,[R1, #+0]
        SUBS     R1,R4,R1
        BMI.N    ??host_keepalive_1
// 3929       switch (busy_state) {
        CMP      R0,#+1
        BEQ.N    ??host_keepalive_2
        BCC.N    ??host_keepalive_0
        CMP      R0,#+3
        BEQ.N    ??host_keepalive_3
        BCC.N    ??host_keepalive_2
        CMP      R0,#+4
        BEQ.N    ??host_keepalive_4
        B.N      ??host_keepalive_0
// 3930         case IN_HANDLER:
// 3931         case IN_PROCESS:
// 3932           SERIAL_ECHO_START();
??host_keepalive_2:
        LDR.W    R0,??DataTable140_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3933           SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
        LDR.W    R0,??DataTable140_15
        B.N      ??host_keepalive_5
// 3934           break;
// 3935         case PAUSED_FOR_USER:
// 3936           SERIAL_ECHO_START();
??host_keepalive_3:
        LDR.W    R0,??DataTable140_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3937           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
        LDR.W    R0,??DataTable140_16
        B.N      ??host_keepalive_5
// 3938           break;
// 3939         case PAUSED_FOR_INPUT:
// 3940           SERIAL_ECHO_START();
??host_keepalive_4:
        LDR.W    R0,??DataTable140_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3941           SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
        LDR.W    R0,??DataTable140_17
??host_keepalive_5:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 3942           break;
// 3943         default:
// 3944           break;
// 3945       }
// 3946     }
// 3947     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
??host_keepalive_0:
        LDRB     R0,[R5, #+10]
        MOV      R1,#+1000
        MLA      R0,R1,R0,R4
        LDR.W    R1,??DataTable140_14
        STR      R0,[R1, #+0]
// 3948   }
??host_keepalive_1:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock50

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable131:
        DC32     _ZN8Endstops16endstop_hit_bitsE
// 3949 
// 3950 #endif // HOST_KEEPALIVE_FEATURE
// 3951 
// 3952 
// 3953 /**************************************************
// 3954  ***************** GCode Handlers *****************
// 3955  **************************************************/
// 3956 
// 3957 #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 3958   #define G0_G1_CONDITION !axis_unhomed_error(parser.seen('X'), parser.seen('Y'), parser.seen('Z'))
// 3959 #else
// 3960   #define G0_G1_CONDITION true
// 3961 #endif
// 3962 
// 3963 /**
// 3964  * G0, G1: Coordinated movement of X Y Z E axes
// 3965  */
// 3966 inline void gcode_G0_G1(
// 3967   #if 0//IS_SCARA
// 3968     bool fast_move=false
// 3969   #endif
// 3970 ) {
// 3971   if (IsRunning() && G0_G1_CONDITION) {
// 3972     gcode_get_destination(); // For X Y Z E F
// 3973     
// 3974    /*    
// 3975     if (gCfgItems.breakpoint_reprint_flg == 1) 
// 3976     {
// 3977         if ((destination[2] <= gCfgItems.breakpoint_z_pos)&&(card.sdpos >= 5000)) //¶ÏµãÐø´òÐèÒª´óÓÚ5kÖ®ºóµÄÄÚÈÝ²ÅÄÜ½øÐÐÐø´ò¡£
// 3978         {
// 3979             return;
// 3980         }
// 3981     }
// 3982     */
// 3983     #if ENABLED(FWRETRACT)
// 3984       if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 3985         // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 3986         if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 3987           const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 3988           // Is this a retract or recover move?
// 3989           if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 3990             current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 3991             sync_plan_position_e();                         // AND from the planner
// 3992             return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 3993           }
// 3994         }
// 3995       }
// 3996     #endif // FWRETRACT
// 3997 
// 3998     #if 0//IS_SCARA
// 3999       fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 4000     #else
// 4001       prepare_move_to_destination();
// 4002     #endif
// 4003 
// 4004     #if ENABLED(NANODLP_Z_SYNC)
// 4005       #if ENABLED(NANODLP_ALL_AXIS)
// 4006         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 4007       #else
// 4008         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 4009       #endif
// 4010       if (_MOVE_SYNC) {
// 4011         stepper.synchronize();
// 4012         SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4013       }
// 4014     #endif
// 4015   }
// 4016 }
// 4017 inline void gcode_G0_G1_SCARA(
// 4018 	  bool fast_move=false
// 4019   )
// 4020   {
// 4021     if (IsRunning() && G0_G1_CONDITION) {
// 4022       gcode_get_destination(); // For X Y Z E F
// 4023 
// 4024     #if ENABLED(FWRETRACT)
// 4025         if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 4026           // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
// 4027           if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
// 4028             const float echange = destination[E_AXIS] - current_position[E_AXIS];
// 4029             // Is this a retract or recover move?
// 4030             if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
// 4031               current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
// 4032               sync_plan_position_e();                         // AND from the planner
// 4033               return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
// 4034             }
// 4035           }
// 4036         }
// 4037     #endif // FWRETRACT
// 4038 
// 4039     #if 1//IS_SCARA
// 4040         fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
// 4041     #else
// 4042         prepare_move_to_destination();
// 4043     #endif
// 4044 
// 4045     #if ENABLED(NANODLP_Z_SYNC)
// 4046     #if ENABLED(NANODLP_ALL_AXIS)
// 4047         #define _MOVE_SYNC true                 // For any move wait and output sync message
// 4048     #else
// 4049         #define _MOVE_SYNC parser.seenval('Z')  // Only for Z move
// 4050     #endif
// 4051         if (_MOVE_SYNC) {
// 4052           stepper.synchronize();
// 4053           SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4054         }
// 4055     #endif
// 4056     }
// 4057 }
// 4058 
// 4059 /**
// 4060  * G2: Clockwise Arc
// 4061  * G3: Counterclockwise Arc
// 4062  *
// 4063  * This command has two forms: IJ-form and R-form.
// 4064  *
// 4065  *  - I specifies an X offset. J specifies a Y offset.
// 4066  *    At least one of the IJ parameters is required.
// 4067  *    X and Y can be omitted to do a complete circle.
// 4068  *    The given XY is not error-checked. The arc ends
// 4069  *     based on the angle of the destination.
// 4070  *    Mixing I or J with R will throw an error.
// 4071  *
// 4072  *  - R specifies the radius. X or Y is required.
// 4073  *    Omitting both X and Y will throw an error.
// 4074  *    X or Y must differ from the current XY.
// 4075  *    Mixing R with I or J will throw an error.
// 4076  *
// 4077  *  - P specifies the number of full circles to do
// 4078  *    before the specified arc move.
// 4079  *
// 4080  *  Examples:
// 4081  *
// 4082  *    G2 I10           ; CW circle centered at X+10
// 4083  *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
// 4084  */
// 4085 #if ENABLED(ARC_SUPPORT)
// 4086 
// 4087   inline void gcode_G2_G3(const bool clockwise) {
// 4088     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 4089       if (axis_unhomed_error()) return;
// 4090     #endif
// 4091 
// 4092     if (IsRunning()) {
// 4093 
// 4094       #if ENABLED(SF_ARC_FIX)
// 4095         const bool relative_mode_backup = relative_mode;
// 4096         relative_mode = true;
// 4097       #endif
// 4098 
// 4099       gcode_get_destination();
// 4100 
// 4101       #if ENABLED(SF_ARC_FIX)
// 4102         relative_mode = relative_mode_backup;
// 4103       #endif
// 4104 
// 4105       float arc_offset[2] = { 0.0, 0.0 };
// 4106       if (parser.seenval('R')) {
// 4107         const float r = parser.value_linear_units(),
// 4108                     p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
// 4109                     p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
// 4110         if (r && (p2 != p1 || q2 != q1)) {
// 4111           const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
// 4112                       dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
// 4113                       d = HYPOT(dx, dy),                          // Linear distance between the points
// 4114                       h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
// 4115                       mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
// 4116                       sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
// 4117                       cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
// 4118           arc_offset[0] = cx - p1;
// 4119           arc_offset[1] = cy - q1;
// 4120         }
// 4121       }
// 4122       else {
// 4123         if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
// 4124         if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
// 4125       }
// 4126 
// 4127       if (arc_offset[0] || arc_offset[1]) {
// 4128 
// 4129         #if ENABLED(ARC_P_CIRCLES)
// 4130           // P indicates number of circles to do
// 4131           int8_t circles_to_do = parser.byteval('P');
// 4132           if (!WITHIN(circles_to_do, 0, 100)) {
// 4133             SERIAL_ERROR_START();
// 4134             SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 4135           }
// 4136           while (circles_to_do--)
// 4137             plan_arc(current_position, arc_offset, clockwise);
// 4138         #endif
// 4139 
// 4140         // Send the arc to the planner
// 4141         plan_arc(destination, arc_offset, clockwise);
// 4142         refresh_cmd_timeout();
// 4143       }
// 4144       else {
// 4145         // Bad arguments
// 4146         SERIAL_ERROR_START();
// 4147         SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
// 4148       }
// 4149     }
// 4150   }
// 4151 
// 4152 #endif // ARC_SUPPORT
// 4153 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock51 Using cfiCommon0
          CFI Function _Z5dwellm
        THUMB
// 4154 void dwell(millis_t time) {
_Z5dwellm:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4155   refresh_cmd_timeout();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.W    R1,??DataTable140_18
        STR      R0,[R1, #+120]
// 4156   time += previous_cmd_ms;
        ADDS     R4,R0,R4
        B.N      ??dwell_0
// 4157   while (PENDING(millis(), time)) idle();
??dwell_1:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??dwell_0:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R4
        BMI.N    ??dwell_1
// 4158 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock51

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132_1:
        DC32     0xc1200000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132_2:
        DC32     `?<Constant "Bed X: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable132_3:
        DC32     `?<Constant " Y: ">`
// 4159 
// 4160 /**
// 4161  * G4: Dwell S<seconds> or P<milliseconds>
// 4162  */
// 4163 inline void gcode_G4() {
// 4164   millis_t dwell_ms = 0;
// 4165 
// 4166   if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
// 4167   if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
// 4168 
// 4169   stepper.synchronize();
// 4170   #if ENABLED(NANODLP_Z_SYNC)
// 4171     SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4172   #endif
// 4173 
// 4174   if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
// 4175 
// 4176   dwell(dwell_ms);
// 4177 }
// 4178 
// 4179 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 4180 
// 4181   /**
// 4182    * Parameters interpreted according to:
// 4183    * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
// 4184    * However I, J omission is not supported at this point; all
// 4185    * parameters can be omitted and default to zero.
// 4186    */
// 4187 
// 4188   /**
// 4189    * G5: Cubic B-spline
// 4190    */
// 4191   inline void gcode_G5() {
// 4192     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 4193       if (axis_unhomed_error()) return;
// 4194     #endif
// 4195 
// 4196     if (IsRunning()) {
// 4197 
// 4198       #if ENABLED(CNC_WORKSPACE_PLANES)
// 4199         if (workspace_plane != PLANE_XY) {
// 4200           SERIAL_ERROR_START();
// 4201           SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
// 4202           return;
// 4203         }
// 4204       #endif
// 4205 
// 4206       gcode_get_destination();
// 4207 
// 4208       const float offset[] = {
// 4209         parser.linearval('I'),
// 4210         parser.linearval('J'),
// 4211         parser.linearval('P'),
// 4212         parser.linearval('Q')
// 4213       };
// 4214 
// 4215       plan_cubic_move(offset);
// 4216     }
// 4217   }
// 4218 
// 4219 #endif // BEZIER_CURVE_SUPPORT
// 4220 
// 4221 #if ENABLED(FWRETRACT)
// 4222 
// 4223   /**
// 4224    * G10 - Retract filament according to settings of M207
// 4225    */
// 4226   inline void gcode_G10() {
// 4227     #if EXTRUDERS > 1
// 4228       const bool rs = parser.boolval('S');
// 4229       retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
// 4230     #endif
// 4231     retract(true
// 4232       #if EXTRUDERS > 1
// 4233         , rs
// 4234       #endif
// 4235     );
// 4236   }
// 4237 
// 4238   /**
// 4239    * G11 - Recover filament according to settings of M208
// 4240    */
// 4241   inline void gcode_G11() { retract(false); }
// 4242 
// 4243 #endif // FWRETRACT
// 4244 
// 4245 #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 4246   /**
// 4247    * G12: Clean the nozzle
// 4248    */
// 4249   inline void gcode_G12() {
// 4250     // Don't allow nozzle cleaning without homing first
// 4251     if (axis_unhomed_error()) return;
// 4252 
// 4253     const uint8_t pattern = parser.ushortval('P', 0),
// 4254                   strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
// 4255                   objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
// 4256     const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
// 4257 
// 4258     Nozzle::clean(pattern, strokes, radius, objects);
// 4259   }
// 4260 #endif
// 4261 
// 4262 #if ENABLED(CNC_WORKSPACE_PLANES)
// 4263 
// 4264   inline void report_workspace_plane() {
// 4265     SERIAL_ECHO_START();
// 4266     SERIAL_ECHOPGM("Workspace Plane ");
// 4267     serialprintPGM(
// 4268       workspace_plane == PLANE_YZ ? PSTR("YZ\n") :
// 4269       workspace_plane == PLANE_ZX ? PSTR("ZX\n") :
// 4270                                     PSTR("XY\n")
// 4271     );
// 4272   }
// 4273 
// 4274   inline void set_workspace_plane(const WorkspacePlane plane) {
// 4275     workspace_plane = plane;
// 4276     if (DEBUGGING(INFO)) report_workspace_plane();
// 4277   }
// 4278 
// 4279   /**
// 4280    * G17: Select Plane XY
// 4281    * G18: Select Plane ZX
// 4282    * G19: Select Plane YZ
// 4283    */
// 4284   inline void gcode_G17() { set_workspace_plane(PLANE_XY); }
// 4285   inline void gcode_G18() { set_workspace_plane(PLANE_ZX); }
// 4286   inline void gcode_G19() { set_workspace_plane(PLANE_YZ); }
// 4287 
// 4288 #endif // CNC_WORKSPACE_PLANES
// 4289 
// 4290 #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 4291 
// 4292   /**
// 4293    * Select a coordinate system and update the workspace offset.
// 4294    * System index -1 is used to specify machine-native.
// 4295    */
// 4296   bool select_coordinate_system(const int8_t _new) {
// 4297     if (active_coordinate_system == _new) return false;
// 4298     float old_offset[XYZ] = { 0 }, new_offset[XYZ] = { 0 };
// 4299     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4300       COPY(old_offset, coordinate_system[active_coordinate_system]);
// 4301     if (WITHIN(_new, 0, MAX_COORDINATE_SYSTEMS - 1))
// 4302       COPY(new_offset, coordinate_system[_new]);
// 4303     active_coordinate_system = _new;
// 4304     LOOP_XYZ(i) {
// 4305       const float diff = new_offset[i] - old_offset[i];
// 4306       if (diff) {
// 4307         position_shift[i] += diff;
// 4308         update_software_endstops((AxisEnum)i);
// 4309       }
// 4310     }
// 4311     return true;
// 4312   }
// 4313 
// 4314   /**
// 4315    * In CNC G-code G53 is like a modifier
// 4316    * It precedes a movement command (or other modifiers) on the same line.
// 4317    * This is the first command to use parser.chain() to make this possible.
// 4318    */
// 4319   inline void gcode_G53() {
// 4320     // If this command has more following...
// 4321     if (parser.chain()) {
// 4322       const int8_t _system = active_coordinate_system;
// 4323       active_coordinate_system = -1;
// 4324       process_parsed_command();
// 4325       active_coordinate_system = _system;
// 4326     }
// 4327   }
// 4328 
// 4329   /**
// 4330    * G54-G59.3: Select a new workspace
// 4331    *
// 4332    * A workspace is an XYZ offset to the machine native space.
// 4333    * All workspaces default to 0,0,0 at start, or with EEPROM
// 4334    * support they may be restored from a previous session.
// 4335    *
// 4336    * G92 is used to set the current workspace's offset.
// 4337    */
// 4338   inline void gcode_G54_59(uint8_t subcode=0) {
// 4339     const int8_t _space = parser.codenum - 54 + subcode;
// 4340     if (select_coordinate_system(_space)) {
// 4341       SERIAL_PROTOCOLLNPAIR("Select workspace ", _space);
// 4342       report_current_position();
// 4343     }
// 4344   }
// 4345   FORCE_INLINE void gcode_G54() { gcode_G54_59(); }
// 4346   FORCE_INLINE void gcode_G55() { gcode_G54_59(); }
// 4347   FORCE_INLINE void gcode_G56() { gcode_G54_59(); }
// 4348   FORCE_INLINE void gcode_G57() { gcode_G54_59(); }
// 4349   FORCE_INLINE void gcode_G58() { gcode_G54_59(); }
// 4350   FORCE_INLINE void gcode_G59() { gcode_G54_59(parser.subcode); }
// 4351 
// 4352 #endif
// 4353 
// 4354 #if ENABLED(INCH_MODE_SUPPORT)
// 4355   /**
// 4356    * G20: Set input mode to inches
// 4357    */
// 4358   inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
// 4359 
// 4360   /**
// 4361    * G21: Set input mode to millimeters
// 4362    */
// 4363   inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
// 4364 #endif
// 4365 
// 4366 #if ENABLED(NOZZLE_PARK_FEATURE)
// 4367   /**
// 4368    * G27: Park the nozzle
// 4369    */
// 4370   inline void gcode_G27() {
// 4371     // Don't allow nozzle parking without homing first
// 4372     if (axis_unhomed_error()) return;
// 4373     Nozzle::park(parser.ushortval('P'));
// 4374   }
// 4375 #endif // NOZZLE_PARK_FEATURE
// 4376 
// 4377 #if 1//ENABLED(QUICK_HOME)
// 4378 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock52 Using cfiCommon0
          CFI Function _Z13quick_home_xyv
        THUMB
// 4379   static void quick_home_xy() {
_Z13quick_home_xyv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
// 4380 
// 4381     // Pretend the current position is 0,0
// 4382     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        LDR.N    R6,??DataTable137_1
        MOVS     R0,#+0
        SUB      SP,SP,#+12
          CFI CFA R13+48
        STR      R0,[R6, #+20]
        STR      R0,[R6, #+16]
// 4383     sync_plan_position();
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
// 4384 
// 4385     const int x_axis_home_dir =
// 4386       #if ENABLED(DUAL_X_CARRIAGE)
// 4387         x_home_dir(active_extruder)
// 4388       #else
// 4389         home_dir(X_AXIS)
// 4390       #endif
// 4391     ;
        LDR.W    R7,??DataTable140_19
        LDRSB    R0,[R7, #+0]
// 4392 
// 4393     const float mlx = max_length(X_AXIS),
        LDR      R9,[R7, #+56]
        STR      R0,[SP, #+0]
// 4394                 mly = max_length(Y_AXIS),
// 4395                 mlratio = mlx > mly ? mly / mlx : mlx / mly,
        MOV      R1,R9
        LDR      R4,[R7, #+60]
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITT      CS 
        MOVCS    R0,R9
        MOVCS    R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
// 4396                 fr_mm_s = min(homing_feedrate_mm_s[X_AXIS], homing_feedrate_mm_s[Y_AXIS]) * SQRT(sq(mlratio) + 1.0);
        LDR      R11,[R7, #+8]
        LDR      R0,[R7, #+4]
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R11,R0
        MOVS     R5,#+2
        MOV      R8,#+1065353216
        B.N      ??quick_home_xy_0
??quick_home_xy_1:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??quick_home_xy_0:
        LSLS     R0,R5,#+31
        BPL.N    ??quick_home_xy_2
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??quick_home_xy_2:
        LSRS     R5,R5,#+1
        BNE.N    ??quick_home_xy_1
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R5,R0
        MOV      R11,R1
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable140_3  ;; 0x3ff00000
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall sqrt
        BL       sqrt
        MOV      R2,R5
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+4]
// 4397 
// 4398     do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
        MOV      R0,R9
        LDR.W    R5,??DataTable140_6  ;; 0x3ff80000
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        MOV      R11,R1
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R10
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        LDRSB    R0,[R7, #+1]
        MOV      R5,R1
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        ADD      R2,SP,#+4
        ADD      R1,SP,#+0
        ADD      R0,SP,#+8
          CFI FunCall _Z22do_blocking_move_to_xyRKfS0_S0_
        BL       _Z22do_blocking_move_to_xyRKfS0_S0_
// 4399     endstops.hit_on_purpose(); // clear endstop hit flags
        LDR.W    R1,??DataTable140_20
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
// 4400     current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
        STR      R0,[R6, #+20]
        STR      R0,[R6, #+16]
// 4401   }
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock52

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable133:
        DC32     `?<Constant " Z: ">`
// 4402 
// 4403 #endif // QUICK_HOME
// 4404 
// 4405 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4406 
// 4407   void log_machine_info() {
// 4408     SERIAL_ECHOPGM("Machine Type: ");
// 4409     #if ENABLED(DELTA)
// 4410       SERIAL_ECHOLNPGM("Delta");
// 4411     #elif IS_SCARA
// 4412       SERIAL_ECHOLNPGM("SCARA");
// 4413     #elif IS_CORE
// 4414       SERIAL_ECHOLNPGM("Core");
// 4415     #else
// 4416       SERIAL_ECHOLNPGM("Cartesian");
// 4417     #endif
// 4418 
// 4419     SERIAL_ECHOPGM("Probe: ");
// 4420     #if ENABLED(PROBE_MANUALLY)
// 4421       SERIAL_ECHOLNPGM("PROBE_MANUALLY");
// 4422     #elif ENABLED(FIX_MOUNTED_PROBE)
// 4423       SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
// 4424     #elif ENABLED(BLTOUCH)
// 4425       SERIAL_ECHOLNPGM("BLTOUCH");
// 4426     #elif HAS_Z_SERVO_ENDSTOP
// 4427       SERIAL_ECHOLNPGM("SERVO PROBE");
// 4428     #elif ENABLED(Z_PROBE_SLED)
// 4429       SERIAL_ECHOLNPGM("Z_PROBE_SLED");
// 4430     #elif ENABLED(Z_PROBE_ALLEN_KEY)
// 4431       SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
// 4432     #else
// 4433       SERIAL_ECHOLNPGM("NONE");
// 4434     #endif
// 4435 
// 4436     #if HAS_BED_PROBE
// 4437       SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
// 4438       SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
// 4439       SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
// 4440       #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4441         SERIAL_ECHOPGM(" (Right");
// 4442       #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4443         SERIAL_ECHOPGM(" (Left");
// 4444       #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4445         SERIAL_ECHOPGM(" (Middle");
// 4446       #else
// 4447         SERIAL_ECHOPGM(" (Aligned With");
// 4448       #endif
// 4449       #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
// 4450         SERIAL_ECHOPGM("-Back");
// 4451       #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
// 4452         SERIAL_ECHOPGM("-Front");
// 4453       #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
// 4454         SERIAL_ECHOPGM("-Center");
// 4455       #endif
// 4456       if (zprobe_zoffset < 0)
// 4457         SERIAL_ECHOPGM(" & Below");
// 4458       else if (zprobe_zoffset > 0)
// 4459         SERIAL_ECHOPGM(" & Above");
// 4460       else
// 4461         SERIAL_ECHOPGM(" & Same Z as");
// 4462       SERIAL_ECHOLNPGM(" Nozzle)");
// 4463     #endif
// 4464 
// 4465     #if HAS_ABL
// 4466       SERIAL_ECHOPGM("Auto Bed Leveling: ");
// 4467       #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 4468         SERIAL_ECHOPGM("LINEAR");
// 4469       #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4470         SERIAL_ECHOPGM("BILINEAR");
// 4471       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 4472         SERIAL_ECHOPGM("3POINT");
// 4473       #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4474         SERIAL_ECHOPGM("UBL");
// 4475       #endif
// 4476       if (planner.leveling_active) {
// 4477         SERIAL_ECHOLNPGM(" (enabled)");
// 4478         #if ABL_PLANAR
// 4479           const float diff[XYZ] = {
// 4480             stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
// 4481             stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
// 4482             stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
// 4483           };
// 4484           SERIAL_ECHOPGM("ABL Adjustment X");
// 4485           if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
// 4486           SERIAL_ECHO(diff[X_AXIS]);
// 4487           SERIAL_ECHOPGM(" Y");
// 4488           if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
// 4489           SERIAL_ECHO(diff[Y_AXIS]);
// 4490           SERIAL_ECHOPGM(" Z");
// 4491           if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
// 4492           SERIAL_ECHO(diff[Z_AXIS]);
// 4493         #elif ENABLED(AUTO_BED_LEVELING_UBL)
// 4494           SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
// 4495         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 4496           SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
// 4497         #endif
// 4498       }
// 4499       else
// 4500         SERIAL_ECHOLNPGM(" (disabled)");
// 4501 
// 4502       SERIAL_EOL();
// 4503 
// 4504     #elif ENABLED(MESH_BED_LEVELING)
// 4505 
// 4506       SERIAL_ECHOPGM("Mesh Bed Leveling");
// 4507       if (planner.leveling_active) {
// 4508         float rz = current_position[Z_AXIS];
// 4509         planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], rz);
// 4510         SERIAL_ECHOLNPGM(" (enabled)");
// 4511         SERIAL_ECHOPAIR("MBL Adjustment Z", rz);
// 4512       }
// 4513       else
// 4514         SERIAL_ECHOPGM(" (disabled)");
// 4515 
// 4516       SERIAL_EOL();
// 4517 
// 4518     #endif // MESH_BED_LEVELING
// 4519   }
// 4520 
// 4521 #endif // DEBUG_LEVELING_FEATURE
// 4522 
// 4523 #if 1//ENABLED(DELTA)
// 4524 
// 4525   /**
// 4526    * A delta can only safely home all axes at the same time
// 4527    * This is like quick_home_xy() but for 3 towers.
// 4528    */
// 4529   inline bool home_delta() {
// 4530     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4531       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
// 4532     #endif
// 4533     // Init the current position of all carriages to 0,0,0
// 4534     ZERO(current_position);
// 4535     sync_plan_position();
// 4536 
// 4537     // Move all carriages together linearly until an endstop is hit.
// 4538     current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (delta_height + 10);
// 4539     feedrate_mm_s = homing_feedrate_mm_s[X_AXIS];
// 4540     buffer_line_to_current_position();
// 4541     stepper.synchronize();
// 4542 
// 4543     // If an endstop was not hit, then damage can occur if homing is continued.
// 4544     // This can occur if the delta height not set correctly.
// 4545     if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
// 4546       LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
// 4547       SERIAL_ERROR_START();
// 4548       SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
// 4549       return false;
// 4550     }
// 4551 
// 4552     endstops.hit_on_purpose(); // clear endstop hit flags
// 4553 
// 4554     // At least one carriage has reached the top.
// 4555     // Now re-home each carriage separately.
// 4556     HOMEAXIS(A);
// 4557     HOMEAXIS(B);
// 4558     HOMEAXIS(C);
// 4559 
// 4560     // Set all carriages to their home positions
// 4561     // Do this here all at once for Delta, because
// 4562     // XYZ isn't ABC. Applying this per-tower would
// 4563     // give the impression that they are the same.
// 4564     LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
// 4565 
// 4566     SYNC_PLAN_POSITION_KINEMATIC();
// 4567 
// 4568     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4569       if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
// 4570     #endif
// 4571 
// 4572     return true;
// 4573   }
// 4574 
// 4575 #endif // DELTA
// 4576 
// 4577 //#if ENABLED(Z_SAFE_HOMING)
// 4578 
// 4579   inline void home_z_safely() {
// 4580 
// 4581     // Disallow Z homing if X or Y are unknown
// 4582     if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
// 4583       //LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
// 4584       SERIAL_ECHO_START();
// 4585       SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
// 4586       return;
// 4587     }
// 4588 
// 4589     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4590       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
// 4591     #endif
// 4592 
// 4593     SYNC_PLAN_POSITION_KINEMATIC();
// 4594 
// 4595     /**
// 4596      * Move the Z probe (or just the nozzle) to the safe homing point
// 4597      */
// 4598     destination[X_AXIS] = Z_SAFE_HOMING_X_POINT;
// 4599     destination[Y_AXIS] = Z_SAFE_HOMING_Y_POINT;
// 4600     destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
// 4601 
// 4602     #if HOMING_Z_WITH_PROBE
// 4603     if((Z_HOME_DIR < 0) && (Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN))  /*--mks cfg--*/
// 4604     {      
// 4605         destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 4606         destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 4607     }
// 4608     #endif
// 4609 if(MACHINETPYE & IS_KINEMATIC)
// 4610 {
// 4611     if (position_is_reachable_IS_KINEMATIC(destination[X_AXIS], destination[Y_AXIS])) {
// 4612 
// 4613       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4614         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4615       #endif
// 4616 
// 4617       // This causes the carriage on Dual X to unpark
// 4618       #if ENABLED(DUAL_X_CARRIAGE)
// 4619         active_extruder_parked = false;
// 4620       #endif
// 4621 
// 4622       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4623       HOMEAXIS(Z);
// 4624     }
// 4625     else {
// 4626       //LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4627       SERIAL_ECHO_START();
// 4628       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4629     }
// 4630 }
// 4631 else
// 4632 {
// 4633     if (position_is_reachable_IS_CARTESIAN(destination[X_AXIS], destination[Y_AXIS])) {
// 4634 
// 4635       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4636         if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
// 4637       #endif
// 4638 
// 4639       // This causes the carriage on Dual X to unpark
// 4640       #if ENABLED(DUAL_X_CARRIAGE)
// 4641         active_extruder_parked = false;
// 4642       #endif
// 4643 
// 4644       do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
// 4645       HOMEAXIS(Z);
// 4646     }
// 4647     else {
// 4648       //LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
// 4649       SERIAL_ECHO_START();
// 4650       SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
// 4651     }    
// 4652 }
// 4653     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4654       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
// 4655     #endif
// 4656   }
// 4657 
// 4658 //#endif // Z_SAFE_HOMING
// 4659 
// 4660 #if ENABLED(PROBE_MANUALLY)
// 4661   bool g29_in_progress = false;
// 4662 #else
// 4663   constexpr bool g29_in_progress = false;
// 4664 #endif
// 4665 
// 4666 /**
// 4667  * G28: Home all axes according to settings
// 4668  *
// 4669  * Parameters
// 4670  *
// 4671  *  None  Home to all axes with no parameters.
// 4672  *        With QUICK_HOME enabled XY will home together, then Z.
// 4673  *
// 4674  * Cartesian parameters
// 4675  *
// 4676  *  X   Home to the X endstop
// 4677  *  Y   Home to the Y endstop
// 4678  *  Z   Home to the Z endstop
// 4679  *
// 4680  */
// 4681 inline void gcode_G28(const bool always_home_all) {
// 4682 
// 4683   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4684     if (DEBUGGING(LEVELING)) {
// 4685       SERIAL_ECHOLNPGM(">>> gcode_G28");
// 4686       log_machine_info();
// 4687     }
// 4688   #endif
// 4689 
// 4690   // Wait for planner moves to finish!
// 4691   stepper.synchronize();
// 4692 
// 4693   // Cancel the active G29 session
// 4694   #if ENABLED(PROBE_MANUALLY)
// 4695     g29_in_progress = false;
// 4696   #endif
// 4697 
// 4698   // Disable the leveling matrix before homing
// 4699   //#if HAS_LEVELING
// 4700   	//const 
// 4701   	bool ubl_state_at_entry;
// 4702     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4703     if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4704     {
// 4705     	ubl_state_at_entry = planner.leveling_active;
// 4706     }
// 4707     //#endif
// 4708     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 4709     {
// 4710     	set_bed_leveling_enabled(false);
// 4711     }
// 4712   //#endif
// 4713 
// 4714   #if ENABLED(CNC_WORKSPACE_PLANES)
// 4715     workspace_plane = PLANE_XY;
// 4716   #endif
// 4717 
// 4718   // Always home with tool 0 active
// 4719   #if HOTENDS > 1
// 4720     const uint8_t old_tool_index = active_extruder;
// 4721     tool_change(0, 0, true);
// 4722   #endif
// 4723 
// 4724   #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 4725     extruder_duplication_enabled = false;
// 4726   #endif
// 4727 
// 4728   setup_for_endstop_or_probe_move();
// 4729   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4730     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
// 4731   #endif
// 4732   endstops.enable(true); // Enable endstops for next homing move
// 4733 
// 4734   //#if ENABLED(DELTA)
// 4735   if(MACHINETPYE == DELTA)
// 4736   {
// 4737     home_delta();
// 4738     UNUSED(always_home_all);
// 4739   }
// 4740   //#else // NOT DELTA
// 4741   else
// 4742   {
// 4743     const bool homeX = always_home_all || parser.seen('X'),
// 4744                homeY = always_home_all || parser.seen('Y'),
// 4745                homeZ = always_home_all || parser.seen('Z'),
// 4746                home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
// 4747 
// 4748     set_destination_from_current();
// 4749 
// 4750     //#if Z_HOME_DIR > 0  // If homing away from BED do Z first
// 4751 	if(Z_HOME_DIR > 0)
// 4752 	{
// 4753       if (home_all || homeZ) {
// 4754         HOMEAXIS(Z);
// 4755         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4756           if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
// 4757         #endif
// 4758       }
// 4759 	}
// 4760     //#endif
// 4761 
// 4762     if ((home_all || homeX || homeY) 
// 4763         #if 1
// 4764 		&& ((mksReprint.mks_printer_state != MKS_REPRINTING)
// 4765 	  	||(mksReprint.mks_printer_state != MKS_REPRINTED))
// 4766 	  	#endif
// 4767         )
// 4768       {
// 4769       // Raise Z before homing any other axes and z is not already high enough (never lower z)
// 4770       destination[Z_AXIS] = Z_HOMING_HEIGHT;
// 4771       if (destination[Z_AXIS] > current_position[Z_AXIS]) {
// 4772 
// 4773         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4774           if (DEBUGGING(LEVELING))
// 4775             SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
// 4776         #endif
// 4777 
// 4778         do_blocking_move_to_z(destination[Z_AXIS]);
// 4779       }
// 4780     }
// 4781 
// 4782     //#if ENABLED(QUICK_HOME)
// 4783 	if(MACHINETPYE&IS_SCARA)
// 4784 	{
// 4785       if (home_all || (homeX && homeY)) quick_home_xy();
// 4786 	}
// 4787     //#endif
// 4788 
// 4789     //#if ENABLED(HOME_Y_BEFORE_X)
// 4790       //sean 19.12.16
// 4791       #if 0
// 4792 	if(MACHINETPYE&IS_SCARA)
// 4793 	#else 
// 4794 	if(HOME_Y_BEFORE_X)
// 4795 	#endif
// 4796 	{
// 4797       // Home Y
// 4798       if (home_all || homeY) {
// 4799         HOMEAXIS(Y);
// 4800         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4801           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4802         #endif
// 4803       }
// 4804 	}
// 4805     //#endif
// 4806 
// 4807     // Home X
// 4808     if (home_all || homeX) {
// 4809 
// 4810       #if ENABLED(DUAL_X_CARRIAGE)
// 4811 
// 4812         // Always home the 2nd (right) extruder first
// 4813         active_extruder = 1;
// 4814         HOMEAXIS(X);
// 4815 
// 4816         // Remember this extruder's position for later tool change
// 4817         inactive_extruder_x_pos = current_position[X_AXIS];
// 4818 
// 4819         // Home the 1st (left) extruder
// 4820         active_extruder = 0;
// 4821         HOMEAXIS(X);
// 4822 
// 4823         // Consider the active extruder to be parked
// 4824         COPY(raised_parked_position, current_position);
// 4825         delayed_move_time = 0;
// 4826         active_extruder_parked = true;
// 4827 
// 4828       #else
// 4829 
// 4830         HOMEAXIS(X);
// 4831 
// 4832       #endif
// 4833 
// 4834       #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4835         if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
// 4836       #endif
// 4837     }
// 4838 
// 4839     //#if DISABLED(HOME_Y_BEFORE_X)
// 4840 	if(!HOME_Y_BEFORE_X)
// 4841 	{
// 4842       // Home Y
// 4843       if (home_all || homeY) {
// 4844         HOMEAXIS(Y);
// 4845         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4846           if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
// 4847         #endif
// 4848       }
// 4849 	}
// 4850     //#endif
// 4851 
// 4852     // Home Z last if homing towards the bed
// 4853     //#if Z_HOME_DIR < 0
// 4854     if(Z_HOME_DIR < 0)
// 4855     {
// 4856       if (home_all || homeZ) {
// 4857         //#if ENABLED(Z_SAFE_HOMING)
// 4858 	 if(Z_SAFE_HOMING)
// 4859           home_z_safely();
// 4860         //#else
// 4861         else
// 4862           HOMEAXIS(Z);
// 4863         //#endif
// 4864         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4865           if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
// 4866         #endif
// 4867       } // home_all || homeZ
// 4868     }
// 4869     //#endif // Z_HOME_DIR < 0
// 4870 
// 4871     SYNC_PLAN_POSITION_KINEMATIC();
// 4872 }
// 4873   //#endif // !DELTA (gcode_G28)
// 4874 
// 4875   endstops.not_homing();
// 4876 
// 4877   #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 4878     // move to a height where we can use the full xy-area
// 4879     do_blocking_move_to_z(delta_clip_start_height);
// 4880   #endif
// 4881 
// 4882   //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 4883   if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 4884     set_bed_leveling_enabled(ubl_state_at_entry);
// 4885   //#endif
// 4886 
// 4887   clean_up_after_endstop_or_probe_move();
// 4888 
// 4889   // Restore the active tool after homing
// 4890   #if HOTENDS > 1
// 4891     #if ENABLED(PARKING_EXTRUDER)
// 4892       #define NO_FETCH false // fetch the previous toolhead
// 4893     #else
// 4894       #define NO_FETCH true
// 4895     #endif
// 4896     tool_change(old_tool_index, 0, NO_FETCH);
// 4897   #endif
// 4898 
// 4899   lcd_refresh();
// 4900 
// 4901   report_current_position();
// 4902 
// 4903   #if ENABLED(NANODLP_Z_SYNC)
// 4904     #if ENABLED(NANODLP_ALL_AXIS)
// 4905       #define _HOME_SYNC true                 // For any axis, output sync text.
// 4906     #else
// 4907       #define _HOME_SYNC (home_all || homeZ)  // Only for Z-axis
// 4908     #endif
// 4909     if (_HOME_SYNC)
// 4910       SERIAL_ECHOLNPGM(MSG_Z_MOVE_COMP);
// 4911   #endif
// 4912 
// 4913   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 4914     if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
// 4915   #endif
// 4916 } // G28
// 4917 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock53 Using cfiCommon0
          CFI Function _Z13home_all_axesv
        THUMB
// 4918 void home_all_axes() { gcode_G28(true); }
_Z13home_all_axesv:
        MOVS     R0,#+1
          CFI FunCall _Z9gcode_G28b
        B.W      _Z9gcode_G28b
          CFI EndBlock cfiBlock53
// 4919 
// 4920 #if HAS_PROBING_PROCEDURE
// 4921 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock54 Using cfiCommon0
          CFI Function _Z18out_of_range_errorPKc
        THUMB
// 4922   void out_of_range_error(const char* p_edge) {
_Z18out_of_range_errorPKc:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        MOV      R4,R0
// 4923     SERIAL_PROTOCOLPGM("?Probe ");
        LDR.W    R0,??DataTable140_21
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4924     serialprintPGM(p_edge);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4925     SERIAL_PROTOCOLLNPGM(" position out of range.");
        LDR.W    R0,??DataTable140_22
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI EndBlock cfiBlock54
// 4926   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable134:
        DC32     `?<Constant "Probing failed\\n">`
// 4927 
// 4928 #endif
// 4929 
// 4930 #if 1//ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
// 4931 
// 4932   #if ENABLED(LCD_BED_LEVELING)
// 4933     //extern 
// 4934     bool lcd_wait_for_move;
// 4935   #else
// 4936     constexpr bool lcd_wait_for_move = false;
// 4937   #endif
// 4938 
// 4939   inline void _manual_goto_xy(const float &rx, const float &ry) {
// 4940 
// 4941     //#if MANUAL_PROBE_HEIGHT > 0
// 4942     if(MANUAL_PROBE_HEIGHT > 0)
// 4943     {
// 4944       const float prev_z = current_position[Z_AXIS];
// 4945       do_blocking_move_to(rx, ry, MANUAL_PROBE_HEIGHT);
// 4946       do_blocking_move_to_z(prev_z);
// 4947     }
// 4948     //#else
// 4949     else
// 4950     {
// 4951       do_blocking_move_to_xy(rx, ry);
// 4952     }
// 4953     //#endif
// 4954 
// 4955     current_position[X_AXIS] = rx;
// 4956     current_position[Y_AXIS] = ry;
// 4957 
// 4958     #if ENABLED(LCD_BED_LEVELING)
// 4959       lcd_wait_for_move = false;
// 4960     #endif
// 4961   }
// 4962 
// 4963 #endif
// 4964 
// 4965 #if 1//ENABLED(MESH_BED_LEVELING)
// 4966 
// 4967   // Save 130 bytes with non-duplication of PSTR

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock55 Using cfiCommon0
          CFI Function _Z16echo_not_enteredv
        THUMB
// 4968   void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
_Z16echo_not_enteredv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable140_23
        LDR.N    R5,??DataTable139_6
        B.N      ??echo_not_entered_0
??echo_not_entered_1:
        UXTB     R1,R1
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??echo_not_entered_0:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??echo_not_entered_1
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock55

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135:
        DC32     _ZN17mesh_bed_leveling8has_meshE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable135_1:
        DC32     _ZN7Planner15leveling_activeE
// 4969 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock56 Using cfiCommon0
          CFI Function _Z15mbl_mesh_reportv
        THUMB
// 4970   void mbl_mesh_report() {
_Z15mbl_mesh_reportv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
// 4971     //SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
// 4972     SERIAL_PROTOCOLPGM("Num X,Y: ");
        LDR.W    R0,??DataTable140_24
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4973     SERIAL_PROTOCOL((int)GRID_MAX_POINTS_X);
        LDR.W    R5,??DataTable140
        LDR.N    R4,??DataTable139_6
        LDRB     R1,[R5, #+96]
        MOVS     R2,#+10
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 4974     SERIAL_PROTOCOLCHAR(',');
        MOVS     R1,#+44
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 4975     SERIAL_PROTOCOL((int)GRID_MAX_POINTS_Y);
        ADD      R6,R5,#+96
        MOVS     R2,#+10
        LDRB     R1,[R6, #+1]
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
// 4976     SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 4977     SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
        LDR.W    R0,??DataTable140_25
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        LDR.W    R0,??DataTable140_26
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 4978     SERIAL_PROTOCOLLNPGM("\nMeasured points:");
        LDR.W    R0,??DataTable140_27
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 4979 	/*
// 4980     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
// 4981       [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
// 4982     );
// 4983     */
// 4984     print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,2);
        LDRB     R1,[R6, #+1]
        LDRB     R0,[R5, #+96]
        ADD      SP,SP,#+8
          CFI CFA R13+16
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R3,#+2
        MOVS     R2,#+5
          CFI FunCall _Z14print_2d_arrayhhhh
        B.W      _Z14print_2d_arrayhhhh
          CFI EndBlock cfiBlock56
// 4985   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable136:
        DC32     `?<Constant {(-9.9999990233E+3F), (-9.999999023`

        SECTION `.rodata`:CONST:REORDER:NOROOT(0)
        SECTION_GROUP _ZTI5Print
// __absolute char const <Typeinfo for Print>
_ZTI5Print:
        DATA
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs
// __absolute char const <_ZZNK10duration_t8toStringEPcEs>[20]
_ZZNK10duration_t8toStringEPcEs:
        DATA
        DC8 "%iy %id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_0
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_0>[16]
_ZZNK10duration_t8toStringEPcEs_0:
        DATA
        DC8 "%id %ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_1
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_1>[12]
_ZZNK10duration_t8toStringEPcEs_1:
        DATA
        DC8 "%ih %im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_2
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_2>[8]
_ZZNK10duration_t8toStringEPcEs_2:
        DATA
        DC8 "%im %is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZNK10duration_t8toStringEPcEs_3
// __absolute char const <_ZZNK10duration_t8toStringEPcEs_3>[4]
_ZZNK10duration_t8toStringEPcEs_3:
        DATA
        DC8 "%is"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs
// __absolute char const <_ZZ19get_serial_commandsvEs>[5]
_ZZ19get_serial_commandsvEs:
        DATA
        DC8 "M110"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_0
// __absolute char const <_ZZ19get_serial_commandsvEs_0>[51]
_ZZ19get_serial_commandsvEs_0:
        DATA
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 20H, 69H, 73H, 20H, 6EH
        DC8 6FH, 74H, 20H, 4CH, 61H, 73H, 74H, 20H
        DC8 4CH, 69H, 6EH, 65H, 20H, 4EH, 75H, 6DH
        DC8 62H, 65H, 72H, 2BH, 31H, 2CH, 20H, 4CH
        DC8 61H, 73H, 74H, 20H, 4CH, 69H, 6EH, 65H
        DC8 3AH, 20H, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_1
// __absolute char const <_ZZ19get_serial_commandsvEs_1>[31]
_ZZ19get_serial_commandsvEs_1:
        DATA
        DC8 "checksum mismatch, Last Line: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_2
// __absolute char const <_ZZ19get_serial_commandsvEs_2>[42]
_ZZ19get_serial_commandsvEs_2:
        DATA
        DC8 "No Checksum with line number, Last Line: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_3
// __absolute char const <_ZZ19get_serial_commandsvEs_3>[119]
_ZZ19get_serial_commandsvEs_3:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_5
// __absolute char const <_ZZ19get_serial_commandsvEs_5>[5]
_ZZ19get_serial_commandsvEs_5:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_6
// __absolute char const <_ZZ19get_serial_commandsvEs_6>[5]
_ZZ19get_serial_commandsvEs_6:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_7
// __absolute char const <_ZZ19get_serial_commandsvEs_7>[9]
_ZZ19get_serial_commandsvEs_7:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvEs_8
// __absolute char const <_ZZ19get_serial_commandsvEs_8>[5]
_ZZ19get_serial_commandsvEs_8:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs
// __absolute char const <_ZZ19get_sdcard_commandsvEs>[20]
_ZZ19get_sdcard_commandsvEs:
        DATA
        DC8 "Done printing file\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_sdcard_commandsvEs_0
// __absolute char const <_ZZ19get_sdcard_commandsvEs_0>[15]
_ZZ19get_sdcard_commandsvEs_0:
        DATA
        DC8 "SD read error\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs
// __absolute char const <_ZZ17get_wifi_commandsvEs>[119]
_ZZ17get_wifi_commandsvEs:
        DATA
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_1
// __absolute char const <_ZZ17get_wifi_commandsvEs_1>[5]
_ZZ17get_wifi_commandsvEs_1:
        DATA
        DC8 "M108"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_2
// __absolute char const <_ZZ17get_wifi_commandsvEs_2>[5]
_ZZ17get_wifi_commandsvEs_2:
        DATA
        DC8 "M112"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_3
// __absolute char const <_ZZ17get_wifi_commandsvEs_3>[9]
_ZZ17get_wifi_commandsvEs_3:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvEs_4
// __absolute char const <_ZZ17get_wifi_commandsvEs_4>[5]
_ZZ17get_wifi_commandsvEs_4:
        DATA
        DC8 "M410"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ24get_homing_bump_feedrate8AxisEnumEs
// __absolute char const <_ZZ24get_homing_bump_feedrate8AxisEnumEs>[34]
_ZZ24get_homing_bump_feedrate8AxisEnumEs:
        DATA
        DC8 "Warning: Homing Bump Divisor < 1\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ11gcode_G2_G3bEs
// __absolute char const <_ZZ11gcode_G2_G3bEs>[22]
_ZZ11gcode_G2_G3bEs:
        DATA
        DC8 "G2/G3 bad parameters\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10home_deltavEs_0
// __absolute char const <_ZZ10home_deltavEs_0>[15]
_ZZ10home_deltavEs_0:
        DATA
        DC8 "Homing failed\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ13home_z_safelyvEs
// __absolute char const <_ZZ13home_z_safelyvEs>[17]
_ZZ13home_z_safelyvEs:
        DATA
        DC8 "G28 Z Forbidden\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ13home_z_safelyvEs_0
// __absolute char const <_ZZ13home_z_safelyvEs_0>[18]
_ZZ13home_z_safelyvEs_0:
        DATA
        DC8 "Z probe out. bed\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs>[23]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs:
        DATA
        DC8 "S out of range (0-5).\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0>[8]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0:
        DATA
        DC8 "State: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1>[4]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2>[4]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3>[32]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3:
        DATA
        DC8 "Mesh bed leveling has no data.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4>[7]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4:
        DATA
        DC8 "G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5>[11]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5:
        DATA
        DC8 "G28\012G29 S2"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6>[41]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6:
        DATA
        DC8 "Start mesh probing with \"G29 S1\" first.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7>[20]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7:
        DATA
        DC8 "Mesh probing done.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8:
        DATA
        DC8 "X out of range (1-mksCfg.grid_max_points_x).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9>[46]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9:
        DATA
        DC8 "Y out of range (1-mksCfg.grid_max_points_y).\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_>[15]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_:
        DATA
        DC8 "MBL G29 point "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
// __absolute char const <_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_>[5]
_ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_:
        DATA
        DC8 " of "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs
// __absolute char const <_ZZ9gcode_G29vEs>[23]
_ZZ9gcode_G29vEs:
        DATA
        DC8 "malloc eqnAMatrix err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_0
// __absolute char const <_ZZ9gcode_G29vEs_0>[23]
_ZZ9gcode_G29vEs_0:
        DATA
        DC8 "malloc eqnBVector err!"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_1
// __absolute char const <_ZZ9gcode_G29vEs_1>[18]
_ZZ9gcode_G29vEs_1:
        DATA
        DC8 "No bilinear grid\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_2
// __absolute char const <_ZZ9gcode_G29vEs_2>[13]
_ZZ9gcode_G29vEs_2:
        DATA
        DC8 "Bad Z value\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_3
// __absolute char const <_ZZ9gcode_G29vEs_3>[40]
_ZZ9gcode_G29vEs_3:
        DATA
        DC8 "?(V)erbose level is implausible (0-4).\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_4
// __absolute char const <_ZZ9gcode_G29vEs_4>[53]
_ZZ9gcode_G29vEs_4:
        DATA
        DC8 3FH, 4EH, 75H, 6DH, 62H, 65H, 72H, 20H
        DC8 6FH, 66H, 20H, 70H, 72H, 6FH, 62H, 65H
        DC8 20H, 70H, 6FH, 69H, 6EH, 74H, 73H, 20H
        DC8 69H, 73H, 20H, 69H, 6DH, 70H, 6CH, 61H
        DC8 75H, 73H, 69H, 62H, 6CH, 65H, 20H, 28H
        DC8 32H, 20H, 6DH, 69H, 6EH, 69H, 6DH, 75H
        DC8 6DH, 29H, 2EH, 0AH, 0
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_5
// __absolute char const <_ZZ9gcode_G29vEs_5>[7]
_ZZ9gcode_G29vEs_5:
        DATA
        DC8 "(L)eft"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_6
// __absolute char const <_ZZ9gcode_G29vEs_6>[8]
_ZZ9gcode_G29vEs_6:
        DATA
        DC8 "(R)ight"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_7
// __absolute char const <_ZZ9gcode_G29vEs_7>[8]
_ZZ9gcode_G29vEs_7:
        DATA
        DC8 "(F)ront"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_8
// __absolute char const <_ZZ9gcode_G29vEs_8>[7]
_ZZ9gcode_G29vEs_8:
        DATA
        DC8 "(B)ack"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs_9
// __absolute char const <_ZZ9gcode_G29vEs_9>[22]
_ZZ9gcode_G29vEs_9:
        DATA
        DC8 "G29 Auto Bed Leveling"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__10_
// __absolute char const <_ZZ9gcode_G29vEs__10_>[10]
_ZZ9gcode_G29vEs__10_:
        DATA
        DC8 " (DRYRUN)"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__11_
// __absolute char const <_ZZ9gcode_G29vEs__11_>[22]
_ZZ9gcode_G29vEs__11_:
        DATA
        DC8 "Eqn coefficients: a: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__12_
// __absolute char const <_ZZ9gcode_G29vEs__12_>[5]
_ZZ9gcode_G29vEs__12_:
        DATA
        DC8 " b: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__13_
// __absolute char const <_ZZ9gcode_G29vEs__13_>[5]
_ZZ9gcode_G29vEs__13_:
        DATA
        DC8 " d: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__14_
// __absolute char const <_ZZ9gcode_G29vEs__14_>[25]
_ZZ9gcode_G29vEs__14_:
        DATA
        DC8 "Mean of sampled points: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__15_
// __absolute char const <_ZZ9gcode_G29vEs__15_>[195]
_ZZ9gcode_G29vEs__15_:
        DATA
        DC8 0AH, 42H, 65H, 64H, 20H, 48H, 65H, 69H
        DC8 67H, 68H, 74H, 20H, 54H, 6FH, 70H, 6FH
        DC8 67H, 72H, 61H, 70H, 68H, 79H, 3AH, 0AH
        DC8 20H, 20H, 20H, 2BH, 2DH, 2DH, 2DH, 20H
        DC8 42H, 41H, 43H, 4BH, 20H, 2DH, 2DH, 2BH
        DC8 0AH, 20H, 20H, 20H, 7CH, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 7CH, 0AH, 20H, 4CH, 20H, 7CH, 20H, 20H
        DC8 20H, 20H, 28H, 2BH, 29H, 20H, 20H, 20H
        DC8 20H, 7CH, 20H, 52H, 0AH, 20H, 45H, 20H
        DC8 7CH, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 7CH, 20H, 49H, 0AH
        DC8 20H, 46H, 20H, 7CH, 20H, 28H, 2DH, 29H
        DC8 20H, 4EH, 20H, 28H, 2BH, 29H, 20H, 7CH
        DC8 20H, 47H, 0AH, 20H, 54H, 20H, 7CH, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 20H, 20H, 7CH, 20H, 48H, 0AH, 20H, 20H
        DC8 20H, 7CH, 20H, 20H, 20H, 20H, 28H, 2DH
        DC8 29H, 20H, 20H, 20H, 20H, 7CH, 20H, 54H
        DC8 0AH, 20H, 20H, 20H, 7CH, 20H, 20H, 20H
        DC8 20H, 20H, 20H, 20H, 20H, 20H, 20H, 20H
        DC8 7CH, 0AH, 20H, 20H, 20H, 4FH, 2DH, 2DH
        DC8 20H, 46H, 52H, 4FH, 4EH, 54H, 20H, 2DH
        DC8 2DH, 2BH, 0AH, 20H, 28H, 30H, 2CH, 30H
        DC8 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__16_
// __absolute char const <_ZZ9gcode_G29vEs__16_>[3]
_ZZ9gcode_G29vEs__16_:
        DATA
        DC8 " +"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__17_
// __absolute char const <_ZZ9gcode_G29vEs__17_>[41]
_ZZ9gcode_G29vEs__17_:
        DATA
        DC8 "\012Corrected Bed Height vs. Bed Topology:\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G29vEs__18_
// __absolute char const <_ZZ9gcode_G29vEs__18_>[31]
_ZZ9gcode_G29vEs__18_:
        DATA
        DC8 "\012\012Bed Level Correction Matrix:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs
// __absolute char const <_ZZ9gcode_G30vEs>[8]
_ZZ9gcode_G30vEs:
        DATA
        DC8 "Bed X: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_0
// __absolute char const <_ZZ9gcode_G30vEs_0>[5]
_ZZ9gcode_G30vEs_0:
        DATA
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G30vEs_1
// __absolute char const <_ZZ9gcode_G30vEs_1>[5]
_ZZ9gcode_G30vEs_1:
        DATA
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_G42vEs
// __absolute char const <_ZZ9gcode_G42vEs>[31]
_ZZ9gcode_G42vEs:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs
// __absolute char const <_ZZ9gcode_M20vEs>[17]
_ZZ9gcode_M20vEs:
        DATA
        DC8 "Begin file list\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M20vEs_0
// __absolute char const <_ZZ9gcode_M20vEs_0>[15]
_ZZ9gcode_M20vEs_0:
        DATA
        DC8 "End file list\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M31vEs
// __absolute char const <_ZZ9gcode_M31vEs>[13]
_ZZ9gcode_M31vEs:
        DATA
        DC8 "Print time: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M42vEs
// __absolute char const <_ZZ9gcode_M42vEs>[15]
_ZZ9gcode_M42vEs:
        DATA
        DC8 "Protected Pin\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs
// __absolute char const <_ZZ9gcode_M49vEs>[11]
_ZZ9gcode_M49vEs:
        DATA
        DC8 "G26 Debug "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_0
// __absolute char const <_ZZ9gcode_M49vEs_0>[5]
_ZZ9gcode_M49vEs_0:
        DATA
        DC8 "on.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ9gcode_M49vEs_1
// __absolute char const <_ZZ9gcode_M49vEs_1>[6]
_ZZ9gcode_M49vEs_1:
        DATA
        DC8 "off.\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M105vEs
// __absolute char const <_ZZ10gcode_M105vEs>[3]
_ZZ10gcode_M105vEs:
        DATA
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M112vEs
// __absolute char const <_ZZ10gcode_M112vEs>[9]
_ZZ10gcode_M112vEs:
        DATA
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M109vEs_5
// __absolute char const <_ZZ10gcode_M109vEs_5>[4]
_ZZ10gcode_M109vEs_5:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M190vEs_0
// __absolute char const <_ZZ10gcode_M190vEs_0>[4]
_ZZ10gcode_M190vEs_0:
        DATA
        DC8 " W:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_4
// __absolute char const <_ZZ10gcode_M111vEs_4>[7]
_ZZ10gcode_M111vEs_4:
        DATA
        DC8 "DEBUG:"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vEs_5
// __absolute char const <_ZZ10gcode_M111vEs_5>[4]
_ZZ10gcode_M111vEs_5:
        DATA
        DC8 "off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M113vEs
// __absolute char const <_ZZ10gcode_M113vEs>[7]
_ZZ10gcode_M113vEs:
        DATA
        DC8 "M113 S"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs
// __absolute char const <_ZZ10gcode_M115vEs>[198]
_ZZ10gcode_M115vEs:
        DATA
        DC8 46H, 49H, 52H, 4DH, 57H, 41H, 52H, 45H
        DC8 5FH, 4EH, 41H, 4DH, 45H, 3AH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 31H, 2EH, 30H
        DC8 2EH, 30H, 20H, 28H, 47H, 69H, 74H, 68H
        DC8 75H, 62H, 29H, 20H, 53H, 4FH, 55H, 52H
        DC8 43H, 45H, 5FH, 43H, 4FH, 44H, 45H, 5FH
        DC8 55H, 52H, 4CH, 3AH, 68H, 74H, 74H, 70H
        DC8 73H, 3AH, 2FH, 2FH, 67H, 69H, 74H, 68H
        DC8 75H, 62H, 2EH, 63H, 6FH, 6DH, 2FH, 4DH
        DC8 61H, 72H, 6CH, 69H, 6EH, 46H, 69H, 72H
        DC8 6DH, 77H, 61H, 72H, 65H, 2FH, 4DH, 61H
        DC8 72H, 6CH, 69H, 6EH, 20H, 50H, 52H, 4FH
        DC8 54H, 4FH, 43H, 4FH, 4CH, 5FH, 56H, 45H
        DC8 52H, 53H, 49H, 4FH, 4EH, 3AH, 31H, 2EH
        DC8 30H, 20H, 4DH, 41H, 43H, 48H, 49H, 4EH
        DC8 45H, 5FH, 54H, 59H, 50H, 45H, 3AH, 33H
        DC8 44H, 20H, 50H, 72H, 69H, 6EH, 74H, 65H
        DC8 72H, 20H, 45H, 58H, 54H, 52H, 55H, 44H
        DC8 45H, 52H, 5FH, 43H, 4FH, 55H, 4EH, 54H
        DC8 3AH, 32H, 20H, 55H, 55H, 49H, 44H, 3AH
        DC8 63H, 65H, 64H, 65H, 32H, 61H, 32H, 66H
        DC8 2DH, 34H, 31H, 61H, 32H, 2DH, 34H, 37H
        DC8 34H, 38H, 2DH, 39H, 62H, 31H, 32H, 2DH
        DC8 63H, 35H, 35H, 63H, 36H, 32H, 66H, 33H
        DC8 36H, 37H, 66H, 66H, 0AH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_0
// __absolute char const <_ZZ10gcode_M115vEs_0>[16]
_ZZ10gcode_M115vEs_0:
        DATA
        DC8 "SERIAL_XON_XOFF"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_1
// __absolute char const <_ZZ10gcode_M115vEs_1>[7]
_ZZ10gcode_M115vEs_1:
        DATA
        DC8 "EEPROM"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_2
// __absolute char const <_ZZ10gcode_M115vEs_2>[11]
_ZZ10gcode_M115vEs_2:
        DATA
        DC8 "VOLUMETRIC"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_3
// __absolute char const <_ZZ10gcode_M115vEs_3>[16]
_ZZ10gcode_M115vEs_3:
        DATA
        DC8 "AUTOREPORT_TEMP"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_4
// __absolute char const <_ZZ10gcode_M115vEs_4>[9]
_ZZ10gcode_M115vEs_4:
        DATA
        DC8 "PROGRESS"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_5
// __absolute char const <_ZZ10gcode_M115vEs_5>[10]
_ZZ10gcode_M115vEs_5:
        DATA
        DC8 "PRINT_JOB"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_6
// __absolute char const <_ZZ10gcode_M115vEs_6>[10]
_ZZ10gcode_M115vEs_6:
        DATA
        DC8 "AUTOLEVEL"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_7
// __absolute char const <_ZZ10gcode_M115vEs_7>[8]
_ZZ10gcode_M115vEs_7:
        DATA
        DC8 "Z_PROBE"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_8
// __absolute char const <_ZZ10gcode_M115vEs_8>[14]
_ZZ10gcode_M115vEs_8:
        DATA
        DC8 "LEVELING_DATA"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs_9
// __absolute char const <_ZZ10gcode_M115vEs_9>[14]
_ZZ10gcode_M115vEs_9:
        DATA
        DC8 "BUILD_PERCENT"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__10_
// __absolute char const <_ZZ10gcode_M115vEs__10_>[15]
_ZZ10gcode_M115vEs__10_:
        DATA
        DC8 "SOFTWARE_POWER"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__11_
// __absolute char const <_ZZ10gcode_M115vEs__11_>[14]
_ZZ10gcode_M115vEs__11_:
        DATA
        DC8 "TOGGLE_LIGHTS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__12_
// __absolute char const <_ZZ10gcode_M115vEs__12_>[22]
_ZZ10gcode_M115vEs__12_:
        DATA
        DC8 "CASE_LIGHT_BRIGHTNESS"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M115vEs__13_
// __absolute char const <_ZZ10gcode_M115vEs__13_>[17]
_ZZ10gcode_M115vEs__13_:
        DATA
        DC8 "EMERGENCY_PARSER"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M118vEs
// __absolute char const <_ZZ10gcode_M118vEs>[4]
_ZZ10gcode_M118vEs:
        DATA
        DC8 "// "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs
// __absolute char const <_ZZ10gcode_M204vEs>[40]
_ZZ10gcode_M204vEs:
        DATA
        DC8 "Setting Print and Travel Acceleration: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_0
// __absolute char const <_ZZ10gcode_M204vEs_0>[29]
_ZZ10gcode_M204vEs_0:
        DATA
        DC8 "Setting Print Acceleration: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_1
// __absolute char const <_ZZ10gcode_M204vEs_1>[31]
_ZZ10gcode_M204vEs_1:
        DATA
        DC8 "Setting Retract Acceleration: "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M204vEs_2
// __absolute char const <_ZZ10gcode_M204vEs_2>[30]
_ZZ10gcode_M204vEs_2:
        DATA
        DC8 "Setting Travel Acceleration: "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ15gcode_M666_dualvEs
// __absolute char const <_ZZ15gcode_M666_dualvEs>[31]
_ZZ15gcode_M666_dualvEs:
        DATA
        DC8 "Dual Endstop Adjustment (mm): "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ15gcode_M666_dualvEs_0
// __absolute char const <_ZZ15gcode_M666_dualvEs_0>[3]
_ZZ15gcode_M666_dualvEs_0:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs
// __absolute char const <_ZZ10gcode_M211vEs>[16]
_ZZ10gcode_M211vEs:
        DATA
        DC8 "Soft endstops: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_0
// __absolute char const <_ZZ10gcode_M211vEs_0>[4]
_ZZ10gcode_M211vEs_0:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_1
// __absolute char const <_ZZ10gcode_M211vEs_1>[4]
_ZZ10gcode_M211vEs_1:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_2
// __absolute char const <_ZZ10gcode_M211vEs_2>[8]
_ZZ10gcode_M211vEs_2:
        DATA
        DC8 "  Min: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(1)
        SECTION_GROUP _ZZ10gcode_M211vEs_3
// __absolute char const <_ZZ10gcode_M211vEs_3>[2]
_ZZ10gcode_M211vEs_3:
        DATA
        DC8 "X"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_4
// __absolute char const <_ZZ10gcode_M211vEs_4>[3]
_ZZ10gcode_M211vEs_4:
        DATA
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_5
// __absolute char const <_ZZ10gcode_M211vEs_5>[3]
_ZZ10gcode_M211vEs_5:
        DATA
        DC8 " Z"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M211vEs_6
// __absolute char const <_ZZ10gcode_M211vEs_6>[8]
_ZZ10gcode_M211vEs_6:
        DATA
        DC8 "  Max: "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M218vEs
// __absolute char const <_ZZ10gcode_M218vEs>[16]
_ZZ10gcode_M218vEs:
        DATA
        DC8 "Hotend offsets:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs
// __absolute char const <_ZZ10gcode_M280vEs>[8]
_ZZ10gcode_M280vEs:
        DATA
        DC8 " Servo "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs_0
// __absolute char const <_ZZ10gcode_M280vEs_0>[15]
_ZZ10gcode_M280vEs_0:
        DATA
        DC8 " out of range\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M280vEs_1
// __absolute char const <_ZZ10gcode_M280vEs_1>[7]
_ZZ10gcode_M280vEs_1:
        DATA
        DC8 "Servo "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ18mod_zprobe_zoffsetRKfEs
// __absolute char const <_ZZ18mod_zprobe_zoffsetRKfEs>[17]
_ZZ18mod_zprobe_zoffsetRKfEs:
        DATA
        DC8 "Probe Z Offset: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs
// __absolute char const <_ZZ10gcode_M301vEs>[4]
_ZZ10gcode_M301vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_0
// __absolute char const <_ZZ10gcode_M301vEs_0>[4]
_ZZ10gcode_M301vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_1
// __absolute char const <_ZZ10gcode_M301vEs_1>[4]
_ZZ10gcode_M301vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M301vEs_2
// __absolute char const <_ZZ10gcode_M301vEs_2>[17]
_ZZ10gcode_M301vEs_2:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs
// __absolute char const <_ZZ10gcode_M304vEs>[4]
_ZZ10gcode_M304vEs:
        DATA
        DC8 " p:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_0
// __absolute char const <_ZZ10gcode_M304vEs_0>[4]
_ZZ10gcode_M304vEs_0:
        DATA
        DC8 " i:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M304vEs_1
// __absolute char const <_ZZ10gcode_M304vEs_1>[4]
_ZZ10gcode_M304vEs_1:
        DATA
        DC8 " d:"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs
// __absolute char const <_ZZ10gcode_M302vEs>[19]
_ZZ10gcode_M302vEs:
        DATA
        DC8 "Cold extrudes are "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_0
// __absolute char const <_ZZ10gcode_M302vEs_0>[3]
_ZZ10gcode_M302vEs_0:
        DATA
        DC8 "en"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_1
// __absolute char const <_ZZ10gcode_M302vEs_1>[4]
_ZZ10gcode_M302vEs_1:
        DATA
        DC8 "dis"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_2
// __absolute char const <_ZZ10gcode_M302vEs_2>[17]
_ZZ10gcode_M302vEs_2:
        DATA
        DC8 "abled (min temp "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M302vEs_3
// __absolute char const <_ZZ10gcode_M302vEs_3>[4]
_ZZ10gcode_M302vEs_3:
        DATA
        DC8 "C)\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M303vEs
// __absolute char const <_ZZ10gcode_M303vEs>[18]
_ZZ10gcode_M303vEs:
        DATA
        DC8 "PIDTEMP disabled\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M360vEs
// __absolute char const <_ZZ10gcode_M360vEs>[15]
_ZZ10gcode_M360vEs:
        DATA
        DC8 " Cal: Theta 0\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M361vEs
// __absolute char const <_ZZ10gcode_M361vEs>[16]
_ZZ10gcode_M361vEs:
        DATA
        DC8 " Cal: Theta 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M362vEs
// __absolute char const <_ZZ10gcode_M362vEs>[13]
_ZZ10gcode_M362vEs:
        DATA
        DC8 " Cal: Psi 0\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M363vEs
// __absolute char const <_ZZ10gcode_M363vEs>[14]
_ZZ10gcode_M363vEs:
        DATA
        DC8 " Cal: Psi 90\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M364vEs
// __absolute char const <_ZZ10gcode_M364vEs>[20]
_ZZ10gcode_M364vEs:
        DATA
        DC8 " Cal: Theta-Psi 90\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs
// __absolute char const <_ZZ10gcode_M420vEs>[32]
_ZZ10gcode_M420vEs:
        DATA
        DC8 "?EEPROM storage not available.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_0
// __absolute char const <_ZZ10gcode_M420vEs_0>[24]
_ZZ10gcode_M420vEs_0:
        DATA
        DC8 "?Invalid storage slot.\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_1
// __absolute char const <_ZZ10gcode_M420vEs_1>[11]
_ZZ10gcode_M420vEs_1:
        DATA
        DC8 "?Use 0 to "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_2
// __absolute char const <_ZZ10gcode_M420vEs_2>[21]
_ZZ10gcode_M420vEs_2:
        DATA
        DC8 "ubl.mesh_is_valid = "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_3
// __absolute char const <_ZZ10gcode_M420vEs_3>[20]
_ZZ10gcode_M420vEs_3:
        DATA
        DC8 "ubl.storage_slot = "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_4
// __absolute char const <_ZZ10gcode_M420vEs_4>[29]
_ZZ10gcode_M420vEs_4:
        DATA
        DC8 "Bed Level Correction Matrix:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_5
// __absolute char const <_ZZ10gcode_M420vEs_5>[22]
_ZZ10gcode_M420vEs_5:
        DATA
        DC8 "Mesh Bed Level data:\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_6
// __absolute char const <_ZZ10gcode_M420vEs_6>[31]
_ZZ10gcode_M420vEs_6:
        DATA
        DC8 "Failed to enable Bed Leveling\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_7
// __absolute char const <_ZZ10gcode_M420vEs_7>[14]
_ZZ10gcode_M420vEs_7:
        DATA
        DC8 "Bed Leveling "
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_8
// __absolute char const <_ZZ10gcode_M420vEs_8>[4]
_ZZ10gcode_M420vEs_8:
        DATA
        DC8 "On "

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs_9
// __absolute char const <_ZZ10gcode_M420vEs_9>[4]
_ZZ10gcode_M420vEs_9:
        DATA
        DC8 "Off"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs__10_
// __absolute char const <_ZZ10gcode_M420vEs__10_>[13]
_ZZ10gcode_M420vEs__10_:
        DATA
        DC8 "Fade Height "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M420vEs__11_
// __absolute char const <_ZZ10gcode_M420vEs__11_>[5]
_ZZ10gcode_M420vEs__11_:
        DATA
        DC8 "Off\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs>[32]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
// __absolute char const <_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0>[31]
_ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
// __absolute char const <_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs>[32]
_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
// __absolute char const <_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0>[31]
_ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
// __absolute char const <_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs>[32]
_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs:
        DATA
        DC8 "M421 incorrect parameter usage\012"

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
// __absolute char const <_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0>[31]
_ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0:
        DATA
        DC8 "Mesh point cannot be resolved\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M428vEs
// __absolute char const <_ZZ10gcode_M428vEs>[30]
_ZZ10gcode_M428vEs:
        DATA
        DC8 "Too far from reference point\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs
// __absolute char const <_ZZ10gcode_M851vEs>[15]
_ZZ10gcode_M851vEs:
        DATA
        DC8 "Probe Z Offset"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_0
// __absolute char const <_ZZ10gcode_M851vEs_0>[25]
_ZZ10gcode_M851vEs_0:
        DATA
        DC8 " z_min:  -20 z_max:  20\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M851vEs_1
// __absolute char const <_ZZ10gcode_M851vEs_1>[3]
_ZZ10gcode_M851vEs_1:
        DATA
        DC8 ": "
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M355vEs
// __absolute char const <_ZZ10gcode_M355vEs>[15]
_ZZ10gcode_M355vEs:
        DATA
        DC8 "No case light\012"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ22invalid_extruder_errorhEs
// __absolute char const <_ZZ22invalid_extruder_errorhEs>[17]
_ZZ22invalid_extruder_errorhEs:
        DATA
        DC8 "Invalid extruder"
        DC8 0, 0, 0
// 4986 
// 4987   /**
// 4988    * G29: Mesh-based Z probe, probes a grid and produces a
// 4989    *      mesh to compensate for variable bed height
// 4990    *
// 4991    * Parameters With MESH_BED_LEVELING:
// 4992    *
// 4993    *  S0              Produce a mesh report
// 4994    *  S1              Start probing mesh points
// 4995    *  S2              Probe the next mesh point
// 4996    *  S3 Xn Yn Zn.nn  Manually modify a single point
// 4997    *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
// 4998    *  S5              Reset and disable mesh
// 4999    *
// 5000    * The S0 report the points as below
// 5001    *
// 5002    *  +----> X-axis  1-n
// 5003    *  |
// 5004    *  |
// 5005    *  v Y-axis  1-n
// 5006    *
// 5007    */
// 5008 //  inline void gcode_G29() {
// 5009 inline void gcode_G29_MESH_BED_LEVELING() {
// 5010 
// 5011     static int mbl_probe_index = -1;
// 5012     #if HAS_SOFTWARE_ENDSTOPS
// 5013       static bool enable_soft_endstops;
// 5014     #endif
// 5015 
// 5016     const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
// 5017     if (!WITHIN(state, 0, 5)) {
// 5018       SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
// 5019       return;
// 5020     }
// 5021 
// 5022     int8_t px, py;
// 5023 
// 5024     switch (state) {
// 5025       case MeshReport:
// 5026         if (leveling_is_valid()) {
// 5027           SERIAL_PROTOCOLLNPAIR("State: ", planner.leveling_active ? MSG_ON : MSG_OFF);
// 5028           mbl_mesh_report();
// 5029         }
// 5030         else
// 5031           SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
// 5032         break;
// 5033 
// 5034       case MeshStart:
// 5035         mbl.reset();
// 5036         mbl_probe_index = 0;
// 5037         enqueue_and_echo_commands_P(lcd_wait_for_move ? PSTR("G29 S2") : PSTR("G28\nG29 S2"));
// 5038         break;
// 5039 
// 5040       case MeshNext:
// 5041         if (mbl_probe_index < 0) {
// 5042           SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
// 5043           return;
// 5044         }
// 5045         // For each G29 S2...
// 5046         if (mbl_probe_index == 0) {
// 5047           #if HAS_SOFTWARE_ENDSTOPS
// 5048             // For the initial G29 S2 save software endstop state
// 5049             enable_soft_endstops = soft_endstops_enabled;
// 5050           #endif
// 5051         }
// 5052         else {
// 5053           // For G29 S2 after adjusting Z.
// 5054           mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
// 5055           #if HAS_SOFTWARE_ENDSTOPS
// 5056             soft_endstops_enabled = enable_soft_endstops;
// 5057           #endif
// 5058         }
// 5059         // If there's another point to sample, move there with optional lift.
// 5060         if (mbl_probe_index < GRID_MAX_POINTS) {
// 5061           mbl.zigzag(mbl_probe_index, px, py);
// 5062           _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
// 5063 
// 5064           #if HAS_SOFTWARE_ENDSTOPS
// 5065             // Disable software endstops to allow manual adjustment
// 5066             // If G29 is not completed, they will not be re-enabled
// 5067             soft_endstops_enabled = false;
// 5068           #endif
// 5069 
// 5070           mbl_probe_index++;
// 5071         }
// 5072         else {
// 5073           // One last "return to the bed" (as originally coded) at completion
// 5074           current_position[Z_AXIS] = Z_MIN_POS + MANUAL_PROBE_HEIGHT;
// 5075           buffer_line_to_current_position();
// 5076           stepper.synchronize();
// 5077 
// 5078           // After recording the last point, activate home and activate
// 5079           mbl_probe_index = -1;
// 5080           SERIAL_PROTOCOLLNPGM("Mesh probing done.");
// 5081           BUZZ(100, 659);
// 5082           BUZZ(100, 698);
// 5083           mbl.has_mesh = true;
// 5084 
// 5085           home_all_axes();
// 5086           set_bed_leveling_enabled(true);
// 5087 
// 5088           #if ENABLED(MESH_G28_REST_ORIGIN)
// 5089             current_position[Z_AXIS] = Z_MIN_POS;
// 5090             set_destination_from_current();
// 5091             buffer_line_to_destination(homing_feedrate_mm_s[Z_AXIS]);
// 5092             stepper.synchronize();
// 5093           #endif
// 5094 
// 5095           #if ENABLED(LCD_BED_LEVELING)
// 5096             lcd_wait_for_move = false;
// 5097           #endif
// 5098         }
// 5099         break;
// 5100 
// 5101       case MeshSet:
// 5102         if (parser.seenval('X')) {
// 5103           px = parser.value_int() - 1;
// 5104           if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
// 5105             SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
// 5106             return;
// 5107           }
// 5108         }
// 5109         else {
// 5110           SERIAL_CHAR('X'); echo_not_entered();
// 5111           return;
// 5112         }
// 5113 
// 5114         if (parser.seenval('Y')) {
// 5115           py = parser.value_int() - 1;
// 5116           if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
// 5117             SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
// 5118             return;
// 5119           }
// 5120         }
// 5121         else {
// 5122           SERIAL_CHAR('Y'); echo_not_entered();
// 5123           return;
// 5124         }
// 5125 
// 5126         if (parser.seenval('Z'))
// 5127           mbl.z_values[px][py] = parser.value_linear_units();
// 5128         else {
// 5129           SERIAL_CHAR('Z'); echo_not_entered();
// 5130           return;
// 5131         }
// 5132         break;
// 5133 
// 5134       case MeshSetZOffset:
// 5135         if (parser.seenval('Z'))
// 5136           mbl.z_offset = parser.value_linear_units();
// 5137         else {
// 5138           SERIAL_CHAR('Z'); echo_not_entered();
// 5139           return;
// 5140         }
// 5141         break;
// 5142 
// 5143       case MeshReset:
// 5144         reset_bed_level();
// 5145         break;
// 5146 
// 5147     } // switch(state)
// 5148 
// 5149     if (state == MeshStart || state == MeshNext) {
// 5150       SERIAL_PROTOCOLPAIR("MBL G29 point ", min(mbl_probe_index, GRID_MAX_POINTS));
// 5151       SERIAL_PROTOCOLLNPAIR(" of ", int(GRID_MAX_POINTS));
// 5152     }
// 5153 
// 5154     report_current_position();
// 5155   }
// 5156 #endif
// 5157 //#if 1
// 5158 //#elif OLDSCHOOL_ABL
// 5159 
// 5160   #if 1//ABL_GRID
// 5161     #if ENABLED(PROBE_Y_FIRST)
// 5162       #define PR_OUTER_VAR xCount
// 5163       #define PR_OUTER_END abl_grid_points_x
// 5164       #define PR_INNER_VAR yCount
// 5165       #define PR_INNER_END abl_grid_points_y
// 5166     #else
// 5167       #define PR_OUTER_VAR yCount
// 5168       #define PR_OUTER_END abl_grid_points_y
// 5169       #define PR_INNER_VAR xCount
// 5170       #define PR_INNER_END abl_grid_points_x
// 5171     #endif
// 5172   #endif
// 5173 
// 5174   /**
// 5175    * G29: Detailed Z probe, probes the bed at 3 or more points.
// 5176    *      Will fail if the printer has not been homed with G28.
// 5177    *
// 5178    * Enhanced G29 Auto Bed Leveling Probe Routine
// 5179    *
// 5180    *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
// 5181    *     or alter the bed level data. Useful to check the topology
// 5182    *     after a first run of G29.
// 5183    *
// 5184    *  J  Jettison current bed leveling data
// 5185    *
// 5186    *  V  Set the verbose level (0-4). Example: "G29 V3"
// 5187    *
// 5188    * Parameters With LINEAR leveling only:
// 5189    *
// 5190    *  P  Set the size of the grid that will be probed (P x P points).
// 5191    *     Example: "G29 P4"
// 5192    *
// 5193    *  X  Set the X size of the grid that will be probed (X x Y points).
// 5194    *     Example: "G29 X7 Y5"
// 5195    *
// 5196    *  Y  Set the Y size of the grid that will be probed (X x Y points).
// 5197    *
// 5198    *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
// 5199    *     This is useful for manual bed leveling and finding flaws in the bed (to
// 5200    *     assist with part placement).
// 5201    *     Not supported by non-linear delta printer bed leveling.
// 5202    *
// 5203    * Parameters With LINEAR and BILINEAR leveling only:
// 5204    *
// 5205    *  S  Set the XY travel speed between probe points (in units/min)
// 5206    *
// 5207    *  F  Set the Front limit of the probing grid
// 5208    *  B  Set the Back limit of the probing grid
// 5209    *  L  Set the Left limit of the probing grid
// 5210    *  R  Set the Right limit of the probing grid
// 5211    *
// 5212    * Parameters with DEBUG_LEVELING_FEATURE only:
// 5213    *
// 5214    *  C  Make a totally fake grid with no actual probing.
// 5215    *     For use in testing when no probing is possible.
// 5216    *
// 5217    * Parameters with BILINEAR leveling only:
// 5218    *
// 5219    *  Z  Supply an additional Z probe offset
// 5220    *
// 5221    * Extra parameters with PROBE_MANUALLY:
// 5222    *
// 5223    *  To do manual probing simply repeat G29 until the procedure is complete.
// 5224    *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
// 5225    *
// 5226    *  Q  Query leveling and G29 state
// 5227    *
// 5228    *  A  Abort current leveling procedure
// 5229    *
// 5230    * Extra parameters with BILINEAR only:
// 5231    *
// 5232    *  W  Write a mesh point. (If G29 is idle.)
// 5233    *  I  X index for mesh point
// 5234    *  J  Y index for mesh point
// 5235    *  X  X for mesh point, overrides I
// 5236    *  Y  Y for mesh point, overrides J
// 5237    *  Z  Z for mesh point. Otherwise, raw current Z.
// 5238    *
// 5239    * Without PROBE_MANUALLY:
// 5240    *
// 5241    *  E  By default G29 will engage the Z probe, test the bed, then disengage.
// 5242    *     Include "E" to engage/disengage the Z probe for each sample.
// 5243    *     There's no extra effect if you have a fixed Z probe.
// 5244    *
// 5245    */
// 5246   inline void gcode_G29() {
// 5247 
// 5248     // G29 Q is also available if debugging
// 5249     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5250       const bool query = parser.seen('Q');
// 5251       const uint8_t old_debug_flags = marlin_debug_flags;
// 5252       if (query) marlin_debug_flags |= DEBUG_LEVELING;
// 5253       if (DEBUGGING(LEVELING)) {
// 5254         DEBUG_POS(">>> G29", current_position);
// 5255         log_machine_info();
// 5256       }
// 5257       marlin_debug_flags = old_debug_flags;
// 5258       #if DISABLED(PROBE_MANUALLY)
// 5259         if (query) return;
// 5260       #endif
// 5261     #endif
// 5262 
// 5263     #if ENABLED(PROBE_MANUALLY)
// 5264       const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
// 5265     #endif
// 5266 
// 5267     #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
// 5268       const bool faux = parser.boolval('C');
// 5269     #elif ENABLED(PROBE_MANUALLY)
// 5270       const bool faux = no_action;
// 5271     #else
// 5272       bool constexpr faux = false;
// 5273     #endif
// 5274 
// 5275     // Don't allow auto-leveling without homing first
// 5276     if (axis_unhomed_error()) return;
// 5277 
// 5278     // Define local vars 'static' for manual probing, 'auto' otherwise
// 5279     #if ENABLED(PROBE_MANUALLY)
// 5280       #define ABL_VAR static
// 5281     #else
// 5282       #define ABL_VAR
// 5283     #endif
// 5284 
// 5285     ABL_VAR int verbose_level=0;
// 5286     ABL_VAR float xProbe=0, yProbe=0, measured_z=0;
// 5287     ABL_VAR bool dryrun=false, abl_should_enable=false;
// 5288 
// 5289     //#if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5290       ABL_VAR int abl_probe_index=0;
// 5291     //#endif
// 5292 
// 5293     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
// 5294       ABL_VAR bool enable_soft_endstops = true;
// 5295     #endif
// 5296 
// 5297     #if 1//ABL_GRID
// 5298 
// 5299       #if ENABLED(PROBE_MANUALLY)
// 5300         ABL_VAR uint8_t PR_OUTER_VAR;
// 5301         ABL_VAR  int8_t PR_INNER_VAR;
// 5302       #endif
// 5303 
// 5304       ABL_VAR int left_probe_bed_position=0, right_probe_bed_position=0, front_probe_bed_position=0, back_probe_bed_position=0;
// 5305       ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
// 5306 
// 5307       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5308         ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
// 5309                         abl_grid_points_y = GRID_MAX_POINTS_Y;
// 5310         ABL_VAR bool do_topography_map=0;
// 5311       //#else // Bilinear
// 5312       //  uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
// 5313       //                    abl_grid_points_y = GRID_MAX_POINTS_Y;
// 5314       //#endif
// 5315 
// 5316       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5317         ABL_VAR int abl2;
// 5318       //#elif ENABLED(PROBE_MANUALLY) // Bilinear
// 5319       //  int constexpr abl2 = GRID_MAX_POINTS;
// 5320       //#endif
// 5321       if(! (BED_LEVELING_METHOD&ABL_PLANAR)) abl2 = GRID_MAX_POINTS;
// 5322 
// 5323       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5324 
// 5325         ABL_VAR float zoffset;
// 5326 
// 5327       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5328 
// 5329         ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X_MAX][GRID_MAX_POINTS_Y_MAX];
// 5330 
// 5331         ABL_VAR float *eqnAMatrix=NULL,//[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
// 5332                       *eqnBVector=NULL,//[GRID_MAX_POINTS],     // "B" vector of Z points
// 5333                       mean;
// 5334 		eqnAMatrix = (float *)malloc((GRID_MAX_POINTS * 3 + 1) * sizeof(float));
// 5335 		if(eqnAMatrix == NULL)
// 5336 			{
// 5337 			Running = false;
// 5338 			kill("malloc eqnAMatrix err!");
// 5339 			}
// 5340 		for(int i=0;i<GRID_MAX_POINTS * 3 + 1;i++)
// 5341             *(eqnAMatrix+i) = 0.0;
// 5342 
// 5343 		
// 5344 		eqnBVector = (float *)malloc((GRID_MAX_POINTS + 1) * sizeof(float));
// 5345 		if(eqnBVector == NULL)
// 5346 		{
// 5347 			Running = false;
// 5348 			kill("malloc eqnBVector err!");
// 5349 		}
// 5350 		for(int i=0;i<GRID_MAX_POINTS + 1;i++) 	*(eqnBVector+i) = 0.0;        
// 5351       //#endif
// 5352 
// 5353    // #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5354 
// 5355       #if ENABLED(PROBE_MANUALLY)
// 5356         int constexpr abl2 = 3; // used to show total points
// 5357       #endif
// 5358 
// 5359       // Probe at 3 arbitrary points
// 5360       ABL_VAR vector_3 points[3] = {
// 5361         vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
// 5362         vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
// 5363         vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
// 5364       };
// 5365 
// 5366    // #endif // AUTO_BED_LEVELING_3POINT
// 5367 
// 5368     //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5369     struct linear_fit_data lsf_results;
// 5370     if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_LINEAR)
// 5371     {
// 5372       incremental_LSF_reset(&lsf_results);
// 5373     }
// 5374     //#endif
// 5375 
// 5376     /**
// 5377      * On the initial G29 fetch command parameters.
// 5378      */
// 5379     if (!g29_in_progress) {
// 5380 #if 0
// 5381       #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5382         abl_probe_index = -1;
// 5383       #endif
// 5384 #else
// 5385       if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5386          abl_probe_index = -1;
// 5387 #endif
// 5388       abl_should_enable = planner.leveling_active;
// 5389 
// 5390       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5391       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 5392 
// 5393         if (parser.seen('W')) {
// 5394           if (!leveling_is_valid()) {
// 5395             SERIAL_ERROR_START();
// 5396             SERIAL_ERRORLNPGM("No bilinear grid");
// 5397             return;
// 5398           }
// 5399 
// 5400           const float rz = parser.seenval('Z') ? RAW_Z_POSITION(parser.value_linear_units()) : current_position[Z_AXIS];
// 5401           if (!WITHIN(rz, -10, 10)) {
// 5402             SERIAL_ERROR_START();
// 5403             SERIAL_ERRORLNPGM("Bad Z value");
// 5404             return;
// 5405           }
// 5406 
// 5407           const float rx = RAW_X_POSITION(parser.linearval('X', NAN)),
// 5408                       ry = RAW_Y_POSITION(parser.linearval('Y', NAN));
// 5409           int8_t i = parser.byteval('I', -1),
// 5410                  j = parser.byteval('J', -1);
// 5411 
// 5412           if (!isnan(rx) && !isnan(ry)) {
// 5413             // Get nearest i / j from rx / ry
// 5414             i = (rx - bilinear_start[X_AXIS] + 0.5 * xGridSpacing) / xGridSpacing;
// 5415             j = (ry - bilinear_start[Y_AXIS] + 0.5 * yGridSpacing) / yGridSpacing;
// 5416             i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
// 5417             j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
// 5418           }
// 5419           if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
// 5420             set_bed_leveling_enabled(false);
// 5421             z_values[i][j] = rz;
// 5422             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5423               bed_level_virt_interpolate();
// 5424             #endif
// 5425             set_bed_leveling_enabled(abl_should_enable);
// 5426             if (abl_should_enable) report_current_position();
// 5427           }
// 5428           return;
// 5429         } // parser.seen('W')
// 5430       }
// 5431       //#endif
// 5432 
// 5433       // Jettison bed leveling data
// 5434       if (parser.seen('J')) {
// 5435         reset_bed_level();
// 5436         return;
// 5437       }
// 5438 
// 5439       verbose_level = parser.intval('V');
// 5440       if (!WITHIN(verbose_level, 0, 4)) {
// 5441         SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 5442         return;
// 5443       }
// 5444 
// 5445       dryrun = parser.boolval('D')
// 5446         #if ENABLED(PROBE_MANUALLY)
// 5447           || no_action
// 5448         #endif
// 5449       ;
// 5450 
// 5451       //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5452       if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5453         {
// 5454         do_topography_map = verbose_level > 2 || parser.boolval('T');
// 5455 
// 5456         // X and Y specify points in each direction, overriding the default
// 5457         // These values may be saved with the completed mesh
// 5458         abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
// 5459         abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
// 5460         if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
// 5461 
// 5462         if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
// 5463           SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
// 5464           return;
// 5465         }
// 5466 
// 5467         abl2 = abl_grid_points_x * abl_grid_points_y;
// 5468         mean = 0;
// 5469         }
// 5470       //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5471       else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5472       {
// 5473         zoffset = parser.linearval('Z');
// 5474       }
// 5475 
// 5476       //#endif
// 5477 
// 5478       //#if ABL_GRID
// 5479       if(BED_LEVELING_METHOD&ABL_GRID)  {
// 5480 
// 5481         xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
// 5482 
// 5483         left_probe_bed_position  = parser.seenval('L') ? (int)RAW_X_POSITION(parser.value_linear_units()) : LEFT_PROBE_BED_POSITION;
// 5484         right_probe_bed_position = parser.seenval('R') ? (int)RAW_X_POSITION(parser.value_linear_units()) : RIGHT_PROBE_BED_POSITION;
// 5485         front_probe_bed_position = parser.seenval('F') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : FRONT_PROBE_BED_POSITION;
// 5486         back_probe_bed_position  = parser.seenval('B') ? (int)RAW_Y_POSITION(parser.value_linear_units()) : BACK_PROBE_BED_POSITION;
// 5487 
// 5488         const bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
// 5489                    left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
// 5490                    right_out_r = right_probe_bed_position > MAX_PROBE_X,
// 5491                    right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
// 5492                    front_out_f = front_probe_bed_position < MIN_PROBE_Y,
// 5493                    front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
// 5494                    back_out_b = back_probe_bed_position > MAX_PROBE_Y,
// 5495                    back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
// 5496 
// 5497         if (left_out || right_out || front_out || back_out) {
// 5498           if (left_out) {
// 5499             out_of_range_error(PSTR("(L)eft"));
// 5500             left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - (MIN_PROBE_EDGE);
// 5501           }
// 5502           if (right_out) {
// 5503             out_of_range_error(PSTR("(R)ight"));
// 5504             right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
// 5505           }
// 5506           if (front_out) {
// 5507             out_of_range_error(PSTR("(F)ront"));
// 5508             front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - (MIN_PROBE_EDGE);
// 5509           }
// 5510           if (back_out) {
// 5511             out_of_range_error(PSTR("(B)ack"));
// 5512             back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
// 5513           }
// 5514           return;
// 5515         }
// 5516 
// 5517         // probe at the points of a lattice grid
// 5518         xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
// 5519         yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
// 5520       }
// 5521       //#endif // ABL_GRID
// 5522 
// 5523       if (verbose_level > 0) {
// 5524         SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling");
// 5525         if (dryrun) SERIAL_PROTOCOLPGM(" (DRYRUN)");
// 5526         SERIAL_EOL();
// 5527       }
// 5528 
// 5529       stepper.synchronize();
// 5530 
// 5531       // Disable auto bed leveling during G29.
// 5532       // Be formal so G29 can be done successively without G28.
// 5533       set_bed_leveling_enabled(false);
// 5534 
// 5535       #if HAS_BED_PROBE
// 5536         // Deploy the probe. Probe will raise if needed.
// 5537         if (DEPLOY_PROBE()) {
// 5538           set_bed_leveling_enabled(abl_should_enable);
// 5539           return;
// 5540         }
// 5541       #endif
// 5542 
// 5543       if (!faux) setup_for_endstop_or_probe_move();
// 5544 
// 5545       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5546       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5547       {
// 5548         #if ENABLED(PROBE_MANUALLY)
// 5549           if (!no_action)
// 5550         #endif
// 5551         if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
// 5552           || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
// 5553           || left_probe_bed_position != bilinear_start[X_AXIS]
// 5554           || front_probe_bed_position != bilinear_start[Y_AXIS]
// 5555         ) {
// 5556           // Reset grid to 0.0 or "not probed". (Also disables ABL)
// 5557           reset_bed_level();
// 5558 
// 5559           // Initialize a grid with the given dimensions
// 5560           bilinear_grid_spacing[X_AXIS] = xGridSpacing;
// 5561           bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
// 5562           bilinear_start[X_AXIS] = left_probe_bed_position;
// 5563           bilinear_start[Y_AXIS] = front_probe_bed_position;
// 5564 
// 5565           // Can't re-enable (on error) until the new grid is written
// 5566           abl_should_enable = false;
// 5567         }
// 5568       }
// 5569       //#endif // AUTO_BED_LEVELING_BILINEAR
// 5570 
// 5571       //#if ENABLED(AUTO_BED_LEVELING_3POINT)
// 5572       if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_3POINT)
// 5573       {
// 5574         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5575           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
// 5576         #endif
// 5577 
// 5578         // Probe at 3 arbitrary points
// 5579         points[0].z = points[1].z = points[2].z = 0;
// 5580       }
// 5581       //#endif // AUTO_BED_LEVELING_3POINT
// 5582 
// 5583     } // !g29_in_progress
// 5584 
// 5585     #if ENABLED(PROBE_MANUALLY)
// 5586 
// 5587       // For manual probing, get the next index to probe now.
// 5588       // On the first probe this will be incremented to 0.
// 5589       if (!no_action) {
// 5590         ++abl_probe_index;
// 5591         g29_in_progress = true;
// 5592       }
// 5593 
// 5594       // Abort current G29 procedure, go back to idle state
// 5595       if (seenA && g29_in_progress) {
// 5596         SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
// 5597         #if HAS_SOFTWARE_ENDSTOPS
// 5598           soft_endstops_enabled = enable_soft_endstops;
// 5599         #endif
// 5600         set_bed_leveling_enabled(abl_should_enable);
// 5601         g29_in_progress = false;
// 5602         #if ENABLED(LCD_BED_LEVELING)
// 5603           lcd_wait_for_move = false;
// 5604         #endif
// 5605       }
// 5606 
// 5607       // Query G29 status
// 5608       if (verbose_level || seenQ) {
// 5609         SERIAL_PROTOCOLPGM("Manual G29 ");
// 5610         if (g29_in_progress) {
// 5611           SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
// 5612           SERIAL_PROTOCOLLNPAIR(" of ", abl2);
// 5613         }
// 5614         else
// 5615           SERIAL_PROTOCOLLNPGM("idle");
// 5616       }
// 5617 
// 5618       if (no_action) return;
// 5619 
// 5620       if (abl_probe_index == 0) {
// 5621         // For the initial G29 save software endstop state
// 5622         #if HAS_SOFTWARE_ENDSTOPS
// 5623           enable_soft_endstops = soft_endstops_enabled;
// 5624         #endif
// 5625       }
// 5626       else {
// 5627         // For G29 after adjusting Z.
// 5628         // Save the previous Z before going to the next point
// 5629         measured_z = current_position[Z_AXIS];
// 5630 
// 5631         #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5632 
// 5633           mean += measured_z;
// 5634           eqnBVector[abl_probe_index] = measured_z;
// 5635           eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5636           eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5637           eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5638 
// 5639           incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5640 
// 5641         #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5642 
// 5643           z_values[xCount][yCount] = measured_z + zoffset;
// 5644 
// 5645           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5646             if (DEBUGGING(LEVELING)) {
// 5647               SERIAL_PROTOCOLPAIR("Save X", xCount);
// 5648               SERIAL_PROTOCOLPAIR(" Y", yCount);
// 5649               SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
// 5650             }
// 5651           #endif
// 5652 
// 5653         #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5654 
// 5655           points[abl_probe_index].z = measured_z;
// 5656 
// 5657         #endif
// 5658       }
// 5659 
// 5660       //
// 5661       // If there's another point to sample, move there with optional lift.
// 5662       //
// 5663 
// 5664       #if ABL_GRID
// 5665 
// 5666         // Skip any unreachable points
// 5667         while (abl_probe_index < abl2) {
// 5668 
// 5669           // Set xCount, yCount based on abl_probe_index, with zig-zag
// 5670           PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
// 5671           PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
// 5672 
// 5673           // Probe in reverse order for every other row/column
// 5674           bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
// 5675 
// 5676           if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
// 5677 
// 5678           const float xBase = xCount * xGridSpacing + left_probe_bed_position,
// 5679                       yBase = yCount * yGridSpacing + front_probe_bed_position;
// 5680 
// 5681           xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5682           yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5683 
// 5684           #if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5685             indexIntoAB[xCount][yCount] = abl_probe_index;
// 5686           #endif
// 5687 
// 5688           // Keep looping till a reachable point is found
// 5689           if(MACHINETPYE & IS_KINEMATIC)
// 5690             if (position_is_reachable_IS_KINEMATIC(xProbe, yProbe)) break;
// 5691           else
// 5692             if (position_is_reachable_IS_CARTESIAN(xProbe, yProbe)) break;
// 5693             
// 5694           ++abl_probe_index;
// 5695         }
// 5696 
// 5697         // Is there a next point to move to?
// 5698         if (abl_probe_index < abl2) {
// 5699           _manual_goto_xy(xProbe, yProbe); // Can be used here too!
// 5700           #if HAS_SOFTWARE_ENDSTOPS
// 5701             // Disable software endstops to allow manual adjustment
// 5702             // If G29 is not completed, they will not be re-enabled
// 5703             soft_endstops_enabled = false;
// 5704           #endif
// 5705           return;
// 5706         }
// 5707         else {
// 5708 
// 5709           // Leveling done! Fall through to G29 finishing code below
// 5710 
// 5711           SERIAL_PROTOCOLLNPGM("Grid probing done.");
// 5712 
// 5713           // Re-enable software endstops, if needed
// 5714           #if HAS_SOFTWARE_ENDSTOPS
// 5715             soft_endstops_enabled = enable_soft_endstops;
// 5716           #endif
// 5717         }
// 5718 
// 5719       #elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5720 
// 5721         // Probe at 3 arbitrary points
// 5722         if (abl_probe_index < abl2) {
// 5723           xProbe = points[abl_probe_index].x;
// 5724           yProbe = points[abl_probe_index].y;
// 5725           _manual_goto_xy(xProbe, yProbe);
// 5726           #if HAS_SOFTWARE_ENDSTOPS
// 5727             // Disable software endstops to allow manual adjustment
// 5728             // If G29 is not completed, they will not be re-enabled
// 5729             soft_endstops_enabled = false;
// 5730           #endif
// 5731           return;
// 5732         }
// 5733         else {
// 5734 
// 5735           SERIAL_PROTOCOLLNPGM("3-point probing done.");
// 5736 
// 5737           // Re-enable software endstops, if needed
// 5738           #if HAS_SOFTWARE_ENDSTOPS
// 5739             soft_endstops_enabled = enable_soft_endstops;
// 5740           #endif
// 5741 
// 5742           if (!dryrun) {
// 5743             vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5744             if (planeNormal.z < 0) {
// 5745               planeNormal.x *= -1;
// 5746               planeNormal.y *= -1;
// 5747               planeNormal.z *= -1;
// 5748             }
// 5749             planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5750 
// 5751             // Can't re-enable (on error) until the new grid is written
// 5752             abl_should_enable = false;
// 5753           }
// 5754 
// 5755         }
// 5756 
// 5757       #endif // AUTO_BED_LEVELING_3POINT
// 5758 
// 5759     #else // !PROBE_MANUALLY
// 5760     {
// 5761       const bool stow_probe_after_each = parser.boolval('E');
// 5762 
// 5763       measured_z = 0;
// 5764 
// 5765       //#if ABL_GRID
// 5766         if(BED_LEVELING_METHOD&ABL_GRID)
// 5767         {
// 5768         bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
// 5769 
// 5770         measured_z = 0;
// 5771 
// 5772         // Outer loop is Y with PROBE_Y_FIRST disabled
// 5773         for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
// 5774 
// 5775           int8_t inStart, inStop, inInc;
// 5776 
// 5777           if (zig) { // away from origin
// 5778             inStart = 0;
// 5779             inStop = PR_INNER_END;
// 5780             inInc = 1;
// 5781           }
// 5782           else {     // towards origin
// 5783             inStart = PR_INNER_END - 1;
// 5784             inStop = -1;
// 5785             inInc = -1;
// 5786           }
// 5787 
// 5788           zig ^= true; // zag
// 5789 
// 5790           // Inner loop is Y with PROBE_Y_FIRST enabled
// 5791           for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
// 5792 
// 5793             float xBase = left_probe_bed_position + xGridSpacing * xCount,
// 5794                   yBase = front_probe_bed_position + yGridSpacing * yCount;
// 5795 
// 5796             xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
// 5797             yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
// 5798 
// 5799             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5800             if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5801               indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
// 5802             //#endif
// 5803 
// 5804             //#if IS_KINEMATIC
// 5805             if(MACHINETPYE & IS_KINEMATIC)
// 5806               // Avoid probing outside the round or hexagonal area
// 5807               if (!position_is_reachable_by_probe_IS_KINEMATIC(xProbe, yProbe)) continue;
// 5808             //#endif
// 5809             
// 5810             int16_t randData = rand()%200;
// 5811             if(randData > 100)  randData = 100 - randData;
// 5812 
// 5813             measured_z = faux ? 0.001 * randData/*random(-100, 101) */: probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5814 
// 5815             if (isnan(measured_z)) {
// 5816               set_bed_leveling_enabled(abl_should_enable);
// 5817               break;
// 5818             }
// 5819 
// 5820             //#if ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5821             if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_LINEAR)
// 5822             {
// 5823               mean += measured_z;
// 5824               /*
// 5825               eqnBVector[abl_probe_index] = measured_z;
// 5826               eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
// 5827               eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
// 5828               eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
// 5829               */
// 5830             *(eqnBVector+abl_probe_index) = measured_z;
// 5831             *(eqnAMatrix+abl_probe_index + 0 * abl2) = xProbe;
// 5832             *(eqnAMatrix+abl_probe_index + 1 * abl2) = yProbe;
// 5833             *(eqnAMatrix+abl_probe_index + 2 * abl2) = 1;
// 5834 
// 5835               incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
// 5836             }
// 5837             //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5838             else if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_BILINEAR)
// 5839             {
// 5840               z_values[xCount][yCount] = measured_z + zoffset;
// 5841             }
// 5842             //#endif
// 5843 
// 5844             abl_should_enable = false;
// 5845             idle();
// 5846 
// 5847           } // inner
// 5848         } // outer
// 5849       }
// 5850       //#elif ENABLED(AUTO_BED_LEVELING_3POINT)
// 5851       else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_3POINT)
// 5852       {
// 5853         // Probe at 3 arbitrary points
// 5854 
// 5855         for (uint8_t i = 0; i < 3; ++i) {
// 5856           // Retain the last probe position
// 5857           xProbe = points[i].x;
// 5858           yProbe = points[i].y;
// 5859           int16_t randData = rand()%200;
// 5860 	      if(randData > 100)	randData = 100 - randData;
// 5861           measured_z = faux ? 0.001 * randData/*random(-100, 101)*/ : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
// 5862           if (isnan(measured_z)) {
// 5863             set_bed_leveling_enabled(abl_should_enable);
// 5864             break;
// 5865           }
// 5866           points[i].z = measured_z;
// 5867         }
// 5868 
// 5869         if (!dryrun && !isnan(measured_z)) {
// 5870           vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
// 5871           if (planeNormal.z < 0) {
// 5872             planeNormal.x *= -1;
// 5873             planeNormal.y *= -1;
// 5874             planeNormal.z *= -1;
// 5875           }
// 5876           planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
// 5877 
// 5878           // Can't re-enable (on error) until the new grid is written
// 5879           abl_should_enable = false;
// 5880         }
// 5881       }
// 5882       //#endif // AUTO_BED_LEVELING_3POINT
// 5883 
// 5884       // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
// 5885       if (STOW_PROBE()) {
// 5886         set_bed_leveling_enabled(abl_should_enable);
// 5887         measured_z = NAN;
// 5888       }
// 5889     }
// 5890     #endif // !PROBE_MANUALLY
// 5891 
// 5892     //
// 5893     // G29 Finishing Code
// 5894     //
// 5895     // Unless this is a dry run, auto bed leveling will
// 5896     // definitely be enabled after this point.
// 5897     //
// 5898     // If code above wants to continue leveling, it should
// 5899     // return or loop before this point.
// 5900     //
// 5901 
// 5902     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 5903       if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
// 5904     #endif
// 5905 
// 5906     #if ENABLED(PROBE_MANUALLY)
// 5907       g29_in_progress = false;
// 5908       #if ENABLED(LCD_BED_LEVELING)
// 5909         lcd_wait_for_move = false;
// 5910       #endif
// 5911     #endif
// 5912 
// 5913     // Calculate leveling, print reports, correct the position
// 5914     if (!isnan(measured_z)) {
// 5915       //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 5916         if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 5917         {
// 5918             if (!dryrun) extrapolate_unprobed_bed_level();
// 5919             print_bilinear_leveling_grid();
// 5920 
// 5921             refresh_bed_level();
// 5922 
// 5923             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 5924               print_bilinear_leveling_grid_virt();
// 5925             #endif
// 5926        }
// 5927       //#elif ENABLED(AUTO_BED_LEVELING_LINEAR)
// 5928        else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_LINEAR)
// 5929         {
// 5930         // For LINEAR leveling calculate matrix, print reports, correct the position
// 5931 
// 5932         /**
// 5933          * solve the plane equation ax + by + d = z
// 5934          * A is the matrix with rows [x y 1] for all the probed points
// 5935          * B is the vector of the Z positions
// 5936          * the normal vector to the plane is formed by the coefficients of the
// 5937          * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
// 5938          * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
// 5939          */
// 5940         float plane_equation_coefficients[3];
// 5941 
// 5942         finish_incremental_LSF(&lsf_results);
// 5943         plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
// 5944         plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
// 5945         plane_equation_coefficients[2] = -lsf_results.D;
// 5946 
// 5947         mean /= abl2;
// 5948 
// 5949         if (verbose_level) {
// 5950           SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
// 5951           SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
// 5952           SERIAL_PROTOCOLPGM(" b: ");
// 5953           SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
// 5954           SERIAL_PROTOCOLPGM(" d: ");
// 5955           SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
// 5956           SERIAL_EOL();
// 5957           if (verbose_level > 2) {
// 5958             SERIAL_PROTOCOLPGM("Mean of sampled points: ");
// 5959             SERIAL_PROTOCOL_F(mean, 8);
// 5960             SERIAL_EOL();
// 5961           }
// 5962         }
// 5963 
// 5964         // Create the matrix but don't correct the position yet
// 5965         if (!dryrun)
// 5966           planner.bed_level_matrix = matrix_3x3::create_look_at(
// 5967             vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
// 5968           );
// 5969 
// 5970         // Show the Topography map if enabled
// 5971         if (do_topography_map) {
// 5972 
// 5973           SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
// 5974                                  "   +--- BACK --+\n"
// 5975                                  "   |           |\n"
// 5976                                  " L |    (+)    | R\n"
// 5977                                  " E |           | I\n"
// 5978                                  " F | (-) N (+) | G\n"
// 5979                                  " T |           | H\n"
// 5980                                  "   |    (-)    | T\n"
// 5981                                  "   |           |\n"
// 5982                                  "   O-- FRONT --+\n"
// 5983                                  " (0,0)");
// 5984 
// 5985           float min_diff = 999;
// 5986 
// 5987           for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 5988             for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 5989               int ind = indexIntoAB[xx][yy];
// 5990               /*
// 5991               float diff = eqnBVector[ind] - mean,
// 5992                     x_tmp = eqnAMatrix[ind + 0 * abl2],
// 5993                     y_tmp = eqnAMatrix[ind + 1 * abl2],
// 5994                     z_tmp = 0;
// 5995                     */
// 5996                   float diff = *(eqnBVector+ind) - mean,
// 5997                         x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 5998                         y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 5999                         z_tmp = 0;
// 6000 
// 6001               apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 6002 
// 6003               //NOMORE(min_diff, eqnBVector[ind] - z_tmp);
// 6004               NOMORE(min_diff, *(eqnBVector+ind) - z_tmp);
// 6005 
// 6006               if (diff >= 0.0)
// 6007                 SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
// 6008               else
// 6009                 SERIAL_PROTOCOLCHAR(' ');
// 6010               SERIAL_PROTOCOL_F(diff, 5);
// 6011             } // xx
// 6012             SERIAL_EOL();
// 6013           } // yy
// 6014           SERIAL_EOL();
// 6015 
// 6016           if (verbose_level > 3) {
// 6017             SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
// 6018 
// 6019             for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
// 6020               for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
// 6021                 int ind = indexIntoAB[xx][yy];
// 6022                 /*
// 6023                 float x_tmp = eqnAMatrix[ind + 0 * abl2],
// 6024                       y_tmp = eqnAMatrix[ind + 1 * abl2],
// 6025                       z_tmp = 0;
// 6026                       */
// 6027                 float x_tmp = *(eqnAMatrix+ind + 0 * abl2),
// 6028                       y_tmp = *(eqnAMatrix+ind + 1 * abl2),
// 6029                       z_tmp = 0;
// 6030 
// 6031                 apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
// 6032 
// 6033                 //float diff = eqnBVector[ind] - z_tmp - min_diff;
// 6034                 float diff = *(eqnBVector+ind) - z_tmp - min_diff;
// 6035                 if (diff >= 0.0)
// 6036                   SERIAL_PROTOCOLPGM(" +");
// 6037                 // Include + for column alignment
// 6038                 else
// 6039                   SERIAL_PROTOCOLCHAR(' ');
// 6040                 SERIAL_PROTOCOL_F(diff, 5);
// 6041               } // xx
// 6042               SERIAL_EOL();
// 6043             } // yy
// 6044             SERIAL_EOL();
// 6045           }
// 6046         } //do_topography_map
// 6047         }
// 6048       //#endif // AUTO_BED_LEVELING_LINEAR
// 6049 
// 6050       //#if ABL_PLANAR
// 6051       if(BED_LEVELING_METHOD&ABL_PLANAR)  {
// 6052 
// 6053         // For LINEAR and 3POINT leveling correct the current position
// 6054 
// 6055         if (verbose_level > 0)
// 6056           planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
// 6057 
// 6058         if (!dryrun) {
// 6059           //
// 6060           // Correct the current XYZ position based on the tilted plane.
// 6061           //
// 6062 
// 6063           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6064             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
// 6065           #endif
// 6066 
// 6067           float converted[XYZ];
// 6068           COPY(converted, current_position);
// 6069 
// 6070           planner.leveling_active = true;
// 6071           planner.unapply_leveling(converted); // use conversion machinery
// 6072           planner.leveling_active = false;
// 6073 
// 6074           // Use the last measured distance to the bed, if possible
// 6075           if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
// 6076             && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
// 6077           ) {
// 6078             const float simple_z = current_position[Z_AXIS] - measured_z;
// 6079             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6080               if (DEBUGGING(LEVELING)) {
// 6081                 SERIAL_ECHOPAIR("Z from Probe:", simple_z);
// 6082                 SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
// 6083                 SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
// 6084               }
// 6085             #endif
// 6086             converted[Z_AXIS] = simple_z;
// 6087           }
// 6088 
// 6089           // The rotated XY and corrected Z are now current_position
// 6090           COPY(current_position, converted);
// 6091 
// 6092           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6093             if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
// 6094           #endif
// 6095         }
// 6096         }
// 6097       //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 6098       else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR) {
// 6099 
// 6100         if (!dryrun) {
// 6101           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6102             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
// 6103           #endif
// 6104 
// 6105           // Unapply the offset because it is going to be immediately applied
// 6106           // and cause compensation movement in Z
// 6107           current_position[Z_AXIS] -= bilinear_z_offset(current_position);
// 6108 
// 6109           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6110             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
// 6111           #endif
// 6112         }
// 6113         }
// 6114       //#endif // ABL_PLANAR
// 6115 
// 6116       #ifdef Z_PROBE_END_SCRIPT
// 6117         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6118           if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
// 6119         #endif
// 6120         enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
// 6121         stepper.synchronize();
// 6122       #endif
// 6123 
// 6124       // Auto Bed Leveling is complete! Enable if possible.
// 6125       planner.leveling_active = dryrun ? abl_should_enable : true;
// 6126     } // !isnan(measured_z)
// 6127 
// 6128     // Restore state after probing
// 6129     if (!faux) clean_up_after_endstop_or_probe_move();
// 6130 
// 6131     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 6132       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< G29");
// 6133     #endif
// 6134 
// 6135     report_current_position();
// 6136 
// 6137     KEEPALIVE_STATE(IN_HANDLER);
// 6138 
// 6139     if (planner.leveling_active)
// 6140       SYNC_PLAN_POSITION_KINEMATIC();
// 6141 
// 6142     free(eqnBVector);
// 6143 	free(eqnAMatrix);
// 6144   }
// 6145 
// 6146 #endif // OLDSCHOOL_ABL
// 6147 
// 6148 #if HAS_BED_PROBE
// 6149 
// 6150   /**
// 6151    * G30: Do a single Z probe at the current XY
// 6152    *
// 6153    * Parameters:
// 6154    *
// 6155    *   X   Probe X position (default current X)
// 6156    *   Y   Probe Y position (default current Y)
// 6157    *   E   Engage the probe for each probe
// 6158    */
// 6159   inline void gcode_G30() {
// 6160     const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
// 6161                 ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 6162     if(MACHINETPYE & IS_KINEMATIC)
// 6163         if (!position_is_reachable_by_probe_IS_KINEMATIC(xpos, ypos)) return;
// 6164     else
// 6165         if (!position_is_reachable_by_probe_IS_CARTESIAN(xpos, ypos)) return;
// 6166 
// 6167     // Disable leveling so the planner won't mess with us
// 6168     //#if HAS_LEVELING
// 6169 	if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6170       set_bed_leveling_enabled(false);
// 6171     //#endif
// 6172 
// 6173     setup_for_endstop_or_probe_move();
// 6174 
// 6175     const float measured_z = probe_pt(xpos, ypos, parser.boolval('E'), 1);
// 6176 
// 6177     if (!isnan(measured_z)) {
// 6178       SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
// 6179       SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
// 6180       SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
// 6181     }
// 6182 
// 6183     clean_up_after_endstop_or_probe_move();
// 6184 
// 6185     report_current_position();
// 6186   }
// 6187 
// 6188   #if ENABLED(Z_PROBE_SLED)
// 6189 
// 6190     /**
// 6191      * G31: Deploy the Z probe
// 6192      */
// 6193     inline void gcode_G31() { DEPLOY_PROBE(); }
// 6194 
// 6195     /**
// 6196      * G32: Stow the Z probe
// 6197      */
// 6198     inline void gcode_G32() { STOW_PROBE(); }
// 6199 
// 6200   #endif // Z_PROBE_SLED
// 6201 
// 6202 #endif // HAS_BED_PROBE
// 6203 
// 6204 #if ENABLED(DELTA_AUTO_CALIBRATION)
// 6205 
// 6206   constexpr uint8_t _7P_STEP = 1,              // 7-point step - to change number of calibration points
// 6207                     _4P_STEP = _7P_STEP * 2,   // 4-point step
// 6208                     NPP      = _7P_STEP * 6;   // number of calibration points on the radius
// 6209   enum CalEnum {                               // the 7 main calibration points - add definitions if needed
// 6210     CEN      = 0,
// 6211     __A      = 1,
// 6212     _AB      = __A + _7P_STEP,
// 6213     __B      = _AB + _7P_STEP,
// 6214     _BC      = __B + _7P_STEP,
// 6215     __C      = _BC + _7P_STEP,
// 6216     _CA      = __C + _7P_STEP,
// 6217   };
// 6218 
// 6219   #define LOOP_CAL_PT(VAR, S, N) for (uint8_t VAR=S; VAR<=NPP; VAR+=N)
// 6220   #define F_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR<NPP+0.9999; VAR+=N)
// 6221   #define I_LOOP_CAL_PT(VAR, S, N) for (float VAR=S; VAR>CEN+0.9999; VAR-=N)
// 6222   #define LOOP_CAL_ALL(VAR) LOOP_CAL_PT(VAR, CEN, 1)
// 6223   #define LOOP_CAL_RAD(VAR) LOOP_CAL_PT(VAR, __A, _7P_STEP)
// 6224   #define LOOP_CAL_ACT(VAR, _4P, _OP) LOOP_CAL_PT(VAR, _OP ? _AB : __A, _4P ? _4P_STEP : _7P_STEP)
// 6225 
// 6226   static void print_signed_float(const char * const prefix, const float &f) {
// 6227     SERIAL_PROTOCOLPGM("  ");
// 6228     serialprintPGM(prefix);
// 6229     SERIAL_PROTOCOLCHAR(':');
// 6230     if (f >= 0) SERIAL_CHAR('+');
// 6231     SERIAL_PROTOCOL_F(f, 2);
// 6232   }
// 6233 
// 6234   static void print_G33_settings(const bool end_stops, const bool tower_angles) {
// 6235     SERIAL_PROTOCOLPAIR(".Height:", delta_height);
// 6236     if (end_stops) {
// 6237       print_signed_float(PSTR("Ex"), delta_endstop_adj[A_AXIS]);
// 6238       print_signed_float(PSTR("Ey"), delta_endstop_adj[B_AXIS]);
// 6239       print_signed_float(PSTR("Ez"), delta_endstop_adj[C_AXIS]);
// 6240     }
// 6241     if (end_stops && tower_angles) {
// 6242       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 6243       SERIAL_EOL();
// 6244       SERIAL_CHAR('.');
// 6245       SERIAL_PROTOCOL_SP(13);
// 6246     }
// 6247     if (tower_angles) {
// 6248       print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
// 6249       print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
// 6250       print_signed_float(PSTR("Tz"), delta_tower_angle_trim[C_AXIS]);
// 6251     }
// 6252     if ((!end_stops && tower_angles) || (end_stops && !tower_angles)) { // XOR
// 6253       SERIAL_PROTOCOLPAIR("  Radius:", delta_radius);
// 6254     }
// 6255     SERIAL_EOL();
// 6256   }
// 6257 
// 6258   static void print_G33_results(const float z_at_pt[NPP + 1], const bool tower_points, const bool opposite_points) {
// 6259     SERIAL_PROTOCOLPGM(".    ");
// 6260     print_signed_float(PSTR("c"), z_at_pt[CEN]);
// 6261     if (tower_points) {
// 6262       print_signed_float(PSTR(" x"), z_at_pt[__A]);
// 6263       print_signed_float(PSTR(" y"), z_at_pt[__B]);
// 6264       print_signed_float(PSTR(" z"), z_at_pt[__C]);
// 6265     }
// 6266     if (tower_points && opposite_points) {
// 6267       SERIAL_EOL();
// 6268       SERIAL_CHAR('.');
// 6269       SERIAL_PROTOCOL_SP(13);
// 6270     }
// 6271     if (opposite_points) {
// 6272       print_signed_float(PSTR("yz"), z_at_pt[_BC]);
// 6273       print_signed_float(PSTR("zx"), z_at_pt[_CA]);
// 6274       print_signed_float(PSTR("xy"), z_at_pt[_AB]);
// 6275     }
// 6276     SERIAL_EOL();
// 6277   }
// 6278 
// 6279   /**
// 6280    * After G33:
// 6281    *  - Move to the print ceiling (DELTA_HOME_TO_SAFE_ZONE only)
// 6282    *  - Stow the probe
// 6283    *  - Restore endstops state
// 6284    *  - Select the old tool, if needed
// 6285    */
// 6286   static void G33_cleanup(
// 6287     #if HOTENDS > 1
// 6288       const uint8_t old_tool_index
// 6289     #endif
// 6290   ) {
// 6291     #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
// 6292       do_blocking_move_to_z(delta_clip_start_height);
// 6293     #endif
// 6294     STOW_PROBE();
// 6295     clean_up_after_endstop_or_probe_move();
// 6296     #if HOTENDS > 1
// 6297       tool_change(old_tool_index, 0, true);
// 6298     #endif
// 6299   }
// 6300 
// 6301   inline float calibration_probe(const float nx, const float ny, const bool stow) {
// 6302     #if HAS_BED_PROBE
// 6303       return probe_pt(nx, ny, stow, 0, false);
// 6304     #else
// 6305       UNUSED(stow);
// 6306       return lcd_probe_pt(nx, ny);
// 6307     #endif
// 6308   }
// 6309 
// 6310   static float probe_G33_points(float z_at_pt[NPP + 1], const int8_t probe_points, const bool towers_set, const bool stow_after_each) {
// 6311     const bool _0p_calibration      = probe_points == 0,
// 6312                _1p_calibration      = probe_points == 1,
// 6313                _4p_calibration      = probe_points == 2,
// 6314                _4p_opposite_points  = _4p_calibration && !towers_set,
// 6315                _7p_calibration      = probe_points >= 3 || probe_points == 0,
// 6316                _7p_no_intermediates = probe_points == 3,
// 6317                _7p_1_intermediates  = probe_points == 4,
// 6318                _7p_2_intermediates  = probe_points == 5,
// 6319                _7p_4_intermediates  = probe_points == 6,
// 6320                _7p_6_intermediates  = probe_points == 7,
// 6321                _7p_8_intermediates  = probe_points == 8,
// 6322                _7p_11_intermediates = probe_points == 9,
// 6323                _7p_14_intermediates = probe_points == 10,
// 6324                _7p_intermed_points  = probe_points >= 4,
// 6325                _7p_6_centre         = probe_points >= 5 && probe_points <= 7,
// 6326                _7p_9_centre         = probe_points >= 8;
// 6327 
// 6328     LOOP_CAL_ALL(axis) z_at_pt[axis] = 0.0;
// 6329 
// 6330     if (!_0p_calibration) {
// 6331 
// 6332       if (!_7p_no_intermediates && !_7p_4_intermediates && !_7p_11_intermediates) { // probe the center
// 6333         z_at_pt[CEN] += calibration_probe(0, 0, stow_after_each);
// 6334         if (isnan(z_at_pt[CEN])) return NAN;
// 6335       }
// 6336 
// 6337       if (_7p_calibration) { // probe extra center points
// 6338         const float start  = _7p_9_centre ? _CA + _7P_STEP / 3.0 : _7p_6_centre ? _CA : __C,
// 6339                     steps  = _7p_9_centre ? _4P_STEP / 3.0 : _7p_6_centre ? _7P_STEP : _4P_STEP;
// 6340         I_LOOP_CAL_PT(axis, start, steps) {
// 6341           const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6342                       r = delta_calibration_radius * 0.1;
// 6343           z_at_pt[CEN] += calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 6344           if (isnan(z_at_pt[CEN])) return NAN;
// 6345        }
// 6346         z_at_pt[CEN] /= float(_7p_2_intermediates ? 7 : probe_points);
// 6347       }
// 6348 
// 6349       if (!_1p_calibration) {  // probe the radius
// 6350         const CalEnum start  = _4p_opposite_points ? _AB : __A;
// 6351         const float   steps  = _7p_14_intermediates ? _7P_STEP / 15.0 : // 15r * 6 + 10c = 100
// 6352                                _7p_11_intermediates ? _7P_STEP / 12.0 : // 12r * 6 +  9c = 81
// 6353                                _7p_8_intermediates  ? _7P_STEP /  9.0 : //  9r * 6 + 10c = 64
// 6354                                _7p_6_intermediates  ? _7P_STEP /  7.0 : //  7r * 6 +  7c = 49
// 6355                                _7p_4_intermediates  ? _7P_STEP /  5.0 : //  5r * 6 +  6c = 36
// 6356                                _7p_2_intermediates  ? _7P_STEP /  3.0 : //  3r * 6 +  7c = 25
// 6357                                _7p_1_intermediates  ? _7P_STEP /  2.0 : //  2r * 6 +  4c = 16
// 6358                                _7p_no_intermediates ? _7P_STEP :        //  1r * 6 +  3c = 9
// 6359                                _4P_STEP;                                // .5r * 6 +  1c = 4
// 6360         bool zig_zag = true;
// 6361         F_LOOP_CAL_PT(axis, start, _7p_9_centre ? steps * 3 : steps) {
// 6362           const int8_t offset = _7p_9_centre ? 1 : 0;
// 6363           for (int8_t circle = -offset; circle <= offset; circle++) {
// 6364             const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6365                         r = delta_calibration_radius * (1 + 0.1 * (zig_zag ? circle : - circle)),
// 6366                         interpol = fmod(axis, 1);
// 6367             const float z_temp = calibration_probe(cos(a) * r, sin(a) * r, stow_after_each);
// 6368             if (isnan(z_temp)) return NAN;
// 6369             // split probe point to neighbouring calibration points
// 6370             z_at_pt[uint8_t(round(axis - interpol + NPP - 1)) % NPP + 1] += z_temp * sq(cos(RADIANS(interpol * 90)));
// 6371             z_at_pt[uint8_t(round(axis - interpol))           % NPP + 1] += z_temp * sq(sin(RADIANS(interpol * 90)));
// 6372           }
// 6373           zig_zag = !zig_zag;
// 6374         }
// 6375         if (_7p_intermed_points)
// 6376           LOOP_CAL_RAD(axis)
// 6377             z_at_pt[axis] /= _7P_STEP / steps;
// 6378       }
// 6379 
// 6380       float S1 = z_at_pt[CEN],
// 6381             S2 = sq(z_at_pt[CEN]);
// 6382       int16_t N = 1;
// 6383       if (!_1p_calibration) { // std dev from zero plane
// 6384         LOOP_CAL_ACT(axis, _4p_calibration, _4p_opposite_points) {
// 6385           S1 += z_at_pt[axis];
// 6386           S2 += sq(z_at_pt[axis]);
// 6387           N++;
// 6388         }
// 6389         return round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
// 6390       }
// 6391     }
// 6392 
// 6393     return 0.00001;
// 6394   }
// 6395 
// 6396   #if HAS_BED_PROBE
// 6397 
// 6398     static bool G33_auto_tune() {
// 6399       float z_at_pt[NPP + 1]      = { 0.0 },
// 6400             z_at_pt_base[NPP + 1] = { 0.0 },
// 6401             z_temp, h_fac = 0.0, r_fac = 0.0, a_fac = 0.0, norm = 0.8;
// 6402 
// 6403       #define ZP(N,I) ((N) * z_at_pt[I])
// 6404       #define Z06(I)  ZP(6, I)
// 6405       #define Z03(I)  ZP(3, I)
// 6406       #define Z02(I)  ZP(2, I)
// 6407       #define Z01(I)  ZP(1, I)
// 6408       #define Z32(I)  ZP(3/2, I)
// 6409 
// 6410       SERIAL_PROTOCOLPGM("AUTO TUNE baseline");
// 6411       SERIAL_EOL();
// 6412       if (isnan(probe_G33_points(z_at_pt_base, 3, true, false))) return false;
// 6413       print_G33_results(z_at_pt_base, true, true);
// 6414 
// 6415       LOOP_XYZ(axis) {
// 6416         delta_endstop_adj[axis] -= 1.0;
// 6417         recalc_delta_settings();
// 6418 
// 6419         endstops.enable(true);
// 6420         if (!home_delta()) return false;
// 6421         endstops.not_homing();
// 6422 
// 6423         SERIAL_PROTOCOLPGM("Tuning E");
// 6424         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6425         SERIAL_EOL();
// 6426 
// 6427         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6428         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6429         print_G33_results(z_at_pt, true, true);
// 6430         delta_endstop_adj[axis] += 1.0;
// 6431         recalc_delta_settings();
// 6432         switch (axis) {
// 6433           case A_AXIS :
// 6434             h_fac += 4.0 / (Z03(CEN) +Z01(__A)                               +Z32(_CA) +Z32(_AB)); // Offset by X-tower end-stop
// 6435             break;
// 6436           case B_AXIS :
// 6437             h_fac += 4.0 / (Z03(CEN)           +Z01(__B)           +Z32(_BC)           +Z32(_AB)); // Offset by Y-tower end-stop
// 6438             break;
// 6439           case C_AXIS :
// 6440             h_fac += 4.0 / (Z03(CEN)                     +Z01(__C) +Z32(_BC) +Z32(_CA)          ); // Offset by Z-tower end-stop
// 6441             break;
// 6442         }
// 6443       }
// 6444       h_fac /= 3.0;
// 6445       h_fac *= norm; // Normalize to 1.02 for Kossel mini
// 6446 
// 6447       for (int8_t zig_zag = -1; zig_zag < 2; zig_zag += 2) {
// 6448         delta_radius += 1.0 * zig_zag;
// 6449         recalc_delta_settings();
// 6450 
// 6451         endstops.enable(true);
// 6452         if (!home_delta()) return false;
// 6453         endstops.not_homing();
// 6454 
// 6455         SERIAL_PROTOCOLPGM("Tuning R");
// 6456         SERIAL_PROTOCOL(zig_zag == -1 ? "-" : "+");
// 6457         SERIAL_EOL();
// 6458         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6459         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6460         print_G33_results(z_at_pt, true, true);
// 6461         delta_radius -= 1.0 * zig_zag;
// 6462         recalc_delta_settings();
// 6463         r_fac -= zig_zag * 6.0 / (Z03(__A) +Z03(__B) +Z03(__C) +Z03(_BC) +Z03(_CA) +Z03(_AB)); // Offset by delta radius
// 6464       }
// 6465       r_fac /= 2.0;
// 6466       r_fac *= 3 * norm; // Normalize to 2.25 for Kossel mini
// 6467 
// 6468       LOOP_XYZ(axis) {
// 6469         delta_tower_angle_trim[axis] += 1.0;
// 6470         delta_endstop_adj[(axis + 1) % 3] -= 1.0 / 4.5;
// 6471         delta_endstop_adj[(axis + 2) % 3] += 1.0 / 4.5;
// 6472         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6473         delta_height -= z_temp;
// 6474         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6475         recalc_delta_settings();
// 6476 
// 6477         endstops.enable(true);
// 6478         if (!home_delta()) return false;
// 6479         endstops.not_homing();
// 6480 
// 6481         SERIAL_PROTOCOLPGM("Tuning T");
// 6482         SERIAL_CHAR(tolower(axis_codes[axis]));
// 6483         SERIAL_EOL();
// 6484 
// 6485         if (isnan(probe_G33_points(z_at_pt, 3, true, false))) return false;
// 6486         LOOP_CAL_ALL(axis) z_at_pt[axis] -= z_at_pt_base[axis];
// 6487         print_G33_results(z_at_pt, true, true);
// 6488 
// 6489         delta_tower_angle_trim[axis] -= 1.0;
// 6490         delta_endstop_adj[(axis+1) % 3] += 1.0/4.5;
// 6491         delta_endstop_adj[(axis+2) % 3] -= 1.0/4.5;
// 6492         z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6493         delta_height -= z_temp;
// 6494         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6495         recalc_delta_settings();
// 6496         switch (axis) {
// 6497           case A_AXIS :
// 6498             a_fac += 4.0 / (          Z06(__B) -Z06(__C)           +Z06(_CA) -Z06(_AB)); // Offset by alpha tower angle
// 6499             break;
// 6500           case B_AXIS :
// 6501             a_fac += 4.0 / (-Z06(__A)          +Z06(__C) -Z06(_BC)           +Z06(_AB)); // Offset by beta tower angle
// 6502             break;
// 6503           case C_AXIS :
// 6504             a_fac += 4.0 / (Z06(__A) -Z06(__B)           +Z06(_BC) -Z06(_CA)          ); // Offset by gamma tower angle
// 6505             break;
// 6506         }
// 6507       }
// 6508       a_fac /= 3.0;
// 6509       a_fac *= norm; // Normalize to 0.83 for Kossel mini
// 6510 
// 6511       endstops.enable(true);
// 6512       if (!home_delta()) return false;
// 6513       endstops.not_homing();
// 6514       print_signed_float(PSTR( "H_FACTOR: "), h_fac);
// 6515       print_signed_float(PSTR(" R_FACTOR: "), r_fac);
// 6516       print_signed_float(PSTR(" A_FACTOR: "), a_fac);
// 6517       SERIAL_EOL();
// 6518       SERIAL_PROTOCOLPGM("Copy these values to Configuration.h");
// 6519       SERIAL_EOL();
// 6520       return true;
// 6521     }
// 6522 
// 6523   #endif // HAS_BED_PROBE
// 6524 
// 6525   /**
// 6526    * G33 - Delta '1-4-7-point' Auto-Calibration
// 6527    *       Calibrate height, endstops, delta radius, and tower angles.
// 6528    *
// 6529    * Parameters:
// 6530    *
// 6531    *   Pn  Number of probe points:
// 6532    *      P0     No probe. Normalize only.
// 6533    *      P1     Probe center and set height only.
// 6534    *      P2     Probe center and towers. Set height, endstops and delta radius.
// 6535    *      P3     Probe all positions: center, towers and opposite towers. Set all.
// 6536    *      P4-P10 Probe all positions + at different itermediate locations and average them.
// 6537    *
// 6538    *   T   Don't calibrate tower angle corrections
// 6539    *
// 6540    *   Cn.nn  Calibration precision; when omitted calibrates to maximum precision
// 6541    *
// 6542    *   Fn  Force to run at least n iterations and takes the best result
// 6543    *
// 6544    *   A   Auto tune calibartion factors (set in Configuration.h)
// 6545    *
// 6546    *   Vn  Verbose level:
// 6547    *      V0  Dry-run mode. Report settings and probe results. No calibration.
// 6548    *      V1  Report start and end settings only
// 6549    *      V2  Report settings at each iteration
// 6550    *      V3  Report settings and probe results
// 6551    *
// 6552    *   E   Engage the probe for each point
// 6553    */
// 6554   inline void gcode_G33() {
// 6555 
// 6556     const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
// 6557     if (!WITHIN(probe_points, 0, 10)) {
// 6558       SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (0-10).");
// 6559       return;
// 6560     }
// 6561 
// 6562     const int8_t verbose_level = parser.byteval('V', 1);
// 6563     if (!WITHIN(verbose_level, 0, 3)) {
// 6564       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-3).");
// 6565       return;
// 6566     }
// 6567 
// 6568     const float calibration_precision = parser.floatval('C', 0.0);
// 6569     if (calibration_precision < 0) {
// 6570       SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>=0).");
// 6571       return;
// 6572     }
// 6573 
// 6574     const int8_t force_iterations = parser.intval('F', 0);
// 6575     if (!WITHIN(force_iterations, 0, 30)) {
// 6576       SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
// 6577       return;
// 6578     }
// 6579 
// 6580     const bool towers_set           = !parser.boolval('T'),
// 6581                auto_tune            = parser.boolval('A'),
// 6582                stow_after_each      = parser.boolval('E'),
// 6583                _0p_calibration      = probe_points == 0,
// 6584                _1p_calibration      = probe_points == 1,
// 6585                _4p_calibration      = probe_points == 2,
// 6586                _7p_9_centre         = probe_points >= 8,
// 6587                _tower_results       = (_4p_calibration && towers_set)
// 6588                                       || probe_points >= 3 || probe_points == 0,
// 6589                _opposite_results    = (_4p_calibration && !towers_set)
// 6590                                       || probe_points >= 3 || probe_points == 0,
// 6591                _endstop_results     = probe_points != 1,
// 6592                _angle_results       = (probe_points >= 3 || probe_points == 0) && towers_set;
// 6593     const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
// 6594     int8_t iterations = 0;
// 6595     float test_precision,
// 6596           zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
// 6597           zero_std_dev_min = zero_std_dev,
// 6598           e_old[ABC] = {
// 6599             delta_endstop_adj[A_AXIS],
// 6600             delta_endstop_adj[B_AXIS],
// 6601             delta_endstop_adj[C_AXIS]
// 6602           },
// 6603           dr_old = delta_radius,
// 6604           zh_old = delta_height,
// 6605           ta_old[ABC] = {
// 6606             delta_tower_angle_trim[A_AXIS],
// 6607             delta_tower_angle_trim[B_AXIS],
// 6608             delta_tower_angle_trim[C_AXIS]
// 6609           };
// 6610 
// 6611     SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
// 6612 
// 6613     if (!_1p_calibration && !_0p_calibration) {  // test if the outer radius is reachable
// 6614       LOOP_CAL_RAD(axis) {
// 6615         const float a = RADIANS(210 + (360 / NPP) *  (axis - 1)),
// 6616                     r = delta_calibration_radius * (1 + (_7p_9_centre ? 0.1 : 0.0));
// 6617         if(MACHINETPYE & IS_KINEMATIC)
// 6618         {
// 6619         if (!position_is_reachable_IS_KINEMATIC(cos(a) * r, sin(a) * r)) {
// 6620           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6621           return;
// 6622         }
// 6623         else
// 6624         {
// 6625         if (!position_is_reachable_IS_CARTESIAN(cos(a) * r, sin(a) * r)) {
// 6626           SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
// 6627           return;        
// 6628         }
// 6629         }
// 6630       }
// 6631     }
// 6632 
// 6633     stepper.synchronize();
// 6634     //#if HAS_LEVELING
// 6635     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 6636       reset_bed_level(); // After calibration bed-level data is no longer valid
// 6637     //#endif
// 6638 
// 6639     #if HOTENDS > 1
// 6640       const uint8_t old_tool_index = active_extruder;
// 6641       tool_change(0, 0, true);
// 6642       #define G33_CLEANUP() G33_cleanup(old_tool_index)
// 6643     #else
// 6644       #define G33_CLEANUP() G33_cleanup()
// 6645     #endif
// 6646 
// 6647     setup_for_endstop_or_probe_move();
// 6648     endstops.enable(true);
// 6649     if (!_0p_calibration) {
// 6650       if (!home_delta())
// 6651         return;
// 6652       endstops.not_homing();
// 6653     }
// 6654 
// 6655     if (auto_tune) {
// 6656       #if HAS_BED_PROBE
// 6657         G33_auto_tune();
// 6658       #else
// 6659         SERIAL_PROTOCOLLNPGM("A probe is needed for auto-tune");
// 6660       #endif
// 6661       G33_CLEANUP();
// 6662       return;
// 6663     }
// 6664 
// 6665     // Report settings
// 6666 
// 6667     const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
// 6668     serialprintPGM(checkingac);
// 6669     if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
// 6670     SERIAL_EOL();
// 6671     lcd_setstatusPGM(checkingac);
// 6672 
// 6673     print_G33_settings(_endstop_results, _angle_results);
// 6674 
// 6675     do {
// 6676 
// 6677       float z_at_pt[NPP + 1] = { 0.0 };
// 6678 
// 6679       test_precision = zero_std_dev;
// 6680 
// 6681       iterations++;
// 6682 
// 6683       // Probe the points
// 6684 
// 6685       zero_std_dev = probe_G33_points(z_at_pt, probe_points, towers_set, stow_after_each);
// 6686       if (isnan(zero_std_dev)) {
// 6687         SERIAL_PROTOCOLPGM("Correct delta_radius with M665 R or end-stops with M666 X Y Z");
// 6688         SERIAL_EOL();
// 6689         return G33_CLEANUP();
// 6690       }
// 6691 
// 6692       // Solve matrices
// 6693 
// 6694       if ((zero_std_dev < test_precision || iterations <= force_iterations) && zero_std_dev > calibration_precision) {
// 6695         if (zero_std_dev < zero_std_dev_min) {
// 6696           COPY(e_old, delta_endstop_adj);
// 6697           dr_old = delta_radius;
// 6698           zh_old = delta_height;
// 6699           COPY(ta_old, delta_tower_angle_trim);
// 6700         }
// 6701 
// 6702         float e_delta[ABC] = { 0.0 }, r_delta = 0.0, t_delta[ABC] = { 0.0 };
// 6703         const float r_diff = delta_radius - delta_calibration_radius,
// 6704                     h_factor = 1 / 6.0 *
// 6705                       #ifdef H_FACTOR
// 6706                         (H_FACTOR),                                       // Set in Configuration.h
// 6707                       #else
// 6708                         (1.00 + r_diff * 0.001),                          // 1.02 for r_diff = 20mm
// 6709                       #endif
// 6710                     r_factor = 1 / 6.0 *
// 6711                       #ifdef R_FACTOR
// 6712                         -(R_FACTOR),                                      // Set in Configuration.h
// 6713                       #else
// 6714                         -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),    // 2.25 for r_diff = 20mm
// 6715                       #endif
// 6716                     a_factor = 1 / 6.0 *
// 6717                       #ifdef A_FACTOR
// 6718                         (A_FACTOR);                                       // Set in Configuration.h
// 6719                       #else
// 6720                         (66.66 / delta_calibration_radius);               // 0.83 for cal_rd = 80mm
// 6721                       #endif
// 6722 
// 6723         #define ZP(N,I) ((N) * z_at_pt[I])
// 6724         #define Z6(I) ZP(6, I)
// 6725         #define Z4(I) ZP(4, I)
// 6726         #define Z2(I) ZP(2, I)
// 6727         #define Z1(I) ZP(1, I)
// 6728 
// 6729         #if !HAS_BED_PROBE
// 6730           test_precision = 0.00; // forced end
// 6731         #endif
// 6732 
// 6733         switch (probe_points) {
// 6734           case 0:
// 6735             test_precision = 0.00; // forced end
// 6736             break;
// 6737 
// 6738           case 1:
// 6739             test_precision = 0.00; // forced end
// 6740             LOOP_XYZ(axis) e_delta[axis] = Z1(CEN);
// 6741             break;
// 6742 
// 6743           case 2:
// 6744             if (towers_set) {
// 6745               e_delta[A_AXIS] = (Z6(CEN) +Z4(__A) -Z2(__B) -Z2(__C)) * h_factor;
// 6746               e_delta[B_AXIS] = (Z6(CEN) -Z2(__A) +Z4(__B) -Z2(__C)) * h_factor;
// 6747               e_delta[C_AXIS] = (Z6(CEN) -Z2(__A) -Z2(__B) +Z4(__C)) * h_factor;
// 6748               r_delta         = (Z6(CEN) -Z2(__A) -Z2(__B) -Z2(__C)) * r_factor;
// 6749             }
// 6750             else {
// 6751               e_delta[A_AXIS] = (Z6(CEN) -Z4(_BC) +Z2(_CA) +Z2(_AB)) * h_factor;
// 6752               e_delta[B_AXIS] = (Z6(CEN) +Z2(_BC) -Z4(_CA) +Z2(_AB)) * h_factor;
// 6753               e_delta[C_AXIS] = (Z6(CEN) +Z2(_BC) +Z2(_CA) -Z4(_AB)) * h_factor;
// 6754               r_delta         = (Z6(CEN) -Z2(_BC) -Z2(_CA) -Z2(_AB)) * r_factor;
// 6755             }
// 6756             break;
// 6757 
// 6758           default:
// 6759             e_delta[A_AXIS] = (Z6(CEN) +Z2(__A) -Z1(__B) -Z1(__C) -Z2(_BC) +Z1(_CA) +Z1(_AB)) * h_factor;
// 6760             e_delta[B_AXIS] = (Z6(CEN) -Z1(__A) +Z2(__B) -Z1(__C) +Z1(_BC) -Z2(_CA) +Z1(_AB)) * h_factor;
// 6761             e_delta[C_AXIS] = (Z6(CEN) -Z1(__A) -Z1(__B) +Z2(__C) +Z1(_BC) +Z1(_CA) -Z2(_AB)) * h_factor;
// 6762             r_delta         = (Z6(CEN) -Z1(__A) -Z1(__B) -Z1(__C) -Z1(_BC) -Z1(_CA) -Z1(_AB)) * r_factor;
// 6763 
// 6764             if (towers_set) {
// 6765               t_delta[A_AXIS] = (         -Z4(__B) +Z4(__C)          -Z4(_CA) +Z4(_AB)) * a_factor;
// 6766               t_delta[B_AXIS] = ( Z4(__A)          -Z4(__C) +Z4(_BC)          -Z4(_AB)) * a_factor;
// 6767               t_delta[C_AXIS] = (-Z4(__A) +Z4(__B)          -Z4(_BC) +Z4(_CA)         ) * a_factor;
// 6768               e_delta[A_AXIS] += (t_delta[B_AXIS] - t_delta[C_AXIS]) / 4.5;
// 6769               e_delta[B_AXIS] += (t_delta[C_AXIS] - t_delta[A_AXIS]) / 4.5;
// 6770               e_delta[C_AXIS] += (t_delta[A_AXIS] - t_delta[B_AXIS]) / 4.5;
// 6771             }
// 6772             break;
// 6773         }
// 6774 
// 6775         LOOP_XYZ(axis) delta_endstop_adj[axis] += e_delta[axis];
// 6776         delta_radius += r_delta;
// 6777         LOOP_XYZ(axis) delta_tower_angle_trim[axis] += t_delta[axis];
// 6778       }
// 6779       else if (zero_std_dev >= test_precision) {   // step one back
// 6780         COPY(delta_endstop_adj, e_old);
// 6781         delta_radius = dr_old;
// 6782         delta_height = zh_old;
// 6783         COPY(delta_tower_angle_trim, ta_old);
// 6784       }
// 6785 
// 6786       if (verbose_level != 0) {                                    // !dry run
// 6787         // normalise angles to least squares
// 6788         if (_angle_results) {
// 6789           float a_sum = 0.0;
// 6790           LOOP_XYZ(axis) a_sum += delta_tower_angle_trim[axis];
// 6791           LOOP_XYZ(axis) delta_tower_angle_trim[axis] -= a_sum / 3.0;
// 6792         }
// 6793 
// 6794         // adjust delta_height and endstops by the max amount
// 6795         const float z_temp = MAX3(delta_endstop_adj[A_AXIS], delta_endstop_adj[B_AXIS], delta_endstop_adj[C_AXIS]);
// 6796         delta_height -= z_temp;
// 6797         LOOP_XYZ(axis) delta_endstop_adj[axis] -= z_temp;
// 6798       }
// 6799       recalc_delta_settings();
// 6800       NOMORE(zero_std_dev_min, zero_std_dev);
// 6801 
// 6802       // print report
// 6803 
// 6804       if (verbose_level > 2)
// 6805         print_G33_results(z_at_pt, _tower_results, _opposite_results);
// 6806 
// 6807       if (verbose_level != 0) {                                    // !dry run
// 6808         if ((zero_std_dev >= test_precision && iterations > force_iterations) || zero_std_dev <= calibration_precision) {  // end iterations
// 6809           SERIAL_PROTOCOLPGM("Calibration OK");
// 6810           SERIAL_PROTOCOL_SP(32);
// 6811           #if HAS_BED_PROBE
// 6812             if (zero_std_dev >= test_precision && !_1p_calibration)
// 6813               SERIAL_PROTOCOLPGM("rolling back.");
// 6814             else
// 6815           #endif
// 6816             {
// 6817               SERIAL_PROTOCOLPGM("std dev:");
// 6818               SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
// 6819             }
// 6820           SERIAL_EOL();
// 6821           char mess[21];
// 6822           strcpy_P(mess, PSTR("Calibration sd:"));
// 6823           if (zero_std_dev_min < 1)
// 6824             sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
// 6825           else
// 6826             sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
// 6827           lcd_setstatus(mess);
// 6828           print_G33_settings(_endstop_results, _angle_results);
// 6829           serialprintPGM(save_message);
// 6830           SERIAL_EOL();
// 6831         }
// 6832         else {                                                     // !end iterations
// 6833           char mess[15];
// 6834           if (iterations < 31)
// 6835             sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
// 6836           else
// 6837             strcpy_P(mess, PSTR("No convergence"));
// 6838           SERIAL_PROTOCOL(mess);
// 6839           SERIAL_PROTOCOL_SP(32);
// 6840           SERIAL_PROTOCOLPGM("std dev:");
// 6841           SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6842           SERIAL_EOL();
// 6843           lcd_setstatus(mess);
// 6844           if (verbose_level > 1)
// 6845             print_G33_settings(_endstop_results, _angle_results);
// 6846         }
// 6847       }
// 6848       else {                                                       // dry run
// 6849         const char *enddryrun = PSTR("End DRY-RUN");
// 6850         serialprintPGM(enddryrun);
// 6851         SERIAL_PROTOCOL_SP(35);
// 6852         SERIAL_PROTOCOLPGM("std dev:");
// 6853         SERIAL_PROTOCOL_F(zero_std_dev, 3);
// 6854         SERIAL_EOL();
// 6855 
// 6856         char mess[21];
// 6857         strcpy_P(mess, enddryrun);
// 6858         strcpy_P(&mess[11], PSTR(" sd:"));
// 6859         if (zero_std_dev < 1)
// 6860           sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
// 6861         else
// 6862           sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
// 6863         lcd_setstatus(mess);
// 6864       }
// 6865 
// 6866       endstops.enable(true);
// 6867       if (!home_delta())
// 6868         return;
// 6869       endstops.not_homing();
// 6870 
// 6871     }
// 6872     while (((zero_std_dev < test_precision && iterations < 31) || iterations <= force_iterations) && zero_std_dev > calibration_precision);
// 6873 
// 6874     G33_CLEANUP();
// 6875   }
// 6876 
// 6877 #endif // DELTA_AUTO_CALIBRATION
// 6878 
// 6879 #if ENABLED(G38_PROBE_TARGET)
// 6880 
// 6881   static bool G38_run_probe() {
// 6882 
// 6883     bool G38_pass_fail = false;
// 6884 
// 6885     #if MULTIPLE_PROBING > 1
// 6886       // Get direction of move and retract
// 6887       float retract_mm[XYZ];
// 6888       LOOP_XYZ(i) {
// 6889         float dist = destination[i] - current_position[i];
// 6890         retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
// 6891       }
// 6892     #endif
// 6893 
// 6894     stepper.synchronize();  // wait until the machine is idle
// 6895 
// 6896     // Move until destination reached or target hit
// 6897     endstops.enable(true);
// 6898     G38_move = true;
// 6899     G38_endstop_hit = false;
// 6900     prepare_move_to_destination();
// 6901     stepper.synchronize();
// 6902     G38_move = false;
// 6903 
// 6904     endstops.hit_on_purpose();
// 6905     set_current_from_steppers_for_axis(ALL_AXES);
// 6906     SYNC_PLAN_POSITION_KINEMATIC();
// 6907 
// 6908     if (G38_endstop_hit) {
// 6909 
// 6910       G38_pass_fail = true;
// 6911 
// 6912       #if MULTIPLE_PROBING > 1
// 6913         // Move away by the retract distance
// 6914         set_destination_from_current();
// 6915         LOOP_XYZ(i) destination[i] += retract_mm[i];
// 6916         endstops.enable(false);
// 6917         prepare_move_to_destination();
// 6918         stepper.synchronize();
// 6919 
// 6920         feedrate_mm_s /= 4;
// 6921 
// 6922         // Bump the target more slowly
// 6923         LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
// 6924 
// 6925         endstops.enable(true);
// 6926         G38_move = true;
// 6927         prepare_move_to_destination();
// 6928         stepper.synchronize();
// 6929         G38_move = false;
// 6930 
// 6931         set_current_from_steppers_for_axis(ALL_AXES);
// 6932         SYNC_PLAN_POSITION_KINEMATIC();
// 6933       #endif
// 6934     }
// 6935 
// 6936     endstops.hit_on_purpose();
// 6937     endstops.not_homing();
// 6938     return G38_pass_fail;
// 6939   }
// 6940 
// 6941   /**
// 6942    * G38.2 - probe toward workpiece, stop on contact, signal error if failure
// 6943    * G38.3 - probe toward workpiece, stop on contact
// 6944    *
// 6945    * Like G28 except uses Z min probe for all axes
// 6946    */
// 6947   inline void gcode_G38(bool is_38_2) {
// 6948     // Get X Y Z E F
// 6949     gcode_get_destination();
// 6950 
// 6951     setup_for_endstop_or_probe_move();
// 6952 
// 6953     // If any axis has enough movement, do the move
// 6954     LOOP_XYZ(i)
// 6955       if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
// 6956         if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate_mm_s[(AxisEnum)i];
// 6957         // If G38.2 fails throw an error
// 6958         if (!G38_run_probe() && is_38_2) {
// 6959           SERIAL_ERROR_START();
// 6960           SERIAL_ERRORLNPGM("Failed to reach target");
// 6961         }
// 6962         break;
// 6963       }
// 6964 
// 6965     clean_up_after_endstop_or_probe_move();
// 6966   }
// 6967 
// 6968 #endif // G38_PROBE_TARGET
// 6969 
// 6970 #if 1//HAS_MESH
// 6971 
// 6972   /**
// 6973    * G42: Move X & Y axes to mesh coordinates (I & J)
// 6974    */
// 6975   inline void gcode_G42() {
// 6976     #if ENABLED(NO_MOTION_BEFORE_HOMING)
// 6977       if (axis_unhomed_error()) return;
// 6978     #endif
// 6979 
// 6980     if (IsRunning()) {
// 6981       const bool hasI = parser.seenval('I');
// 6982       const int8_t ix = hasI ? parser.value_int() : 0;
// 6983       const bool hasJ = parser.seenval('J');
// 6984       const int8_t iy = hasJ ? parser.value_int() : 0;
// 6985 
// 6986       if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
// 6987         SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
// 6988         return;
// 6989       }
// 6990 
// 6991       set_destination_from_current();
// 6992       if (hasI) 
// 6993       {
// 6994         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 6995             destination[X_AXIS] = _GET_MESH_X_ABL(ix);
// 6996         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 6997             destination[X_AXIS] = _GET_MESH_X_UBL(ix);
// 6998         if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 6999             destination[X_AXIS] = _GET_MESH_X_MBL(ix);        
// 7000       }
// 7001       if (hasJ) 
// 7002       {
// 7003         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 7004             destination[Y_AXIS] = _GET_MESH_Y_ABL (iy);
// 7005         if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 7006             destination[Y_AXIS] = _GET_MESH_Y_UBL(iy);
// 7007         if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 7008             destination[Y_AXIS] = _GET_MESH_Y_MBL(iy);        
// 7009       }         
// 7010       if (parser.boolval('P')) {
// 7011         if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
// 7012         if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
// 7013       }
// 7014 
// 7015       const float fval = parser.linearval('F');
// 7016       if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
// 7017 
// 7018       // SCARA kinematic has "safe" XY raw moves
// 7019       //#if IS_SCARA
// 7020       if(MACHINETPYE & IS_SCARA)
// 7021         prepare_uninterpolated_move_to_destination();
// 7022       //#else
// 7023       else
// 7024         prepare_move_to_destination();
// 7025       //#endif
// 7026     }
// 7027   }
// 7028 
// 7029 #endif // HAS_MESH
// 7030 #if 0
// 7031 /**
// 7032  * G92: Set current position to given X Y Z E
// 7033  */
// 7034 inline void gcode_G92() {
// 7035 
// 7036   stepper.synchronize();
// 7037 
// 7038   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7039     switch (parser.subcode) {
// 7040       case 1:
// 7041         // Zero the G92 values and restore current position
// 7042         #if !IS_SCARA
// 7043           LOOP_XYZ(i) {
// 7044             const float v = position_shift[i];
// 7045             if (v) {
// 7046               position_shift[i] = 0;
// 7047               update_software_endstops((AxisEnum)i);
// 7048             }
// 7049           }
// 7050         #endif // Not SCARA
// 7051         return;
// 7052     }
// 7053   #endif
// 7054 
// 7055   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7056     #define IS_G92_0 (parser.subcode == 0)
// 7057   #else
// 7058     #define IS_G92_0 true
// 7059   #endif
// 7060 
// 7061   bool didE = false;
// 7062   bool didXYZ = false;
// 7063   //#if IS_SCARA || !HAS_POSITION_SHIFT
// 7064   if(MACHINETPYE&IS_SCARA) {
// 7065     //bool 
// 7066     didXYZ = false;
// 7067   }
// 7068   //#else
// 7069   else
// 7070   {
// 7071   	#if !HAS_POSITION_SHIFT
// 7072 		//bool 
// 7073 		didXYZ = false;	
// 7074   	#else
// 7075 		//constexpr bool 
// 7076 		didXYZ = false;
// 7077 	#endif
// 7078   }
// 7079   //#endif
// 7080 
// 7081   if (IS_G92_0) LOOP_XYZE(i) {
// 7082     if (parser.seenval(axis_codes[i])) {
// 7083       const float l = parser.value_axis_units((AxisEnum)i),
// 7084                   v = i == E_AXIS ? l : LOGICAL_TO_NATIVE(l, i),
// 7085                   d = v - current_position[i];
// 7086       if (!NEAR_ZERO(d)) {
// 7087         //#if IS_SCARA || !HAS_POSITION_SHIFT
// 7088         if(MACHINETPYE&IS_SCARA) {
// 7089           if (i == E_AXIS) didE = true; else didXYZ = true;
// 7090           current_position[i] = v;        // Without workspaces revert to Marlin 1.0 behavior
// 7091         }
// 7092 		else
// 7093 		{
// 7094 			#if HAS_POSITION_SHIFT
// 7095 	          if (i == E_AXIS) {
// 7096 	            didE = true;
// 7097 	            current_position[E_AXIS] = v; // When using coordinate spaces, only E is set directly
// 7098 	          }
// 7099 	          else {
// 7100 	            position_shift[i] += d;       // Other axes simply offset the coordinate space
// 7101 	            update_software_endstops((AxisEnum)i);
// 7102 	          }
// 7103 			
// 7104         	#endif
// 7105 		}
// 7106       }
// 7107     }
// 7108   }
// 7109 
// 7110   #if ENABLED(CNC_COORDINATE_SYSTEMS)
// 7111     // Apply workspace offset to the active coordinate system
// 7112     if (WITHIN(active_coordinate_system, 0, MAX_COORDINATE_SYSTEMS - 1))
// 7113       COPY(coordinate_system[active_coordinate_system], position_shift);
// 7114   #endif
// 7115 
// 7116   if (didXYZ)
// 7117     SYNC_PLAN_POSITION_KINEMATIC();
// 7118   else if (didE)
// 7119     sync_plan_position_e();
// 7120 
// 7121   report_current_position();
// 7122 }
// 7123 #else
// 7124 
// 7125 /**
// 7126  * G92: Set current position to given X Y Z E
// 7127  */
// 7128 inline void gcode_G92() {
// 7129   bool didXYZ = false,
// 7130        didE = parser.seen('E');
// 7131 
// 7132   if (!didE) stepper.synchronize();
// 7133 
// 7134   LOOP_XYZE(i) {
// 7135     if (parser.seenval(axis_codes[i])) {
// 7136       //#if IS_SCARA
// 7137       if(MACHINETPYE&IS_SCARA)
// 7138       {
// 7139         current_position[i] = parser.value_axis_units((AxisEnum)i);
// 7140         if (i != E_AXIS) didXYZ = true;
// 7141       }
// 7142       //#else
// 7143       else
// 7144       {
// 7145         #if HAS_POSITION_SHIFT
// 7146           const float p = current_position[i];
// 7147         #endif
// 7148         float v = parser.value_axis_units((AxisEnum)i);
// 7149 
// 7150         current_position[i] = v;
// 7151 
// 7152         if (i != E_AXIS) {
// 7153           didXYZ = true;
// 7154           #if HAS_POSITION_SHIFT
// 7155             position_shift[i] += v - p; // Offset the coordinate space
// 7156             update_software_endstops((AxisEnum)i);
// 7157           #endif
// 7158         }
// 7159       }
// 7160       //#endif
// 7161     }
// 7162   }
// 7163   if (didXYZ)
// 7164     SYNC_PLAN_POSITION_KINEMATIC();
// 7165   else if (didE)
// 7166     sync_plan_position_e();
// 7167 
// 7168   report_current_position();
// 7169 }
// 7170 
// 7171 #endif
// 7172 #if HAS_RESUME_CONTINUE
// 7173 
// 7174   /**
// 7175    * M0: Unconditional stop - Wait for user button press on LCD
// 7176    * M1: Conditional stop   - Wait for user button press on LCD
// 7177    */
// 7178   inline void gcode_M0_M1() {
// 7179     const char * const args = parser.string_arg;
// 7180 
// 7181     millis_t ms = 0;
// 7182     bool hasP = false, hasS = false;
// 7183     if (parser.seenval('P')) {
// 7184       ms = parser.value_millis(); // milliseconds to wait
// 7185       hasP = ms > 0;
// 7186     }
// 7187     if (parser.seenval('S')) {
// 7188       ms = parser.value_millis_from_seconds(); // seconds to wait
// 7189       hasS = ms > 0;
// 7190     }
// 7191 
// 7192     #if ENABLED(ULTIPANEL)
// 7193 
// 7194       if (!hasP && !hasS && args && *args)
// 7195         lcd_setstatus(args, true);
// 7196       else {
// 7197         LCD_MESSAGEPGM(MSG_USERWAIT);
// 7198         #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
// 7199           dontExpireStatus();
// 7200         #endif
// 7201       }
// 7202 
// 7203     #else
// 7204 
// 7205       if (!hasP && !hasS && args && *args) {
// 7206         SERIAL_ECHO_START();
// 7207         SERIAL_ECHOLN(args);
// 7208       }
// 7209 
// 7210     #endif
// 7211 
// 7212     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7213     wait_for_user = true;
// 7214 
// 7215     stepper.synchronize();
// 7216     refresh_cmd_timeout();
// 7217 
// 7218     if (ms > 0) {
// 7219       ms += previous_cmd_ms;  // wait until this time for a click
// 7220       while (PENDING(millis(), ms) && wait_for_user) idle();
// 7221     }
// 7222     else {
// 7223       #if ENABLED(ULTIPANEL)
// 7224         if (lcd_detected()) {
// 7225           while (wait_for_user) idle();
// 7226           print_job_timer.isPaused() ? LCD_MESSAGEPGM(WELCOME_MSG) : LCD_MESSAGEPGM(MSG_RESUMING);
// 7227         }
// 7228       #else
// 7229         while (wait_for_user) idle();
// 7230       #endif
// 7231     }
// 7232 
// 7233     wait_for_user = false;
// 7234     KEEPALIVE_STATE(IN_HANDLER);
// 7235   }
// 7236 
// 7237 #endif // HAS_RESUME_CONTINUE
// 7238 
// 7239 #if ENABLED(SPINDLE_LASER_ENABLE)
// 7240   /**
// 7241    * M3: Spindle Clockwise
// 7242    * M4: Spindle Counter-clockwise
// 7243    *
// 7244    *  S0 turns off spindle.
// 7245    *
// 7246    *  If no speed PWM output is defined then M3/M4 just turns it on.
// 7247    *
// 7248    *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
// 7249    *  Hardware PWM is required. ISRs are too slow.
// 7250    *
// 7251    * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
// 7252    *       No other settings give a PWM signal that goes from 0 to 5 volts.
// 7253    *
// 7254    *       The system automatically sets WGM to Mode 1, so no special
// 7255    *       initialization is needed.
// 7256    *
// 7257    *       WGM bits for timer 2 are automatically set by the system to
// 7258    *       Mode 1. This produces an acceptable 0 to 5 volt signal.
// 7259    *       No special initialization is needed.
// 7260    *
// 7261    * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
// 7262    *       factors for timers 2, 3, 4, and 5 are acceptable.
// 7263    *
// 7264    *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
// 7265    *  the spindle/laser during power-up or when connecting to the host
// 7266    *  (usually goes through a reset which sets all I/O pins to tri-state)
// 7267    *
// 7268    *  PWM duty cycle goes from 0 (off) to 255 (always on).
// 7269    */
// 7270 
// 7271   // Wait for spindle to come up to speed
// 7272   inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
// 7273 
// 7274   // Wait for spindle to stop turning
// 7275   inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
// 7276 
// 7277   /**
// 7278    * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
// 7279    *
// 7280    * it accepts inputs of 0-255
// 7281    */
// 7282 
// 7283   inline void ocr_val_mode() {
// 7284     uint8_t spindle_laser_power = parser.value_byte();
// 7285     WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
// 7286     if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
// 7287     analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
// 7288   }
// 7289 
// 7290   inline void gcode_M3_M4(bool is_M3) {
// 7291 
// 7292     stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
// 7293     #if SPINDLE_DIR_CHANGE
// 7294       const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
// 7295       if (SPINDLE_STOP_ON_DIR_CHANGE \ 
// 7296          && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \ 
// 7297          && READ(SPINDLE_DIR_PIN) != rotation_dir
// 7298       ) {
// 7299         WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
// 7300         delay_for_power_down();
// 7301       }
// 7302       WRITE(SPINDLE_DIR_PIN, rotation_dir);
// 7303     #endif
// 7304 
// 7305     /**
// 7306      * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
// 7307      * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
// 7308      * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
// 7309      */
// 7310     #if ENABLED(SPINDLE_LASER_PWM)
// 7311       if (parser.seen('O')) ocr_val_mode();
// 7312       else {
// 7313         const float spindle_laser_power = parser.floatval('S');
// 7314         if (spindle_laser_power == 0) {
// 7315           WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
// 7316           analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);                           // only write low byte
// 7317           delay_for_power_down();
// 7318         }
// 7319         else {
// 7320           int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
// 7321           NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
// 7322           if (spindle_laser_power <= SPEED_POWER_MIN)
// 7323             ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
// 7324           if (spindle_laser_power >= SPEED_POWER_MAX)
// 7325             ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
// 7326           if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
// 7327           WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
// 7328           analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
// 7329           delay_for_power_up();
// 7330         }
// 7331       }
// 7332     #else
// 7333       WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
// 7334       delay_for_power_up();
// 7335     #endif
// 7336   }
// 7337 
// 7338  /**
// 7339   * M5 turn off spindle
// 7340   */
// 7341   inline void gcode_M5() {
// 7342     stepper.synchronize();
// 7343     WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
// 7344     delay_for_power_down();
// 7345   }
// 7346 
// 7347 #endif // SPINDLE_LASER_ENABLE
// 7348 
// 7349 /**
// 7350  * M17: Enable power on all stepper motors
// 7351  */
// 7352 inline void gcode_M17() {
// 7353   LCD_MESSAGEPGM(MSG_NO_MOVE);
// 7354   enable_all_steppers();
// 7355 }
// 7356 
// 7357 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 7358 
// 7359   static float resume_position[XYZE];
// 7360   static bool move_away_flag = false;
// 7361   #if ENABLED(SDSUPPORT)
// 7362     static bool sd_print_paused = false;
// 7363   #endif
// 7364 
// 7365   static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
// 7366     static millis_t next_buzz = 0;
// 7367     static int8_t runout_beep = 0;
// 7368 
// 7369     if (init) next_buzz = runout_beep = 0;
// 7370 
// 7371     const millis_t ms = millis();
// 7372     if (ELAPSED(ms, next_buzz)) {
// 7373       if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
// 7374         next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
// 7375         BUZZ(300, 2000);
// 7376         runout_beep++;
// 7377       }
// 7378     }
// 7379   }
// 7380 
// 7381   static void ensure_safe_temperature() {
// 7382     bool heaters_heating = true;
// 7383 
// 7384     wait_for_heatup = true;    // M108 will clear this
// 7385     while (wait_for_heatup && heaters_heating) {
// 7386       idle();
// 7387       heaters_heating = false;
// 7388       HOTEND_LOOP() {
// 7389         if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
// 7390           heaters_heating = true;
// 7391           #if ENABLED(ULTIPANEL)
// 7392             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
// 7393           #endif
// 7394           break;
// 7395         }
// 7396       }
// 7397     }
// 7398   }
// 7399 
// 7400   #if IS_KINEMATIC
// 7401     #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
// 7402   #else
// 7403     #define RUNPLAN(RATE_MM_S) buffer_line_to_destination(RATE_MM_S)
// 7404   #endif
// 7405 
// 7406   void do_pause_e_move(const float &length, const float fr) {
// 7407     current_position[E_AXIS] += length / planner.e_factor[active_extruder];
// 7408     set_destination_from_current();
// 7409     RUNPLAN(fr);
// 7410     stepper.synchronize();
// 7411   }
// 7412 
// 7413   static bool pause_print(const float &retract, const point_t &park_point, const float &unload_length = 0,
// 7414                           const int8_t max_beep_count = 0, const bool show_lcd = false
// 7415   ) {
// 7416     if (move_away_flag) return false; // already paused
// 7417 
// 7418     #ifdef ACTION_ON_PAUSE
// 7419       SERIAL_ECHOLNPGM("//action:" ACTION_ON_PAUSE);
// 7420     #endif
// 7421 
// 7422     if (!DEBUGGING(DRYRUN) && unload_length != 0) {
// 7423       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 7424         if (!thermalManager.allow_cold_extrude &&
// 7425             thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
// 7426           SERIAL_ERROR_START();
// 7427           SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
// 7428           return false;
// 7429         }
// 7430       #endif
// 7431 
// 7432       ensure_safe_temperature(); // wait for extruder to heat up before unloading
// 7433     }
// 7434 
// 7435     // Indicate that the printer is paused
// 7436     move_away_flag = true;
// 7437 
// 7438     // Pause the print job and timer
// 7439     #if ENABLED(SDSUPPORT)
// 7440       if (card.sdprinting) {
// 7441         card.pauseSDPrint();
// 7442         sd_print_paused = true;
// 7443       }
// 7444     #endif
// 7445     print_job_timer.pause();
// 7446 
// 7447     // Show initial message and wait for synchronize steppers
// 7448     if (show_lcd) {
// 7449       #if ENABLED(ULTIPANEL)
// 7450         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
// 7451       #endif
// 7452     }
// 7453 
// 7454     // Save current position
// 7455     stepper.synchronize();
// 7456     COPY(resume_position, current_position);
// 7457 
// 7458     // Initial retract before move to filament change position
// 7459     if (retract && !thermalManager.tooColdToExtrude(active_extruder))
// 7460       do_pause_e_move(retract, PAUSE_PARK_RETRACT_FEEDRATE);
// 7461 
// 7462     // Park the nozzle by moving up by z_lift and then moving to (x_pos, y_pos)
// 7463     Nozzle::park(2, park_point);
// 7464 
// 7465     if (unload_length != 0) {
// 7466       if (show_lcd) {
// 7467         #if ENABLED(ULTIPANEL)
// 7468           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
// 7469           idle();
// 7470         #endif
// 7471       }
// 7472 
// 7473       // Unload filament
// 7474       do_pause_e_move(unload_length, FILAMENT_CHANGE_UNLOAD_FEEDRATE);
// 7475     }
// 7476 
// 7477     if (show_lcd) {
// 7478       #if ENABLED(ULTIPANEL)
// 7479         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7480       #endif
// 7481     }
// 7482 
// 7483     #if HAS_BUZZER
// 7484       filament_change_beep(max_beep_count, true);
// 7485     #endif
// 7486 
// 7487     idle();
// 7488 
// 7489     // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
// 7490     #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
// 7491       disable_e_steppers();
// 7492       safe_delay(100);
// 7493     #endif
// 7494 
// 7495     // Start the heater idle timers
// 7496     const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7497 
// 7498     HOTEND_LOOP()
// 7499       thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7500 
// 7501     return true;
// 7502   }
// 7503 
// 7504   static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
// 7505     bool nozzle_timed_out = false;
// 7506 
// 7507     // Wait for filament insert by user and press button
// 7508     KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7509     wait_for_user = true;    // LCD click or M108 will clear this
// 7510     while (wait_for_user) {
// 7511       #if HAS_BUZZER
// 7512         filament_change_beep(max_beep_count);
// 7513       #endif
// 7514 
// 7515       // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
// 7516       // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
// 7517       if (!nozzle_timed_out)
// 7518         HOTEND_LOOP()
// 7519           nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7520 
// 7521       if (nozzle_timed_out) {
// 7522         #if ENABLED(ULTIPANEL)
// 7523           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
// 7524         #endif
// 7525 
// 7526         // Wait for LCD click or M108
// 7527         while (wait_for_user) idle(true);
// 7528 
// 7529         // Re-enable the heaters if they timed out
// 7530         HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
// 7531 
// 7532         // Wait for the heaters to reach the target temperatures
// 7533         ensure_safe_temperature();
// 7534 
// 7535         #if ENABLED(ULTIPANEL)
// 7536           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7537         #endif
// 7538 
// 7539         // Start the heater idle timers
// 7540         const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
// 7541 
// 7542         HOTEND_LOOP()
// 7543           thermalManager.start_heater_idle_timer(e, nozzle_timeout);
// 7544 
// 7545         wait_for_user = true; /* Wait for user to load filament */
// 7546         nozzle_timed_out = false;
// 7547 
// 7548         #if HAS_BUZZER
// 7549           filament_change_beep(max_beep_count, true);
// 7550         #endif
// 7551       }
// 7552 
// 7553       idle(true);
// 7554     }
// 7555     KEEPALIVE_STATE(IN_HANDLER);
// 7556   }
// 7557 
// 7558   static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
// 7559     bool nozzle_timed_out = false;
// 7560 
// 7561     if (!move_away_flag) return;
// 7562 
// 7563     // Re-enable the heaters if they timed out
// 7564     HOTEND_LOOP() {
// 7565       nozzle_timed_out |= thermalManager.is_heater_idle(e);
// 7566       thermalManager.reset_heater_idle_timer(e);
// 7567     }
// 7568 
// 7569     if (nozzle_timed_out) ensure_safe_temperature();
// 7570 
// 7571     #if HAS_BUZZER
// 7572       filament_change_beep(max_beep_count, true);
// 7573     #endif
// 7574 
// 7575     set_destination_from_current();
// 7576 
// 7577     if (load_length != 0) {
// 7578       #if ENABLED(ULTIPANEL)
// 7579         // Show "insert filament"
// 7580         if (nozzle_timed_out)
// 7581           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
// 7582       #endif
// 7583 
// 7584       KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7585       wait_for_user = true;    // LCD click or M108 will clear this
// 7586       while (wait_for_user && nozzle_timed_out) {
// 7587         #if HAS_BUZZER
// 7588           filament_change_beep(max_beep_count);
// 7589         #endif
// 7590         idle(true);
// 7591       }
// 7592       KEEPALIVE_STATE(IN_HANDLER);
// 7593 
// 7594       #if ENABLED(ULTIPANEL)
// 7595         // Show "load" message
// 7596         lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
// 7597       #endif
// 7598 
// 7599       // Load filament
// 7600       do_pause_e_move(load_length, FILAMENT_CHANGE_LOAD_FEEDRATE);
// 7601     }
// 7602 
// 7603     #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
// 7604 
// 7605       if (!thermalManager.tooColdToExtrude(active_extruder)) {
// 7606         float extrude_length = initial_extrude_length;
// 7607 
// 7608         do {
// 7609           if (extrude_length > 0) {
// 7610             // "Wait for filament extrude"
// 7611             lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
// 7612 
// 7613             // Extrude filament to get into hotend
// 7614             do_pause_e_move(extrude_length, ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
// 7615           }
// 7616 
// 7617           // Show "Extrude More" / "Resume" menu and wait for reply
// 7618           KEEPALIVE_STATE(PAUSED_FOR_USER);
// 7619           wait_for_user = false;
// 7620           lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
// 7621           while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
// 7622           KEEPALIVE_STATE(IN_HANDLER);
// 7623 
// 7624           extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
// 7625 
// 7626           // Keep looping if "Extrude More" was selected
// 7627         } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
// 7628       }
// 7629 
// 7630     #endif
// 7631 
// 7632     #if ENABLED(ULTIPANEL)
// 7633       // "Wait for print to resume"
// 7634       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
// 7635     #endif
// 7636 
// 7637     // Set extruder to saved position
// 7638     destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
// 7639     planner.set_e_position_mm(current_position[E_AXIS]);
// 7640 
// 7641     // Move XY to starting position, then Z
// 7642     do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], NOZZLE_PARK_XY_FEEDRATE);
// 7643     do_blocking_move_to_z(resume_position[Z_AXIS], NOZZLE_PARK_Z_FEEDRATE);
// 7644 
// 7645     #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 7646       filament_ran_out = false;
// 7647     #endif
// 7648 
// 7649     #if ENABLED(ULTIPANEL)
// 7650       // Show status screen
// 7651       lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
// 7652     #endif
// 7653 
// 7654     #ifdef ACTION_ON_RESUME
// 7655       SERIAL_ECHOLNPGM("//action:" ACTION_ON_RESUME);
// 7656     #endif
// 7657 
// 7658     #if ENABLED(SDSUPPORT)
// 7659       if (sd_print_paused) {
// 7660         card.startFileprint();
// 7661         sd_print_paused = false;
// 7662       }
// 7663     #endif
// 7664 
// 7665     move_away_flag = false;
// 7666   }
// 7667 #endif // ADVANCED_PAUSE_FEATURE
// 7668 
// 7669 #if ENABLED(SDSUPPORT)
// 7670 
// 7671   /**
// 7672    * M20: List SD card to serial output
// 7673    */
// 7674   inline void gcode_M20() {
// 7675     SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
// 7676     card.ls();
// 7677     SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
// 7678   }
// 7679 
// 7680   /**
// 7681    * M21: Init SD Card
// 7682    */
// 7683   inline void gcode_M21() { card.initsd(); }
// 7684 
// 7685   /**
// 7686    * M22: Release SD Card
// 7687    */
// 7688   inline void gcode_M22() { card.release(); }
// 7689 
// 7690   /**
// 7691    * M23: Open a file
// 7692    */
// 7693    #ifdef USE_MKS_WIFI    
// 7694   inline void gcode_M23() { 
// 7695   	if(card.openFile(parser.command_ptr, true) < 0)
// 7696   	{
// 7697   		/*for 8.3 principle*/
// 7698 		char *gSuffix = strstr((char *)parser.command_ptr, ".g");
// 7699 		if(!gSuffix)
// 7700 		{
// 7701 			gSuffix = strstr((char *)parser.command_ptr, ".G");		
// 7702 		}
// 7703 		if(gSuffix)
// 7704 		{
// 7705 			*(gSuffix + 2) = '\0';
// 7706 			if((uint32_t)gSuffix - (uint32_t)parser.command_ptr > 8)
// 7707 			{
// 7708 				parser.command_ptr[7] = '~';
// 7709 				parser.command_ptr[8] = '.';
// 7710 				parser.command_ptr[9] = 'g';
// 7711 				parser.command_ptr[10] = '\0';
// 7712 			}
// 7713 			card.openFile(parser.command_ptr, true) ;
// 7714 		}
// 7715   	}
// 7716   }
// 7717 #else
// 7718   inline void gcode_M23() {
// 7719     // Simplify3D includes the size, so zero out all spaces (#7227)
// 7720     for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
// 7721     card.openFile(parser.string_arg, true);
// 7722     strcpy(curFileName, mksReprint.filename);//(uint8_t *)&mksReprint.filename[0]
// 7723   }
// 7724 #endif
// 7725   /**
// 7726    * M24: Start or Resume SD Print
// 7727    */
// 7728   inline void gcode_M24() {
// 7729   	mks_resumePrint();
// 7730   
// 7731     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7732       resume_print();
// 7733     #endif
// 7734 	
// 7735 	#ifdef USE_MKS_WIFI
// 7736 	if(card.lastOpenOk())
// 7737 	#endif	
// 7738 		if(mksReprint.mks_printer_state != MKS_REPRINTING && mksReprint.mks_printer_state != MKS_REPRINTED)
// 7739 		{
// 7740 
// 7741 	    	card.startFileprint();
// 7742 	    	print_job_timer.start();
// 7743 		}
// 7744   }
// 7745 
// 7746   /**
// 7747    * M25: Pause SD Print
// 7748    */
// 7749   inline void gcode_M25() {
// 7750     card.pauseSDPrint();
// 7751     print_job_timer.pause();
// 7752 
// 7753     #if ENABLED(PARK_HEAD_ON_PAUSE)
// 7754       enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
// 7755     #endif
// 7756 	
// 7757 	mksReprint.mks_printer_state = MKS_PAUSING;
// 7758   }
// 7759 /**
// 7760 	 * M998: Stop SD Print
// 7761 */
// 7762 	inline void gcode_M998() {
// 7763 		if(mksReprint.mks_printer_state == MKS_REPRINTED)	
// 7764 		return;
// 7765 			
// 7766 		mksReprint.mks_printer_state = MKS_IDLE;
// 7767         if(gCfgItems.pwroff_save_mode != 1)
// 7768 		    epr_write_data(EPR_SAV_FLAG, (uint8_t *)&mksReprint.mks_printer_state,sizeof(mksReprint.mks_printer_state));
// 7769 
// 7770 		card.stopSDPrint();
// 7771 		clear_command_queue();
// 7772 		quickstop_stepper();
// 7773 		print_job_timer.stop();
// 7774 		thermalManager.disable_all_heaters();
// 7775 		#if FAN_COUNT > 0
// 7776 			for (uint8_t i = 0; i < FAN_COUNT; i++) 
// 7777             {         
// 7778                 fanSpeeds[i] = 0;
// 7779                 #if 1
// 7780                 MKS_FAN_TIM = 0 ;
// 7781                 #endif
// 7782              }
// 7783 		#endif
// 7784 		wait_for_heatup = false;
// 7785 	}
// 7786 
// 7787   /**
// 7788    * M26: Set SD Card file index
// 7789    */
// 7790   inline void gcode_M26() {
// 7791     if (card.cardOK && parser.seenval('S'))
// 7792       card.setIndex(parser.value_long());
// 7793   }
// 7794 
// 7795   /**
// 7796    * M27: Get SD Card status
// 7797    */
// 7798   inline void gcode_M27() { card.getStatus(); }
// 7799 
// 7800   /**
// 7801    * M28: Start SD Write
// 7802    */
// 7803   inline void gcode_M28() { card.openFile(parser.string_arg, false); }
// 7804 
// 7805   /**
// 7806    * M29: Stop SD Write
// 7807    * Processed in write to file routine above
// 7808    */
// 7809   inline void gcode_M29() {
// 7810     // card.saving = false;
// 7811   }
// 7812 
// 7813   /**
// 7814    * M30 <filename>: Delete SD Card file
// 7815    */
// 7816   inline void gcode_M30() {
// 7817     if (card.cardOK) {
// 7818       card.closefile();
// 7819       card.removeFile(parser.string_arg);
// 7820     }
// 7821   }
// 7822 
// 7823 #endif // SDSUPPORT
// 7824 
// 7825 /**
// 7826  * M31: Get the time since the start of SD Print (or last M109)
// 7827  */
// 7828 inline void gcode_M31() {
// 7829   char buffer[21];
// 7830   duration_t elapsed = print_job_timer.duration();
// 7831   elapsed.toString(buffer);
// 7832   lcd_setstatus(buffer);
// 7833 
// 7834   SERIAL_ECHO_START();
// 7835   SERIAL_ECHOLNPAIR("Print time: ", buffer);
// 7836 }
// 7837 
// 7838 #if ENABLED(SDSUPPORT)
// 7839 
// 7840   /**
// 7841    * M32: Select file and start SD Print
// 7842    *
// 7843    * Examples:
// 7844    *
// 7845    *    M32 !PATH/TO/FILE.GCO#      ; Start FILE.GCO
// 7846    *    M32 P !PATH/TO/FILE.GCO#    ; Start FILE.GCO as a procedure
// 7847    *    M32 S60 !PATH/TO/FILE.GCO#  ; Start FILE.GCO at byte 60
// 7848    *
// 7849    */
// 7850   inline void gcode_M32() {
// 7851     if (card.sdprinting) stepper.synchronize();
// 7852 
// 7853     if (card.cardOK|| card.usbOK) {
// 7854       const bool call_procedure = parser.boolval('P');
// 7855 
// 7856       card.openFile(parser.string_arg, true, call_procedure);
// 7857 
// 7858       if (parser.seenval('S')) card.setIndex(parser.value_long());
// 7859 
// 7860       card.startFileprint();
// 7861 
// 7862       // Procedure calls count as normal print time.
// 7863       if (!call_procedure) print_job_timer.start();
// 7864     }
// 7865   }
// 7866 
// 7867   #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 7868 
// 7869     /**
// 7870      * M33: Get the long full path of a file or folder
// 7871      *
// 7872      * Parameters:
// 7873      *   <dospath> Case-insensitive DOS-style path to a file or folder
// 7874      *
// 7875      * Example:
// 7876      *   M33 miscel~1/armchair/armcha~1.gco
// 7877      *
// 7878      * Output:
// 7879      *   /Miscellaneous/Armchair/Armchair.gcode
// 7880      */
// 7881     inline void gcode_M33() {
// 7882       card.printLongPath(parser.string_arg);
// 7883     }
// 7884 
// 7885   #endif
// 7886 
// 7887   #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 7888     /**
// 7889      * M34: Set SD Card Sorting Options
// 7890      */
// 7891     inline void gcode_M34() {
// 7892       if (parser.seen('S')) card.setSortOn(parser.value_bool());
// 7893       if (parser.seenval('F')) {
// 7894         const int v = parser.value_long();
// 7895         card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
// 7896       }
// 7897       //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
// 7898     }
// 7899   #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 7900 
// 7901   /**
// 7902    * M928: Start SD Write
// 7903    */
// 7904   inline void gcode_M928() {
// 7905     card.openLogFile(parser.string_arg);
// 7906   }
// 7907 
// 7908 #endif // SDSUPPORT
// 7909 
// 7910 /**
// 7911  * Sensitive pin test for M42, M226
// 7912  */
// 7913 static bool pin_is_protected(const int8_t pin) {
// 7914   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
// 7915   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
// 7916     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
// 7917   return false;
// 7918 }
// 7919 
// 7920 /**
// 7921  * M42: Change pin status via GCode
// 7922  *
// 7923  *  P<pin>  Pin number (LED if omitted)
// 7924  *  S<byte> Pin status from 0 - 255
// 7925  */
// 7926 inline void gcode_M42() {
// 7927   if (!parser.seenval('S')) return;
// 7928   const byte pin_status = parser.value_byte();
// 7929 
// 7930   const int pin_number = parser.intval('P', LED_PIN);
// 7931   if (pin_number < 0) return;
// 7932 
// 7933   if (pin_is_protected(pin_number)) {
// 7934     SERIAL_ERROR_START();
// 7935     SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
// 7936     return;
// 7937   }
// 7938 
// 7939   pinMode(pin_number, OUTPUT);
// 7940   digitalWrite(pin_number, pin_status);
// 7941   //analogWrite(pin_number, pin_status);
// 7942 
// 7943   #if FAN_COUNT > 0
// 7944     switch (pin_number) {
// 7945       #if HAS_FAN0
// 7946         case FAN_PIN: fanSpeeds[0] = pin_status; break;
// 7947       #endif
// 7948       #if HAS_FAN1
// 7949         case FAN1_PIN: fanSpeeds[1] = pin_status; break;
// 7950       #endif
// 7951       #if HAS_FAN2
// 7952         case FAN2_PIN: fanSpeeds[2] = pin_status; break;
// 7953       #endif
// 7954     }
// 7955   #endif
// 7956 }
// 7957 
// 7958 #if ENABLED(PINS_DEBUGGING)
// 7959 
// 7960   #include "pinsDebug.h"
// 7961 
// 7962   inline void toggle_pins() {
// 7963     const bool I_flag = parser.boolval('I');
// 7964     const int repeat = parser.intval('R', 1),
// 7965               start = parser.intval('S'),
// 7966               end = parser.intval('L', NUM_DIGITAL_PINS - 1),
// 7967               wait = parser.intval('W', 500);
// 7968 
// 7969     for (uint8_t pin = start; pin <= end; pin++) {
// 7970       //report_pin_state_extended(pin, I_flag, false);
// 7971 
// 7972       if (!I_flag && pin_is_protected(pin)) {
// 7973         report_pin_state_extended(pin, I_flag, true, "Untouched ");
// 7974         SERIAL_EOL();
// 7975       }
// 7976       else {
// 7977         report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
// 7978         #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
// 7979           if (pin == TEENSY_E2) {
// 7980             SET_OUTPUT(TEENSY_E2);
// 7981             for (int16_t j = 0; j < repeat; j++) {
// 7982               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7983               WRITE(TEENSY_E2, HIGH); safe_delay(wait);
// 7984               WRITE(TEENSY_E2, LOW);  safe_delay(wait);
// 7985             }
// 7986           }
// 7987           else if (pin == TEENSY_E3) {
// 7988             SET_OUTPUT(TEENSY_E3);
// 7989             for (int16_t j = 0; j < repeat; j++) {
// 7990               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7991               WRITE(TEENSY_E3, HIGH); safe_delay(wait);
// 7992               WRITE(TEENSY_E3, LOW);  safe_delay(wait);
// 7993             }
// 7994           }
// 7995           else
// 7996         #endif
// 7997         {
// 7998           pinMode(pin, OUTPUT);
// 7999           for (int16_t j = 0; j < repeat; j++) {
// 8000             digitalWrite(pin, 0); safe_delay(wait);
// 8001             digitalWrite(pin, 1); safe_delay(wait);
// 8002             digitalWrite(pin, 0); safe_delay(wait);
// 8003           }
// 8004         }
// 8005 
// 8006       }
// 8007       SERIAL_EOL();
// 8008     }
// 8009     SERIAL_ECHOLNPGM("Done.");
// 8010 
// 8011   } // toggle_pins
// 8012 
// 8013   inline void servo_probe_test() {
// 8014     #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
// 8015 
// 8016       SERIAL_ERROR_START();
// 8017       SERIAL_ERRORLNPGM("SERVO not setup");
// 8018 
// 8019     #elif !HAS_Z_SERVO_ENDSTOP
// 8020 
// 8021       SERIAL_ERROR_START();
// 8022       SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
// 8023 
// 8024     #else // HAS_Z_SERVO_ENDSTOP
// 8025 
// 8026       const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
// 8027 
// 8028       SERIAL_PROTOCOLLNPGM("Servo probe test");
// 8029       SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
// 8030       SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
// 8031       SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
// 8032 
// 8033       bool probe_inverting;
// 8034 
// 8035       //#if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 8036       uint8_t PROBE_TEST_PIN = 0;
// 8037 	  if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
// 8038 	  {
// 8039 
// 8040        // #define PROBE_TEST_PIN Z_MIN_PIN
// 8041 	   PROBE_TEST_PIN = Z_MIN_PIN;
// 8042 
// 8043         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
// 8044         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
// 8045         SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
// 8046 /*
// 8047         #if Z_MIN_ENDSTOP_INVERTING
// 8048           SERIAL_PROTOCOLLNPGM("true");
// 8049         #else
// 8050           SERIAL_PROTOCOLLNPGM("false");
// 8051         #endif
// 8052 */		if(Z_MIN_ENDSTOP_INVERTING)
// 8053 			SERIAL_PROTOCOLLNPGM("true");
// 8054 		else
// 8055 			SERIAL_PROTOCOLLNPGM("false");
// 8056 		/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 8057 
// 8058         probe_inverting = Z_MIN_ENDSTOP_INVERTING;
// 8059 	  }
// 8060       //#elif ENABLED(Z_MIN_PROBE_ENDSTOP)
// 8061 	  else if(Z_MIN_PROBE_PIN_MODE == Z_MIN_PROBE_USES_Z_MAX_ENDSTOP_PIN
// 8062 	  {
// 8063         //#define PROBE_TEST_PIN Z_MIN_PROBE_PIN
// 8064         PROBE_TEST_PIN = Z_MAX_PIN;
// 8065         SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
// 8066         SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
// 8067         SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
// 8068 /*
// 8069         #if Z_MIN_PROBE_ENDSTOP_INVERTING
// 8070           SERIAL_PROTOCOLLNPGM("true");
// 8071         #else
// 8072           SERIAL_PROTOCOLLNPGM("false");
// 8073         #endif
// 8074 */
// 8075 		if(Z_MIN_PROBE_ENDSTOP_INVERTING)
// 8076 			SERIAL_PROTOCOLLNPGM("true");
// 8077 		else
// 8078 			SERIAL_PROTOCOLLNPGM("false");
// 8079 	/*--mks cfg end-- Z_MIN_ENDSTOP_INVERTING */
// 8080 
// 8081         probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
// 8082 	  }
// 8083       //#endif
// 8084 
// 8085       SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
// 8086       SET_INPUT_PULLUP(PROBE_TEST_PIN);
// 8087       bool deploy_state, stow_state;
// 8088       for (uint8_t i = 0; i < 4; i++) {
// 8089         MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
// 8090         safe_delay(500);
// 8091         deploy_state = READ(PROBE_TEST_PIN);
// 8092         MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 8093         safe_delay(500);
// 8094         stow_state = READ(PROBE_TEST_PIN);
// 8095       }
// 8096       if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
// 8097 
// 8098       refresh_cmd_timeout();
// 8099 
// 8100       if (deploy_state != stow_state) {
// 8101         SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
// 8102         if (deploy_state) {
// 8103           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
// 8104           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
// 8105         }
// 8106         else {
// 8107           SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
// 8108           SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
// 8109         }
// 8110         //#if ENABLED(BLTOUCH)
// 8111         if(MKSTOUCH == 1)
// 8112           SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
// 8113         //#endif
// 8114 
// 8115       }
// 8116       else {                                           // measure active signal length
// 8117         MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
// 8118         safe_delay(500);
// 8119         SERIAL_PROTOCOLLNPGM("please trigger probe");
// 8120         uint16_t probe_counter = 0;
// 8121 
// 8122         // Allow 30 seconds max for operator to trigger probe
// 8123         for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
// 8124 
// 8125           safe_delay(2);
// 8126 
// 8127           if (0 == j % (500 * 1)) // keep cmd_timeout happy
// 8128             refresh_cmd_timeout();
// 8129 
// 8130           if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
// 8131 
// 8132             for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
// 8133               safe_delay(2);
// 8134 
// 8135             if (probe_counter == 50)
// 8136               SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
// 8137             else if (probe_counter >= 2)
// 8138               SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
// 8139             else
// 8140               SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
// 8141 
// 8142             MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
// 8143 
// 8144           }  // pulse detected
// 8145 
// 8146         } // for loop waiting for trigger
// 8147 
// 8148         if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
// 8149 
// 8150       } // measure active signal length
// 8151 
// 8152     #endif
// 8153 
// 8154   } // servo_probe_test
// 8155 
// 8156   /**
// 8157    * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
// 8158    *
// 8159    *  M43         - report name and state of pin(s)
// 8160    *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
// 8161    *                  I       Flag to ignore Marlin's pin protection.
// 8162    *
// 8163    *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
// 8164    *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
// 8165    *                  I       Flag to ignore Marlin's pin protection.
// 8166    *
// 8167    *  M43 E<bool> - Enable / disable background endstop monitoring
// 8168    *                  - Machine continues to operate
// 8169    *                  - Reports changes to endstops
// 8170    *                  - Toggles LED_PIN when an endstop changes
// 8171    *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
// 8172    *
// 8173    *  M43 T       - Toggle pin(s) and report which pin is being toggled
// 8174    *                  S<pin>  - Start Pin number.   If not given, will default to 0
// 8175    *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
// 8176    *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
// 8177    *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
// 8178    *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
// 8179    *
// 8180    *  M43 S       - Servo probe test
// 8181    *                  P<index> - Probe index (optional - defaults to 0
// 8182    */
// 8183   inline void gcode_M43() {
// 8184 
// 8185     if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
// 8186       toggle_pins();
// 8187       return;
// 8188     }
// 8189 
// 8190     // Enable or disable endstop monitoring
// 8191     if (parser.seen('E')) {
// 8192       endstop_monitor_flag = parser.value_bool();
// 8193       SERIAL_PROTOCOLPGM("endstop monitor ");
// 8194       serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
// 8195       SERIAL_PROTOCOLLNPGM("abled");
// 8196       return;
// 8197     }
// 8198 
// 8199     if (parser.seen('S')) {
// 8200       servo_probe_test();
// 8201       return;
// 8202     }
// 8203 
// 8204     // Get the range of pins to test or watch
// 8205     const uint8_t first_pin = parser.byteval('P'),
// 8206                   last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
// 8207 
// 8208     if (first_pin > last_pin) return;
// 8209 
// 8210     const bool ignore_protection = parser.boolval('I');
// 8211 
// 8212     // Watch until click, M108, or reset
// 8213     if (parser.boolval('W')) {
// 8214       SERIAL_PROTOCOLLNPGM("Watching pins");
// 8215       byte pin_state[last_pin - first_pin + 1];
// 8216       for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 8217         if (pin_is_protected(pin) && !ignore_protection) continue;
// 8218         pinMode(pin, INPUT_PULLUP);
// 8219         delay(1);
// 8220         /*
// 8221           if (IS_ANALOG(pin))
// 8222             pin_state[pin - first_pin] = analogRead(pin - analogInputToDigitalPin(0)); // int16_t pin_state[...]
// 8223           else
// 8224         //
// 8225         */
// 8226             pin_state[pin - first_pin] = digitalRead(pin);
// 8227       }
// 8228 
// 8229       #if HAS_RESUME_CONTINUE
// 8230         wait_for_user = true;
// 8231         KEEPALIVE_STATE(PAUSED_FOR_USER);
// 8232       #endif
// 8233 
// 8234       for (;;) {
// 8235         for (int8_t pin = first_pin; pin <= last_pin; pin++) {
// 8236           if (pin_is_protected(pin) && !ignore_protection) continue;
// 8237           const byte val =
// 8238             /*
// 8239               IS_ANALOG(pin)
// 8240                 ? analogRead(pin - analogInputToDigitalPin(0)) : // int16_t val
// 8241                 :
// 8242             //
// 8243             */
// 8244               digitalRead(pin);
// 8245           if (val != pin_state[pin - first_pin]) {
// 8246             report_pin_state_extended(pin, ignore_protection, false);
// 8247             pin_state[pin - first_pin] = val;
// 8248           }
// 8249         }
// 8250 
// 8251         #if HAS_RESUME_CONTINUE
// 8252           if (!wait_for_user) {
// 8253             KEEPALIVE_STATE(IN_HANDLER);
// 8254             break;
// 8255           }
// 8256         #endif
// 8257 
// 8258         safe_delay(200);
// 8259       }
// 8260       return;
// 8261     }
// 8262 
// 8263     // Report current state of selected pin(s)
// 8264     for (uint8_t pin = first_pin; pin <= last_pin; pin++)
// 8265       report_pin_state_extended(pin, ignore_protection, true);
// 8266   }
// 8267 
// 8268 #endif // PINS_DEBUGGING
// 8269 
// 8270 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 8271 
// 8272   /**
// 8273    * M48: Z probe repeatability measurement function.
// 8274    *
// 8275    * Usage:
// 8276    *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
// 8277    *     P = Number of sampled points (4-50, default 10)
// 8278    *     X = Sample X position
// 8279    *     Y = Sample Y position
// 8280    *     V = Verbose level (0-4, default=1)
// 8281    *     E = Engage Z probe for each reading
// 8282    *     L = Number of legs of movement before probe
// 8283    *     S = Schizoid (Or Star if you prefer)
// 8284    *
// 8285    * This function requires the machine to be homed before invocation.
// 8286    */
// 8287   inline void gcode_M48() {
// 8288 
// 8289     if (axis_unhomed_error()) return;
// 8290 
// 8291     const int8_t verbose_level = parser.byteval('V', 1);
// 8292     if (!WITHIN(verbose_level, 0, 4)) {
// 8293       SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
// 8294       return;
// 8295     }
// 8296 
// 8297     if (verbose_level > 0)
// 8298       SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
// 8299 
// 8300     const int8_t n_samples = parser.byteval('P', 10);
// 8301     if (!WITHIN(n_samples, 4, 50)) {
// 8302       SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
// 8303       return;
// 8304     }
// 8305 
// 8306     const bool stow_probe_after_each = parser.boolval('E');
// 8307 
// 8308     float X_current = current_position[X_AXIS],
// 8309           Y_current = current_position[Y_AXIS];
// 8310 
// 8311     const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
// 8312                 Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
// 8313 
// 8314     //#if DISABLED(DELTA)
// 8315     if(MACHINETPYE != DELTA)
// 8316     {
// 8317       if (!WITHIN(X_probe_location, MIN_PROBE_X, MAX_PROBE_X)) {
// 8318         out_of_range_error(PSTR("X"));
// 8319         return;
// 8320       }
// 8321       if (!WITHIN(Y_probe_location, MIN_PROBE_Y, MAX_PROBE_Y)) {
// 8322         out_of_range_error(PSTR("Y"));
// 8323         return;
// 8324       }
// 8325     }
// 8326     //#else
// 8327     else
// 8328      {
// 8329      if(MACHINETPYE & IS_KINEMATIC)
// 8330         {
// 8331       if (!position_is_reachable_by_probe_IS_KINEMATIC(X_probe_location, Y_probe_location)) {
// 8332         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 8333         return;
// 8334       }
// 8335         }
// 8336      else
// 8337         {
// 8338       if (!position_is_reachable_by_probe_IS_CARTESIAN(X_probe_location, Y_probe_location)) {
// 8339         SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
// 8340         return;
// 8341       }
// 8342         }        
// 8343      }
// 8344     //#endif
// 8345 
// 8346     bool seen_L = parser.seen('L');
// 8347     uint8_t n_legs = seen_L ? parser.value_byte() : 0;
// 8348     if (n_legs > 15) {
// 8349       SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
// 8350       return;
// 8351     }
// 8352     if (n_legs == 1) n_legs = 2;
// 8353 
// 8354     const bool schizoid_flag = parser.boolval('S');
// 8355     if (schizoid_flag && !seen_L) n_legs = 7;
// 8356 
// 8357     /**
// 8358      * Now get everything to the specified probe point So we can safely do a
// 8359      * probe to get us close to the bed.  If the Z-Axis is far from the bed,
// 8360      * we don't want to use that as a starting point for each probe.
// 8361      */
// 8362     if (verbose_level > 2)
// 8363       SERIAL_PROTOCOLLNPGM("Positioning the probe...");
// 8364 
// 8365     // Disable bed level correction in M48 because we want the raw data when we probe
// 8366 /*
// 8367     #if HAS_LEVELING
// 8368       const bool was_enabled = planner.leveling_active;
// 8369       set_bed_leveling_enabled(false);
// 8370     #endif
// 8371 */
// 8372 	bool was_enabled;
// 8373 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 8374 		was_enabled = ubl.state.active;
// 8375 	else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 8376 		was_enabled = mbl.active();
// 8377 	else if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 8378 		was_enabled = planner.leveling_active;
// 8379 
// 8380 	if(BED_LEVELING_METHOD != NULL_BED_LEVELING)
// 8381 		set_bed_leveling_enabled(false);
// 8382 
// 8383     setup_for_endstop_or_probe_move();
// 8384 
// 8385     double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
// 8386 
// 8387     // Move to the first point, deploy, and probe
// 8388     const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
// 8389     bool probing_good = !isnan(t);
// 8390 
// 8391     if (probing_good) {
// 8392       //randomSeed(millis());
// 8393 	  srand(millis());
// 8394 
// 8395       for (uint8_t n = 0; n < n_samples; n++) {
// 8396         if (n_legs) {
// 8397           const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
// 8398           float angle = random(0.0, 360.0);
// 8399           const float radius = random(
// 8400             #if ENABLED(DELTA)
// 8401               0.1250000000 * (DELTA_PROBEABLE_RADIUS),
// 8402               0.3333333333 * (DELTA_PROBEABLE_RADIUS)
// 8403             #else
// 8404               5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
// 8405             #endif
// 8406           );
// 8407 
// 8408           if (verbose_level > 3) {
// 8409             SERIAL_ECHOPAIR("Starting radius: ", radius);
// 8410             SERIAL_ECHOPAIR("   angle: ", angle);
// 8411             SERIAL_ECHOPGM(" Direction: ");
// 8412             if (dir > 0) SERIAL_ECHOPGM("Counter-");
// 8413             SERIAL_ECHOLNPGM("Clockwise");
// 8414           }
// 8415 
// 8416           for (uint8_t l = 0; l < n_legs - 1; l++) {
// 8417             double delta_angle;
// 8418 
// 8419             if (schizoid_flag)
// 8420               // The points of a 5 point star are 72 degrees apart.  We need to
// 8421               // skip a point and go to the next one on the star.
// 8422               delta_angle = dir * 2.0 * 72.0;
// 8423 
// 8424             else
// 8425               // If we do this line, we are just trying to move further
// 8426               // around the circle.
// 8427               delta_angle = dir * (float) random(25, 45);
// 8428 
// 8429             angle += delta_angle;
// 8430 
// 8431             while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
// 8432               angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
// 8433             while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
// 8434               angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
// 8435 
// 8436             X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
// 8437             Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
// 8438 
// 8439             //#if DISABLED(DELTA)
// 8440             if(MACHINETPYE != DELTA)
// 8441             {
// 8442               X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
// 8443               Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
// 8444             }
// 8445             //#else
// 8446             else
// 8447             {
// 8448               // If we have gone out too far, we can do a simple fix and scale the numbers
// 8449               // back in closer to the origin.
// 8450               if(MACHINETPYE & IS_KINEMATIC)
// 8451                 {
// 8452               while (!position_is_reachable_by_probe_IS_KINEMATIC(X_current, Y_current)) {
// 8453                 X_current *= 0.8;
// 8454                 Y_current *= 0.8;
// 8455                 if (verbose_level > 3) {
// 8456                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 8457                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 8458                 }
// 8459               }
// 8460                 }
// 8461               else
// 8462                  {
// 8463               while (!position_is_reachable_by_probe_IS_CARTESIAN(X_current, Y_current)) {
// 8464                 X_current *= 0.8;
// 8465                 Y_current *= 0.8;
// 8466                 if (verbose_level > 3) {
// 8467                   SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
// 8468                   SERIAL_ECHOLNPAIR(", ", Y_current);
// 8469                 }
// 8470               }
// 8471                 }               
// 8472             }
// 8473             //#endif
// 8474             if (verbose_level > 3) {
// 8475               SERIAL_PROTOCOLPGM("Going to:");
// 8476               SERIAL_ECHOPAIR(" X", X_current);
// 8477               SERIAL_ECHOPAIR(" Y", Y_current);
// 8478               SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
// 8479             }
// 8480             do_blocking_move_to_xy(X_current, Y_current);
// 8481           } // n_legs loop
// 8482         } // n_legs
// 8483 
// 8484         // Probe a single point
// 8485         sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
// 8486 
// 8487         // Break the loop if the probe fails
// 8488         probing_good = !isnan(sample_set[n]);
// 8489         if (!probing_good) break;
// 8490 
// 8491         /**
// 8492          * Get the current mean for the data points we have so far
// 8493          */
// 8494         double sum = 0.0;
// 8495         for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
// 8496         mean = sum / (n + 1);
// 8497 
// 8498         NOMORE(min, sample_set[n]);
// 8499         NOLESS(max, sample_set[n]);
// 8500 
// 8501         /**
// 8502          * Now, use that mean to calculate the standard deviation for the
// 8503          * data points we have so far
// 8504          */
// 8505         sum = 0.0;
// 8506         for (uint8_t j = 0; j <= n; j++)
// 8507           sum += sq(sample_set[j] - mean);
// 8508 
// 8509         sigma = SQRT(sum / (n + 1));
// 8510         if (verbose_level > 0) {
// 8511           if (verbose_level > 1) {
// 8512             SERIAL_PROTOCOL(n + 1);
// 8513             SERIAL_PROTOCOLPGM(" of ");
// 8514             SERIAL_PROTOCOL((int)n_samples);
// 8515             SERIAL_PROTOCOLPGM(": z: ");
// 8516             SERIAL_PROTOCOL_F(sample_set[n], 3);
// 8517             if (verbose_level > 2) {
// 8518               SERIAL_PROTOCOLPGM(" mean: ");
// 8519               SERIAL_PROTOCOL_F(mean, 4);
// 8520               SERIAL_PROTOCOLPGM(" sigma: ");
// 8521               SERIAL_PROTOCOL_F(sigma, 6);
// 8522               SERIAL_PROTOCOLPGM(" min: ");
// 8523               SERIAL_PROTOCOL_F(min, 3);
// 8524               SERIAL_PROTOCOLPGM(" max: ");
// 8525               SERIAL_PROTOCOL_F(max, 3);
// 8526               SERIAL_PROTOCOLPGM(" range: ");
// 8527               SERIAL_PROTOCOL_F(max-min, 3);
// 8528             }
// 8529             SERIAL_EOL();
// 8530           }
// 8531         }
// 8532 
// 8533       } // n_samples loop
// 8534     }
// 8535 
// 8536     STOW_PROBE();
// 8537 
// 8538     if (probing_good) {
// 8539       SERIAL_PROTOCOLLNPGM("Finished!");
// 8540 
// 8541       if (verbose_level > 0) {
// 8542         SERIAL_PROTOCOLPGM("Mean: ");
// 8543         SERIAL_PROTOCOL_F(mean, 6);
// 8544         SERIAL_PROTOCOLPGM(" Min: ");
// 8545         SERIAL_PROTOCOL_F(min, 3);
// 8546         SERIAL_PROTOCOLPGM(" Max: ");
// 8547         SERIAL_PROTOCOL_F(max, 3);
// 8548         SERIAL_PROTOCOLPGM(" Range: ");
// 8549         SERIAL_PROTOCOL_F(max-min, 3);
// 8550         SERIAL_EOL();
// 8551       }
// 8552 
// 8553       SERIAL_PROTOCOLPGM("Standard Deviation: ");
// 8554       SERIAL_PROTOCOL_F(sigma, 6);
// 8555       SERIAL_EOL();
// 8556       SERIAL_EOL();
// 8557     }
// 8558 
// 8559     clean_up_after_endstop_or_probe_move();
// 8560 
// 8561     // Re-enable bed level correction if it had been on
// 8562     //#if HAS_LEVELING
// 8563     if(BED_LEVELING_METHOD&HAS_LEVELING)
// 8564       set_bed_leveling_enabled(was_enabled);
// 8565     //#endif
// 8566 
// 8567     report_current_position();
// 8568   }
// 8569 
// 8570 #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 8571 
// 8572 #if 1//ENABLED(G26_MESH_VALIDATION)
// 8573 
// 8574   inline void gcode_M49() {
// 8575     g26_debug_flag ^= true;
// 8576     SERIAL_PROTOCOLPGM("G26 Debug ");
// 8577     serialprintPGM(g26_debug_flag ? PSTR("on.\n") : PSTR("off.\n"));
// 8578   }
// 8579 
// 8580 #endif // G26_MESH_VALIDATION
// 8581 
// 8582 #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 8583   /**
// 8584    * M73: Set percentage complete (for display on LCD)
// 8585    *
// 8586    * Example:
// 8587    *   M73 P25 ; Set progress to 25%
// 8588    *
// 8589    * Notes:
// 8590    *   This has no effect during an SD print job
// 8591    */
// 8592   inline void gcode_M73() {
// 8593     if (!IS_SD_PRINTING && parser.seen('P')) {
// 8594       progress_bar_percent = parser.value_byte();
// 8595       NOMORE(progress_bar_percent, 100);
// 8596     }
// 8597   }
// 8598 #endif // ULTRA_LCD && LCD_SET_PROGRESS_MANUALLY
// 8599 
// 8600 /**
// 8601  * M75: Start print timer
// 8602  */
// 8603 inline void gcode_M75() { print_job_timer.start(); }
// 8604 
// 8605 /**
// 8606  * M76: Pause print timer
// 8607  */
// 8608 inline void gcode_M76() { print_job_timer.pause(); }
// 8609 
// 8610 /**
// 8611  * M77: Stop print timer
// 8612  */
// 8613 inline void gcode_M77() { print_job_timer.stop(); }
// 8614 
// 8615 #if ENABLED(PRINTCOUNTER)
// 8616   /**
// 8617    * M78: Show print statistics
// 8618    */
// 8619   inline void gcode_M78() {
// 8620     // "M78 S78" will reset the statistics
// 8621     if (parser.intval('S') == 78)
// 8622       print_job_timer.initStats();
// 8623     else
// 8624       print_job_timer.showStats();
// 8625   }
// 8626 #endif
// 8627 
// 8628 /**
// 8629  * M104: Set hot end temperature
// 8630  */
// 8631 inline void gcode_M104() {
// 8632   if (get_target_extruder_from_command(104)) return;
// 8633   if (DEBUGGING(DRYRUN)) return;
// 8634 
// 8635   #if ENABLED(SINGLENOZZLE)
// 8636     if (target_extruder != active_extruder) return;
// 8637   #endif
// 8638 
// 8639   if (parser.seenval('S')) {
// 8640     const int16_t temp = parser.value_celsius();
// 8641     thermalManager.setTargetHotend(temp, target_extruder);
// 8642 
// 8643     #if ENABLED(DUAL_X_CARRIAGE)
// 8644       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8645         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8646     #endif
// 8647 
// 8648     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8649       /**
// 8650        * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
// 8651        * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
// 8652        * standby mode, for instance in a dual extruder setup, without affecting
// 8653        * the running print timer.
// 8654        */
// 8655       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8656         print_job_timer.stop();
// 8657         LCD_MESSAGEPGM(WELCOME_MSG);
// 8658       }
// 8659     #endif
// 8660 
// 8661     //if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8662     //  lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8663 		if(parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8664 		{
// 8665 		switch(target_extruder)
// 8666 			{
// 8667 			case 0:
// 8668 				LCD_MESSAGEPGM("E1 Heating...");
// 8669 				break;
// 8670 			case 1:
// 8671 				LCD_MESSAGEPGM("E2 Heating...");
// 8672 				break;
// 8673 			case 2:
// 8674 				LCD_MESSAGEPGM("E3 Heating...");
// 8675 				break;
// 8676 			case 3:
// 8677 				LCD_MESSAGEPGM("E4 Heating...");
// 8678 				break;
// 8679 			case 4:
// 8680 				LCD_MESSAGEPGM("E5 Heating...");
// 8681 				break;
// 8682 			default: break;
// 8683 				
// 8684 			}
// 8685 		}    
// 8686   }
// 8687 
// 8688   #if ENABLED(AUTOTEMP)
// 8689     planner.autotemp_M104_M109();
// 8690   #endif
// 8691 }
// 8692 
// 8693 /**
// 8694  * M105: Read hot end and bed temperature
// 8695  */
// 8696 inline void gcode_M105() {
// 8697   if (get_target_extruder_from_command(105)) return;
// 8698 /*
// 8699   #if HAS_TEMP_HOTEND || HAS_TEMP_BED
// 8700     SERIAL_PROTOCOLPGM(MSG_OK);
// 8701     thermalManager.print_heaterstates();
// 8702   #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
// 8703     SERIAL_ERROR_START();
// 8704     SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
// 8705   #endif
// 8706 */
// 8707   SERIAL_PROTOCOLPGM(MSG_OK);
// 8708   thermalManager.print_heaterstates();
// 8709 
// 8710   SERIAL_EOL();
// 8711 }
// 8712 
// 8713 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND /*|| HAS_TEMP_BED*/)
// 8714 
// 8715   /**
// 8716    * M155: Set temperature auto-report interval. M155 S<seconds>
// 8717    */
// 8718   inline void gcode_M155() {
// 8719     if (parser.seenval('S'))
// 8720       thermalManager.set_auto_report_interval(parser.value_byte());
// 8721   }
// 8722 
// 8723 #endif // AUTO_REPORT_TEMPERATURES
// 8724 
// 8725 #if FAN_COUNT > 0
// 8726 
// 8727   /**
// 8728    * M106: Set Fan Speed
// 8729    *
// 8730    *  S<int>   Speed between 0-255
// 8731    *  P<index> Fan index, if more than one fan
// 8732    *
// 8733    * With EXTRA_FAN_SPEED enabled:
// 8734    *
// 8735    *  T<int>   Restore/Use/Set Temporary Speed:
// 8736    *           1     = Restore previous speed after T2
// 8737    *           2     = Use temporary speed set with T3-255
// 8738    *           3-255 = Set the speed for use with T2
// 8739    */
// 8740   inline void gcode_M106() {
// 8741     const uint8_t p = parser.byteval('P');
// 8742     if (p < FAN_COUNT) {
// 8743       #if ENABLED(EXTRA_FAN_SPEED)
// 8744         const int16_t t = parser.intval('T');
// 8745         if (t > 0) {
// 8746           switch (t) {
// 8747             case 1:
// 8748               fanSpeeds[p] = old_fanSpeeds[p];
// 8749               break;
// 8750             case 2:
// 8751               old_fanSpeeds[p] = fanSpeeds[p];
// 8752               fanSpeeds[p] = new_fanSpeeds[p];
// 8753               break;
// 8754             default:
// 8755               new_fanSpeeds[p] = min(t, 255);
// 8756               break;
// 8757           }
// 8758           return;
// 8759         }
// 8760       #endif // EXTRA_FAN_SPEED
// 8761       const uint16_t s = parser.ushortval('S', 255);
// 8762       fanSpeeds[p] = min(s, 255);
// 8763 	  MKS_FAN_TIM = s*10000/255;
// 8764     }
// 8765   }
// 8766 
// 8767   /**
// 8768    * M107: Fan Off
// 8769    */
// 8770   inline void gcode_M107() {
// 8771     const uint16_t p = parser.ushortval('P');
// 8772     if (p < FAN_COUNT) 
// 8773     {
// 8774 		fanSpeeds[p] = 0;
// 8775 		MKS_FAN_TIM = 0 ;
// 8776     }
// 8777   }
// 8778 
// 8779 #endif // FAN_COUNT > 0
// 8780 
// 8781 #if DISABLED(EMERGENCY_PARSER)
// 8782 
// 8783   /**
// 8784    * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
// 8785    */
// 8786   inline void gcode_M108() { wait_for_heatup = false; }
// 8787 
// 8788 
// 8789   /**
// 8790    * M112: Emergency Stop
// 8791    */
// 8792   inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
// 8793 
// 8794 
// 8795   /**
// 8796    * M410: Quickstop - Abort all planned moves
// 8797    *
// 8798    * This will stop the carriages mid-move, so most likely they
// 8799    * will be out of sync with the stepper position after this.
// 8800    */
// 8801   inline void gcode_M410() { quickstop_stepper(); }
// 8802 
// 8803 #endif
// 8804 
// 8805 /**
// 8806  * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
// 8807  *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
// 8808  */
// 8809 
// 8810 #ifndef MIN_COOLING_SLOPE_DEG
// 8811   #define MIN_COOLING_SLOPE_DEG 1.50
// 8812 #endif
// 8813 #ifndef MIN_COOLING_SLOPE_TIME
// 8814   #define MIN_COOLING_SLOPE_TIME 60
// 8815 #endif
// 8816 
// 8817 inline void gcode_M109() {
// 8818 
// 8819   if (get_target_extruder_from_command(109)) return;
// 8820   if (DEBUGGING(DRYRUN)) return;
// 8821 
// 8822   #if ENABLED(SINGLENOZZLE)
// 8823     if (target_extruder != active_extruder) return;
// 8824   #endif
// 8825 
// 8826   const bool no_wait_for_cooling = parser.seenval('S');
// 8827   if (no_wait_for_cooling || parser.seenval('R')) {
// 8828     const int16_t temp = parser.value_celsius();
// 8829     thermalManager.setTargetHotend(temp, target_extruder);
// 8830 
// 8831     #if ENABLED(DUAL_X_CARRIAGE)
// 8832       if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
// 8833         thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
// 8834     #endif
// 8835 
// 8836     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 8837       /**
// 8838        * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
// 8839        * standby mode, (e.g., in a dual extruder setup) without affecting
// 8840        * the running print timer.
// 8841        */
// 8842       if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
// 8843         print_job_timer.stop();
// 8844         LCD_MESSAGEPGM(WELCOME_MSG);
// 8845       }
// 8846       else
// 8847         print_job_timer.start();
// 8848     #endif
// 8849 
// 8850     //if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
// 8851 	if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
// 8852 	{
// 8853 			switch(target_extruder)
// 8854 			{
// 8855 			case 0:
// 8856 				LCD_MESSAGEPGM("E1 Heating...");
// 8857 				break;
// 8858 			case 1:
// 8859 				LCD_MESSAGEPGM("E2 Heating...");
// 8860 				break;
// 8861 			case 2:
// 8862 				LCD_MESSAGEPGM("E3 Heating...");
// 8863 				break;
// 8864 			case 3:
// 8865 				LCD_MESSAGEPGM("E4 Heating...");
// 8866 				break;
// 8867 			case 4:
// 8868 				LCD_MESSAGEPGM("E5 Heating...");
// 8869 				break;
// 8870 			default: break;
// 8871 			}
// 8872 	}
// 8873 
// 8874   }
// 8875   else return;
// 8876 
// 8877   #if ENABLED(AUTOTEMP)
// 8878     planner.autotemp_M104_M109();
// 8879   #endif
// 8880 
// 8881   #if TEMP_RESIDENCY_TIME > 0
// 8882     millis_t residency_start_ms = 0;
// 8883     // Loop until the temperature has stabilized
// 8884     #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
// 8885   #else
// 8886     // Loop until the temperature is very close target
// 8887     #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
// 8888   #endif
// 8889 
// 8890   float target_temp = -1.0, old_temp = 9999.0;
// 8891   bool wants_to_cool = false;
// 8892   wait_for_heatup = true;
// 8893   millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 8894 
// 8895   #if DISABLED(BUSY_WHILE_HEATING)
// 8896     KEEPALIVE_STATE(NOT_BUSY);
// 8897   #endif
// 8898 
// 8899   #if ENABLED(PRINTER_EVENT_LEDS)
// 8900     const float start_temp = thermalManager.degHotend(target_extruder);
// 8901     uint8_t old_blue = 0;
// 8902   #endif
// 8903   
// 8904   #if WATCH_HOTENDS
// 8905     thermalManager.start_watching_heater(target_extruder);
// 8906   #endif
// 8907       
// 8908   mks_heating_busy = 1;
// 8909 
// 8910   do {
// 8911     // Target temperature might be changed during the loop
// 8912     if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
// 8913       wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
// 8914       target_temp = thermalManager.degTargetHotend(target_extruder);
// 8915 
// 8916       // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 8917       if (no_wait_for_cooling && wants_to_cool) break;
// 8918     }
// 8919 
// 8920     now = millis();
// 8921     if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
// 8922       next_temp_ms = now + 1000UL;
// 8923       thermalManager.print_heaterstates();
// 8924       #if TEMP_RESIDENCY_TIME > 0
// 8925         SERIAL_PROTOCOLPGM(" W:");
// 8926         if (residency_start_ms)
// 8927           SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 8928         else
// 8929           SERIAL_PROTOCOLCHAR('?');
// 8930       #endif
// 8931       SERIAL_EOL();
// 8932     }
// 8933 
// 8934     idle();
// 8935     refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 8936 
// 8937     const float temp = thermalManager.degHotend(target_extruder);
// 8938 
// 8939     #if ENABLED(PRINTER_EVENT_LEDS)
// 8940       // Gradually change LED strip from violet to red as nozzle heats up
// 8941       if (!wants_to_cool) {
// 8942         const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
// 8943         if (blue != old_blue) {
// 8944           old_blue = blue;
// 8945           leds.set_color(
// 8946             MakeLEDColor(255, 0, blue, 0, pixels.getBrightness())
// 8947             #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 8948               , true
// 8949             #endif
// 8950           );
// 8951         }
// 8952       }
// 8953     #endif
// 8954 
// 8955     #if TEMP_RESIDENCY_TIME > 0
// 8956 
// 8957       const float temp_diff = FABS(target_temp - temp);
// 8958 
// 8959       if (!residency_start_ms) {
// 8960         // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
// 8961         if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
// 8962       }
// 8963       else if (temp_diff > TEMP_HYSTERESIS) {
// 8964         // Restart the timer whenever the temperature falls outside the hysteresis.
// 8965         residency_start_ms = now;
// 8966       }
// 8967 
// 8968     #endif
// 8969 
// 8970     // Prevent a wait-forever situation if R is misused i.e. M109 R0
// 8971     if (wants_to_cool) {
// 8972       // break after MIN_COOLING_SLOPE_TIME seconds
// 8973       // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
// 8974       if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 8975         if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
// 8976         next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
// 8977         old_temp = temp;
// 8978       }
// 8979     }
// 8980 
// 8981   } while (wait_for_heatup && TEMP_CONDITIONS);
// 8982   
// 8983   mks_heating_busy = 0;
// 8984 
// 8985   if (wait_for_heatup) {
// 8986     LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
// 8987     #if ENABLED(PRINTER_EVENT_LEDS)
// 8988       leds.set_white();
// 8989     #endif
// 8990   }
// 8991 
// 8992   #if DISABLED(BUSY_WHILE_HEATING)
// 8993     KEEPALIVE_STATE(IN_HANDLER);
// 8994   #endif
// 8995 }
// 8996 
// 8997 #if 1//HAS_TEMP_BED
// 8998 
// 8999   #ifndef MIN_COOLING_SLOPE_DEG_BED
// 9000     #define MIN_COOLING_SLOPE_DEG_BED 1.50
// 9001   #endif
// 9002   #ifndef MIN_COOLING_SLOPE_TIME_BED
// 9003     #define MIN_COOLING_SLOPE_TIME_BED 60
// 9004   #endif
// 9005 
// 9006   /**
// 9007    * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
// 9008    *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
// 9009    */
// 9010   inline void gcode_M190() {
// 9011     if (DEBUGGING(DRYRUN)) return;
// 9012 
// 9013     LCD_MESSAGEPGM(MSG_BED_HEATING);
// 9014     const bool no_wait_for_cooling = parser.seenval('S');
// 9015     if (no_wait_for_cooling || parser.seenval('R')) {
// 9016       thermalManager.setTargetBed(parser.value_celsius());
// 9017       #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
// 9018         if (parser.value_celsius() > BED_MINTEMP)
// 9019           print_job_timer.start();
// 9020       #endif
// 9021     }
// 9022     else return;
// 9023 
// 9024     #if TEMP_BED_RESIDENCY_TIME > 0
// 9025       millis_t residency_start_ms = 0;
// 9026       // Loop until the temperature has stabilized
// 9027       #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
// 9028     #else
// 9029       // Loop until the temperature is very close target
// 9030       #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
// 9031     #endif
// 9032 
// 9033     float target_temp = -1.0, old_temp = 9999.0;
// 9034     bool wants_to_cool = false;
// 9035     wait_for_heatup = true;
// 9036     millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
// 9037 
// 9038     #if DISABLED(BUSY_WHILE_HEATING)
// 9039       KEEPALIVE_STATE(NOT_BUSY);
// 9040     #endif
// 9041 
// 9042     target_extruder = active_extruder; // for print_heaterstates
// 9043 
// 9044     #if ENABLED(PRINTER_EVENT_LEDS)
// 9045       const float start_temp = thermalManager.degBed();
// 9046       uint8_t old_red = 255;
// 9047     #endif
// 9048 	mks_heating_busy = 1;
// 9049 
// 9050     do {
// 9051       // Target temperature might be changed during the loop
// 9052       if (target_temp != thermalManager.degTargetBed()) {
// 9053         wants_to_cool = thermalManager.isCoolingBed();
// 9054         target_temp = thermalManager.degTargetBed();
// 9055 
// 9056         // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
// 9057         if (no_wait_for_cooling && wants_to_cool) break;
// 9058       }
// 9059 
// 9060       now = millis();
// 9061       if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
// 9062         next_temp_ms = now + 1000UL;
// 9063         thermalManager.print_heaterstates();
// 9064         #if TEMP_BED_RESIDENCY_TIME > 0
// 9065           SERIAL_PROTOCOLPGM(" W:");
// 9066           if (residency_start_ms)
// 9067             SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
// 9068           else
// 9069             SERIAL_PROTOCOLCHAR('?');
// 9070         #endif
// 9071         SERIAL_EOL();
// 9072       }
// 9073 
// 9074       idle();
// 9075       refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
// 9076 
// 9077       const float temp = thermalManager.degBed();
// 9078 
// 9079       #if ENABLED(PRINTER_EVENT_LEDS)
// 9080         // Gradually change LED strip from blue to violet as bed heats up
// 9081         if (!wants_to_cool) {
// 9082           const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
// 9083           if (red != old_red) {
// 9084             old_red = red;
// 9085             leds.set_color(
// 9086               MakeLEDColor(red, 0, 255, 0, pixels.getBrightness())
// 9087               #if ENABLED(NEOPIXEL_IS_SEQUENTIAL)
// 9088                 , true
// 9089               #endif
// 9090             );
// 9091           }
// 9092         }
// 9093       #endif
// 9094 
// 9095       #if TEMP_BED_RESIDENCY_TIME > 0
// 9096 
// 9097         const float temp_diff = FABS(target_temp - temp);
// 9098 
// 9099         if (!residency_start_ms) {
// 9100           // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
// 9101           if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
// 9102         }
// 9103         else if (temp_diff > TEMP_BED_HYSTERESIS) {
// 9104           // Restart the timer whenever the temperature falls outside the hysteresis.
// 9105           residency_start_ms = now;
// 9106         }
// 9107 
// 9108       #endif // TEMP_BED_RESIDENCY_TIME > 0
// 9109 
// 9110       // Prevent a wait-forever situation if R is misused i.e. M190 R0
// 9111       if (wants_to_cool) {
// 9112         // Break after MIN_COOLING_SLOPE_TIME_BED seconds
// 9113         // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
// 9114         if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
// 9115           if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
// 9116           next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
// 9117           old_temp = temp;
// 9118         }
// 9119       }
// 9120 
// 9121     } while (wait_for_heatup && TEMP_BED_CONDITIONS);
// 9122 
// 9123 	mks_heating_busy = 0;
// 9124 
// 9125     if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
// 9126     #if DISABLED(BUSY_WHILE_HEATING)
// 9127       KEEPALIVE_STATE(IN_HANDLER);
// 9128     #endif
// 9129   }
// 9130 
// 9131 #endif // HAS_TEMP_BED
// 9132 
// 9133 /**
// 9134  * M110: Set Current Line Number
// 9135  */
// 9136 inline void gcode_M110() {
// 9137   if (parser.seenval('N')) gcode_LastN = parser.value_long();
// 9138 }
// 9139 
// 9140 /**
// 9141  * M111: Set the debug level
// 9142  */
// 9143 inline void gcode_M111() {
// 9144   if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
// 9145 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_1
// 9146   const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
_ZZ10gcode_M111vE11str_debug_1:
        DATA
        DC8 "ECHO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_2
// 9147                     str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
_ZZ10gcode_M111vE11str_debug_2:
        DATA
        DC8 "INFO"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_4
// 9148                     str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
_ZZ10gcode_M111vE11str_debug_4:
        DATA
        DC8 "ERRORS"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE11str_debug_8
// 9149                     str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
_ZZ10gcode_M111vE11str_debug_8:
        DATA
        DC8 "DRYRUN"
        DC8 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE12str_debug_16
// 9150                     str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
_ZZ10gcode_M111vE12str_debug_16:
        DATA
        DC8 "COMMUNICATION"
        DC8 0, 0
// 9151                     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9152                       , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
// 9153                     #endif
// 9154                     ;
// 9155 

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ10gcode_M111vE13debug_strings
// 9156   const static char* const debug_strings[] PROGMEM = {
_ZZ10gcode_M111vE13debug_strings:
        DATA
        DC32 _ZZ10gcode_M111vE11str_debug_1, _ZZ10gcode_M111vE11str_debug_2
        DC32 _ZZ10gcode_M111vE11str_debug_4, _ZZ10gcode_M111vE11str_debug_8
        DC32 _ZZ10gcode_M111vE12str_debug_16

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "mks_pft.sys">`:
        DC8 "mks_pft.sys"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "enqueueing \\"">`:
        DC8 "enqueueing \""
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "sd:%d">`:
        DC8 "sd:%d"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Invalid extruder ">`:
        DC8 " Invalid extruder "
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Home ">`:
        DC8 "Home "
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "X">`:
        DC8 "X"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Y">`:
        DC8 "Y"

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "Z">`:
        DC8 "Z"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " first\\n">`:
        DC8 " first\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "STOP called because o...">`:
        DC8 53H, 54H, 4FH, 50H, 20H, 63H, 61H, 6CH
        DC8 6CH, 65H, 64H, 20H, 62H, 65H, 63H, 61H
        DC8 75H, 73H, 65H, 20H, 6FH, 66H, 20H, 42H
        DC8 4CH, 54H, 6FH, 75H, 63H, 68H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 2DH, 20H, 72H
        DC8 65H, 73H, 74H, 61H, 72H, 74H, 20H, 77H
        DC8 69H, 74H, 68H, 20H, 4DH, 39H, 39H, 39H
        DC8 0AH, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Bed X: ">`:
        DC8 "Bed X: "

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y: ">`:
        DC8 " Y: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Z: ">`:
        DC8 " Z: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Probing failed\\n">`:
        DC8 "Probing failed\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(-9.9999990233E+3F), (-9.999999023`:
        DC32 0C61C3FFFH, 0C61C3FFFH, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Bilinear Leveling Grid:\\n">`:
        DC8 "Bilinear Leveling Grid:\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "busy: processing\\n">`:
        DC8 "busy: processing\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "busy: paused for user\\n">`:
        DC8 "busy: paused for user\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "busy: paused for input\\n">`:
        DC8 "busy: paused for input\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F)}>`:
        DC32 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "?Probe ">`:
        DC8 "?Probe "

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " position out of range.\\n">`:
        DC8 " position out of range.\012"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " not entered.\\n">`:
        DC8 " not entered.\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Num X,Y: ">`:
        DC8 "Num X,Y: "
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Z offset: ">`:
        DC8 "Z offset: "
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "\\nMeasured points:\\n">`:
        DC8 "\012Measured points:\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "X:">`:
        DC8 "X:"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y:">`:
        DC8 " Y:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Z:">`:
        DC8 " Z:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " E:">`:
        DC8 " E:"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "SCARA Theta:">`:
        DC8 "SCARA Theta:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "   Psi+Theta:">`:
        DC8 "   Psi+Theta:"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Cap:">`:
        DC8 "Cap:"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant ":">`:
        DC8 ":"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Active Extruder: ">`:
        DC8 "Active Extruder: "
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "bed leveling hasn\\'t d...">`:
        DC8 "bed leveling hasn't defined!"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "HAS_NO_TEMP_BED!\\n">`:
        DC8 "HAS_NO_TEMP_BED!\012"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Resend: ">`:
        DC8 "Resend: "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "ok">`:
        DC8 "ok"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {(0.0F), (0.0F), (0.0F)}>`:
        DC32 0H, 0H, 0H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " cold extrusion preve...">`:
        DC8 " cold extrusion prevented\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " too long extrusion p...">`:
        DC8 " too long extrusion prevented\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "KILL caused by too mu...">`:
        DC8 4BH, 49H, 4CH, 4CH, 20H, 63H, 61H, 75H
        DC8 73H, 65H, 64H, 20H, 62H, 79H, 20H, 74H
        DC8 6FH, 6FH, 20H, 6DH, 75H, 63H, 68H, 20H
        DC8 69H, 6EH, 61H, 63H, 74H, 69H, 76H, 65H
        DC8 20H, 74H, 69H, 6DH, 65H, 20H, 2DH, 20H
        DC8 63H, 75H, 72H, 72H, 65H, 6EH, 74H, 20H
        DC8 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H, 3AH
        DC8 20H, 0
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "KILLED. ">`:
        DC8 "KILLED. "
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Printer halted. kill(...">`:
        DC8 "Printer halted. kill() called!\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_1`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Err%d">`:
        DC8 "Err%d"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Printer stopped due t...">`:
        DC8 50H, 72H, 69H, 6EH, 74H, 65H, 72H, 20H
        DC8 73H, 74H, 6FH, 70H, 70H, 65H, 64H, 20H
        DC8 64H, 75H, 65H, 20H, 74H, 6FH, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 73H, 2EH, 20H, 46H
        DC8 69H, 78H, 20H, 74H, 68H, 65H, 20H, 65H
        DC8 72H, 72H, 6FH, 72H, 20H, 61H, 6EH, 64H
        DC8 20H, 75H, 73H, 65H, 20H, 4DH, 39H, 39H
        DC8 39H, 20H, 74H, 6FH, 20H, 72H, 65H, 73H
        DC8 74H, 61H, 72H, 74H, 2EH, 20H, 28H, 54H
        DC8 65H, 6DH, 70H, 65H, 72H, 61H, 74H, 75H
        DC8 72H, 65H, 20H, 69H, 73H, 20H, 72H, 65H
        DC8 73H, 65H, 74H, 2EH, 20H, 53H, 65H, 74H
        DC8 20H, 69H, 74H, 20H, 61H, 66H, 74H, 65H
        DC8 72H, 20H, 72H, 65H, 73H, 74H, 61H, 72H
        DC8 74H, 69H, 6EH, 67H, 29H, 0AH, 0
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "MKS Robin Nano">`:
        DC8 "MKS Robin Nano"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "1.0.0\\n">`:
        DC8 "1.0.0\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Last Updated: ">`:
        DC8 " Last Updated: "

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "2017-12-25 12:00">`:
        DC8 "2017-12-25 12:00"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " | Author: (none, def...">`:
        DC8 " | Author: (none, default config)\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Compiled: Apr 13 2020\\n">`:
        DC8 "Compiled: Apr 13 2020\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Free Memory: ">`:
        DC8 " Free Memory: "
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "  PlannerBufferBytes: ">`:
        DC8 "  PlannerBufferBytes: "
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M29">`:
        DC8 "M29"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "Done saving file.\\n">`:
        DC8 "Done saving file.\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "0.000">`:
        DC8 "0.000"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "TP-LINK_MKS">`:
        DC8 "TP-LINK_MKS"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "makerbase">`:
        DC8 "makerbase"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "192.168.3.100">`:
        DC8 "192.168.3.100"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "255.255.255.0">`:
        DC8 "255.255.255.0"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "192.168.3.1">`:
        DC8 "192.168.3.1"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "192.168.3.255">`:
        DC8 "192.168.3.255"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "baizhongyun.cn">`:
        DC8 "baizhongyun.cn"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G28 X0 Y0">`:
        DC8 "G28 X0 Y0"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M140 S">`:
        DC8 "M140 S"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%d">`:
        DC8 "%d"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M104 T1 S">`:
        DC8 "M104 T1 S"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M109 T0 S">`:
        DC8 "M109 T0 S"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M109 T1 S">`:
        DC8 "M109 T1 S"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "M190 S">`:
        DC8 "M190 S"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G92 Z">`:
        DC8 "G92 Z"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%f">`:
        DC8 "%f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G1 E">`:
        DC8 "G1 E"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G92 E">`:
        DC8 "G92 E"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G1 X">`:
        DC8 "G1 X"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant " Y">`:
        DC8 " Y"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G1 Z">`:
        DC8 "G1 Z"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%.3f F%.3f">`:
        DC8 "%.3f F%.3f"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "%.3f">`:
        DC8 "%.3f"
        DC8 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G28">`:
        DC8 "G28"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "G1 Z0">`:
        DC8 "G1 Z0"
        DC8 0, 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "/">`:
        DC8 "/"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_2`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "start\\n">`:
        DC8 "start\012"
        DC8 0

        SECTION `.rodata`:CONST:NOROOT(1)
        DATA
`?<Constant "\\n">`:
        DC8 "\012"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "end">`:
        DC8 "end"

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_3`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant "clear">`:
        DC8 "clear"
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
`?<Constant {'\\000'}>_4`:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
axis_codes:
        DC8 88, 89, 90, 69

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
L1:
        DC32 43160000H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
L2:
        DC32 43160000H

        SECTION `.rodata`:CONST:NOROOT(2)
        DATA
??sensitive_pins:
        DC8 0, 1, 1, 0, 2, 3, 3, 6, 5, 7, 8, 8, 11, 10, 12, 13, 14, 14, -1, 21
        DC8 17, -1, -1, -1, 16, 15, 17, -1, -1, 19, 18, 20, -1, -1, 21, 78, 22
        DC8 -1, 79, 23, -1, 80, 19, 18, 20, -1, -1, -1, -1, -1, -1, 0
// 9157     str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
// 9158     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9159       , str_debug_32
// 9160     #endif
// 9161   };
// 9162 
// 9163   SERIAL_ECHO_START();
// 9164   SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
// 9165   if (marlin_debug_flags) {
// 9166     uint8_t comma = 0;
// 9167     for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
// 9168       if (TEST(marlin_debug_flags, i)) {
// 9169         if (comma++) SERIAL_CHAR(',');
// 9170         //serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
// 9171         serialprintPGM((char*)&(debug_strings[i]));
// 9172       }
// 9173     }
// 9174   }
// 9175   else {
// 9176     SERIAL_ECHOPGM(MSG_DEBUG_OFF);
// 9177   }
// 9178   SERIAL_EOL();
// 9179 }
// 9180 
// 9181 #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 9182 
// 9183   /**
// 9184    * M113: Get or set Host Keepalive interval (0 to disable)
// 9185    *
// 9186    *   S<seconds> Optional. Set the keepalive interval.
// 9187    */
// 9188   inline void gcode_M113() {
// 9189     if (parser.seenval('S')) {
// 9190       host_keepalive_interval = parser.value_byte();
// 9191       NOMORE(host_keepalive_interval, 60);
// 9192     }
// 9193     else {
// 9194       SERIAL_ECHO_START();
// 9195       SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
// 9196     }
// 9197   }
// 9198 
// 9199 #endif
// 9200 
// 9201 #if ENABLED(BARICUDA)
// 9202 
// 9203   #if HAS_HEATER_1
// 9204     /**
// 9205      * M126: Heater 1 valve open
// 9206      */
// 9207     inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
// 9208     /**
// 9209      * M127: Heater 1 valve close
// 9210      */
// 9211     inline void gcode_M127() { baricuda_valve_pressure = 0; }
// 9212   #endif
// 9213 
// 9214   #if HAS_HEATER_2
// 9215     /**
// 9216      * M128: Heater 2 valve open
// 9217      */
// 9218     inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
// 9219     /**
// 9220      * M129: Heater 2 valve close
// 9221      */
// 9222     inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
// 9223   #endif
// 9224 
// 9225 #endif // BARICUDA
// 9226 
// 9227 /**
// 9228  * M140: Set bed temperature
// 9229  */
// 9230 inline void gcode_M140() {
// 9231   if (DEBUGGING(DRYRUN)) return;
// 9232   if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
// 9233 }
// 9234 
// 9235 #if ENABLED(ULTIPANEL)
// 9236 
// 9237   /**
// 9238    * M145: Set the heatup state for a material in the LCD menu
// 9239    *
// 9240    *   S<material> (0=PLA, 1=ABS)
// 9241    *   H<hotend temp>
// 9242    *   B<bed temp>
// 9243    *   F<fan speed>
// 9244    */
// 9245   inline void gcode_M145() {
// 9246     const uint8_t material = (uint8_t)parser.intval('S');
// 9247     if (material >= COUNT(lcd_preheat_hotend_temp)) {
// 9248       SERIAL_ERROR_START();
// 9249       SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
// 9250     }
// 9251     else {
// 9252       int v;
// 9253       if (parser.seenval('H')) {
// 9254         v = parser.value_int();
// 9255         lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
// 9256       }
// 9257       if (parser.seenval('F')) {
// 9258         v = parser.value_int();
// 9259         lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
// 9260       }
// 9261       #if TEMP_SENSOR_BED != 0
// 9262         if (parser.seenval('B')) {
// 9263           v = parser.value_int();
// 9264           lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
// 9265         }
// 9266       #endif
// 9267     }
// 9268   }
// 9269 
// 9270 #endif // ULTIPANEL
// 9271 
// 9272 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 9273   /**
// 9274    * M149: Set temperature units
// 9275    */
// 9276   inline void gcode_M149() {
// 9277          if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
// 9278     else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
// 9279     else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
// 9280   }
// 9281 #endif
// 9282 
// 9283 #if HAS_POWER_SWITCH
// 9284 
// 9285   /**
// 9286    * M80   : Turn on the Power Supply
// 9287    * M80 S : Report the current state and exit
// 9288    */
// 9289   inline void gcode_M80() {
// 9290 
// 9291     // S: Report the current power supply state and exit
// 9292     if (parser.seen('S')) {
// 9293       serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
// 9294       return;
// 9295     }
// 9296 
// 9297     OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
// 9298 
// 9299     /**
// 9300      * If you have a switch on suicide pin, this is useful
// 9301      * if you want to start another print with suicide feature after
// 9302      * a print without suicide...
// 9303      */
// 9304     #if HAS_SUICIDE
// 9305       OUT_WRITE(SUICIDE_PIN, HIGH);
// 9306     #endif
// 9307 
// 9308     #if ENABLED(HAVE_TMC2130)
// 9309       delay(100);
// 9310       tmc2130_init(); // Settings only stick when the driver has power
// 9311     #endif
// 9312 
// 9313     powersupply_on = true;
// 9314 
// 9315     #if ENABLED(ULTIPANEL)
// 9316       LCD_MESSAGEPGM(WELCOME_MSG);
// 9317     #endif
// 9318 
// 9319     #if ENABLED(HAVE_TMC2208)
// 9320       delay(100);
// 9321       tmc2208_init();
// 9322     #endif
// 9323   }
// 9324 
// 9325 #endif // HAS_POWER_SWITCH
// 9326 
// 9327 /**
// 9328  * M81: Turn off Power, including Power Supply, if there is one.
// 9329  *
// 9330  *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
// 9331  */
// 9332 inline void gcode_M81() {
// 9333   thermalManager.disable_all_heaters();
// 9334   stepper.finish_and_disable();
// 9335 
// 9336   #if FAN_COUNT > 0
// 9337     for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
// 9338     #if ENABLED(PROBING_FANS_OFF)
// 9339       fans_paused = false;
// 9340       ZERO(paused_fanSpeeds);
// 9341     #endif
// 9342   #endif
// 9343 
// 9344   safe_delay(1000); // Wait 1 second before switching off
// 9345 
// 9346   #if HAS_SUICIDE
// 9347     stepper.synchronize();
// 9348     suicide();
// 9349   #elif HAS_POWER_SWITCH
// 9350     OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
// 9351     powersupply_on = false;
// 9352   #endif
// 9353 
// 9354   #if ENABLED(ULTIPANEL)
// 9355     //LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
// 9356       if(LCD_LANGUAGE)
// 9357         LCD_MESSAGEPGM(MACHINE_NAME " " "\xb5 " ".");
// 9358       else
// 9359         LCD_MESSAGEPGM(MACHINE_NAME " " "Off" ".");    
// 9360   #endif
// 9361 }
// 9362 
// 9363 /**
// 9364  * M82: Set E codes absolute (default)
// 9365  */
// 9366 inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
// 9367 
// 9368 /**
// 9369  * M83: Set E codes relative while in Absolute Coordinates (G90) mode
// 9370  */
// 9371 inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
// 9372 
// 9373 /**
// 9374  * M18, M84: Disable stepper motors
// 9375  */
// 9376 inline void gcode_M18_M84() {
// 9377   if (parser.seenval('S')) {
// 9378     stepper_inactive_time = parser.value_millis_from_seconds();
// 9379   }
// 9380   else {
// 9381     bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
// 9382     if (all_axis) {
// 9383       stepper.finish_and_disable();
// 9384     }
// 9385     else {
// 9386       stepper.synchronize();
// 9387       if (parser.seen('X')) disable_X();
// 9388       if (parser.seen('Y')) disable_Y();
// 9389       if (parser.seen('Z')) disable_Z();
// 9390       #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
// 9391         if (parser.seen('E')) disable_e_steppers();
// 9392       #endif
// 9393     }
// 9394 
// 9395     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 9396       ubl.lcd_map_control = defer_return_to_status = false;
// 9397     #endif
// 9398   }
// 9399 }
// 9400 
// 9401 /**
// 9402  * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
// 9403  */
// 9404 inline void gcode_M85() {
// 9405   if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
// 9406 }
// 9407 
// 9408 /**
// 9409  * Multi-stepper support for M92, M201, M203
// 9410  */
// 9411 #if ENABLED(DISTINCT_E_FACTORS)
// 9412   #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
// 9413   #define TARGET_EXTRUDER target_extruder
// 9414 #else
// 9415   #define GET_TARGET_EXTRUDER(CMD) NOOP
// 9416   #define TARGET_EXTRUDER 0
// 9417 #endif
// 9418 
// 9419 /**
// 9420  * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
// 9421  *      (Follows the same syntax as G92)
// 9422  *
// 9423  *      With multiple extruders use T to specify which one.
// 9424  */
// 9425 inline void gcode_M92() {
// 9426 
// 9427   GET_TARGET_EXTRUDER(92);
// 9428 
// 9429   LOOP_XYZE(i) {
// 9430     if (parser.seen(axis_codes[i])) {
// 9431       if (i == E_AXIS) {
// 9432         const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
// 9433         if (value < 20.0) {
// 9434           float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
// 9435           planner.max_jerk[E_AXIS] *= factor;
// 9436           planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
// 9437           planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
// 9438         }
// 9439         planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
// 9440       }
// 9441       else {
// 9442         planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
// 9443       }
// 9444     }
// 9445   }
// 9446   planner.refresh_positioning();
// 9447 }
// 9448 
// 9449 /**
// 9450  * Output the current position to serial
// 9451  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock57 Using cfiCommon0
          CFI Function _Z23report_current_positionv
        THUMB
// 9452 void report_current_position() {
_Z23report_current_positionv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 9453   SERIAL_PROTOCOLPGM("X:");
        ADR.N    R0,??DataTable139  ;; 0x58, 0x3A, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9454   SERIAL_PROTOCOL(/*LOGICAL_X_POSITION*/(current_position[X_AXIS]));
        MOVS     R0,#+2
        LDR.N    R5,??DataTable137_1
        LDR.N    R4,??DataTable139_6
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+16]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9455   SERIAL_PROTOCOLPGM(" Y:");
        ADR.N    R0,??DataTable139_1  ;; " Y:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9456   SERIAL_PROTOCOL(/*LOGICAL_Y_POSITION*/(current_position[Y_AXIS]));
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+20]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9457   SERIAL_PROTOCOLPGM(" Z:");
        ADR.N    R0,??DataTable139_3  ;; " Z:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9458   SERIAL_PROTOCOL(/*LOGICAL_Z_POSITION*/(current_position[Z_AXIS]));
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+24]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9459   SERIAL_PROTOCOLPGM(" E:");
        ADR.N    R0,??DataTable139_4  ;; " E:"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9460   SERIAL_PROTOCOL(current_position[E_AXIS]);
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+28]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
// 9461 
// 9462   stepper.report_positions();
          CFI FunCall _ZN7Stepper16report_positionsEv
        BL       _ZN7Stepper16report_positionsEv
// 9463 
// 9464   //#if IS_SCARA
// 9465   if(MACHINETPYE&IS_SCARA)  
        LDR.N    R0,??DataTable140
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??report_current_position_0
// 9466   {
// 9467     SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R1,R0
        LDR.N    R0,??DataTable140_28
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
// 9468     SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R1,R0
        LDR.N    R0,??DataTable140_29
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 9469     SERIAL_EOL();
        B.N      ?Subroutine6
// 9470   }
// 9471   //#endif
// 9472 }
??report_current_position_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock57

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137:
        DC32     ??gridx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_1:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_2:
        DC32     _ZN7Planner13z_fade_heightE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_3:
        DC32     0xb58637bd

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_4:
        DC32     0x358637be

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable137_5:
        DC32     _ZN7Planner21inverse_z_fade_heightE
// 9473 
// 9474 #ifdef M114_DETAIL
// 9475 
// 9476   void report_xyze(const float pos[], const uint8_t n = 4, const uint8_t precision = 3) {
// 9477     char str[12];
// 9478     for (uint8_t i = 0; i < n; i++) {
// 9479       SERIAL_CHAR(' ');
// 9480       SERIAL_CHAR(axis_codes[i]);
// 9481       SERIAL_CHAR(':');
// 9482       SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
// 9483     }
// 9484     SERIAL_EOL();
// 9485   }
// 9486 
// 9487   inline void report_xyz(const float pos[]) { report_xyze(pos, 3); }
// 9488 
// 9489   void report_current_position_detail() {
// 9490 
// 9491     stepper.synchronize();
// 9492 
// 9493     SERIAL_PROTOCOLPGM("\nLogical:");
// 9494     const float logical[XYZ] = {
// 9495       LOGICAL_X_POSITION(current_position[X_AXIS]),
// 9496       LOGICAL_Y_POSITION(current_position[Y_AXIS]),
// 9497       LOGICAL_Z_POSITION(current_position[Z_AXIS])
// 9498     };
// 9499     report_xyze(logical);
// 9500 
// 9501     SERIAL_PROTOCOLPGM("Raw:    ");
// 9502     report_xyz(current_position);
// 9503 
// 9504     float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 9505 
// 9506     #if PLANNER_LEVELING
// 9507       SERIAL_PROTOCOLPGM("Leveled:");
// 9508       planner.apply_leveling(leveled);
// 9509       report_xyz(leveled);
// 9510 
// 9511       SERIAL_PROTOCOLPGM("UnLevel:");
// 9512       float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
// 9513       planner.unapply_leveling(unleveled);
// 9514       report_xyz(unleveled);
// 9515     #endif
// 9516 
// 9517     #if IS_KINEMATIC
// 9518       #if IS_SCARA
// 9519         SERIAL_PROTOCOLPGM("ScaraK: ");
// 9520       #else
// 9521         SERIAL_PROTOCOLPGM("DeltaK: ");
// 9522       #endif
// 9523       inverse_kinematics(leveled);  // writes delta[]
// 9524       report_xyz(delta);
// 9525     #endif
// 9526 
// 9527     SERIAL_PROTOCOLPGM("Stepper:");
// 9528     LOOP_XYZE(i) {
// 9529       SERIAL_CHAR(' ');
// 9530       SERIAL_CHAR(axis_codes[i]);
// 9531       SERIAL_CHAR(':');
// 9532       SERIAL_PROTOCOL(stepper.position((AxisEnum)i));
// 9533     }
// 9534     SERIAL_EOL();
// 9535 
// 9536     #if IS_SCARA
// 9537       const float deg[XYZ] = {
// 9538         stepper.get_axis_position_degrees(A_AXIS),
// 9539         stepper.get_axis_position_degrees(B_AXIS)
// 9540       };
// 9541       SERIAL_PROTOCOLPGM("Degrees:");
// 9542       report_xyze(deg, 2);
// 9543     #endif
// 9544 
// 9545     SERIAL_PROTOCOLPGM("FromStp:");
// 9546     get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
// 9547     const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
// 9548     report_xyze(from_steppers);
// 9549 
// 9550     const float diff[XYZE] = {
// 9551       from_steppers[X_AXIS] - leveled[X_AXIS],
// 9552       from_steppers[Y_AXIS] - leveled[Y_AXIS],
// 9553       from_steppers[Z_AXIS] - leveled[Z_AXIS],
// 9554       from_steppers[E_AXIS] - current_position[E_AXIS]
// 9555     };
// 9556     SERIAL_PROTOCOLPGM("Differ: ");
// 9557     report_xyze(diff);
// 9558   }
// 9559 #endif // M114_DETAIL
// 9560 
// 9561 /**
// 9562  * M114: Report current position to host
// 9563  */
// 9564 inline void gcode_M114() {
// 9565 
// 9566   #ifdef M114_DETAIL
// 9567     if (parser.seen('D')) {
// 9568       report_current_position_detail();
// 9569       return;
// 9570     }
// 9571   #endif
// 9572 
// 9573   stepper.synchronize();
// 9574   report_current_position();
// 9575 }
// 9576 
// 9577 /**
// 9578  * M115: Capabilities string
// 9579  */
// 9580 
// 9581 #if ENABLED(EXTENDED_CAPABILITIES_REPORT)

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock58 Using cfiCommon0
          CFI Function _Z8cap_linePKcb
        THUMB
// 9582   static void cap_line(const char * const name, bool ena=false) {
_Z8cap_linePKcb:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        MOV      R5,R1
// 9583     SERIAL_PROTOCOLPGM("Cap:");
        LDR.N    R0,??DataTable140_30
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9584     serialprintPGM(name);
        MOV      R0,R4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9585     SERIAL_PROTOCOLPGM(":");
        ADR.N    R0,??DataTable139_7  ;; ":"
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 9586     SERIAL_PROTOCOLLN(int(ena ? 1 : 0));
        LDR.N    R4,??DataTable139_6
        MOVS     R2,#+10
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEii
        BL       _ZN5Print5printEii
          CFI EndBlock cfiBlock58
        REQUIRE ?Subroutine6
        ;; // Fall through to label ?Subroutine6
// 9587   }

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock59 Using cfiCommon0
          CFI NoFunction
          CFI CFA R13+16
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine6:
        MOV      R0,R4
        POP      {R2,R4,R5,LR}
          CFI CFA R13+0
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
??Subroutine6_0:
        MOVS     R1,#+10
          CFI FunCall _Z23report_current_positionv _ZN10USARTClass5writeEh
          CFI FunCall _Z8cap_linePKcb _ZN10USARTClass5writeEh
          CFI FunCall _Z14print_2d_arrayhhhh _ZN10USARTClass5writeEh
          CFI FunCall _Z10ok_to_sendv _ZN10USARTClass5writeEh
        B.W      _ZN10USARTClass5writeEh
          CFI EndBlock cfiBlock59
// 9588 #endif
// 9589 
// 9590 inline void gcode_M115() {
// 9591   SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
// 9592 
// 9593   #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
// 9594 
// 9595     // SERIAL_XON_XOFF
// 9596     cap_line(PSTR("SERIAL_XON_XOFF")
// 9597       #if ENABLED(SERIAL_XON_XOFF)
// 9598         , true
// 9599       #endif
// 9600     );
// 9601 
// 9602     // EEPROM (M500, M501)
// 9603     cap_line(PSTR("EEPROM")
// 9604       #if ENABLED(EEPROM_SETTINGS)
// 9605         , true
// 9606       #endif
// 9607     );
// 9608 
// 9609     // Volumetric Extrusion (M200)
// 9610     cap_line(PSTR("VOLUMETRIC")
// 9611       #if DISABLED(NO_VOLUMETRICS)
// 9612         , true
// 9613       #endif
// 9614     );
// 9615 
// 9616     // AUTOREPORT_TEMP (M155)
// 9617     cap_line(PSTR("AUTOREPORT_TEMP")
// 9618       #if ENABLED(AUTO_REPORT_TEMPERATURES)
// 9619         , true
// 9620       #endif
// 9621     );
// 9622 
// 9623     // PROGRESS (M530 S L, M531 <file>, M532 X L)
// 9624     cap_line(PSTR("PROGRESS"));
// 9625 
// 9626     // Print Job timer M75, M76, M77
// 9627     cap_line(PSTR("PRINT_JOB"), true);
// 9628 
// 9629     // AUTOLEVEL (G29)
// 9630     cap_line(PSTR("AUTOLEVEL")
// 9631       #if HAS_AUTOLEVEL
// 9632         , true
// 9633       #endif
// 9634     );
// 9635 
// 9636     // Z_PROBE (G30)
// 9637     cap_line(PSTR("Z_PROBE")
// 9638       #if HAS_BED_PROBE
// 9639         , true
// 9640       #endif
// 9641     );
// 9642 
// 9643     // MESH_REPORT (M420 V)
// 9644     cap_line(PSTR("LEVELING_DATA")
// 9645       #if HAS_LEVELING
// 9646         , true
// 9647       #endif
// 9648     );
// 9649 
// 9650     // BUILD_PERCENT (M73)
// 9651     cap_line(PSTR("BUILD_PERCENT")
// 9652       #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 9653         , true
// 9654       #endif
// 9655     );
// 9656 
// 9657     // SOFTWARE_POWER (M80, M81)
// 9658     cap_line(PSTR("SOFTWARE_POWER")
// 9659       #if HAS_POWER_SWITCH
// 9660         , true
// 9661       #endif
// 9662     );
// 9663 
// 9664     // CASE LIGHTS (M355)
// 9665     cap_line(PSTR("TOGGLE_LIGHTS")
// 9666       #if HAS_CASE_LIGHT
// 9667         , true
// 9668       #endif
// 9669     );
// 9670     cap_line(PSTR("CASE_LIGHT_BRIGHTNESS")
// 9671       #if HAS_CASE_LIGHT
// 9672         , USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)
// 9673       #endif
// 9674     );
// 9675 
// 9676     // EMERGENCY_PARSER (M108, M112, M410)
// 9677     cap_line(PSTR("EMERGENCY_PARSER")
// 9678       #if ENABLED(EMERGENCY_PARSER)
// 9679         , true
// 9680       #endif
// 9681     );
// 9682 
// 9683   #endif // EXTENDED_CAPABILITIES_REPORT
// 9684 }
// 9685 
// 9686 /**
// 9687  * M117: Set LCD Status Message
// 9688  */
// 9689 inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
// 9690 
// 9691 /**
// 9692  * M118: Display a message in the host console.
// 9693  *
// 9694  *  A1  Append '// ' for an action command, as in OctoPrint
// 9695  *  E1  Have the host 'echo:' the text
// 9696  */
// 9697 inline void gcode_M118() {
// 9698   if (parser.boolval('E')) SERIAL_ECHO_START();
// 9699   if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
// 9700   SERIAL_ECHOLN(parser.string_arg);
// 9701 }
// 9702 
// 9703 /**
// 9704  * M119: Output endstop states to serial output
// 9705  */
// 9706 inline void gcode_M119() { endstops.M119(); }
// 9707 
// 9708 /**
// 9709  * M120: Enable endstops and set non-homing endstop state to "enabled"
// 9710  */
// 9711 inline void gcode_M120() { endstops.enable_globally(true); }
// 9712 
// 9713 /**
// 9714  * M121: Disable endstops and set non-homing endstop state to "disabled"
// 9715  */
// 9716 inline void gcode_M121() { endstops.enable_globally(false); }
// 9717 
// 9718 #if ENABLED(PARK_HEAD_ON_PAUSE)
// 9719 
// 9720   /**
// 9721    * M125: Store current position and move to filament change position.
// 9722    *       Called on pause (by M25) to prevent material leaking onto the
// 9723    *       object. On resume (M24) the head will be moved back and the
// 9724    *       print will resume.
// 9725    *
// 9726    *       If Marlin is compiled without SD Card support, M125 can be
// 9727    *       used directly to pause the print and move to park position,
// 9728    *       resuming with a button click or M108.
// 9729    *
// 9730    *    L = override retract length
// 9731    *    X = override X
// 9732    *    Y = override Y
// 9733    *    Z = override Z raise
// 9734    */
// 9735   inline void gcode_M125() {
// 9736 
// 9737     // Initial retract before move to filament change position
// 9738     const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 9739       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 9740         - (PAUSE_PARK_RETRACT_LENGTH)
// 9741       #endif
// 9742     ;
// 9743 
// 9744     point_t park_point = NOZZLE_PARK_POINT;
// 9745 
// 9746     // Move XY axes to filament change position or given position
// 9747     if (parser.seenval('X')) park_point.x = parser.linearval('X');
// 9748     if (parser.seenval('Y')) park_point.y = parser.linearval('Y');
// 9749 
// 9750     // Lift Z axis
// 9751     if (parser.seenval('Z')) park_point.z = parser.linearval('Z');
// 9752 
// 9753     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 9754       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 9755       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 9756     #endif
// 9757 
// 9758     #if DISABLED(SDSUPPORT)
// 9759       const bool job_running = print_job_timer.isRunning();
// 9760     #endif
// 9761 
// 9762     if (pause_print(retract, park_point)) {
// 9763       #if DISABLED(SDSUPPORT)
// 9764         // Wait for lcd click or M108
// 9765         wait_for_filament_reload();
// 9766 
// 9767         // Return to print position and continue
// 9768         resume_print();
// 9769 
// 9770         if (job_running) print_job_timer.start();
// 9771       #endif
// 9772     }
// 9773   }
// 9774 
// 9775 #endif // PARK_HEAD_ON_PAUSE
// 9776 
// 9777 #if HAS_COLOR_LEDS
// 9778 
// 9779   /**
// 9780    * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
// 9781    *       and Brightness       - Use P (for NEOPIXEL only)
// 9782    *
// 9783    * Always sets all 3 or 4 components. If a component is left out, set to 0.
// 9784    *                                    If brightness is left out, no value changed
// 9785    *
// 9786    * Examples:
// 9787    *
// 9788    *   M150 R255       ; Turn LED red
// 9789    *   M150 R255 U127  ; Turn LED orange (PWM only)
// 9790    *   M150            ; Turn LED off
// 9791    *   M150 R U B      ; Turn LED white
// 9792    *   M150 W          ; Turn LED white using a white LED
// 9793    *   M150 P127       ; Set LED 50% brightness
// 9794    *   M150 P          ; Set LED full brightness
// 9795    */
// 9796   inline void gcode_M150() {
// 9797     leds.set_color(MakeLEDColor(
// 9798       parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9799       parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9800       parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9801       parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
// 9802       parser.seen('P') ? (parser.has_value() ? parser.value_byte() : 255) : pixels.getBrightness()
// 9803     ));
// 9804   }
// 9805 
// 9806 #endif // HAS_COLOR_LEDS
// 9807 
// 9808 #if DISABLED(NO_VOLUMETRICS)
// 9809 
// 9810   /**
// 9811    * M200: Set filament diameter and set E axis units to cubic units
// 9812    *
// 9813    *    T<extruder> - Optional extruder number. Current extruder if omitted.
// 9814    *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
// 9815    */
// 9816   inline void gcode_M200() {
// 9817 
// 9818     if (get_target_extruder_from_command(200)) return;
// 9819 
// 9820     if (parser.seen('D')) {
// 9821       // setting any extruder filament size disables volumetric on the assumption that
// 9822       // slicers either generate in extruder values as cubic mm or as as filament feeds
// 9823       // for all extruders
// 9824       if ( (parser.volumetric_enabled = (parser.value_linear_units() != 0.0)) )
// 9825         planner.set_filament_size(target_extruder, parser.value_linear_units());
// 9826     }
// 9827     planner.calculate_volumetric_multipliers();
// 9828   }
// 9829 
// 9830 #endif // !NO_VOLUMETRICS
// 9831 
// 9832 /**
// 9833  * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
// 9834  *
// 9835  *       With multiple extruders use T to specify which one.
// 9836  */
// 9837 inline void gcode_M201() {
// 9838 
// 9839   GET_TARGET_EXTRUDER(201);
// 9840 
// 9841   LOOP_XYZE(i) {
// 9842     if (parser.seen(axis_codes[i])) {
// 9843       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9844       planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
// 9845     }
// 9846   }
// 9847   // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
// 9848   planner.reset_acceleration_rates();
// 9849 }
// 9850 
// 9851 #if 0 // Not used for Sprinter/grbl gen6
// 9852   inline void gcode_M202() {
// 9853     LOOP_XYZE(i) {
// 9854       if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
// 9855     }
// 9856   }
// 9857 #endif
// 9858 
// 9859 
// 9860 /**
// 9861  * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
// 9862  *
// 9863  *       With multiple extruders use T to specify which one.
// 9864  */
// 9865 inline void gcode_M203() {
// 9866 
// 9867   GET_TARGET_EXTRUDER(203);
// 9868 
// 9869   LOOP_XYZE(i)
// 9870     if (parser.seen(axis_codes[i])) {
// 9871       const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
// 9872       planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
// 9873     }
// 9874 }
// 9875 
// 9876 /**
// 9877  * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
// 9878  *
// 9879  *    P = Printing moves
// 9880  *    R = Retract only (no X, Y, Z) moves
// 9881  *    T = Travel (non printing) moves
// 9882  *
// 9883  *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
// 9884  */
// 9885 inline void gcode_M204() {
// 9886   if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
// 9887     planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
// 9888     SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
// 9889   }
// 9890   if (parser.seen('P')) {
// 9891     planner.acceleration = parser.value_linear_units();
// 9892     SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
// 9893   }
// 9894   if (parser.seen('R')) {
// 9895     planner.retract_acceleration = parser.value_linear_units();
// 9896     SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
// 9897   }
// 9898   if (parser.seen('T')) {
// 9899     planner.travel_acceleration = parser.value_linear_units();
// 9900     SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
// 9901   }
// 9902 }
// 9903 
// 9904 /**
// 9905  * M205: Set Advanced Settings
// 9906  *
// 9907  *    S = Min Feed Rate (units/s)
// 9908  *    T = Min Travel Feed Rate (units/s)
// 9909  *    B = Min Segment Time (Âµs)
// 9910  *    X = Max X Jerk (units/sec^2)
// 9911  *    Y = Max Y Jerk (units/sec^2)
// 9912  *    Z = Max Z Jerk (units/sec^2)
// 9913  *    E = Max E Jerk (units/sec^2)
// 9914  */
// 9915 inline void gcode_M205() {
// 9916   if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
// 9917   if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
// 9918   if (parser.seen('B')) planner.min_segment_time_us = parser.value_ulong();
// 9919   if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
// 9920   if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
// 9921   if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
// 9922   if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
// 9923 }
// 9924 
// 9925 #if 1//HAS_M206_COMMAND
// 9926 
// 9927   /**
// 9928    * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
// 9929    *
// 9930    * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
// 9931    * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
// 9932    * ***              In the next 1.2 release, it will simply be disabled by default.
// 9933    */
// 9934   inline void gcode_M206() {
// 9935   if(MACHINETPYE == DELTA) return;
// 9936     LOOP_XYZ(i)
// 9937       if (parser.seen(axis_codes[i]))
// 9938         set_home_offset((AxisEnum)i, parser.value_linear_units());
// 9939 
// 9940     //#if ENABLED(MORGAN_SCARA)
// 9941     if(MACHINETPYE == MORGAN_SCARA)
// 9942     {
// 9943       if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_float()); // Theta
// 9944       if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_float()); // Psi
// 9945     }
// 9946     //#endif
// 9947 
// 9948     report_current_position();
// 9949   }
// 9950 
// 9951 #endif // HAS_M206_COMMAND
// 9952 
// 9953 #if 1//ENABLED(DELTA)
// 9954   /**
// 9955    * M665: Set delta configurations
// 9956    *
// 9957    *    H = delta height
// 9958    *    L = diagonal rod
// 9959    *    R = delta radius
// 9960    *    S = segments per second
// 9961    *    B = delta calibration radius
// 9962    *    X = Alpha (Tower 1) angle trim
// 9963    *    Y = Beta (Tower 2) angle trim
// 9964    *    Z = Rotate A and B by this angle
// 9965    */
// 9966   inline void gcode_M665() {
// 9967     if (parser.seen('H')) delta_height                   = parser.value_linear_units();
// 9968     if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
// 9969     if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
// 9970     if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
// 9971     if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
// 9972     if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
// 9973     if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
// 9974     if (parser.seen('Z')) delta_tower_angle_trim[C_AXIS] = parser.value_float();
// 9975     recalc_delta_settings();
// 9976   }
// 9977   /**
// 9978    * M666: Set delta endstop adjustment
// 9979    */
// 9980   inline void gcode_M666() {
// 9981     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9982       if (DEBUGGING(LEVELING)) {
// 9983         SERIAL_ECHOLNPGM(">>> gcode_M666");
// 9984       }
// 9985     #endif
// 9986     LOOP_XYZ(i) {
// 9987       if (parser.seen(axis_codes[i])) {
// 9988         if (parser.value_linear_units() * Z_HOME_DIR <= 0)
// 9989           delta_endstop_adj[i] = parser.value_linear_units();
// 9990         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9991           if (DEBUGGING(LEVELING)) {
// 9992             SERIAL_ECHOPAIR("delta_endstop_adj[", axis_codes[i]);
// 9993             SERIAL_ECHOLNPAIR("] = ", delta_endstop_adj[i]);
// 9994           }
// 9995         #endif
// 9996       }
// 9997     }
// 9998     #if ENABLED(DEBUG_LEVELING_FEATURE)
// 9999       if (DEBUGGING(LEVELING)) {
// 10000         SERIAL_ECHOLNPGM("<<< gcode_M666");
// 10001       }
// 10002     #endif
// 10003   }
// 10004 
// 10005 #elif IS_SCARA
// 10006 
// 10007   /**
// 10008    * M665: Set SCARA settings
// 10009    *
// 10010    * Parameters:
// 10011    *
// 10012    *   S[segments-per-second] - Segments-per-second
// 10013    *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
// 10014    *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
// 10015    *
// 10016    *   A, P, and X are all aliases for the shoulder angle
// 10017    *   B, T, and Y are all aliases for the elbow angle
// 10018    */
// 10019   inline void gcode_M665() {
// 10020     if (parser.seen('S')) delta_segments_per_second = parser.value_float();
// 10021 
// 10022     const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
// 10023     const uint8_t sumAPX = hasA + hasP + hasX;
// 10024     if (sumAPX == 1)
// 10025       home_offset[A_AXIS] = parser.value_float();
// 10026     else if (sumAPX > 1) {
// 10027       SERIAL_ERROR_START();
// 10028       SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
// 10029       return;
// 10030     }
// 10031 
// 10032     const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
// 10033     const uint8_t sumBTY = hasB + hasT + hasY;
// 10034     if (sumBTY == 1)
// 10035       home_offset[B_AXIS] = parser.value_float();
// 10036     else if (sumBTY > 1) {
// 10037       SERIAL_ERROR_START();
// 10038       SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
// 10039       return;
// 10040     }
// 10041   }
// 10042 
// 10043 
// 10044 #endif
// 10045 //#elif ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 10046 
// 10047   /**
// 10048    * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
// 10049    */
// 10050   inline void gcode_M666_dual() {
// 10051     SERIAL_ECHOPGM("Dual Endstop Adjustment (mm): ");
// 10052     #if ENABLED(X_DUAL_ENDSTOPS)
// 10053       if (parser.seen('X')) x_endstop_adj = parser.value_linear_units();
// 10054       SERIAL_ECHOPAIR(" X", x_endstop_adj);
// 10055     #endif
// 10056     #if ENABLED(Y_DUAL_ENDSTOPS)
// 10057       if (parser.seen('Y')) y_endstop_adj = parser.value_linear_units();
// 10058       SERIAL_ECHOPAIR(" Y", y_endstop_adj);
// 10059     #endif
// 10060     //#if ENABLED(Z_DUAL_ENDSTOPS)
// 10061     if(Z_DUAL_ENDSTOPS==1)
// 10062     {
// 10063       if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
// 10064       SERIAL_ECHOPAIR(" Z", z_endstop_adj);
// 10065     }
// 10066     //#endif
// 10067     SERIAL_EOL();
// 10068   }
// 10069 
// 10070 //#endif // !DELTA && Z_DUAL_ENDSTOPS
// 10071 
// 10072 #if ENABLED(FWRETRACT)
// 10073 
// 10074   /**
// 10075    * M207: Set firmware retraction values
// 10076    *
// 10077    *   S[+units]    retract_length
// 10078    *   W[+units]    swap_retract_length (multi-extruder)
// 10079    *   F[units/min] retract_feedrate_mm_s
// 10080    *   Z[units]     retract_zlift
// 10081    */
// 10082   inline void gcode_M207() {
// 10083     if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
// 10084     if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10085     if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
// 10086     if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
// 10087   }
// 10088 
// 10089   /**
// 10090    * M208: Set firmware un-retraction values
// 10091    *
// 10092    *   S[+units]    retract_recover_length (in addition to M207 S*)
// 10093    *   W[+units]    swap_retract_recover_length (multi-extruder)
// 10094    *   F[units/min] retract_recover_feedrate_mm_s
// 10095    *   R[units/min] swap_retract_recover_feedrate_mm_s
// 10096    */
// 10097   inline void gcode_M208() {
// 10098     if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
// 10099     if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10100     if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
// 10101     if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
// 10102   }
// 10103 
// 10104   /**
// 10105    * M209: Enable automatic retract (M209 S1)
// 10106    *   For slicers that don't support G10/11, reversed extrude-only
// 10107    *   moves will be classified as retraction.
// 10108    */
// 10109   inline void gcode_M209() {
// 10110     if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
// 10111       if (parser.seen('S')) {
// 10112         autoretract_enabled = parser.value_bool();
// 10113         for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
// 10114       }
// 10115     }
// 10116   }
// 10117 
// 10118 #endif // FWRETRACT
// 10119 
// 10120 /**
// 10121  * M211: Enable, Disable, and/or Report software endstops
// 10122  *
// 10123  * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
// 10124  */
// 10125 inline void gcode_M211() {
// 10126   SERIAL_ECHO_START();
// 10127   #if HAS_SOFTWARE_ENDSTOPS
// 10128     if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
// 10129     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 10130     serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
// 10131   #else
// 10132     SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
// 10133     SERIAL_ECHOPGM(MSG_OFF);
// 10134   #endif
// 10135   SERIAL_ECHOPGM(MSG_SOFT_MIN);
// 10136   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_min[X_AXIS]));
// 10137   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_min[Y_AXIS]));
// 10138   SERIAL_ECHOPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_min[Z_AXIS]));
// 10139   SERIAL_ECHOPGM(MSG_SOFT_MAX);
// 10140   SERIAL_ECHOPAIR(    MSG_X, LOGICAL_X_POSITION(soft_endstop_max[X_AXIS]));
// 10141   SERIAL_ECHOPAIR(" " MSG_Y, LOGICAL_Y_POSITION(soft_endstop_max[Y_AXIS]));
// 10142   SERIAL_ECHOLNPAIR(" " MSG_Z, LOGICAL_Z_POSITION(soft_endstop_max[Z_AXIS]));
// 10143 }
// 10144 
// 10145 #if HOTENDS > 1
// 10146 
// 10147   /**
// 10148    * M218 - set hotend offset (in linear units)
// 10149    *
// 10150    *   T<tool>
// 10151    *   X<xoffset>
// 10152    *   Y<yoffset>
// 10153    *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
// 10154    */
// 10155   inline void gcode_M218() {
// 10156     if (get_target_extruder_from_command(218) || target_extruder == 0) return;
// 10157 
// 10158     if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
// 10159     if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
// 10160 
// 10161     #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 10162       if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
// 10163     #endif
// 10164 
// 10165     SERIAL_ECHO_START();
// 10166     SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 10167     HOTEND_LOOP() {
// 10168       SERIAL_CHAR(' ');
// 10169       SERIAL_ECHO(hotend_offset[X_AXIS][e]);
// 10170       SERIAL_CHAR(',');
// 10171       SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
// 10172       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
// 10173         SERIAL_CHAR(',');
// 10174         SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
// 10175       #endif
// 10176     }
// 10177     SERIAL_EOL();
// 10178   }
// 10179 
// 10180 #endif // HOTENDS > 1
// 10181 
// 10182 /**
// 10183  * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
// 10184  */
// 10185 inline void gcode_M220() {
// 10186   if (parser.seenval('S')) feedrate_percentage = parser.value_int();
// 10187 }
// 10188 
// 10189 /**
// 10190  * M221: Set extrusion percentage (M221 T0 S95)
// 10191  */
// 10192 inline void gcode_M221() {
// 10193   if (get_target_extruder_from_command(221)) return;
// 10194   if (parser.seenval('S')) {
// 10195     planner.flow_percentage[target_extruder] = parser.value_int();
// 10196     planner.refresh_e_factor(target_extruder);
// 10197   }
// 10198 }
// 10199 
// 10200 /**
// 10201  * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
// 10202  */
// 10203 inline void gcode_M226() {
// 10204   if (parser.seen('P')) {
// 10205     const int pin_number = parser.value_int(),
// 10206               pin_state = parser.intval('S', -1); // required pin state - default is inverted
// 10207 
// 10208     if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
// 10209 
// 10210       int target = LOW;
// 10211 
// 10212       stepper.synchronize();
// 10213 
// 10214       pinMode(pin_number, INPUT);
// 10215       switch (pin_state) {
// 10216         case 1:
// 10217           target = HIGH;
// 10218           break;
// 10219         case 0:
// 10220           target = LOW;
// 10221           break;
// 10222         case -1:
// 10223           target = !digitalRead(pin_number);
// 10224           break;
// 10225       }
// 10226 
// 10227       while (digitalRead(pin_number) != target) idle();
// 10228 
// 10229     } // pin_state -1 0 1 && pin_number > -1
// 10230   } // parser.seen('P')
// 10231 }
// 10232 
// 10233 #if ENABLED(EXPERIMENTAL_I2CBUS)
// 10234 
// 10235   /**
// 10236    * M260: Send data to a I2C slave device
// 10237    *
// 10238    * This is a PoC, the formating and arguments for the GCODE will
// 10239    * change to be more compatible, the current proposal is:
// 10240    *
// 10241    *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
// 10242    *
// 10243    *  M260 B<byte-1 value in base 10>
// 10244    *  M260 B<byte-2 value in base 10>
// 10245    *  M260 B<byte-3 value in base 10>
// 10246    *
// 10247    *  M260 S1 ; Send the buffered data and reset the buffer
// 10248    *  M260 R1 ; Reset the buffer without sending data
// 10249    *
// 10250    */
// 10251   inline void gcode_M260() {
// 10252     // Set the target address
// 10253     if (parser.seen('A')) i2c.address(parser.value_byte());
// 10254 
// 10255     // Add a new byte to the buffer
// 10256     if (parser.seen('B')) i2c.addbyte(parser.value_byte());
// 10257 
// 10258     // Flush the buffer to the bus
// 10259     if (parser.seen('S')) i2c.send();
// 10260 
// 10261     // Reset and rewind the buffer
// 10262     else if (parser.seen('R')) i2c.reset();
// 10263   }
// 10264 
// 10265   /**
// 10266    * M261: Request X bytes from I2C slave device
// 10267    *
// 10268    * Usage: M261 A<slave device address base 10> B<number of bytes>
// 10269    */
// 10270   inline void gcode_M261() {
// 10271     if (parser.seen('A')) i2c.address(parser.value_byte());
// 10272 
// 10273     uint8_t bytes = parser.byteval('B', 1);
// 10274 
// 10275     if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
// 10276       i2c.relay(bytes);
// 10277     }
// 10278     else {
// 10279       SERIAL_ERROR_START();
// 10280       SERIAL_ERRORLN("Bad i2c request");
// 10281     }
// 10282   }
// 10283 
// 10284 #endif // EXPERIMENTAL_I2CBUS
// 10285 
// 10286 //#if HAS_SERVOS
// 10287 
// 10288   /**
// 10289    * M280: Get or set servo position. P<index> [S<angle>]
// 10290    */
// 10291   inline void gcode_M280() {
// 10292   	int mksAngle;
// 10293   #if defined(MKS_ROBIN2)||defined(MKS_ROBIN_NANO)
// 10294     if (!parser.seen('P')) return;
// 10295     const int servo_index = parser.value_int();
// 10296     if (WITHIN(servo_index, 0, 0/*NUM_SERVOS - 1*/)) {
// 10297     if (parser.seen('S'))
// 10298     //MOVE_SERVO(servo_index, parser.value_int());
// 10299     {
// 10300      switch(parser.value_int())
// 10301     	{
// 10302     	case 10:
// 10303 			mksAngle = 700/2;
// 10304 			break;
// 10305 		case 90:
// 10306 			mksAngle = 1500/2;
// 10307 			break;
// 10308 			case 120:
// 10309 			mksAngle = 1800/2;
// 10310 			break;
// 10311 		case 160:
// 10312 			mksAngle = 2200/2;
// 10313 			break;
// 10314 		case 60:
// 10315 			mksAngle = 1200/2;
// 10316 			break;
// 10317 		default:
// 10318 			mksAngle = 2200/2;
// 10319 			break;
// 10320 			
// 10321     	}
// 10322 		MKS_TOUCH_TIM = mksAngle;
// 10323     }        
// 10324       else {
// 10325         SERIAL_ECHO_START();
// 10326         SERIAL_ECHOPAIR(" Servo ", servo_index);
// 10327 		SERIAL_ECHOLNPGM(" out of range");
// 10328         //SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
// 10329       }
// 10330     }
// 10331     else {
// 10332       SERIAL_ERROR_START();
// 10333       SERIAL_ECHOPAIR("Servo ", servo_index);
// 10334       SERIAL_ECHOLNPGM(" out of range");
// 10335     }
// 10336     #endif
// 10337   }
// 10338 
// 10339 //#endif // HAS_SERVOS
// 10340 
// 10341 #if ENABLED(BABYSTEPPING)
// 10342 
// 10343   #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10344     FORCE_INLINE void mod_zprobe_zoffset(const float &offs) {
// 10345       zprobe_zoffset += offs;
// 10346       SERIAL_ECHO_START();
// 10347       SERIAL_ECHOLNPAIR(MSG_PROBE_Z_OFFSET ": ", zprobe_zoffset);
// 10348     }
// 10349   #endif
// 10350 
// 10351   /**
// 10352    * M290: Babystepping
// 10353    */
// 10354   inline void gcode_M290() {
// 10355     #if ENABLED(BABYSTEP_XY)
// 10356       for (uint8_t a = X_AXIS; a <= Z_AXIS; a++)
// 10357         if (parser.seenval(axis_codes[a]) || (a == Z_AXIS && parser.seenval('S'))) {
// 10358           const float offs = constrain(parser.value_axis_units((AxisEnum)a), -2, 2);
// 10359           thermalManager.babystep_axis((AxisEnum)a, offs * planner.axis_steps_per_mm[a]);
// 10360           #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10361             if (a == Z_AXIS && (!parser.seen('P') || parser.value_bool())) mod_zprobe_zoffset(offs);
// 10362           #endif
// 10363         }
// 10364     #else
// 10365       if (parser.seenval('Z') || parser.seenval('S')) {
// 10366         const float offs = constrain(parser.value_axis_units(Z_AXIS), -2, 2);
// 10367         thermalManager.babystep_axis(Z_AXIS, offs * planner.axis_steps_per_mm[Z_AXIS]);
// 10368         #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
// 10369           if (!parser.seen('P') || parser.value_bool()) mod_zprobe_zoffset(offs);
// 10370         #endif
// 10371       }
// 10372     #endif
// 10373   }
// 10374 
// 10375 #endif // BABYSTEPPING
// 10376 
// 10377 #if HAS_BUZZER
// 10378 
// 10379   /**
// 10380    * M300: Play beep sound S<frequency Hz> P<duration ms>
// 10381    */
// 10382   inline void gcode_M300() {
// 10383     uint16_t const frequency = parser.ushortval('S', 260);
// 10384     uint16_t duration = parser.ushortval('P', 1000);
// 10385 
// 10386     // Limits the tone duration to 0-5 seconds.
// 10387     NOMORE(duration, 5000);
// 10388 
// 10389     BUZZ(duration, frequency);
// 10390   }
// 10391 
// 10392 #endif // HAS_BUZZER
// 10393 
// 10394 #if 1//ENABLED(PIDTEMP)
// 10395 
// 10396   /**
// 10397    * M301: Set PID parameters P I D (and optionally C, L)
// 10398    *
// 10399    *   P[float] Kp term
// 10400    *   I[float] Ki term (unscaled)
// 10401    *   D[float] Kd term (unscaled)
// 10402    *
// 10403    * With PID_EXTRUSION_SCALING:
// 10404    *
// 10405    *   C[float] Kc term
// 10406    *   L[float] LPQ length
// 10407    */
// 10408   inline void gcode_M301() {
// 10409 
// 10410     // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
// 10411     // default behaviour (omitting E parameter) is to update for extruder 0 only
// 10412     const uint8_t e = parser.byteval('E'); // extruder being updated
// 10413 
// 10414     if (e < HOTENDS) { // catch bad input value
// 10415       if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
// 10416       if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
// 10417       if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
// 10418       #if ENABLED(PID_EXTRUSION_SCALING)
// 10419         if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
// 10420         if (parser.seen('L')) lpq_len = parser.value_float();
// 10421         NOMORE(lpq_len, LPQ_MAX_LEN);
// 10422       #endif
// 10423 
// 10424       thermalManager.updatePID();
// 10425       SERIAL_ECHO_START();
// 10426       #if ENABLED(PID_PARAMS_PER_HOTEND)
// 10427         SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
// 10428       #endif // PID_PARAMS_PER_HOTEND
// 10429       SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
// 10430       SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
// 10431       SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
// 10432       #if ENABLED(PID_EXTRUSION_SCALING)
// 10433         //Kc does not have scaling applied above, or in resetting defaults
// 10434         SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
// 10435       #endif
// 10436       SERIAL_EOL();
// 10437     }
// 10438     else {
// 10439       SERIAL_ERROR_START();
// 10440       SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
// 10441     }
// 10442   }
// 10443 
// 10444 #endif // PIDTEMP
// 10445 
// 10446 #if 1//ENABLED(PIDTEMPBED)
// 10447 
// 10448   inline void gcode_M304() {
// 10449     if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
// 10450     if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
// 10451     if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
// 10452 
// 10453     SERIAL_ECHO_START();
// 10454     SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
// 10455     SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
// 10456     SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
// 10457   }
// 10458 
// 10459 #endif // PIDTEMPBED
// 10460 
// 10461 #if defined(CHDK) || HAS_PHOTOGRAPH
// 10462 
// 10463   /**
// 10464    * M240: Trigger a camera by emulating a Canon RC-1
// 10465    *       See http://www.doc-diy.net/photo/rc-1_hacked/
// 10466    */
// 10467   inline void gcode_M240() {
// 10468     #ifdef CHDK
// 10469 
// 10470       OUT_WRITE(CHDK, HIGH);
// 10471       chdkHigh = millis();
// 10472       chdkActive = true;
// 10473 
// 10474     #elif HAS_PHOTOGRAPH
// 10475 
// 10476       const uint8_t NUM_PULSES = 16;
// 10477       const float PULSE_LENGTH = 0.01524;
// 10478       for (int i = 0; i < NUM_PULSES; i++) {
// 10479         WRITE(PHOTOGRAPH_PIN, HIGH);
// 10480         _delay_ms(PULSE_LENGTH);
// 10481         WRITE(PHOTOGRAPH_PIN, LOW);
// 10482         _delay_ms(PULSE_LENGTH);
// 10483       }
// 10484       delay(7.33);
// 10485       for (int i = 0; i < NUM_PULSES; i++) {
// 10486         WRITE(PHOTOGRAPH_PIN, HIGH);
// 10487         _delay_ms(PULSE_LENGTH);
// 10488         WRITE(PHOTOGRAPH_PIN, LOW);
// 10489         _delay_ms(PULSE_LENGTH);
// 10490       }
// 10491 
// 10492     #endif // !CHDK && HAS_PHOTOGRAPH
// 10493   }
// 10494 
// 10495 #endif // CHDK || PHOTOGRAPH_PIN
// 10496 
// 10497 #if HAS_LCD_CONTRAST
// 10498 
// 10499   /**
// 10500    * M250: Read and optionally set the LCD contrast
// 10501    */
// 10502   inline void gcode_M250() {
// 10503     if (parser.seen('C')) set_lcd_contrast(parser.value_int());
// 10504     SERIAL_PROTOCOLPGM("lcd contrast value: ");
// 10505     SERIAL_PROTOCOL(lcd_contrast);
// 10506     SERIAL_EOL();
// 10507   }
// 10508 
// 10509 #endif // HAS_LCD_CONTRAST
// 10510 
// 10511 #if ENABLED(PREVENT_COLD_EXTRUSION)
// 10512 
// 10513   /**
// 10514    * M302: Allow cold extrudes, or set the minimum extrude temperature
// 10515    *
// 10516    *       S<temperature> sets the minimum extrude temperature
// 10517    *       P<bool> enables (1) or disables (0) cold extrusion
// 10518    *
// 10519    *  Examples:
// 10520    *
// 10521    *       M302         ; report current cold extrusion state
// 10522    *       M302 P0      ; enable cold extrusion checking
// 10523    *       M302 P1      ; disables cold extrusion checking
// 10524    *       M302 S0      ; always allow extrusion (disables checking)
// 10525    *       M302 S170    ; only allow extrusion above 170
// 10526    *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
// 10527    */
// 10528   inline void gcode_M302() {
// 10529     const bool seen_S = parser.seen('S');
// 10530     if (seen_S) {
// 10531       thermalManager.extrude_min_temp = parser.value_celsius();
// 10532       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
// 10533     }
// 10534 
// 10535     if (parser.seen('P'))
// 10536       thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
// 10537     else if (!seen_S) {
// 10538       // Report current state
// 10539       SERIAL_ECHO_START();
// 10540       SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
// 10541       SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
// 10542       SERIAL_ECHOLNPGM("C)");
// 10543     }
// 10544   }
// 10545 
// 10546 #endif // PREVENT_COLD_EXTRUSION
// 10547 
// 10548 /**
// 10549  * M303: PID relay autotune
// 10550  *
// 10551  *       S<temperature> sets the target temperature. (default 150C)
// 10552  *       E<extruder> (-1 for the bed) (default 0)
// 10553  *       C<cycles>
// 10554  *       U<bool> with a non-zero value will apply the result to current settings
// 10555  */
// 10556 inline void gcode_M303() {
// 10557   //#if HAS_PID_HEATING
// 10558   if(HAS_PID_HEATING) {
// 10559     const int e = parser.intval('E'), c = parser.intval('C', 5);
// 10560     const bool u = parser.boolval('U');
// 10561 
// 10562     int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
// 10563 
// 10564     if (WITHIN(e, 0, HOTENDS - 1))
// 10565       target_extruder = e;
// 10566 
// 10567     #if DISABLED(BUSY_WHILE_HEATING)
// 10568       KEEPALIVE_STATE(NOT_BUSY);
// 10569     #endif
// 10570 
// 10571     thermalManager.PID_autotune(temp, e, c, u);
// 10572 
// 10573     #if DISABLED(BUSY_WHILE_HEATING)
// 10574       KEEPALIVE_STATE(IN_HANDLER);
// 10575     #endif
// 10576   }
// 10577   //#else
// 10578   else
// 10579   {
// 10580     SERIAL_ERROR_START();
// 10581     SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
// 10582   }
// 10583   //#endif
// 10584 }
// 10585 
// 10586 #if 1//ENABLED(MORGAN_SCARA)
// 10587 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock60 Using cfiCommon0
          CFI Function _Z17SCARA_move_to_calhh
        THUMB
// 10588   bool SCARA_move_to_cal(const uint8_t delta_a, const uint8_t delta_b) {
_Z17SCARA_move_to_calhh:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
// 10589     if (IsRunning()) {
        LDR.N    R5,??DataTable140_18
        MOV      R4,R1
        LDRB     R1,[R5, #+4]
        SUB      SP,SP,#+12
          CFI CFA R13+24
        CBZ.N    R1,??SCARA_move_to_cal_0
// 10590       forward_kinematics_SCARA(delta_a, delta_b);
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+4]
        MOV      R0,R4
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
// 10591       destination[X_AXIS] = cartes[X_AXIS];
        LDR      R0,[R5, #+96]
        STR      R0,[R5, #+32]
// 10592       destination[Y_AXIS] = cartes[Y_AXIS];
        LDR      R0,[R5, #+100]
        STR      R0,[R5, #+36]
// 10593       destination[Z_AXIS] = current_position[Z_AXIS];
        LDR      R0,[R5, #+24]
        STR      R0,[R5, #+40]
// 10594       prepare_move_to_destination();
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
// 10595       return true;
        MOVS     R0,#+1
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}
          CFI CFA R13+24
// 10596     }
// 10597     return false;
??SCARA_move_to_cal_0:
        MOVS     R0,#+0
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock60
// 10598   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable138:
        DC32     _ZN7Planner11last_fade_zE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable138_1:
        DC32     0xc479fff0
// 10599 
// 10600   /**
// 10601    * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
// 10602    */
// 10603   inline bool gcode_M360() {
// 10604     SERIAL_ECHOLNPGM(" Cal: Theta 0");
// 10605     return SCARA_move_to_cal(0, 120);
// 10606   }
// 10607 
// 10608   /**
// 10609    * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
// 10610    */
// 10611   inline bool gcode_M361() {
// 10612     SERIAL_ECHOLNPGM(" Cal: Theta 90");
// 10613     return SCARA_move_to_cal(90, 130);
// 10614   }
// 10615 
// 10616   /**
// 10617    * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
// 10618    */
// 10619   inline bool gcode_M362() {
// 10620     SERIAL_ECHOLNPGM(" Cal: Psi 0");
// 10621     return SCARA_move_to_cal(60, 180);
// 10622   }
// 10623 
// 10624   /**
// 10625    * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
// 10626    */
// 10627   inline bool gcode_M363() {
// 10628     SERIAL_ECHOLNPGM(" Cal: Psi 90");
// 10629     return SCARA_move_to_cal(50, 90);
// 10630   }
// 10631 
// 10632   /**
// 10633    * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
// 10634    */
// 10635   inline bool gcode_M364() {
// 10636     SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
// 10637     return SCARA_move_to_cal(45, 135);
// 10638   }
// 10639 
// 10640 #endif // SCARA
// 10641 
// 10642 #if ENABLED(EXT_SOLENOID)
// 10643 
// 10644   void enable_solenoid(const uint8_t num) {
// 10645     switch (num) {
// 10646       case 0:
// 10647         OUT_WRITE(SOL0_PIN, HIGH);
// 10648         break;
// 10649         #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10650           case 1:
// 10651             OUT_WRITE(SOL1_PIN, HIGH);
// 10652             break;
// 10653         #endif
// 10654         #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10655           case 2:
// 10656             OUT_WRITE(SOL2_PIN, HIGH);
// 10657             break;
// 10658         #endif
// 10659         #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10660           case 3:
// 10661             OUT_WRITE(SOL3_PIN, HIGH);
// 10662             break;
// 10663         #endif
// 10664         #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10665           case 4:
// 10666             OUT_WRITE(SOL4_PIN, HIGH);
// 10667             break;
// 10668         #endif
// 10669       default:
// 10670         SERIAL_ECHO_START();
// 10671         SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
// 10672         break;
// 10673     }
// 10674   }
// 10675 
// 10676   void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
// 10677 
// 10678   void disable_all_solenoids() {
// 10679     OUT_WRITE(SOL0_PIN, LOW);
// 10680     #if HAS_SOLENOID_1 && EXTRUDERS > 1
// 10681       OUT_WRITE(SOL1_PIN, LOW);
// 10682     #endif
// 10683     #if HAS_SOLENOID_2 && EXTRUDERS > 2
// 10684       OUT_WRITE(SOL2_PIN, LOW);
// 10685     #endif
// 10686     #if HAS_SOLENOID_3 && EXTRUDERS > 3
// 10687       OUT_WRITE(SOL3_PIN, LOW);
// 10688     #endif
// 10689     #if HAS_SOLENOID_4 && EXTRUDERS > 4
// 10690       OUT_WRITE(SOL4_PIN, LOW);
// 10691     #endif
// 10692   }
// 10693 
// 10694   /**
// 10695    * M380: Enable solenoid on the active extruder
// 10696    */
// 10697   inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
// 10698 
// 10699   /**
// 10700    * M381: Disable all solenoids
// 10701    */
// 10702   inline void gcode_M381() { disable_all_solenoids(); }
// 10703 
// 10704 #endif // EXT_SOLENOID
// 10705 
// 10706 /**
// 10707  * M400: Finish all moves
// 10708  */
// 10709 inline void gcode_M400() { stepper.synchronize(); }
// 10710 
// 10711 #if HAS_BED_PROBE
// 10712 
// 10713   /**
// 10714    * M401: Engage Z Servo endstop if available
// 10715    */
// 10716   inline void gcode_M401() { DEPLOY_PROBE(); }
// 10717 
// 10718   /**
// 10719    * M402: Retract Z Servo endstop if enabled
// 10720    */
// 10721   inline void gcode_M402() { STOW_PROBE(); }
// 10722 
// 10723 #endif // HAS_BED_PROBE
// 10724 
// 10725 #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 10726 
// 10727   /**
// 10728    * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
// 10729    */
// 10730   inline void gcode_M404() {
// 10731     if (parser.seen('W')) {
// 10732       filament_width_nominal = parser.value_linear_units();
// 10733       planner.volumetric_area_nominal = CIRCLE_AREA(filament_width_nominal * 0.5);
// 10734     }
// 10735     else {
// 10736       SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
// 10737       SERIAL_PROTOCOLLN(filament_width_nominal);
// 10738     }
// 10739   }
// 10740 
// 10741   /**
// 10742    * M405: Turn on filament sensor for control
// 10743    */
// 10744   inline void gcode_M405() {
// 10745     // This is technically a linear measurement, but since it's quantized to centimeters and is a different
// 10746     // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
// 10747     if (parser.seen('D')) {
// 10748       meas_delay_cm = parser.value_byte();
// 10749       NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
// 10750     }
// 10751 
// 10752     if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
// 10753       const int8_t temp_ratio = thermalManager.widthFil_to_size_ratio();
// 10754 
// 10755       for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
// 10756         measurement_delay[i] = temp_ratio;
// 10757 
// 10758       filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
// 10759     }
// 10760 
// 10761     filament_sensor = true;
// 10762   }
// 10763 
// 10764   /**
// 10765    * M406: Turn off filament sensor for control
// 10766    */
// 10767   inline void gcode_M406() {
// 10768     filament_sensor = false;
// 10769     planner.calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
// 10770   }
// 10771 
// 10772   /**
// 10773    * M407: Get measured filament diameter on serial output
// 10774    */
// 10775   inline void gcode_M407() {
// 10776     SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
// 10777     SERIAL_PROTOCOLLN(filament_width_meas);
// 10778   }
// 10779 
// 10780 #endif // FILAMENT_WIDTH_SENSOR
// 10781 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock61 Using cfiCommon0
          CFI Function _Z17quickstop_stepperv
        THUMB
// 10782 void quickstop_stepper() {
_Z17quickstop_stepperv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 10783   stepper.quick_stop();
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
// 10784   stepper.synchronize();
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 10785   set_current_from_steppers_for_axis(ALL_AXES);
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
        LDR.N    R0,??DataTable140
        LDR.N    R4,??DataTable140_18
        LDRB     R0,[R0, #+66]
        MOVS     R1,#+46
        TST      R0,R1
        ITT      NE 
        ADDNE    R0,R4,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
        ADD      R0,R4,#+96
        ADD      R1,R4,#+16
        LDM      R0!,{R2-R4}
        STM      R1!,{R2-R4}
// 10786   SYNC_PLAN_POSITION_KINEMATIC();
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.W      _Z28SYNC_PLAN_POSITION_KINEMATICv
          CFI EndBlock cfiBlock61
// 10787 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139:
        DC8      0x58, 0x3A, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_1:
        DC8      " Y:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_2:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_3:
        DC8      " Z:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_4:
        DC8      " E:"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_5:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_6:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_7:
        DC8      ":",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable139_8:
        DC32     _ZN17mesh_bed_leveling8z_valuesE
// 10788 
// 10789 #if 1//HAS_LEVELING
// 10790   /**
// 10791    * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
// 10792    *
// 10793    *   S[bool]   Turns leveling on or off
// 10794    *   Z[height] Sets the Z fade height (0 or none to disable)
// 10795    *   V[bool]   Verbose - Print the leveling grid
// 10796    *
// 10797    * With AUTO_BED_LEVELING_UBL only:
// 10798    *
// 10799    *   L[index]  Load UBL mesh from index (0 is default)
// 10800    */
// 10801   inline void gcode_M420() {
// 10802 
// 10803     const float oldpos[] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
// 10804 
// 10805     //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 10806 	if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)	
// 10807 	{
// 10808       // L to load a mesh from the EEPROM
// 10809       if (parser.seen('L')) {
// 10810 
// 10811         #if ENABLED(EEPROM_SETTINGS)
// 10812           const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.storage_slot;
// 10813           const int16_t a = settings.calc_num_meshes();
// 10814 
// 10815           if (!a) {
// 10816             SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10817             return;
// 10818           }
// 10819 
// 10820           if (!WITHIN(storage_slot, 0, a - 1)) {
// 10821             SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
// 10822             SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
// 10823             return;
// 10824           }
// 10825 
// 10826           settings.load_mesh(storage_slot);
// 10827           ubl.storage_slot = storage_slot;
// 10828 
// 10829         #else
// 10830 
// 10831           SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
// 10832           return;
// 10833 
// 10834         #endif
// 10835       }
// 10836 
// 10837       // L to load a mesh from the EEPROM
// 10838       if (parser.seen('L') || parser.seen('V')) {
// 10839         ubl.display_map(0);  // Currently only supports one map type
// 10840         SERIAL_ECHOLNPAIR("ubl.mesh_is_valid = ", ubl.mesh_is_valid());
// 10841         SERIAL_ECHOLNPAIR("ubl.storage_slot = ", ubl.storage_slot);
// 10842       }
// 10843 	}
// 10844     //#endif // AUTO_BED_LEVELING_UBL
// 10845 
// 10846     // V to print the matrix or mesh
// 10847     if (parser.seen('V')) {
// 10848       //#if ABL_PLANAR
// 10849       if(BED_LEVELING_METHOD&ABL_PLANAR)
// 10850         planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
// 10851 	  else
// 10852 	  {
// 10853       //#else
// 10854         if (leveling_is_valid()) {
// 10855           //#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10856           if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 10857           {
// 10858             print_bilinear_leveling_grid();
// 10859             #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10860               print_bilinear_leveling_grid_virt();
// 10861             #endif
// 10862           }
// 10863          //#elif ENABLED(MESH_BED_LEVELING)
// 10864          else if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 10865          {
// 10866             SERIAL_ECHOLNPGM("Mesh Bed Level data:");
// 10867             mbl_mesh_report();
// 10868          }
// 10869          // #endif
// 10870         }
// 10871 	  }
// 10872       //#endif
// 10873     }
// 10874 
// 10875     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10876 	if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
// 10877 	{
// 10878       if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units(), false);
// 10879 	}
// 10880     #endif
// 10881 
// 10882     bool to_enable = false;
// 10883     if (parser.seen('S')) {
// 10884       to_enable = parser.value_bool();
// 10885       set_bed_leveling_enabled(to_enable);
// 10886     }
// 10887 
// 10888     const bool new_status = planner.leveling_active;
// 10889 
// 10890     if (to_enable && !new_status) {
// 10891       SERIAL_ERROR_START();
// 10892       SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
// 10893     }
// 10894 
// 10895     SERIAL_ECHO_START();
// 10896     SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
// 10897 
// 10898     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 10899       SERIAL_ECHO_START();
// 10900       SERIAL_ECHOPGM("Fade Height ");
// 10901       if (planner.z_fade_height > 0.0)
// 10902         SERIAL_ECHOLN(planner.z_fade_height);
// 10903       else
// 10904         SERIAL_ECHOLNPGM(MSG_OFF);
// 10905     #endif
// 10906 
// 10907     // Report change in position
// 10908     if (memcmp(oldpos, current_position, sizeof(oldpos)))
// 10909       report_current_position();
// 10910   }
// 10911 #endif
// 10912 
// 10913 #if 1//ENABLED(MESH_BED_LEVELING)
// 10914 
// 10915   /**
// 10916    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10917    *
// 10918    * Usage:
// 10919    *   M421 X<linear> Y<linear> Z<linear>
// 10920    *   M421 X<linear> Y<linear> Q<offset>
// 10921    *   M421 I<xindex> J<yindex> Z<linear>
// 10922    *   M421 I<xindex> J<yindex> Q<offset>
// 10923    */
// 10924   inline void gcode_M421_MESH_BED_LEVELING() {
// 10925     const bool hasX = parser.seen('X'), hasI = parser.seen('I');
// 10926     const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(parser.value_linear_units()) : -1;
// 10927     const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
// 10928     const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(parser.value_linear_units()) : -1;
// 10929     const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
// 10930 
// 10931     if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
// 10932       SERIAL_ERROR_START();
// 10933       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10934     }
// 10935     else if (ix < 0 || iy < 0) {
// 10936       SERIAL_ERROR_START();
// 10937       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10938     }
// 10939     else
// 10940       mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
// 10941   }
// 10942 #endif
// 10943 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 10944 
// 10945   /**
// 10946    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10947    *
// 10948    * Usage:
// 10949    *   M421 I<xindex> J<yindex> Z<linear>
// 10950    *   M421 I<xindex> J<yindex> Q<offset>
// 10951    */
// 10952   inline void gcode_M421_AUTO_BED_LEVELING_BILINEAR() {
// 10953     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10954     const bool hasI = ix >= 0,
// 10955                hasJ = iy >= 0,
// 10956                hasZ = parser.seen('Z'),
// 10957                hasQ = !hasZ && parser.seen('Q');
// 10958 
// 10959     if (!hasI || !hasJ || !(hasZ || hasQ)) {
// 10960       SERIAL_ERROR_START();
// 10961       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 10962     }
// 10963     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 10964       SERIAL_ERROR_START();
// 10965       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 10966     }
// 10967     else {
// 10968       z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
// 10969       #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 10970         bed_level_virt_interpolate();
// 10971       #endif
// 10972     }
// 10973   }
// 10974 #endif
// 10975 #if 1//ENABLED(AUTO_BED_LEVELING_UBL)
// 10976 
// 10977   /**
// 10978    * M421: Set a single Mesh Bed Leveling Z coordinate
// 10979    *
// 10980    * Usage:
// 10981    *   M421 I<xindex> J<yindex> Z<linear>
// 10982    *   M421 I<xindex> J<yindex> Q<offset>
// 10983    *   M421 C Z<linear>
// 10984    *   M421 C Q<offset>
// 10985    */
// 10986   inline void gcode_M421_AUTO_BED_LEVELING_UBL() {
// 10987     int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
// 10988     const bool hasI = ix >= 0,
// 10989                hasJ = iy >= 0,
// 10990                hasC = parser.seen('C'),
// 10991                hasZ = parser.seen('Z'),
// 10992                hasQ = !hasZ && parser.seen('Q');
// 10993 
// 10994     if (hasC) {
// 10995       const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL);
// 10996       ix = location.x_index;
// 10997       iy = location.y_index;
// 10998     }
// 10999 
// 11000     if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
// 11001       SERIAL_ERROR_START();
// 11002       SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
// 11003     }
// 11004     else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
// 11005       SERIAL_ERROR_START();
// 11006       SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
// 11007     }
// 11008     else
// 11009       ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
// 11010   }
// 11011 
// 11012 #endif // AUTO_BED_LEVELING_UBL
// 11013 
// 11014 #if 1//HAS_M206_COMMAND
// 11015 
// 11016   /**
// 11017    * M428: Set home_offset based on the distance between the
// 11018    *       current_position and the nearest "reference point."
// 11019    *       If an axis is past center its endstop position
// 11020    *       is the reference-point. Otherwise it uses 0. This allows
// 11021    *       the Z offset to be set near the bed when using a max endstop.
// 11022    *
// 11023    *       M428 can't be used more than 2cm away from 0 or an endstop.
// 11024    *
// 11025    *       Use M206 to set these values directly.
// 11026    */
// 11027   inline void gcode_M428() {
// 11028   
// 11029   	if(MACHINETPYE == DELTA) return;
// 11030 	
// 11031     if (axis_unhomed_error()) return;
// 11032 
// 11033     float diff[XYZ];
// 11034     LOOP_XYZ(i) {
// 11035       diff[i] = base_home_pos((AxisEnum)i) - current_position[i];
// 11036       if (!WITHIN(diff[i], -20, 20) && home_dir((AxisEnum)i) > 0)
// 11037         diff[i] = -current_position[i];
// 11038       if (!WITHIN(diff[i], -20, 20)) {
// 11039         SERIAL_ERROR_START();
// 11040         SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
// 11041         LCD_ALERTMESSAGEPGM("Err: Too far!");
// 11042         BUZZ(200, 40);
// 11043         return;
// 11044       }
// 11045     }
// 11046 
// 11047     LOOP_XYZ(i) set_home_offset((AxisEnum)i, diff[i]);
// 11048     report_current_position();
// 11049     LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
// 11050     BUZZ(100, 659);
// 11051     BUZZ(100, 698);
// 11052   }
// 11053 
// 11054 #endif // HAS_M206_COMMAND
// 11055 
// 11056 /**
// 11057  * M500: Store settings in EEPROM
// 11058  */
// 11059 inline void gcode_M500() {
// 11060   (void)settings.save();
// 11061 }
// 11062 
// 11063 /**
// 11064  * M501: Read settings from EEPROM
// 11065  */
// 11066 inline void gcode_M501() {
// 11067   (void)settings.load();
// 11068 }
// 11069 
// 11070 /**
// 11071  * M502: Revert to default settings
// 11072  */
// 11073 inline void gcode_M502() {
// 11074   (void)settings.reset();
// 11075 }
// 11076 
// 11077 #if DISABLED(DISABLE_M503)
// 11078   /**
// 11079    * M503: print settings currently in memory
// 11080    */
// 11081   inline void gcode_M503() {
// 11082     (void)settings.report(parser.seen('S') && !parser.value_bool());
// 11083   }
// 11084 #endif
// 11085 
// 11086 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 11087 
// 11088   /**
// 11089    * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
// 11090    */
// 11091   inline void gcode_M540() {
// 11092     if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
// 11093   }
// 11094 
// 11095 #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
// 11096 
// 11097 #if HAS_BED_PROBE
// 11098 
// 11099   inline void gcode_M851() {
// 11100     SERIAL_ECHO_START();
// 11101     SERIAL_ECHOPGM(MSG_PROBE_Z_OFFSET);
// 11102     if (parser.seen('Z')) {
// 11103       const float value = parser.value_linear_units();
// 11104       if (!WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
// 11105         SERIAL_ECHOLNPGM(" " MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
// 11106         return;
// 11107       }
// 11108       zprobe_zoffset = value;
// 11109     }
// 11110     SERIAL_ECHOLNPAIR(": ", zprobe_zoffset);
// 11111   }
// 11112 
// 11113 #endif // HAS_BED_PROBE
// 11114 
// 11115 #if ENABLED(SKEW_CORRECTION_GCODE)
// 11116 
// 11117   /**
// 11118    * M852: Get or set the machine skew factors. Reports current values with no arguments.
// 11119    *
// 11120    *  S[xy_factor] - Alias for 'I'
// 11121    *  I[xy_factor] - New XY skew factor
// 11122    *  J[xz_factor] - New XZ skew factor
// 11123    *  K[yz_factor] - New YZ skew factor
// 11124    */
// 11125   inline void gcode_M852() {
// 11126     uint8_t ijk = 0, badval = 0, setval = 0;
// 11127 
// 11128     if (parser.seen('I') || parser.seen('S')) {
// 11129       ++ijk;
// 11130       const float value = parser.value_linear_units();
// 11131       if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11132         if (planner.xy_skew_factor != value) {
// 11133           planner.xy_skew_factor = value;
// 11134           ++setval;
// 11135         }
// 11136       }
// 11137       else
// 11138         ++badval;
// 11139     }
// 11140 
// 11141     #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 11142 
// 11143       if (parser.seen('J')) {
// 11144         ++ijk;
// 11145         const float value = parser.value_linear_units();
// 11146         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11147           if (planner.xz_skew_factor != value) {
// 11148             planner.xz_skew_factor = value;
// 11149             ++setval;
// 11150           }
// 11151         }
// 11152         else
// 11153           ++badval;
// 11154       }
// 11155 
// 11156       if (parser.seen('K')) {
// 11157         ++ijk;
// 11158         const float value = parser.value_linear_units();
// 11159         if (WITHIN(value, SKEW_FACTOR_MIN, SKEW_FACTOR_MAX)) {
// 11160           if (planner.yz_skew_factor != value) {
// 11161             planner.yz_skew_factor = value;
// 11162             ++setval;
// 11163           }
// 11164         }
// 11165         else
// 11166           ++badval;
// 11167       }
// 11168 
// 11169     #endif
// 11170 
// 11171     if (badval)
// 11172       SERIAL_ECHOLNPGM(MSG_SKEW_MIN " " STRINGIFY(SKEW_FACTOR_MIN) " " MSG_SKEW_MAX " " STRINGIFY(SKEW_FACTOR_MAX));
// 11173 
// 11174     // When skew is changed the current position changes
// 11175     if (setval) {
// 11176       set_current_from_steppers_for_axis(ALL_AXES);
// 11177       SYNC_PLAN_POSITION_KINEMATIC();
// 11178       report_current_position();
// 11179     }
// 11180 
// 11181     if (!ijk) {
// 11182       SERIAL_ECHO_START();
// 11183       SERIAL_ECHOPAIR(MSG_SKEW_FACTOR " XY: ", planner.xy_skew_factor);
// 11184       #if ENABLED(SKEW_CORRECTION_FOR_Z)
// 11185         SERIAL_ECHOPAIR(" XZ: ", planner.xz_skew_factor);
// 11186         SERIAL_ECHOLNPAIR(" YZ: ", planner.yz_skew_factor);
// 11187       #else
// 11188         SERIAL_EOL();
// 11189       #endif
// 11190     }
// 11191   }
// 11192 
// 11193 #endif // SKEW_CORRECTION_GCODE
// 11194 
// 11195 #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 11196 
// 11197   /**
// 11198    * M600: Pause for filament change
// 11199    *
// 11200    *  E[distance] - Retract the filament this far (negative value)
// 11201    *  Z[distance] - Move the Z axis by this distance
// 11202    *  X[position] - Move to this X position, with Y
// 11203    *  Y[position] - Move to this Y position, with X
// 11204    *  U[distance] - Retract distance for removal (negative value) (manual reload)
// 11205    *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
// 11206    *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
// 11207    *
// 11208    *  Default values are used for omitted arguments.
// 11209    *
// 11210    */
// 11211   inline void gcode_M600() {
// 11212     point_t park_point = NOZZLE_PARK_POINT;
// 11213 
// 11214     #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
// 11215       // Don't allow filament change without homing first
// 11216       if (axis_unhomed_error()) home_all_axes();
// 11217     #endif
// 11218 
// 11219     // Initial retract before move to filament change position
// 11220     const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
// 11221       #ifdef PAUSE_PARK_RETRACT_LENGTH
// 11222         - (PAUSE_PARK_RETRACT_LENGTH)
// 11223       #endif
// 11224     ;
// 11225 
// 11226     // Lift Z axis
// 11227     if (parser.seenval('Z'))
// 11228       park_point.z = parser.linearval('Z');
// 11229 
// 11230     // Move XY axes to filament change position or given position
// 11231     if (parser.seenval('X'))
// 11232       park_point.x = parser.linearval('X');
// 11233 
// 11234     if (parser.seenval('Y'))
// 11235       park_point.y = parser.linearval('Y');
// 11236 
// 11237     #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
// 11238       park_point.x += (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0);
// 11239       park_point.y += (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0);
// 11240     #endif
// 11241 
// 11242     // Unload filament
// 11243     const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
// 11244       #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
// 11245         - (FILAMENT_CHANGE_UNLOAD_LENGTH)
// 11246       #endif
// 11247     ;
// 11248 
// 11249     // Load filament
// 11250     const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
// 11251       #ifdef FILAMENT_CHANGE_LOAD_LENGTH
// 11252         + FILAMENT_CHANGE_LOAD_LENGTH
// 11253       #endif
// 11254     ;
// 11255 
// 11256     const int beep_count = parser.intval('B',
// 11257       #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 11258         FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
// 11259       #else
// 11260         -1
// 11261       #endif
// 11262     );
// 11263 
// 11264     const bool job_running = print_job_timer.isRunning();
// 11265 
// 11266     if (pause_print(retract, park_point, unload_length, beep_count, true)) {
// 11267       wait_for_filament_reload(beep_count);
// 11268       resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
// 11269     }
// 11270 
// 11271     // Resume the print job timer if it was running
// 11272     if (job_running) print_job_timer.start();
// 11273   }
// 11274 
// 11275 #endif // ADVANCED_PAUSE_FEATURE
// 11276 
// 11277 #if ENABLED(MK2_MULTIPLEXER)
// 11278 
// 11279   inline void select_multiplexed_stepper(const uint8_t e) {
// 11280     stepper.synchronize();
// 11281     disable_e_steppers();
// 11282     WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 11283     WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 11284     WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
// 11285     safe_delay(100);
// 11286   }
// 11287 
// 11288   /**
// 11289    * M702: Unload all extruders
// 11290    */
// 11291   inline void gcode_M702() {
// 11292     for (uint8_t s = 0; s < E_STEPPERS; s++) {
// 11293       select_multiplexed_stepper(e);
// 11294       // TODO: standard unload filament function
// 11295       // MK2 firmware behavior:
// 11296       //  - Make sure temperature is high enough
// 11297       //  - Raise Z to at least 15 to make room
// 11298       //  - Extrude 1cm of filament in 1 second
// 11299       //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
// 11300       //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
// 11301       //  - Restore E max feedrate to 50
// 11302     }
// 11303     // Go back to the last active extruder
// 11304     select_multiplexed_stepper(active_extruder);
// 11305     disable_e_steppers();
// 11306   }
// 11307 
// 11308 #endif // MK2_MULTIPLEXER
// 11309 
// 11310 #if ENABLED(DUAL_X_CARRIAGE)
// 11311 
// 11312   /**
// 11313    * M605: Set dual x-carriage movement mode
// 11314    *
// 11315    *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
// 11316    *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
// 11317    *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
// 11318    *                         units x-offset and an optional differential hotend temperature of
// 11319    *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
// 11320    *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
// 11321    *
// 11322    *    Note: the X axis should be homed after changing dual x-carriage mode.
// 11323    */
// 11324   inline void gcode_M605() {
// 11325     stepper.synchronize();
// 11326     if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
// 11327     switch (dual_x_carriage_mode) {
// 11328       case DXC_FULL_CONTROL_MODE:
// 11329       case DXC_AUTO_PARK_MODE:
// 11330         break;
// 11331       case DXC_DUPLICATION_MODE:
// 11332         if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
// 11333         if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
// 11334         SERIAL_ECHO_START();
// 11335         SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
// 11336         SERIAL_CHAR(' ');
// 11337         SERIAL_ECHO(hotend_offset[X_AXIS][0]);
// 11338         SERIAL_CHAR(',');
// 11339         SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
// 11340         SERIAL_CHAR(' ');
// 11341         SERIAL_ECHO(duplicate_extruder_x_offset);
// 11342         SERIAL_CHAR(',');
// 11343         SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
// 11344         break;
// 11345       default:
// 11346         dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
// 11347         break;
// 11348     }
// 11349     active_extruder_parked = false;
// 11350     extruder_duplication_enabled = false;
// 11351     delayed_move_time = 0;
// 11352   }
// 11353 
// 11354 #elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 11355 
// 11356   inline void gcode_M605() {
// 11357     stepper.synchronize();
// 11358     extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
// 11359     SERIAL_ECHO_START();
// 11360     SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
// 11361   }
// 11362 
// 11363 #endif // DUAL_NOZZLE_DUPLICATION_MODE
// 11364 
// 11365 #if ENABLED(LIN_ADVANCE)
// 11366   /**
// 11367    * M900: Set and/or Get advance K factor and WH/D ratio
// 11368    *
// 11369    *  K<factor>                  Set advance K factor
// 11370    *  R<ratio>                   Set ratio directly (overrides WH/D)
// 11371    *  W<width> H<height> D<diam> Set ratio from WH/D
// 11372    */
// 11373   inline void gcode_M900() {
// 11374     stepper.synchronize();
// 11375 
// 11376     const float newK = parser.floatval('K', -1);
// 11377     if (newK >= 0) planner.extruder_advance_k = newK;
// 11378 
// 11379     float newR = parser.floatval('R', -1);
// 11380     if (newR < 0) {
// 11381       const float newD = parser.floatval('D', -1),
// 11382                   newW = parser.floatval('W', -1),
// 11383                   newH = parser.floatval('H', -1);
// 11384       if (newD >= 0 && newW >= 0 && newH >= 0)
// 11385         newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
// 11386     }
// 11387     if (newR >= 0) planner.advance_ed_ratio = newR;
// 11388 
// 11389     SERIAL_ECHO_START();
// 11390     SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
// 11391     SERIAL_ECHOPGM(" E/D=");
// 11392     const float ratio = planner.advance_ed_ratio;
// 11393     if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
// 11394     SERIAL_EOL();
// 11395   }
// 11396 #endif // LIN_ADVANCE
// 11397 
// 11398 #if HAS_TRINAMIC
// 11399   static bool report_tmc_status = false;
// 11400   const char extended_axis_codes[11][3] = { "X", "X2", "Y", "Y2", "Z", "Z2", "E0", "E1", "E2", "E3", "E4" };
// 11401   enum TMC_AxisEnum {
// 11402     TMC_X,
// 11403     TMC_X2,
// 11404     TMC_Y,
// 11405     TMC_Y2,
// 11406     TMC_Z,
// 11407     TMC_Z2,
// 11408     TMC_E0,
// 11409     TMC_E1,
// 11410     TMC_E2,
// 11411     TMC_E3,
// 11412     TMC_E4
// 11413   };
// 11414   #if ENABLED(TMC_DEBUG)
// 11415     enum TMC_debug_enum {
// 11416       TMC_CODES,
// 11417       TMC_ENABLED,
// 11418       TMC_CURRENT,
// 11419       TMC_RMS_CURRENT,
// 11420       TMC_MAX_CURRENT,
// 11421       TMC_IRUN,
// 11422       TMC_IHOLD,
// 11423       TMC_CS_ACTUAL,
// 11424       TMC_PWM_SCALE,
// 11425       TMC_VSENSE,
// 11426       TMC_STEALTHCHOP,
// 11427       TMC_MICROSTEPS,
// 11428       TMC_TSTEP,
// 11429       TMC_TPWMTHRS,
// 11430       TMC_TPWMTHRS_MMS,
// 11431       TMC_OTPW,
// 11432       TMC_OTPW_TRIGGERED,
// 11433       TMC_TOFF,
// 11434       TMC_TBL,
// 11435       TMC_HEND,
// 11436       TMC_HSTRT,
// 11437       TMC_SGT
// 11438     };
// 11439     enum TMC_drv_status_enum {
// 11440       TMC_DRV_CODES,
// 11441       TMC_STST,
// 11442       TMC_OLB,
// 11443       TMC_OLA,
// 11444       TMC_S2GB,
// 11445       TMC_S2GA,
// 11446       TMC_DRV_OTPW,
// 11447       TMC_OT,
// 11448       TMC_STALLGUARD,
// 11449       TMC_DRV_CS_ACTUAL,
// 11450       TMC_FSACTIVE,
// 11451       TMC_SG_RESULT,
// 11452       TMC_DRV_STATUS_HEX,
// 11453       TMC_T157,
// 11454       TMC_T150,
// 11455       TMC_T143,
// 11456       TMC_T120,
// 11457       TMC_STEALTH,
// 11458       TMC_S2VSB,
// 11459       TMC_S2VSA
// 11460     };
// 11461     static void drv_status_print_hex(const char name[], const uint32_t drv_status) {
// 11462       SERIAL_ECHO(name);
// 11463       SERIAL_ECHOPGM(" = 0x");
// 11464       for(int B=24; B>=8; B-=8){
// 11465         MYSERIAL.print((drv_status>>(B+4))&0xF, HEX);
// 11466         MYSERIAL.print((drv_status>>B)&0xF, HEX);
// 11467         MYSERIAL.print(':');
// 11468       }
// 11469       MYSERIAL.print((drv_status>>4)&0xF, HEX);
// 11470       MYSERIAL.print((drv_status)&0xF, HEX);
// 11471       SERIAL_EOL();
// 11472     }
// 11473 
// 11474     #if ENABLED(HAVE_TMC2130)
// 11475       static void tmc_status(TMC2130Stepper &st, const TMC_debug_enum i) {
// 11476         switch(i) {
// 11477           case TMC_PWM_SCALE: MYSERIAL.print(st.PWM_SCALE(), DEC); break;
// 11478           case TMC_TSTEP: SERIAL_ECHO(st.TSTEP()); break;
// 11479           case TMC_SGT: MYSERIAL.print(st.sgt(), DEC); break;
// 11480           case TMC_STEALTHCHOP: serialprintPGM(st.stealthChop() ? PSTR("true") : PSTR("false")); break;
// 11481           default: break;
// 11482         }
// 11483       }
// 11484       static void tmc_parse_drv_status(TMC2130Stepper &st, const TMC_drv_status_enum i) {
// 11485         switch(i) {
// 11486           case TMC_STALLGUARD: if (st.stallguard()) SERIAL_ECHOPGM("X"); break;
// 11487           case TMC_SG_RESULT:  MYSERIAL.print(st.sg_result(), DEC);      break;
// 11488           case TMC_FSACTIVE:   if (st.fsactive())   SERIAL_ECHOPGM("X"); break;
// 11489           default: break;
// 11490         }
// 11491       }
// 11492     #endif
// 11493     #if ENABLED(HAVE_TMC2208)
// 11494       static void tmc_status(TMC2208Stepper &st, const TMC_debug_enum i) {
// 11495         switch(i) {
// 11496           case TMC_TSTEP:
// 11497             {
// 11498               uint32_t data = 0;
// 11499               st.TSTEP(&data);
// 11500               MYSERIAL.print(data);
// 11501               break;
// 11502             }
// 11503           case TMC_PWM_SCALE: MYSERIAL.print(st.pwm_scale_sum(), DEC); break;
// 11504           case TMC_STEALTHCHOP: serialprintPGM(st.stealth() ? PSTR("true") : PSTR("false")); break;
// 11505           case TMC_S2VSA: if (st.s2vsa()) SERIAL_ECHOPGM("X"); break;
// 11506           case TMC_S2VSB: if (st.s2vsb()) SERIAL_ECHOPGM("X"); break;
// 11507           default: break;
// 11508         }
// 11509       }
// 11510       static void tmc_parse_drv_status(TMC2208Stepper &st, const TMC_drv_status_enum i) {
// 11511         switch(i) {
// 11512           case TMC_T157: if (st.t157()) SERIAL_ECHOPGM("X"); break;
// 11513           case TMC_T150: if (st.t150()) SERIAL_ECHOPGM("X"); break;
// 11514           case TMC_T143: if (st.t143()) SERIAL_ECHOPGM("X"); break;
// 11515           case TMC_T120: if (st.t120()) SERIAL_ECHOPGM("X"); break;
// 11516           default: break;
// 11517         }
// 11518       }
// 11519     #endif
// 11520     template <typename TMC>
// 11521     static void tmc_status(TMC &st, TMC_AxisEnum axis, const TMC_debug_enum i, const float spmm) {
// 11522       SERIAL_ECHO('\t');
// 11523       switch(i) {
// 11524         case TMC_CODES: SERIAL_ECHO(extended_axis_codes[axis]); break;
// 11525         case TMC_ENABLED: serialprintPGM(st.isEnabled() ? PSTR("true") : PSTR("false")); break;
// 11526         case TMC_CURRENT: SERIAL_ECHO(st.getCurrent()); break;
// 11527         case TMC_RMS_CURRENT: MYSERIAL.print(st.rms_current()); break;
// 11528         case TMC_MAX_CURRENT: MYSERIAL.print((float)st.rms_current()*1.41, 0); break;
// 11529         case TMC_IRUN:
// 11530           MYSERIAL.print(st.irun(), DEC);
// 11531           SERIAL_ECHOPGM("/31");
// 11532           break;
// 11533         case TMC_IHOLD:
// 11534           MYSERIAL.print(st.ihold(), DEC);
// 11535           SERIAL_ECHOPGM("/31");
// 11536           break;
// 11537         case TMC_CS_ACTUAL:
// 11538           MYSERIAL.print(st.cs_actual(), DEC);
// 11539           SERIAL_ECHOPGM("/31");
// 11540           break;
// 11541 
// 11542         case TMC_VSENSE: serialprintPGM(st.vsense() ? PSTR("1=.18") : PSTR("0=.325")); break;
// 11543 
// 11544         case TMC_MICROSTEPS: SERIAL_ECHO(st.microsteps()); break;
// 11545         case TMC_TPWMTHRS:
// 11546           {
// 11547             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 11548             SERIAL_ECHO(tpwmthrs_val);
// 11549           }
// 11550           break;
// 11551         case TMC_TPWMTHRS_MMS:
// 11552           {
// 11553             uint32_t tpwmthrs_val = st.TPWMTHRS();
// 11554             tpwmthrs_val ? SERIAL_ECHO(12650000UL * st.microsteps() / (256 * tpwmthrs_val * spmm)) : SERIAL_ECHO('-');
// 11555           }
// 11556           break;
// 11557         case TMC_OTPW: serialprintPGM(st.otpw() ? PSTR("true") : PSTR("false")); break;
// 11558         case TMC_OTPW_TRIGGERED: serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false")); break;
// 11559         case TMC_TOFF: MYSERIAL.print(st.toff(), DEC); break;
// 11560         case TMC_TBL: MYSERIAL.print(st.blank_time(), DEC); break;
// 11561         case TMC_HEND: MYSERIAL.print(st.hysterisis_end(), DEC); break;
// 11562         case TMC_HSTRT: MYSERIAL.print(st.hysterisis_start(), DEC); break;
// 11563         default: tmc_status(st, i); break;
// 11564       }
// 11565     }
// 11566     template <typename TMC>
// 11567     static void tmc_parse_drv_status(TMC &st, TMC_AxisEnum axis, const TMC_drv_status_enum i) {
// 11568       SERIAL_ECHOPGM("\t");
// 11569       switch(i) {
// 11570         case TMC_DRV_CODES:     SERIAL_ECHO(extended_axis_codes[axis]);  break;
// 11571         case TMC_STST:          if (st.stst())         SERIAL_ECHOPGM("X"); break;
// 11572         case TMC_OLB:           if (st.olb())          SERIAL_ECHOPGM("X"); break;
// 11573         case TMC_OLA:           if (st.ola())          SERIAL_ECHOPGM("X"); break;
// 11574         case TMC_S2GB:          if (st.s2gb())         SERIAL_ECHOPGM("X"); break;
// 11575         case TMC_S2GA:          if (st.s2ga())         SERIAL_ECHOPGM("X"); break;
// 11576         case TMC_DRV_OTPW:      if (st.otpw())         SERIAL_ECHOPGM("X"); break;
// 11577         case TMC_OT:            if (st.ot())           SERIAL_ECHOPGM("X"); break;
// 11578         case TMC_DRV_CS_ACTUAL: MYSERIAL.print(st.cs_actual(), DEC);        break;
// 11579         case TMC_DRV_STATUS_HEX:drv_status_print_hex(extended_axis_codes[axis], st.DRV_STATUS()); break;
// 11580         default: tmc_parse_drv_status(st, i); break;
// 11581       }
// 11582     }
// 11583 
// 11584     static void tmc_debug_loop(const TMC_debug_enum i) {
// 11585       #if X_IS_TRINAMIC
// 11586         tmc_status(stepperX, TMC_X, i, planner.axis_steps_per_mm[X_AXIS]);
// 11587       #endif
// 11588       #if X2_IS_TRINAMIC
// 11589         tmc_status(stepperX2, TMC_X2, i, planner.axis_steps_per_mm[X_AXIS]);
// 11590       #endif
// 11591 
// 11592       #if Y_IS_TRINAMIC
// 11593         tmc_status(stepperY, TMC_Y, i, planner.axis_steps_per_mm[Y_AXIS]);
// 11594       #endif
// 11595       #if Y2_IS_TRINAMIC
// 11596         tmc_status(stepperY2, TMC_Y2, i, planner.axis_steps_per_mm[Y_AXIS]);
// 11597       #endif
// 11598 
// 11599       #if Z_IS_TRINAMIC
// 11600         tmc_status(stepperZ, TMC_Z, i, planner.axis_steps_per_mm[Z_AXIS]);
// 11601       #endif
// 11602       #if Z2_IS_TRINAMIC
// 11603         tmc_status(stepperZ2, TMC_Z2, i, planner.axis_steps_per_mm[Z_AXIS]);
// 11604       #endif
// 11605 
// 11606       #if E0_IS_TRINAMIC
// 11607         tmc_status(stepperE0, TMC_E0, i, planner.axis_steps_per_mm[E_AXIS]);
// 11608       #endif
// 11609       #if E1_IS_TRINAMIC
// 11610         tmc_status(stepperE1, TMC_E1, i, planner.axis_steps_per_mm[E_AXIS+1]);
// 11611       #endif
// 11612       #if E2_IS_TRINAMIC
// 11613         tmc_status(stepperE2, TMC_E2, i, planner.axis_steps_per_mm[E_AXIS+2]);
// 11614       #endif
// 11615       #if E3_IS_TRINAMIC
// 11616         tmc_status(stepperE3, TMC_E3, i, planner.axis_steps_per_mm[E_AXIS+3]);
// 11617       #endif
// 11618       #if E4_IS_TRINAMIC
// 11619         tmc_status(stepperE4, TMC_E4, i, planner.axis_steps_per_mm[E_AXIS+4]);
// 11620       #endif
// 11621 
// 11622       SERIAL_EOL();
// 11623     }
// 11624 
// 11625     static void drv_status_loop(const TMC_drv_status_enum i) {
// 11626       #if X_IS_TRINAMIC
// 11627         tmc_parse_drv_status(stepperX, TMC_X, i);
// 11628       #endif
// 11629       #if X2_IS_TRINAMIC
// 11630         tmc_parse_drv_status(stepperX2, TMC_X2, i);
// 11631       #endif
// 11632 
// 11633       #if Y_IS_TRINAMIC
// 11634         tmc_parse_drv_status(stepperY, TMC_Y, i);
// 11635       #endif
// 11636       #if Y2_IS_TRINAMIC
// 11637         tmc_parse_drv_status(stepperY2, TMC_Y2, i);
// 11638       #endif
// 11639 
// 11640       #if Z_IS_TRINAMIC
// 11641         tmc_parse_drv_status(stepperZ, TMC_Z, i);
// 11642       #endif
// 11643       #if Z2_IS_TRINAMIC
// 11644         tmc_parse_drv_status(stepperZ2, TMC_Z2, i);
// 11645       #endif
// 11646 
// 11647       #if E0_IS_TRINAMIC
// 11648         tmc_parse_drv_status(stepperE0, TMC_E0, i);
// 11649       #endif
// 11650       #if E1_IS_TRINAMIC
// 11651         tmc_parse_drv_status(stepperE1, TMC_E1, i);
// 11652       #endif
// 11653       #if E2_IS_TRINAMIC
// 11654         tmc_parse_drv_status(stepperE2, TMC_E2, i);
// 11655       #endif
// 11656       #if E3_IS_TRINAMIC
// 11657         tmc_parse_drv_status(stepperE3, TMC_E3, i);
// 11658       #endif
// 11659       #if E4_IS_TRINAMIC
// 11660         tmc_parse_drv_status(stepperE4, TMC_E4, i);
// 11661       #endif
// 11662 
// 11663       SERIAL_EOL();
// 11664     }
// 11665 
// 11666     inline void gcode_M122() {
// 11667       if (parser.seen('S')) {
// 11668         if (parser.value_bool()) {
// 11669           SERIAL_ECHOLNPGM("axis:pwm_scale |status_response|");
// 11670           report_tmc_status = true;
// 11671         } else
// 11672           report_tmc_status = false;
// 11673       } else {
// 11674         SERIAL_ECHOPGM("\t");                 tmc_debug_loop(TMC_CODES);
// 11675         SERIAL_ECHOPGM("Enabled\t");          tmc_debug_loop(TMC_ENABLED);
// 11676         SERIAL_ECHOPGM("Set current");        tmc_debug_loop(TMC_CURRENT);
// 11677         SERIAL_ECHOPGM("RMS current");        tmc_debug_loop(TMC_RMS_CURRENT);
// 11678         SERIAL_ECHOPGM("MAX current");        tmc_debug_loop(TMC_MAX_CURRENT);
// 11679         SERIAL_ECHOPGM("Run current");        tmc_debug_loop(TMC_IRUN);
// 11680         SERIAL_ECHOPGM("Hold current");       tmc_debug_loop(TMC_IHOLD);
// 11681         SERIAL_ECHOPGM("CS actual\t");        tmc_debug_loop(TMC_CS_ACTUAL);
// 11682         SERIAL_ECHOPGM("PWM scale");          tmc_debug_loop(TMC_PWM_SCALE);
// 11683         SERIAL_ECHOPGM("vsense\t");           tmc_debug_loop(TMC_VSENSE);
// 11684         SERIAL_ECHOPGM("stealthChop");        tmc_debug_loop(TMC_STEALTHCHOP);
// 11685         SERIAL_ECHOPGM("msteps\t");           tmc_debug_loop(TMC_MICROSTEPS);
// 11686         SERIAL_ECHOPGM("tstep\t");            tmc_debug_loop(TMC_TSTEP);
// 11687         SERIAL_ECHOPGM("pwm\nthreshold\t");   tmc_debug_loop(TMC_TPWMTHRS);
// 11688         SERIAL_ECHOPGM("[mm/s]\t");           tmc_debug_loop(TMC_TPWMTHRS_MMS);
// 11689         SERIAL_ECHOPGM("OT prewarn");         tmc_debug_loop(TMC_OTPW);
// 11690         SERIAL_ECHOPGM("OT prewarn has\nbeen triggered"); tmc_debug_loop(TMC_OTPW_TRIGGERED);
// 11691         SERIAL_ECHOPGM("off time\t");         tmc_debug_loop(TMC_TOFF);
// 11692         SERIAL_ECHOPGM("blank time");         tmc_debug_loop(TMC_TBL);
// 11693         SERIAL_ECHOPGM("hysterisis\n-end\t"); tmc_debug_loop(TMC_HEND);
// 11694         SERIAL_ECHOPGM("-start\t");           tmc_debug_loop(TMC_HSTRT);
// 11695         SERIAL_ECHOPGM("Stallguard thrs");    tmc_debug_loop(TMC_SGT);
// 11696 
// 11697         SERIAL_ECHOPGM("DRVSTATUS");          drv_status_loop(TMC_DRV_CODES);
// 11698         #if ENABLED(HAVE_TMC2130)
// 11699           SERIAL_ECHOPGM("stallguard\t");     drv_status_loop(TMC_STALLGUARD);
// 11700           SERIAL_ECHOPGM("sg_result\t");      drv_status_loop(TMC_SG_RESULT);
// 11701           SERIAL_ECHOPGM("fsactive\t");       drv_status_loop(TMC_FSACTIVE);
// 11702         #endif
// 11703         SERIAL_ECHOPGM("stst\t");             drv_status_loop(TMC_STST);
// 11704         SERIAL_ECHOPGM("olb\t");              drv_status_loop(TMC_OLB);
// 11705         SERIAL_ECHOPGM("ola\t");              drv_status_loop(TMC_OLA);
// 11706         SERIAL_ECHOPGM("s2gb\t");             drv_status_loop(TMC_S2GB);
// 11707         SERIAL_ECHOPGM("s2ga\t");             drv_status_loop(TMC_S2GA);
// 11708         SERIAL_ECHOPGM("otpw\t");             drv_status_loop(TMC_DRV_OTPW);
// 11709         SERIAL_ECHOPGM("ot\t");               drv_status_loop(TMC_OT);
// 11710         #if ENABLED(HAVE_TMC2208)
// 11711           SERIAL_ECHOPGM("157C\t");           drv_status_loop(TMC_T157);
// 11712           SERIAL_ECHOPGM("150C\t");           drv_status_loop(TMC_T150);
// 11713           SERIAL_ECHOPGM("143C\t");           drv_status_loop(TMC_T143);
// 11714           SERIAL_ECHOPGM("120C\t");           drv_status_loop(TMC_T120);
// 11715           SERIAL_ECHOPGM("s2vsa\t");          drv_status_loop(TMC_S2VSA);
// 11716           SERIAL_ECHOPGM("s2vsb\t");          drv_status_loop(TMC_S2VSB);
// 11717         #endif
// 11718         SERIAL_ECHOLNPGM("Driver registers:");drv_status_loop(TMC_DRV_STATUS_HEX);
// 11719       }
// 11720     }
// 11721   #endif
// 11722 
// 11723   template<typename TMC>
// 11724   static void tmc_get_current(TMC &st, const char name[]) {
// 11725     SERIAL_ECHO(name);
// 11726     SERIAL_ECHOPGM(" axis driver current: ");
// 11727     SERIAL_ECHOLN(st.getCurrent());
// 11728   }
// 11729   template<typename TMC>
// 11730   static void tmc_set_current(TMC &st, const char name[], const int mA) {
// 11731     st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
// 11732     tmc_get_current(st, name);
// 11733   }
// 11734 
// 11735   template<typename TMC>
// 11736   static void tmc_report_otpw(TMC &st, const char name[]) {
// 11737     SERIAL_ECHO(name);
// 11738     SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
// 11739     serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
// 11740     SERIAL_EOL();
// 11741   }
// 11742   template<typename TMC>
// 11743   static void tmc_clear_otpw(TMC &st, const char name[]) {
// 11744     st.clear_otpw();
// 11745     SERIAL_ECHO(name);
// 11746     SERIAL_ECHOLNPGM(" prewarn flag cleared");
// 11747   }
// 11748 
// 11749   template<typename TMC>
// 11750   static void tmc_get_pwmthrs(TMC &st, const char name[], const uint16_t spmm) {
// 11751     SERIAL_ECHO(name);
// 11752     SERIAL_ECHOPGM(" stealthChop max speed set to ");
// 11753     SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.TPWMTHRS() * spmm));
// 11754   }
// 11755   template<typename TMC>
// 11756   static void tmc_set_pwmthrs(TMC &st, const char name[], const int32_t thrs, const uint32_t spmm) {
// 11757     st.TPWMTHRS(12650000UL * st.microsteps() / (256 * thrs * spmm));
// 11758     tmc_get_pwmthrs(st, name, spmm);
// 11759   }
// 11760 
// 11761   template<typename TMC>
// 11762   static void tmc_get_sgt(TMC &st, const char name[]) {
// 11763     SERIAL_ECHO(name);
// 11764     SERIAL_ECHOPGM(" driver homing sensitivity set to ");
// 11765     MYSERIAL.println(st.sgt(), DEC);
// 11766   }
// 11767   template<typename TMC>
// 11768   static void tmc_set_sgt(TMC &st, const char name[], const int8_t sgt_val) {
// 11769     st.sgt(sgt_val);
// 11770     tmc_get_sgt(st, name);
// 11771   }
// 11772 
// 11773   /**
// 11774    * M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 11775    * Report driver currents when no axis specified
// 11776    */
// 11777   inline void gcode_M906() {
// 11778     uint16_t values[XYZE];
// 11779     LOOP_XYZE(i)
// 11780       values[i] = parser.intval(axis_codes[i]);
// 11781 
// 11782     #if X_IS_TRINAMIC
// 11783       if (values[X_AXIS]) tmc_set_current(stepperX, extended_axis_codes[TMC_X], values[X_AXIS]);
// 11784       else tmc_get_current(stepperX, extended_axis_codes[TMC_X]);
// 11785     #endif
// 11786     #if X2_IS_TRINAMIC
// 11787       if (values[X_AXIS]) tmc_set_current(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS]);
// 11788       else tmc_get_current(stepperX2, extended_axis_codes[TMC_X2]);
// 11789     #endif
// 11790     #if Y_IS_TRINAMIC
// 11791       if (values[Y_AXIS]) tmc_set_current(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS]);
// 11792       else tmc_get_current(stepperY, extended_axis_codes[TMC_Y]);
// 11793     #endif
// 11794     #if Y2_IS_TRINAMIC
// 11795       if (values[Y_AXIS]) tmc_set_current(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS]);
// 11796       else tmc_get_current(stepperY2, extended_axis_codes[TMC_Y2]);
// 11797     #endif
// 11798     #if Z_IS_TRINAMIC
// 11799       if (values[Z_AXIS]) tmc_set_current(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS]);
// 11800       else tmc_get_current(stepperZ, extended_axis_codes[TMC_Z]);
// 11801     #endif
// 11802     #if Z2_IS_TRINAMIC
// 11803       if (values[Z_AXIS]) tmc_set_current(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS]);
// 11804       else tmc_get_current(stepperZ2, extended_axis_codes[TMC_Z2]);
// 11805     #endif
// 11806     #if E0_IS_TRINAMIC
// 11807       if (values[E_AXIS]) tmc_set_current(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS]);
// 11808       else tmc_get_current(stepperE0, extended_axis_codes[TMC_E0]);
// 11809     #endif
// 11810     #if E1_IS_TRINAMIC
// 11811       if (values[E_AXIS]) tmc_set_current(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS]);
// 11812       else tmc_get_current(stepperE1, extended_axis_codes[TMC_E1]);
// 11813     #endif
// 11814     #if E2_IS_TRINAMIC
// 11815       if (values[E_AXIS]) tmc_set_current(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS]);
// 11816       else tmc_get_current(stepperE2, extended_axis_codes[TMC_E2]);
// 11817     #endif
// 11818     #if E3_IS_TRINAMIC
// 11819       if (values[E_AXIS]) tmc_set_current(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS]);
// 11820       else tmc_get_current(stepperE3, extended_axis_codes[TMC_E3]);
// 11821     #endif
// 11822     #if E4_IS_TRINAMIC
// 11823       if (values[E_AXIS]) tmc_set_current(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS]);
// 11824       else tmc_get_current(stepperE4, extended_axis_codes[TMC_E4]);
// 11825     #endif
// 11826 
// 11827   }
// 11828 
// 11829   /**
// 11830    * M911: Report TMC stepper driver overtemperature pre-warn flag
// 11831    * The flag is held by the library and persist until manually cleared by M912
// 11832    */
// 11833   inline void gcode_M911() {
// 11834     #if ENABLED(X_IS_TMC2130) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11835       tmc_report_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11836     #endif
// 11837     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11838       tmc_report_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11839     #endif
// 11840     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11841       tmc_report_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11842     #endif
// 11843     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX)) || ENABLED(IS_TRAMS)
// 11844       tmc_report_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11845     #endif
// 11846   }
// 11847 
// 11848   /**
// 11849    * M912: Clear TMC stepper driver overtemperature pre-warn flag held by the library
// 11850    */
// 11851   inline void gcode_M912() {
// 11852     const bool clearX = parser.seen(axis_codes[X_AXIS]), clearY = parser.seen(axis_codes[Y_AXIS]), clearZ = parser.seen(axis_codes[Z_AXIS]), clearE = parser.seen(axis_codes[E_AXIS]),
// 11853              clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
// 11854     #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS) || (ENABLED(X_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11855       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11856     #endif
// 11857     #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && PIN_EXISTS(X_SERIAL_RX))
// 11858       if (clearX || clearAll) tmc_clear_otpw(stepperX, extended_axis_codes[TMC_X]);
// 11859     #endif
// 11860 
// 11861     #if ENABLED(Y_IS_TMC2130) || (ENABLED(Y_IS_TMC2208) && PIN_EXISTS(Y_SERIAL_RX))
// 11862       if (clearY || clearAll) tmc_clear_otpw(stepperY, extended_axis_codes[TMC_Y]);
// 11863     #endif
// 11864 
// 11865     #if ENABLED(Z_IS_TMC2130) || (ENABLED(Z_IS_TMC2208) && PIN_EXISTS(Z_SERIAL_RX))
// 11866       if (clearZ || clearAll) tmc_clear_otpw(stepperZ, extended_axis_codes[TMC_Z]);
// 11867     #endif
// 11868 
// 11869     #if ENABLED(E0_IS_TMC2130) || (ENABLED(E0_IS_TMC2208) && PIN_EXISTS(E0_SERIAL_RX))
// 11870       if (clearE || clearAll) tmc_clear_otpw(stepperE0, extended_axis_codes[TMC_E0]);
// 11871     #endif
// 11872   }
// 11873 
// 11874   /**
// 11875    * M913: Set HYBRID_THRESHOLD speed.
// 11876    */
// 11877   #if ENABLED(HYBRID_THRESHOLD)
// 11878     inline void gcode_M913() {
// 11879       uint16_t values[XYZE];
// 11880       LOOP_XYZE(i)
// 11881         values[i] = parser.intval(axis_codes[i]);
// 11882 
// 11883       #if X_IS_TRINAMIC
// 11884         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX, extended_axis_codes[TMC_X], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11885         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X], planner.axis_steps_per_mm[X_AXIS]);
// 11886       #endif
// 11887       #if X2_IS_TRINAMIC
// 11888         if (values[X_AXIS]) tmc_set_pwmthrs(stepperX2, extended_axis_codes[TMC_X2], values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
// 11889         else tmc_get_pwmthrs(stepperX, extended_axis_codes[TMC_X2], planner.axis_steps_per_mm[X_AXIS]);
// 11890       #endif
// 11891 
// 11892       #if Y_IS_TRINAMIC
// 11893         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY, extended_axis_codes[TMC_Y], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11894         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y], planner.axis_steps_per_mm[Y_AXIS]);
// 11895       #endif
// 11896       #if Y2_IS_TRINAMIC
// 11897         if (values[Y_AXIS]) tmc_set_pwmthrs(stepperY2, extended_axis_codes[TMC_Y2], values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
// 11898         else tmc_get_pwmthrs(stepperY, extended_axis_codes[TMC_Y2], planner.axis_steps_per_mm[Y_AXIS]);
// 11899       #endif
// 11900 
// 11901       #if Z_IS_TRINAMIC
// 11902         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11903         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z], planner.axis_steps_per_mm[Z_AXIS]);
// 11904       #endif
// 11905       #if Z2_IS_TRINAMIC
// 11906         if (values[Z_AXIS]) tmc_set_pwmthrs(stepperZ2, extended_axis_codes[TMC_Z2], values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
// 11907         else tmc_get_pwmthrs(stepperZ, extended_axis_codes[TMC_Z2], planner.axis_steps_per_mm[Z_AXIS]);
// 11908       #endif
// 11909 
// 11910       #if E0_IS_TRINAMIC
// 11911         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11912         else tmc_get_pwmthrs(stepperE0, extended_axis_codes[TMC_E0], planner.axis_steps_per_mm[E_AXIS]);
// 11913       #endif
// 11914       #if E1_IS_TRINAMIC
// 11915         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11916         else tmc_get_pwmthrs(stepperE1, extended_axis_codes[TMC_E1], planner.axis_steps_per_mm[E_AXIS]);
// 11917       #endif
// 11918       #if E2_IS_TRINAMIC
// 11919         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11920         else tmc_get_pwmthrs(stepperE2, extended_axis_codes[TMC_E2], planner.axis_steps_per_mm[E_AXIS]);
// 11921       #endif
// 11922       #if E3_IS_TRINAMIC
// 11923         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11924         else tmc_get_pwmthrs(stepperE3, extended_axis_codes[TMC_E3], planner.axis_steps_per_mm[E_AXIS]);
// 11925       #endif
// 11926       #if E4_IS_TRINAMIC
// 11927         if (values[E_AXIS]) tmc_set_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
// 11928         else tmc_get_pwmthrs(stepperE4, extended_axis_codes[TMC_E4], planner.axis_steps_per_mm[E_AXIS]);
// 11929       #endif
// 11930     }
// 11931   #endif // HYBRID_THRESHOLD
// 11932 
// 11933   /**
// 11934    * M914: Set SENSORLESS_HOMING sensitivity.
// 11935    */
// 11936   #if ENABLED(SENSORLESS_HOMING)
// 11937     inline void gcode_M914() {
// 11938       #if ENABLED(X_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11939         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX, extended_axis_codes[TMC_X], parser.value_int());
// 11940         else tmc_get_sgt(stepperX, extended_axis_codes[TMC_X]);
// 11941       #endif
// 11942       #if ENABLED(X2_IS_TMC2130)
// 11943         if (parser.seen(axis_codes[X_AXIS])) tmc_set_sgt(stepperX2, extended_axis_codes[TMC_X2], parser.value_int());
// 11944         else tmc_get_sgt(stepperX2, extended_axis_codes[TMC_X2]);
// 11945       #endif
// 11946       #if ENABLED(Y_IS_TMC2130) || ENABLED(IS_TRAMS)
// 11947         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY, extended_axis_codes[TMC_Y], parser.value_int());
// 11948         else tmc_get_sgt(stepperY, extended_axis_codes[TMC_Y]);
// 11949       #endif
// 11950       #if ENABLED(Y2_IS_TMC2130)
// 11951         if (parser.seen(axis_codes[Y_AXIS])) tmc_set_sgt(stepperY2, extended_axis_codes[TMC_Y2], parser.value_int());
// 11952         else tmc_get_sgt(stepperY2, extended_axis_codes[TMC_Y2]);
// 11953       #endif
// 11954     }
// 11955   #endif // SENSORLESS_HOMING
// 11956 
// 11957   /**
// 11958    * TMC Z axis calibration routine
// 11959    */
// 11960   #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 11961     inline void gcode_M915() {
// 11962       uint16_t _rms = parser.seenval('S') ? parser.value_int() : CALIBRATION_CURRENT;
// 11963       uint16_t _z = parser.seenval('Z') ? parser.value_int() : CALIBRATION_EXTRA_HEIGHT;
// 11964 
// 11965       if (!axis_known_position[Z_AXIS]) {
// 11966         SERIAL_ECHOLNPGM("\nPlease home Z axis first");
// 11967         return;
// 11968       }
// 11969 
// 11970       uint16_t Z_current_1 = stepperZ.getCurrent();
// 11971       uint16_t Z2_current_1 = stepperZ.getCurrent();
// 11972 
// 11973       stepperZ.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11974       stepperZ2.setCurrent(_rms, R_SENSE, HOLD_MULTIPLIER);
// 11975       SERIAL_ECHOPAIR("\nCalibration current: Z", _rms);
// 11976 
// 11977       soft_endstops_enabled = false;
// 11978 
// 11979       do_blocking_move_to_z(Z_MAX_POS+_z);
// 11980 
// 11981       stepperZ.setCurrent(Z_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11982       stepperZ2.setCurrent(Z2_current_1, R_SENSE, HOLD_MULTIPLIER);
// 11983 
// 11984       do_blocking_move_to_z(Z_MAX_POS);
// 11985       soft_endstops_enabled = true;
// 11986 
// 11987       SERIAL_ECHOLNPGM("\nHoming Z because we lost steps");
// 11988       home_z_safely();
// 11989     }
// 11990   #endif
// 11991 
// 11992 #endif // HAS_TRINAMIC
// 11993 
// 11994 /**
// 11995  * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
// 11996  */
// 11997 inline void gcode_M907() {
// 11998   #if HAS_DIGIPOTSS
// 11999 
// 12000     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
// 12001     if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
// 12002     if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
// 12003 
// 12004   #elif HAS_MOTOR_CURRENT_PWM
// 12005 
// 12006     #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
// 12007       if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
// 12008     #endif
// 12009     #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
// 12010       if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
// 12011     #endif
// 12012     #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
// 12013       if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
// 12014     #endif
// 12015 
// 12016   #endif
// 12017 
// 12018   #if ENABLED(DIGIPOT_I2C)
// 12019     // this one uses actual amps in floating point
// 12020     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
// 12021     // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
// 12022     for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
// 12023   #endif
// 12024 
// 12025   #if ENABLED(DAC_STEPPER_CURRENT)
// 12026     if (parser.seen('S')) {
// 12027       const float dac_percent = parser.value_float();
// 12028       for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
// 12029     }
// 12030     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
// 12031   #endif
// 12032 }
// 12033 
// 12034 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 12035 
// 12036   /**
// 12037    * M908: Control digital trimpot directly (M908 P<pin> S<current>)
// 12038    */
// 12039   inline void gcode_M908() {
// 12040     #if HAS_DIGIPOTSS
// 12041       stepper.digitalPotWrite(
// 12042         parser.intval('P'),
// 12043         parser.intval('S')
// 12044       );
// 12045     #endif
// 12046     #ifdef DAC_STEPPER_CURRENT
// 12047       dac_current_raw(
// 12048         parser.byteval('P', -1),
// 12049         parser.ushortval('S', 0)
// 12050       );
// 12051     #endif
// 12052   }
// 12053 
// 12054   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 12055 
// 12056     inline void gcode_M909() { dac_print_values(); }
// 12057 
// 12058     inline void gcode_M910() { dac_commit_eeprom(); }
// 12059 
// 12060   #endif
// 12061 
// 12062 #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 12063 
// 12064 #if HAS_MICROSTEPS
// 12065 
// 12066   // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 12067   inline void gcode_M350() {
// 12068     if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
// 12069     LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
// 12070     if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
// 12071     stepper.microstep_readings();
// 12072   }
// 12073 
// 12074   /**
// 12075    * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
// 12076    *       S# determines MS1 or MS2, X# sets the pin high/low.
// 12077    */
// 12078   inline void gcode_M351() {
// 12079     if (parser.seenval('S')) switch (parser.value_byte()) {
// 12080       case 1:
// 12081         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
// 12082         if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
// 12083         break;
// 12084       case 2:
// 12085         LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
// 12086         if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
// 12087         break;
// 12088     }
// 12089     stepper.microstep_readings();
// 12090   }
// 12091 
// 12092 #endif // HAS_MICROSTEPS
// 12093 
// 12094 #if HAS_CASE_LIGHT
// 12095   #ifndef INVERT_CASE_LIGHT
// 12096     #define INVERT_CASE_LIGHT false
// 12097   #endif
// 12098   uint8_t case_light_brightness;  // LCD routine wants INT
// 12099   bool case_light_on;
// 12100 
// 12101   void update_case_light() {
// 12102     pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
// 12103     if (case_light_on) {
// 12104       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 12105         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness);
// 12106       else
// 12107         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
// 12108     }
// 12109     else {
// 12110       if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
// 12111         analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 : 0);
// 12112       else
// 12113         WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
// 12114     }
// 12115   }
// 12116 #endif // HAS_CASE_LIGHT
// 12117 
// 12118 /**
// 12119  * M355: Turn case light on/off and set brightness
// 12120  *
// 12121  *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
// 12122  *
// 12123  *   S<bool>  Set case light on/off
// 12124  *
// 12125  *   When S turns on the light on a PWM pin then the current brightness level is used/restored
// 12126  *
// 12127  *   M355 P200 S0 turns off the light & sets the brightness level
// 12128  *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
// 12129  */
// 12130 inline void gcode_M355() {
// 12131   #if HAS_CASE_LIGHT
// 12132     uint8_t args = 0;
// 12133     if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
// 12134     if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
// 12135     if (args) update_case_light();
// 12136 
// 12137     // always report case light status
// 12138     SERIAL_ECHO_START();
// 12139     if (!case_light_on) {
// 12140       SERIAL_ECHOLN("Case light: off");
// 12141     }
// 12142     else {
// 12143       if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
// 12144       else SERIAL_ECHOLNPAIR("Case light: ", (int)case_light_brightness);
// 12145     }
// 12146 
// 12147   #else
// 12148     SERIAL_ERROR_START();
// 12149     SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
// 12150   #endif // HAS_CASE_LIGHT
// 12151 }
// 12152 
// 12153 #if ENABLED(MIXING_EXTRUDER)
// 12154 
// 12155   /**
// 12156    * M163: Set a single mix factor for a mixing extruder
// 12157    *       This is called "weight" by some systems.
// 12158    *
// 12159    *   S[index]   The channel index to set
// 12160    *   P[float]   The mix value
// 12161    *
// 12162    */
// 12163   inline void gcode_M163() {
// 12164     const int mix_index = parser.intval('S');
// 12165     if (mix_index < MIXING_STEPPERS) {
// 12166       float mix_value = parser.floatval('P');
// 12167       NOLESS(mix_value, 0.0);
// 12168       mixing_factor[mix_index] = RECIPROCAL(mix_value);
// 12169     }
// 12170   }
// 12171 
// 12172   #if MIXING_VIRTUAL_TOOLS > 1
// 12173 
// 12174     /**
// 12175      * M164: Store the current mix factors as a virtual tool.
// 12176      *
// 12177      *   S[index]   The virtual tool to store
// 12178      *
// 12179      */
// 12180     inline void gcode_M164() {
// 12181       const int tool_index = parser.intval('S');
// 12182       if (tool_index < MIXING_VIRTUAL_TOOLS) {
// 12183         normalize_mix();
// 12184         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 12185           mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
// 12186       }
// 12187     }
// 12188 
// 12189   #endif
// 12190 
// 12191   #if ENABLED(DIRECT_MIXING_IN_G1)
// 12192     /**
// 12193      * M165: Set multiple mix factors for a mixing extruder.
// 12194      *       Factors that are left out will be set to 0.
// 12195      *       All factors together must add up to 1.0.
// 12196      *
// 12197      *   A[factor] Mix factor for extruder stepper 1
// 12198      *   B[factor] Mix factor for extruder stepper 2
// 12199      *   C[factor] Mix factor for extruder stepper 3
// 12200      *   D[factor] Mix factor for extruder stepper 4
// 12201      *   H[factor] Mix factor for extruder stepper 5
// 12202      *   I[factor] Mix factor for extruder stepper 6
// 12203      *
// 12204      */
// 12205     inline void gcode_M165() { gcode_get_mix(); }
// 12206   #endif
// 12207 
// 12208 #endif // MIXING_EXTRUDER
// 12209 
// 12210 /**
// 12211  * M999: Restart after being stopped
// 12212  *
// 12213  * Default behaviour is to flush the serial buffer and request
// 12214  * a resend to the host starting on the last N line received.
// 12215  *
// 12216  * Sending "M999 S1" will resume printing without flushing the
// 12217  * existing command buffer.
// 12218  *
// 12219  */
// 12220 inline void gcode_M999() {
// 12221   Running = true;
// 12222   lcd_reset_alert_level();
// 12223 
// 12224   if (parser.boolval('S')) return;
// 12225 
// 12226   // gcode_LastN = Stopped_gcode_LastN;
// 12227   FlushSerialRequestResend();
// 12228 }
// 12229 
// 12230 #if ENABLED(SWITCHING_EXTRUDER)
// 12231   #if EXTRUDERS > 3
// 12232     #define REQ_ANGLES 4
// 12233     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
// 12234   #else
// 12235     #define REQ_ANGLES 2
// 12236     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
// 12237   #endif
// 12238   inline void move_extruder_servo(const uint8_t e) {
// 12239     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
// 12240     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
// 12241     stepper.synchronize();
// 12242     #if EXTRUDERS & 1
// 12243       if (e < EXTRUDERS - 1)
// 12244     #endif
// 12245     {
// 12246       MOVE_SERVO(_SERVO_NR, angles[e]);
// 12247       safe_delay(500);
// 12248     }
// 12249   }
// 12250 #endif // SWITCHING_EXTRUDER
// 12251 
// 12252 #if ENABLED(SWITCHING_NOZZLE)
// 12253   inline void move_nozzle_servo(const uint8_t e) {
// 12254     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
// 12255     stepper.synchronize();
// 12256     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
// 12257     safe_delay(500);
// 12258   }
// 12259 #endif
// 12260 
// 12261 inline void invalid_extruder_error(const uint8_t e) {
// 12262   SERIAL_ECHO_START();
// 12263   SERIAL_CHAR('T');
// 12264   SERIAL_ECHO_F(e, DEC);
// 12265   SERIAL_CHAR(' ');
// 12266   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
// 12267 }
// 12268 
// 12269 #if ENABLED(PARKING_EXTRUDER)
// 12270 
// 12271   #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12272     #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 12273   #else
// 12274     #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
// 12275   #endif
// 12276 
// 12277   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
// 12278     switch (extruder_num) {
// 12279       case 1: OUT_WRITE(SOL1_PIN, state); break;
// 12280       default: OUT_WRITE(SOL0_PIN, state); break;
// 12281     }
// 12282     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
// 12283       dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
// 12284     #endif
// 12285   }
// 12286 
// 12287   inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
// 12288   inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
// 12289 
// 12290 #endif // PARKING_EXTRUDER
// 12291 
// 12292 #if HAS_FANMUX
// 12293 
// 12294   void fanmux_switch(const uint8_t e) {
// 12295     WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
// 12296     #if PIN_EXISTS(FANMUX1)
// 12297       WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
// 12298       #if PIN_EXISTS(FANMUX2)
// 12299         WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
// 12300       #endif
// 12301     #endif
// 12302   }
// 12303 
// 12304   FORCE_INLINE void fanmux_init(void) {
// 12305     SET_OUTPUT(FANMUX0_PIN);
// 12306     #if PIN_EXISTS(FANMUX1)
// 12307       SET_OUTPUT(FANMUX1_PIN);
// 12308       #if PIN_EXISTS(FANMUX2)
// 12309         SET_OUTPUT(FANMUX2_PIN);
// 12310       #endif
// 12311     #endif
// 12312     fanmux_switch(0);
// 12313   }
// 12314 
// 12315 #endif // HAS_FANMUX
// 12316 
// 12317 /**
// 12318  * Perform a tool-change, which may result in moving the
// 12319  * previous tool out of the way and the new tool into place.
// 12320  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock62 Using cfiCommon0
          CFI Function _Z11tool_changehfb
        THUMB
// 12321 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
_Z11tool_changehfb:
        PUSH     {R4-R9,R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R6,R0
        SUB      SP,SP,#+104
          CFI CFA R13+136
        MOV      R0,R1
        MOV      R5,R2
// 12322   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 12323 
// 12324     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
// 12325       return invalid_extruder_error(tmp_extruder);
// 12326 
// 12327     // T0-Tnnn: Switch virtual tool by changing the mix
// 12328     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
// 12329       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
// 12330 
// 12331   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12332 
// 12333     if (tmp_extruder >= EXTRUDERS)
        CMP      R6,#+2
        BLT.N    ??tool_change_0
// 12334       return invalid_extruder_error(tmp_extruder);
        LDR.N    R0,??DataTable140_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??DataTable140_31
        MOVS     R1,#+84
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R2,#+10
        MOV      R1,R6
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEhi
        BL       _ZN5Print5printEhi
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R1,??DataTable140_32
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R4
        B.N      ??tool_change_1
// 12335 
// 12336     #if HOTENDS > 1
// 12337 
// 12338       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
??tool_change_0:
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        LDR.N    R4,??DataTable140_18
        IT       CC 
        STRCC    R0,[SP, #+24]
        BCC.N    ??tool_change_2
        LDR      R0,[R4, #+112]
        STR      R0,[SP, #+24]
        LDR.N    R0,??DataTable140_19
        LDR      R0,[R0, #+100]
??tool_change_2:
        STR      R0,[R4, #+112]
// 12339 
// 12340       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
// 12341 
// 12342       if (tmp_extruder != active_extruder) {
        LDRB     R0,[R4, #+10]
        CMP      R6,R0
        BEQ.W    ??tool_change_3
// 12343         if (!no_move && axis_unhomed_error()) {
        CBNZ.N   R5,??tool_change_4
        MOVS     R1,#+1
        MOVS     R2,#+1
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CBZ.N    R0,??tool_change_4
// 12344           no_move = true;
        MOVS     R5,#+1
// 12345           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12346             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
// 12347           #endif
// 12348         }
// 12349 
// 12350         // Save current position to destination, for use later
// 12351         //if(gCfgItems.breakpoint_flg!=1)
// 12352             set_destination_from_current();
??tool_change_4:
        ADD      R0,R4,#+16
        LDM      R0!,{R2,R3,R7,R12}
        ADD      R1,R4,#+32
// 12353 
// 12354         #if ENABLED(DUAL_X_CARRIAGE)
// 12355 
// 12356           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12357             if (DEBUGGING(LEVELING)) {
// 12358               SERIAL_ECHOPGM("Dual X Carriage Mode ");
// 12359               switch (dual_x_carriage_mode) {
// 12360                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
// 12361                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
// 12362                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
// 12363               }
// 12364             }
// 12365           #endif
// 12366 
// 12367           const float xhome = x_home_pos(active_extruder);
// 12368           if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
// 12369               && IsRunning()
// 12370               && (delayed_move_time || current_position[X_AXIS] != xhome)
// 12371           ) {
// 12372             float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
// 12373             //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 12374             if(mksCfg.max_software_endstops){
// 12375               NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
// 12376             }
// 12377             //#endif
// 12378             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12379               if (DEBUGGING(LEVELING)) {
// 12380                 SERIAL_ECHOLNPAIR("Raise to ", raised_z);
// 12381                 SERIAL_ECHOLNPAIR("MoveX to ", xhome);
// 12382                 SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
// 12383               }
// 12384             #endif
// 12385             // Park old head: 1) raise 2) move to park position 3) lower
// 12386             for (uint8_t i = 0; i < 3; i++)
// 12387               planner.buffer_line(
// 12388                 i == 0 ? current_position[X_AXIS] : xhome,
// 12389                 current_position[Y_AXIS],
// 12390                 i == 2 ? current_position[Z_AXIS] : raised_z,
// 12391                 current_position[E_AXIS],
// 12392                 planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
// 12393                 active_extruder
// 12394               );
// 12395             stepper.synchronize();
// 12396           }
// 12397 
// 12398           // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
// 12399           current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
// 12400           current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 12401 
// 12402           // Activate the new extruder ahead of calling set_axis_is_at_home!
// 12403           active_extruder = tmp_extruder;
// 12404 
// 12405           // This function resets the max/min values - the current position may be overwritten below.
// 12406           set_axis_is_at_home(X_AXIS);
// 12407 
// 12408           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12409             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
// 12410           #endif
// 12411 
// 12412           // Only when auto-parking are carriages safe to move
// 12413           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
// 12414 
// 12415           switch (dual_x_carriage_mode) {
// 12416             case DXC_FULL_CONTROL_MODE:
// 12417               // New current position is the position of the activated extruder
// 12418               current_position[X_AXIS] = inactive_extruder_x_pos;
// 12419               // Save the inactive extruder's position (from the old current_position)
// 12420               inactive_extruder_x_pos = destination[X_AXIS];
// 12421               break;
// 12422             case DXC_AUTO_PARK_MODE:
// 12423               // record raised toolhead position for use by unpark
// 12424               COPY(raised_parked_position, current_position);
// 12425               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
// 12426               //#if ENABLED(MAX_SOFTWARE_ENDSTOPS)
// 12427               if(mksCfg.max_software_endstops){
// 12428                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
// 12429               }
// 12430               //#endif
// 12431               active_extruder_parked = true;
// 12432               delayed_move_time = 0;
// 12433               break;
// 12434             case DXC_DUPLICATION_MODE:
// 12435               // If the new extruder is the left one, set it "parked"
// 12436               // This triggers the second extruder to move into the duplication position
// 12437               active_extruder_parked = (active_extruder == 0);
// 12438 
// 12439               if (active_extruder_parked)
// 12440                 current_position[X_AXIS] = inactive_extruder_x_pos;
// 12441               else
// 12442                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
// 12443               inactive_extruder_x_pos = destination[X_AXIS];
// 12444               extruder_duplication_enabled = false;
// 12445               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12446                 if (DEBUGGING(LEVELING)) {
// 12447                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
// 12448                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
// 12449                 }
// 12450               #endif
// 12451               break;
// 12452           }
// 12453 
// 12454           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12455             if (DEBUGGING(LEVELING)) {
// 12456               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
// 12457               DEBUG_POS("New extruder (parked)", current_position);
// 12458             }
// 12459           #endif
// 12460 
// 12461           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
// 12462 
// 12463         #else // !DUAL_X_CARRIAGE
// 12464 
// 12465           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
// 12466             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
// 12467             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
// 12468             if (!no_move) {
// 12469 
// 12470               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
// 12471                           midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
// 12472                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
// 12473                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
// 12474               /**
// 12475                *  Steps:
// 12476                *    1. Raise Z-Axis to give enough clearance
// 12477                *    2. Move to park position of old extruder
// 12478                *    3. Disengage magnetic field, wait for delay
// 12479                *    4. Move near new extruder
// 12480                *    5. Engage magnetic field for new extruder
// 12481                *    6. Move to parking incl. offset of new extruder
// 12482                *    7. Lower Z-Axis
// 12483                */
// 12484 
// 12485               // STEP 1
// 12486               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12487                 SERIAL_ECHOLNPGM("Starting Autopark");
// 12488                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
// 12489               #endif
// 12490               current_position[Z_AXIS] += z_raise;
// 12491               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12492                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
// 12493                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
// 12494               #endif
// 12495               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 12496               stepper.synchronize();
// 12497 
// 12498               // STEP 2
// 12499               current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
// 12500               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12501                 SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
// 12502                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
// 12503               #endif
// 12504               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12505               stepper.synchronize();
// 12506 
// 12507               // STEP 3
// 12508               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12509                 SERIAL_ECHOLNPGM("(3) Disengage magnet ");
// 12510               #endif
// 12511               pe_deactivate_magnet(active_extruder);
// 12512 
// 12513               // STEP 4
// 12514               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12515                 SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
// 12516               #endif
// 12517               current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
// 12518 
// 12519               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12520                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
// 12521               #endif
// 12522               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12523               stepper.synchronize();
// 12524 
// 12525               // STEP 5
// 12526               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12527                 SERIAL_ECHOLNPGM("(5) Engage magnetic field");
// 12528               #endif
// 12529 
// 12530               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12531                 pe_activate_magnet(active_extruder); //just save power for inverted magnets
// 12532               #endif
// 12533               pe_activate_magnet(tmp_extruder);
// 12534 
// 12535               // STEP 6
// 12536               current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
// 12537               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12538               current_position[X_AXIS] = grabpos;
// 12539               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12540                 SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
// 12541                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
// 12542               #endif
// 12543               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
// 12544               stepper.synchronize();
// 12545 
// 12546               // Step 7
// 12547               current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
// 12548               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12549                 SERIAL_ECHOLNPGM("(7) Move midway between hotends");
// 12550                 if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
// 12551               #endif
// 12552               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
// 12553               stepper.synchronize();
// 12554               #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12555                 SERIAL_ECHOLNPGM("Autopark done.");
// 12556               #endif
// 12557             }
// 12558             else { // nomove == true
// 12559               // Only engage magnetic field for new extruder
// 12560               pe_activate_magnet(tmp_extruder);
// 12561               #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 12562                 pe_activate_magnet(active_extruder); // Just save power for inverted magnets
// 12563               #endif
// 12564             }
// 12565             current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
// 12566 
// 12567             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12568               if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
// 12569             #endif
// 12570 
// 12571           #endif // dualParking extruder
// 12572 
// 12573           #if ENABLED(SWITCHING_NOZZLE)
// 12574             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
// 12575             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
// 12576             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
// 12577                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
// 12578 
// 12579             // Always raise by some amount (destination copied from current_position earlier)
// 12580             current_position[Z_AXIS] += z_raise;
// 12581             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
// 12582             move_nozzle_servo(tmp_extruder);
// 12583           #endif
// 12584 
// 12585           /**
// 12586            * Set current_position to the position of the new nozzle.
// 12587            * Offsets are based on linear distance, so we need to get
// 12588            * the resulting position in coordinate space.
// 12589            *
// 12590            * - With grid or 3-point leveling, offset XYZ by a tilted vector
// 12591            * - With mesh leveling, update Z for the new position
// 12592            * - Otherwise, just use the raw linear distance
// 12593            *
// 12594            * Software endstops are altered here too. Consider a case where:
// 12595            *   E0 at X=0 ... E1 at X=10
// 12596            * When we switch to E1 now X=10, but E1 can't move left.
// 12597            * To express this we apply the change in XY to the software endstops.
// 12598            * E1 can move farther right than E0, so the right limit is extended.
// 12599            *
// 12600            * Note that we don't adjust the Z software endstops. Why not?
// 12601            * Consider a case where Z=0 (here) and switching to E1 makes Z=1
// 12602            * because the bed is 1mm lower at the new position. As long as
// 12603            * the first nozzle is out of the way, the carriage should be
// 12604            * allowed to move 1mm lower. This technically "breaks" the
// 12605            * Z software endstop. But this is technically correct (and
// 12606            * there is no viable alternative).
// 12607            */
// 12608           //#if ABL_PLANAR
// 12609           float xydiff[2]={0};
        LDR.N    R0,??DataTable140
        STM      R1!,{R2,R3,R7,R12}
        LDRB     R0,[R0, #+66]
        MOV      R8,#+0
        MOVS     R1,#+6
        MOV      R9,R8
        LDR.N    R7,??DataTable140_33
        TST      R0,R1
        BEQ.N    ??tool_change_5
// 12610 		  if(BED_LEVELING_METHOD&ABL_PLANAR)
// 12611 		  	{
// 12612             // Offset extruder, make sure to apply the bed level rotation matrix
// 12613             vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
// 12614                                                hotend_offset[Y_AXIS][tmp_extruder],
// 12615                                                0),
        LDR.W    R9,??DataTable140_4
        ADD      R0,R9,R6, LSL #+2
        LDR      R2,[R0, #+44]
        LDR      R1,[R0, #+36]
        MOVS     R3,#+0
        ADD      R0,SP,#+52
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDRB     R0,[R4, #+10]
        ADD      R1,R9,R0, LSL #+2
        ADD      R0,R9,R0, LSL #+2
        LDR      R2,[R1, #+44]
        LDR      R1,[R0, #+36]
        MOV      R3,R8
        ADD      R0,SP,#+40
// 12616                      act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
// 12617                                                hotend_offset[Y_AXIS][active_extruder],
// 12618                                                0),
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        ADD      R0,SP,#+40
        SUB      SP,SP,#+8
          CFI CFA R13+144
        LDM      R0!,{R2,R3}
        MOV      R1,SP
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+136
        ADD      R1,SP,#+52
        ADD      R0,SP,#+4
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
// 12619                      offset_vec = tmp_offset_vec - act_offset_vec;
        ADD      R1,SP,#+4
        LDM      R1!,{R2,R3,R12}
        ADD      R0,SP,#+28
// 12620 
// 12621             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12622               if (DEBUGGING(LEVELING)) {
// 12623                 tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
// 12624                 act_offset_vec.debug(PSTR("act_offset_vec"));
// 12625                 offset_vec.debug(PSTR("offset_vec (BEFORE)"));
// 12626               }
// 12627             #endif
// 12628 
// 12629             offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
        LDR.N    R1,??DataTable140_34
        STM      R0!,{R2,R3,R12}
        SUB      SP,SP,#+12
          CFI CFA R13+148
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R1-R3}
          CFI CFA R13+136
        ADD      R0,SP,#+64
          CFI FunCall _ZN10matrix_3x39transposeES_
        BL       _ZN10matrix_3x39transposeES_
        ADD      R1,SP,#+64
        SUB      SP,SP,#+12
          CFI CFA R13+148
        MOV      R0,SP
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R1-R3}
          CFI CFA R13+136
        ADD      R0,SP,#+28
          CFI FunCall _ZN8vector_314apply_rotationE10matrix_3x3
        BL       _ZN8vector_314apply_rotationE10matrix_3x3
// 12630 
// 12631             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12632               if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
// 12633             #endif
// 12634 
// 12635             // Adjustments to the current position
// 12636             //const float xydiff[2] = { offset_vec.x, offset_vec.y };
// 12637 			xydiff[0] = offset_vec.x;
        LDR      R8,[SP, #+28]
// 12638 			xydiff[1] = offset_vec.y;
        LDR      R9,[SP, #+32]
// 12639             current_position[Z_AXIS] += offset_vec.z;
        LDR      R1,[R4, #+24]
        LDR      R0,[SP, #+36]
        B.N      ??tool_change_6
// 12640 		  }
// 12641           //#else // !ABL_PLANAR
// 12642 			else
// 12643 			{
// 12644 				/*
// 12645             		const float xydiff[2] = {
// 12646               			hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
// 12647              	 		hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
// 12648             		};*/
// 12649             if(gCfgItems.breakpoint_flg!=1)
??tool_change_5:
        LDRB     R0,[R7, #+357]
        CMP      R0,#+1
        BEQ.N    ??tool_change_7
        LDRB     R11,[R4, #+10]
        LDR.W    R9,??DataTable140_4
        ADD      R0,R9,R6, LSL #+2
        ADD      R1,R9,R11, LSL #+2
        LDR      R0,[R0, #+36]
        LDR      R1,[R1, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
// 12650             {
// 12651 			    xydiff[0] = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
// 12652 			    xydiff[1] = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
        ADD      R0,R9,R6, LSL #+2
        ADD      R1,R9,R11, LSL #+2
        LDR      R0,[R0, #+44]
        LDR      R1,[R1, #+44]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
// 12653             }
// 12654 				
// 12655             //#if ENABLED(MESH_BED_LEVELING)
// 12656 			if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
??tool_change_7:
        LDR.N    R0,??DataTable140
        LDRB     R0,[R0, #+66]
        CMP      R0,#+32
        BNE.N    ??tool_change_8
// 12657 			{
// 12658               if (planner.leveling_active) {
        LDR.N    R0,??DataTable140_35
        LDRB     R0,[R0, #+0]
        CBZ.N    R0,??tool_change_8
// 12659                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12660                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
// 12661                 #endif
// 12662                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
        LDR      R0,[R4, #+16]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+12]
// 12663                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
        MOV      R1,R9
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+8]
// 12664                       z1 = current_position[Z_AXIS], z2 = z1;
// 12665                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
        ADD      R2,SP,#+0
        LDR      R0,[R4, #+24]
        STR      R0,[SP, #+0]
        STR      R0,[SP, #+4]
        ADD      R1,R4,#+20
        ADD      R0,R4,#+16
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 12666                 planner.apply_leveling(x2, y2, z2);
        ADD      R2,SP,#+4
        ADD      R1,SP,#+8
        ADD      R0,SP,#+12
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
// 12667                 current_position[Z_AXIS] += z2 - z1;
        LDR      R0,[SP, #+4]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+24]
??tool_change_6:
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+24]
// 12668                 #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12669                   if (DEBUGGING(LEVELING))
// 12670                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
// 12671                 #endif
// 12672               }
// 12673 			}
// 12674             //#endif // MESH_BED_LEVELING
// 12675 				}
// 12676           //#endif // !HAS_ABL
// 12677 
// 12678           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12679             if (DEBUGGING(LEVELING)) {
// 12680               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
// 12681               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
// 12682               SERIAL_ECHOLNPGM(" }");
// 12683             }
// 12684           #endif
// 12685 
// 12686           // The newly-selected extruder XY is actually at...
// 12687           if(gCfgItems.breakpoint_flg!=1)
??tool_change_8:
        LDRB     R0,[R7, #+357]
        CMP      R0,#+1
        BEQ.N    ??tool_change_9
// 12688           {
// 12689             current_position[X_AXIS] += xydiff[X_AXIS];
        LDR      R0,[R4, #+16]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+16]
// 12690             current_position[Y_AXIS] += xydiff[Y_AXIS];
        MOV      R1,R9
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+20]
// 12691           }
// 12692           // Set the new active extruder
// 12693           active_extruder = tmp_extruder;
??tool_change_9:
        STRB     R6,[R4, #+10]
// 12694 
// 12695         #endif // !DUAL_X_CARRIAGE
// 12696 
// 12697         #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12698           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
// 12699         #endif
// 12700 
// 12701         // Tell the planner the new "current position"
// 12702         if(gCfgItems.breakpoint_flg!=1)
        LDRB     R0,[R7, #+357]
        CMP      R0,#+1
        IT       NE 
// 12703             SYNC_PLAN_POSITION_KINEMATIC();
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BLNE     _Z28SYNC_PLAN_POSITION_KINEMATICv
// 12704 
// 12705         // Move to the "old position" (move the extruder into place)
// 12706         #if ENABLED(SWITCHING_NOZZLE)
// 12707           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
// 12708         #endif
// 12709         if (!no_move && IsRunning()) {
        LDRB     R0,[R4, #+4]
        EOR      R0,R0,#0x1
        ORRS     R0,R0,R5
        BNE.N    ??tool_change_3
// 12710           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12711             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
// 12712           #endif
// 12713           // Move back to the original (or tweaked) position
// 12714           if(gCfgItems.breakpoint_flg!=1)
        LDRB     R0,[R7, #+357]
        CMP      R0,#+1
        BEQ.N    ??tool_change_3
// 12715             do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R4,#+40
        ADD      R1,R4,#+36
        ADD      R0,R4,#+32
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
// 12716         }
// 12717         #if ENABLED(SWITCHING_NOZZLE)
// 12718           else {
// 12719             // Move back down. (Including when the new tool is higher.)
// 12720             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
// 12721           }
// 12722         #endif
// 12723       } // (tmp_extruder != active_extruder)
// 12724 
// 12725       stepper.synchronize();
??tool_change_3:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
// 12726 
// 12727       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
// 12728         disable_all_solenoids();
// 12729         enable_solenoid_on_active_extruder();
// 12730       #endif // EXT_SOLENOID
// 12731 
// 12732       feedrate_mm_s = old_feedrate_mm_s;
        LDR      R0,[SP, #+24]
        STR      R0,[R4, #+112]
// 12733 
// 12734     #else // HOTENDS <= 1
// 12735 
// 12736       UNUSED(fr_mm_s);
// 12737       UNUSED(no_move);
// 12738 
// 12739       #if ENABLED(MK2_MULTIPLEXER)
// 12740         if (tmp_extruder >= E_STEPPERS)
// 12741           return invalid_extruder_error(tmp_extruder);
// 12742 
// 12743         select_multiplexed_stepper(tmp_extruder);
// 12744       #endif
// 12745 
// 12746       // Set the new active extruder
// 12747       active_extruder = tmp_extruder;
// 12748 
// 12749     #endif // HOTENDS <= 1
// 12750 
// 12751     #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 12752       stepper.synchronize();
// 12753       move_extruder_servo(active_extruder);
// 12754     #endif
// 12755 
// 12756     #if HAS_FANMUX
// 12757       fanmux_switch(active_extruder);
// 12758     #endif
// 12759 
// 12760     SERIAL_ECHO_START();
        LDR.N    R0,??DataTable140_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 12761     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
        LDRB     R1,[R4, #+10]
        LDR.N    R0,??DataTable140_36
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??DataTable140_31
        MOVS     R1,#+10
??tool_change_1:
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 12762 
// 12763   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
// 12764 }
        ADD      SP,SP,#+104
          CFI CFA R13+32
        POP      {R4-R9,R11,PC}   ;; return
          CFI EndBlock cfiBlock62

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_1:
        DC32     0x40400000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_2:
        DC32     `?<Constant "Bilinear Leveling Grid:\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_3:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_4:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_5:
        DC32     _ZN7Stepper17performing_homingE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_6:
        DC32     0x3ff80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_7:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_8:
        DC32     _ZZ24get_homing_bump_feedrate8AxisEnumEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_9:
        DC32     _ZN7Stepper14locked_z_motorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_10:
        DC32     _ZN7Stepper15locked_z2_motorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_11:
        DC32     0x9999999a

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_12:
        DC32     0x3fb99999

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_13:
        DC32     axis_codes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_14:
        DC32     next_busy_signal_ms

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_15:
        DC32     `?<Constant "busy: processing\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_16:
        DC32     `?<Constant "busy: paused for user\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_17:
        DC32     `?<Constant "busy: paused for input\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_18:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_19:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_20:
        DC32     _ZN8Endstops16endstop_hit_bitsE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_21:
        DC32     `?<Constant "?Probe ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_22:
        DC32     `?<Constant " position out of range.\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_23:
        DC32     `?<Constant " not entered.\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_24:
        DC32     `?<Constant "Num X,Y: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_25:
        DC32     `?<Constant "Z offset: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_26:
        DC32     _ZN17mesh_bed_leveling8z_offsetE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_27:
        DC32     `?<Constant "\\nMeasured points:\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_28:
        DC32     `?<Constant "SCARA Theta:">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_29:
        DC32     `?<Constant "   Psi+Theta:">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_30:
        DC32     `?<Constant "Cap:">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_31:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_32:
        DC32     _ZZ22invalid_extruder_errorhEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_33:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_34:
        DC32     _ZN7Planner16bed_level_matrixE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_35:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable140_36:
        DC32     `?<Constant "Active Extruder: ">`
// 12765 
// 12766 /**
// 12767  * T0-T3: Switch tool, usually switching extruders
// 12768  *
// 12769  *   F[units/min] Set the movement feedrate
// 12770  *   S1           Don't move the tool in XY after change
// 12771  */
// 12772 inline void gcode_T(const uint8_t tmp_extruder) {
// 12773 
// 12774   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12775     if (DEBUGGING(LEVELING)) {
// 12776       SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
// 12777       SERIAL_CHAR(')');
// 12778       SERIAL_EOL();
// 12779       DEBUG_POS("BEFORE", current_position);
// 12780     }
// 12781   #endif
// 12782 
// 12783   #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
// 12784 
// 12785     tool_change(tmp_extruder);
// 12786 
// 12787   #elif HOTENDS > 1
// 12788 
// 12789     tool_change(
// 12790       tmp_extruder,
// 12791       MMM_TO_MMS(parser.linearval('F')),
// 12792       (tmp_extruder == active_extruder) || parser.boolval('S')
// 12793     );
// 12794 
// 12795   #endif
// 12796 
// 12797   #if ENABLED(DEBUG_LEVELING_FEATURE)
// 12798     if (DEBUGGING(LEVELING)) {
// 12799       DEBUG_POS("AFTER", current_position);
// 12800       SERIAL_ECHOLNPGM("<<< gcode_T");
// 12801     }
// 12802   #endif
// 12803 }
// 12804 
// 12805 /**
// 12806  * Process the parsed command and dispatch it to its handler
// 12807  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock63 Using cfiCommon0
          CFI Function _Z22process_parsed_commandv
        THUMB
// 12808 void process_parsed_command() {
_Z22process_parsed_commandv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
// 12809   KEEPALIVE_STATE(IN_HANDLER);
        LDR.W    R8,??process_parsed_command_0
        MOVS     R0,#+1
        STRB     R0,[R8, #+9]
        SUB      SP,SP,#+28
          CFI CFA R13+64
// 12810 
// 12811   // Handle a known G, M, or T
// 12812   switch (parser.command_letter) {
        LDR.W    R0,??process_parsed_command_0+0x4
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+71
        BEQ.N    ??process_parsed_command_1
        CMP      R0,#+77
        BEQ.W    ??process_parsed_command_2
        CMP      R0,#+84
        BEQ.W    ??process_parsed_command_3
        B.W      ??process_parsed_command_4
// 12813     case 'G': switch (parser.codenum) {
??process_parsed_command_1:
        LDR.W    R0,??process_parsed_command_0+0x8
        LDR      R0,[R0, #+0]
        MOVS     R1,R0
        IT       NE 
        CMPNE    R0,#+1
        BEQ.N    ??process_parsed_command_5
        CMP      R0,#+2
        IT       NE 
        CMPNE    R0,#+3
        BEQ.N    ??process_parsed_command_6
        CMP      R0,#+4
        BEQ.N    ??process_parsed_command_7
        CMP      R0,#+26
        BEQ.N    ??process_parsed_command_8
        CMP      R0,#+28
        BEQ.N    ??process_parsed_command_9
        CMP      R0,#+29
        BEQ.W    ??process_parsed_command_10
        CMP      R0,#+30
        BEQ.W    ??process_parsed_command_11
        CMP      R0,#+42
        BEQ.W    ??process_parsed_command_12
        CMP      R0,#+90
        BEQ.W    ??process_parsed_command_13
        CMP      R0,#+91
        BEQ.W    ??process_parsed_command_14
        CMP      R0,#+92
        BEQ.W    ??process_parsed_command_15
        B.W      ??process_parsed_command_16
// 12814 
// 12815       // G0, G1
// 12816       case 0:
// 12817       case 1:
// 12818         //#if IS_SCARA
// 12819         if(MACHINETPYE&IS_SCARA)
??process_parsed_command_5:
        LDR.W    R2,??process_parsed_command_17
        LDRB     R1,[R2, #+4]
        LDR.W    R2,??process_parsed_command_17+0x4
        LDRH     R2,[R2, #+34]
        MOV      R3,#+768
        TST      R2,R3
        BEQ.N    ??process_parsed_command_18
// 12820           gcode_G0_G1_SCARA(parser.codenum == 0);
        SUBS     R4,R0,#+1
        SBCS     R4,R4,R4
        LSRS     R4,R4,#+31
        CMP      R1,#+0
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        CBZ.N    R4,??process_parsed_command_19
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        BL       _Z42prepare_uninterpolated_move_to_destinationf
        B.W      ??process_parsed_command_16
// 12821         //#else
// 12822         else
// 12823           gcode_G0_G1();
??process_parsed_command_18:
        CMP      R1,#+0
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??process_parsed_command_19:
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
        B.W      ??process_parsed_command_16
// 12824         //#endif
// 12825         break;
// 12826 
// 12827       // G2, G3
// 12828       #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
// 12829         case 2: // G2: CW ARC
// 12830         case 3: // G3: CCW ARC
// 12831           gcode_G2_G3(parser.codenum == 2);
??process_parsed_command_6:
        CMP      R0,#+2
        ITE      EQ 
        MOVEQ    R0,#+1
        MOVNE    R0,#+0
          CFI FunCall _Z11gcode_G2_G3b
        BL       _Z11gcode_G2_G3b
// 12832           break;
        B.W      ??process_parsed_command_16
// 12833       #endif
// 12834 
// 12835       // G4 Dwell
// 12836       case 4:
// 12837         gcode_G4();
??process_parsed_command_7:
        MOVS     R4,#+0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_17+0x8
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_20
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        MOV      R4,R0
??process_parsed_command_20:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_21
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_17+0xC  ;; 0x447a0000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        MOV      R4,R0
??process_parsed_command_21:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOV      R0,R4
          CFI FunCall _Z5dwellm
        BL       _Z5dwellm
// 12838         break;
        B.W      ??process_parsed_command_16
// 12839 
// 12840       #if ENABLED(BEZIER_CURVE_SUPPORT)
// 12841         case 5: // G5: Cubic B_spline
// 12842           gcode_G5();
// 12843           break;
// 12844       #endif // BEZIER_CURVE_SUPPORT
// 12845 
// 12846       #if ENABLED(FWRETRACT)
// 12847         case 10: // G10: retract
// 12848           gcode_G10();
// 12849           break;
// 12850         case 11: // G11: retract_recover
// 12851           gcode_G11();
// 12852           break;
// 12853       #endif // FWRETRACT
// 12854 
// 12855       #if ENABLED(NOZZLE_CLEAN_FEATURE)
// 12856         case 12:
// 12857           gcode_G12(); // G12: Nozzle Clean
// 12858           break;
// 12859       #endif // NOZZLE_CLEAN_FEATURE
// 12860 
// 12861       #if ENABLED(CNC_WORKSPACE_PLANES)
// 12862         case 17: // G17: Select Plane XY
// 12863           gcode_G17();
// 12864           break;
// 12865         case 18: // G18: Select Plane ZX
// 12866           gcode_G18();
// 12867           break;
// 12868         case 19: // G19: Select Plane YZ
// 12869           gcode_G19();
// 12870           break;
// 12871       #endif // CNC_WORKSPACE_PLANES
// 12872 
// 12873       #if ENABLED(INCH_MODE_SUPPORT)
// 12874         case 20: // G20: Inch Mode
// 12875           gcode_G20();
// 12876           break;
// 12877 
// 12878         case 21: // G21: MM Mode
// 12879           gcode_G21();
// 12880           break;
// 12881       #endif // INCH_MODE_SUPPORT
// 12882 
// 12883       //#if ENABLED(G26_MESH_VALIDATION)
// 12884         case 26: // G26: Mesh Validation Pattern generation
// 12885         if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_parsed_command_8:
        LDR.W    R0,??process_parsed_command_17+0x4
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_16
// 12886           gcode_G26();
          CFI FunCall _Z9gcode_G26v
        BL       _Z9gcode_G26v
        B.W      ??process_parsed_command_16
// 12887           break;
// 12888       //#endif // G26_MESH_VALIDATION
// 12889 
// 12890       #if ENABLED(NOZZLE_PARK_FEATURE)
// 12891         case 27: // G27: Nozzle Park
// 12892           gcode_G27();
// 12893           break;
// 12894       #endif // NOZZLE_PARK_FEATURE
// 12895 
// 12896       case 28: // G28: Home all axes, one at a time
// 12897         #if 1
// 12898       	if (gCfgItems.breakpoint_reprint_flg == 1) break;
??process_parsed_command_9:
        LDR.W    R0,??process_parsed_command_17+0x10
        LDRB     R0,[R0, #+344]
        CMP      R0,#+1
        BEQ.W    ??process_parsed_command_16
// 12899         #endif
// 12900         gcode_G28(false);
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
// 12901 		if((BED_LEVELING_METHOD & HAS_LEVELING) && (BED_LEVELING_METHOD != AUTO_BED_LEVELING_UBL))
        LDR.W    R4,??process_parsed_command_17+0x14
        ADDW     R6,R4,#+54
        MOVS     R1,#+62
        LDRB     R0,[R6, #+12]
        TST      R0,R1
        IT       NE 
        CMPNE    R0,#+16
        BEQ.W    ??process_parsed_command_16
// 12902 		{
// 12903 			 set_bed_leveling_enabled(true);
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
// 12904 			#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
// 12905 				if((MACHINETPYE != DELTA) && (BED_LEVELING_METHOD&HAS_FADE))	//mks_delta
        LDRSH    R0,[R6, #+34]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_16
        LDRB     R0,[R6, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_16
// 12906 				 { 
// 12907 				 	if (parser.seenval('Z')) set_z_fade_height(parser.value_linear_units()/*code_value_linear_units()*/);
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
// 12908 				 }
// 12909 			#endif
// 12910           }
        MOVS     R1,#+1
          CFI FunCall _Z17set_z_fade_heightfb
        BL       _Z17set_z_fade_heightfb
        B.W      ??process_parsed_command_16
// 12911         break;
// 12912 
// 12913       //#if HAS_LEVELING
// 12914         case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
// 12915                  // or provides access to the UBL System if enabled.
// 12916 		if(BED_LEVELING_METHOD&HAS_LEVELING)	 
??process_parsed_command_10:
        LDR.W    R4,??process_parsed_command_17+0x14
        ADDW     R6,R4,#+54
        MOVS     R1,#+62
        LDRB     R0,[R6, #+12]
        TST      R0,R1
        BEQ.N    ??process_parsed_command_22
// 12917 		{
// 12918 			switch(BED_LEVELING_METHOD)	 /*--mks cfg-- MESH_BED_LEVELING */ 
        CMP      R0,#+2
        ITT      NE 
        CMPNE    R0,#+4
        CMPNE    R0,#+8
        BEQ.N    ??process_parsed_command_23
        CMP      R0,#+16
        BEQ.N    ??process_parsed_command_24
        CMP      R0,#+32
        BNE.N    ??process_parsed_command_25
// 12919 			{
// 12920 				case MESH_BED_LEVELING:
// 12921 					gcode_G29_MESH_BED_LEVELING();
          CFI FunCall _Z27gcode_G29_MESH_BED_LEVELINGv
        BL       _Z27gcode_G29_MESH_BED_LEVELINGv
// 12922 					(void)settings.save();
        B.W      ??process_parsed_command_26
// 12923 				break;
// 12924 				case AUTO_BED_LEVELING_3POINT:
// 12925 				case AUTO_BED_LEVELING_LINEAR:
// 12926 				case AUTO_BED_LEVELING_BILINEAR:
// 12927 					gcode_G29();
??process_parsed_command_23:
          CFI FunCall _Z9gcode_G29v
        BL       _Z9gcode_G29v
// 12928 					(void)settings.save();
        B.W      ??process_parsed_command_26
// 12929 				break;
// 12930 				case AUTO_BED_LEVELING_UBL:
// 12931 					gcode_G29_UBL();
??process_parsed_command_24:
          CFI FunCall _ZN20unified_bed_leveling13gcode_G29_UBLEv
        BL       _ZN20unified_bed_leveling13gcode_G29_UBLEv
// 12932 				break;
        B.W      ??process_parsed_command_16
// 12933 				default:
// 12934 					SERIAL_PROTOCOL("bed leveling hasn't defined!");
??process_parsed_command_25:
        LDR.W    R5,??process_parsed_command_27
        LDR.W    R1,??process_parsed_command_27+0x4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
// 12935 					SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R5
        B.W      ??process_parsed_command_28
// 12936 				break;
// 12937 			}
// 12938 		}
// 12939 		else
// 12940 		{
// 12941 			SERIAL_PROTOCOL("bed leveling hasn't defined!");
??process_parsed_command_22:
        LDR.W    R5,??process_parsed_command_27
        LDR.W    R1,??process_parsed_command_27+0x4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
// 12942 			SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R5
        B.W      ??process_parsed_command_28
// 12943 		}
// 12944 
// 12945         break;
// 12946       //#endif // HAS_LEVELING
// 12947 
// 12948       #if HAS_BED_PROBE
// 12949 
// 12950         case 30: // G30 Single Z probe
// 12951           gcode_G30();
??process_parsed_command_11:
        LDR.W    R4,??process_parsed_command_17+0x14
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_29
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        B.N      ??process_parsed_command_30
??process_parsed_command_29:
        LDR.W    R0,??process_parsed_command_17
        LDR      R1,[R0, #+16]
        LDR      R0,[R4, #+108]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
??process_parsed_command_30:
        STR      R0,[SP, #+8]
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_31
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        B.N      ??process_parsed_command_32
??process_parsed_command_31:
        LDR.W    R0,??process_parsed_command_17
        LDR      R1,[R0, #+20]
        LDR      R0,[R4, #+112]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
??process_parsed_command_32:
        STR      R0,[SP, #+4]
        ADDW     R6,R4,#+54
        MOVW     R1,#+770
        LDRH     R0,[R6, #+34]
        TST      R0,R1
        BEQ.N    ??process_parsed_command_33
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        BL       _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
??process_parsed_command_33:
        LDRB     R0,[R6, #+12]
        MOVS     R1,#+62
        TST      R0,R1
        ITT      NE 
        MOVNE    R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BLNE     _Z24set_bed_leveling_enabledb
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_34
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        MVNS     R2,R2
        LSRS     R2,R2,#+31
        B.N      ??process_parsed_command_35
??process_parsed_command_34:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R2,R0
??process_parsed_command_35:
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        MOVS     R3,#+1
        ADD      R1,SP,#+4
        ADD      R0,SP,#+8
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
        MOV      R7,R0
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??process_parsed_command_36
        LDR      R0,[SP, #+8]
        LDR.W    R4,??process_parsed_command_27+0x8  ;; 0x88e368f1
        LDR.W    R5,??process_parsed_command_27+0xC  ;; 0x3ee4f8b5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??process_parsed_command_27+0x10
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??process_parsed_command_27+0x14
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??process_parsed_command_27+0x18
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR.W    R0,??process_parsed_command_27
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??process_parsed_command_36:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        B.W      ??process_parsed_command_16
// 12952           break;
// 12953 
// 12954         #if ENABLED(Z_PROBE_SLED)
// 12955 
// 12956             case 31: // G31: dock the sled
// 12957               gcode_G31();
// 12958               break;
// 12959 
// 12960             case 32: // G32: undock the sled
// 12961               gcode_G32();
// 12962               break;
// 12963 
// 12964         #endif // Z_PROBE_SLED
// 12965 
// 12966       #endif // HAS_BED_PROBE
// 12967 
// 12968       #if ENABLED(DELTA_AUTO_CALIBRATION)
// 12969 
// 12970         case 33: // G33: Delta Auto-Calibration
// 12971           gcode_G33();
// 12972           break;
// 12973 
// 12974       #endif // DELTA_AUTO_CALIBRATION
// 12975 
// 12976       #if ENABLED(G38_PROBE_TARGET)
// 12977         case 38: // G38.2 & G38.3
// 12978           if (parser.subcode == 2 || parser.subcode == 3)
// 12979             gcode_G38(parser.subcode == 2);
// 12980           break;
// 12981       #endif
// 12982 
// 12983       case 90: // G90
// 12984         relative_mode = false;
??process_parsed_command_13:
        MOVS     R0,#+0
        B.N      ??process_parsed_command_37
// 12985         break;
// 12986       case 91: // G91
// 12987         relative_mode = true;
??process_parsed_command_14:
        MOVS     R0,#+1
??process_parsed_command_37:
        LDR.W    R1,??process_parsed_command_17
        STRB     R0,[R1, #+11]
// 12988         break;
        B.W      ??process_parsed_command_16
// 12989 
// 12990       case 92: // G92
// 12991         gcode_G92();
??process_parsed_command_15:
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
// 12992         break;
        B.W      ??process_parsed_command_16
// 12993 
// 12994       #if HAS_MESH
// 12995         case 42:
// 12996           gcode_G42();
??process_parsed_command_12:
          CFI FunCall _Z9gcode_G42v
        BL       _Z9gcode_G42v
// 12997           break;
        B.W      ??process_parsed_command_16
// 12998       #endif
// 12999 
// 13000       #if ENABLED(DEBUG_GCODE_PARSER)
// 13001         case 800:
// 13002           parser.debug(); // GCode Parser Test for G
// 13003           break;
// 13004       #endif
// 13005     }
// 13006     break;
// 13007 
// 13008     case 'M': switch (parser.codenum) {
??process_parsed_command_2:
        LDR.W    R0,??process_parsed_command_0+0x8
        LDR      R0,[R0, #+0]
        SUBS     R0,R0,#+17
        BEQ.W    ??process_parsed_command_38
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_39
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_40
        SUBS     R0,R0,#+1
        CMP      R0,#+1
        BLS.W    ??process_parsed_command_41
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_42
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_43
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_44
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_45
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_46
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_47
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_48
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_49
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_50
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_51
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_52
        SUBS     R0,R0,#+26
        BEQ.W    ??process_parsed_command_53
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_54
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_55
        SUBS     R0,R0,#+4
        BEQ.W    ??process_parsed_command_56
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_57
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_58
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_39
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_59
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_60
        SUBS     R0,R0,#+12
        BEQ.W    ??process_parsed_command_61
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_62
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_63
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_64
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_65
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_66
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_67
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_68
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_69
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_70
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_71
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_72
        SUBS     R0,R0,#+3
        BEQ.W    ??process_parsed_command_73
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_74
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_75
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_76
        SUBS     R0,R0,#+19
        BEQ.W    ??process_parsed_command_77
        SUBS     R0,R0,#+15
        BEQ.W    ??process_parsed_command_78
        SUBS     R0,R0,#+35
        BEQ.W    ??process_parsed_command_79
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_80
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_81
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_82
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_83
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_84
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_85
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_86
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_87
        SUBS     R0,R0,#+2
        BEQ.W    ??process_parsed_command_88
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_89
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_90
        SUBS     R0,R0,#+54
        BEQ.W    ??process_parsed_command_91
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_92
        SUBS     R0,R0,#+11
        BEQ.W    ??process_parsed_command_93
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_94
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_95
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_96
        SUBS     R0,R0,#+51
        BEQ.W    ??process_parsed_command_97
        SUBS     R0,R0,#+5
        BEQ.W    ??process_parsed_command_98
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_99
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_100
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_101
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_102
        SUBS     R0,R0,#+36
        BEQ.W    ??process_parsed_command_103
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_104
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_105
        SUBS     R0,R0,#+8
        BEQ.W    ??process_parsed_command_106
        SUBS     R0,R0,#+10
        BEQ.W    ??process_parsed_command_107
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_108
        SUBS     R0,R0,#+7
        BEQ.W    ??process_parsed_command_109
        SUBS     R0,R0,#+72
        BEQ.W    ??process_parsed_command_26
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_110
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_111
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_112
        SUBS     R0,R0,#+162
        BEQ.W    ??process_parsed_command_113
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_114
        SUBS     R0,R0,#+185
        BEQ.W    ??process_parsed_command_115
        SUBS     R0,R0,#+77
        BEQ.W    ??process_parsed_command_116
        SUBS     R0,R0,#+70
        BEQ.N    ??process_parsed_command_117
        SUBS     R0,R0,#+1
        BEQ.W    ??process_parsed_command_118
        B.W      ??process_parsed_command_16
// 13009       #if HAS_RESUME_CONTINUE
// 13010         case 0: // M0: Unconditional stop - Wait for user button press on LCD
// 13011         case 1: // M1: Conditional stop - Wait for user button press on LCD
// 13012           gcode_M0_M1();
// 13013           break;
// 13014       #endif // ULTIPANEL
// 13015 
// 13016       #if ENABLED(SPINDLE_LASER_ENABLE)
// 13017         case 3:
// 13018           gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
// 13019           break;               // synchronizes with movement commands
// 13020         case 4:
// 13021           gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
// 13022           break;               // synchronizes with movement commands
// 13023         case 5:
// 13024           gcode_M5();     // M5 - turn spindle/laser off
// 13025           break;          // synchronizes with movement commands
// 13026       #endif
// 13027       case 17: // M17: Enable all stepper motors
// 13028         gcode_M17();
??process_parsed_command_38:
          CFI FunCall _Z19enable_all_steppersv
        BL       _Z19enable_all_steppersv
// 13029         break;
        B.W      ??process_parsed_command_16
// 13030 
// 13031       #if ENABLED(SDSUPPORT)
// 13032         case 20: // M20: list SD card
// 13033           gcode_M20(); break;
??process_parsed_command_40:
        LDR.W    R0,??process_parsed_command_119
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??process_parsed_command_119+0x4
          CFI FunCall _ZN10CardReader2lsEv
        BL       _ZN10CardReader2lsEv
        LDR.W    R0,??process_parsed_command_119+0x8
        B.W      ??process_parsed_command_120
// 13034         case 21: // M21: init SD card
// 13035           //gcode_M21(); break;
// 13036         case 22: // M22: release SD card
// 13037           gcode_M22(); break;
??process_parsed_command_41:
        LDR.W    R0,??process_parsed_command_119+0x4
          CFI FunCall _ZN10CardReader7releaseEv
        BL       _ZN10CardReader7releaseEv
        B.W      ??process_parsed_command_16
// 13038         case 23: // M23: Select file
// 13039           gcode_M23(); break;
??process_parsed_command_42:
        LDR.W    R0,??process_parsed_command_119+0xC
        LDR      R1,[R0, #+0]
        B.N      ??process_parsed_command_121
??process_parsed_command_122:
        CMP      R2,#+32
        ITT      EQ 
        MOVEQ    R2,#+0
        STRBEQ   R2,[R1, #+0]
        ADDS     R1,R1,#+1
??process_parsed_command_121:
        LDRSB    R2,[R1, #+0]
        CMP      R2,#+0
        BNE.N    ??process_parsed_command_122
        LDR      R1,[R0, #+0]
        LDR.W    R4,??process_parsed_command_119+0x4
        MOVS     R3,#+1
        MOVS     R2,#+1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        ADDW     R1,R4,#+1916
        LDR.W    R0,??process_parsed_command_119+0x10
          CFI FunCall strcpy
        BL       strcpy
        B.W      ??process_parsed_command_16
// 13040         case 24: // M24: Start SD print
// 13041           gcode_M24(); 
??process_parsed_command_43:
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
// 13042 
// 13043           if(mksReprint.mks_printer_state == MKS_WORKING)
        LDR.W    R0,??process_parsed_command_119+0x4
        LDRB     R0,[R0, #+2068]
        CMP      R0,#+167
        BNE.W    ??process_parsed_command_16
// 13044           {
// 13045             clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 13046             reset_file_info();
          CFI FunCall reset_file_info
        BL       reset_file_info
// 13047             reset_print_time();
          CFI FunCall reset_print_time
        BL       reset_print_time
// 13048             start_print_time();
          CFI FunCall start_print_time
        BL       start_print_time
// 13049             #if defined(TFT35)
// 13050             preview_gcode_prehandle(curFileName);
        LDR.W    R0,??process_parsed_command_119+0x10
          CFI FunCall preview_gcode_prehandle
        BL       preview_gcode_prehandle
// 13051             #endif
// 13052             draw_printing();            
        B.N      ??process_parsed_command_123
// 13053            }
// 13054           break;
// 13055         case 25: // M25: Pause SD print
// 13056             gcode_M25(); 
??process_parsed_command_44:
        LDR.W    R4,??process_parsed_command_119+0x4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
        LDR.W    R0,??process_parsed_command_17
        ADD      R5,R0,#+132
        MOV      R0,R5
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        MOVS     R0,#+169
        STRB     R0,[R4, #+2068]
// 13057             if(mksReprint.mks_printer_state == MKS_PAUSING)
// 13058             {
// 13059             	stop_print_time();							
          CFI FunCall stop_print_time
        BL       stop_print_time
// 13060             	clear_cur_ui();
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 13061             
// 13062             	card.pauseSDPrint();
        MOV      R0,R4
          CFI FunCall _ZN10CardReader12pauseSDPrintEv
        BL       _ZN10CardReader12pauseSDPrintEv
// 13063             	print_job_timer.pause();
        MOV      R0,R5
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
// 13064 		#if defined(TFT35)
// 13065             	if(from_flash_pic==1)
        LDR.W    R0,??process_parsed_command_124
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        ITEE     EQ 
// 13066             		flash_preview_begin = 1;
        LDREQ.W  R1,??process_parsed_command_124+0x4
// 13067             	else
// 13068             		default_preview_flg = 1;							
        MOVNE    R0,#+1
        LDRNE.W  R1,??process_parsed_command_124+0x8
        STRB     R0,[R1, #+0]
// 13069 
// 13070             	draw_printing();
??process_parsed_command_123:
          CFI FunCall draw_printing
        BL       draw_printing
        B.W      ??process_parsed_command_16
// 13071                #else
// 13072                draw_pause();
// 13073 		#endif
// 13074             }          
// 13075           break;
// 13076         case 998:	//M998: Stop SD print
// 13077           gcode_M998(); break;			  
??process_parsed_command_117:
        LDR.W    R4,??process_parsed_command_119+0x4
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+172
        BEQ.W    ??process_parsed_command_16
        MOVS     R0,#+166
        STRB     R0,[R4, #+2068]
        LDR.W    R0,??process_parsed_command_17+0x10
        LDRB     R0,[R0, #+431]
        CMP      R0,#+1
        BEQ.N    ??process_parsed_command_125
        MOVS     R2,#+1
        ADDW     R1,R4,#+2068
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??process_parsed_command_125:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader11stopSDPrintEv
        BL       _ZN10CardReader11stopSDPrintEv
        LDR.W    R4,??process_parsed_command_17
        LDRB     R0,[R4, #+8]
        STRB     R0,[R4, #+7]
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        ADD      R0,R4,#+132
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        MOVS     R0,#+0
        LDR.W    R1,??process_parsed_command_126  ;; 0x40000440
        STR      R0,[R4, #+116]
        STR      R0,[R1, #+0]
        STRB     R0,[R4, #+12]
        B.W      ??process_parsed_command_16
// 13078         case 26: // M26: Set SD index
// 13079           gcode_M26(); break;
??process_parsed_command_45:
        LDR.W    R4,??process_parsed_command_119+0x4
        ADD      R0,R4,#+1888
        LDRB     R0,[R0, #+3]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_17+0x8
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        STR      R0,[R4, #+1120]
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall f_lseek
        BL       f_lseek
        B.W      ??process_parsed_command_16
// 13080         case 27: // M27: Get SD status
// 13081           gcode_M27(); break;
??process_parsed_command_46:
        LDR.W    R0,??process_parsed_command_119+0x4
          CFI FunCall _ZN10CardReader9getStatusEv
        BL       _ZN10CardReader9getStatusEv
        B.W      ??process_parsed_command_16
// 13082         case 28: // M28: Start SD write
// 13083           gcode_M28(); break;
??process_parsed_command_47:
        LDR.W    R0,??process_parsed_command_119+0xC
        LDR      R1,[R0, #+0]
        LDR.W    R0,??process_parsed_command_119+0x4
        MOVS     R3,#+1
        MOVS     R2,#+0
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        B.W      ??process_parsed_command_16
// 13084         case 29: // M29: Stop SD write
// 13085           gcode_M29(); break;
// 13086         case 30: // M30 <filename> Delete File
// 13087           gcode_M30(); break;
??process_parsed_command_48:
        LDR.W    R4,??process_parsed_command_119+0x4
        ADD      R0,R4,#+1888
        LDRB     R0,[R0, #+3]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R1,#+0
        MOV      R0,R4
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
        LDR.W    R0,??process_parsed_command_119+0xC
        LDR      R1,[R0, #+0]
        MOV      R0,R4
          CFI FunCall _ZN10CardReader10removeFileEPc
        BL       _ZN10CardReader10removeFileEPc
        B.W      ??process_parsed_command_16
// 13088         case 32: // M32: Select file and start SD print
// 13089           gcode_M32(); break;
??process_parsed_command_50:
        LDR.W    R4,??process_parsed_command_119+0x4
        LDRB     R0,[R4, #+1888]
        CBZ.N    R0,??process_parsed_command_127
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??process_parsed_command_127:
        ADDW     R0,R4,#+1888
        LDRB     R1,[R0, #+3]
        LDRB     R0,[R0, #+4]
        ORRS     R0,R0,R1
        BEQ.W    ??process_parsed_command_16
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_128
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R5,R0,#+1
        SBCS     R5,R5,R5
        MVNS     R5,R5
        LSRS     R5,R5,#+31
        B.N      ??process_parsed_command_129
??process_parsed_command_128:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R5,R0
??process_parsed_command_129:
        LDR.W    R0,??process_parsed_command_119+0xC
        LDR      R1,[R0, #+0]
        MOV      R3,R5
        MOVS     R2,#+1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_17+0x8
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_130
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        STR      R0,[R4, #+1120]
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall f_lseek
        BL       f_lseek
??process_parsed_command_130:
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        CMP      R5,#+0
        BNE.W    ??process_parsed_command_16
        B.N      ??process_parsed_command_53
// 13090 
// 13091         #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
// 13092           case 33: // M33: Get the long full path to a file or folder
// 13093             gcode_M33(); break;
// 13094         #endif
// 13095 
// 13096         #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
// 13097           case 34: // M34: Set SD card sorting options
// 13098             gcode_M34(); break;
// 13099         #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
// 13100 
// 13101         case 928: // M928: Start SD write
// 13102           gcode_M928(); break;
??process_parsed_command_116:
        LDR.W    R0,??process_parsed_command_119+0xC
        LDR      R1,[R0, #+0]
        LDR.W    R0,??process_parsed_command_119+0x4
          CFI FunCall _ZN10CardReader11openLogFileEPc
        BL       _ZN10CardReader11openLogFileEPc
        B.W      ??process_parsed_command_16
// 13103       #endif // SDSUPPORT
// 13104 
// 13105       case 31: // M31: Report time since the start of SD print or last M109
// 13106         gcode_M31(); break;
??process_parsed_command_49:
        LDR.W    R0,??process_parsed_command_131
          CFI FunCall _ZN9Stopwatch8durationEv
        BL       _ZN9Stopwatch8durationEv
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _ZNK10duration_t8toStringEPc
        BL       _ZNK10duration_t8toStringEPc
        LDR.W    R0,??process_parsed_command_131+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      R1,SP,#+4
        LDR.W    R0,??process_parsed_command_132
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        B.W      ??process_parsed_command_133
// 13107 
// 13108       case 42: // M42: Change pin state
// 13109         gcode_M42(); break;
??process_parsed_command_51:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_17+0x8
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_134
        LDR      R0,[R7, #+0]
        CBZ.N    R0,??process_parsed_command_135
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R5,R0
        B.N      ??process_parsed_command_136
??process_parsed_command_135:
        MOVS     R5,#+0
        B.N      ??process_parsed_command_136
??process_parsed_command_134:
        MOV      R5,#-1
??process_parsed_command_136:
        SXTH     R5,R5
        CMP      R5,#+0
        BMI.W    ??process_parsed_command_16
        SXTB     R0,R5
        MOVS     R1,#+0
        LDR.W    R2,??process_parsed_command_132+0x4
??process_parsed_command_137:
        LDRSB    R3,[R2], #+1
        CMP      R0,R3
        ITT      NE 
        LDRSBNE  R3,[R2], #+1
        CMPNE    R0,R3
        ITT      NE 
        LDRSBNE  R3,[R2], #+1
        CMPNE    R0,R3
        BEQ.N    ??process_parsed_command_138
        ADDS     R1,R1,#+3
        UXTB     R1,R1
        CMP      R1,#+51
        BCC.N    ??process_parsed_command_137
        LDR.W    R0,??process_parsed_command_139
        LDRH     R1,[R0, R5, LSL #+1]
        LDR.W    R0,??process_parsed_command_139+0x4
        LDR      R0,[R0, R5, LSL #+2]
        SXTB     R2,R4
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        CMP      R5,#+17
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??process_parsed_command_17
        STR      R4,[R0, #+116]
        B.W      ??process_parsed_command_16
??process_parsed_command_138:
        LDR.W    R0,??process_parsed_command_139+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??process_parsed_command_139+0xC
        B.W      ??process_parsed_command_120
// 13110 
// 13111       #if ENABLED(PINS_DEBUGGING)
// 13112         case 43: // M43: Read pin state
// 13113           gcode_M43(); break;
// 13114       #endif
// 13115 
// 13116 
// 13117       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
// 13118         case 48: // M48: Z probe repeatability test
// 13119           gcode_M48();
// 13120           break;
// 13121       #endif // Z_MIN_PROBE_REPEATABILITY_TEST
// 13122 
// 13123       //#if ENABLED(G26_MESH_VALIDATION)
// 13124         case 49: // M49: Turn on or off G26 debug flag for verbose output
// 13125         if(BED_LEVELING_METHOD&AUTO_BED_LEVELING_UBL)
??process_parsed_command_52:
        LDR.W    R0,??process_parsed_command_17+0x4
        LDRB     R0,[R0, #+12]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_16
// 13126           gcode_M49();
        LDRB     R0,[R8, #+8]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[R8, #+8]
        LDR.W    R0,??process_parsed_command_140
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R8, #+8]
        CMP      R0,#+0
        ITE      EQ 
        LDREQ.W  R0,??process_parsed_command_140+0x4
        LDRNE.W  R0,??process_parsed_command_140+0x8
        B.W      ??process_parsed_command_120
// 13127           break;
// 13128       //#endif // G26_MESH_VALIDATION
// 13129 
// 13130       #if ENABLED(ULTRA_LCD) && ENABLED(LCD_SET_PROGRESS_MANUALLY)
// 13131         case 73: // M73: Set print progress percentage
// 13132           gcode_M73(); break;
// 13133       #endif
// 13134 
// 13135       case 75: // M75: Start print timer
// 13136         gcode_M75(); break;
??process_parsed_command_53:
        LDR.W    R0,??process_parsed_command_131
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
        B.W      ??process_parsed_command_16
// 13137       case 76: // M76: Pause print timer
// 13138         gcode_M76(); break;
??process_parsed_command_54:
        LDR.W    R0,??process_parsed_command_131
          CFI FunCall _ZN9Stopwatch5pauseEv
        BL       _ZN9Stopwatch5pauseEv
        B.W      ??process_parsed_command_16
// 13139       case 77: // M77: Stop print timer
// 13140         gcode_M77(); break;
??process_parsed_command_55:
        LDR.W    R0,??process_parsed_command_131
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        B.W      ??process_parsed_command_16
// 13141 
// 13142       #if ENABLED(PRINTCOUNTER)
// 13143         case 78: // M78: Show print statistics
// 13144           gcode_M78(); break;
// 13145       #endif
// 13146 
// 13147       #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13148         case 100: // M100: Free Memory Report
// 13149           gcode_M100();
// 13150           break;
// 13151       #endif
// 13152 
// 13153       case 104: // M104: Set hot end temperature
// 13154         gcode_M104();
??process_parsed_command_61:
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
// 13155         break;
        B.W      ??process_parsed_command_16
// 13156 
// 13157       case 110: // M110: Set Current Line Number
// 13158         gcode_M110();
??process_parsed_command_67:
        MOVS     R0,#+78
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_17+0x8
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        LDR.W    R1,??process_parsed_command_17
        STR      R0,[R1, #+108]
        B.W      ??process_parsed_command_16
// 13159         break;
// 13160 
// 13161       case 111: // M111: Set debug level
// 13162         gcode_M111();
??process_parsed_command_68:
        LDR.W    R0,??process_parsed_command_140+0xC
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_141
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_17+0x8
        LDRB     R0,[R5, #+18]
        CBZ.N    R0,??process_parsed_command_142
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_142:
        STR      R0,[R7, #+0]
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_143
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
??process_parsed_command_143:
        LDR.W    R1,??process_parsed_command_17
        STRB     R0,[R1, #+5]
??process_parsed_command_141:
        LDR.W    R0,??process_parsed_command_131+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??process_parsed_command_140+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R9,??process_parsed_command_17
        LDRB     R0,[R9, #+5]
        CBZ.N    R0,??process_parsed_command_144
        LDR.W    R10,??process_parsed_command_140+0x1C
        LDR.W    R5,??process_parsed_command_27
        MOVS     R6,#+0
        MOVS     R4,#+0
        MOVS     R7,#+1
??process_parsed_command_145:
        LDRB     R0,[R9, #+5]
        LSL      R1,R7,R4
        TST      R0,R1
        BEQ.N    ??process_parsed_command_146
        MOV      R0,R6
        ADDS     R6,R0,#+1
        UXTB     R0,R0
        CBZ.N    R0,??process_parsed_command_147
        MOVS     R1,#+44
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??process_parsed_command_147:
        MOV      R11,R10
        B.N      ??process_parsed_command_148
??process_parsed_command_149:
        UXTB     R1,R1
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??process_parsed_command_148:
        LDRSB    R1,[R11], #+1
        MOVS     R0,R1
        BNE.N    ??process_parsed_command_149
??process_parsed_command_146:
        ADDS     R4,R4,#+1
        ADD      R10,R10,#+4
        CMP      R4,#+5
        BCS.W    ??process_parsed_command_133
        B.N      ??process_parsed_command_145
??process_parsed_command_144:
        LDR.W    R0,??process_parsed_command_140+0x20
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.W      ??process_parsed_command_133
// 13163         break;
// 13164 
// 13165       #if DISABLED(EMERGENCY_PARSER)
// 13166 
// 13167         case 108: // M108: Cancel Waiting
// 13168           gcode_M108();
??process_parsed_command_65:
        LDR.W    R1,??process_parsed_command_17
        STRB     R0,[R1, #+12]
// 13169           break;
        B.W      ??process_parsed_command_16
// 13170 
// 13171         case 112: // M112: Emergency Stop
// 13172           gcode_M112();
??process_parsed_command_69:
        LDR.W    R0,??process_parsed_command_150
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 13173           break;
        B.W      ??process_parsed_command_16
// 13174 
// 13175         case 410: // M410 quickstop - Abort all the planned moves.
// 13176           gcode_M410();
??process_parsed_command_106:
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
// 13177           break;
        B.W      ??process_parsed_command_16
// 13178 
// 13179       #endif
// 13180 
// 13181       #if ENABLED(HOST_KEEPALIVE_FEATURE)
// 13182         case 113: // M113: Set Host Keepalive interval
// 13183           gcode_M113();
??process_parsed_command_70:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_151
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        STRB     R0,[R8, #+10]
        CMP      R0,#+61
        BLT.W    ??process_parsed_command_16
        MOVS     R0,#+60
        STRB     R0,[R8, #+10]
        B.W      ??process_parsed_command_16
??process_parsed_command_151:
        LDR.W    R0,??process_parsed_command_131+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R1,[R8, #+10]
        LDR.W    R0,??process_parsed_command_152
          CFI FunCall _Z17serial_echopair_PPKcm
        BL       _Z17serial_echopair_PPKcm
        B.W      ??process_parsed_command_133
// 13184           break;
// 13185       #endif
// 13186 
// 13187       case 140: // M140: Set bed temperature
// 13188       if(HAS_TEMP_BED)	/*--mks cfg-- HAS_TEMP_BED --*/
??process_parsed_command_77:
        LDR.W    R0,??process_parsed_command_17+0x4
        LDRB     R0,[R0, #+2]
        CBZ.N    R0,??process_parsed_command_153
// 13189         gcode_M140();
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
        B.W      ??process_parsed_command_16
// 13190         else
// 13191           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!"); 	  
??process_parsed_command_153:
        LDR.W    R0,??process_parsed_command_152+0x4
        B.W      ??process_parsed_command_120
// 13192         break;
// 13193 
// 13194       case 105: // M105: Report current temperature
// 13195         gcode_M105();
??process_parsed_command_62:
        MOVS     R0,#+105
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CBNZ.N   R0,??process_parsed_command_154
        LDR.W    R0,??process_parsed_command_152+0x8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.W    R0,??process_parsed_command_27
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13196         KEEPALIVE_STATE(NOT_BUSY);
??process_parsed_command_154:
        MOVS     R0,#+0
        STRB     R0,[R8, #+9]
// 13197         return; // "ok" already printed
// 13198 
// 13199      // #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 13200      #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)
// 13201         case 155: // M155: Set temperature auto-report interval
// 13202           gcode_M155();
// 13203           break;
// 13204       #endif
// 13205 
// 13206       case 109: // M109: Wait for hotend temperature to reach target
// 13207         gcode_M109();
// 13208         break;
// 13209 
// 13210       //#if HAS_TEMP_BED
// 13211         case 190: // M190: Wait for bed temperature to reach target
// 13212         if(HAS_TEMP_BED) 
// 13213           gcode_M190();
// 13214 		else
// 13215           SERIAL_PROTOCOLLNPGM("HAS_NO_TEMP_BED!");
// 13216           break;
// 13217       //#endif // HAS_TEMP_BED
// 13218 
// 13219       #if FAN_COUNT > 0
// 13220         case 106: // M106: Fan On
// 13221           gcode_M106();
// 13222           break;
// 13223         case 107: // M107: Fan Off
// 13224           gcode_M107();
// 13225           break;
// 13226       #endif // FAN_COUNT > 0
// 13227 
// 13228       #if ENABLED(PARK_HEAD_ON_PAUSE)
// 13229         case 125: // M125: Store current position and move to filament change position
// 13230           gcode_M125(); break;
// 13231       #endif
// 13232 
// 13233       #if ENABLED(BARICUDA)
// 13234         // PWM for HEATER_1_PIN
// 13235         #if HAS_HEATER_1
// 13236           case 126: // M126: valve open
// 13237             gcode_M126();
// 13238             break;
// 13239           case 127: // M127: valve closed
// 13240             gcode_M127();
// 13241             break;
// 13242         #endif // HAS_HEATER_1
// 13243 
// 13244         // PWM for HEATER_2_PIN
// 13245         #if HAS_HEATER_2
// 13246           case 128: // M128: valve open
// 13247             gcode_M128();
// 13248             break;
// 13249           case 129: // M129: valve closed
// 13250             gcode_M129();
// 13251             break;
// 13252         #endif // HAS_HEATER_2
// 13253       #endif // BARICUDA
// 13254 
// 13255       #if HAS_POWER_SWITCH
// 13256 
// 13257         case 80: // M80: Turn on Power Supply
// 13258           gcode_M80();
// 13259           break;
// 13260 
// 13261       #endif // HAS_POWER_SWITCH
// 13262 
// 13263       case 81: // M81: Turn off Power, including Power Supply, if possible
// 13264         gcode_M81();
// 13265         break;
// 13266 
// 13267       case 82: // M82: Set E axis normal mode (same as other axes)
// 13268         gcode_M82();
// 13269         break;
// 13270       case 83: // M83: Set E axis relative mode
// 13271         gcode_M83();
// 13272         break;
// 13273       case 18: // M18 => M84
// 13274       case 84: // M84: Disable all steppers or set timeout
// 13275         gcode_M18_M84();
// 13276         break;
// 13277       case 85: // M85: Set inactivity stepper shutdown timeout
// 13278         gcode_M85();
// 13279         break;
// 13280       case 92: // M92: Set the steps-per-unit for one or more axes
// 13281         gcode_M92();
// 13282         break;
// 13283       case 114: // M114: Report current position
// 13284         gcode_M114();
// 13285         break;
// 13286       case 115: // M115: Report capabilities
// 13287         gcode_M115();
// 13288         break;
// 13289       case 117: // M117: Set LCD message text, if possible
// 13290         gcode_M117();
// 13291         break;
// 13292       case 118: // M118: Display a message in the host console
// 13293         gcode_M118();
// 13294         break;
// 13295       case 119: // M119: Report endstop states
// 13296         gcode_M119();
// 13297         break;
// 13298       case 120: // M120: Enable endstops
// 13299         gcode_M120();
// 13300         break;
// 13301       case 121: // M121: Disable endstops
// 13302         gcode_M121();
// 13303         break;
// 13304 
// 13305       #if ENABLED(ULTIPANEL)
// 13306 
// 13307         case 145: // M145: Set material heatup parameters
// 13308           gcode_M145();
// 13309           break;
// 13310 
// 13311       #endif
// 13312 
// 13313       #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
// 13314         case 149: // M149: Set temperature units
// 13315           gcode_M149();
// 13316           break;
// 13317       #endif
// 13318 
// 13319       #if HAS_COLOR_LEDS
// 13320 
// 13321         case 150: // M150: Set Status LED Color
// 13322           gcode_M150();
// 13323           break;
// 13324 
// 13325       #endif // HAS_COLOR_LEDS
// 13326 
// 13327       #if ENABLED(MIXING_EXTRUDER)
// 13328         case 163: // M163: Set a component weight for mixing extruder
// 13329           gcode_M163();
// 13330           break;
// 13331         #if MIXING_VIRTUAL_TOOLS > 1
// 13332           case 164: // M164: Save current mix as a virtual extruder
// 13333             gcode_M164();
// 13334             break;
// 13335         #endif
// 13336         #if ENABLED(DIRECT_MIXING_IN_G1)
// 13337           case 165: // M165: Set multiple mix weights
// 13338             gcode_M165();
// 13339             break;
// 13340         #endif
// 13341       #endif
// 13342 
// 13343       #if DISABLED(NO_VOLUMETRICS)
// 13344         case 200: // M200: Set filament diameter, E to cubic units
// 13345           gcode_M200();
// 13346           break;
// 13347       #endif
// 13348 
// 13349       case 201: // M201: Set max acceleration for print moves (units/s^2)
// 13350         gcode_M201();
// 13351         break;
// 13352       #if 0 // Not used for Sprinter/grbl gen6
// 13353         case 202: // M202
// 13354           gcode_M202();
// 13355           break;
// 13356       #endif
// 13357       case 203: // M203: Set max feedrate (units/sec)
// 13358         gcode_M203();
// 13359         break;
// 13360       case 204: // M204: Set acceleration
// 13361         gcode_M204();
// 13362         break;
// 13363       case 205: // M205: Set advanced settings
// 13364         gcode_M205();
// 13365         break;
// 13366 
// 13367       //#if HAS_M206_COMMAND
// 13368         case 206: // M206: Set home offsets
// 13369         if(MACHINETPYE != DELTA)
// 13370           gcode_M206();
// 13371           break;
// 13372       //#endif
// 13373 
// 13374       //#if ENABLED(DELTA)
// 13375         case 665: // M665: Set delta configurations
// 13376         if(MACHINETPYE == DELTA)
// 13377           gcode_M665();
// 13378           break;
// 13379       //#endif
// 13380 
// 13381       //#if ENABLED(DELTA) || ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
// 13382         case 666: // M666: Set delta or dual endstop adjustment
// 13383         if(MACHINETPYE == DELTA)
// 13384           gcode_M666();
// 13385         else if(Z_DUAL_ENDSTOPS==1)
// 13386         {
// 13387           gcode_M666_dual();  
// 13388         }
// 13389           break;
// 13390       //#endif
// 13391 
// 13392       #if ENABLED(FWRETRACT)
// 13393         case 207: // M207: Set Retract Length, Feedrate, and Z lift
// 13394           gcode_M207();
// 13395           break;
// 13396         case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
// 13397           gcode_M208();
// 13398           break;
// 13399         case 209: // M209: Turn Automatic Retract Detection on/off
// 13400           if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
// 13401           break;
// 13402       #endif // FWRETRACT
// 13403 
// 13404       case 211: // M211: Enable, Disable, and/or Report software endstops
// 13405         gcode_M211();
// 13406         break;
// 13407 
// 13408       #if HOTENDS > 1
// 13409         case 218: // M218: Set a tool offset
// 13410           gcode_M218();
// 13411           break;
// 13412       #endif // HOTENDS > 1
// 13413 
// 13414       case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
// 13415         gcode_M220();
// 13416         break;
// 13417 
// 13418       case 221: // M221: Set Flow Percentage
// 13419         gcode_M221();
// 13420         break;
// 13421 
// 13422       case 226: // M226: Wait until a pin reaches a state
// 13423         gcode_M226();
// 13424         break;
// 13425 
// 13426       //#if HAS_SERVOS
// 13427         case 280: // M280: Set servo position absolute
// 13428           gcode_M280();
// 13429           break;
// 13430       //#endif // HAS_SERVOS
// 13431 
// 13432       #if ENABLED(BABYSTEPPING)
// 13433         case 290: // M290: Babystepping
// 13434           gcode_M290();
// 13435           break;
// 13436       #endif // BABYSTEPPING
// 13437 
// 13438       #if HAS_BUZZER
// 13439         case 300: // M300: Play beep tone
// 13440           gcode_M300();
// 13441           break;
// 13442       #endif // HAS_BUZZER
// 13443 
// 13444       //#if ENABLED(PIDTEMP)
// 13445         case 301: // M301: Set hotend PID parameters
// 13446         if(PIDTEMP) 
// 13447           gcode_M301();
// 13448           break;
// 13449       //#endif // PIDTEMP
// 13450 
// 13451       //#if ENABLED(PIDTEMPBED)
// 13452         case 304: // M304: Set bed PID parameters
// 13453         if(PIDTEMPBED) 
// 13454           gcode_M304();
// 13455           break;
// 13456       //#endif // PIDTEMPBED
// 13457 
// 13458       #if defined(CHDK) || HAS_PHOTOGRAPH
// 13459         case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
// 13460           gcode_M240();
// 13461           break;
// 13462       #endif // CHDK || PHOTOGRAPH_PIN
// 13463 
// 13464       #if HAS_LCD_CONTRAST
// 13465         case 250: // M250: Set LCD contrast
// 13466           gcode_M250();
// 13467           break;
// 13468       #endif // HAS_LCD_CONTRAST
// 13469 
// 13470       #if ENABLED(EXPERIMENTAL_I2CBUS)
// 13471 
// 13472         case 260: // M260: Send data to an i2c slave
// 13473           gcode_M260();
// 13474           break;
// 13475 
// 13476         case 261: // M261: Request data from an i2c slave
// 13477           gcode_M261();
// 13478           break;
// 13479 
// 13480       #endif // EXPERIMENTAL_I2CBUS
// 13481 
// 13482       #if ENABLED(PREVENT_COLD_EXTRUSION)
// 13483         case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
// 13484           gcode_M302();
// 13485           break;
// 13486       #endif // PREVENT_COLD_EXTRUSION
// 13487 
// 13488       case 303: // M303: PID autotune
// 13489         gcode_M303();
// 13490         break;
// 13491 
// 13492       //#if ENABLED(MORGAN_SCARA)
// 13493         case 360:  // M360: SCARA Theta pos1
// 13494         if(MACHINETPYE == MORGAN_SCARA)
// 13495           if (gcode_M360()) return;
// 13496           break;
// 13497         case 361:  // M361: SCARA Theta pos2
// 13498         if(MACHINETPYE == MORGAN_SCARA)
// 13499           if (gcode_M361()) return;
// 13500           break;
// 13501         case 362:  // M362: SCARA Psi pos1
// 13502         if(MACHINETPYE == MORGAN_SCARA)
// 13503           if (gcode_M362()) return;
// 13504           break;
// 13505         case 363:  // M363: SCARA Psi pos2
// 13506         if(MACHINETPYE == MORGAN_SCARA)
// 13507           if (gcode_M363()) return;
// 13508           break;
// 13509         case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
// 13510         if(MACHINETPYE == MORGAN_SCARA)
// 13511           if (gcode_M364()) return;
// 13512           break;
// 13513       //#endif // SCARA
// 13514 
// 13515       case 400: // M400: Finish all moves
// 13516         gcode_M400();
// 13517         break;
// 13518 
// 13519       #if HAS_BED_PROBE
// 13520         case 401: // M401: Deploy probe
// 13521           gcode_M401();
// 13522           break;
// 13523         case 402: // M402: Stow probe
// 13524           gcode_M402();
// 13525           break;
// 13526       #endif // HAS_BED_PROBE
// 13527 
// 13528       #if ENABLED(FILAMENT_WIDTH_SENSOR)
// 13529         case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
// 13530           gcode_M404();
// 13531           break;
// 13532         case 405:  // M405: Turn on filament sensor for control
// 13533           gcode_M405();
// 13534           break;
// 13535         case 406:  // M406: Turn off filament sensor for control
// 13536           gcode_M406();
// 13537           break;
// 13538         case 407:   // M407: Display measured filament diameter
// 13539           gcode_M407();
// 13540           break;
// 13541       #endif // FILAMENT_WIDTH_SENSOR
// 13542 
// 13543       //#if HAS_LEVELING
// 13544         case 420: // M420: Enable/Disable Bed Leveling
// 13545         if(BED_LEVELING_METHOD&HAS_LEVELING)
// 13546           gcode_M420();
// 13547           break;
// 13548       //#endif
// 13549 
// 13550       //#if HAS_MESH
// 13551         case 421: // M421: Set a Mesh Bed Leveling Z coordinate
// 13552           if(BED_LEVELING_METHOD & MESH_BED_LEVELING)
// 13553           	gcode_M421_MESH_BED_LEVELING();
// 13554 		  else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_BILINEAR)
// 13555           	gcode_M421_AUTO_BED_LEVELING_BILINEAR();
// 13556           else if(BED_LEVELING_METHOD & AUTO_BED_LEVELING_UBL)
// 13557             gcode_M421_AUTO_BED_LEVELING_UBL();
// 13558           break;
// 13559       //#endif
// 13560 
// 13561       //#if HAS_M206_COMMAND
// 13562         case 428: // M428: Apply current_position to home_offset
// 13563         if(MACHINETPYE != DELTA)
// 13564           gcode_M428();
// 13565           break;
// 13566       //#endif
// 13567 
// 13568       case 500: // M500: Store settings in EEPROM
// 13569         gcode_M500();
// 13570         break;
// 13571       case 501: // M501: Read settings from EEPROM
// 13572         gcode_M501();
// 13573         break;
// 13574       case 502: // M502: Revert to default settings
// 13575         gcode_M502();
// 13576         break;
// 13577 
// 13578       #if DISABLED(DISABLE_M503)
// 13579         case 503: // M503: print settings currently in memory
// 13580           gcode_M503();
// 13581           break;
// 13582       #endif
// 13583 
// 13584       #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
// 13585         case 540: // M540: Set abort on endstop hit for SD printing
// 13586           gcode_M540();
// 13587           break;
// 13588       #endif
// 13589 
// 13590       #if HAS_BED_PROBE
// 13591         case 851: // M851: Set Z Probe Z Offset
// 13592           gcode_M851();
// 13593           break;
// 13594       #endif // HAS_BED_PROBE
// 13595 
// 13596       #if ENABLED(SKEW_CORRECTION_GCODE)
// 13597         case 852: // M852: Set Skew factors
// 13598           gcode_M852();
// 13599           break;
// 13600       #endif
// 13601 
// 13602       #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 13603         case 600: // M600: Pause for filament change
// 13604           gcode_M600();
// 13605           break;
// 13606       #endif // ADVANCED_PAUSE_FEATURE
// 13607 
// 13608       #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
// 13609         case 605: // M605: Set Dual X Carriage movement mode
// 13610           gcode_M605();
// 13611           break;
// 13612       #endif // DUAL_X_CARRIAGE
// 13613 
// 13614       #if ENABLED(MK2_MULTIPLEXER)
// 13615         case 702: // M702: Unload all extruders
// 13616           gcode_M702();
// 13617           break;
// 13618       #endif
// 13619 
// 13620       #if ENABLED(LIN_ADVANCE)
// 13621         case 900: // M900: Set advance K factor.
// 13622           gcode_M900();
// 13623           break;
// 13624       #endif
// 13625 
// 13626       case 907: // M907: Set digital trimpot motor current using axis codes.
// 13627         gcode_M907();
// 13628         break;
// 13629 
// 13630       #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
// 13631 
// 13632         case 908: // M908: Control digital trimpot directly.
// 13633           gcode_M908();
// 13634           break;
// 13635 
// 13636         #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
// 13637 
// 13638           case 909: // M909: Print digipot/DAC current value
// 13639             gcode_M909();
// 13640             break;
// 13641 
// 13642           case 910: // M910: Commit digipot/DAC value to external EEPROM
// 13643             gcode_M910();
// 13644             break;
// 13645 
// 13646         #endif
// 13647 
// 13648       #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
// 13649 
// 13650       #if ENABLED(HAVE_TMC2130) || ENABLED(HAVE_TMC2208)
// 13651         case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
// 13652           gcode_M906();
// 13653           break;
// 13654 
// 13655         case 911: // M911: Report TMC prewarn triggered flags
// 13656           gcode_M911();
// 13657           break;
// 13658 
// 13659         case 912: // M911: Clear TMC prewarn triggered flags
// 13660           gcode_M912();
// 13661           break;
// 13662 
// 13663         #if ENABLED(TMC_DEBUG)
// 13664           case 122:  // Debug TMC steppers
// 13665             gcode_M122();
// 13666             break;
// 13667         #endif
// 13668 
// 13669         #if ENABLED(HYBRID_THRESHOLD)
// 13670           case 913: // M913: Set HYBRID_THRESHOLD speed.
// 13671             gcode_M913();
// 13672             break;
// 13673         #endif
// 13674 
// 13675         #if ENABLED(SENSORLESS_HOMING)
// 13676           case 914: // M914: Set SENSORLESS_HOMING sensitivity.
// 13677             gcode_M914();
// 13678             break;
// 13679         #endif
// 13680 
// 13681         #if ENABLED(TMC_Z_CALIBRATION) && (Z_IS_TRINAMIC || Z2_IS_TRINAMIC)
// 13682           case 915: // M915: TMC Z axis calibration routine
// 13683             gcode_M915();
// 13684             break;
// 13685         #endif
// 13686       #endif
// 13687 
// 13688       #if HAS_MICROSTEPS
// 13689 
// 13690         case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
// 13691           gcode_M350();
// 13692           break;
// 13693 
// 13694         case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
// 13695           gcode_M351();
// 13696           break;
// 13697 
// 13698       #endif // HAS_MICROSTEPS
// 13699 
// 13700       case 355: // M355 set case light brightness
// 13701         gcode_M355();
// 13702         break;
// 13703 
// 13704       #if ENABLED(DEBUG_GCODE_PARSER)
// 13705         case 800:
// 13706           parser.debug(); // GCode Parser Test for M
// 13707           break;
// 13708       #endif
// 13709 
// 13710       #if ENABLED(I2C_POSITION_ENCODERS)
// 13711 
// 13712         case 860: // M860 Report encoder module position
// 13713           gcode_M860();
// 13714           break;
// 13715 
// 13716         case 861: // M861 Report encoder module status
// 13717           gcode_M861();
// 13718           break;
// 13719 
// 13720         case 862: // M862 Perform axis test
// 13721           gcode_M862();
// 13722           break;
// 13723 
// 13724         case 863: // M863 Calibrate steps/mm
// 13725           gcode_M863();
// 13726           break;
// 13727 
// 13728         case 864: // M864 Change module address
// 13729           gcode_M864();
// 13730           break;
// 13731 
// 13732         case 865: // M865 Check module firmware version
// 13733           gcode_M865();
// 13734           break;
// 13735 
// 13736         case 866: // M866 Report axis error count
// 13737           gcode_M866();
// 13738           break;
// 13739 
// 13740         case 867: // M867 Toggle error correction
// 13741           gcode_M867();
// 13742           break;
// 13743 
// 13744         case 868: // M868 Set error correction threshold
// 13745           gcode_M868();
// 13746           break;
// 13747 
// 13748         case 869: // M869 Report axis error
// 13749           gcode_M869();
// 13750           break;
// 13751 
// 13752       #endif // I2C_POSITION_ENCODERS
// 13753 
// 13754       case 999: // M999: Restart after being Stopped
// 13755         gcode_M999();
// 13756         break;
// 13757     }
// 13758     break;
// 13759 
// 13760     case 'T':
// 13761       gcode_T(parser.codenum);
// 13762       break;
// 13763 
// 13764     default: parser.unknown_command_error();
// 13765   }
// 13766 
// 13767   KEEPALIVE_STATE(NOT_BUSY);
// 13768 
// 13769   ok_to_send();
// 13770 }
        B.W      ?Subroutine4
??process_parsed_command_78:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        CMP      R4,#+61
        IT       GE 
        MOVGE    R4,#+60
        LDR.W    R0,??process_parsed_command_152+0xC
        STRB     R4,[R0, #+0]
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R1,#+1000
        MLA      R0,R1,R4,R0
        LDR.W    R1,??process_parsed_command_152+0x10
        B.W      ??process_parsed_command_155
??process_parsed_command_66:
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
        B.W      ??process_parsed_command_16
??process_parsed_command_79:
        LDR.W    R0,??process_parsed_command_17+0x4
        LDRB     R0,[R0, #+2]
        CBZ.N    R0,??process_parsed_command_156
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
        B.W      ??process_parsed_command_16
??process_parsed_command_156:
        LDR.W    R0,??process_parsed_command_152+0x4
        B.W      ??process_parsed_command_120
??process_parsed_command_63:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_157
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
??process_parsed_command_157:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_158
        LDR.W    R7,??process_parsed_command_17+0x8
        LDR      R0,[R7, #+0]
        CBZ.N    R0,??process_parsed_command_159
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??process_parsed_command_159
??process_parsed_command_158:
        MOVS     R0,#+255
??process_parsed_command_159:
        UXTH     R0,R0
        MOVS     R1,#+255
        CMP      R0,#+255
        IT       LE 
        MOVLE    R1,R0
        LDR.W    R2,??process_parsed_command_17
        STR      R1,[R2, #+116]
        MOVW     R1,#+10000
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??process_parsed_command_126  ;; 0x40000440
        B.W      ??process_parsed_command_155
??process_parsed_command_64:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_17+0x8
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_160
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        UXTH     R0,R0
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
??process_parsed_command_160:
        LDR.W    R1,??process_parsed_command_17
        MOVS     R0,#+0
        STR      R0,[R1, #+116]
        LDR.W    R1,??process_parsed_command_126  ;; 0x40000440
        B.W      ??process_parsed_command_155
??process_parsed_command_56:
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        BL       _ZN7Stepper18finish_and_disableEv
        LDR.N    R1,??process_parsed_command_17
        MOVS     R0,#+0
        STR      R0,[R1, #+116]
        MOV      R0,#+1000
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
        B.W      ??process_parsed_command_16
??process_parsed_command_58:
        MOVS     R0,#+1
??process_parsed_command_57:
        LDR.N    R1,??process_parsed_command_17
        STRB     R0,[R1, #+3]
        B.W      ??process_parsed_command_16
??process_parsed_command_39:
          CFI FunCall _Z13gcode_M18_M84v
        BL       _Z13gcode_M18_M84v
        B.W      ??process_parsed_command_16
??process_parsed_command_59:
        LDR.W    R0,??process_parsed_command_140+0xC
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+29
        BPL.W    ??process_parsed_command_16
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.N    R7,??process_parsed_command_17+0x8
        LDRB     R0,[R5, #+18]
        CBZ.N    R0,??process_parsed_command_161
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_161:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??process_parsed_command_17+0xC  ;; 0x447a0000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        STR      R0,[R8, #+96]
        B.W      ??process_parsed_command_16
??process_parsed_command_60:
          CFI FunCall _Z9gcode_M92v
        BL       _Z9gcode_M92v
        B.W      ??process_parsed_command_16
??process_parsed_command_71:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        B.N      ??process_parsed_command_162
??process_parsed_command_72:
        LDR.W    R0,??process_parsed_command_163
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.W    R0,??process_parsed_command_163+0x4
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_163+0x8
        MOVS     R1,#+1
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.W    R0,??process_parsed_command_163+0xC
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_163+0x10
        MOVS     R1,#+1
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.W    R0,??process_parsed_command_163+0x14
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_163+0x18
        MOVS     R1,#+1
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.W    R0,??process_parsed_command_163+0x1C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_163+0x20
        MOVS     R1,#+1
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+1
        LDR.W    R0,??process_parsed_command_163+0x24
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_163+0x28
        MOVS     R1,#+0
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.W    R0,??process_parsed_command_163+0x2C
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_164
        MOVS     R1,#+0
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        MOVS     R1,#+0
        LDR.W    R0,??process_parsed_command_164+0x4
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        LDR.W    R0,??process_parsed_command_164+0x8
        MOVS     R1,#+0
          CFI FunCall _Z8cap_linePKcb
        BL       _Z8cap_linePKcb
        B.W      ??process_parsed_command_16
??process_parsed_command_73:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_165
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CBNZ.N   R0,??process_parsed_command_166
        B.N      ??process_parsed_command_167
??process_parsed_command_165:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??process_parsed_command_167
??process_parsed_command_166:
        LDR.W    R0,??process_parsed_command_131+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??process_parsed_command_167:
        MOVS     R0,#+65
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??process_parsed_command_17+0x8
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_168
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CBNZ.N   R0,??process_parsed_command_169
        B.N      ??process_parsed_command_170
??process_parsed_command_168:
        MOVS     R0,#+65
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??process_parsed_command_170
??process_parsed_command_169:
        LDR.W    R0,??process_parsed_command_164+0xC
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??process_parsed_command_170:
        LDR.W    R0,??process_parsed_command_119+0xC
        LDR.N    R5,??process_parsed_command_27
        LDR      R1,[R0, #+0]
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
        B.W      ??process_parsed_command_28
??process_parsed_command_74:
          CFI FunCall _ZN8Endstops4M119Ev
        BL       _ZN8Endstops4M119Ev
        B.W      ??process_parsed_command_16
??process_parsed_command_75:
        LDR.W    R1,??process_parsed_command_164+0x10
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
        LDR.W    R1,??process_parsed_command_164+0x14
        B.W      ??process_parsed_command_171
??process_parsed_command_76:
        LDR.W    R1,??process_parsed_command_164+0x10
        STRB     R0,[R1, #+0]
        LDR.W    R1,??process_parsed_command_164+0x14
        B.W      ??process_parsed_command_171
??process_parsed_command_80:
        MOVS     R0,#+200
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??process_parsed_command_140+0xC
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+28
        BPL.N    ??process_parsed_command_172
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.N    R7,??process_parsed_command_17+0x8
        LDRB     R0,[R5, #+3]
        CBZ.N    R0,??process_parsed_command_173
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_173:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        ITE      NE 
        MOVNE    R0,#+1
        MOVEQ    R0,#+0
        LDR.W    R1,??process_parsed_command_174
        STRB     R0,[R1, #+0]
        LDRB     R0,[R1, #+0]
        CBZ.N    R0,??process_parsed_command_172
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??process_parsed_command_17
        LDR.W    R2,??process_parsed_command_174+0x4
        LDRB     R1,[R1, #+13]
        STR      R0,[R2, R1, LSL #+2]
        MOVS     R1,#+0
        LDR      R0,[R2, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        ITT      EQ 
        LDREQ.W  R0,??process_parsed_command_174+0x8  ;; 0x40400000
        STREQ    R0,[R2, #+0]
        LDR      R0,[R2, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        ITT      EQ 
        LDREQ.W  R0,??process_parsed_command_174+0x8  ;; 0x40400000
        STREQ    R0,[R2, #+4]
??process_parsed_command_172:
          CFI FunCall _ZN7Planner32calculate_volumetric_multipliersEv
        BL       _ZN7Planner32calculate_volumetric_multipliersEv
        B.W      ??process_parsed_command_16
        Nop      
        DATA
??process_parsed_command_0:
        DC32     axis_homed
        DC32     _ZN11GCodeParser14command_letterE
        DC32     _ZN11GCodeParser7codenumE
        THUMB
??process_parsed_command_81:
        MOVS     R0,#+201
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
        MOVS     R4,#+0
        LDR.W    R5,??process_parsed_command_175
        LDR.W    R7,??process_parsed_command_175+0x4
??process_parsed_command_176:
        LDRSB    R0,[R5, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??process_parsed_command_177
        CMP      R4,#+3
        ITTE     EQ 
        LDREQ.N  R0,??process_parsed_command_17
        LDRBEQ   R0,[R0, #+13]
        MOVNE    R0,#+0
        ADDS     R0,R0,R4
        UXTB     R6,R0
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        STR      R0,[R7, R6, LSL #+2]
??process_parsed_command_177:
        ADDS     R4,R4,#+1
        ADDS     R5,R5,#+1
        CMP      R4,#+4
        BLT.N    ??process_parsed_command_176
          CFI FunCall _ZN7Planner24reset_acceleration_ratesEv
        BL       _ZN7Planner24reset_acceleration_ratesEv
        B.W      ??process_parsed_command_16
??process_parsed_command_82:
        MOVS     R0,#+203
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
        LDR.W    R5,??process_parsed_command_175
        LDR.W    R7,??process_parsed_command_178
        MOVS     R4,#+0
??process_parsed_command_179:
        LDRSB    R0,[R5, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??process_parsed_command_180
        CMP      R4,#+3
        ITTE     EQ 
        LDREQ.N  R0,??process_parsed_command_17
        LDRBEQ   R0,[R0, #+13]
        MOVNE    R0,#+0
        ADDS     R0,R0,R4
        UXTB     R6,R0
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R7, R6, LSL #+2]
??process_parsed_command_180:
        ADDS     R4,R4,#+1
        ADDS     R5,R5,#+1
        CMP      R4,#+4
        BLT.N    ??process_parsed_command_179
        B.W      ??process_parsed_command_16
??process_parsed_command_83:
        LDR.W    R4,??process_parsed_command_140+0xC
        LDR.W    R5,??process_parsed_command_140+0x10
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_181
        LDRB     R0,[R5, #+18]
        LDR.N    R7,??process_parsed_command_17+0x8
        CBZ.N    R0,??process_parsed_command_182
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_182:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_183
        STR      R0,[R1, #+0]
        LDR.W    R1,??process_parsed_command_183+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.W    R0,??process_parsed_command_183+0x8
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??process_parsed_command_27
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??process_parsed_command_181:
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_184
        LDRB     R0,[R5, #+15]
        LDR.N    R7,??process_parsed_command_17+0x8
        CBZ.N    R0,??process_parsed_command_185
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_185:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_183
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.W    R0,??process_parsed_command_183+0xC
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??process_parsed_command_27
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??process_parsed_command_184:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_186
        LDRB     R0,[R5, #+17]
        LDR.N    R7,??process_parsed_command_17+0x8
        CBZ.N    R0,??process_parsed_command_187
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_187:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_188
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.W    R0,??process_parsed_command_188+0x4
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.N    R0,??process_parsed_command_27
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??process_parsed_command_186:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+28
        BPL.W    ??process_parsed_command_16
        LDRB     R0,[R5, #+19]
        LDR.N    R7,??process_parsed_command_17+0x8
        CBZ.N    R0,??process_parsed_command_189
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_189:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_183+0x4
        STR      R0,[R1, #+0]
        MOV      R1,R0
        LDR.W    R0,??process_parsed_command_188+0x8
        B.W      ??process_parsed_command_190
        DATA
??process_parsed_command_17:
        DC32     axis_relative_modes
        DC32     mksCfg+0x36
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     0x447a0000
        DC32     gCfgItems
        DC32     mksCfg
        THUMB
??process_parsed_command_84:
        LDR.W    R4,??process_parsed_command_140+0xC
        LDR.W    R5,??process_parsed_command_140+0x10
        LDRB     R0,[R4, #+2]
        LDR.W    R7,??process_parsed_command_191
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_192
        LDRB     R0,[R5, #+18]
        CBZ.N    R0,??process_parsed_command_193
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_193:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_191+0x4
        STR      R0,[R1, #+0]
??process_parsed_command_192:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+28
        BPL.N    ??process_parsed_command_194
        LDRB     R0,[R5, #+19]
        CBZ.N    R0,??process_parsed_command_195
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_195:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_191+0x8
        STR      R0,[R1, #+0]
??process_parsed_command_194:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_196
        LDRB     R0,[R5, #+1]
        CBNZ.N   R0,??process_parsed_command_197
        STR      R0,[R7, #+0]
??process_parsed_command_198:
        MOVS     R0,#+0
??process_parsed_command_199:
        LDR.W    R1,??process_parsed_command_191+0xC
        STR      R0,[R1, #+0]
??process_parsed_command_196:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_200
        LDRB     R0,[R5, #+23]
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R1,??process_parsed_command_140+0x14
        LDRNE    R1,[R1, #+0]
        ADDNE    R0,R0,R1
        B.N      ??process_parsed_command_201
??process_parsed_command_197:
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BEQ.N    ??process_parsed_command_198
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        B.N      ??process_parsed_command_199
??process_parsed_command_201:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_191+0x10
        STR      R0,[R1, #+0]
??process_parsed_command_200:
        LDRB     R0,[R4, #+3]
        LSLS     R0,R0,#+31
        BPL.N    ??process_parsed_command_202
        LDRB     R0,[R5, #+24]
        CBZ.N    R0,??process_parsed_command_203
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_203:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_191+0x10
        STR      R0,[R1, #+4]
??process_parsed_command_202:
        LDRB     R0,[R4, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_204
        LDRB     R0,[R5, #+25]
        CBZ.N    R0,??process_parsed_command_205
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_205:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_191+0x10
        STR      R0,[R1, #+8]
??process_parsed_command_204:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_16
        LDRB     R0,[R5, #+4]
        CBZ.N    R0,??process_parsed_command_206
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_206:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_191+0x10
        STR      R0,[R1, #+12]
        B.W      ??process_parsed_command_16
        DATA
??process_parsed_command_27:
        DC32     Serial3
        DC32     `?<Constant "bed leveling hasn\\'t d...">`
        DC32     0x88e368f1
        DC32     0x3ee4f8b5
        DC32     _ZZ9gcode_G30vEs
        DC32     _ZZ9gcode_G30vEs_0
        DC32     _ZZ9gcode_G30vEs_1
        THUMB
??process_parsed_command_85:
        LDR.W    R4,??process_parsed_command_207
        ADDW     R6,R4,#+54
        LDRSH    R0,[R6, #+34]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_16
        LDR.W    R9,??process_parsed_command_207+0x4
        LDR.W    R5,??process_parsed_command_175
        MOVS     R4,#+0
        ADD      R7,R9,#+48
??process_parsed_command_208:
        LDRSB    R0,[R5, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??process_parsed_command_209
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRSH    R1,[R6, #+34]
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_209
        STR      R0,[R7, #+0]
        SXTB     R0,R4
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??process_parsed_command_209:
        ADDS     R4,R4,#+1
        ADDS     R7,R7,#+4
        ADDS     R5,R5,#+1
        CMP      R4,#+3
        BLT.N    ??process_parsed_command_208
        LDRSH    R0,[R6, #+34]
        CMP      R0,#+256
        BNE.N    ??process_parsed_command_162
        LDR.W    R4,??process_parsed_command_140+0xC
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+28
        BPL.N    ??process_parsed_command_210
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+19]
        CBZ.N    R0,??process_parsed_command_211
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_211:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRSH    R1,[R6, #+34]
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_210
        STR      R0,[R9, #+48]
        MOVS     R0,#+0
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??process_parsed_command_210:
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_162
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+15]
        CBZ.N    R0,??process_parsed_command_212
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_212:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRSH    R1,[R6, #+34]
        CMP      R1,#+2
        BEQ.N    ??process_parsed_command_162
        STR      R0,[R9, #+52]
        MOVS     R0,#+1
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??process_parsed_command_162:
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        B.W      ??process_parsed_command_16
??process_parsed_command_113:
        LDR.W    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+2
        BNE.W    ??process_parsed_command_16
        LDR.W    R4,??process_parsed_command_140+0xC
        LDR.W    R5,??process_parsed_command_140+0x10
        LDRB     R0,[R4, #+0]
        LDR.W    R7,??process_parsed_command_191
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_213
        LDRB     R0,[R5, #+7]
        CBZ.N    R0,??process_parsed_command_214
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_214:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??process_parsed_command_207+0x4
        STR      R0,[R1, #+128]
??process_parsed_command_213:
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+28
        BPL.N    ??process_parsed_command_215
        LDRB     R0,[R5, #+11]
        CBZ.N    R0,??process_parsed_command_216
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_216:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+120]
??process_parsed_command_215:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_217
        LDRB     R0,[R5, #+17]
        CBZ.N    R0,??process_parsed_command_218
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_218:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+116]
??process_parsed_command_217:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_219
        LDRB     R0,[R5, #+18]
        CBZ.N    R0,??process_parsed_command_220
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_220:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+128]
??process_parsed_command_219:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_221
        LDRB     R0,[R5, #+1]
        CBZ.N    R0,??process_parsed_command_222
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_222:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+124]
??process_parsed_command_221:
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_223
        LDRB     R0,[R5, #+23]
        CBZ.N    R0,??process_parsed_command_224
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_224:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+72]
??process_parsed_command_223:
        LDRB     R0,[R4, #+3]
        LSLS     R0,R0,#+31
        BPL.N    ??process_parsed_command_225
        LDRB     R0,[R5, #+24]
        CBZ.N    R0,??process_parsed_command_226
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_226:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+76]
??process_parsed_command_225:
        LDRB     R0,[R4, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_227
        LDRB     R0,[R5, #+25]
        CBZ.N    R0,??process_parsed_command_228
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_228:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+80]
??process_parsed_command_227:
          CFI FunCall _Z21recalc_delta_settingsv
        BL       _Z21recalc_delta_settingsv
        B.W      ??process_parsed_command_16
??process_parsed_command_114:
        LDR.W    R4,??process_parsed_command_207
        ADD      R0,R4,#+54
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+2
        BNE.N    ??process_parsed_command_229
        LDR.W    R5,??process_parsed_command_175
        ADD      R7,R8,#+104
        MOVS     R6,#+3
??process_parsed_command_230:
        LDRSB    R0,[R5, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??process_parsed_command_231
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R9,R0
        LDRSB    R0,[R4, #+7]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BHI.N    ??process_parsed_command_231
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R7, #+0]
??process_parsed_command_231:
        ADDS     R7,R7,#+4
        ADDS     R5,R5,#+1
        SUBS     R6,R6,#+1
        BNE.N    ??process_parsed_command_230
        B.W      ??process_parsed_command_16
??process_parsed_command_229:
        ADDW     R4,R4,#+247
        LDRB     R0,[R4, #+11]
        CMP      R0,#+1
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable143
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDRB     R0,[R4, #+11]
        CMP      R0,#+1
        BNE.W    ??process_parsed_command_133
        LDR.W    R0,??process_parsed_command_140+0xC
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_232
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+25]
        CBZ.N    R0,??process_parsed_command_233
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_233:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R8, #+100]
??process_parsed_command_232:
        LDR      R1,[R8, #+100]
        LDR.W    R0,??DataTable141_1
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        B.W      ??process_parsed_command_133
        Nop      
        DATA
??process_parsed_command_119:
        DC32     _ZZ9gcode_M20vEs
        DC32     card
        DC32     _ZZ9gcode_M20vEs_0
        DC32     _ZN11GCodeParser10string_argE
        DC32     curFileName
        THUMB
??process_parsed_command_86:
        LDR.N    R0,??process_parsed_command_131+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??process_parsed_command_140+0xC
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_234
        LDR.W    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+18]
        CBNZ.N   R0,??process_parsed_command_235
        STR      R0,[R7, #+0]
??process_parsed_command_236:
        MOVS     R0,#+1
??process_parsed_command_237:
        LDR.W    R1,??process_parsed_command_207+0x4
        STRB     R0,[R1, #+9]
??process_parsed_command_234:
        LDR.W    R0,??DataTable142
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R6,??process_parsed_command_207+0x4
        LDRB     R0,[R6, #+9]
        CMP      R0,#+0
        ITE      NE 
        LDRNE.W  R0,??DataTable142_1
        LDREQ.W  R0,??DataTable142_2
        B.N      ??process_parsed_command_238
??process_parsed_command_235:
        LDR.W    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BEQ.N    ??process_parsed_command_236
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??process_parsed_command_237
??process_parsed_command_238:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable142_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R1,[R6, #+72]
        LDR      R0,[R6, #+60]
        LDR.W    R4,??DataTable142_4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R6, #+76]
        LDR      R0,[R6, #+64]
        LDR.W    R5,??DataTable142_5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R6, #+80]
        LDR      R0,[R6, #+68]
        LDR.W    R7,??DataTable143_1
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.W    R0,??DataTable143_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R1,[R6, #+84]
        LDR      R0,[R6, #+60]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R6, #+88]
        LDR      R0,[R6, #+64]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR      R1,[R6, #+92]
        LDR      R0,[R6, #+68]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R7
        B.W      ??process_parsed_command_190
??process_parsed_command_87:
        MOVS     R0,#+218
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
        LDR.W    R4,??process_parsed_command_207+0x4
        LDRB     R0,[R4, #+13]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_191
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_239
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRB     R1,[R4, #+13]
        ADD      R1,R8,R1, LSL #+2
        STR      R0,[R1, #+36]
??process_parsed_command_239:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??process_parsed_command_191
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_240
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRB     R1,[R4, #+13]
        ADD      R1,R8,R1, LSL #+2
        STR      R0,[R1, #+44]
??process_parsed_command_240:
        LDR.N    R0,??process_parsed_command_131+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable143_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R7,#+0
        LDR.W    R4,??process_parsed_command_207
        LDR.W    R5,??DataTable144
        B.N      ??process_parsed_command_241
        Nop      
        DATA
??process_parsed_command_124:
        DC32     from_flash_pic
        DC32     flash_preview_begin
        DC32     default_preview_flg
        THUMB
??process_parsed_command_242:
        MOVS     R1,#+32
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        ADD      R0,R8,#+36
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+44
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOVS     R0,#+2
        STR      R0,[SP, #+0]
        ADD      R0,R8,R7, LSL #+2
        LDR      R0,[R0, #+44]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADDS     R7,R7,#+1
        SXTB     R7,R7
??process_parsed_command_241:
        LDRB     R0,[R4, #+247]
        CMP      R7,R0
        BLT.N    ??process_parsed_command_242
        MOVS     R1,#+10
        MOV      R0,R5
        B.W      ??process_parsed_command_28
??process_parsed_command_88:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_191
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        LDR.W    R1,??process_parsed_command_207+0x4
        STRH     R0,[R1, #+14]
        B.W      ??process_parsed_command_16
        DATA
??process_parsed_command_126:
        DC32     0x40000440
        THUMB
??process_parsed_command_89:
        MOVS     R0,#+221
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??process_parsed_command_16
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R7,??process_parsed_command_191
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        LDR.W    R1,??process_parsed_command_207+0x4
        LDRB     R7,[R1, #+13]
        LDR.W    R1,??DataTable144_1
        STRH     R0,[R1, R7, LSL #+1]
        LDRSH    R0,[R1, R7, LSL #+1]
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.W    R2,??DataTable144_2  ;; 0x47ae147b
        LDR.W    R3,??DataTable144_3  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        LDR.W    R0,??DataTable144_4
        LDR      R0,[R0, R7, LSL #+2]
        MOV      R5,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable144_5
        STR      R0,[R1, R7, LSL #+2]
        B.W      ??process_parsed_command_16
??process_parsed_command_90:
        LDR.N    R0,??process_parsed_command_140+0xC
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+24
        BPL.W    ??process_parsed_command_16
        LDR.N    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+15]
        CBNZ.N   R0,??process_parsed_command_243
        STR      R0,[R7, #+0]
??process_parsed_command_244:
        MOVS     R4,#+0
??process_parsed_command_245:
        SXTH     R4,R4
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_246
        LDR      R0,[R7, #+0]
        CBZ.N    R0,??process_parsed_command_247
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??process_parsed_command_247
??process_parsed_command_243:
        LDR.N    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BEQ.N    ??process_parsed_command_244
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R4,R0
        B.N      ??process_parsed_command_245
??process_parsed_command_246:
        MOV      R0,#-1
??process_parsed_command_247:
        SXTH     R0,R0
        ADDS     R0,R0,#+1
        CMP      R0,#+3
        BCS.W    ??process_parsed_command_16
        CMP      R4,#+0
        BMI.W    ??process_parsed_command_16
        SXTB     R0,R4
        MOVS     R1,#+0
        LDR.N    R2,??process_parsed_command_132+0x4
??process_parsed_command_248:
        LDRSB    R3,[R2], #+1
        CMP      R0,R3
        ITT      NE 
        LDRSBNE  R3,[R2], #+1
        CMPNE    R0,R3
        ITT      NE 
        LDRSBNE  R3,[R2], #+1
        CMPNE    R0,R3
        BEQ.W    ??process_parsed_command_16
        ADDS     R1,R1,#+3
        UXTB     R1,R1
        CMP      R1,#+51
        BCC.N    ??process_parsed_command_248
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??process_parsed_command_249:
        LDR.N    R0,??process_parsed_command_139
        LDRH     R1,[R0, R4, LSL #+1]
        LDR.N    R0,??process_parsed_command_139+0x4
        LDR      R0,[R0, R4, LSL #+2]
          CFI FunCall HAL_GPIO_ReadPin
        BL       HAL_GPIO_ReadPin
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _Z4idlev
        BL       _Z4idlev
        B.N      ??process_parsed_command_249
        DATA
??process_parsed_command_131:
        DC32     axis_relative_modes+0x84
        DC32     echomagic
        THUMB
??process_parsed_command_91:
        LDR.N    R4,??process_parsed_command_140+0xC
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+24
        BPL.W    ??process_parsed_command_16
        LDR.N    R5,??process_parsed_command_140+0x10
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+15]
        CBNZ.N   R0,??process_parsed_command_250
        STR      R0,[R7, #+0]
??process_parsed_command_251:
        MOVS     R6,#+0
??process_parsed_command_252:
        SXTH     R6,R6
        CMP      R6,#+0
        BNE.N    ??process_parsed_command_253
        LDRB     R0,[R4, #+2]
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_254
        LDRB     R0,[R5, #+18]
        CBNZ.N   R0,??process_parsed_command_255
        STR      R0,[R7, #+0]
??process_parsed_command_256:
        MOVW     R0,#+1100
??process_parsed_command_257:
        LDR.W    R1,??DataTable144_6  ;; 0x40012c34
??process_parsed_command_155:
        STR      R0,[R1, #+0]
        B.W      ??process_parsed_command_16
        DATA
??process_parsed_command_132:
        DC32     _ZZ9gcode_M31vEs
        DC32     ??sensitive_pins
        THUMB
??process_parsed_command_250:
        LDR.N    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BEQ.N    ??process_parsed_command_251
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R6,R0
        B.N      ??process_parsed_command_252
??process_parsed_command_255:
        LDR.N    R1,??process_parsed_command_140+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BEQ.N    ??process_parsed_command_256
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        SXTH     R0,R0
        CMP      R0,#+10
        BEQ.N    ??process_parsed_command_258
        CMP      R0,#+60
        BEQ.N    ??process_parsed_command_259
        CMP      R0,#+90
        BEQ.N    ??process_parsed_command_260
        CMP      R0,#+120
        BEQ.N    ??process_parsed_command_261
        B.N      ??process_parsed_command_256
        DATA
??process_parsed_command_139:
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     errormagic
        DC32     _ZZ9gcode_M42vEs
        THUMB
??process_parsed_command_259:
        MOV      R0,#+600
        B.N      ??process_parsed_command_257
??process_parsed_command_261:
        MOV      R0,#+900
        B.N      ??process_parsed_command_257
??process_parsed_command_260:
        MOVW     R0,#+750
        B.N      ??process_parsed_command_257
??process_parsed_command_258:
        MOV      R0,#+350
        B.N      ??process_parsed_command_257
??process_parsed_command_254:
        LDR.W    R0,??DataTable145_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R1,#+0
        LDR.W    R0,??DataTable145_2
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.W    R0,??DataTable145_3
        B.N      ??process_parsed_command_120
??process_parsed_command_253:
        LDR.W    R0,??DataTable145_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable145_5
        MOV      R1,R6
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.W    R0,??DataTable145_3
        B.N      ??process_parsed_command_120
        DATA
??process_parsed_command_140:
        DC32     _ZZ9gcode_M49vEs
        DC32     _ZZ9gcode_M49vEs_1
        DC32     _ZZ9gcode_M49vEs_0
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     _ZZ10gcode_M111vEs_4
        DC32     _ZZ10gcode_M111vE13debug_strings
        DC32     _ZZ10gcode_M111vEs_5
          CFI FunCall _Z10gcode_M290v
        THUMB
??process_parsed_command_92:
        BL       _Z10gcode_M290v
        B.N      ??process_parsed_command_16
??process_parsed_command_93:
        LDR.W    R0,??process_parsed_command_207
        LDRB     R0,[R0, #+54]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_262
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CMP      R0,#+2
        BGE.W    ??process_parsed_command_263
??process_parsed_command_262:
        LDR.W    R4,??DataTable145_6
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_264
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+15]
        CBZ.N    R0,??process_parsed_command_265
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_265:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??DataTable145_9
        STR      R0,[R1, #+0]
??process_parsed_command_264:
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+31
        BPL.N    ??process_parsed_command_266
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+8]
        CBZ.N    R0,??process_parsed_command_267
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_267:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable145_12
        STR      R0,[R1, #+0]
??process_parsed_command_266:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+28
        BPL.N    ??process_parsed_command_268
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+3]
        CBZ.N    R0,??process_parsed_command_269
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_269:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable145_13
        STR      R0,[R1, #+0]
??process_parsed_command_268:
        LDR.W    R0,??DataTable145_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable145_9
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable145_14
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.W    R0,??DataTable145_12
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??DataTable145_15
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR.W    R0,??DataTable145_13
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??DataTable145_16
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        B.N      ??process_parsed_command_133
        DATA
??process_parsed_command_150:
        DC32     _ZZ10gcode_M112vEs
        THUMB
??process_parsed_command_263:
        LDR.W    R0,??DataTable145_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R5,??DataTable144
        LDR.W    R1,??DataTable145_17
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
        B.N      ??process_parsed_command_28
        DATA
??process_parsed_command_152:
        DC32     _ZZ10gcode_M113vEs
        DC32     `?<Constant "HAS_NO_TEMP_BED!\\n">`
        DC32     _ZZ10gcode_M105vEs
        DC32     _ZN11Temperature25auto_report_temp_intervalE
        DC32     _ZN11Temperature19next_temp_report_msE
        THUMB
??process_parsed_command_96:
        LDR.W    R0,??DataTable141
        LDRB     R0,[R0, #+1]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        LDR.W    R4,??DataTable145_6
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_270
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+15]
        CBZ.N    R0,??process_parsed_command_271
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_271:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??DataTable146
        STR      R0,[R1, #+0]
??process_parsed_command_270:
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+31
        BPL.N    ??process_parsed_command_272
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+8]
        CBZ.N    R0,??process_parsed_command_273
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_273:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable146_1
        STR      R0,[R1, #+0]
??process_parsed_command_272:
        LDRB     R0,[R4, #+0]
        LSLS     R0,R0,#+28
        BPL.N    ??process_parsed_command_274
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+3]
        CBZ.N    R0,??process_parsed_command_275
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_275:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??DataTable146_2
        STR      R0,[R1, #+0]
??process_parsed_command_274:
        LDR.W    R0,??DataTable145_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable146
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable146_3
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        LDR.W    R0,??DataTable146_1
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??DataTable146_4
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        LDR.W    R0,??DataTable146_2
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable145_10  ;; 0x88e368f1
        LDR.W    R3,??DataTable145_11  ;; 0x3fc4f8b5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R0,??DataTable146_5
          CFI FunCall _Z17serial_echopair_PPKcd
        BL       _Z17serial_echopair_PPKcd
        B.N      ??process_parsed_command_133
??process_parsed_command_94:
        LDR.W    R4,??DataTable145_6
        LDRB     R0,[R4, #+2]
        LSRS     R0,R0,#+2
        ANDS     R6,R0,#0x1
        BEQ.N    ??process_parsed_command_276
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+18]
        CBZ.N    R0,??process_parsed_command_277
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_277:
        STR      R0,[R7, #+0]
??process_parsed_command_276:
        CBZ.N    R6,??process_parsed_command_278
        LDR.W    R5,??DataTable146_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRH     R0,[R5, #+0]
        LDRSH    R1,[R5, #+0]
        SUBS     R0,R1,#+1
        SBCS     R0,R0,R0
        LDR.W    R1,??DataTable146_7
        LSRS     R0,R0,#+31
        STRB     R0,[R1, #+0]
??process_parsed_command_278:
        LDRB     R0,[R4, #+1]
        LSLS     R0,R0,#+24
        BPL.N    ??process_parsed_command_279
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+15]
        CBNZ.N   R0,??process_parsed_command_280
        STR      R0,[R7, #+0]
??process_parsed_command_281:
        MOVS     R0,#+1
??process_parsed_command_282:
        LDR.W    R1,??DataTable146_7
??process_parsed_command_171:
        STRB     R0,[R1, #+0]
        B.N      ??process_parsed_command_16
??process_parsed_command_280:
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        LDR.W    R1,??DataTable146_6
        LDRSH    R1,[R1, #+0]
        STR      R0,[R7, #+0]
        CMP      R1,#+0
        IT       NE 
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_281
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??process_parsed_command_282
        DATA
??process_parsed_command_163:
        DC32     _ZZ10gcode_M115vEs
        DC32     _ZZ10gcode_M115vEs_0
        DC32     _ZZ10gcode_M115vEs_1
        DC32     _ZZ10gcode_M115vEs_2
        DC32     _ZZ10gcode_M115vEs_3
        DC32     _ZZ10gcode_M115vEs_4
        DC32     _ZZ10gcode_M115vEs_5
        DC32     _ZZ10gcode_M115vEs_6
        DC32     _ZZ10gcode_M115vEs_7
        DC32     _ZZ10gcode_M115vEs_8
        DC32     _ZZ10gcode_M115vEs_9
        DC32     _ZZ10gcode_M115vEs__10_
        THUMB
??process_parsed_command_279:
        CMP      R6,#+0
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable145_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable146_7
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        ITE      NE 
        LDRNE.W  R1,??DataTable148
        LDREQ.W  R1,??DataTable148_1
        LDR.W    R0,??DataTable148_2
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.W    R0,??DataTable146_6
        LDRSH    R1,[R0, #+0]
        LDR.W    R0,??DataTable148_3
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.W    R0,??DataTable148_4
        B.N      ??process_parsed_command_120
??process_parsed_command_95:
        LDR.W    R4,??process_parsed_command_207
        LDRB     R0,[R4, #+54]
        CMP      R0,#+0
        ITTT     EQ 
        ADDEQ    R0,R4,#+54
        LDRBEQ   R0,[R0, #+1]
        CMPEQ    R0,#+0
        BNE.N    ??process_parsed_command_283
        LDR.W    R0,??DataTable145_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable148_5
        B.N      ??process_parsed_command_120
        Nop      
        DATA
??process_parsed_command_164:
        DC32     _ZZ10gcode_M115vEs__11_
        DC32     _ZZ10gcode_M115vEs__12_
        DC32     _ZZ10gcode_M115vEs__13_
        DC32     _ZZ10gcode_M118vEs
        DC32     _ZN8Endstops7enabledE
        DC32     _ZN8Endstops16enabled_globallyE
        THUMB
??process_parsed_command_283:
        LDR.N    R7,??process_parsed_command_191
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_284
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R4,R0
        B.N      ??process_parsed_command_285
??process_parsed_command_284:
        MOVS     R4,#+0
??process_parsed_command_285:
        SXTH     R4,R4
        MOVS     R0,#+67
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_286
        LDR      R0,[R7, #+0]
        CBZ.N    R0,??process_parsed_command_287
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R5,R0
        B.N      ??process_parsed_command_288
??process_parsed_command_287:
        MOVS     R5,#+0
        B.N      ??process_parsed_command_288
??process_parsed_command_286:
        MOVS     R5,#+5
??process_parsed_command_288:
        MOVS     R0,#+85
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_289
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R6,R0,#+1
        SBCS     R6,R6,R6
        MVNS     R0,R6
        LSRS     R6,R0,#+31
        B.N      ??process_parsed_command_290
??process_parsed_command_289:
        MOVS     R0,#+85
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R6,R0
??process_parsed_command_290:
        CMP      R4,#+0
        ITE      MI 
        LDRMI.W  R9,??DataTable148_6  ;; 0x428c0000
        LDRPL.W  R9,??DataTable148_7  ;; 0x43160000
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_291
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R9,R0
??process_parsed_command_291:
        MOV      R0,R9
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        CMP      R4,#+2
        ITT      CC 
        LDRCC.N  R1,??process_parsed_command_207+0x4
        STRBCC   R4,[R1, #+13]
        SXTB     R5,R5
        SXTB     R4,R4
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R3,R6
        MOV      R2,R5
        MOV      R1,R4
          CFI FunCall _ZN11Temperature12PID_autotuneEfaab
        BL       _ZN11Temperature12PID_autotuneEfaab
        B.N      ??process_parsed_command_16
??process_parsed_command_98:
        LDR.N    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??process_parsed_command_207+0x4
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable148_9  ;; 0x42f00000
        B.N      ??process_parsed_command_292
        Nop      
        DATA
??process_parsed_command_174:
        DC32     _ZN11GCodeParser18volumetric_enabledE
        DC32     _ZN7Planner13filament_sizeE
        DC32     0x40400000
        THUMB
??process_parsed_command_99:
        LDR.N    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??process_parsed_command_207+0x4
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_11  ;; 0x42b40000
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable148_12  ;; 0x43020000
        B.N      ??process_parsed_command_292
        DATA
??process_parsed_command_175:
        DC32     axis_codes
        DC32     _ZN7Planner26max_acceleration_mm_per_s2E
        THUMB
??process_parsed_command_100:
        LDR.N    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_13
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??process_parsed_command_207+0x4
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_14  ;; 0x42700000
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable148_15  ;; 0x43340000
        B.N      ??process_parsed_command_292
??process_parsed_command_101:
        LDR.N    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_16
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??process_parsed_command_207+0x4
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_17  ;; 0x42480000
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable148_11  ;; 0x42b40000
        B.N      ??process_parsed_command_292
        DATA
??process_parsed_command_178:
        DC32     _ZN7Planner17max_feedrate_mm_sE
        THUMB
??process_parsed_command_102:
        LDR.N    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+256
        BNE.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R4,??process_parsed_command_207+0x4
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??process_parsed_command_16
        LDR.W    R0,??DataTable148_19  ;; 0x42340000
        STR      R0,[SP, #+4]
        LDR.W    R0,??DataTable148_20  ;; 0x43070000
??process_parsed_command_292:
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,SP,#+4
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
        LDR      R0,[R4, #+96]
        STR      R0,[R4, #+32]
        LDR      R0,[R4, #+100]
        STR      R0,[R4, #+36]
        LDR      R0,[R4, #+24]
        STR      R0,[R4, #+40]
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
        B.W      ?Subroutine4
        DATA
??process_parsed_command_183:
        DC32     _ZN7Planner12accelerationE
        DC32     _ZN7Planner19travel_accelerationE
        DC32     _ZZ10gcode_M204vEs
        DC32     _ZZ10gcode_M204vEs_0
          CFI FunCall _ZN7Stepper11synchronizeEv
        THUMB
??process_parsed_command_103:
        BL       _ZN7Stepper11synchronizeEv
        B.N      ??process_parsed_command_16
??process_parsed_command_104:
        MOVS     R0,#+1
??process_parsed_command_105:
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        B.N      ??process_parsed_command_16
??process_parsed_command_107:
        MOVS     R1,#+62
        LDR.N    R0,??DataTable141
        LDRB     R0,[R0, #+12]
        TST      R0,R1
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _Z10gcode_M420v
        BL       _Z10gcode_M420v
        B.N      ??process_parsed_command_16
??process_parsed_command_108:
        LDR.N    R4,??process_parsed_command_207
        ADDW     R6,R4,#+54
        LDRB     R0,[R6, #+12]
        LSLS     R1,R0,#+26
        BPL.N    ??process_parsed_command_293
          CFI FunCall _Z28gcode_M421_MESH_BED_LEVELINGv
        BL       _Z28gcode_M421_MESH_BED_LEVELINGv
        B.N      ??process_parsed_command_16
??process_parsed_command_293:
        LSLS     R1,R0,#+28
        BPL.N    ??process_parsed_command_294
          CFI FunCall _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        BL       _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        B.N      ??process_parsed_command_16
??process_parsed_command_294:
        LSLS     R0,R0,#+27
        BPL.W    ??process_parsed_command_16
          CFI FunCall _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        BL       _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        B.N      ??process_parsed_command_16
??process_parsed_command_109:
        LDR.N    R0,??DataTable141
        LDRSH    R0,[R0, #+34]
        CMP      R0,#+2
        BEQ.W    ??process_parsed_command_16
          CFI FunCall _Z10gcode_M428v
        BL       _Z10gcode_M428v
        B.N      ??process_parsed_command_16
        Nop      
        DATA
??process_parsed_command_188:
        DC32     _ZN7Planner20retract_accelerationE
        DC32     _ZZ10gcode_M204vEs_1
        DC32     _ZZ10gcode_M204vEs_2
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
??process_parsed_command_26:
        BL       _ZN14MarlinSettings4saveEv
        B.N      ??process_parsed_command_16
??process_parsed_command_110:
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
        B.N      ??process_parsed_command_16
??process_parsed_command_111:
          CFI FunCall _ZN14MarlinSettings5resetEv
        BL       _ZN14MarlinSettings5resetEv
        B.N      ??process_parsed_command_16
??process_parsed_command_112:
        LDR.W    R0,??DataTable145_6
        LDRB     R0,[R0, #+2]
        LSLS     R0,R0,#+29
        BPL.N    ??process_parsed_command_295
        LDR.W    R5,??DataTable145_7
        LDR.N    R7,??process_parsed_command_191
        LDRB     R0,[R5, #+18]
        CBNZ.N   R0,??process_parsed_command_296
        STR      R0,[R7, #+0]
??process_parsed_command_297:
        MOVS     R0,#+1
??process_parsed_command_298:
        EOR      R0,R0,#0x1
        B.N      ??process_parsed_command_299
??process_parsed_command_296:
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BEQ.N    ??process_parsed_command_297
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??process_parsed_command_298
        Nop      
        DATA
??process_parsed_command_191:
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN7Planner17min_feedrate_mm_sE
        DC32     _ZN7Planner24min_travel_feedrate_mm_sE
        DC32     _ZN7Planner19min_segment_time_usE
        DC32     _ZN7Planner8max_jerkE
        THUMB
??process_parsed_command_295:
        MOVS     R0,#+0
??process_parsed_command_299:
          CFI FunCall _ZN14MarlinSettings6reportEb
        BL       _ZN14MarlinSettings6reportEb
        B.N      ??process_parsed_command_16
??process_parsed_command_115:
        LDR.W    R0,??DataTable145_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable148_21
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable145_6
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??process_parsed_command_300
        LDR.W    R5,??DataTable145_7
        LDR.W    R7,??DataTable148_22
        LDRB     R0,[R5, #+25]
        CBZ.N    R0,??process_parsed_command_301
        LDR.W    R1,??DataTable145_8
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??process_parsed_command_301:
        STR      R0,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??DataTable148_23  ;; 0xc1a00000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??process_parsed_command_302
        LDR.W    R1,??DataTable148_24  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??process_parsed_command_302
        LDR.N    R1,??process_parsed_command_207+0x4
        STR      R0,[R1, #+124]
??process_parsed_command_300:
        LDR.N    R0,??process_parsed_command_207+0x4
        LDR      R1,[R0, #+124]
        LDR.W    R0,??DataTable148_25
??process_parsed_command_190:
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
??process_parsed_command_133:
        LDR.N    R0,??DataTable144
        MOVS     R1,#+10
??process_parsed_command_28:
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??process_parsed_command_16
??process_parsed_command_302:
        LDR.W    R0,??DataTable149
        B.N      ??process_parsed_command_120
??process_parsed_command_97:
        LDR.W    R0,??DataTable145_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??DataTable149_1
??process_parsed_command_120:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??process_parsed_command_16
??process_parsed_command_118:
        LDR.N    R1,??process_parsed_command_207+0x4
        MOVS     R0,#+1
        STRB     R0,[R1, #+4]
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??DataTable148_22
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_303
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CMP      R0,#+0
        BNE.N    ??process_parsed_command_16
        B.N      ??process_parsed_command_304
??process_parsed_command_303:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBNZ.N   R0,??process_parsed_command_16
??process_parsed_command_304:
          CFI FunCall _Z24FlushSerialRequestResendv
        BL       _Z24FlushSerialRequestResendv
        B.N      ??process_parsed_command_16
??process_parsed_command_3:
        LDR.W    R0,??DataTable149_2
        LDR      R4,[R0, #+0]
        LDR.N    R0,??process_parsed_command_207+0x4
        LDRB     R0,[R0, #+10]
        UXTB     R4,R4
        CMP      R4,R0
        BEQ.N    ??process_parsed_command_305
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??DataTable148_22
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??process_parsed_command_306
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R5,R0,#+1
        SBCS     R5,R5,R5
        MVNS     R5,R5
        LSRS     R5,R5,#+31
        B.N      ??process_parsed_command_307
        Nop      
        DATA
??process_parsed_command_207:
        DC32     mksCfg
        DC32     axis_relative_modes
        THUMB
??process_parsed_command_306:
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        MOV      R5,R0
        B.N      ??process_parsed_command_307
??process_parsed_command_305:
        MOVS     R5,#+1
??process_parsed_command_307:
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??process_parsed_command_308
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
??process_parsed_command_308:
        LDR.W    R1,??DataTable148_14  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R0
        MOV      R2,R5
        MOV      R0,R4
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
        B.N      ??process_parsed_command_16
??process_parsed_command_4:
        LDR.W    R0,??DataTable151
          CFI FunCall _ZN11GCodeParser21unknown_command_errorEv
        BL       _ZN11GCodeParser21unknown_command_errorEv
??process_parsed_command_16:
        MOVS     R0,#+0
        STRB     R0,[R8, #+9]
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.W      ?Subroutine4
          CFI EndBlock cfiBlock63

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141:
        DC32     mksCfg+0x36

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable141_1:
        DC32     _ZZ15gcode_M666_dualvEs_0
// 13771 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock64 Using cfiCommon0
          CFI Function _Z20process_next_commandv
        THUMB
// 13772 void process_next_command() 
// 13773 {
_Z20process_next_commandv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
// 13774   char * const current_command = command_queue[cmd_queue_index_r];
        LDR.W    R0,??DataTable148_26
        LDRB     R1,[R0, #+7]
// 13775 
// 13776   if (DEBUGGING(ECHO)) {
        LDRB     R0,[R0, #+5]
        ADD      R2,R1,R1, LSL #+1
        LDR.W    R1,??DataTable151_1
        ADD      R4,R1,R2, LSL #+5
        LSLS     R0,R0,#+31
        BPL.N    ??process_next_command_0
// 13777     SERIAL_ECHO_START();
        LDR.N    R0,??DataTable145_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13778     SERIAL_ECHOLN(current_command);
        LDR.N    R5,??DataTable144
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEPKc
        BL       _ZN5Print5printEPKc
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13779     #if ENABLED(M100_FREE_MEMORY_WATCHER)
// 13780       SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
// 13781       M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
// 13782     #endif
// 13783   }
// 13784 
// 13785   // Parse the next command in the queue
// 13786   parser.parse(current_command);
??process_next_command_0:
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
// 13787   process_parsed_command();
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z22process_parsed_commandv
        B.W      _Z22process_parsed_commandv
          CFI EndBlock cfiBlock64
// 13788 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142:
        DC32     _ZZ10gcode_M211vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_1:
        DC32     _ZZ10gcode_M211vEs_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_2:
        DC32     _ZZ10gcode_M211vEs_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_3:
        DC32     _ZZ10gcode_M211vEs_2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_4:
        DC32     _ZZ10gcode_M211vEs_3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable142_5:
        DC32     _ZZ10gcode_M211vEs_4
// 13789 
// 13790 /**
// 13791  * Send a "Resend: nnn" message to the host to
// 13792  * indicate that a command needs to be re-sent.
// 13793  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock65 Using cfiCommon0
          CFI Function _Z24FlushSerialRequestResendv
          CFI FunCall _Z10ok_to_sendv
        THUMB
// 13794 void FlushSerialRequestResend() {
_Z24FlushSerialRequestResendv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13795   //char command_queue[cmd_queue_index_r][100]="Resend:";
// 13796   MYSERIAL.flush();
        LDR.N    R4,??DataTable144
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5flushEv
        BL       _ZN10USARTClass5flushEv
// 13797   SERIAL_PROTOCOLPGM(MSG_RESEND);
        LDR.W    R0,??DataTable151_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13798   SERIAL_PROTOCOLLN(gcode_LastN + 1);
        LDR.W    R0,??DataTable148_26
        LDR      R0,[R0, #+108]
        ADDS     R1,R0,#+1
        MOVS     R2,#+10
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 13799   ok_to_send();
        POP      {R4,LR}
          CFI EndBlock cfiBlock65
        REQUIRE _Z10ok_to_sendv
        ;; // Fall through to label ok_to_send()
// 13800 }
// 13801 
// 13802 /**
// 13803  * Send an "ok" message to the host, indicating
// 13804  * that a command was successfully processed.
// 13805  *
// 13806  * If ADVANCED_OK is enabled also include:
// 13807  *   N<int>  Line number of the command, if any
// 13808  *   P<int>  Planner space remaining
// 13809  *   B<int>  Block queue space remaining
// 13810  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock66 Using cfiCommon0
          CFI Function _Z10ok_to_sendv
        THUMB
// 13811 void ok_to_send() {
_Z10ok_to_sendv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 13812   refresh_cmd_timeout();
        LDR.W    R4,??DataTable148_26
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
// 13813   if (!send_ok[cmd_queue_index_r]) return;
        LDR.W    R1,??DataTable151_3
        STR      R0,[R4, #+120]
        LDRB     R0,[R4, #+7]
        ADDS     R0,R0,R1
        LDRB     R0,[R0, #+20]
        CBZ.N    R0,??ok_to_send_0
// 13814   SERIAL_PROTOCOLPGM(MSG_OK);
        ADR.N    R0,??DataTable145  ;; 0x6F, 0x6B, 0x00, 0x00
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 13815   #if ENABLED(ADVANCED_OK)
// 13816     char* p = command_queue[cmd_queue_index_r];
// 13817     if (*p == 'N') {
// 13818       SERIAL_PROTOCOL(' ');
// 13819       SERIAL_ECHO(*p++);
// 13820       while (NUMERIC_SIGNED(*p))
// 13821         SERIAL_ECHO(*p++);
// 13822     }
// 13823     SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
// 13824     SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
// 13825   #endif
// 13826   SERIAL_EOL();
        LDR.N    R0,??DataTable144
        POP      {R4,LR}
          CFI R4 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        B.W      ??Subroutine6_0
          CFI R4 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??ok_to_send_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock66
// 13827 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143:
        DC32     _ZZ15gcode_M666_dualvEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_1:
        DC32     _ZZ10gcode_M211vEs_5

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_2:
        DC32     _ZZ10gcode_M211vEs_6

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable143_3:
        DC32     _ZZ10gcode_M218vEs
// 13828 
// 13829 #if HAS_SOFTWARE_ENDSTOPS
// 13830 
// 13831   /**
// 13832    * Constrain the given coordinates to the software endstops.
// 13833    *
// 13834    * For DELTA/SCARA the XY constraint is based on the smallest
// 13835    * radius within the set software endstops.
// 13836    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock67 Using cfiCommon0
          CFI Function _Z26clamp_to_software_endstopsPf
        THUMB
// 13837   void clamp_to_software_endstops(float target[XYZ]) {
_Z26clamp_to_software_endstopsPf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 13838     if (!soft_endstops_enabled) return;
        LDR.W    R5,??DataTable148_26
        MOV      R4,R0
        LDRB     R0,[R5, #+9]
        CMP      R0,#+0
        BEQ.N    ??clamp_to_software_endstops_0
// 13839     //#if IS_KINEMATIC
// 13840     if(MACHINETPYE & IS_KINEMATIC )
        LDR.W    R9,??DataTable151_4
        ADD      R10,R9,#+32
        MOVW     R1,#+770
        LDRH     R0,[R10, #+56]
        TST      R0,R1
        BEQ.N    ??clamp_to_software_endstops_1
// 13841     {
// 13842       const float dist_2 = HYPOT2(target[X_AXIS], target[Y_AXIS]);
        LDR      R7,[R4, #+0]
        MOV      R11,#+1065353216
        MOVS     R6,#+2
        MOV      R8,R11
        B.N      ??clamp_to_software_endstops_2
??clamp_to_software_endstops_3:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??clamp_to_software_endstops_2:
        LSLS     R0,R6,#+31
        BPL.N    ??clamp_to_software_endstops_4
        MOV      R0,R8
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??clamp_to_software_endstops_4:
        LSRS     R6,R6,#+1
        BNE.N    ??clamp_to_software_endstops_3
        LDR      R6,[R4, #+4]
        MOVS     R7,#+2
        B.N      ??clamp_to_software_endstops_5
??clamp_to_software_endstops_6:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??clamp_to_software_endstops_5:
        LSLS     R0,R7,#+31
        BPL.N    ??clamp_to_software_endstops_7
        MOV      R0,R11
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??clamp_to_software_endstops_7:
        LSRS     R7,R7,#+1
        BNE.N    ??clamp_to_software_endstops_6
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
// 13843       if (dist_2 > soft_endstop_radius_2) {
        LDR.W    R6,??DataTable151_5
        MOV      R1,R0
        LDR      R0,[R6, #+96]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_8
// 13844         const float ratio = soft_endstop_radius / SQRT(dist_2); // 200 / 300 = 0.66
        MOV      R0,R1
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R6, #+92]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R6,R0
// 13845         target[X_AXIS] *= ratio;
        LDR      R0,[R4, #+0]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R4, #+0]
// 13846         target[Y_AXIS] *= ratio;
        MOV      R1,R6
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        B.N      ??clamp_to_software_endstops_9
// 13847       }
// 13848     }
// 13849     //#else
// 13850     else
// 13851     {
// 13852 		if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_1:
        LDRB     R0,[R9, #+32]
        CBZ.N    R0,??clamp_to_software_endstops_10
// 13853 		{
// 13854       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
// 13855        	 	NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
        LDR      R1,[R5, #+72]
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        STRCC    R1,[R4, #+0]
// 13856       		//#endif
// 13857       		//#if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
// 13858         	NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
        LDR      R1,[R5, #+76]
        LDR      R0,[R4, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        STRCC    R1,[R4, #+4]
// 13859       		//#endif
// 13860 		}
// 13861 		if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_10:
        LDRB     R0,[R10, #+1]
        CBZ.N    R0,??clamp_to_software_endstops_8
// 13862 		{	
// 13863       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
// 13864         	NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
        LDR      R0,[R5, #+84]
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        STRCC    R0,[R4, #+0]
// 13865       		//#endif
// 13866       		//#if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
// 13867         	NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
        LDR      R0,[R5, #+88]
        LDR      R1,[R4, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??clamp_to_software_endstops_8
??clamp_to_software_endstops_9:
        STR      R0,[R4, #+4]
// 13868       		//#endif
// 13869 		}
// 13870     }
// 13871     //#endif
// 13872 	if(mksCfg.min_software_endstops)
??clamp_to_software_endstops_8:
        LDRB     R0,[R9, #+32]
        CBZ.N    R0,??clamp_to_software_endstops_11
// 13873 	{
// 13874     //#if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
// 13875       NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
        LDR      R1,[R5, #+80]
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        STRCC    R1,[R4, #+8]
// 13876     //#endif
// 13877 	}
// 13878 	if(mksCfg.max_software_endstops)
??clamp_to_software_endstops_11:
        LDRB     R0,[R10, #+1]
        CBZ.N    R0,??clamp_to_software_endstops_0
// 13879 	{
// 13880     //#if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
// 13881       NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
        LDR      R0,[R5, #+92]
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        STRCC    R0,[R4, #+8]
// 13882     //#endif
// 13883 	}
// 13884   }
??clamp_to_software_endstops_0:
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock67

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_1:
        DC32     _ZN7Planner15flow_percentageE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_2:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_3:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_4:
        DC32     _ZN7Planner21volumetric_multiplierE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_5:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable144_6:
        DC32     0x40012c34
// 13885 
// 13886 #endif
// 13887 
// 13888 #if 1//ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 13889 
// 13890   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
// 13891     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
// 13892     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
// 13893     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
// 13894     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
// 13895     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
// 13896   #else
// 13897     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
// 13898     #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
// 13899     #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
// 13900     #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
// 13901     #define ABL_BG_GRID(X,Y)  z_values[X][Y]
// 13902   #endif
// 13903 
// 13904   // Get the Z adjustment for non-linear bed leveling

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock68 Using cfiCommon0
          CFI Function _Z17bilinear_z_offsetPKf
        THUMB
// 13905   float bilinear_z_offset(const float raw[XYZ]) {
_Z17bilinear_z_offsetPKf:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
// 13906 
// 13907     static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
// 13908                  last_x = -999.999, last_y = -999.999;
// 13909 
// 13910     // Whole units for the grid line indices. Constrained within bounds.
// 13911     static int8_t gridx, gridy, nextx, nexty,
// 13912                   last_gridx = -99, last_gridy = -99;
// 13913 
// 13914     // XY relative to the probed area
// 13915     const float rx = raw[X_AXIS] - bilinear_start[X_AXIS],
        LDR.W    R4,??DataTable151_6
        MOV      R5,R0
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 13916                 ry = raw[Y_AXIS] - bilinear_start[Y_AXIS];
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R5, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 13917 
// 13918     #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
// 13919       // Keep using the last grid box
// 13920       #define FAR_EDGE_OR_BOX 2
// 13921     #else
// 13922       // Just use the grid far edge
// 13923       #define FAR_EDGE_OR_BOX 1
// 13924     #endif
// 13925 
// 13926     if (last_x != rx) {
        LDR      R0,[R4, #+64]
        MOV      R1,R6
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??bilinear_z_offset_0
// 13927       last_x = rx;
// 13928       ratio_x = rx * ABL_BG_FACTOR(X_AXIS);
        LDR      R0,[R4, #+24]
        STR      R6,[R4, #+64]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
// 13929       const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
        LDR.W    R6,??DataTable151_4
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R8,R1
        BCC.N    ??bilinear_z_offset_1
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R9,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R9
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R8,R0
        BCC.N    ??bilinear_z_offset_1
        MOV      R0,R7
          CFI FunCall floorf
        BL       floorf
        MOV      R8,R0
// 13930       ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
??bilinear_z_offset_1:
        MOV      R0,R7
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
// 13931 
// 13932       #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13933         // Beyond the grid maintain height at grid edges
// 13934         NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R0,#+0
        STR      R0,[R4, #+56]
// 13935       #endif
// 13936 
// 13937       gridx = gx;
        MOV      R0,R8
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STRB     R0,[R4, #+0]
// 13938       nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
        SXTB     R0,R0
        LDRB     R1,[R6, #+96]
        ADDS     R2,R0,#+1
        SUBS     R3,R1,#+1
        CMP      R2,R3
        ITE      LT 
        ADDLT    R0,R0,#+1
        SUBGE    R0,R1,#+1
        STRB     R0,[R4, #+2]
// 13939     }
// 13940 
// 13941     if (last_y != ry || last_gridx != gridx) {
??bilinear_z_offset_0:
        LDR      R0,[R4, #+68]
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??bilinear_z_offset_2
        LDRSB    R0,[R4, #+4]
        LDRSB    R1,[R4, #+0]
        CMP      R0,R1
        BEQ.W    ??bilinear_z_offset_3
        B.N      ??bilinear_z_offset_4
// 13942 
// 13943       if (last_y != ry) {
// 13944         last_y = ry;
// 13945         ratio_y = ry * ABL_BG_FACTOR(Y_AXIS);
??bilinear_z_offset_2:
        LDR      R0,[R4, #+28]
        STR      R5,[R4, #+68]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
// 13946         const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
          CFI FunCall floorf
        BL       floorf
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R6,#+0
        BCC.N    ??bilinear_z_offset_5
        MOV      R0,R5
          CFI FunCall floorf
        BL       floorf
        LDR.W    R6,??DataTable151_4
        ADD      R1,R6,#+96
        MOV      R7,R0
        LDRB     R0,[R1, #+1]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R6,R0
        BCC.N    ??bilinear_z_offset_5
        MOV      R0,R5
          CFI FunCall floorf
        BL       floorf
        MOV      R6,R0
// 13947         ratio_y -= gy;
??bilinear_z_offset_5:
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
// 13948 
// 13949         #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
// 13950           // Beyond the grid maintain height at grid edges
// 13951           NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R0,#+0
        STR      R0,[R4, #+60]
// 13952         #endif
// 13953 
// 13954         gridy = gy;
        MOV      R0,R6
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
// 13955         nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
        LDR.W    R6,??DataTable151_4
        STRB     R0,[R4, #+1]
        ADD      R1,R6,#+96
        SXTB     R0,R0
        LDRB     R1,[R1, #+1]
        ADDS     R2,R0,#+1
        SUBS     R3,R1,#+1
        CMP      R2,R3
        ITE      LT 
        ADDLT    R0,R0,#+1
        SUBGE    R0,R1,#+1
        STRB     R0,[R4, #+3]
// 13956       }
// 13957 
// 13958       if (last_gridx != gridx || last_gridy != gridy) {
??bilinear_z_offset_4:
        LDRSB    R0,[R4, #+0]
        LDRSB    R1,[R4, #+4]
        LDRSB    R5,[R4, #+1]
        CMP      R1,R0
        ITT      EQ 
        LDRSBEQ  R1,[R4, #+5]
        CMPEQ    R1,R5
        BEQ.N    ??bilinear_z_offset_6
// 13959         last_gridx = gridx;
        STRB     R0,[R4, #+4]
// 13960         last_gridy = gridy;
// 13961         // Z at the box corners
// 13962         z1 = ABL_BG_GRID(gridx, gridy);       // left-front
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R6,??DataTable152
        LDRSB    R7,[R4, #+3]
        STRB     R5,[R4, #+5]
        ADD      R0,R6,R1, LSL #+4
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+32]
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+36]
// 13963         d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
// 13964         z3 = ABL_BG_GRID(nextx, gridy);       // right-front
        LDRSB    R0,[R4, #+2]
        ADD      R1,R0,R0, LSL #+1
        ADD      R0,R6,R1, LSL #+4
        LDR      R1,[R0, R5, LSL #+2]
        STR      R1,[R4, #+40]
// 13965         d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+44]
// 13966       }
// 13967 
// 13968       // Bilinear interpolate. Needed since ry or gridx has changed.
// 13969                   L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
??bilinear_z_offset_6:
        LDR      R5,[R4, #+60]
        LDR      R0,[R4, #+36]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+32]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
// 13970       const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
// 13971 
// 13972       D = R - L;
        LDR      R0,[R4, #+44]
        STR      R6,[R4, #+48]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+40]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+52]
// 13973     }
// 13974 
// 13975     const float offset = L + ratio_x * D;   // the offset almost always changes
// 13976 
// 13977     /*
// 13978     static float last_offset = 0;
// 13979     if (FABS(last_offset - offset) > 0.2) {
// 13980       SERIAL_ECHOPGM("Sudden Shift at ");
// 13981       SERIAL_ECHOPAIR("x=", rx);
// 13982       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
// 13983       SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
// 13984       SERIAL_ECHOPAIR(" y=", ry);
// 13985       SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
// 13986       SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
// 13987       SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
// 13988       SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
// 13989       SERIAL_ECHOPAIR(" z1=", z1);
// 13990       SERIAL_ECHOPAIR(" z2=", z2);
// 13991       SERIAL_ECHOPAIR(" z3=", z3);
// 13992       SERIAL_ECHOLNPAIR(" z4=", z4);
// 13993       SERIAL_ECHOPAIR(" L=", L);
// 13994       SERIAL_ECHOPAIR(" R=", R);
// 13995       SERIAL_ECHOLNPAIR(" offset=", offset);
// 13996     }
// 13997     last_offset = offset;
// 13998     //*/
// 13999 
// 14000     return offset;
??bilinear_z_offset_3:
        LDR      R1,[R4, #+56]
        LDR      R0,[R4, #+52]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R4, #+48]
        POP      {R2,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
          CFI EndBlock cfiBlock68
// 14001   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145:
        DC8      0x6F, 0x6B, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_1:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_2:
        DC32     _ZZ10gcode_M280vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_3:
        DC32     _ZZ10gcode_M280vEs_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_4:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_5:
        DC32     _ZZ10gcode_M280vEs_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_6:
        DC32     _ZN11GCodeParser8codebitsE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_7:
        DC32     _ZN11GCodeParser5paramE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_8:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_9:
        DC32     _ZN11Temperature2KpE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_10:
        DC32     0x88e368f1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_11:
        DC32     0x3fc4f8b5

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_12:
        DC32     _ZN11Temperature2KiE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_13:
        DC32     _ZN11Temperature2KdE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_14:
        DC32     _ZZ10gcode_M301vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_15:
        DC32     _ZZ10gcode_M301vEs_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_16:
        DC32     _ZZ10gcode_M301vEs_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable145_17:
        DC32     _ZZ10gcode_M301vEs_2

        SECTION `.data`:DATA:REORDER:NOROOT(2)
??gridx:
        DATA
        DC8 0
        DC8 0
        DC8 0
        DC8 0
        DC8 -99
        DC8 -99
        DC8 0, 0
bilinear_grid_spacing:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_start:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
bilinear_grid_factor:
        DC8 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC8 0, 0, 0, 0
        DC32 0C479FFF0H
        DC32 0C479FFF0H

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
_ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index:
        DATA
        DC32 -1
// 14002 
// 14003 #endif // AUTO_BED_LEVELING_BILINEAR
// 14004 
// 14005 #if 1//ENABLED(DELTA)
// 14006 
// 14007   /**
// 14008    * Recalculate factors used for delta kinematics whenever
// 14009    * settings have been changed (e.g., by M665).
// 14010    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock69 Using cfiCommon0
          CFI Function _Z21recalc_delta_settingsv
        THUMB
// 14011   void recalc_delta_settings() {
_Z21recalc_delta_settingsv:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
// 14012     const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
// 14013                 drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
// 14014     delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]); // front left tower
        LDR.W    R6,??DataTable152_1
        LDR.W    R7,??DataTable152_2  ;; 0x43520000
        LDR      R0,[R6, #+72]
        LDR.W    R5,??DataTable152_3  ;; 0x54442d18
        LDR.W    R9,??DataTable152_4  ;; 0x400921fb
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R5
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable152_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+1
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R8,R1
        MOV      R4,R0
        LDR      R1,[R6, #+116]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+12]
// 14015     delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (delta_radius + trt[A_AXIS]);
        MOV      R1,R7
        LDR      R0,[R6, #+72]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R5
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable152_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R7,R1
        MOV      R4,R0
        LDR      R1,[R6, #+116]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+16]
// 14016     delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]); // front right tower
        LDR.W    R7,??DataTable152_6  ;; 0x43a50000
        LDR      R0,[R6, #+76]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R5
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable152_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+1
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R8,R1
        MOV      R4,R0
        LDR      R1,[R6, #+116]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+20]
// 14017     delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (delta_radius + trt[B_AXIS]);
        MOVS     R4,#+0
        LDR      R0,[R6, #+76]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R5
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R4
        LDR.W    R3,??DataTable152_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R7,R1
        MOV      R4,R0
        LDR      R1,[R6, #+116]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R7
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+24]
// 14018     delta_tower[C_AXIS][X_AXIS] = cos(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]); // back middle tower
        MOVS     R4,#+1
        LDR.N    R7,??DataTable148_11  ;; 0x42b40000
        LDR      R0,[R6, #+80]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R5
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOVS     R2,#+0
        LDR.W    R3,??DataTable152_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R8,R1
        MOV      R4,R0
        LDR      R1,[R6, #+116]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R8
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+28]
// 14019     delta_tower[C_AXIS][Y_AXIS] = sin(RADIANS( 90 + delta_tower_angle_trim[C_AXIS])) * (delta_radius + trt[C_AXIS]);
        MOVS     R4,#+0
        LDR      R0,[R6, #+80]
        MOV      R1,R7
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R5
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R4
        LDR.W    R3,??DataTable152_5  ;; 0x40668000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R5,R1
        MOV      R4,R0
        LDR      R1,[R6, #+116]
        MOVS     R0,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+32]
// 14020     delta_diagonal_rod_2_tower[A_AXIS] = sq(delta_diagonal_rod + drt[A_AXIS]);
        MOVS     R0,#+0
        LDR      R1,[R6, #+120]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        MOV      R8,#+1065353216
        MOV      R7,R4
        MOVS     R5,#+2
        MOV      R9,R8
        B.N      ??recalc_delta_settings_0
??recalc_delta_settings_1:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_0:
        LSLS     R0,R5,#+31
        BPL.N    ??recalc_delta_settings_2
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_2:
        LSRS     R5,R5,#+1
        BNE.N    ??recalc_delta_settings_1
        STR      R9,[R6, #+84]
// 14021     delta_diagonal_rod_2_tower[B_AXIS] = sq(delta_diagonal_rod + drt[B_AXIS]);
        MOV      R7,R4
        MOVS     R5,#+2
        MOV      R9,R8
        B.N      ??recalc_delta_settings_3
??recalc_delta_settings_4:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??recalc_delta_settings_3:
        LSLS     R0,R5,#+31
        BPL.N    ??recalc_delta_settings_5
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??recalc_delta_settings_5:
        LSRS     R5,R5,#+1
        BNE.N    ??recalc_delta_settings_4
        STR      R9,[R6, #+88]
// 14022     delta_diagonal_rod_2_tower[C_AXIS] = sq(delta_diagonal_rod + drt[C_AXIS]);
        MOVS     R7,#+2
        B.N      ??recalc_delta_settings_6
??recalc_delta_settings_7:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??recalc_delta_settings_6:
        LSLS     R0,R7,#+31
        BPL.N    ??recalc_delta_settings_8
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??recalc_delta_settings_8:
        LSRS     R7,R7,#+1
        BNE.N    ??recalc_delta_settings_7
        STR      R8,[R6, #+92]
// 14023     update_software_endstops(Z_AXIS);
        MOVS     R0,#+2
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
// 14024     axis_homed[X_AXIS] = axis_homed[Y_AXIS] = axis_homed[Z_AXIS] = false;
        MOVS     R0,#+0
        STRB     R0,[R6, #+2]
        STRH     R0,[R6, #+0]
// 14025   }
        POP      {R0,R4-R9,PC}    ;; return
          CFI EndBlock cfiBlock69

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146:
        DC32     _ZN11Temperature5bedKpE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_1:
        DC32     _ZN11Temperature5bedKiE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_2:
        DC32     _ZN11Temperature5bedKdE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_3:
        DC32     _ZZ10gcode_M304vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_4:
        DC32     _ZZ10gcode_M304vEs_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_5:
        DC32     _ZZ10gcode_M304vEs_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_6:
        DC32     _ZN11Temperature16extrude_min_tempE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable146_7:
        DC32     _ZN11Temperature18allow_cold_extrudeE
// 14026 
// 14027   #if ENABLED(DELTA_FAST_SQRT)
// 14028     /**
// 14029      * Fast inverse sqrt from Quake III Arena
// 14030      * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
// 14031      */
// 14032     float Q_rsqrt(const float number) {
// 14033       long i;
// 14034       float x2, y;
// 14035       const float threehalfs = 1.5f;
// 14036       x2 = number * 0.5f;
// 14037       y  = number;
// 14038       i  = * ( long * ) &y;                       // evil floating point bit level hacking
// 14039       i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
// 14040       y  = * ( float * ) &i;
// 14041       y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
// 14042       // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
// 14043       return y;
// 14044     }
// 14045 
// 14046   #endif
// 14047 
// 14048   /**
// 14049    * Delta Inverse Kinematics
// 14050    *
// 14051    * Calculate the tower positions for a given machine
// 14052    * position, storing the result in the delta[] array.
// 14053    *
// 14054    * This is an expensive calculation, requiring 3 square
// 14055    * roots per segmented linear move, and strains the limits
// 14056    * of a Mega2560 with a Graphical Display.
// 14057    *
// 14058    * Suggested optimizations include:
// 14059    *
// 14060    * - Disable the home_offset (M206) and/or position_shift (G92)
// 14061    *   features to remove up to 12 float additions.
// 14062    *
// 14063    * - Use a fast-inverse-sqrt function and add the reciprocal.
// 14064    *   (see above)
// 14065    */
// 14066 
// 14067   #define DELTA_DEBUG() do { \ 
// 14068       SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \ 
// 14069       SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \ 
// 14070       SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \ 
// 14071       SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \ 
// 14072       SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \ 
// 14073       SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \ 
// 14074     }while(0)
// 14075 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock70 Using cfiCommon0
          CFI Function _Z18inverse_kinematicsPKf
        THUMB
// 14076   void inverse_kinematics(const float raw[XYZ]) {
_Z18inverse_kinematicsPKf:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R4,R0
// 14077     DELTA_IK(raw);
        LDR.W    R5,??DataTable152_1
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,#+1065353216
        MOV      R8,R0
        MOVS     R7,#+2
        MOV      R9,R6
        B.N      ??inverse_kinematics_0
??inverse_kinematics_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_0:
        LSLS     R0,R7,#+31
        BPL.N    ??inverse_kinematics_2
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_2:
        LSRS     R7,R7,#+1
        BNE.N    ??inverse_kinematics_1
        LDR      R0,[R5, #+16]
        LDR      R1,[R4, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOVS     R7,#+2
        MOV      R10,R6
        B.N      ??inverse_kinematics_3
??inverse_kinematics_4:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_3:
        LSLS     R0,R7,#+31
        BPL.N    ??inverse_kinematics_5
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_5:
        LSRS     R7,R7,#+1
        BNE.N    ??inverse_kinematics_4
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+84]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        LDR      R1,[R4, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+60]
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOVS     R7,#+2
        MOV      R9,R6
        B.N      ??inverse_kinematics_6
??inverse_kinematics_7:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_6:
        LSLS     R0,R7,#+31
        BPL.N    ??inverse_kinematics_8
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_8:
        LSRS     R7,R7,#+1
        BNE.N    ??inverse_kinematics_7
        LDR      R0,[R5, #+24]
        LDR      R1,[R4, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOVS     R7,#+2
        MOV      R10,R6
        B.N      ??inverse_kinematics_9
??inverse_kinematics_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_9:
        LSLS     R0,R7,#+31
        BPL.N    ??inverse_kinematics_11
        MOV      R0,R10
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??inverse_kinematics_11:
        LSRS     R7,R7,#+1
        BNE.N    ??inverse_kinematics_10
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+88]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+64]
        LDR      R1,[R4, #+0]
        LDR      R0,[R5, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOVS     R7,#+2
        MOV      R9,R6
        B.N      ??inverse_kinematics_12
??inverse_kinematics_13:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_12:
        LSLS     R0,R7,#+31
        BPL.N    ??inverse_kinematics_14
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??inverse_kinematics_14:
        LSRS     R7,R7,#+1
        BNE.N    ??inverse_kinematics_13
        LDR      R0,[R5, #+32]
        LDR      R1,[R4, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOVS     R7,#+2
        B.N      ??inverse_kinematics_15
??inverse_kinematics_16:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_15:
        LSLS     R0,R7,#+31
        BPL.N    ??inverse_kinematics_17
        MOV      R0,R6
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??inverse_kinematics_17:
        LSRS     R7,R7,#+1
        BNE.N    ??inverse_kinematics_16
        MOV      R0,R9
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+68]
// 14078     // DELTA_DEBUG();
// 14079   }
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock70
// 14080 
// 14081   /**
// 14082    * Calculate the highest Z position where the
// 14083    * effector has the full range of XY motion.
// 14084    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock71 Using cfiCommon0
          CFI Function _Z28delta_safe_distance_from_topv
        THUMB
// 14085   float delta_safe_distance_from_top() {
_Z28delta_safe_distance_from_topv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+16
          CFI CFA R13+32
// 14086     float cartesian[XYZ] = { 0, 0, 0 };
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        STM      R0!,{R1-R3}
// 14087 	if(MACHINETPYE == MORGAN_SCARA)
        LDR.W    R4,??DataTable151_4
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        ADD      R0,SP,#+0
        BNE.N    ??delta_safe_distance_from_top_0
// 14088 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_1
// 14089 	else
// 14090     	inverse_kinematics(cartesian);
??delta_safe_distance_from_top_0:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 14091 	
// 14092     float distance = delta[A_AXIS];
// 14093     cartesian[Y_AXIS] = DELTA_PRINTABLE_RADIUS;
??delta_safe_distance_from_top_1:
        LDR      R0,[R4, #+84]
        LDR.W    R5,??DataTable152_1
        LDR      R6,[R5, #+60]
        STR      R0,[SP, #+4]
// 14094 	if(MACHINETPYE == MORGAN_SCARA)
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+256
        ADD      R0,SP,#+0
        BNE.N    ??delta_safe_distance_from_top_2
// 14095 		inverse_kinematics_MORGAN_SCARA(cartesian);
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??delta_safe_distance_from_top_3
// 14096 	else
// 14097     	inverse_kinematics(cartesian);
??delta_safe_distance_from_top_2:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
// 14098     return FABS(distance - delta[A_AXIS]);
??delta_safe_distance_from_top_3:
        LDR      R1,[R5, #+60]
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        ADD      SP,SP,#+16
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock71
// 14099   }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148:
        DC32     _ZZ10gcode_M302vEs_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_1:
        DC32     _ZZ10gcode_M302vEs_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_2:
        DC32     _ZZ10gcode_M302vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_3:
        DC32     _ZZ10gcode_M302vEs_2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_4:
        DC32     _ZZ10gcode_M302vEs_3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_5:
        DC32     _ZZ10gcode_M303vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_6:
        DC32     0x428c0000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_7:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_8:
        DC32     _ZZ10gcode_M360vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_9:
        DC32     0x42f00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_10:
        DC32     _ZZ10gcode_M361vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_11:
        DC32     0x42b40000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_12:
        DC32     0x43020000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_13:
        DC32     _ZZ10gcode_M362vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_14:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_15:
        DC32     0x43340000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_16:
        DC32     _ZZ10gcode_M363vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_17:
        DC32     0x42480000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_18:
        DC32     _ZZ10gcode_M364vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_19:
        DC32     0x42340000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_20:
        DC32     0x43070000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_21:
        DC32     _ZZ10gcode_M851vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_22:
        DC32     _ZN11GCodeParser9value_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_23:
        DC32     0xc1a00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_24:
        DC32     0x41a00001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_25:
        DC32     _ZZ10gcode_M851vEs_1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable148_26:
        DC32     axis_relative_modes
// 14100 
// 14101   /**
// 14102    * Delta Forward Kinematics
// 14103    *
// 14104    * See the Wikipedia article "Trilateration"
// 14105    * https://en.wikipedia.org/wiki/Trilateration
// 14106    *
// 14107    * Establish a new coordinate system in the plane of the
// 14108    * three carriage points. This system has its origin at
// 14109    * tower1, with tower2 on the X axis. Tower3 is in the X-Y
// 14110    * plane with a Z component of zero.
// 14111    * We will define unit vectors in this coordinate system
// 14112    * in our original coordinate system. Then when we calculate
// 14113    * the Xnew, Ynew and Znew values, we can translate back into
// 14114    * the original system by moving along those unit vectors
// 14115    * by the corresponding values.
// 14116    *
// 14117    * Variable names matched to Marlin, c-version, and avoid the
// 14118    * use of any vector library.
// 14119    *
// 14120    * by Andreas Hardtung 2016-06-07
// 14121    * based on a Java function from "Delta Robot Kinematics V3"
// 14122    * by Steve Graves
// 14123    *
// 14124    * The result is stored in the cartes[] array.
// 14125    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock72 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAfff
        THUMB
// 14126   void forward_kinematics_DELTA(float z1, float z2, float z3) {
_Z24forward_kinematics_DELTAfff:
        PUSH     {R0,R2,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        MOV      R4,R1
        LDR.W    R0,??DataTable153
        LDR.W    R1,??DataTable153
        LDR      R0,[R0, #+20]
        LDR      R1,[R1, #+12]
        SUB      SP,SP,#+36
          CFI CFA R13+80
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
// 14127     // Create a vector in old coordinates along x axis of new coordinate
// 14128     const float p12[] = {
        LDR.W    R0,??DataTable153
        LDR.W    R1,??DataTable153
        LDR      R0,[R0, #+24]
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+36]
        MOV      R9,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
// 14129       delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 14130       delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 14131       z2 - z1
// 14132     },
// 14133 
// 14134     // Get the Magnitude of vector.
// 14135     d = SQRT(sq(p12[0]) + sq(p12[1]) + sq(p12[2])),
        MOV      R8,R10
        MOVS     R5,#+2
        MOV      R11,#+1065353216
        B.N      ??forward_kinematics_DELTA_0
??forward_kinematics_DELTA_1:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_0:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_2
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_2:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_1
        MOV      R5,R9
        MOVS     R6,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_3
??forward_kinematics_DELTA_4:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_3:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_5
        MOV      R0,R8
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_5:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_4
        MOV      R7,R4
        MOVS     R5,#+2
        MOV      R6,#+1065353216
        B.N      ??forward_kinematics_DELTA_6
??forward_kinematics_DELTA_7:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_6:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_8
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_8:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_7
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+20]
// 14136 
// 14137     // Create unit vector by dividing by magnitude.
// 14138     ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d },
        MOV      R0,R10
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[SP, #+20]
        STR      R0,[SP, #+16]
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+12]
        MOV      R0,R4
        LDR      R1,[SP, #+20]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
// 14139 
// 14140     // Get the vector from the origin of the new system to the third point.
// 14141     p13[3] = {
        LDR.W    R1,??DataTable153
        LDR      R1,[R1, #+12]
        STR      R0,[SP, #+8]
        LDR.W    R0,??DataTable153
        LDR      R0,[R0, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R1,??DataTable153
        LDR      R1,[R1, #+16]
        MOV      R5,R0
        LDR.W    R0,??DataTable153
        LDR      R0,[R0, #+32]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+36]
        MOV      R6,R0
        LDR      R0,[SP, #+40]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
// 14142       delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS],
// 14143       delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS],
// 14144       z3 - z1
// 14145     },
// 14146 
// 14147     // Use the dot product to find the component of this vector on the X axis.
// 14148     i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2],
        LDR      R0,[SP, #+16]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
// 14149 
// 14150     // Create a vector along the x axis that represents the x component of p13.
// 14151     iex[] = { ex[0] * i, ex[1] * i, ex[2] * i };
// 14152 
// 14153     // Subtract the X component from the original vector leaving only Y. We use the
// 14154     // variable that will be the unit vector after we scale it.
// 14155     float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
        LDR      R0,[SP, #+16]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R10,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 14156 
// 14157     // The magnitude of Y component
// 14158     const float j = SQRT(sq(ey[0]) + sq(ey[1]) + sq(ey[2]));
        MOV      R8,R9
        MOVS     R5,#+2
        MOV      R11,#+1065353216
        B.N      ??forward_kinematics_DELTA_9
??forward_kinematics_DELTA_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_9:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_11
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??forward_kinematics_DELTA_11:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_10
        MOV      R5,R10
        MOVS     R6,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_12
??forward_kinematics_DELTA_13:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_12:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_14
        MOV      R0,R8
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_14:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_13
        LDR      R7,[SP, #+24]
        MOVS     R5,#+2
        MOV      R6,#+1065353216
        B.N      ??forward_kinematics_DELTA_15
??forward_kinematics_DELTA_16:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_15:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_17
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_17:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_16
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+4]
// 14159 
// 14160     // Convert to a unit vector
// 14161     ey[0] /= j; ey[1] /= j;  ey[2] /= j;
        MOV      R0,R9
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[SP, #+4]
        MOV      R9,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R10,R0
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R11,R0
// 14162 
// 14163     // The cross product of the unit x and y is the unit z
// 14164     // float[] ez = vectorCrossProd(ex, ey);
// 14165     const float ez[3] = {
        LDR      R0,[SP, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
        MOV      R1,R9
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+16]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+32]
        MOV      R1,R10
        LDR      R0,[SP, #+16]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
// 14166       ex[1] * ey[2] - ex[2] * ey[1],
// 14167       ex[2] * ey[0] - ex[0] * ey[2],
// 14168       ex[0] * ey[1] - ex[1] * ey[0]
// 14169     },
// 14170     // We now have the d, i and j values defined in Wikipedia.
// 14171     // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
// 14172     Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
        MOVS     R6,#+2
        LDR      R5,[SP, #+20]
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_18
??forward_kinematics_DELTA_19:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_18:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_20
        MOV      R0,R8
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_20:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_19
        LDR.W    R0,??DataTable153
        LDR.W    R1,??DataTable153
        LDR      R0,[R0, #+84]
        LDR      R1,[R1, #+88]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+20]
        MOV      R5,R0
        MOV      R0,#+1073741824
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+0]
// 14173     Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
        MOV      R5,R4
        MOVS     R6,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_21
??forward_kinematics_DELTA_22:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_21:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_23
        MOV      R0,R8
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_23:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_22
        LDR      R7,[SP, #+4]
        MOVS     R5,#+2
        MOV      R6,#+1065353216
        B.N      ??forward_kinematics_DELTA_24
??forward_kinematics_DELTA_25:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_24:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_26
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_26:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_25
        LDR.W    R0,??DataTable153
        LDR.W    R1,??DataTable153
        LDR      R0,[R0, #+84]
        LDR      R1,[R1, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        MOV      R0,R8
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
// 14174     Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
        LDR      R5,[SP, #+0]
        MOV      R4,R0
        MOVS     R6,#+2
        MOV      R8,#+1065353216
        B.N      ??forward_kinematics_DELTA_27
??forward_kinematics_DELTA_28:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??forward_kinematics_DELTA_27:
        LSLS     R0,R6,#+31
        BPL.N    ??forward_kinematics_DELTA_29
        MOV      R0,R8
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??forward_kinematics_DELTA_29:
        LSRS     R6,R6,#+1
        BNE.N    ??forward_kinematics_DELTA_28
        MOV      R7,R4
        MOVS     R5,#+2
        MOV      R6,#+1065353216
        B.N      ??forward_kinematics_DELTA_30
??forward_kinematics_DELTA_31:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??forward_kinematics_DELTA_30:
        LSLS     R0,R5,#+31
        BPL.N    ??forward_kinematics_DELTA_32
        MOV      R0,R6
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??forward_kinematics_DELTA_32:
        LSRS     R5,R5,#+1
        BNE.N    ??forward_kinematics_DELTA_31
        MOV      R0,R8
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR.W    R0,??DataTable153
        LDR      R0,[R0, #+84]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
// 14175 
// 14176     // Start from the origin of the old coordinates and add vectors in the
// 14177     // old coords that represent the Xnew, Ynew and Znew to find the point
// 14178     // in the old system.
// 14179     cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
        LDR.N    R5,??DataTable151_7
        LDR      R1,[SP, #+16]
        MOV      R7,R0
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.W    R1,??DataTable153
        LDR      R1,[R1, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        LDR      R0,[SP, #+24]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R5, #+96]
// 14180     cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
        LDR      R1,[SP, #+12]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.W    R1,??DataTable153
        LDR      R1,[R1, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,R10
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        LDR      R0,[SP, #+32]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R5, #+100]
// 14181     cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
        LDR      R1,[SP, #+8]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+36]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,R11
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R0,[SP, #+28]
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R5, #+104]
// 14182   }
        ADD      SP,SP,#+44
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock72

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149:
        DC32     _ZZ10gcode_M851vEs_0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_1:
        DC32     _ZZ10gcode_M355vEs

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable149_2:
        DC32     _ZN11GCodeParser7codenumE
// 14183 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock73 Using cfiCommon0
          CFI Function _Z24forward_kinematics_DELTAPf
        THUMB
// 14184   void forward_kinematics_DELTA(float point[ABC]) {
// 14185     forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
_Z24forward_kinematics_DELTAPf:
        LDR      R2,[R0, #+8]
        LDR      R1,[R0, #+4]
        LDR      R0,[R0, #+0]
          CFI FunCall _Z24forward_kinematics_DELTAfff
        B.N      _Z24forward_kinematics_DELTAfff
          CFI EndBlock cfiBlock73
// 14186   }
// 14187 
// 14188 #endif // DELTA
// 14189 
// 14190 /**
// 14191  * Get the stepper positions in the cartes[] array.
// 14192  * Forward kinematics are applied for DELTA and SCARA.
// 14193  *
// 14194  * The result is in the current coordinate space with
// 14195  * leveling applied. The coordinates need to be run through
// 14196  * unapply_leveling to obtain machine coordinates suitable
// 14197  * for current_position, etc.
// 14198  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock74 Using cfiCommon0
          CFI Function _Z27get_cartesian_from_steppersv
        THUMB
// 14199 void get_cartesian_from_steppers() {
_Z27get_cartesian_from_steppersv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        LDR.N    R0,??DataTable151_4
        LDRSH    R0,[R0, #+88]
        SUB      SP,SP,#+12
          CFI CFA R13+24
        CMP      R0,#+2
        BNE.N    ??get_cartesian_from_steppers_0
// 14200   //#if ENABLED(DELTA)
// 14201   if(MACHINETPYE == DELTA)  {
// 14202     forward_kinematics_DELTA(
// 14203       stepper.get_axis_position_mm(A_AXIS),
// 14204       stepper.get_axis_position_mm(B_AXIS),
// 14205       stepper.get_axis_position_mm(C_AXIS)
// 14206     );
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R4,R0
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R5,R0
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        MOV      R2,R4
        MOV      R1,R5
          CFI FunCall _Z24forward_kinematics_DELTAfff
        BL       _Z24forward_kinematics_DELTAfff
// 14207   	}
// 14208   //#else
// 14209   else
// 14210   {
// 14211     //#if IS_SCARA
// 14212 	if(MACHINETPYE&IS_SCARA) {
// 14213       forward_kinematics_SCARA(
// 14214         stepper.get_axis_position_degrees(A_AXIS),
// 14215         stepper.get_axis_position_degrees(B_AXIS)
// 14216       );
// 14217 	}
// 14218     //#else
// 14219     else
// 14220     {
// 14221       cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
// 14222       cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
// 14223     }
// 14224     //#endif
// 14225     cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
// 14226   }
// 14227   //#endif
// 14228 }
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}
          CFI CFA R13+24
??get_cartesian_from_steppers_0:
        MOV      R1,#+768
        LDR.N    R4,??DataTable151_7
        TST      R0,R1
        BEQ.N    ??get_cartesian_from_steppers_1
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[SP, #+0]
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z24forward_kinematics_SCARARKfS0_
        BL       _Z24forward_kinematics_SCARARKfS0_
        B.N      ??get_cartesian_from_steppers_2
??get_cartesian_from_steppers_1:
        MOVS     R0,#+0
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+96]
        MOVS     R0,#+1
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+100]
??get_cartesian_from_steppers_2:
        MOVS     R0,#+2
          CFI FunCall _ZN7Stepper20get_axis_position_mmE8AxisEnum
        BL       _ZN7Stepper20get_axis_position_mmE8AxisEnum
        STR      R0,[R4, #+104]
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock74
// 14229 
// 14230 /**
// 14231  * Set the current_position for an axis based on
// 14232  * the stepper positions, removing any leveling that
// 14233  * may have been applied.
// 14234  *
// 14235  * To prevent small shifts in axis position always call
// 14236  * SYNC_PLAN_POSITION_KINEMATIC after updating axes with this.
// 14237  *
// 14238  * To keep hosts in sync, always call report_current_position
// 14239  * after updating the current_position.
// 14240  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock75 Using cfiCommon0
          CFI Function _Z34set_current_from_steppers_for_axis8AxisEnum
        THUMB
// 14241 void set_current_from_steppers_for_axis(const AxisEnum axis) {
_Z34set_current_from_steppers_for_axis8AxisEnum:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
// 14242   get_cartesian_from_steppers();
          CFI FunCall _Z27get_cartesian_from_steppersv
        BL       _Z27get_cartesian_from_steppersv
// 14243   //#if PLANNER_LEVELING
// 14244   if(BED_LEVELING_METHOD&PLANNER_LEVELING)
        LDR.N    R0,??DataTable151_4
        LDR.N    R5,??DataTable151_7
        LDRB     R0,[R0, #+66]
        MOVS     R1,#+46
        TST      R0,R1
        ITT      NE 
// 14245     planner.unapply_leveling(cartes);
        ADDNE    R0,R5,#+96
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BLNE     _ZN7Planner16unapply_levelingEPf
// 14246   //#endif
// 14247   if (axis == ALL_AXES)
        CMP      R4,#+100
        BNE.N    ??set_current_from_steppers_for_axis_0
// 14248     COPY(current_position, cartes);
        ADD      R0,R5,#+96
        LDM      R0!,{R2-R4}
        ADD      R1,R5,#+16
        STM      R1!,{R2-R4}
        POP      {R0,R4,R5,PC}
// 14249   else
// 14250     current_position[axis] = cartes[axis];
??set_current_from_steppers_for_axis_0:
        ADD      R0,R5,R4, LSL #+2
        LDR      R1,[R0, #+96]
        STR      R1,[R0, #+16]
// 14251 }
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock75

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151:
        DC32     parser

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_1:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_2:
        DC32     `?<Constant "Resend: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_3:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_4:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_5:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_6:
        DC32     ??gridx

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable151_7:
        DC32     axis_relative_modes
// 14252 
// 14253 #if 1//IS_CARTESIAN
// 14254 #if 1//ENABLED(SEGMENT_LEVELED_MOVES)
// 14255 
// 14256   /**
// 14257    * Prepare a segmented move on a CARTESIAN setup.
// 14258    *
// 14259    * This calls planner.buffer_line several times, adding
// 14260    * small incremental moves. This allows the planner to
// 14261    * apply more detailed bed leveling to the full move.
// 14262    */
// 14263   inline void segmented_line_to_destination(const float &fr_mm_s, const float segment_size=LEVELED_SEGMENT_LENGTH) {
// 14264 
// 14265     const float xdiff = destination[X_AXIS] - current_position[X_AXIS],
// 14266                 ydiff = destination[Y_AXIS] - current_position[Y_AXIS];
// 14267 
// 14268     // If the move is only in Z/E don't split up the move
// 14269     if (!xdiff && !ydiff) {
// 14270       planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 14271       return;
// 14272     }
// 14273 
// 14274     // Remaining cartesian distances
// 14275     const float zdiff = destination[Z_AXIS] - current_position[Z_AXIS],
// 14276                 ediff = destination[E_AXIS] - current_position[E_AXIS];
// 14277 
// 14278     // Get the linear distance in XYZ
// 14279     // If the move is very short, check the E move distance
// 14280     // No E move either? Game over.
// 14281     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 14282     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 14283     if (UNEAR_ZERO(cartesian_mm)) return;
// 14284 
// 14285     // The length divided by the segment size
// 14286     // At least one segment is required
// 14287     uint16_t segments = cartesian_mm / segment_size;
// 14288     NOLESS(segments, 1);
// 14289 
// 14290     // The approximate length of each segment
// 14291     const float inv_segments = 1.0 / float(segments),
// 14292                 segment_distance[XYZE] = {
// 14293                   xdiff * inv_segments,
// 14294                   ydiff * inv_segments,
// 14295                   zdiff * inv_segments,
// 14296                   ediff * inv_segments
// 14297                 };
// 14298 
// 14299     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 14300     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 14301 
// 14302     // Get the raw current position as starting point
// 14303     float raw[XYZE];
// 14304     COPY(raw, current_position);
// 14305 
// 14306     // Calculate and execute the segments
// 14307     while (--segments) {
// 14308       static millis_t next_idle_ms = millis() + 200UL;
// 14309       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 14310       if (ELAPSED(millis(), next_idle_ms)) {
// 14311         next_idle_ms = millis() + 200UL;
// 14312         idle();
// 14313       }
// 14314       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 14315       planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
// 14316     }
// 14317 
// 14318     // Since segment_distance is only approximate,
// 14319     // the final move must be to the exact destination.
// 14320     planner.buffer_line_kinematic(destination, fr_mm_s, active_extruder);
// 14321   }
// 14322 #endif
// 14323 //#elif ENABLED(MESH_BED_LEVELING)
// 14324 #if 1
// 14325   /**
// 14326    * Prepare a mesh-leveled linear move in a Cartesian setup,
// 14327    * splitting the move where it crosses mesh borders.
// 14328    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock76 Using cfiCommon0
          CFI Function _Z24mesh_line_to_destinationfhh
        THUMB
// 14329   void mesh_line_to_destination(const float fr_mm_s, uint8_t x_splits=0xFF, uint8_t y_splits=0xFF) {
_Z24mesh_line_to_destinationfhh:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R4,R0
// 14330     // Get current and destination cells for this line
// 14331     int cx1 = mbl.cell_index_x(current_position[X_AXIS]),
        LDR.W    R7,??DataTable158
        SUB      SP,SP,#+16
          CFI CFA R13+48
        MOV      R5,R1
        MOV      R6,R2
        ADD      R0,R7,#+16
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R9,R0
// 14332         cy1 = mbl.cell_index_y(current_position[Y_AXIS]),
        ADD      R0,R7,#+20
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
        MOV      R8,R0
// 14333         cx2 = mbl.cell_index_x(destination[X_AXIS]),
        ADD      R0,R7,#+32
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_xERKf
        BL       _ZN17mesh_bed_leveling12cell_index_xERKf
        MOV      R10,R0
// 14334         cy2 = mbl.cell_index_y(destination[Y_AXIS]);
        ADD      R0,R7,#+36
          CFI FunCall _ZN17mesh_bed_leveling12cell_index_yERKf
        BL       _ZN17mesh_bed_leveling12cell_index_yERKf
// 14335     NOMORE(cx1, GRID_MAX_POINTS_X - 2);
        LDR.W    R1,??DataTable158_1
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R9
        IT       LT 
        MOVLT    R9,R2
        ADDS     R1,R1,#+96
        LDRB     R1,[R1, #+1]
        SUBS     R1,R1,#+2
        CMP      R1,R8
        IT       LT 
// 14336     NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
        MOVLT    R8,R1
// 14337     NOMORE(cx2, GRID_MAX_POINTS_X - 2);
        CMP      R2,R10
        IT       LT 
        MOVLT    R10,R2
// 14338     NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
        CMP      R1,R0
        IT       LT 
        MOVLT    R0,R1
// 14339 
// 14340     // Start and end in the same cell? No split needed.
// 14341     if (cx1 == cx2 && cy1 == cy2) {
        CMP      R9,R10
        IT       EQ 
        CMPEQ    R8,R0
        BEQ.W    ??mesh_line_to_destination_0
// 14342       buffer_line_to_destination(fr_mm_s);
// 14343       set_current_from_destination();
// 14344       return;
// 14345     }
// 14346 
// 14347     #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 14348 
// 14349     float normalized_dist, end[XYZE];
// 14350     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
        MOV      R2,R10
        CMP      R10,R9
        IT       LT 
        MOVLT    R2,R9
        MOV      R3,R0
        CMP      R0,R8
        IT       LT 
        MOVLT    R3,R8
// 14351 
// 14352     // Crosses on the X and not already split on this X?
// 14353     // The x_splits flags are insurance against rounding errors.
// 14354     if (cx2 != cx1 && TEST(x_splits, gcx)) {
        CMP      R10,R9
        ITTT     NE 
        MOVNE    R1,#+1
        LSLNE    R1,R1,R2
        TSTNE    R5,R1
        BEQ.N    ??mesh_line_to_destination_1
// 14355       // Split on the X grid line
// 14356       CBI(x_splits, gcx);
// 14357       COPY(end, destination);
        ADD      R0,R7,#+32
        LDM      R0!,{R3,R8,R12,LR}
        BICS     R5,R5,R1
        ADD      R1,SP,#+0
// 14358       destination[X_AXIS] = mbl.index_to_xpos[gcx];
        LDR.W    R0,??DataTable159
        STM      R1!,{R3,R8,R12,LR}
        SXTB     R2,R2
        LDR      R0,[R0, R2, LSL #+2]
// 14359       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        LDR      R8,[R7, #+16]
        STR      R0,[R7, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 14360       destination[Y_AXIS] = MBL_SEGMENT_END(Y);
        LDR      R9,[R7, #+20]
        LDR      R0,[R7, #+36]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+36]
// 14361     }
// 14362     // Crosses on the Y and not already split on this Y?
// 14363     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 14364       // Split on the Y grid line
// 14365       CBI(y_splits, gcy);
// 14366       COPY(end, destination);
// 14367       destination[Y_AXIS] = mbl.index_to_ypos[gcy];
// 14368       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 14369       destination[X_AXIS] = MBL_SEGMENT_END(X);
// 14370     }
// 14371     else {
// 14372       // Must already have been split on these border(s)
// 14373       buffer_line_to_destination(fr_mm_s);
// 14374       set_current_from_destination();
// 14375       return;
// 14376     }
// 14377 
// 14378     destination[Z_AXIS] = MBL_SEGMENT_END(Z);
??mesh_line_to_destination_2:
        LDR      R9,[R7, #+24]
        LDR      R0,[R7, #+40]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+40]
// 14379     destination[E_AXIS] = MBL_SEGMENT_END(E);
        LDR      R9,[R7, #+28]
        LDR      R0,[R7, #+44]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+44]
// 14380 
// 14381     // Do the split and look for more borders
// 14382     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 14383 
// 14384     // Restore destination from stack
// 14385     COPY(destination, end);
        ADD      R0,SP,#+0
        ADD      R1,R7,#+32
        LDM      R0!,{R2,R3,R7,R12}
        STM      R1!,{R2,R3,R7,R12}
// 14386     mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
// 14387   }
        B.N      ?Subroutine2
??mesh_line_to_destination_1:
        CMP      R0,R8
        ITTT     NE 
        MOVNE    R1,#+1
        LSLNE    R0,R1,R3
        TSTNE    R6,R0
        BEQ.N    ??mesh_line_to_destination_0
        BICS     R6,R6,R0
        ADD      R0,R7,#+32
        LDM      R0!,{R2,R8,R12,LR}
        ADD      R1,SP,#+0
        LDR.W    R0,??DataTable159_1
        STM      R1!,{R2,R8,R12,LR}
        SXTB     R3,R3
        LDR      R0,[R0, R3, LSL #+2]
        LDR      R8,[R7, #+20]
        STR      R0,[R7, #+36]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R9,[R7, #+16]
        LDR      R0,[R7, #+32]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+32]
        B.N      ??mesh_line_to_destination_2
??mesh_line_to_destination_0:
        MOV      R0,R4
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
        ADD      R0,R7,#+32
        LDM      R0!,{R2-R5}
        ADD      R1,R7,#+16
        STM      R1!,{R2-R5}
          CFI EndBlock cfiBlock76
        REQUIRE ?Subroutine2
        ;; // Fall through to label ?Subroutine2

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock77 Using cfiCommon0
          CFI NoFunction
          CFI NoCalls _Z14do_homing_move8AxisEnumff
          CFI NoCalls _Z24mesh_line_to_destinationfhh
          CFI CFA R13+48
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
        THUMB
?Subroutine2:
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock77
// 14388 #endif
// 14389 //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 14390 #if 1
// 14391   #define CELL_INDEX(A,V) ((V - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
// 14392 
// 14393   /**
// 14394    * Prepare a bilinear-leveled linear move on Cartesian,
// 14395    * splitting the move where it crosses grid borders.
// 14396    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock78 Using cfiCommon0
          CFI Function _Z28bilinear_line_to_destinationftt
        THUMB
// 14397   void bilinear_line_to_destination(const float fr_mm_s, uint16_t x_splits=0xFFFF, uint16_t y_splits=0xFFFF) {
_Z28bilinear_line_to_destinationftt:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
// 14398     // Get current and destination cells for this line
// 14399     int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
        LDR.W    R8,??DataTable160
        MOV      R4,R0
        LDR      R0,[R8, #+16]
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOV      R5,R1
        MOV      R6,R2
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R7,??DataTable158
        MOV      R11,R0
        LDR      R0,[R7, #+16]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R9,R0
        LDR      R0,[R8, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R10,R0
// 14400         cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
// 14401         cx2 = CELL_INDEX(X, destination[X_AXIS]),
        LDR      R0,[R7, #+32]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+24]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R11,R0
// 14402         cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
        LDR      R0,[R8, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R7, #+36]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R8, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
// 14403     cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
        LDR.W    R1,??DataTable158_1
        CMP      R9,#+0
        IT       MI 
        MOVMI    R9,#+0
        BMI.N    ??bilinear_line_to_destination_0
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R9
        IT       LT 
        MOVLT    R9,R2
// 14404     cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_0:
        CMP      R10,#+0
        IT       MI 
        MOVMI    R10,#+0
        BMI.N    ??bilinear_line_to_destination_1
        ADD      R2,R1,#+96
        LDRB     R2,[R2, #+1]
        SUBS     R2,R2,#+2
        CMP      R2,R10
        IT       LT 
        MOVLT    R10,R2
// 14405     cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
??bilinear_line_to_destination_1:
        CMP      R11,#+0
        IT       MI 
        MOVMI    R11,#+0
        BMI.N    ??bilinear_line_to_destination_2
        LDRB     R2,[R1, #+96]
        SUBS     R2,R2,#+2
        CMP      R2,R11
        IT       LT 
        MOVLT    R11,R2
// 14406     cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
??bilinear_line_to_destination_2:
        CMP      R0,#+0
        IT       MI 
        MOVMI    R0,#+0
        BMI.N    ??bilinear_line_to_destination_3
        ADD      R2,R1,#+96
        LDRB     R1,[R2, #+1]
        SUBS     R2,R1,#+2
        CMP      R2,R0
        IT       LT 
        MOVLT    R0,R2
// 14407 
// 14408     // Start and end in the same cell? No split needed.
// 14409     if (cx1 == cx2 && cy1 == cy2) {
??bilinear_line_to_destination_3:
        CMP      R9,R11
        IT       EQ 
        CMPEQ    R10,R0
        BEQ.W    ??bilinear_line_to_destination_4
// 14410       buffer_line_to_destination(fr_mm_s);
// 14411       set_current_from_destination();
// 14412       return;
// 14413     }
// 14414 
// 14415     #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
// 14416 
// 14417     float normalized_dist, end[XYZE];
// 14418     const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
        MOV      R3,R11
        CMP      R11,R9
        IT       LT 
        MOVLT    R3,R9
        MOV      R2,R0
        CMP      R0,R10
        IT       LT 
        MOVLT    R2,R10
// 14419 
// 14420     // Crosses on the X and not already split on this X?
// 14421     // The x_splits flags are insurance against rounding errors.
// 14422     if (cx2 != cx1 && TEST(x_splits, gcx)) {
        CMP      R11,R9
        ITTT     NE 
        MOVNE    R1,#+1
        LSLNE    R1,R1,R3
        TSTNE    R5,R1
        BEQ.N    ??bilinear_line_to_destination_5
// 14423       // Split on the X grid line
// 14424       CBI(x_splits, gcx);
// 14425       COPY(end, destination);
        ADD      R0,R7,#+32
        LDM      R0!,{R2,R9,R12,LR}
        BICS     R5,R5,R1
        ADD      R1,SP,#+0
// 14426       destination[X_AXIS] = bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx;
        SXTB     R3,R3
        STM      R1!,{R2,R9,R12,LR}
        LDR      R0,[R8, #+16]
        LDR      R1,[R8, #+8]
        MLA      R0,R3,R1,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
// 14427       normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
        LDR      R8,[R7, #+16]
        STR      R0,[R7, #+32]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
// 14428       destination[Y_AXIS] = LINE_SEGMENT_END(Y);
        LDR      R9,[R7, #+20]
        LDR      R0,[R7, #+36]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+36]
// 14429     }
// 14430     // Crosses on the Y and not already split on this Y?
// 14431     else if (cy2 != cy1 && TEST(y_splits, gcy)) {
// 14432       // Split on the Y grid line
// 14433       CBI(y_splits, gcy);
// 14434       COPY(end, destination);
// 14435       destination[Y_AXIS] = bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy;
// 14436       normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
// 14437       destination[X_AXIS] = LINE_SEGMENT_END(X);
// 14438     }
// 14439     else {
// 14440       // Must already have been split on these border(s)
// 14441       buffer_line_to_destination(fr_mm_s);
// 14442       set_current_from_destination();
// 14443       return;
// 14444     }
// 14445 
// 14446     destination[Z_AXIS] = LINE_SEGMENT_END(Z);
??bilinear_line_to_destination_6:
        LDR      R9,[R7, #+24]
        LDR      R0,[R7, #+40]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+40]
// 14447     destination[E_AXIS] = LINE_SEGMENT_END(E);
        LDR      R9,[R7, #+28]
        LDR      R0,[R7, #+44]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+44]
// 14448 
// 14449     // Do the split and look for more borders
// 14450     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 14451 
// 14452     // Restore destination from stack
// 14453     COPY(destination, end);
        ADD      R0,SP,#+0
        ADD      R1,R7,#+32
        LDM      R0!,{R2,R3,R7,R12}
        STM      R1!,{R2,R3,R7,R12}
// 14454     bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
        MOV      R2,R6
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
// 14455   }
        B.W      ?Subroutine5
??bilinear_line_to_destination_5:
        CMP      R0,R10
        ITTT     NE 
        MOVNE    R1,#+1
        LSLNE    R0,R1,R2
        TSTNE    R6,R0
        BEQ.N    ??bilinear_line_to_destination_4
        BICS     R6,R6,R0
        ADD      R0,R7,#+32
        LDM      R0!,{R3,R9,R12,LR}
        ADD      R1,SP,#+0
        SXTB     R2,R2
        STM      R1!,{R3,R9,R12,LR}
        LDR      R0,[R8, #+20]
        LDR      R1,[R8, #+12]
        MLA      R0,R2,R1,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R8,[R7, #+20]
        STR      R0,[R7, #+36]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        LDR      R9,[R7, #+16]
        LDR      R0,[R7, #+32]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+32]
        B.N      ??bilinear_line_to_destination_6
??bilinear_line_to_destination_4:
        MOV      R0,R4
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
        ADD      R0,R7,#+32
        LDM      R0!,{R2-R5}
        ADD      R1,R7,#+16
        STM      R1!,{R2-R5}
        B.W      ?Subroutine5
          CFI EndBlock cfiBlock78

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152:
        DC32     z_values

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_1:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_2:
        DC32     0x43520000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_3:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_4:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_5:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable152_6:
        DC32     0x43a50000
// 14456 
// 14457 #endif // AUTO_BED_LEVELING_BILINEAR
// 14458 #endif // IS_CARTESIAN
// 14459 
// 14460 #if 1//!UBL_SEGMENTED
// 14461 #if 1//IS_KINEMATIC
// 14462 
// 14463   /**
// 14464    * Prepare a linear move in a DELTA or SCARA setup.
// 14465    *
// 14466    * This calls planner.buffer_line several times, adding
// 14467    * small incremental moves for DELTA or SCARA.
// 14468    *
// 14469    * For Unified Bed Leveling (Delta or Segmented Cartesian)
// 14470    * the ubl.prepare_segmented_line_to method replaces this.
// 14471    */
// 14472   inline bool prepare_kinematic_move_to(const float (&rtarget)[XYZE]) {
// 14473 
// 14474     // Get the top feedrate of the move in the XY plane
// 14475     const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
// 14476 
// 14477     const float xdiff = rtarget[X_AXIS] - current_position[X_AXIS],
// 14478                 ydiff = rtarget[Y_AXIS] - current_position[Y_AXIS];
// 14479 
// 14480     // If the move is only in Z/E don't split up the move
// 14481     if (!xdiff && !ydiff) {
// 14482       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 14483       return false; // caller will update current_position
// 14484     }
// 14485 
// 14486     // Fail if attempting move outside printable radius
// 14487     if(MACHINETPYE & IS_KINEMATIC)
// 14488     {
// 14489         if (!position_is_reachable_IS_KINEMATIC(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 14490     }
// 14491     else
// 14492     {
// 14493         if (!position_is_reachable_IS_CARTESIAN(rtarget[X_AXIS], rtarget[Y_AXIS])) return true;
// 14494     }
// 14495     // Remaining cartesian distances
// 14496     const float zdiff = rtarget[Z_AXIS] - current_position[Z_AXIS],
// 14497                 ediff = rtarget[E_AXIS] - current_position[E_AXIS];
// 14498 
// 14499     // Get the linear distance in XYZ
// 14500     // If the move is very short, check the E move distance
// 14501     // No E move either? Game over.
// 14502     float cartesian_mm = SQRT(sq(xdiff) + sq(ydiff) + sq(zdiff));
// 14503     if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(ediff);
// 14504     if (UNEAR_ZERO(cartesian_mm)) return true;
// 14505 
// 14506     // Minimum number of seconds to move the given distance
// 14507     const float seconds = cartesian_mm / _feedrate_mm_s;
// 14508 
// 14509     // The number of segments-per-second times the duration
// 14510     // gives the number of segments
// 14511     uint16_t segments = delta_segments_per_second * seconds;
// 14512 
// 14513     // For SCARA minimum segment size is 0.25mm
// 14514     //#if IS_SCARA
// 14515 	if(MACHINETPYE&IS_SCARA)
// 14516       NOMORE(segments, cartesian_mm * 4);
// 14517     //#endif
// 14518 
// 14519     // At least one segment is required
// 14520     NOLESS(segments, 1);
// 14521 
// 14522     // The approximate length of each segment
// 14523     const float inv_segments = 1.0 / float(segments),
// 14524                 segment_distance[XYZE] = {
// 14525                   xdiff * inv_segments,
// 14526                   ydiff * inv_segments,
// 14527                   zdiff * inv_segments,
// 14528                   ediff * inv_segments
// 14529                 };
// 14530 
// 14531     // SERIAL_ECHOPAIR("mm=", cartesian_mm);
// 14532     // SERIAL_ECHOPAIR(" seconds=", seconds);
// 14533     // SERIAL_ECHOLNPAIR(" segments=", segments);
// 14534 
// 14535     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14536       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14537       // i.e., Complete the angular vector in the given time.
// 14538       const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
// 14539                   inverse_secs = inv_segment_length * _feedrate_mm_s;
// 14540       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14541             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14542     #endif
// 14543 
// 14544     // Get the current position as starting point
// 14545     float raw[XYZE];
// 14546     COPY(raw, current_position);
// 14547 
// 14548 
// 14549     // Calculate and execute the segments
// 14550     while (--segments) {
// 14551 
// 14552       static millis_t next_idle_ms = millis() + 200UL;
// 14553       thermalManager.manage_heater();  // This returns immediately if not really needed.
// 14554       if (ELAPSED(millis(), next_idle_ms)) {
// 14555         next_idle_ms = millis() + 200UL;
// 14556         idle();
// 14557       }
// 14558 
// 14559       LOOP_XYZE(i) raw[i] += segment_distance[i];
// 14560       //#if ENABLED(DELTA)
// 14561       if(MACHINETPYE&DELTA)
// 14562         DELTA_IK(raw); // Delta can inline its kinematics
// 14563       //#else
// 14564       else
// 14565         inverse_kinematics(raw);
// 14566       //#endif
// 14567 
// 14568       ADJUST_DELTA(raw); // Adjust Z if bed leveling is enabled
// 14569 
// 14570       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14571         // For SCARA scale the feed rate from mm/s to degrees/s
// 14572         // i.e., Complete the angular vector in the given time.
// 14573         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14574         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14575       #else
// 14576           if (gCfgItems.breakpoint_reprint_flg == 1) 
// 14577           {
// 14578               if (rtarget[Z_AXIS] < gCfgItems.breakpoint_z_pos) 
// 14579               {
// 14580                   //current_position[Z_AXIS] = rtarget[Z_AXIS];
// 14581                   //current_position[E_AXIS] = destination[E_AXIS];
// 14582 
// 14583                   gCfgItems.had_breakpoint=1;
// 14584                   gCfgItems.breakpoint_e_position=LROUND(raw[E_AXIS] * planner.axis_steps_per_mm[E_AXIS]);
// 14585                                     
// 14586                   return false;
// 14587               }
// 14588           }
// 14589         //gCfgItems.breakpoint_reprint_flg = 0;
// 14590         planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], raw[E_AXIS], _feedrate_mm_s, active_extruder);
// 14591       #endif
// 14592     }
// 14593 
// 14594     // Ensure last segment arrives at target location.
// 14595     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14596       inverse_kinematics(rtarget);
// 14597       ADJUST_DELTA(rtarget);
// 14598       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], rtarget[Z_AXIS], rtarget[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14599     #else
// 14600       planner.buffer_line_kinematic(rtarget, _feedrate_mm_s, active_extruder);
// 14601     #endif
// 14602 
// 14603     return false; // caller will update current_position
// 14604   }
// 14605 #endif
// 14606 //#else // !IS_KINEMATIC
// 14607 #if 1
// 14608   /**
// 14609    * Prepare a linear move in a Cartesian setup.
// 14610    *
// 14611    * When a mesh-based leveling system is active, moves are segmented
// 14612    * according to the configuration of the leveling system.
// 14613    *
// 14614    * Returns true if current_position[] was set to destination[]
// 14615    */
// 14616   inline bool prepare_move_to_destination_cartesian() {
// 14617     #if 1//HAS_MESH
// 14618       if (planner.leveling_active && planner.leveling_active_at_z(destination[Z_AXIS])) {
// 14619         //#if ENABLED(AUTO_BED_LEVELING_UBL)
// 14620         if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_UBL)
// 14621         {
// 14622           ubl.line_to_destination_cartesian(MMS_SCALED(feedrate_mm_s), active_extruder);  // UBL's motion routine needs to know about
// 14623           return true;     
// 14624 		 }// all moves, including Z-only moves.
// 14625         //#elif ENABLED(SEGMENT_LEVELED_MOVES)
// 14626 		//{
// 14627         //  segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14628         //  return false; // caller will update current_position
// 14629 		//}
// 14630         //#else
// 14631         else
// 14632         {
// 14633           #if ENABLED(SEGMENT_LEVELED_MOVES)
// 14634             segmented_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14635             return false; // caller will update current_position
// 14636           #else
// 14637           /**
// 14638            * For MBL and ABL-BILINEAR only segment moves when X or Y are involved.
// 14639            * Otherwise fall through to do a direct single move.
// 14640            */
// 14641           if (current_position[X_AXIS] != destination[X_AXIS] || current_position[Y_AXIS] != destination[Y_AXIS]) {
// 14642             //#if ENABLED(MESH_BED_LEVELING)
// 14643             if(BED_LEVELING_METHOD == MESH_BED_LEVELING)
// 14644               mesh_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14645             //#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
// 14646             else if(BED_LEVELING_METHOD == AUTO_BED_LEVELING_BILINEAR)
// 14647               bilinear_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14648             //#endif
// 14649             return true;
// 14650           }
// 14651           #endif
// 14652         }
// 14653         //#endif
// 14654       }
// 14655     #endif // HAS_MESH
// 14656 
// 14657     buffer_line_to_destination(MMS_SCALED(feedrate_mm_s));
// 14658     return false; // caller will update current_position
// 14659   }
// 14660 
// 14661 #endif // !IS_KINEMATIC
// 14662 #endif // !UBL_SEGMENTED
// 14663 
// 14664 #if ENABLED(DUAL_X_CARRIAGE)
// 14665 
// 14666   /**
// 14667    * Unpark the carriage, if needed
// 14668    */
// 14669   inline bool dual_x_carriage_unpark() {
// 14670     if (active_extruder_parked)
// 14671       switch (dual_x_carriage_mode) {
// 14672 
// 14673         case DXC_FULL_CONTROL_MODE: break;
// 14674 
// 14675         case DXC_AUTO_PARK_MODE:
// 14676           if (current_position[E_AXIS] == destination[E_AXIS]) {
// 14677             // This is a travel move (with no extrusion)
// 14678             // Skip it, but keep track of the current position
// 14679             // (so it can be used as the start of the next non-travel move)
// 14680             if (delayed_move_time != 0xFFFFFFFFUL) {
// 14681               set_current_from_destination();
// 14682               NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
// 14683               delayed_move_time = millis();
// 14684               return true;
// 14685             }
// 14686           }
// 14687           // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
// 14688           for (uint8_t i = 0; i < 3; i++)
// 14689             planner.buffer_line(
// 14690               i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
// 14691               i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
// 14692               i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
// 14693               current_position[E_AXIS],
// 14694               i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
// 14695               active_extruder
// 14696             );
// 14697           delayed_move_time = 0;
// 14698           active_extruder_parked = false;
// 14699           #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14700             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
// 14701           #endif
// 14702           break;
// 14703 
// 14704         case DXC_DUPLICATION_MODE:
// 14705           if (active_extruder == 0) {
// 14706             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14707               if (DEBUGGING(LEVELING)) {
// 14708                 SERIAL_ECHOPAIR("Set planner X", inactive_extruder_x_pos);
// 14709                 SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
// 14710               }
// 14711             #endif
// 14712             // move duplicate extruder into correct duplication position.
// 14713             planner.set_position_mm(
// 14714               inactive_extruder_x_pos,
// 14715               current_position[Y_AXIS],
// 14716               current_position[Z_AXIS],
// 14717               current_position[E_AXIS]
// 14718             );
// 14719             planner.buffer_line(
// 14720               current_position[X_AXIS] + duplicate_extruder_x_offset,
// 14721               current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
// 14722               planner.max_feedrate_mm_s[X_AXIS], 1
// 14723             );
// 14724             SYNC_PLAN_POSITION_KINEMATIC();
// 14725             stepper.synchronize();
// 14726             extruder_duplication_enabled = true;
// 14727             active_extruder_parked = false;
// 14728             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14729               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
// 14730             #endif
// 14731           }
// 14732           else {
// 14733             #if ENABLED(DEBUG_LEVELING_FEATURE)
// 14734               if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
// 14735             #endif
// 14736           }
// 14737           break;
// 14738       }
// 14739     return false;
// 14740   }
// 14741 
// 14742 #endif // DUAL_X_CARRIAGE
// 14743 
// 14744 /**
// 14745  * Prepare a single move and get ready for the next one
// 14746  *
// 14747  * This may result in several calls to planner.buffer_line to
// 14748  * do smaller moves for DELTA, SCARA, mesh moves, etc.
// 14749  *
// 14750  * Make sure current_position[E] and destination[E] are good
// 14751  * before calling or cold/lengthy extrusion may get missed.
// 14752  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock79 Using cfiCommon0
          CFI Function _Z27prepare_move_to_destinationv
        THUMB
// 14753 void prepare_move_to_destination() {
_Z27prepare_move_to_destinationv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
// 14754   clamp_to_software_endstops(destination);
        LDR.W    R4,??DataTable158
        SUB      SP,SP,#+12
          CFI CFA R13+24
        ADD      R0,R4,#+32
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14755   refresh_cmd_timeout();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R4, #+120]
// 14756 
// 14757   #if ENABLED(PREVENT_COLD_EXTRUSION) || ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 14758 
// 14759     if (!DEBUGGING(DRYRUN)) {
        LDRB     R0,[R4, #+5]
        LSLS     R0,R0,#+28
        BMI.N    ??prepare_move_to_destination_0
// 14760       if (destination[E_AXIS] != current_position[E_AXIS]) {
        LDR      R5,[R4, #+44]
        LDR      R1,[R4, #+28]
        MOV      R0,R5
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_0
// 14761         #if ENABLED(PREVENT_COLD_EXTRUSION)
// 14762           if (thermalManager.tooColdToExtrude(active_extruder)) {
        LDR.W    R0,??DataTable165
        LDRB     R0,[R0, #+0]
        CBNZ.N   R0,??prepare_move_to_destination_1
        LDR.W    R0,??DataTable166
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R2,??DataTable166_1
        MOV      R1,R0
        LDRB     R0,[R4, #+10]
        LDR      R0,[R2, R0, LSL #+2]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_move_to_destination_1
// 14763             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        STR      R5,[R4, #+28]
// 14764             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable166_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14765             SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
        LDR.W    R0,??DataTable166_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14766           }
// 14767         #endif // PREVENT_COLD_EXTRUSION
// 14768         #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
// 14769           if (FABS(destination[E_AXIS] - current_position[E_AXIS]) * planner.e_factor[active_extruder] > (EXTRUDE_MAXLENGTH)) {
??prepare_move_to_destination_1:
        LDR      R0,[R4, #+44]
        LDR      R1,[R4, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R2,??DataTable167
        BIC      R1,R0,#0x80000000
        LDRB     R0,[R4, #+10]
        LDR      R0,[R2, R0, LSL #+2]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.W    R1,??DataTable167_1  ;; 0x447a0001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??prepare_move_to_destination_0
// 14770             current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
        LDR      R0,[R4, #+44]
        STR      R0,[R4, #+28]
// 14771             SERIAL_ECHO_START();
        LDR.W    R0,??DataTable166_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14772             SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
        LDR.W    R0,??DataTable167_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 14773           }
// 14774         #endif // PREVENT_LENGTHY_EXTRUDE
// 14775       }
// 14776     }
// 14777 
// 14778   #endif
// 14779 
// 14780   #if ENABLED(DUAL_X_CARRIAGE)
// 14781     if (dual_x_carriage_unpark()) return;
// 14782   #endif
// 14783   
// 14784 #if 0
// 14785   if (
// 14786     #if UBL_SEGMENTED
// 14787       ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s))
// 14788     #elif IS_KINEMATIC
// 14789       prepare_kinematic_move_to(destination)
// 14790     #else
// 14791       prepare_move_to_destination_cartesian()
// 14792     #endif
// 14793   ) return;
// 14794 #endif
// 14795 
// 14796   if((BED_LEVELING_METHOD &AUTO_BED_LEVELING_UBL) && (MACHINETPYE == DELTA /*|| ENABLED(SEGMENT_LEVELED_MOVES)*/))
??prepare_move_to_destination_0:
        LDR.W    R0,??DataTable158_1
        LDRB     R2,[R0, #+66]
        ADD      R1,R0,#+66
        LSLS     R0,R2,#+27
        LDRSH    R1,[R1, #+22]
        BPL.N    ??prepare_move_to_destination_2
        CMP      R1,#+2
        BNE.N    ??prepare_move_to_destination_2
// 14797   {
// 14798     if(ubl.prepare_segmented_line_to(destination, MMS_SCALED(feedrate_mm_s)))return;
        LDRSH    R0,[R4, #+14]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable170  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+0
        ADD      R0,R4,#+32
          CFI FunCall _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        BL       _ZN20unified_bed_leveling25prepare_segmented_line_toERA4_KfRS0_
        B.N      ??prepare_move_to_destination_3
// 14799   } 
// 14800   else if(MACHINETPYE & IS_KINEMATIC)
??prepare_move_to_destination_2:
        MOVW     R0,#+770
        TST      R1,R0
        BEQ.N    ??prepare_move_to_destination_4
// 14801   {
// 14802     if(prepare_kinematic_move_to(destination))return;
        ADD      R0,R4,#+32
          CFI FunCall _Z25prepare_kinematic_move_toRA4_Kf
        BL       _Z25prepare_kinematic_move_toRA4_Kf
??prepare_move_to_destination_3:
        CMP      R0,#+0
        BEQ.W    ??prepare_move_to_destination_5
// 14803   }  
// 14804   else//if(MACHINETPYE & IS_CARTESIAN)
// 14805   {
// 14806     if(prepare_move_to_destination_cartesian())return;
// 14807   }
// 14808 
// 14809   set_current_from_destination();
// 14810 }
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}
          CFI CFA R13+24
??prepare_move_to_destination_4:
        LDR.W    R0,??DataTable167_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??prepare_move_to_destination_6
        LDR.W    R0,??DataTable167_5
        LDR      R3,[R0, #+0]
        MOV      R0,R3
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_7
        LDR      R0,[R4, #+40]
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_move_to_destination_6
??prepare_move_to_destination_7:
        CMP      R2,#+16
        BNE.N    ??prepare_move_to_destination_8
        LDRSH    R0,[R4, #+14]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable170  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDRB     R1,[R4, #+10]
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        BL       _ZN20unified_bed_leveling29line_to_destination_cartesianERKfh
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}
          CFI CFA R13+24
??prepare_move_to_destination_8:
        LDR      R0,[R4, #+16]
        LDR      R1,[R4, #+32]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_move_to_destination_9
        LDR      R0,[R4, #+20]
        LDR      R1,[R4, #+36]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??prepare_move_to_destination_6
??prepare_move_to_destination_9:
        CMP      R2,#+32
        BNE.N    ??prepare_move_to_destination_10
        LDRSH    R0,[R4, #+14]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable170  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOVS     R2,#+255
        MOVS     R1,#+255
          CFI FunCall _Z24mesh_line_to_destinationfhh
        BL       _Z24mesh_line_to_destinationfhh
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}
          CFI CFA R13+24
??prepare_move_to_destination_10:
        CMP      R2,#+8
        BNE.N    ??prepare_move_to_destination_11
        LDRSH    R0,[R4, #+14]
        MOVW     R5,#+65535
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable170  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R2,R5
        MOV      R1,R5
          CFI FunCall _Z28bilinear_line_to_destinationftt
        BL       _Z28bilinear_line_to_destinationftt
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}
          CFI CFA R13+24
??prepare_move_to_destination_6:
        LDRSH    R0,[R4, #+14]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R4, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable170  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
          CFI FunCall _Z26buffer_line_to_destinationf
        BL       _Z26buffer_line_to_destinationf
??prepare_move_to_destination_5:
        ADD      R0,R4,#+32
        ADD      R1,R4,#+16
        LDM      R0!,{R2-R5}
        STM      R1!,{R2-R5}
??prepare_move_to_destination_11:
        ADD      SP,SP,#+12
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock79

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable153:
        DC32     axis_homed
// 14811 
// 14812 #if ENABLED(ARC_SUPPORT)
// 14813 
// 14814   #if N_ARC_CORRECTION < 1
// 14815     #undef N_ARC_CORRECTION
// 14816     #define N_ARC_CORRECTION 1
// 14817   #endif
// 14818 
// 14819   /**
// 14820    * Plan an arc in 2 dimensions
// 14821    *
// 14822    * The arc is approximated by generating many small linear segments.
// 14823    * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
// 14824    * Arcs should only be made relatively large (over 5mm), as larger arcs with
// 14825    * larger segments will tend to be more efficient. Your slicer should have
// 14826    * options for G2/G3 arc generation. In future these options may be GCode tunable.
// 14827    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock80 Using cfiCommon0
          CFI Function _Z8plan_arcRA4_KfRA2_S_b
        THUMB
// 14828   void plan_arc(
// 14829     const float (&cart)[XYZE], // Destination position
// 14830     const float (&offset)[2], // Center of rotation relative to current_position
// 14831     const bool clockwise      // Clockwise?
// 14832   ) {
_Z8plan_arcRA4_KfRA2_S_b:
        PUSH     {R0,R1,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+44
        SUB      SP,SP,#+52
          CFI CFA R13+96
// 14833     #if ENABLED(CNC_WORKSPACE_PLANES)
// 14834       AxisEnum p_axis, q_axis, l_axis;
// 14835       switch (workspace_plane) {
// 14836         default:
// 14837         case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
// 14838         case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
// 14839         case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
// 14840       }
// 14841     #else
// 14842       constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
// 14843     #endif
// 14844 
// 14845     // Radius vector from center to current location
// 14846     float r_P = -offset[0], r_Q = -offset[1];
        LDR      R5,[R1, #+0]
        LDR      R6,[R1, #+4]
        EOR      R5,R5,#0x80000000
// 14847 
// 14848     const float radius = HYPOT(r_P, r_Q),
        MOV      R7,#+1065353216
        MOV      R4,R2
        EOR      R6,R6,#0x80000000
        MOV      R9,R5
        MOV      R10,#+2
        MOV      R8,R7
        B.N      ??plan_arc_0
??plan_arc_1:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??plan_arc_0:
        LSLS     R0,R10,#+31
        BPL.N    ??plan_arc_2
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_2:
        LSRS     R10,R10,#+1
        BNE.N    ??plan_arc_1
        MOV      R11,R6
        MOV      R9,#+2
        MOV      R10,R7
        B.N      ??plan_arc_3
??plan_arc_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_3:
        LSLS     R0,R9,#+31
        BPL.N    ??plan_arc_5
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_5:
        LSRS     R9,R9,#+1
        BNE.N    ??plan_arc_4
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R8,R0
        LDR.W    R0,??DataTable158
        LDR      R0,[R0, #+16]
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+24]
// 14849                 center_P = current_position[p_axis] - r_P,
// 14850                 center_Q = current_position[q_axis] - r_Q,
        MOV      R1,R6
        LDR.W    R0,??DataTable158
        LDR      R0,[R0, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
// 14851                 rt_X = cart[p_axis] - center_P,
        LDR      R1,[SP, #+24]
        STR      R0,[SP, #+20]
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
// 14852                 rt_Y = cart[q_axis] - center_Q,
        LDR      R1,[SP, #+20]
        MOV      R9,R0
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
// 14853                 linear_travel = cart[l_axis] - current_position[l_axis],
        LDR.W    R1,??DataTable158
        LDR      R1,[R1, #+24]
        MOV      R10,R0
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+8]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
// 14854                 extruder_travel = cart[E_AXIS] - current_position[E_AXIS];
        LDR.W    R1,??DataTable158
        LDR      R1,[R1, #+28]
        STR      R0,[SP, #+0]
        LDR      R0,[SP, #+52]
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
// 14855 
// 14856     // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
// 14857     float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
        MOV      R1,R9
        MOV      R0,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
        MOV      R0,R6
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R11,R0
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R0,R6
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R11
          CFI FunCall atan2f
        BL       atan2f
// 14858     if (angular_travel < 0) angular_travel += RADIANS(360);
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R9,R0
        BCS.N    ??plan_arc_6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_3  ;; 0x401921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 14859     if (clockwise) angular_travel -= RADIANS(360);
??plan_arc_6:
        CBZ.N    R4,??plan_arc_7
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_4  ;; 0xc01921fb
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R9,R0
// 14860 
// 14861     // Make a circle if the angular rotation is 0 and the target is current position
// 14862     if (angular_travel == 0 && current_position[p_axis] == cart[p_axis] && current_position[q_axis] == cart[q_axis])
??plan_arc_7:
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR      R1,[SP, #+52]
        LDR.W    R0,??DataTable158
        LDR      R1,[R1, #+0]
        LDR      R0,[R0, #+16]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??plan_arc_8
        LDR      R1,[SP, #+52]
        LDR.W    R0,??DataTable158
        LDR      R1,[R1, #+4]
        LDR      R0,[R0, #+20]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        IT       EQ 
// 14863       angular_travel = RADIANS(360);
        LDREQ.W  R9,??DataTable170_5  ;; 0x40c90fdb
// 14864 
// 14865     const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
??plan_arc_8:
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        MOV      R10,#+2
        MOV      R4,R7
        B.N      ??plan_arc_9
??plan_arc_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??plan_arc_9:
        LSLS     R0,R10,#+31
        BPL.N    ??plan_arc_11
        MOV      R0,R4
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??plan_arc_11:
        LSRS     R10,R10,#+1
        BNE.N    ??plan_arc_10
        LDR      R0,[SP, #+0]
        BIC      R11,R0,#0x80000000
        MOV      R8,#+2
        MOV      R10,R7
        B.N      ??plan_arc_12
??plan_arc_13:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??plan_arc_12:
        LSLS     R0,R8,#+31
        BPL.N    ??plan_arc_14
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??plan_arc_14:
        LSRS     R8,R8,#+1
        BNE.N    ??plan_arc_13
        MOV      R0,R4
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
// 14866     if (mm_of_travel < 0.001) return;
        LDR.W    R1,??DataTable170_6  ;; 0x3a83126f
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.W    ??plan_arc_15
// 14867 
// 14868     uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
          CFI FunCall floorf
        BL       floorf
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        UXTH     R0,R0
        STR      R0,[SP, #+4]
// 14869     NOLESS(segments, 1);
        CBNZ.N   R0,??plan_arc_16
        MOVS     R0,#+1
        STR      R0,[SP, #+4]
// 14870 
// 14871     /**
// 14872      * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
// 14873      * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
// 14874      *     r_T = [cos(phi) -sin(phi);
// 14875      *            sin(phi)  cos(phi)] * r ;
// 14876      *
// 14877      * For arc generation, the center of the circle is the axis of rotation and the radius vector is
// 14878      * defined from the circle center to the initial position. Each line segment is formed by successive
// 14879      * vector rotations. This requires only two cos() and sin() computations to form the rotation
// 14880      * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
// 14881      * all double numbers are single precision on the Arduino. (True double precision will not have
// 14882      * round off issues for CNC applications.) Single precision error can accumulate to be greater than
// 14883      * tool precision in some cases. Therefore, arc path correction is implemented.
// 14884      *
// 14885      * Small angle approximation may be used to reduce computation overhead further. This approximation
// 14886      * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
// 14887      * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
// 14888      * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
// 14889      * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
// 14890      * issue for CNC machines with the single precision Arduino calculations.
// 14891      *
// 14892      * This approximation also allows plan_arc to immediately insert a line segment into the planner
// 14893      * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
// 14894      * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
// 14895      * This is important when there are successive arc motions.
// 14896      */
// 14897     // Vector rotation matrix values
// 14898     float raw[XYZE];
// 14899     const float theta_per_segment = angular_travel / segments,
??plan_arc_16:
        ADD      R0,SP,#+4
        LDRH     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R4,R0
        MOV      R0,R9
        MOV      R1,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+12]
// 14900                 linear_per_segment = linear_travel / segments,
        MOV      R1,R4
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[SP, #+32]
// 14901                 extruder_per_segment = extruder_travel / segments,
        MOV      R1,R4
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
// 14902                 sin_T = theta_per_segment,
// 14903                 cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
        LDR      R4,[SP, #+12]
        STR      R0,[SP, #+28]
        MOV      R8,#+2
        B.N      ??plan_arc_17
??plan_arc_18:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??plan_arc_17:
        LSLS     R0,R8,#+31
        BPL.N    ??plan_arc_19
        MOV      R0,R7
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??plan_arc_19:
        LSRS     R8,R8,#+1
        BNE.N    ??plan_arc_18
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable170_7  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.W    R1,??DataTable170_8  ;; 0x3ff00000
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+8]
// 14904 
// 14905     // Initialize the linear axis
// 14906     raw[l_axis] = current_position[l_axis];
        ADD      R4,SP,#+36
        LDR.W    R0,??DataTable158
        LDR      R0,[R0, #+24]
        STR      R0,[R4, #+8]
// 14907 
// 14908     // Initialize the extruder axis
// 14909     raw[E_AXIS] = current_position[E_AXIS];
        LDR.W    R0,??DataTable158
        LDR      R0,[R0, #+28]
        STR      R0,[R4, #+12]
// 14910 
// 14911     const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
        LDR.W    R0,??DataTable158
        LDRSH    R0,[R0, #+14]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R1,??DataTable158
        LDR      R1,[R1, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable167_3  ;; 0x47ae147b
        LDR.W    R3,??DataTable170  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+16]
// 14912 
// 14913     millis_t next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R8,R0,#+200
// 14914 
// 14915     #if N_ARC_CORRECTION > 1
// 14916       int8_t arc_recalc_count = N_ARC_CORRECTION;
// 14917     #endif
// 14918 
// 14919     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14920       // SCARA needs to scale the feed rate from mm/s to degrees/s
// 14921       const float inv_segment_length = 1.0 / (MM_PER_ARC_SEGMENT),
// 14922                   inverse_secs = inv_segment_length * fr_mm_s;
// 14923       float oldA = stepper.get_axis_position_degrees(A_AXIS),
// 14924             oldB = stepper.get_axis_position_degrees(B_AXIS);
// 14925     #endif
// 14926 
// 14927     for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
        LDR      R0,[SP, #+4]
        MOVS     R7,#+1
        MOV      R9,#+25
        CMP      R0,#+2
        BLT.W    ??plan_arc_20
// 14928 
// 14929       thermalManager.manage_heater();
??plan_arc_21:
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
// 14930       if (ELAPSED(millis(), next_idle_ms)) {
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        SUBS     R0,R0,R8
        BMI.N    ??plan_arc_22
// 14931         next_idle_ms = millis() + 200UL;
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADD      R8,R0,#+200
// 14932         idle();
          CFI FunCall _Z4idlev
        BL       _Z4idlev
// 14933       }
// 14934 
// 14935       #if N_ARC_CORRECTION > 1
// 14936         if (--arc_recalc_count) {
??plan_arc_22:
        SUB      R0,R9,#+1
        SXTB     R9,R0
        CMP      R9,#+0
        BEQ.N    ??plan_arc_23
// 14937           // Apply vector rotation matrix to previous r_P / 1
// 14938           const float r_new_Y = r_P * sin_T + r_Q * cos_T;
        LDR      R0,[SP, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        LDR      R0,[SP, #+8]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R10,R0
// 14939           r_P = r_P * cos_T - r_Q * sin_T;
        LDR      R0,[SP, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        LDR      R0,[SP, #+12]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 14940           r_Q = r_new_Y;
        MOV      R6,R10
        B.N      ??plan_arc_24
// 14941         }
// 14942         else
// 14943       #endif
// 14944       {
// 14945         #if N_ARC_CORRECTION > 1
// 14946           arc_recalc_count = N_ARC_CORRECTION;
??plan_arc_23:
        MOV      R9,#+25
// 14947         #endif
// 14948 
// 14949         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
// 14950         // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
// 14951         // To reduce stuttering, the sin and cos could be computed at different times.
// 14952         // For now, compute both at the same time.
// 14953         const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
        UXTH     R0,R7
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        MOVS     R1,#+1
          CFI FunCall __iar_FSin
        BL       __iar_FSin
        MOV      R6,R0
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall __iar_FSin
        BL       __iar_FSin
        MOV      R10,R0
// 14954         r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
        LDR      R0,[SP, #+56]
        LDR      R0,[R0, #+4]
        STR      R0,[SP, #+0]
        MOV      R1,R10
        LDR      R0,[SP, #+56]
        LDR      R11,[R0, #+0]
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
        MOV      R0,R11
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
// 14955         r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        EOR      R10,R0,#0x80000000
        LDR      R0,[SP, #+0]
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 14956       }
// 14957 
// 14958       // Update raw location
// 14959       raw[p_axis] = center_P + r_P;
??plan_arc_24:
        LDR      R0,[SP, #+24]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+36]
// 14960       raw[q_axis] = center_Q + r_Q;
        MOV      R1,R6
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
// 14961       raw[l_axis] += linear_per_segment;
        LDR      R1,[SP, #+32]
        STR      R0,[R4, #+4]
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
// 14962       raw[E_AXIS] += extruder_per_segment;
        LDR      R1,[SP, #+28]
        STR      R0,[R4, #+8]
        LDR      R0,[R4, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, #+12]
// 14963 
// 14964       clamp_to_software_endstops(raw);
        ADD      R0,SP,#+36
          CFI FunCall _Z26clamp_to_software_endstopsPf
        BL       _Z26clamp_to_software_endstopsPf
// 14965 
// 14966       #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14967         // For SCARA scale the feed rate from mm/s to degrees/s
// 14968         // i.e., Complete the angular vector in the given time.
// 14969         inverse_kinematics(raw);
// 14970         ADJUST_DELTA(raw);
// 14971         planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], raw[Z_AXIS], raw[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14972         oldA = delta[A_AXIS]; oldB = delta[B_AXIS];
// 14973       #else
// 14974         planner.buffer_line_kinematic(raw, fr_mm_s, active_extruder);
        LDR.N    R0,??DataTable158
        LDRB     R2,[R0, #+10]
        ADD      R1,SP,#+16
        ADD      R0,SP,#+36
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 14975       #endif
// 14976     }
        LDR      R0,[SP, #+4]
        ADDS     R7,R7,#+1
        CMP      R7,R0
        BLT.W    ??plan_arc_21
// 14977 
// 14978     // Ensure last segment arrives at target location.
// 14979     #if ENABLED(SCARA_FEEDRATE_SCALING)
// 14980       inverse_kinematics(cart);
// 14981       ADJUST_DELTA(cart);
// 14982       planner.buffer_segment(delta[A_AXIS], delta[B_AXIS], cart[Z_AXIS], cart[E_AXIS], HYPOT(delta[A_AXIS] - oldA, delta[B_AXIS] - oldB) * inverse_secs, active_extruder);
// 14983     #else
// 14984       planner.buffer_line_kinematic(cart, fr_mm_s, active_extruder);
??plan_arc_20:
        LDR.N    R0,??DataTable158
        LDRB     R2,[R0, #+10]
        LDR      R0,[SP, #+52]
        ADD      R1,SP,#+16
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
// 14985     #endif
// 14986 
// 14987     // As far as the parser is concerned, the position is now == target. In reality the
// 14988     // motion control system might still be processing the action and the real tool position
// 14989     // in any intermediate location.
// 14990     set_current_from_destination();
        LDR.W    R0,??DataTable170_9
        LDR.W    R1,??DataTable171
        LDM      R0!,{R2-R5}
        STM      R1!,{R2-R5}
// 14991   } // plan_arc
??plan_arc_15:
        ADD      SP,SP,#+60
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI EndBlock cfiBlock80
// 14992 
// 14993 #endif // ARC_SUPPORT
// 14994 
// 14995 #if ENABLED(BEZIER_CURVE_SUPPORT)
// 14996 
// 14997   void plan_cubic_move(const float (&offset)[4]) {
// 14998     cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
// 14999 
// 15000     // As far as the parser is concerned, the position is now == destination. In reality the
// 15001     // motion control system might still be processing the action and the real tool position
// 15002     // in any intermediate location.
// 15003     set_current_from_destination();
// 15004   }
// 15005 
// 15006 #endif // BEZIER_CURVE_SUPPORT
// 15007 
// 15008 #if ENABLED(USE_CONTROLLER_FAN)
// 15009 
// 15010   void controllerFan() {
// 15011     static millis_t lastMotorOn = 0, // Last time a motor was turned on
// 15012                     nextMotorCheck = 0; // Last time the state was checked
// 15013     const millis_t ms = millis();
// 15014     if (ELAPSED(ms, nextMotorCheck)) {
// 15015       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
// 15016       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
// 15017           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
// 15018           #if E_STEPPERS > 1
// 15019             || E1_ENABLE_READ == E_ENABLE_ON
// 15020             #if HAS_X2_ENABLE
// 15021               || X2_ENABLE_READ == X_ENABLE_ON
// 15022             #endif
// 15023             #if E_STEPPERS > 2
// 15024               || E2_ENABLE_READ == E_ENABLE_ON
// 15025               #if E_STEPPERS > 3
// 15026                 || E3_ENABLE_READ == E_ENABLE_ON
// 15027                 #if E_STEPPERS > 4
// 15028                   || E4_ENABLE_READ == E_ENABLE_ON
// 15029                 #endif // E_STEPPERS > 4
// 15030               #endif // E_STEPPERS > 3
// 15031             #endif // E_STEPPERS > 2
// 15032           #endif // E_STEPPERS > 1
// 15033       ) {
// 15034         lastMotorOn = ms; //... set time to NOW so the fan will turn on
// 15035       }
// 15036 
// 15037       // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
// 15038       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
// 15039 
// 15040       // allows digital or PWM fan output to be used (see M42 handling)
// 15041       WRITE(CONTROLLER_FAN_PIN, speed);
// 15042       analogWrite(CONTROLLER_FAN_PIN, speed);
// 15043     }
// 15044   }
// 15045 
// 15046 #endif // USE_CONTROLLER_FAN
// 15047 
// 15048 #if 1//ENABLED(MORGAN_SCARA)
// 15049 
// 15050   /**
// 15051    * Morgan SCARA Forward Kinematics. Results in cartes[].
// 15052    * Maths and first version by QHARLEY.
// 15053    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 15054    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock81 Using cfiCommon0
          CFI Function _Z24forward_kinematics_SCARARKfS0_
        THUMB
// 15055   void forward_kinematics_SCARA(const float &a, const float &b) {
_Z24forward_kinematics_SCARARKfS0_:
        PUSH     {R1,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
        LDR      R0,[R4, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_10  ;; 0x400921fb
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R3,??DataTable170_11  ;; 0x40668000
        MOVS     R2,#+0
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
// 15056 
// 15057     float a_sin = sin(RADIANS(a)) * L1,
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R8,R0
// 15058           a_cos = cos(RADIANS(a)) * L1,
        LDR      R0,[R4, #+0]
        MOV      R9,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_10  ;; 0x400921fb
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R3,??DataTable170_11  ;; 0x40668000
        MOVS     R2,#+0
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+1
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R6,R0
// 15059           b_sin = sin(RADIANS(b)) * L2,
        LDR      R0,[SP, #+0]
        LDR      R0,[R0, #+0]
        MOV      R10,R1
        MOVS     R4,#+0
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_10  ;; 0x400921fb
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R3,??DataTable170_11  ;; 0x40668000
        MOVS     R2,#+0
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R4,R0
        MOV      R5,R1
        MOVS     R7,#+0
        LDR.W    R11,??DataTable170_12  ;; 0x4062c000
        MOV      R2,R7
        MOV      R3,R11
        MOV      R0,R6
        MOV      R1,R10
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R10,R0
        LDR      R0,[SP, #+0]
        LDR      R0,[R0, #+0]
        MOVS     R6,#+1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_10  ;; 0x400921fb
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R3,??DataTable170_11  ;; 0x40668000
        MOV      R2,R7
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R6
          CFI FunCall __iar_Sin
        BL       __iar_Sin
        MOV      R2,R7
        MOV      R3,R11
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable171_1  ;; 0x42c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R1,??DataTable158
        STR      R0,[R1, #+96]
// 15060           b_cos = cos(RADIANS(b)) * L2;
// 15061 
// 15062     cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
// 15063     cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
        MOV      R2,R7
        MOV      R3,R11
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R6,R0
        MOV      R2,R7
        MOV      R3,R11
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable171_2  ;; 0xc2600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R1,??DataTable158
        STR      R0,[R1, #+100]
// 15064 
// 15065     /*
// 15066       SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
// 15067       SERIAL_ECHOPAIR(" b=", b);
// 15068       SERIAL_ECHOPAIR(" a_sin=", a_sin);
// 15069       SERIAL_ECHOPAIR(" a_cos=", a_cos);
// 15070       SERIAL_ECHOPAIR(" b_sin=", b_sin);
// 15071       SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
// 15072       SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
// 15073       SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
// 15074     //
// 15075     */
// 15076   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock81
// 15077 
// 15078   /**
// 15079    * Morgan SCARA Inverse Kinematics. Results in delta[].
// 15080    *
// 15081    * See http://forums.reprap.org/read.php?185,283327
// 15082    *
// 15083    * Maths and first version by QHARLEY.
// 15084    * Integrated into Marlin and slightly restructured by Joachim Cerny.
// 15085    */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock82 Using cfiCommon0
          CFI Function _Z31inverse_kinematics_MORGAN_SCARAPKf
        THUMB
// 15086   void inverse_kinematics_MORGAN_SCARA(const float raw[XYZ]) {
_Z31inverse_kinematics_MORGAN_SCARAPKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R4,R0
// 15087 
// 15088     static float C2, S2, SK1, SK2, THETA, PSI;
// 15089 
// 15090     float sx = raw[X_AXIS] - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
        LDR.W    R0,??DataTable171_3  ;; 0xc2c80000
        LDR      R1,[R4, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
// 15091           sy = raw[Y_AXIS] - SCARA_OFFSET_Y;  // With scaling factor.
        LDR      R1,[R4, #+4]
        MOV      R9,R0
        LDR.W    R0,??DataTable171_4  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
// 15092 
// 15093     if (L1 == L2)
// 15094       C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
        MOV      R8,#+1065353216
        MOV      R10,R0
        MOV      R5,R9
        MOVS     R6,#+2
        MOV      R7,R8
        B.N      ??inverse_kinematics_MORGAN_SCARA_0
??inverse_kinematics_MORGAN_SCARA_1:
        MOV      R0,R5
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??inverse_kinematics_MORGAN_SCARA_0:
        LSLS     R0,R6,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_2
        MOV      R0,R7
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??inverse_kinematics_MORGAN_SCARA_2:
        LSRS     R6,R6,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_1
        MOV      R11,R10
        MOVS     R5,#+2
        MOV      R6,R8
        B.N      ??inverse_kinematics_MORGAN_SCARA_3
??inverse_kinematics_MORGAN_SCARA_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??inverse_kinematics_MORGAN_SCARA_3:
        LSLS     R0,R5,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_5
        MOV      R0,R6
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??inverse_kinematics_MORGAN_SCARA_5:
        LSRS     R5,R5,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_4
        MOV      R0,R7
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R1,??DataTable171_5
        LDR      R1,[R1, #+108]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??DataTable171_6  ;; 0xbf800000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
// 15095     else
// 15096       C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
// 15097 
// 15098     S2 = SQRT(1 - sq(C2));
        MOV      R6,R7
        MOVS     R5,#+2
        B.N      ??inverse_kinematics_MORGAN_SCARA_6
??inverse_kinematics_MORGAN_SCARA_7:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??inverse_kinematics_MORGAN_SCARA_6:
        LSLS     R0,R5,#+31
        BPL.N    ??inverse_kinematics_MORGAN_SCARA_8
        MOV      R0,R8
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??inverse_kinematics_MORGAN_SCARA_8:
        LSRS     R5,R5,#+1
        BNE.N    ??inverse_kinematics_MORGAN_SCARA_7
        MOV      R0,#+1065353216
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
// 15099 
// 15100     // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
// 15101     SK1 = L1 + L2 * C2;
// 15102 
// 15103     // Rotated Arm2 gives the distance from Arm1 to Arm2
// 15104     SK2 = L2 * S2;
// 15105 
// 15106     // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
// 15107     THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
        LDR.W    R5,??DataTable171_7  ;; 0x43160000
        MOV      R8,R0
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
        MOV      R0,R7
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall atan2f
        BL       atan2f
        MOV      R5,R0
        MOV      R1,R10
        MOV      R0,R9
          CFI FunCall atan2f
        BL       atan2f
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R6,R0
// 15108 
// 15109     // Angle of Arm2
// 15110     PSI = ATAN2(S2, C2);
        MOV      R1,R7
        MOV      R0,R8
          CFI FunCall atan2f
        BL       atan2f
        MOV      R5,R0
// 15111 
// 15112     delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
        LDR.W    R7,??DataTable171_8
        LDR.W    R9,??DataTable170_11  ;; 0x40668000
        MOV      R0,R6
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_10  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+60]
// 15113     delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
        MOV      R1,R5
        MOV      R0,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R2,??DataTable170_2  ;; 0x54442d18
        LDR.W    R3,??DataTable170_10  ;; 0x400921fb
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R7, #+64]
// 15114     delta[C_AXIS] = raw[Z_AXIS];
        LDR      R0,[R4, #+8]
        STR      R0,[R7, #+68]
// 15115 
// 15116     /*
// 15117       DEBUG_POS("SCARA IK", raw);
// 15118       DEBUG_POS("SCARA IK", delta);
// 15119       SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
// 15120       SERIAL_ECHOPAIR(",", sy);
// 15121       SERIAL_ECHOPAIR(" C2=", C2);
// 15122       SERIAL_ECHOPAIR(" S2=", S2);
// 15123       SERIAL_ECHOPAIR(" Theta=", THETA);
// 15124       SERIAL_ECHOLNPAIR(" Phi=", PHI);
// 15125     //
// 15126     */
// 15127   }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock82
// 15128 
// 15129 #endif // MORGAN_SCARA
// 15130 
// 15131 #if ENABLED(TEMP_STAT_LEDS)
// 15132 
// 15133   static bool red_led = false;
// 15134   static millis_t next_status_led_update_ms = 0;
// 15135 
// 15136   void handle_status_leds(void) {
// 15137     if (ELAPSED(millis(), next_status_led_update_ms)) {
// 15138       next_status_led_update_ms += 500; // Update every 0.5s
// 15139       float max_temp = 0.0;
// 15140       //#if HAS_TEMP_BED
// 15141       if(HAS_TEMP_BED)
// 15142         max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
// 15143       //#endif
// 15144       HOTEND_LOOP()
// 15145         max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
// 15146       const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
// 15147       if (new_led != red_led) {
// 15148         red_led = new_led;
// 15149         #if PIN_EXISTS(STAT_LED_RED)
// 15150           WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
// 15151           #if PIN_EXISTS(STAT_LED_BLUE)
// 15152             WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
// 15153           #endif
// 15154         #else
// 15155           WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
// 15156         #endif
// 15157       }
// 15158     }
// 15159   }
// 15160 
// 15161 #endif
// 15162 
// 15163 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15164 
// 15165   void handle_filament_runout() {
// 15166     if (!filament_ran_out) {
// 15167       filament_ran_out = true;
// 15168       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
// 15169       stepper.synchronize();
// 15170     }
// 15171   }
// 15172 
// 15173 #endif // FILAMENT_RUNOUT_SENSOR
// 15174 
// 15175 #if ENABLED(FAST_PWM_FAN)
// 15176 
// 15177   void setPwmFrequency(uint8_t pin, int val) {
// 15178     val &= 0x07;
// 15179     switch (digitalPinToTimer(pin)) {
// 15180       #ifdef TCCR0A
// 15181         #if !AVR_AT90USB1286_FAMILY
// 15182           case TIMER0A:
// 15183         #endif
// 15184         case TIMER0B:                           //_SET_CS(0, val);
// 15185                                                   break;
// 15186       #endif
// 15187       #ifdef TCCR1A
// 15188         case TIMER1A: case TIMER1B:             //_SET_CS(1, val);
// 15189                                                   break;
// 15190       #endif
// 15191       #if defined(TCCR2) || defined(TCCR2A)
// 15192         #ifdef TCCR2
// 15193           case TIMER2:
// 15194         #endif
// 15195         #ifdef TCCR2A
// 15196           case TIMER2A: case TIMER2B:
// 15197         #endif
// 15198                                                   _SET_CS(2, val); break;
// 15199       #endif
// 15200       #ifdef TCCR3A
// 15201         case TIMER3A: case TIMER3B: case TIMER3C: _SET_CS(3, val); break;
// 15202       #endif
// 15203       #ifdef TCCR4A
// 15204         case TIMER4A: case TIMER4B: case TIMER4C: _SET_CS(4, val); break;
// 15205       #endif
// 15206       #ifdef TCCR5A
// 15207         case TIMER5A: case TIMER5B: case TIMER5C: _SET_CS(5, val); break;
// 15208       #endif
// 15209     }
// 15210   }
// 15211 
// 15212 #endif // FAST_PWM_FAN
// 15213 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock83 Using cfiCommon0
          CFI Function _Z19enable_all_steppersv
        THUMB
// 15214 void enable_all_steppers() {
_Z19enable_all_steppersv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15215   enable_X();
        LDR.W    R4,??DataTable171_9
        LDR.W    R5,??DataTable171_10
        LDR.W    R6,??DataTable171_11
        LDRH     R1,[R5, #+4]
        LDRSB    R2,[R6, #+260]
        LDR      R0,[R4, #+8]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15216   enable_Y();
        LDRH     R1,[R5, #+14]
        LDR      R0,[R4, #+28]
        ADD      R6,R6,#+260
        LDRSB    R2,[R6, #+1]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15217   enable_Z();
        LDRSB    R2,[R6, #+2]
        LDRH     R1,[R5, #+24]
        LDR      R0,[R4, #+48]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRSB    R2,[R6, #+2]
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15218   enable_E0();
        LDRSB    R2,[R6, #+3]
        LDRH     R1,[R5, #+34]
        LDR      R0,[R4, #+68]
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15219   enable_E1();
        LDRSB    R2,[R6, #+3]
        LDRH     R1,[R5, #+40]
        LDR      R0,[R4, #+80]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock83
// 15220   enable_E2();
// 15221   enable_E3();
// 15222   enable_E4();
// 15223 }
// 15224 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock84 Using cfiCommon0
          CFI Function _Z18disable_e_steppersv
        THUMB
// 15225 void disable_e_steppers() {
_Z18disable_e_steppersv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15226   disable_E0();
        LDR.N    R4,??DataTable158_1
        LDR.W    R5,??DataTable171_9
        LDRB     R0,[R4, #+263]
        LDR.W    R6,??DataTable171_10
        LDRH     R1,[R6, #+34]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R5, #+68]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
// 15227   disable_E1();
        LDRB     R0,[R4, #+263]
        LDRH     R1,[R6, #+40]
        SUBS     R2,R0,#+1
        LDR      R0,[R5, #+80]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        B.W      HAL_GPIO_WritePin
          CFI EndBlock cfiBlock84
// 15228   disable_E2();
// 15229   disable_E3();
// 15230   disable_E4();
// 15231 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable158:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable158_1:
        DC32     mksCfg
// 15232 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock85 Using cfiCommon0
          CFI Function _Z20disable_all_steppersv
        THUMB
// 15233 void disable_all_steppers() {
_Z20disable_all_steppersv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 15234   disable_X();
        LDR.W    R7,??DataTable171_11
        LDR.W    R4,??DataTable171_9
        LDRB     R0,[R7, #+260]
        LDR.W    R5,??DataTable171_10
        LDRH     R1,[R5, #+4]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R4, #+8]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.W    R6,??DataTable171_8
// 15235   disable_Y();
        LDRH     R1,[R5, #+14]
        MOVS     R0,#+0
        STRB     R0,[R6, #+4]
        ADD      R7,R7,#+260
        LDRB     R0,[R7, #+1]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R4, #+28]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+5]
// 15236   disable_Z();
        LDRB     R0,[R7, #+2]
        LDRH     R1,[R5, #+24]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R4, #+48]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R7, #+2]
        LDRH     R1,[R5, #+40]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R4, #+80]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R6, #+6]
// 15237   disable_e_steppers();
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.N      _Z18disable_e_steppersv
          CFI EndBlock cfiBlock85
// 15238 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable159:
        DC32     _ZN17mesh_bed_leveling13index_to_xposE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable159_1:
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
// 15239 
// 15240 #if ENABLED(MONITOR_DRIVER_STATUS)
// 15241   /*
// 15242    * Check for over temperature or short to ground error flags.
// 15243    * Report and log warning of overtemperature condition.
// 15244    * Reduce driver current in a persistent otpw condition.
// 15245    * Keep track of otpw counter so we don't reduce current on a single instance,
// 15246    * and so we don't repeatedly report warning before the condition is cleared.
// 15247    */
// 15248 
// 15249   struct TMC_driver_data {
// 15250     uint32_t drv_status;
// 15251     bool is_otpw;
// 15252     bool is_ot;
// 15253     bool is_error;
// 15254   };
// 15255   #if ENABLED(HAVE_TMC2130)
// 15256     static uint32_t get_pwm_scale(TMC2130Stepper &st) { return st.PWM_SCALE(); }
// 15257     static uint8_t get_status_response(TMC2130Stepper &st) { return st.status_response&0xF; }
// 15258     static TMC_driver_data get_driver_data(TMC2130Stepper &st) {
// 15259       constexpr uint32_t OTPW_bm = 0x4000000UL;
// 15260       constexpr uint8_t OTPW_bp = 26;
// 15261       constexpr uint32_t OT_bm = 0x2000000UL;
// 15262       constexpr uint8_t OT_bp = 25;
// 15263       constexpr uint8_t DRIVER_ERROR_bm = 0x2UL;
// 15264       constexpr uint8_t DRIVER_ERROR_bp = 1;
// 15265       TMC_driver_data data;
// 15266       data.drv_status = st.DRV_STATUS();
// 15267       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 15268       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 15269       data.is_error = (st.status_response & DRIVER_ERROR_bm)>>DRIVER_ERROR_bp;
// 15270       return data;
// 15271     }
// 15272   #endif
// 15273   #if ENABLED(HAVE_TMC2208)
// 15274     static uint32_t get_pwm_scale(TMC2208Stepper &st) { return st.pwm_scale_sum(); }
// 15275     static uint8_t get_status_response(TMC2208Stepper &st) {
// 15276       uint32_t drv_status = st.DRV_STATUS();
// 15277       uint8_t gstat = st.GSTAT();
// 15278       uint8_t response = 0;
// 15279       response |= (drv_status >> (31-3)) & 0b1000;
// 15280       response |= gstat & 0b11;
// 15281       return response;
// 15282     }
// 15283     static TMC_driver_data get_driver_data(TMC2208Stepper &st) {
// 15284       constexpr uint32_t OTPW_bm = 0b1ul;
// 15285       constexpr uint8_t OTPW_bp = 0;
// 15286       constexpr uint32_t OT_bm = 0b10ul;
// 15287       constexpr uint8_t OT_bp = 1;
// 15288       TMC_driver_data data;
// 15289       data.drv_status = st.DRV_STATUS();
// 15290       data.is_otpw = (data.drv_status & OTPW_bm)>>OTPW_bp;
// 15291       data.is_ot = (data.drv_status & OT_bm)>>OT_bp;
// 15292       data.is_error = st.drv_err();
// 15293       return data;
// 15294     }
// 15295   #endif
// 15296 
// 15297   template<typename TMC>
// 15298   uint8_t monitor_tmc_driver(TMC &st, const char axisID, uint8_t otpw_cnt) {
// 15299     TMC_driver_data data = get_driver_data(st);
// 15300 
// 15301     #if ENABLED(STOP_ON_ERROR)
// 15302       if (data.is_error) {
// 15303         SERIAL_EOL();
// 15304         SERIAL_ECHO(axisID);
// 15305         SERIAL_ECHO(" driver error detected:");
// 15306         if (data.is_ot) SERIAL_ECHO("\novertemperature");
// 15307         if (st.s2ga()) SERIAL_ECHO("\nshort to ground (coil A)");
// 15308         if (st.s2gb()) SERIAL_ECHO("\nshort to ground (coil B)");
// 15309         SERIAL_EOL();
// 15310         #if ENABLED(TMC_DEBUG)
// 15311           gcode_M122();
// 15312         #endif
// 15313         kill(PSTR("Driver error"));
// 15314       }
// 15315     #endif
// 15316 
// 15317     // Report if a warning was triggered
// 15318     if (data.is_otpw && otpw_cnt==0) {
// 15319       char timestamp[10];
// 15320       duration_t elapsed = print_job_timer.duration();
// 15321       const bool has_days = (elapsed.value > 60*60*24L);
// 15322       (void)elapsed.toDigital(timestamp, has_days);
// 15323       SERIAL_EOL();
// 15324       SERIAL_ECHO(timestamp);
// 15325       SERIAL_ECHOPGM(": ");
// 15326       SERIAL_ECHO(axisID);
// 15327       SERIAL_ECHOPGM(" driver overtemperature warning! (");
// 15328       SERIAL_ECHO(st.getCurrent());
// 15329       SERIAL_ECHOLN("mA)");
// 15330     }
// 15331     #if CURRENT_STEP_DOWN > 0
// 15332       // Decrease current if is_otpw is true and driver is enabled and there's been more then 4 warnings
// 15333       if (data.is_otpw && !st.isEnabled() && otpw_cnt > 4) {
// 15334         st.setCurrent(st.getCurrent() - CURRENT_STEP_DOWN, R_SENSE, HOLD_MULTIPLIER);
// 15335         #if ENABLED(REPORT_CURRENT_CHANGE)
// 15336           SERIAL_ECHO(axisID);
// 15337           SERIAL_ECHOLNPAIR(" current decreased to ", st.getCurrent());
// 15338         #endif
// 15339       }
// 15340     #endif
// 15341 
// 15342     if (data.is_otpw) {
// 15343       otpw_cnt++;
// 15344       st.flag_otpw = true;
// 15345     }
// 15346     else if (otpw_cnt>0) otpw_cnt--;
// 15347 
// 15348     if (report_tmc_status) {
// 15349       const uint32_t pwm_scale = get_pwm_scale(st);
// 15350       SERIAL_ECHO(axisID);
// 15351       SERIAL_ECHOPAIR(":", pwm_scale);
// 15352       SERIAL_ECHO(" |0b"); MYSERIAL.print(get_status_response(st), BIN);
// 15353       SERIAL_ECHO("| ");
// 15354       if (data.is_error) SERIAL_ECHO('E');
// 15355       else if (data.is_ot) SERIAL_ECHO('O');
// 15356       else if (data.is_otpw) SERIAL_ECHO('W');
// 15357       else if (otpw_cnt>0) MYSERIAL.print(otpw_cnt, DEC);
// 15358       else if (st.flag_otpw) SERIAL_ECHO('F');
// 15359       SERIAL_ECHO("\t");
// 15360     }
// 15361 
// 15362     return otpw_cnt;
// 15363   }
// 15364 
// 15365   void monitor_tmc_driver() {
// 15366     static millis_t next_cOT = 0;
// 15367     if (ELAPSED(millis(), next_cOT)) {
// 15368       next_cOT = millis() + 500;
// 15369       #if ENABLED(X_IS_TMC2130)|| (ENABLED(X_IS_TMC2208) && defined(X_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15370         static uint8_t x_otpw_cnt = 0;
// 15371         x_otpw_cnt = monitor_tmc_driver(stepperX, axis_codes[X_AXIS], x_otpw_cnt);
// 15372       #endif
// 15373       #if ENABLED(Y_IS_TMC2130)|| (ENABLED(Y_IS_TMC2208) && defined(Y_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15374         static uint8_t y_otpw_cnt = 0;
// 15375         y_otpw_cnt = monitor_tmc_driver(stepperY, axis_codes[Y_AXIS], y_otpw_cnt);
// 15376       #endif
// 15377       #if ENABLED(Z_IS_TMC2130)|| (ENABLED(Z_IS_TMC2208) && defined(Z_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15378         static uint8_t z_otpw_cnt = 0;
// 15379         z_otpw_cnt = monitor_tmc_driver(stepperZ, axis_codes[Z_AXIS], z_otpw_cnt);
// 15380       #endif
// 15381       #if ENABLED(X2_IS_TMC2130) || (ENABLED(X2_IS_TMC2208) && defined(X2_HARDWARE_SERIAL))
// 15382         static uint8_t x2_otpw_cnt = 0;
// 15383         x2_otpw_cnt = monitor_tmc_driver(stepperX2, axis_codes[X_AXIS], x2_otpw_cnt);
// 15384       #endif
// 15385       #if ENABLED(Y2_IS_TMC2130) || (ENABLED(Y2_IS_TMC2208) && defined(Y2_HARDWARE_SERIAL))
// 15386         static uint8_t y2_otpw_cnt = 0;
// 15387         y2_otpw_cnt = monitor_tmc_driver(stepperY2, axis_codes[Y_AXIS], y2_otpw_cnt);
// 15388       #endif
// 15389       #if ENABLED(Z2_IS_TMC2130) || (ENABLED(Z2_IS_TMC2208) && defined(Z2_HARDWARE_SERIAL))
// 15390         static uint8_t z2_otpw_cnt = 0;
// 15391         z2_otpw_cnt = monitor_tmc_driver(stepperZ2, axis_codes[Z_AXIS], z2_otpw_cnt);
// 15392       #endif
// 15393       #if ENABLED(E0_IS_TMC2130)|| (ENABLED(E0_IS_TMC2208) && defined(E0_HARDWARE_SERIAL)) || ENABLED(IS_TRAMS)
// 15394         static uint8_t e0_otpw_cnt = 0;
// 15395         e0_otpw_cnt = monitor_tmc_driver(stepperE0, axis_codes[E_AXIS], e0_otpw_cnt);
// 15396       #endif
// 15397       #if ENABLED(E1_IS_TMC2130) || (ENABLED(E1_IS_TMC2208) && defined(E1_HARDWARE_SERIAL))
// 15398         static uint8_t e1_otpw_cnt = 0;
// 15399         e1_otpw_cnt = monitor_tmc_driver(stepperE1, axis_codes[E_AXIS], e1_otpw_cnt);
// 15400       #endif
// 15401       #if ENABLED(E2_IS_TMC2130) || (ENABLED(E2_IS_TMC2208) && defined(E2_HARDWARE_SERIAL))
// 15402         static uint8_t e2_otpw_cnt = 0;
// 15403         e2_otpw_cnt = monitor_tmc_driver(stepperE2, axis_codes[E_AXIS], e2_otpw_cnt);
// 15404       #endif
// 15405       #if ENABLED(E3_IS_TMC2130) || (ENABLED(E3_IS_TMC2208) && defined(E3_HARDWARE_SERIAL))
// 15406         static uint8_t e3_otpw_cnt = 0;
// 15407         e3_otpw_cnt = monitor_tmc_driver(stepperE3, axis_codes[E_AXIS], e3_otpw_cnt);
// 15408       #endif
// 15409       #if ENABLED(E4_IS_TMC2130) || (ENABLED(E4_IS_TMC2208) && defined(E4_HARDWARE_SERIAL))
// 15410         static uint8_t e4_otpw_cnt = 0;
// 15411         e4_otpw_cnt = monitor_tmc_driver(stepperE4, axis_codes[E_AXIS], e4_otpw_cnt);
// 15412       #endif
// 15413 
// 15414       if (report_tmc_status) SERIAL_EOL();
// 15415     }
// 15416   }
// 15417 
// 15418 #endif // MONITOR_DRIVER_STATUS
// 15419 
// 15420 /**
// 15421  * Manage several activities:
// 15422  *  - Check for Filament Runout
// 15423  *  - Keep the command buffer full
// 15424  *  - Check for maximum inactive time between commands
// 15425  *  - Check for maximum inactive time between stepper commands
// 15426  *  - Check if pin CHDK needs to go LOW
// 15427  *  - Check for KILL button held down
// 15428  *  - Check for HOME button held down
// 15429  *  - Check if cooling fan needs to be switched on
// 15430  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
// 15431  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock86 Using cfiCommon0
          CFI Function _Z17manage_inactivityb
        THUMB
// 15432 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
_Z17manage_inactivityb:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
// 15433 
// 15434   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15435     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
// 15436       handle_filament_runout();
// 15437   #endif
// 15438 
// 15439   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R6,??DataTable172
        MOV      R5,R0
        LDRB     R0,[R6, #+6]
        CMP      R0,#+4
        IT       LT 
          CFI FunCall _Z22get_available_commandsv
        BLLT     _Z22get_available_commandsv
// 15440 
// 15441   const millis_t ms = millis();
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
// 15442 
// 15443   if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
        LDR.W    R4,??DataTable171_8
        MOV      R7,R0
        LDR      R0,[R4, #+96]
        CBZ.N    R0,??manage_inactivity_0
        LDR      R1,[R6, #+120]
        SUBS     R1,R7,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_0
// 15444     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable172_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15445     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
        LDR.W    R0,??DataTable172_2
        LDR      R1,[R0, #+0]
        LDR.W    R0,??DataTable172_3
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.W    R0,??DataTable172_4
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15446     kill(PSTR(MSG_KILLED));
        LDR.W    R0,??DataTable172_5
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
// 15447   }
// 15448 
// 15449   // Prevent steppers timing-out in the middle of M600
// 15450   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
// 15451     #define MOVE_AWAY_TEST !move_away_flag
// 15452   #else
// 15453     #define MOVE_AWAY_TEST true
// 15454   #endif
// 15455 
// 15456   if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
// 15457       && !ignore_stepper_queue && !planner.blocks_queued()) {
??manage_inactivity_0:
        LDR.W    R0,??DataTable172_6
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BEQ.N    ??manage_inactivity_1
        LDR      R1,[R6, #+120]
        SUBS     R1,R7,R1
        SUBS     R0,R1,R0
        BMI.N    ??manage_inactivity_1
        CMP      R5,#+0
        BNE.N    ??manage_inactivity_1
        LDR.W    R0,??DataTable172_7
        LDR.W    R1,??DataTable172_8
        LDRB     R0,[R0, #+0]
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BNE.N    ??manage_inactivity_1
// 15458     #if ENABLED(DISABLE_INACTIVE_X)
// 15459       disable_X();
        LDR.W    R7,??DataTable171_11
        LDR.W    R5,??DataTable171_9
        LDRB     R0,[R7, #+260]
        LDR.W    R6,??DataTable171_10
        LDRH     R1,[R6, #+4]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R5, #+8]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
// 15460     #endif
// 15461     #if ENABLED(DISABLE_INACTIVE_Y)
// 15462       disable_Y();
        ADD      R7,R7,#+260
        LDRB     R0,[R7, #+1]
        LDRH     R1,[R6, #+14]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R5, #+28]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+5]
// 15463     #endif
// 15464     #if ENABLED(DISABLE_INACTIVE_Z)
// 15465       disable_Z();
        LDRB     R0,[R7, #+2]
        LDRH     R1,[R6, #+24]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R5, #+48]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R7, #+2]
        LDRH     R1,[R6, #+40]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R5, #+80]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
// 15466     #endif
// 15467     #if ENABLED(DISABLE_INACTIVE_E)
// 15468       disable_e_steppers();
          CFI FunCall _Z18disable_e_steppersv
        BL       _Z18disable_e_steppersv
// 15469     #endif
// 15470     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
// 15471       ubl.lcd_map_control = defer_return_to_status = false;
// 15472     #endif
// 15473   }
// 15474 
// 15475   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
// 15476     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
// 15477       chdkActive = false;
// 15478       WRITE(CHDK, LOW);
// 15479     }
// 15480   #endif
// 15481 
// 15482   #if HAS_KILL
// 15483 
// 15484     // Check if the kill button was pressed and wait just in case it was an accidental
// 15485     // key kill key press
// 15486     // -------------------------------------------------------------------------------
// 15487     static int killCount = 0;   // make the inactivity button a bit less responsive
// 15488     const int KILL_DELAY = 750;
// 15489     if (!READ(KILL_PIN))
// 15490       killCount++;
// 15491     else if (killCount > 0)
// 15492       killCount--;
// 15493 
// 15494     // Exceeded threshold and we can confirm that it was not accidental
// 15495     // KILL the machine
// 15496     // ----------------------------------------------------------------
// 15497     if (killCount >= KILL_DELAY) {
// 15498       SERIAL_ERROR_START();
// 15499       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
// 15500       kill(PSTR(MSG_KILLED));
// 15501     }
// 15502   #endif
// 15503 
// 15504   #if HAS_HOME
// 15505     // Check to see if we have to home, use poor man's debouncer
// 15506     // ---------------------------------------------------------
// 15507     static int homeDebounceCount = 0;   // poor man's debouncing count
// 15508     const int HOME_DEBOUNCE_DELAY = 2500;
// 15509     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
// 15510       if (!homeDebounceCount) {
// 15511         enqueue_and_echo_commands_P(PSTR("G28"));
// 15512         LCD_MESSAGEPGM(MSG_AUTO_HOME);
// 15513       }
// 15514       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
// 15515         homeDebounceCount++;
// 15516       else
// 15517         homeDebounceCount = 0;
// 15518     }
// 15519   #endif
// 15520 
// 15521   #if ENABLED(USE_CONTROLLER_FAN)
// 15522     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
// 15523   #endif
// 15524 
// 15525   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
// 15526     if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
// 15527       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
// 15528       #if ENABLED(SWITCHING_EXTRUDER)
// 15529         const bool oldstatus = E0_ENABLE_READ;
// 15530         enable_E0();
// 15531       #else // !SWITCHING_EXTRUDER
// 15532         bool oldstatus;
// 15533         switch (active_extruder) {
// 15534           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
// 15535           #if E_STEPPERS > 1
// 15536             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
// 15537             #if E_STEPPERS > 2
// 15538               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
// 15539               #if E_STEPPERS > 3
// 15540                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
// 15541                 #if E_STEPPERS > 4
// 15542                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
// 15543                 #endif // E_STEPPERS > 4
// 15544               #endif // E_STEPPERS > 3
// 15545             #endif // E_STEPPERS > 2
// 15546           #endif // E_STEPPERS > 1
// 15547         }
// 15548       #endif // !SWITCHING_EXTRUDER
// 15549 
// 15550       previous_cmd_ms = ms; // refresh_cmd_timeout()
// 15551 
// 15552       const float olde = current_position[E_AXIS];
// 15553       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
// 15554       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
// 15555       current_position[E_AXIS] = olde;
// 15556       planner.set_e_position_mm(olde);
// 15557       stepper.synchronize();
// 15558       #if ENABLED(SWITCHING_EXTRUDER)
// 15559         E0_ENABLE_WRITE(oldstatus);
// 15560       #else
// 15561         switch (active_extruder) {
// 15562           case 0: E0_ENABLE_WRITE(oldstatus); break;
// 15563           #if E_STEPPERS > 1
// 15564             case 1: E1_ENABLE_WRITE(oldstatus); break;
// 15565             #if E_STEPPERS > 2
// 15566               case 2: E2_ENABLE_WRITE(oldstatus); break;
// 15567               #if E_STEPPERS > 3
// 15568                 case 3: E3_ENABLE_WRITE(oldstatus); break;
// 15569                 #if E_STEPPERS > 4
// 15570                   case 4: E4_ENABLE_WRITE(oldstatus); break;
// 15571                 #endif // E_STEPPERS > 4
// 15572               #endif // E_STEPPERS > 3
// 15573             #endif // E_STEPPERS > 2
// 15574           #endif // E_STEPPERS > 1
// 15575         }
// 15576       #endif // !SWITCHING_EXTRUDER
// 15577     }
// 15578   #endif // EXTRUDER_RUNOUT_PREVENT
// 15579 
// 15580   #if ENABLED(DUAL_X_CARRIAGE)
// 15581     // handle delayed move timeout
// 15582     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
// 15583       // travel moves have been received so enact them
// 15584       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
// 15585       set_destination_from_current();
// 15586       prepare_move_to_destination();
// 15587     }
// 15588   #endif
// 15589 
// 15590   #if ENABLED(TEMP_STAT_LEDS)
// 15591     handle_status_leds();
// 15592   #endif
// 15593 
// 15594   #if ENABLED(MONITOR_DRIVER_STATUS)
// 15595     monitor_tmc_driver();
// 15596   #endif
// 15597 
// 15598   planner.check_axes_activity();
??manage_inactivity_1:
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19check_axes_activityEv
        B.W      _ZN7Planner19check_axes_activityEv
          CFI EndBlock cfiBlock86
// 15599 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable160:
        DC32     ??gridx
// 15600 
// 15601 /**
// 15602  * Standard idle routine keeps the machine alive
// 15603  */
// 15604 //extern uint8_t display_hold;
// 15605 //extern uint32_t display_hold_cnt;
// 15606 //extern uint8_t display_hold_release;
// 15607 
// 15608 uint8_t display_hold=0;
// 15609 uint32_t display_hold_cnt=0;
// 15610 uint8_t display_hold_release=0;
// 15611 uint8_t button_disp_pause_state=0;
// 15612 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock87 Using cfiCommon0
          CFI Function _Z10lcd_reInitv
        THUMB
// 15613 void lcd_reInit()
// 15614 {
_Z10lcd_reInitv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15615    GUI_Init();
          CFI FunCall GUI_Init
        BL       GUI_Init
// 15616    //GUI_UC_SetEncodeUTF8();
// 15617    gui_view_init(); 
          CFI FunCall gui_view_init
        BL       gui_view_init
// 15618    
// 15619    if((gCfgItems.language == LANG_SIMPLE_CHINESE)||(gCfgItems.language == LANG_COMPLEX_CHINESE))
        LDR.W    R0,??DataTable172_9
        LDRSB    R1,[R0, #+200]
        CMP      R1,#+1
        ITT      NE 
        LDRSBNE  R0,[R0, #+200]
        CMPNE    R0,#+2
        BNE.N    ??lcd_reInit_0
// 15620   {
// 15621     GUI_SetFont(&GUI_FontHZ16);
        LDR.W    R4,??DataTable172_10
        MOV      R0,R4
          CFI FunCall GUI_SetFont
        BL       GUI_SetFont
// 15622     BUTTON_SetDefaultFont(&GUI_FontHZ16);
        MOV      R0,R4
          CFI FunCall BUTTON_SetDefaultFont
        BL       BUTTON_SetDefaultFont
// 15623     TEXT_SetDefaultFont(&GUI_FontHZ16);  
        MOV      R0,R4
          CFI FunCall TEXT_SetDefaultFont
        BL       TEXT_SetDefaultFont
// 15624     GUI_UC_SetEncodeNone();
          CFI FunCall GUI_UC_SetEncodeNone
        BL       GUI_UC_SetEncodeNone
        B.N      ??lcd_reInit_1
// 15625   }
// 15626   else
// 15627   {
// 15628     GUI_SetFont(&FONT_TITLE);
??lcd_reInit_0:
        LDR.W    R4,??DataTable172_11
        MOV      R0,R4
          CFI FunCall GUI_SetFont
        BL       GUI_SetFont
// 15629     BUTTON_SetDefaultFont(&FONT_TITLE);
        MOV      R0,R4
          CFI FunCall BUTTON_SetDefaultFont
        BL       BUTTON_SetDefaultFont
// 15630     TEXT_SetDefaultFont(&FONT_TITLE);                    
        MOV      R0,R4
          CFI FunCall TEXT_SetDefaultFont
        BL       TEXT_SetDefaultFont
// 15631     GUI_UC_SetEncodeUTF8();
          CFI FunCall GUI_UC_SetEncodeUTF8
        BL       GUI_UC_SetEncodeUTF8
// 15632   }
// 15633   
// 15634    clear_cur_ui();
??lcd_reInit_1:
          CFI FunCall clear_cur_ui
        BL       clear_cur_ui
// 15635    disp_state_stack._disp_index += 1;
        LDR.W    R0,??DataTable172_12
// 15636    if(mksReprint.mks_printer_state == MKS_REPRINTED)
        LDR.W    R4,??DataTable172_13
        LDRB     R1,[R0, #+100]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+100]
        LDR.W    R0,??DataTable172_14
        LDRB     R0,[R0, #+2068]
        CMP      R0,#+172
        ITT      EQ 
// 15637    {
// 15638    	button_disp_pause_state=1;
        MOVEQ    R0,#+1
        STRBEQ   R0,[R4, #+0]
// 15639    }
// 15640    draw_return_ui();
          CFI FunCall draw_return_ui
        BL       draw_return_ui
// 15641    button_disp_pause_state=0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
// 15642    Lcd_Light_ON;
        MOVS     R0,#+1
        LDR.W    R1,??DataTable172_15  ;; 0x422281b4
        STR      R0,[R1, #+0]
// 15643 }
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock87
// 15644 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock88 Using cfiCommon0
          CFI Function _Z4idlev
        THUMB
// 15645 void idle(
// 15646   #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 15647     bool no_stepper_sleep/*=false*/
// 15648   #endif
// 15649 ) {
_Z4idlev:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15650   #if ENABLED(MAX7219_DEBUG)
// 15651     Max7219_idle_tasks();
// 15652   #endif  // MAX7219_DEBUG
// 15653 
// 15654    if(gCfgItems.standby_mode==1)
        LDR.W    R0,??DataTable172_9
        LDRB     R1,[R0, #+692]
        CMP      R1,#+1
        BNE.N    ??idle_0
// 15655     {
// 15656         if(display_hold_cnt>=gCfgItems.standby_time)
        LDR.W    R1,??DataTable173
        LDR      R2,[R1, #+44]
        ADD      R0,R0,#+692
        LDR      R3,[R0, #+4]
        CMP      R2,R3
        BCC.N    ??idle_1
// 15657         {
// 15658             display_hold_cnt -= gCfgItems.standby_time;
        LDR      R0,[R0, #+4]
        SUBS     R0,R2,R0
        STR      R0,[R1, #+44]
// 15659             display_hold=1;
        MOVS     R0,#+1
        STRB     R0,[R1, #+8]
// 15660             Lcd_Light_OFF;
        MOVS     R0,#+0
        LDR.W    R2,??DataTable172_15  ;; 0x422281b4
        STR      R0,[R2, #+0]
// 15661         }
// 15662         if(display_hold_release==1)
??idle_1:
        LDRB     R0,[R1, #+9]
        CMP      R0,#+1
        BNE.N    ??idle_0
// 15663         {
// 15664             display_hold=0;
        MOVS     R0,#+0
        STRB     R0,[R1, #+8]
// 15665             display_hold_release=0;
        STRB     R0,[R1, #+9]
// 15666             lcd_reInit();
          CFI FunCall _Z10lcd_reInitv
        BL       _Z10lcd_reInitv
// 15667         }
// 15668     }
// 15669 
// 15670   lcd_update();
// 15671 
// 15672   host_keepalive();
??idle_0:
          CFI FunCall _Z14host_keepalivev
        BL       _Z14host_keepalivev
// 15673 
// 15674   //#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
// 15675    #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND)	
// 15676     thermalManager.auto_report_temperatures();
          CFI FunCall _ZN11Temperature24auto_report_temperaturesEv
        BL       _ZN11Temperature24auto_report_temperaturesEv
// 15677   #endif
// 15678 
// 15679   manage_inactivity(
// 15680     #if ENABLED(ADVANCED_PAUSE_FEATURE)
// 15681       no_stepper_sleep
// 15682     #endif
// 15683   );
        MOVS     R0,#+0
          CFI FunCall _Z17manage_inactivityb
        BL       _Z17manage_inactivityb
// 15684 
// 15685   thermalManager.manage_heater();
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
// 15686 
// 15687   #if ENABLED(PRINTCOUNTER)
// 15688     print_job_timer.tick();
// 15689   #endif
// 15690 
// 15691   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
// 15692     buzzer.tick();
// 15693   #endif
// 15694   #if 1
// 15695   display_temper_error();
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
// 15696   
// 15697   wifi_looping();
          CFI FunCall _Z12wifi_loopingv
        BL       _Z12wifi_loopingv
// 15698   
// 15699   if(wifi_link_state != WIFI_TRANS_FILE)
        LDR.W    R0,??DataTable172_16
        LDRSB    R0,[R0, #+0]
        CMP      R0,#+16
        IT       NE 
// 15700   {
// 15701 	  GUI_RefreshPage();
          CFI FunCall GUI_RefreshPage
        BLNE     GUI_RefreshPage
// 15702   }
// 15703   #if defined(TFT70)
// 15704   disp_pre_gcode(3,40);
// 15705   #elif defined(TFT35)
// 15706   //#if defined(MKS_ROBIN2)
// 15707   if(preview_no_display != 1)
        LDR.W    R0,??DataTable173
        LDRB     R0,[R0, #+5]
        CMP      R0,#+1
        BEQ.N    ??idle_2
// 15708   {
// 15709 	  disp_pre_gcode(2,36);
        MOVS     R1,#+36
        MOVS     R0,#+2
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
// 15710   }
// 15711   //#endif
// 15712   #endif
// 15713   
// 15714   GUI_TOUCH_Exec(); 	  
??idle_2:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
// 15715   GUI_Exec(); 
        POP      {R0,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall GUI_Exec
        B.W      GUI_Exec
          CFI EndBlock cfiBlock88
// 15716 
// 15717 #endif
// 15718   #if ENABLED(I2C_POSITION_ENCODERS)
// 15719     if (planner.blocks_queued() &&
// 15720         ( (blockBufferIndexRef != planner.block_buffer_head) ||
// 15721           ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
// 15722       blockBufferIndexRef = planner.block_buffer_head;
// 15723       I2CPEM.update();
// 15724       lastUpdateMillis = millis();
// 15725     }
// 15726   #endif
// 15727 }
// 15728 
// 15729 extern "C" void kill_c(const char* lcd_msg);

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock89 Using cfiCommon0
          CFI Function kill_c
        THUMB
// 15730 void kill_c(const char* lcd_msg) {
kill_c:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15731   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable172_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15732   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        LDR.W    R0,??DataTable173_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15733 
// 15734   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15735   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15736 
// 15737   #if ENABLED(ULTRA_LCD)
// 15738     kill_screen(lcd_msg);
// 15739   #else
// 15740     UNUSED(lcd_msg);
// 15741   #endif
// 15742 
// 15743   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15744   cli(); // Stop interrupts
        cpsid i
// 15745 
// 15746   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15747   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15748 
// 15749   #if HAS_POWER_SWITCH
// 15750     SET_INPUT(PS_ON_PIN);
// 15751   #endif
// 15752 
// 15753   suicide();
// 15754   while (1) {
??kill_c_0:
        B.N      ??kill_c_0
          CFI EndBlock cfiBlock89
// 15755     #if ENABLED(USE_WATCHDOG)
// 15756       watchdog_reset();
// 15757     #endif
// 15758   } // Wait for reset
// 15759 }
// 15760 #if 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock90 Using cfiCommon0
          CFI Function _Z17temper_error_killv
        THUMB
// 15761 void temper_error_kill()
// 15762 {
_Z17temper_error_killv:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15763   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable172_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15764   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        LDR.W    R0,??DataTable173_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15765 
// 15766   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15767   disable_all_steppers();	
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15768 
// 15769   _delay_ms(600);
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15770 
// 15771   temper_error_flg = 1;
        LDR.W    R1,??DataTable173_2
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
// 15772 }
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock90
// 15773 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock91 Using cfiCommon0
          CFI Function _Z20display_temper_errorv
        THUMB
// 15774 void display_temper_error()
// 15775 {
_Z20display_temper_errorv:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
// 15776     char buf_err[30]={0};
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        MOV      R4,R1
        STM      R0!,{R1-R4}
        STM      R0!,{R1-R4}
// 15777     
// 15778 	if(temper_error_flg == 1)
        LDR.W    R4,??DataTable173_2
        LDRB     R0,[R4, #+0]
        CMP      R0,#+1
        BNE.N    ??display_temper_error_0
// 15779 	{
// 15780 		card.sdprinting = false;
        LDR.W    R1,??DataTable172_14
        LDR.W    R5,??DataTable172_9
        MOVS     R0,#+0
        STRB     R0,[R1, #+1888]
// 15781 		wait_for_heatup = false;
        LDR.W    R1,??DataTable172
        STRB     R0,[R1, #+12]
// 15782 
// 15783 		GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+20]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 15784 		GUI_SetColor(0X0000ff);//	o¨¬¨¦?¡Á?¨¬?
        MOVS     R0,#+255
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 15785         sprintf(buf_err,"Err%d",temper_error_type);
        LDRB     R2,[R4, #+1]
        LDR.W    R1,??DataTable174
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
// 15786 		GUI_DispStringAt(buf_err,380, TITLE_YPOS);
        MOVS     R2,#+5
        MOV      R1,#+380
        ADD      R0,SP,#+0
          CFI FunCall GUI_DispStringAt
        BL       GUI_DispStringAt
// 15787 		GUI_SetBkColor(gCfgItems.background_color);
        LDR      R0,[R5, #+20]
          CFI FunCall GUI_SetBkColor
        BL       GUI_SetBkColor
// 15788 		GUI_SetColor(gCfgItems.title_color);			
        LDR      R0,[R5, #+24]
          CFI FunCall GUI_SetColor
        BL       GUI_SetColor
// 15789 	}
// 15790 }
??display_temper_error_0:
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock91

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable165:
        DC32     _ZN11Temperature18allow_cold_extrudeE
// 15791 
// 15792 #endif
// 15793 
// 15794 /**
// 15795  * Kill all activity and lock the machine.
// 15796  * After this the machine will need to be reset.
// 15797  */

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock92 Using cfiCommon0
          CFI Function _Z4killPKc
        THUMB
// 15798 void kill(const char* lcd_msg) {
_Z4killPKc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
// 15799   SERIAL_ERROR_START();
        LDR.W    R0,??DataTable172_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15800   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
        LDR.W    R0,??DataTable173_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15801 
// 15802   thermalManager.disable_all_heaters();
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15803   disable_all_steppers();
          CFI FunCall _Z20disable_all_steppersv
        BL       _Z20disable_all_steppersv
// 15804 
// 15805   #if ENABLED(ULTRA_LCD)
// 15806     kill_screen(lcd_msg);
// 15807   #else
// 15808     UNUSED(lcd_msg);
// 15809   #endif
// 15810 
// 15811   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
        MOV      R0,#+600
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15812  
// 15813 
// 15814   _delay_ms(250); //Wait to ensure all interrupts routines stopped
        MOVS     R0,#+250
          CFI FunCall HAL_Delay
        BL       HAL_Delay
// 15815    cli(); // Stop interrupts
        cpsid i
// 15816   thermalManager.disable_all_heaters(); //turn off heaters again
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15817 
// 15818   #ifdef ACTION_ON_KILL
// 15819     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
// 15820   #endif
// 15821 
// 15822   #if HAS_POWER_SWITCH
// 15823     SET_INPUT(PS_ON_PIN);
// 15824   #endif
// 15825 
// 15826   suicide();
// 15827   while (1) {
??kill_0:
        B.N      ??kill_0
          CFI EndBlock cfiBlock92
// 15828     #if ENABLED(USE_WATCHDOG)
// 15829       watchdog_reset();
// 15830     #endif
// 15831   } // Wait for reset
// 15832 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166:
        DC32     _ZN11Temperature16extrude_min_tempE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_1:
        DC32     _ZN11Temperature19current_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_2:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable166_3:
        DC32     `?<Constant " cold extrusion preve...">`
// 15833 
// 15834 /**
// 15835  * Turn off heaters and stop the print in progress
// 15836  * After a stop the machine may be resumed with M999
// 15837  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock93 Using cfiCommon0
          CFI Function _Z4stopv
        THUMB
// 15838 void stop() {
_Z4stopv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
// 15839   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
// 15840 
// 15841   #if ENABLED(PROBING_FANS_OFF)
// 15842     if (fans_paused) fans_pause(false); // put things back the way they were
// 15843   #endif
// 15844 
// 15845   if (IsRunning()) {
        LDR.W    R4,??DataTable172
        LDRB     R0,[R4, #+4]
        CBZ.N    R0,??stop_0
// 15846     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
// 15847     SERIAL_ERROR_START();
        LDR.W    R0,??DataTable172_1
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15848     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
        LDR.W    R0,??DataTable175
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15849     LCD_MESSAGEPGM(MSG_STOPPED);
// 15850     safe_delay(350);       // allow enough time for messages to get out before stopping
        MOV      R0,#+350
          CFI FunCall _Z10safe_delaym
        BL       _Z10safe_delaym
// 15851     Running = false;
        MOVS     R0,#+0
        STRB     R0,[R4, #+4]
// 15852   }
// 15853 }
??stop_0:
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock93

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_1:
        DC32     0x447a0001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_2:
        DC32     `?<Constant " too long extrusion p...">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_3:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_4:
        DC32     _ZN7Planner15leveling_activeE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable167_5:
        DC32     _ZN7Planner13z_fade_heightE
// 15854 
// 15855 /**
// 15856  * Marlin entry-point: Set up before the program loop
// 15857  *  - Set up the kill pin, filament runout, power hold
// 15858  *  - Start the serial port
// 15859  *  - Print startup messages and diagnostics
// 15860  *  - Get EEPROM or default settings
// 15861  *  - Initialize managers for:
// 15862  *    temperature
// 15863  *    planner
// 15864  *    watchdog
// 15865  *    stepper
// 15866  *    photo pin
// 15867  *    servos
// 15868  *    LCD controller
// 15869  *    Digipot I2C
// 15870  *    Z probe sled
// 15871  *    status LEDs
// 15872  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock94 Using cfiCommon0
          CFI Function setup
        THUMB
// 15873 void setup() {
setup:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 15874 
// 15875   #if ENABLED(MAX7219_DEBUG)
// 15876     Max7219_init();
// 15877   #endif
// 15878 /*
// 15879   #if ENABLED(DISABLE_JTAG)
// 15880     // Disable JTAG on AT90USB chips to free up pins for IO
// 15881     MCUCR = 0x80;
// 15882     MCUCR = 0x80;
// 15883   #endif
// 15884   */
// 15885 
// 15886   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
// 15887     setup_filrunoutpin();
// 15888   #endif
// 15889 
// 15890   setup_killpin();
// 15891 
// 15892   //setup_powerhold();
// 15893 
// 15894   #if HAS_STEPPER_RESET
// 15895     disableStepperDrivers();
// 15896   #endif
// 15897 
// 15898   //MYSERIAL.begin(BAUDRATE);
// 15899   //SERIAL_PROTOCOLLNPGM("start");
// 15900   //SERIAL_ECHO_START();
// 15901 
// 15902   #if ENABLED(HAVE_TMC2208)
// 15903     tmc2208_serial_begin();
// 15904   #endif
// 15905 
// 15906   // Check startup - does nothing if bootloader sets MCUSR to 0
// 15907   byte mcu = MCUSR;
// 15908   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
// 15909   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
// 15910   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
// 15911   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
// 15912   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
// 15913   //MCUSR = 0;
// 15914 
// 15915   SERIAL_ECHOPGM(MSG_MARLIN);
        LDR.W    R0,??DataTable173_3
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15916   SERIAL_CHAR(' ');
        LDR.W    R4,??DataTable172_4
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15917   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
        LDR.W    R0,??DataTable173_4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15918   SERIAL_EOL();
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15919 
// 15920   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
// 15921     SERIAL_ECHO_START();
        LDR.W    R5,??DataTable173_5
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15922     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
        LDR.W    R0,??DataTable173_6
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15923     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
        LDR.W    R0,??DataTable173_7
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15924     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
        LDR.W    R0,??DataTable173_8
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15925     SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15926     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
        LDR.W    R0,??DataTable173_9
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15927   #endif
// 15928 
// 15929   SERIAL_ECHO_START();
        MOV      R0,R5
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 15930   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
        MOVW     R1,#+4396
        LDR.W    R0,??DataTable173_10
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
// 15931   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
        LDR.W    R0,??DataTable173_11
        MOV      R1,#+1344
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
// 15932 
// 15933   // Send "ok" after commands by default
// 15934   for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
        LDR.W    R4,??DataTable173
        MOVS     R2,#+1
        MOVS     R1,#+4
        ADD      R0,R4,#+20
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
// 15935 
// 15936   // Load data from EEPROM if available (or use defaults)
// 15937   // This also updates variables in the planner, elsewhere
// 15938   (void)settings.load();
          CFI FunCall _ZN14MarlinSettings4loadEv
        BL       _ZN14MarlinSettings4loadEv
// 15939 
// 15940   //#if HAS_M206_COMMAND
// 15941     // Initialize current position based on home_offset
// 15942     if(MACHINETPYE != DELTA)
        LDR.W    R5,??DataTable171_11
        LDR.W    R0,??DataTable172
        LDRSH    R1,[R5, #+88]
        CMP      R1,#+2
        BEQ.N    ??setup_0
// 15943     	COPY(current_position, home_offset);
        ADD      R1,R0,#+48
        LDM      R1!,{R2,R3,R6}
        ADDS     R0,R0,#+16
        STM      R0!,{R2,R3,R6}
        B.N      ??setup_1
// 15944 	else
// 15945   //#else
// 15946     	ZERO(current_position);
??setup_0:
        ADDS     R0,R0,#+16
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        MOV      R6,R1
        STM      R0!,{R1-R3,R6}
// 15947   //#endif
// 15948 
// 15949   // Vital to init stepper/planner equivalent for current_position
// 15950   SYNC_PLAN_POSITION_KINEMATIC();
??setup_1:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
// 15951 
// 15952   thermalManager.init();    // Initialize temperature loop
        LDR.W    R0,??DataTable173_12
          CFI FunCall _ZN11Temperature4initEv
        BL       _ZN11Temperature4initEv
// 15953 
// 15954   #if ENABLED(USE_WATCHDOG)
// 15955     watchdog_init();
// 15956   #endif
// 15957   //tan add
// 15958   soft_endstop_min_init();
          CFI FunCall _Z21soft_endstop_min_initv
        BL       _Z21soft_endstop_min_initv
// 15959 
// 15960   stepper.init();    // Initialize stepper, this enables interrupts!
          CFI FunCall _ZN7Stepper4initEv
        BL       _ZN7Stepper4initEv
// 15961   servo_init();
// 15962 
// 15963   #if HAS_PHOTOGRAPH
// 15964     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
// 15965   #endif
// 15966 
// 15967   #if HAS_CASE_LIGHT
// 15968     case_light_on = CASE_LIGHT_DEFAULT_ON;
// 15969     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
// 15970     update_case_light();
// 15971   #endif
// 15972 
// 15973   #if ENABLED(SPINDLE_LASER_ENABLE)
// 15974     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
// 15975     #if SPINDLE_DIR_CHANGE
// 15976       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
// 15977     #endif
// 15978     #if ENABLED(SPINDLE_LASER_PWM)
// 15979       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
// 15980       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
// 15981     #endif
// 15982   #endif
// 15983 
// 15984   #if HAS_BED_PROBE
// 15985     endstops.enable_z_probe(false);
        LDR.W    R1,??DataTable175_1
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
// 15986   #endif
// 15987 
// 15988   #if ENABLED(USE_CONTROLLER_FAN)
// 15989     SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
// 15990   #endif
// 15991 
// 15992   #if HAS_STEPPER_RESET
// 15993     enableStepperDrivers();
// 15994   #endif
// 15995 
// 15996   #if ENABLED(DIGIPOT_I2C)
// 15997     digipot_i2c_init();
// 15998   #endif
// 15999 
// 16000   #if ENABLED(DAC_STEPPER_CURRENT)
// 16001     dac_init();
// 16002   #endif
// 16003 
// 16004   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
// 16005     OUT_WRITE(SOL1_PIN, LOW); // turn it off
// 16006   #endif
// 16007 
// 16008   #if HAS_HOME
// 16009     SET_INPUT_PULLUP(HOME_PIN);
// 16010   #endif
// 16011 
// 16012   #if PIN_EXISTS(STAT_LED_RED)
// 16013     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
// 16014   #endif
// 16015 
// 16016   #if PIN_EXISTS(STAT_LED_BLUE)
// 16017     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
// 16018   #endif
// 16019 
// 16020   #if HAS_COLOR_LEDS
// 16021     leds.setup();
// 16022   #endif
// 16023 
// 16024   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
// 16025     SET_OUTPUT(RGB_LED_R_PIN);
// 16026     SET_OUTPUT(RGB_LED_G_PIN);
// 16027     SET_OUTPUT(RGB_LED_B_PIN);
// 16028     #if ENABLED(RGBW_LED)
// 16029       SET_OUTPUT(RGB_LED_W_PIN);
// 16030     #endif
// 16031   #endif
// 16032 
// 16033   #if ENABLED(MK2_MULTIPLEXER)
// 16034     SET_OUTPUT(E_MUX0_PIN);
// 16035     SET_OUTPUT(E_MUX1_PIN);
// 16036     SET_OUTPUT(E_MUX2_PIN);
// 16037   #endif
// 16038 
// 16039   #if HAS_FANMUX
// 16040     fanmux_init();
// 16041   #endif
// 16042 
// 16043   lcd_init();
// 16044 
// 16045   #if ENABLED(SHOW_BOOTSCREEN)
// 16046     lcd_bootscreen();
// 16047   #endif
// 16048 
// 16049   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
// 16050     // Virtual Tools 0, 1, 2, 3 = Filament 1, 2, 3, 4, etc.
// 16051     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS && t < MIXING_STEPPERS; t++)
// 16052       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16053         mixing_virtual_tool_mix[t][i] = (t == i) ? 1.0 : 0.0;
// 16054 
// 16055     // Remaining virtual tools are 100% filament 1
// 16056     #if MIXING_STEPPERS < MIXING_VIRTUAL_TOOLS
// 16057       for (uint8_t t = MIXING_STEPPERS; t < MIXING_VIRTUAL_TOOLS; t++)
// 16058         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16059           mixing_virtual_tool_mix[t][i] = (i == 0) ? 1.0 : 0.0;
// 16060     #endif
// 16061 
// 16062     // Initialize mixing to tool 0 color
// 16063     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
// 16064       mixing_factor[i] = mixing_virtual_tool_mix[0][i];
// 16065   #endif
// 16066 
// 16067   //#if ENABLED(BLTOUCH)
// 16068   mksCfg.mkstouch=1;
        MOVS     R0,#+1
        STRB     R0,[R5, #+256]
// 16069   if(MKSTOUCH == 1)
// 16070   {
// 16071     // Make sure any BLTouch error condition is cleared
// 16072     bltouch_command(BLTOUCH_RESET);
        MOVS     R0,#+160
          CFI FunCall _Z15bltouch_commandi
        BL       _Z15bltouch_commandi
// 16073     set_bltouch_deployed(true);
        MOVS     R0,#+1
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 16074     set_bltouch_deployed(false);
        MOVS     R0,#+0
          CFI FunCall _Z20set_bltouch_deployedb
        BL       _Z20set_bltouch_deployedb
// 16075   }
// 16076   //#endif
// 16077 
// 16078   #if ENABLED(I2C_POSITION_ENCODERS)
// 16079     I2CPEM.init();
// 16080   #endif
// 16081 
// 16082   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
// 16083     i2c.onReceive(i2c_on_receive);
// 16084     i2c.onRequest(i2c_on_request);
// 16085   #endif
// 16086 
// 16087   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
// 16088     setup_endstop_interrupts();
// 16089   #endif
// 16090 
// 16091   #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
// 16092     move_extruder_servo(0);  // Initialize extruder servo
// 16093   #endif
// 16094 
// 16095   #if ENABLED(SWITCHING_NOZZLE)
// 16096     move_nozzle_servo(0);  // Initialize nozzle servo
// 16097   #endif
// 16098 
// 16099   #if ENABLED(PARKING_EXTRUDER)
// 16100     #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
// 16101       pe_activate_magnet(0);
// 16102       pe_activate_magnet(1);
// 16103     #else
// 16104       pe_deactivate_magnet(0);
// 16105       pe_deactivate_magnet(1);
// 16106     #endif
// 16107   #endif
// 16108   #if ENABLED(MKS_12864OLED) || ENABLED(MKS_12864OLED_SSD1306)
// 16109     SET_OUTPUT(LCD_PINS_DC);
// 16110     OUT_WRITE(LCD_PINS_RS, LOW);
// 16111     delay(1000);
// 16112     WRITE(LCD_PINS_RS, HIGH);
// 16113   #endif
// 16114     display_hold=0;
        MOVS     R0,#+0
        STRB     R0,[R4, #+8]
// 16115     display_hold_cnt=0;
        STR      R0,[R4, #+44]
// 16116 }
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock94
// 16117 
// 16118 /**
// 16119  * The main Marlin program loop
// 16120  *
// 16121  *  - Save or log commands to SD
// 16122  *  - Process available commands (if not saving)
// 16123  *  - Call heater manager
// 16124  *  - Call inactivity manager
// 16125  *  - Call endstop manager
// 16126  *  - Call LCD update
// 16127  */

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock95 Using cfiCommon0
          CFI Function loop
        THUMB
// 16128 void loop() {
loop:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
// 16129 #if 1
// 16130     //display_sd_error();
// 16131 
// 16132 	display_temper_error();
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
// 16133 	
// 16134 	PowerOff_Filament_Check();
          CFI FunCall _Z23PowerOff_Filament_Checkv
        BL       _Z23PowerOff_Filament_Checkv
// 16135 	
// 16136 	MYSERIAL.MoremenuCmd();
        LDR.W    R0,??DataTable172_4
          CFI FunCall _ZN10USARTClass11MoremenuCmdEv
        BL       _ZN10USARTClass11MoremenuCmdEv
// 16137 
// 16138 #endif
// 16139   if (commands_in_queue < BUFSIZE) get_available_commands();
        LDR.W    R4,??DataTable172
        LDRB     R0,[R4, #+6]
        CMP      R0,#+4
        IT       LT 
          CFI FunCall _Z22get_available_commandsv
        BLLT     _Z22get_available_commandsv
// 16140 
// 16141   #if 0//ENABLED(SDSUPPORT)
// 16142     card.checkautostart(false);
// 16143   #endif
// 16144   card.checkFilesys(gCfgItems.fileSysType);
        LDR.W    R0,??DataTable172_9
        LDR.W    R5,??DataTable172_14
        LDRB     R1,[R0, #+202]
        MOV      R0,R5
          CFI FunCall _ZN10CardReader12checkFilesysEh
        BL       _ZN10CardReader12checkFilesysEh
// 16145 
// 16146   if (commands_in_queue) {
        LDRB     R0,[R4, #+6]
        CBZ.N    R0,??loop_0
// 16147 
// 16148     #if ENABLED(SDSUPPORT)
// 16149 
// 16150       if (card.saving) {
        LDRB     R0,[R5, #+1889]
        CBZ.N    R0,??loop_1
// 16151         char* command = command_queue[cmd_queue_index_r];
        LDRB     R0,[R4, #+7]
        ADD      R1,R0,R0, LSL #+1
        LDR.W    R0,??DataTable174_1
        ADD      R6,R0,R1, LSL #+5
// 16152         if (strstr_P(command, PSTR("M29"))) {
        ADR.N    R1,??DataTable170_1  ;; "M29"
        MOV      R0,R6
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CBZ.N    R0,??loop_2
// 16153           // M29 closes the file
// 16154           card.closefile();
        MOVS     R1,#+0
        MOV      R0,R5
          CFI FunCall _ZN10CardReader9closefileEb
        BL       _ZN10CardReader9closefileEb
// 16155           SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
        LDR.W    R0,??DataTable175_2
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
// 16156 
// 16157           #if ENABLED(SERIAL_STATS_DROPPED_RX)
// 16158             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
// 16159           #endif
// 16160 
// 16161           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
// 16162             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
// 16163           #endif
// 16164 
// 16165           ok_to_send();
        B.N      ??loop_3
// 16166         }
// 16167         else {
// 16168           // Write the string from the read buffer to SD
// 16169           card.write_command(command);
??loop_2:
        MOV      R1,R6
        MOV      R0,R5
          CFI FunCall _ZN10CardReader13write_commandEPc
        BL       _ZN10CardReader13write_commandEPc
// 16170           if (card.logging)
        LDRB     R0,[R5, #+1890]
        CBNZ.N   R0,??loop_1
// 16171             process_next_command(); // The card is saving because it's logging
// 16172           else
// 16173             ok_to_send();
??loop_3:
          CFI FunCall _Z10ok_to_sendv
        BL       _Z10ok_to_sendv
        B.N      ??loop_4
// 16174         }
// 16175       }
// 16176       else
// 16177         process_next_command();
??loop_1:
          CFI FunCall _Z20process_next_commandv
        BL       _Z20process_next_commandv
// 16178 
// 16179     #else
// 16180 
// 16181       process_next_command();
// 16182 
// 16183     #endif // SDSUPPORT
// 16184 
// 16185     // The queue may be reset by a command handler or by code invoked by idle() within a handler
// 16186     if (commands_in_queue) {
??loop_4:
        LDRB     R0,[R4, #+6]
        CBZ.N    R0,??loop_0
// 16187       --commands_in_queue;
        SUBS     R0,R0,#+1
        STRB     R0,[R4, #+6]
// 16188       if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
        LDRB     R0,[R4, #+7]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+7]
        UXTB     R0,R0
        CMP      R0,#+4
        ITT      GE 
        MOVGE    R0,#+0
        STRBGE   R0,[R4, #+7]
// 16189     }
// 16190   }
// 16191   endstops.report_state();
??loop_0:
          CFI FunCall _ZN8Endstops12report_stateEv
        BL       _ZN8Endstops12report_stateEv
// 16192   idle();
          CFI FunCall _Z4idlev
        BL       _Z4idlev
// 16193   loop_start=1;
        LDR.W    R1,??DataTable176
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
// 16194   
// 16195   mks_PrintStatePolling();
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall mks_PrintStatePolling
        B.W      mks_PrintStatePolling
          CFI EndBlock cfiBlock95
// 16196 }
// 16197 #if 1
// 16198 uint16_t z_high_count;
// 16199 
// 16200 extern uint8_t poweroff_det_flg;
// 16201 extern uint32_t poweroff_det_cnt;
// 16202 extern uint8_t poweroff_det_low_flg;
// 16203 extern uint32_t poweroff_det_low_cnt;
// 16204 extern uint8_t poweroff_det_high_flg;
// 16205 extern uint32_t poweroff_det_high_cnt;
// 16206 
// 16207 extern uint8_t filament_det1_flg;
// 16208 extern uint32_t filament_det1_cnt;
// 16209 extern uint8_t filament_det1_low_flg;
// 16210 extern uint32_t filament_det1_low_cnt;
// 16211 extern uint8_t filament_det1_high_flg;
// 16212 extern uint32_t filament_det1_high_cnt;
// 16213 extern uint8_t filament_det1_check;
// 16214 
// 16215 extern uint8_t filament_det2_flg;
// 16216 extern uint32_t filament_det2_cnt;
// 16217 extern uint8_t filament_det2_low_flg;
// 16218 extern uint32_t filament_det2_low_cnt;
// 16219 extern uint8_t filament_det2_high_flg;
// 16220 extern uint32_t filament_det2_high_cnt;
// 16221 extern uint8_t filament_det2_check;
// 16222 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// 16223 uint32_t wifi_loop_cycle = 500;
wifi_loop_cycle:
        DATA
        DC32 500
// 16224 extern char wifi_check_time;
// 16225 uint8_t wifi_init_flg = 0;
// 16226 uint8_t wifi_init_state = 0;
// 16227 uint8_t wifi_refresh_flg = 0, cloud_refresh_flg = 0;
// 16228 uint8_t waiting_wifi_time = 0;
// 16229 
// 16230 uint8_t beep_flg = 0;
// 16231 uint32_t beep_cnt = 0;
// 16232 
// 16233 extern volatile uint8_t has_adjust_speed;
// 16234 extern volatile uint16_t resume_printed_time;
// 16235 
// 16236 extern uint8_t print_finish_start_timer;
// 16237 extern uint32_t print_finish_timer_count;
// 16238 extern uint8_t print_finish_close_machine;
// 16239 
// 16240 #if 0
// 16241 uint8_t btn_flg = 0;
// 16242 uint32_t btn_beep_cnt = 0;
// 16243 #endif
// 16244 extern void mksBeeperAlarm(void);
// 16245 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock96 Using cfiCommon0
          CFI Function _Z6Beeperj
          CFI NoCalls
        THUMB
// 16246 void Beeper(uint32_t cnt)
// 16247 {
// 16248     beep_flg = 1;
_Z6Beeperj:
        LDR.W    R1,??DataTable173
        MOVS     R2,#+1
        STRB     R2,[R1, #+14]
// 16249     beep_cnt = cnt;
        STR      R0,[R1, #+48]
// 16250     BEEPER_OP = 1;
        LDR.W    R1,??DataTable176_1  ;; 0x42220194
        STR      R2,[R1, #+0]
// 16251 }
        BX       LR               ;; return
          CFI EndBlock cfiBlock96

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_1:
        DC8      "M29"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_2:
        DC32     0x54442d18

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_3:
        DC32     0x401921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_4:
        DC32     0xc01921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_5:
        DC32     0x40c90fdb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_6:
        DC32     0x3a83126f

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_7:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_8:
        DC32     0x3ff00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_9:
        DC32     axis_relative_modes+0x20

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_10:
        DC32     0x400921fb

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_11:
        DC32     0x40668000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable170_12:
        DC32     0x4062c000
// 16252 

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock97 Using cfiCommon0
          CFI Function _Z20SysTick_Handler_Userv
        THUMB
// 16253 void SysTick_Handler_User()
// 16254 {
_Z20SysTick_Handler_Userv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
// 16255 		TimeIncrease++;
        LDR.W    R4,??DataTable173
        LDR      R0,[R4, #+40]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+40]
// 16256 
// 16257 
// 16258 		if(filament_loading_time_flg == 1)
        MOV      R5,#+1000
        LDRB     R0,[R4, #+0]
        LDR      R6,[R4, #+32]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_0
// 16259 		{
// 16260 			filament_loading_time_cnt++;
// 16261 			filament_rate = (uint32_t)(((filament_loading_time_cnt/(gCfgItems.filament_loading_time*1000.0))*100.0)+0.5);
        LDR.W    R0,??DataTable172_9
        LDR      R7,[R0, #+260]
        ADDS     R6,R6,#+1
        MOV      R0,R6
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R8,R0
        MOV      R9,R1
        MOV      R0,R7
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable175_3  ;; 0x408f4000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable175_4  ;; 0x40590000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R3,??DataTable175_5  ;; 0x3fe00000
        MOVS     R2,#+0
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        LDR.W    R1,??DataTable175_6
        STR      R0,[R1, #+0]
// 16262 			if(filament_loading_time_cnt >= (gCfgItems.filament_loading_time*1000))
        MUL      R0,R5,R7
        CMP      R6,R0
        BCC.N    ??SysTick_Handler_User_0
// 16263 			{
// 16264 				filament_loading_time_cnt = 0;
        MOVS     R6,#+0
// 16265 				filament_loading_time_flg = 0;
// 16266 				filament_loading_completed = 1;
        MOVS     R0,#+1
        STRB     R6,[R4, #+0]
        STRB     R0,[R4, #+1]
??SysTick_Handler_User_0:
        STR      R6,[R4, #+32]
// 16267 			}
// 16268 		}
// 16269 		if(filament_unloading_time_flg == 1)
        LDRB     R0,[R4, #+2]
        LDR      R6,[R4, #+36]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_1
// 16270 		{
// 16271 			filament_unloading_time_cnt++;
// 16272 			filament_rate = (uint32_t)(((filament_unloading_time_cnt/(gCfgItems.filament_unloading_time*1000.0))*100.0)+0.5);
        LDR.W    R0,??DataTable172_9
        LDR.W    R7,??DataTable175_6
        ADD      R0,R0,#+260
        ADDS     R6,R6,#+1
        LDR      R8,[R0, #+4]
        MOV      R0,R6
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOV      R10,R0
        MOV      R11,R1
        MOV      R0,R8
          CFI FunCall __aeabi_ui2d
        BL       __aeabi_ui2d
        MOVS     R2,#+0
        LDR.W    R3,??DataTable175_3  ;; 0x408f4000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOVS     R2,#+0
        LDR.W    R3,??DataTable175_4  ;; 0x40590000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.W    R3,??DataTable175_5  ;; 0x3fe00000
        MOVS     R2,#+0
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall __aeabi_d2uiz
        BL       __aeabi_d2uiz
        STR      R0,[R7, #+0]
// 16273 			if(filament_unloading_time_cnt >= (gCfgItems.filament_unloading_time*1000))
        MUL      R0,R5,R8
        CMP      R6,R0
        BCC.N    ??SysTick_Handler_User_1
// 16274 			{
// 16275 				filament_unloading_time_cnt = 0;
// 16276 				filament_unloading_time_flg = 0;
// 16277 				filament_unloading_completed = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+3]
        MOVS     R6,#+0
// 16278 				filament_rate = 100;
        MOVS     R0,#+100
        STRB     R6,[R4, #+2]
        STR      R0,[R7, #+0]
??SysTick_Handler_User_1:
        STR      R6,[R4, #+36]
// 16279 			}
// 16280 		}	
// 16281 	
// 16282 		temperature_change_frequency_cnt++;
        LDR      R0,[R4, #+28]
        ADDS     R0,R0,#+1
// 16283 		if((temperature_change_frequency_cnt>=2000)&&(temperature_change_frequency!=1))
        CMP      R0,#+2000
        BCC.N    ??SysTick_Handler_User_2
        LDR.W    R1,??DataTable176_2
        LDRB     R2,[R1, #+0]
        CMP      R2,#+1
        BEQ.N    ??SysTick_Handler_User_2
// 16284 		{
// 16285 			temperature_change_frequency_cnt = 0;
// 16286 			temperature_change_frequency = 1;
        MOVS     R2,#+1
        MOVS     R0,#+0
        STRB     R2,[R1, #+0]
??SysTick_Handler_User_2:
        STR      R0,[R4, #+28]
// 16287 		}
// 16288 		
// 16289 		if(!(TimeIncrease * TICK_CYCLE % 3000))	// 3s
        MOVW     R1,#+3000
        LDR      R0,[R4, #+40]
        UDIV     R1,R0,R1
        MOVW     R2,#+3000
        MLS      R0,R2,R1,R0
        CBNZ.N   R0,??SysTick_Handler_User_3
// 16290 		{		
// 16291 			printing_rate_update_flag = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+4]
// 16292 		}	
// 16293 
// 16294 		if((TimeIncrease * TICK_CYCLE % 1000) == 0) 
??SysTick_Handler_User_3:
        MOV      R1,R5
        LDR      R0,[R4, #+40]
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CBNZ.N   R0,??SysTick_Handler_User_4
// 16295 		{		
// 16296 			if(print_time.start == 1)
        LDR.W    R0,??DataTable176_3
        LDRSB    R1,[R0, #+7]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_5
// 16297 			{
// 16298 				print_time.seconds++;
        LDRB     R1,[R0, #+5]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+5]
// 16299 			}
// 16300 			display_hold_cnt++;
??SysTick_Handler_User_5:
        LDR      R0,[R4, #+44]
        ADDS     R0,R0,#+1
        STR      R0,[R4, #+44]
// 16301 		}
// 16302 		if((TimeIncrease * TICK_CYCLE % 1000) == 0)
??SysTick_Handler_User_4:
        MOV      R1,R5
        LDR      R0,[R4, #+40]
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CBNZ.N   R0,??SysTick_Handler_User_6
// 16303 		{
// 16304 			z_high_count=1;
        MOVS     R0,#+1
        STRH     R0,[R4, #+24]
// 16305 		}
// 16306 
// 16307 	if(poweroff_det_flg==1)
??SysTick_Handler_User_6:
        LDR.W    R0,??DataTable176_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_7
// 16308 	{
// 16309 		poweroff_det_cnt++;
        LDR.W    R0,??DataTable176_5
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16310 	}
// 16311 		
// 16312 	if(filament_det1_flg==1)
??SysTick_Handler_User_7:
        LDR.W    R0,??DataTable176_6
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_8
// 16313 	{
// 16314 		filament_det1_cnt++;
        LDR.W    R0,??DataTable176_7
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16315 	}
// 16316 
// 16317 	if(filament_det1_low_flg==1)
??SysTick_Handler_User_8:
        LDR.W    R0,??DataTable176_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_9
// 16318 	{
// 16319 		filament_det1_low_cnt++;
        LDR.W    R0,??DataTable176_9
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16320 	}
// 16321 
// 16322 	if(filament_det1_high_flg==1)
??SysTick_Handler_User_9:
        LDR.W    R0,??DataTable176_10
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_10
// 16323 	{
// 16324 		filament_det1_high_cnt++;
        LDR.W    R0,??DataTable176_11
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16325 	}
// 16326 	if(filament_det2_flg==1)
??SysTick_Handler_User_10:
        LDR.W    R0,??DataTable177
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_11
// 16327 	{
// 16328 		filament_det2_cnt++;
        LDR.W    R0,??DataTable177_1
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16329 	}
// 16330 
// 16331 	if(filament_det2_low_flg==1)
??SysTick_Handler_User_11:
        LDR.W    R0,??DataTable177_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_12
// 16332 	{
// 16333 		filament_det2_low_cnt++;
        LDR.W    R0,??DataTable177_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16334 	}
// 16335 
// 16336 	if(filament_det2_high_flg==1)
??SysTick_Handler_User_12:
        LDR.W    R0,??DataTable178
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_13
// 16337 	{
// 16338 		filament_det2_high_cnt++;
        LDR.W    R0,??DataTable178_1
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16339 	}
// 16340 
// 16341 	if(poweroff_det_low_flg==1)
??SysTick_Handler_User_13:
        LDR.W    R0,??DataTable178_2
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_14
// 16342 	{
// 16343 		poweroff_det_low_cnt++;
        LDR.W    R0,??DataTable178_3
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16344 	}
// 16345 	
// 16346 	if(poweroff_det_high_flg==1)
??SysTick_Handler_User_14:
        LDR.W    R0,??DataTable178_4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_15
// 16347 	{
// 16348 		poweroff_det_high_cnt++;
        LDR.W    R0,??DataTable178_5
        LDR      R1,[R0, #+0]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+0]
// 16349 	}		
// 16350 
// 16351 	if(!(TimeIncrease * TICK_CYCLE % 5000))	//5s
??SysTick_Handler_User_15:
        MOVW     R1,#+5000
        LDR      R0,[R4, #+40]
        UDIV     R1,R0,R1
        MOVW     R2,#+5000
        MLS      R0,R2,R1,R0
        CBNZ.N   R0,??SysTick_Handler_User_16
// 16352 	{
// 16353 		wifi_check_time = 1;
        LDR.W    R1,??DataTable178_6
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
// 16354 		waiting_wifi_time ++;
        LDRB     R0,[R4, #+13]
        ADDS     R0,R0,#+1
        STRB     R0,[R4, #+13]
// 16355 		if((waiting_wifi_time == 8) || (gCfgItems.wifi_type == ESP_WIFI))//40s
        UXTB     R0,R0
        CMP      R0,#+8
        ITTT     NE 
        LDRNE.W  R0,??DataTable172_9
        LDRBNE   R0,[R0, #+572]
        CMPNE    R0,#+2
        BNE.N    ??SysTick_Handler_User_17
// 16356 		{
// 16357 			if(wifi_init_flg == 0)
        LDRB     R0,[R4, #+10]
        CBNZ.N   R0,??SysTick_Handler_User_17
// 16358 			{
// 16359 				wifi_init_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+10]
// 16360 			}
// 16361 			
// 16362 		}
// 16363 		if(wifi_refresh_flg == 0)
??SysTick_Handler_User_17:
        LDRB     R0,[R4, #+11]
        CBNZ.N   R0,??SysTick_Handler_User_18
// 16364 			wifi_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+11]
// 16365 		
// 16366 		if(cloud_refresh_flg == 0)
??SysTick_Handler_User_18:
        LDRB     R0,[R4, #+12]
        CBNZ.N   R0,??SysTick_Handler_User_16
// 16367 			cloud_refresh_flg = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
// 16368 
// 16369 	}
// 16370 	
// 16371 
// 16372 	mksBeeperAlarm();
??SysTick_Handler_User_16:
          CFI FunCall _Z14mksBeeperAlarmv
        BL       _Z14mksBeeperAlarmv
// 16373 
// 16374     if(beep_flg == 1)
        LDRB     R0,[R4, #+14]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_19
// 16375     {
// 16376         beep_cnt--;
        LDR      R0,[R4, #+48]
        SUBS     R0,R0,#+1
        STR      R0,[R4, #+48]
// 16377         if(beep_cnt<=0)
        BNE.N    ??SysTick_Handler_User_19
// 16378         {
// 16379            beep_flg = 0;
        STRB     R0,[R4, #+14]
// 16380            BEEPER_OP = 0; 
        LDR.W    R1,??DataTable176_1  ;; 0x42220194
        STR      R0,[R1, #+0]
// 16381         }
// 16382     }  
// 16383 	if(key_value_calc.timer == TIMER_START)
??SysTick_Handler_User_19:
        LDR.W    R0,??DataTable179
        LDRB     R1,[R0, #+37]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_20
// 16384 	{
// 16385 		key_value_calc.timer_count++;
        LDR      R1,[R0, #+40]
        ADDS     R1,R1,#+1
        STR      R1,[R0, #+40]
// 16386 	}
// 16387 	if(((TimeIncrease * TICK_CYCLE % 1000) == 0) )
??SysTick_Handler_User_20:
        MOV      R1,R5
        LDR      R0,[R4, #+40]
        UDIV     R1,R0,R1
        MLS      R0,R5,R1,R0
        CMP      R0,#+0
        ITTT     EQ 
// 16388 	{		
// 16389 		if(tips_disp.timer == TIPS_TIMER_START)
        LDREQ.W  R0,??DataTable179_1
        LDRBEQ   R1,[R0, #+0]
        CMPEQ    R1,#+1
        BNE.N    ??SysTick_Handler_User_21
// 16390 		{
// 16391 			tips_disp.timer_count++;
        LDRB     R1,[R0, #+1]
        ADDS     R1,R1,#+1
        STRB     R1,[R0, #+1]
// 16392 		}
// 16393 	}
// 16394 #if 0
// 16395     if(btn_flg == 1)
// 16396     {
// 16397         btn_beep_cnt--;
// 16398         if(btn_beep_cnt<=0)
// 16399         {
// 16400            btn_flg = 0;
// 16401            BEEPER_OP = 0; 
// 16402         }
// 16403     }
// 16404     #endif
// 16405 	if(has_adjust_speed==1)resume_printed_time++;
??SysTick_Handler_User_21:
        LDRB     R0,[R4, #+15]
        CMP      R0,#+1
        BNE.N    ??SysTick_Handler_User_22
        LDRH     R0,[R4, #+26]
        ADDS     R0,R0,#+1
        STRH     R0,[R4, #+26]
// 16406 
// 16407 	if(print_finish_start_timer==TIMER_START)
??SysTick_Handler_User_22:
        LDRB     R1,[R4, #+16]
        LDR      R0,[R4, #+52]
        CMP      R1,#+1
        BNE.N    ??SysTick_Handler_User_23
// 16408 	{
// 16409 		print_finish_timer_count++;
// 16410 		if(print_finish_timer_count>=(gCfgItems.print_finish_count*1000))
        LDR.N    R1,??DataTable172_9
        LDRH     R1,[R1, #+702]
        ADDS     R0,R0,#+1
        MULS     R1,R5,R1
        CMP      R0,R1
        BCC.N    ??SysTick_Handler_User_23
// 16411 		{
// 16412 			print_finish_start_timer=TIMER_STOP;
        MOVS     R0,#+0
// 16413 			print_finish_timer_count=0;
// 16414 			print_finish_close_machine=true;
        MOVS     R1,#+1
        STRB     R0,[R4, #+16]
        STRB     R1,[R4, #+17]
??SysTick_Handler_User_23:
        STR      R0,[R4, #+52]
// 16415 		}
// 16416 	}
// 16417 }
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock97

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171:
        DC32     axis_relative_modes+0x10

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_1:
        DC32     0x42c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_2:
        DC32     0xc2600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_3:
        DC32     0xc2c80000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_4:
        DC32     0x42600000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_5:
        DC32     home_dir_P

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_6:
        DC32     0xbf800000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_7:
        DC32     0x43160000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_8:
        DC32     axis_homed

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_9:
        DC32     gArrayGpioPort

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_10:
        DC32     gArrayGpioPin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable171_11:
        DC32     mksCfg
// 16418 #endif
// 16419 
// 16420 #include "mks_reprint.cpp"

        SECTION `.data`:DATA:REORDER:NOROOT(2)
// __absolute char *mks_pft_name
mks_pft_name:
        DATA
        DC32 `?<Constant "mks_pft.sys">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock98 Using cfiCommon0
          CFI Function mkstft_ui_load
        THUMB
// __interwork __softfp void mkstft_ui_load()
mkstft_ui_load:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??DataTable172_9
        MOVS     R2,#+4
        ADD      R1,R4,#+20
        MOVW     R0,#+1694
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+24
        MOVW     R0,#+1698
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+32
        MOVW     R0,#+1706
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+40
        MOVW     R0,#+1710
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+36
        MOVW     R0,#+1714
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+52
        MOVW     R0,#+1718
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+56
        MOVW     R0,#+1722
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+60
        MOVW     R0,#+1726
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+64
        MOVW     R0,#+1730
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+76
        MOVW     R0,#+1734
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+80
        MOVW     R0,#+1738
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+68
        MOVW     R0,#+1742
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+72
        MOVW     R0,#+1746
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+100
        MOVW     R0,#+1750
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+104
        MOVW     R0,#+1754
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+463
        MOVW     R0,#+1758
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+200
        MOVW     R0,#+1759
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+228
        MOVW     R0,#+1794
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+244
        MOV      R0,#+1768
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+236
        MOVW     R0,#+1772
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+252
        MOV      R0,#+1776
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+248
        MOVW     R0,#+1780
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+240
        MOV      R0,#+1784
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+256
        MOVW     R0,#+1788
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+229
        MOVW     R0,#+1793
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+677
        MOVW     R0,#+1797
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+460
        MOVW     R0,#+1799
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+221
        MOV      R0,#+1800
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+461
        MOVW     R0,#+1801
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+462
        MOVW     R0,#+1802
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+474
        MOVW     R0,#+1803
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+268
        MOVW     R0,#+1804
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+269
        MOVW     R0,#+1805
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+270
        MOVW     R0,#+1806
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+272
        MOV      R0,#+1808
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+274
        MOVW     R0,#+1810
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+276
        MOVW     R0,#+1812
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+278
        MOVW     R0,#+1814
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+280
        MOV      R0,#+1816
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+282
        MOVW     R0,#+1818
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+284
        MOVW     R0,#+1820
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+286
        MOVW     R0,#+1822
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+288
        MOV      R0,#+1824
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+233
        MOVW     R0,#+1826
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+573
        MOVW     R0,#+1827
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+684
        MOVW     R0,#+1841
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+685
        MOVW     R0,#+1836
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+686
        MOVW     R0,#+1837
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+687
        MOVW     R0,#+1838
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+688
        MOVW     R0,#+1839
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+690
        MOVW     R0,#+1842
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADD      R1,R4,#+692
        MOVW     R0,#+1843
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+696
        MOVW     R0,#+1844
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADD      R1,R4,#+700
        MOV      R0,#+1848
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADDW     R1,R4,#+702
        MOVW     R0,#+1850
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR      R0,[R4, #+20]
          CFI FunCall rgb888_2_rgb565
        BL       rgb888_2_rgb565
        STRH     R0,[R4, #+704]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock98

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_1:
        DC32     errormagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_2:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_3:
        DC32     `?<Constant "KILL caused by too mu...">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_4:
        DC32     Serial3

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_5:
        DC32     `?<Constant "KILLED. ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_6:
        DC32     stepper_inactive_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_7:
        DC32     _ZN7Planner17block_buffer_headE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_8:
        DC32     _ZN7Planner17block_buffer_tailE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_9:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_10:
        DC32     GUI_FontHZ16

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_11:
        DC32     GUI_FontHZ_fontHz14

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_12:
        DC32     disp_state_stack

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_13:
        DC32     button_disp_pause_state

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_14:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_15:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable172_16:
        DC32     wifi_link_state

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock99 Using cfiCommon0
          CFI Function _Z17mkstft_ui_set_eprv
        THUMB
// __interwork __softfp void mkstft_ui_set_epr()
_Z17mkstft_ui_set_eprv:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+8
          CFI CFA R13+24
        MOVW     R4,#+1450
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR      R0,[SP, #+0]
        LDR.W    R5,??DataTable180  ;; 0x76313030
        CMP      R0,R5
        BEQ.W    ??mkstft_ui_set_epr_0
        LDR.W    R6,??DataTable184
        MOVS     R2,#+4
        ADD      R1,R6,#+20
        MOVW     R0,#+1694
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+24
        MOVW     R0,#+1698
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+32
        MOVW     R0,#+1706
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+40
        MOVW     R0,#+1710
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+36
        MOVW     R0,#+1714
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+52
        MOVW     R0,#+1718
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+56
        MOVW     R0,#+1722
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+60
        MOVW     R0,#+1726
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+64
        MOVW     R0,#+1730
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+76
        MOVW     R0,#+1734
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+80
        MOVW     R0,#+1738
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+68
        MOVW     R0,#+1742
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+72
        MOVW     R0,#+1746
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+100
        MOVW     R0,#+1750
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+104
        MOVW     R0,#+1754
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+463
        MOVW     R0,#+1758
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+200
        MOVW     R0,#+1759
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+228
        MOVW     R0,#+1794
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+244
        MOV      R0,#+1768
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+236
        MOVW     R0,#+1772
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+252
        MOV      R0,#+1776
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+248
        MOVW     R0,#+1780
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+240
        MOV      R0,#+1784
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+256
        MOVW     R0,#+1788
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+229
        MOVW     R0,#+1793
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+677
        MOVW     R0,#+1797
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+460
        MOVW     R0,#+1799
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+221
        MOV      R0,#+1800
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+461
        MOVW     R0,#+1801
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+462
        MOVW     R0,#+1802
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+474
        MOVW     R0,#+1803
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+268
        MOVW     R0,#+1804
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+269
        MOVW     R0,#+1805
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+270
        MOVW     R0,#+1806
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+272
        MOV      R0,#+1808
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+274
        MOVW     R0,#+1810
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+276
        MOVW     R0,#+1812
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+278
        MOVW     R0,#+1814
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+280
        MOV      R0,#+1816
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+282
        MOVW     R0,#+1818
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+284
        MOVW     R0,#+1820
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+286
        MOVW     R0,#+1822
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+288
        MOV      R0,#+1824
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+233
        MOVW     R0,#+1826
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+573
        MOVW     R0,#+1827
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+684
        MOVW     R0,#+1841
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+685
        MOVW     R0,#+1836
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+686
        MOVW     R0,#+1837
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+687
        MOVW     R0,#+1838
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+688
        MOVW     R0,#+1839
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R6,#+690
        MOVW     R0,#+1842
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADD      R1,R6,#+692
        MOVW     R0,#+1843
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R6,#+696
        MOVW     R0,#+1844
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADD      R1,R6,#+700
        MOV      R0,#+1848
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+2
        ADDW     R1,R6,#+702
        MOVW     R0,#+1850
          CFI FunCall epr_write_data
        BL       epr_write_data
        STR      R5,[SP, #+0]
        MOVS     R2,#+4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall epr_write_data
        BL       epr_write_data
??mkstft_ui_set_epr_0:
        POP      {R0,R1,R4-R6,PC}  ;; return
          CFI EndBlock cfiBlock99

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_1:
        DC32     `?<Constant "Printer halted. kill(...">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_2:
        DC32     temper_error_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_3:
        DC32     `?<Constant "MKS Robin Nano">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_4:
        DC32     `?<Constant "1.0.0\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_5:
        DC32     echomagic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_6:
        DC32     `?<Constant " Last Updated: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_7:
        DC32     `?<Constant "2017-12-25 12:00">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_8:
        DC32     `?<Constant " | Author: (none, def...">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_9:
        DC32     `?<Constant "Compiled: Apr 13 2020\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_10:
        DC32     `?<Constant " Free Memory: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_11:
        DC32     `?<Constant "  PlannerBufferBytes: ">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable173_12:
        DC32     thermalManager

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock100 Using cfiCommon0
          CFI Function mkstft_ui_init
        THUMB
// __interwork __softfp void mkstft_ui_init()
mkstft_ui_init:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.W    R4,??DataTable184
        LDR.W    R3,??DataTable185  ;; 0x494949
        ADDS     R1,R4,#+4
        MOVS     R2,#+0
        STR      R2,[R1, #+4]
        MVN      R0,#-16777216
        LDR.W    R2,??DataTable186_1  ;; 0xff5449
        STR      R2,[R1, #+8]
        STR      R2,[R1, #+72]
        STR      R3,[R1, #+16]
        MOV      R2,#+65280
        STR      R2,[R1, #+80]
        STR      R0,[R4, #+4]
        STR      R0,[R1, #+12]
        STR      R0,[R1, #+20]
        STR      R0,[R1, #+28]
        STR      R0,[R1, #+52]
        STR      R0,[R1, #+60]
        STR      R0,[R1, #+68]
        STR      R0,[R1, #+76]
        STR      R0,[R1, #+100]
        STR      R0,[R1, #+108]
        MOVS     R0,#+1
        LDR.W    R2,??DataTable186_2  ;; 0xaaaaaa
        LDR.W    R3,??DataTable186_3  ;; 0x1a1a1a
        STR      R2,[R1, #+84]
        STR      R3,[R1, #+24]
        MOVS     R2,#+0
        STR      R2,[R1, #+88]
        STR      R2,[R1, #+92]
        STR      R3,[R1, #+48]
        MOV      R2,#+16711680
        STR      R2,[R1, #+96]
        STR      R3,[R1, #+56]
        MOVS     R2,#+0
        STR      R3,[R1, #+64]
        STR      R2,[R1, #+104]
        STRB     R0,[R4, #+463]
        ADD      R1,R4,#+172
        MOVS     R0,#+3
        STRB     R0,[R1, #+28]
        ADDW     R6,R4,#+221
        MOVS     R0,#+1
        STRB     R0,[R1, #+30]
        MOVS     R0,#+10
        STRB     R0,[R1, #+3]
        STRB     R2,[R4, #+172]
        MOV      R0,#+1065353216
        STR      R0,[R1, #+24]
        MOVS     R2,#+1
        MOVW     R0,#+3000
        STRH     R0,[R1, #+18]
        STRB     R2,[R1, #+16]
        MOVS     R2,#+5
        STRB     R2,[R1, #+15]
        STRB     R2,[R1, #+14]
        MOVS     R2,#+100
        STRH     R2,[R1, #+8]
        STRH     R2,[R1, #+10]
        MOVS     R1,#+0
        STRB     R1,[R4, #+268]
        MOVS     R2,#+4
        ADD      R1,R4,#+268
        STRB     R2,[R1, #+1]
        MOVS     R2,#+50
        STRH     R2,[R1, #+2]
        STRH     R2,[R1, #+4]
        MOVS     R2,#+180
        STRH     R2,[R1, #+6]
        MOVS     R2,#+50
        STRH     R2,[R1, #+8]
        MOVS     R2,#+180
        STRH     R2,[R1, #+10]
        STRH     R2,[R1, #+12]
        MOVS     R2,#+50
        STRH     R2,[R1, #+14]
        MOVS     R2,#+180
        STRH     R2,[R1, #+16]
        STR      R0,[R1, #+28]
        MOVS     R2,#+6
        MOVW     R0,#+1500
        STR      R0,[R1, #+24]
        MOVS     R1,#+0
        ADDW     R0,R4,#+431
        STRB     R1,[R0, #+29]
        STRB     R1,[R4, #+221]
        STRB     R1,[R0, #+30]
        STRB     R1,[R0, #+31]
        STRB     R1,[R4, #+474]
        STRB     R1,[R6, #+12]
        ADD      R0,R4,#+368
        LDR.W    R1,??DataTable187_1
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR.W    R8,??DataTable187_2
        MOVS     R0,#+1
        STRB     R0,[R4, #+313]
        MOVS     R1,#+200
        ADD      R0,R4,#+236
        MOV      R5,#+1000
        STR      R1,[R0, #+16]
        STR      R5,[R0, #+4]
        MOVS     R1,#+100
        STR      R1,[R0, #+8]
        STR      R5,[R4, #+236]
        MOVS     R1,#+200
        STR      R1,[R0, #+20]
        MOVS     R2,#+0
        MOVS     R1,#+100
        STR      R1,[R0, #+12]
        MOVS     R0,#+0
        STRB     R0,[R6, #+7]
        MOVS     R1,#+108
        MOVS     R0,#+1
        STRB     R0,[R6, #+8]
        STRB     R0,[R4, #+571]
        MOV      R0,R8
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.W    R6,??DataTable188
        MOVS     R2,#+0
        MOVS     R1,#+162
        MOV      R0,R6
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R7,#+12
        MOVS     R2,#+12
        LDR.W    R1,??DataTable188_1
        MOV      R0,R8
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R2,#+10
        LDR.W    R1,??DataTable188_2
        ADD      R0,R8,#+32
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        LDR.W    R8,??DataTable188_3
        MOV      R9,#+14
        MOV      R2,R9
        MOV      R1,R8
        ADDS     R0,R6,#+1
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR.W    R10,??DataTable188_4
        MOV      R2,R9
        MOV      R1,R10
        ADD      R0,R6,#+17
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDR.W    R11,??DataTable188_5
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+33
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+49
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+0]
        MOV      R2,R9
        MOV      R1,R8
        ADD      R0,R6,#+66
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R9
        MOV      R1,R10
        ADD      R0,R6,#+82
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+98
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+114
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R7
        MOV      R1,R11
        ADD      R0,R6,#+130
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R9
        LDR.W    R1,??DataTable189
        ADD      R0,R6,#+146
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R0,#+1
        STRB     R0,[R6, #+65]
        ADDW     R6,R4,#+571
        MOVS     R0,#+2
        STRB     R0,[R6, #+1]
        MOVS     R2,#+15
        LDR.W    R1,??DataTable189_1
        ADDW     R0,R4,#+574
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVW     R0,#+10086
        STR      R0,[R4, #+672]
        MOVS     R1,#+23
        MOVS     R0,#+1
        STRB     R0,[R6, #+2]
        ADD      R0,R4,#+672
        STRB     R1,[R0, #+4]
        MOVS     R1,#+0
        STRB     R1,[R0, #+5]
        STRB     R1,[R4, #+431]
        STRB     R1,[R4, #+344]
        STRB     R1,[R4, #+357]
        STRB     R1,[R0, #+12]
        STRB     R1,[R0, #+13]
        STRB     R1,[R0, #+14]
        STRB     R1,[R0, #+15]
        STRH     R5,[R0, #+16]
        STRB     R1,[R0, #+18]
        STRB     R1,[R0, #+19]
        STRB     R1,[R0, #+20]
        STR      R1,[R0, #+24]
        MOVS     R1,#+5
        STRH     R1,[R0, #+28]
        MOVS     R1,#+180
        STRH     R1,[R0, #+30]
          CFI FunCall _Z17mkstft_ui_set_eprv
        BL       _Z17mkstft_ui_set_eprv
        MOVS     R0,#+0
        LDR.W    R1,??DataTable189_2
        STRB     R0,[R1, #+0]
        LDR.W    R1,??DataTable193
        STRB     R0,[R1, #+0]
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock100

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174:
        DC32     `?<Constant "Err%d">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable174_1:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock101 Using cfiCommon0
          CFI Function mks_initPrint
        THUMB
// __interwork __softfp void mks_initPrint()
mks_initPrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R0,??DataTable189_3
        LDR.W    R4,??DataTable189_4
        LDR      R1,[R0, #+212]
        STR      R1,[R4, #+2016]
        ADDS     R0,R0,#+212
        ADDW     R1,R4,#+2016
        LDR      R2,[R0, #+4]
        LDR      R0,[R0, #+8]
        STR      R0,[R1, #+8]
        ADDW     R5,R4,#+2068
        LDR.W    R0,??DataTable193_2  ;; 0x40a00000
        STR      R0,[R1, #+12]
        STR      R2,[R1, #+4]
        MOVS     R0,#+0
        STR      R0,[R1, #+16]
        MOVS     R2,#+0
        MOVS     R0,#+166
        STRB     R0,[R4, #+2068]
        MOVS     R1,#+20
        MOVS     R0,#+0
        STR      R0,[R5, #+4]
        ADD      R0,R4,#+1896
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+0
        MOVS     R1,#+100
        ADDW     R0,R4,#+1916
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R0,#+0
        STRH     R0,[R5, #+52]
        STRH     R0,[R5, #+22]
        STRH     R0,[R5, #+26]
        STRB     R0,[R4, #+2780]
        STRB     R0,[R5, #+20]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock101

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175:
        DC32     `?<Constant "Printer stopped due t...">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_1:
        DC32     _ZN8Endstops15z_probe_enabledE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_2:
        DC32     `?<Constant "Done saving file.\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_3:
        DC32     0x408f4000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_4:
        DC32     0x40590000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_5:
        DC32     0x3fe00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable175_6:
        DC32     filament_rate

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock102 Using cfiCommon0
          CFI Function _Z14mks_WriteToEprv
        THUMB
// __interwork __softfp void mks_WriteToEpr()
_Z14mks_WriteToEprv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.W    R4,??DataTable189_4
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R4, #+2072]
        ADDW     R5,R4,#+2072
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1201
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable190_1
        LDR      R0,[R6, #+0]
        STRH     R0,[R5, #+18]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2090
        MOVW     R0,#+1205
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R7,??DataTable189_3
        LDRB     R0,[R7, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_WriteToEpr_0
        LDR      R0,[R6, #+4]
        STRH     R0,[R5, #+20]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2092
        MOVW     R0,#+1207
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_0:
        LDRB     R0,[R7, #+56]
        CBZ.N    R0,??mks_WriteToEpr_1
        LDR.W    R0,??DataTable190_2
        LDRH     R0,[R0, #+0]
        STRH     R0,[R5, #+22]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2094
        MOVW     R0,#+1209
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_1:
        MOVS     R2,#+4
        ADDW     R1,R4,#+2036
        MOVW     R0,#+1211
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2040
        MOVW     R0,#+1215
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2044
        MOVW     R0,#+1219
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2048
        MOVW     R0,#+1223
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2052
        MOVW     R0,#+1227
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2056
        MOVW     R0,#+1231
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2060
        MOVW     R0,#+1235
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2064
        MOVW     R0,#+1239
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.N    R5,??DataTable176_3
        MOVS     R2,#+2
        ADDS     R1,R5,#+2
        MOV      R0,#+1264
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+2100
        MOVW     R0,#+1247
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2096
        MOVW     R0,#+1243
          CFI FunCall epr_write_data
        BL       epr_write_data
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R2,#+1
        LDR.W    R1,??DataTable195
        B.W      ?Subroutine7
          CFI EndBlock cfiBlock102

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176:
        DC32     loop_start

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_1:
        DC32     0x42220194

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_2:
        DC32     temperature_change_frequency

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_3:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_4:
        DC32     poweroff_det_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_5:
        DC32     poweroff_det_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_6:
        DC32     filament_det1_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_7:
        DC32     filament_det1_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_8:
        DC32     filament_det1_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_9:
        DC32     filament_det1_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_10:
        DC32     filament_det1_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable176_11:
        DC32     filament_det1_high_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock103 Using cfiCommon0
          CFI Function mks_ReadFromEpr
        THUMB
// __interwork __softfp void mks_ReadFromEpr()
mks_ReadFromEpr:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R5,??DataTable189_4
        MOVS     R2,#+100
        ADDW     R1,R5,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R4,??DataTable184
        LDRB     R1,[R4, #+431]
        MOVW     R0,#+1201
        CMP      R1,#+1
        BEQ.N    ??mks_ReadFromEpr_0
        MOVS     R2,#+4
        ADDW     R1,R5,#+2072
        B.N      ??mks_ReadFromEpr_1
??mks_ReadFromEpr_0:
        MOVS     R2,#+4
        ADD      R1,R5,#+2080
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2076
        MOVW     R0,#+1269
??mks_ReadFromEpr_1:
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADDW     R1,R5,#+2090
        MOVW     R0,#+1205
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R6,??DataTable189_3
        LDRB     R0,[R6, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_ReadFromEpr_2
        MOVS     R2,#+2
        ADDW     R1,R5,#+2092
        MOVW     R0,#+1207
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_2:
        LDRB     R0,[R6, #+56]
        CBZ.N    R0,??mks_ReadFromEpr_3
        MOVS     R2,#+2
        ADDW     R1,R5,#+2094
        MOVW     R0,#+1209
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_3:
        MOVS     R2,#+4
        ADDW     R1,R5,#+2036
        MOVW     R0,#+1211
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2040
        MOVW     R0,#+1215
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2044
        MOVW     R0,#+1219
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2048
        MOVW     R0,#+1223
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2052
        MOVW     R0,#+1227
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2056
        MOVW     R0,#+1231
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R5,#+2060
        MOVW     R0,#+1235
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2064
        MOVW     R0,#+1239
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R6,??DataTable193_3
        MOVS     R2,#+2
        ADDS     R1,R6,#+2
        MOV      R0,#+1264
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R5,#+2100
        MOVW     R0,#+1247
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R5,#+2096
        MOVW     R0,#+1243
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R5,??DataTable195_3
        MOVS     R2,#+1
        ADD      R1,R5,#+10
        MOVW     R0,#+1268
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R5, #+10]
        STRB     R0,[R4, #+172]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock103

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable177:
        DC32     filament_det2_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable177_1:
        DC32     filament_det2_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable177_2:
        DC32     filament_det2_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable177_3:
        DC32     filament_det2_low_cnt

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock104 Using cfiCommon0
          CFI Function mks_resumePrint
        THUMB
// __interwork __softfp void mks_resumePrint()
mks_resumePrint:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.W    R4,??DataTable189_4
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+170
        BNE.N    ??mks_resumePrint_0
        MOVS     R0,#+167
        STRB     R0,[R4, #+2068]
        LDR      R0,[R4, #+2028]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        ADDW     R0,R4,#+2028
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
??mks_resumePrint_0:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+171
        ITT      EQ 
        MOVEQ    R0,#+172
        STRBEQ   R0,[R4, #+2068]
        POP      {R4,PC}          ;; return
          CFI EndBlock cfiBlock104

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178:
        DC32     filament_det2_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_1:
        DC32     filament_det2_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_2:
        DC32     poweroff_det_low_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_3:
        DC32     poweroff_det_low_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_4:
        DC32     poweroff_det_high_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_5:
        DC32     poweroff_det_high_cnt

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable178_6:
        DC32     wifi_check_time

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock105 Using cfiCommon0
          CFI Function mks_pausePrint
        THUMB
// __interwork __softfp void mks_pausePrint()
mks_pausePrint:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.W    R0,??DataTable195_3
        LDR.W    R5,??DataTable189_4
        LDR      R1,[R0, #+16]
        ADDW     R4,R5,#+2016
        STR      R1,[R4, #+20]
        LDR      R1,[R0, #+20]
        STR      R1,[R4, #+24]
        LDR      R1,[R0, #+24]
        STR      R1,[R4, #+28]
        LDR      R1,[R0, #+28]
        STR      R1,[R4, #+32]
        LDR      R1,[R0, #+32]
        STR      R1,[R4, #+36]
        LDR      R1,[R0, #+36]
        STR      R1,[R4, #+40]
        LDR      R1,[R0, #+40]
        STR      R1,[R4, #+44]
        LDR      R1,[R0, #+44]
        STR      R1,[R4, #+48]
        LDR      R1,[R0, #+116]
        LDR      R0,[R0, #+112]
        STR      R0,[R4, #+80]
        STRB     R1,[R5, #+2100]
        LDR.W    R0,??DataTable184
        LDRSB    R0,[R0, #+686]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R0,[R4, #+8]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR      R2,[R5, #+2016]
        LDR.W    R1,??DataTable196  ;; 0xbf800000
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??mks_pausePrint_0
        LDR      R4,[R4, #+4]
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??mks_pausePrint_0
        MOV      R1,R4
        MOV      R0,R2
          CFI FunCall mks_moveXY
        BL       mks_moveXY
??mks_pausePrint_0:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14mks_WriteToEprv
        B.N      _Z14mks_WriteToEprv
          CFI EndBlock cfiBlock105

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable179:
        DC32     key_value_calc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable179_1:
        DC32     tips_disp

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
filament_loading_time_flg:
        DS8 1
filament_loading_completed:
        DS8 1
filament_unloading_time_flg:
        DS8 1
filament_unloading_completed:
        DS8 1
printing_rate_update_flag:
        DS8 1
preview_no_display:
        DS8 1
sd_read_error_flg:
        DS8 1
sd_read_cnt:
        DS8 1
display_hold:
        DS8 1
display_hold_release:
        DS8 1
wifi_init_flg:
        DS8 1
wifi_refresh_flg:
        DS8 1
cloud_refresh_flg:
        DS8 1
waiting_wifi_time:
        DS8 1
beep_flg:
        DS8 1
// __absolute uint8_t volatile has_adjust_speed
has_adjust_speed:
        DS8 1
// __absolute uint8_t print_finish_start_timer
print_finish_start_timer:
        DS8 1
// __absolute uint8_t print_finish_close_machine
print_finish_close_machine:
        DS8 1
        DS8 2
        DS8 4
z_high_count:
        DS8 2
// __absolute uint16_t volatile resume_printed_time
resume_printed_time:
        DS8 2
        DS8 4
filament_loading_time_cnt:
        DS8 4
filament_unloading_time_cnt:
        DS8 4
TimeIncrease:
        DS8 4
display_hold_cnt:
        DS8 4
beep_cnt:
        DS8 4
// __absolute uint32_t print_finish_timer_count
print_finish_timer_count:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_heat_completed_load:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
filament_heat_completed_unload:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
loop_start:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
card:
        DS8 1896
// __absolute DATA_REPRINT_ITMES mksReprint
mksReprint:
        DS8 888

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
serial_wait_tick:
        DS8 1
from_wifi_flag:
        DS8 1
        DS8 2
        DS8 4
        DS8 4
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
command_queue:
        DS8 384

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
lcd_wait_for_move:
        DS8 1
        DS8 3
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
saved_feedrate_percentage:
        DS8 2
        DS8 2
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
z_values:
        DS8 576

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
next_busy_signal_ms:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE18serial_line_buffer
_ZZ19get_serial_commandsvE18serial_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_serial_commandsvE19serial_comment_mode
_ZZ19get_serial_commandsvE19serial_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ19get_serial_commandsvE14last_wait_time
_ZZ19get_serial_commandsvE14last_wait_time:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE14stop_buffering
_ZZ19get_sdcard_commandsvE14stop_buffering:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ19get_sdcard_commandsvE15sd_comment_mode
_ZZ19get_sdcard_commandsvE15sd_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ17get_wifi_commandsvE16wifi_line_buffer
_ZZ17get_wifi_commandsvE16wifi_line_buffer:
        DS8 96

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ17get_wifi_commandsvE17wifi_comment_mode
_ZZ17get_wifi_commandsvE17wifi_comment_mode:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
_ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_GROUP _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
// __absolute unsigned char prepare_kinematic_move_to(float const (&)[4]){9}::_ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
_ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        SECTION_GROUP _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
_ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
button_disp_pause_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
wifi_init_state:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
// __absolute uint8_t continue_print_error_flg
continue_print_error_flg:
        DS8 1

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t1
t1:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute uint32_t t2
t2:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
// __absolute char t12[10]
t12:
        DS8 12

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock106 Using cfiCommon0
          CFI Function mks_PrintStatePolling
        THUMB
// __interwork __softfp void mks_PrintStatePolling()
mks_PrintStatePolling:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.W    R4,??DataTable189_4
        LDRB     R0,[R4, #+2068]
        ADDW     R5,R4,#+2024
        CMP      R0,#+169
        BNE.N    ??mks_PrintStatePolling_0
        LDR.W    R0,??DataTable195_4
        LDR.W    R1,??DataTable195_5
        LDRB     R0,[R0, #+0]
        LDRB     R1,[R1, #+0]
        CMP      R0,R1
        BNE.N    ??mks_PrintStatePolling_1
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        CMP      R0,#+101
        BCC.N    ??mks_PrintStatePolling_1
        LDR      R0,[R5, #+8]
        ADDS     R0,R0,#+1
        STR      R0,[R5, #+8]
??mks_PrintStatePolling_1:
        LDR      R0,[R5, #+8]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_2
        MOVS     R0,#+170
        STRB     R0,[R4, #+2068]
        LDR.W    R0,??DataTable184
        LDRB     R0,[R0, #+431]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_3
        MOVS     R2,#+1
        ADDW     R1,R4,#+2068
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_3:
        MOVS     R0,#+0
        STR      R0,[R5, #+8]
          CFI FunCall mks_pausePrint
        BL       mks_pausePrint
        B.N      ??mks_PrintStatePolling_2
??mks_PrintStatePolling_0:
        MOVS     R0,#+0
        STR      R0,[R5, #+8]
??mks_PrintStatePolling_2:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+170
        BNE.N    ??mks_PrintStatePolling_4
        LDR.W    R6,??DataTable195_3
        LDR      R0,[R5, #+12]
        LDR      R1,[R6, #+16]
        LDR.W    R7,??DataTable195_6  ;; 0x38d1b718
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_5
        LDR      R0,[R6, #+16]
        STR      R0,[R5, #+12]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2036
        MOVW     R0,#+1211
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_5:
        LDR      R0,[R5, #+16]
        LDR      R1,[R6, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_6
        LDR      R0,[R6, #+20]
        STR      R0,[R5, #+16]
        MOVS     R2,#+4
        ADD      R1,R4,#+2040
        MOVW     R0,#+1215
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_6:
        LDR      R0,[R5, #+20]
        LDR      R1,[R6, #+24]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        MOV      R1,R7
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??mks_PrintStatePolling_4
        LDR      R0,[R6, #+24]
        STR      R0,[R5, #+20]
        MOVS     R2,#+4
        ADDW     R1,R4,#+2044
        MOVW     R0,#+1219
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_4:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+168
        ITTT     EQ 
        LDREQ.W  R0,??DataTable195_7
        LDRBEQ   R1,[R0, #+0]
        CMPEQ    R1,#+1
        BNE.N    ??mks_PrintStatePolling_7
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        LDR.W    R0,??DataTable184
        LDRSB    R0,[R0, #+687]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+173
        BNE.N    ??mks_PrintStatePolling_8
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R0,R4-R7,PC}
??mks_PrintStatePolling_8:
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
          CFI FunCall mks_adjust_extrude_speed
        BL       mks_adjust_extrude_speed
        MOV      R0,R4
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        LDR.W    R0,??DataTable195_8
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??mks_PrintStatePolling_7:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_9
        LDRB     R0,[R4, #+1888]
        ADDW     R6,R4,#+2068
        CMP      R0,#+0
        ITTE     EQ 
        LDRHEQ   R0,[R6, #+52]
        ADDEQ    R0,R0,#+1
        MOVNE    R0,#+0
        STRH     R0,[R6, #+52]
        LDRH     R0,[R6, #+52]
        CMP      R0,#+21
        BLT.N    ??mks_PrintStatePolling_9
        MOVS     R0,#+0
        STRH     R0,[R6, #+52]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2068]
        LDR.N    R7,??DataTable184
        LDRB     R0,[R7, #+431]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_10
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
          CFI FunCall mks_clearFile
        BL       mks_clearFile
??mks_PrintStatePolling_10:
        LDRB     R0,[R7, #+233]
        CMP      R0,#+1
        ITTT     EQ 
        LDREQ.W  R0,??DataTable195_9
        LDRBEQ   R0,[R0, #+0]
        CMPEQ    R0,#+1
        ITT      EQ 
        LDREQ.W  R1,??DataTable198
        STRBEQ   R0,[R1, #+16]
??mks_PrintStatePolling_9:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+173
        BNE.N    ??mks_PrintStatePolling_11
        MOVS     R0,#+166
        STRB     R0,[R4, #+2068]
        LDR.N    R7,??DataTable184
        LDRB     R0,[R7, #+431]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_12
        MOVS     R2,#+1
        ADDW     R1,R4,#+2068
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_PrintStatePolling_12:
        LDR.W    R6,??DataTable195_3
        LDRB     R0,[R6, #+8]
        STRB     R0,[R6, #+7]
        MOVS     R0,#+0
        STRB     R0,[R6, #+6]
          CFI FunCall _Z17quickstop_stepperv
        BL       _Z17quickstop_stepperv
        LDR      R0,[R6, #+40]
        STR      R0,[R5, #+36]
        LDR      R0,[R4, #+2024]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.W    R0,??DataTable198_1
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        ADD      R0,R6,#+132
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11Temperature19disable_all_heatersEv
        BL       _ZN11Temperature19disable_all_heatersEv
        LDR.W    R1,??DataTable199  ;; 0x40000440
        MOVS     R0,#+0
        STR      R0,[R6, #+116]
        STR      R0,[R1, #+0]
        STRB     R0,[R6, #+12]
        LDRB     R0,[R7, #+431]
        CMP      R0,#+1
        IT       NE 
          CFI FunCall mks_clearFile
        BLNE     mks_clearFile
??mks_PrintStatePolling_11:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+172
        BNE.N    ??mks_PrintStatePolling_13
        LDR.W    R0,??DataTable189_3
        LDRSH    R0,[R0, #+88]
        CMP      R0,#+1
        BEQ.N    ??mks_PrintStatePolling_14
        CMP      R0,#+2
        BEQ.N    ??mks_PrintStatePolling_15
        CMP      R0,#+4
        IT       NE 
        CMPNE    R0,#+8
        BNE.N    ??mks_PrintStatePolling_13
??mks_PrintStatePolling_14:
        LDRSB    R0,[R4, #+2780]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_16
          CFI FunCall mks_contiuePrintPause
        BL       mks_contiuePrintPause
        B.N      ??mks_PrintStatePolling_13
??mks_PrintStatePolling_16:
        CMP      R0,#+2
        BNE.N    ??mks_PrintStatePolling_13
          CFI FunCall mks_contiuePrintPwdwn
        BL       mks_contiuePrintPwdwn
        B.N      ??mks_PrintStatePolling_13
??mks_PrintStatePolling_15:
          CFI FunCall mks_contiuePrintDelta
        BL       mks_contiuePrintDelta
??mks_PrintStatePolling_13:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+167
        BNE.N    ??mks_PrintStatePolling_17
        ADDW     R6,R4,#+2068
        LDRB     R0,[R4, #+1888]
        LDRB     R1,[R6, #+20]
        TST      R0,R1
        BEQ.N    ??mks_PrintStatePolling_17
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        CMP      R0,#+101
        IT       CS 
          CFI FunCall mks_WriteToFile
        BLCS     mks_WriteToFile
        MOVS     R0,#+0
        STRB     R0,[R6, #+20]
??mks_PrintStatePolling_17:
        LDR.W    R5,??DataTable198
        LDRB     R0,[R5, #+15]
        CMP      R0,#+1
        BNE.N    ??mks_PrintStatePolling_18
        LDRH     R0,[R5, #+26]
        MOVW     R1,#+10000
        CMP      R0,R1
        BLT.N    ??mks_PrintStatePolling_18
        MOVS     R0,#+0
        STRH     R0,[R5, #+26]
          CFI FunCall mks_resume_extrude_speed
        BL       mks_resume_extrude_speed
??mks_PrintStatePolling_18:
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+166
        ITT      EQ 
        LDRBEQ   R0,[R5, #+17]
        CMPEQ    R0,#+1
        BNE.N    ??mks_PrintStatePolling_19
        MOVS     R0,#+0
        STRB     R0,[R5, #+17]
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z21Close_machine_displayv
        B.W      _Z21Close_machine_displayv
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_PrintStatePolling_19:
        POP      {R0,R4-R7,PC}    ;; return
          CFI EndBlock cfiBlock106

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable180:
        DC32     0x76313030

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock107 Using cfiCommon0
          CFI Function _Z18mks_setTemperaturev
        THUMB
// __interwork __softfp void mks_setTemperature()
_Z18mks_setTemperaturev:
        PUSH     {R4,R5,R7-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.W    R8,??DataTable189_3
        LDR.W    R4,??DataTable189_4
        LDRB     R0,[R8, #+56]
        SUB      SP,SP,#+40
          CFI CFA R13+64
        ADDW     R5,R4,#+2090
        CMP      R0,#+0
        ITT      NE 
        LDRHNE   R0,[R5, #+4]
        CMPNE    R0,#+0
        BEQ.N    ??mks_setTemperature_0
        MOVS     R1,#+96
        ADDW     R0,R4,#+2122
          CFI FunCall __aeabi_memclr
        BL       __aeabi_memclr
        ADDW     R9,R4,#+2122
        MOVS     R2,#+7
        LDR.W    R1,??DataTable197
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+4]
        ADR.N    R1,??DataTable186  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M140v
        BL       _Z10gcode_M140v
??mks_setTemperature_0:
        LDRH     R0,[R4, #+2090]
        CMP      R0,#+0
        BEQ.N    ??mks_setTemperature_1
        ADDW     R0,R4,#+2122
        STR      R0,[SP, #+0]
        ADDW     R9,R4,#+2122
        LDRB     R0,[R8, #+247]
        ADR.N    R7,??DataTable186  ;; 0x25, 0x64, 0x00, 0x00
        CMP      R0,#+2
        BNE.N    ??mks_setTemperature_2
        MOVS     R2,#+0
        MOVS     R1,#+96
        MOV      R0,R9
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+10
        LDR.W    R1,??DataTable197_1
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        MOV      R1,R7
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M104v
        BL       _Z10gcode_M104v
??mks_setTemperature_2:
        LDR      R0,[SP, #+0]
        MOVS     R2,#+0
        MOVS     R1,#+96
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+10
        LDR.W    R1,??DataTable198_2
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R4, #+2090]
        MOV      R1,R7
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_1:
        LDRB     R0,[R8, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_setTemperature_3
        LDRH     R0,[R5, #+2]
        CBZ.N    R0,??mks_setTemperature_3
        MOVS     R1,#+96
        ADDW     R0,R4,#+2122
          CFI FunCall __aeabi_memclr
        BL       __aeabi_memclr
        ADDW     R9,R4,#+2122
        MOVS     R2,#+10
        LDR.W    R1,??DataTable198_3
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+2]
        ADR.N    R1,??DataTable186  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M109v
        BL       _Z10gcode_M109v
??mks_setTemperature_3:
        LDRB     R0,[R8, #+56]
        CMP      R0,#+0
        ITT      NE 
        LDRHNE   R0,[R5, #+4]
        CMPNE    R0,#+0
        BEQ.N    ??mks_setTemperature_4
        MOVS     R1,#+96
        ADDW     R0,R4,#+2122
          CFI FunCall __aeabi_memclr
        BL       __aeabi_memclr
        ADDW     R9,R4,#+2122
        MOVS     R2,#+7
        LDR.W    R1,??DataTable198_4
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        LDRH     R2,[R5, #+4]
        ADR.N    R1,??DataTable186  ;; 0x25, 0x64, 0x00, 0x00
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z10gcode_M190v
        BL       _Z10gcode_M190v
??mks_setTemperature_4:
        ADD      SP,SP,#+40
          CFI CFA R13+24
        POP      {R4,R5,R7-R9,PC}  ;; return
          CFI EndBlock cfiBlock107

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock108 Using cfiCommon0
          CFI Function mks_setPositionZ
        THUMB
// __interwork __softfp void mks_setPositionZ()
mks_setPositionZ:
        PUSH     {R4,R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        LDR.W    R4,??DataTable189_4
        SUB      SP,SP,#+28
          CFI CFA R13+40
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R4,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R6,R4,#+2122
        MOVS     R2,#+6
        LDR.W    R1,??DataTable199_2
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R4, #+2044]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable187  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        LDR.W    R1,??DataTable199_3
        MOVS     R0,#+0
        STR      R0,[R1, #+80]
        ADD      SP,SP,#+28
          CFI CFA R13+12
        POP      {R4,R6,PC}       ;; return
          CFI EndBlock cfiBlock108

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock109 Using cfiCommon0
          CFI Function _Z18mks_ResetPositionZf
        THUMB
// __interwork __softfp void mks_ResetPositionZ(float)
_Z18mks_ResetPositionZf:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        MOV      R4,R0
        LDR.N    R5,??DataTable189_4
        SUB      SP,SP,#+28
          CFI CFA R13+40
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R5,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R5,R5,#+2122
        MOVS     R2,#+6
        LDR.W    R1,??DataTable199_2
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable187  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        LDR.W    R1,??DataTable199_3
        MOVS     R0,#+0
        STR      R0,[R1, #+80]
        ADD      SP,SP,#+28
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock109

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock110 Using cfiCommon0
          CFI Function _Z15mks_setFeedratev
          CFI NoCalls
        THUMB
// __interwork __softfp void mks_setFeedrate()
_Z15mks_setFeedratev:
        LDR.N    R0,??DataTable189_4
        LDR.W    R1,??DataTable199_3
        LDR      R0,[R0, #+2096]
        STR      R0,[R1, #+112]
        BX       LR               ;; return
          CFI EndBlock cfiBlock110

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable184:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock111 Using cfiCommon0
          CFI Function mks_preExtrude
        THUMB
// __interwork __softfp void mks_preExtrude(float)
mks_preExtrude:
        PUSH     {R4-R9,R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        MOV      R11,R0
        LDR.W    R4,??DataTable195_3
        LDR.W    R8,??DataTable189_4
        MOVS     R0,#+1
        STRB     R0,[R4, #+11]
        SUB      SP,SP,#+32
          CFI CFA R13+64
        ADDW     R0,R8,#+2122
        STR      R0,[SP, #+0]
        MOVS     R6,#+0
        MOVS     R2,#+0
        MOVS     R1,#+96
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R9,R8,#+2122
        MOVS     R2,#+5
        LDR.W    R1,??DataTable199_4
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R5,#+20
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+4
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.N    R7,??DataTable187  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        LDRB     R0,[R4, #+4]
        CBZ.N    R0,??mks_preExtrude_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
??mks_preExtrude_0:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR      R0,[SP, #+0]
        STRB     R6,[R4, #+11]
        MOVS     R2,#+0
        MOVS     R1,#+96
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        MOVS     R2,#+6
        LDR.W    R1,??DataTable200
        MOV      R0,R9
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+4
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R8, #+2064]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+4
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+4
        MOV      R0,R9
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R9
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z9gcode_G92v
        BL       _Z9gcode_G92v
        ADD      SP,SP,#+32
          CFI CFA R13+32
        POP      {R4-R9,R11,PC}   ;; return
          CFI EndBlock cfiBlock111

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable185:
        DC32     0x494949

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock112 Using cfiCommon0
          CFI Function mks_moveXY
        THUMB
// __interwork __softfp void mks_moveXY(float, float)
mks_moveXY:
        PUSH     {R4-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+28
        MOV      R9,R0
        MOV      R8,R1
        LDR.N    R5,??DataTable189_4
        SUB      SP,SP,#+20
          CFI CFA R13+48
        MOVS     R4,#+0
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R5,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R5,R5,#+2122
        MOVS     R2,#+5
        LDR.W    R1,??DataTable199_5
        MOV      R0,R5
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R6,#+20
        MOV      R2,R4
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.N    R7,??DataTable187  ;; 0x25, 0x66, 0x00, 0x00
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable190  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R2,R4
        MOV      R1,R6
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R5
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        LDR.W    R0,??DataTable199_3
        LDRB     R0,[R0, #+4]
        CBZ.N    R0,??mks_moveXY_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
??mks_moveXY_0:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+20
          CFI CFA R13+28
        POP      {R4-R9,PC}       ;; return
          CFI EndBlock cfiBlock112

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_1:
        DC32     0xff5449

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_2:
        DC32     0xaaaaaa

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable186_3:
        DC32     0x1a1a1a

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock113 Using cfiCommon0
          CFI Function mks_moveZ
        THUMB
// __interwork __softfp void mks_moveZ(float)
mks_moveZ:
        PUSH     {R4,R5,R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable189_4
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R5,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R7,R5,#+2122
        MOVS     R2,#+5
        LDR.W    R1,??DataTable199_6
        MOV      R0,R7
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R5, #+2060]
        MOV      R1,R4
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable187  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R7
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R7
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        LDR.W    R0,??DataTable195_3
        LDRB     R0,[R0, #+4]
        CBZ.N    R0,??mks_moveZ_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
??mks_moveZ_0:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4,R5,R7,PC}    ;; return
          CFI EndBlock cfiBlock113

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_1:
        DC32     `?<Constant "0.000">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable187_2:
        DC32     wifiPara

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock114 Using cfiCommon0
          CFI Function _Z18mks_moveZ_relativef
        THUMB
// __interwork __softfp void mks_moveZ_relative(float)
_Z18mks_moveZ_relativef:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        LDR.W    R4,??DataTable195_3
        LDR.N    R6,??DataTable189_4
        MOVS     R0,#+1
        STRB     R0,[R4, #+11]
        SUB      SP,SP,#+24
          CFI CFA R13+40
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R6,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R6,R6,#+2122
        MOVS     R2,#+5
        LDR.W    R1,??DataTable199_6
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable193_1  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        LDRB     R0,[R4, #+4]
        CBZ.N    R0,??mks_moveZ_relative_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
??mks_moveZ_relative_0:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
        STRB     R0,[R4, #+11]
        ADD      SP,SP,#+24
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock114

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188:
        DC32     ipPara

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_1:
        DC32     `?<Constant "TP-LINK_MKS">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_2:
        DC32     `?<Constant "makerbase">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_3:
        DC32     `?<Constant "192.168.3.100">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_4:
        DC32     `?<Constant "255.255.255.0">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable188_5:
        DC32     `?<Constant "192.168.3.1">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock115 Using cfiCommon0
          CFI Function _Z7mks_G28Pc
        THUMB
// __interwork __softfp void mks_G28(char *)
_Z7mks_G28Pc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable189_4
        MOVS     R1,#+96
        ADDW     R0,R5,#+2122
          CFI FunCall __aeabi_memclr
        BL       __aeabi_memclr
        ADDW     R5,R5,#+2122
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        MOVS     R0,#+0
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
        LDR.N    R4,??DataTable189_3
        LDRB     R0,[R4, #+66]
        MOVS     R1,#+62
        TST      R0,R1
        IT       NE 
        CMPNE    R0,#+16
        BEQ.N    ??mks_G28_0
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        LDRSH    R0,[R4, #+88]
        CMP      R0,#+2
        BEQ.N    ??mks_G28_0
        LDRB     R0,[R4, #+66]
        LSLS     R0,R0,#+27
        BPL.N    ??mks_G28_0
        LDR.W    R0,??DataTable200_3
        LDRB     R0,[R0, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??mks_G28_0
        LDR.W    R0,??DataTable200_4
        LDR.W    R1,??DataTable200_5
        LDRB     R0,[R0, #+25]
        CBZ.N    R0,??mks_G28_1
        LDR.W    R2,??DataTable202_2
        LDR      R2,[R2, #+0]
        ADDS     R0,R0,R2
??mks_G28_1:
        STR      R0,[R1, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R1,#+1
          CFI FunCall _Z17set_z_fade_heightfb
        B.W      _Z17set_z_fade_heightfb
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_G28_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock115

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189:
        DC32     `?<Constant "192.168.3.255">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189_1:
        DC32     `?<Constant "baizhongyun.cn">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189_2:
        DC32     BMP_PIC_X

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189_3:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable189_4:
        DC32     card

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock116 Using cfiCommon0
          CFI Function _Z18mks_leveling_moveZf
        THUMB
// __interwork __softfp void mks_leveling_moveZ(float)
_Z18mks_leveling_moveZf:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        MOV      R5,R0
        LDR.W    R6,??DataTable200_6
        SUB      SP,SP,#+32
          CFI CFA R13+48
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R6,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R4,R6,#+2122
        MOVS     R2,#+5
        LDR.W    R1,??DataTable199_6
        MOV      R0,R4
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R2,#+0
        MOVS     R1,#+20
        ADD      R0,SP,#+8
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.W    R0,??DataTable200_7
        LDR      R1,[R0, #+8]
        LDR.W    R0,??DataTable200_8  ;; 0x42700000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        LDR      R0,[R6, #+2060]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R1,??DataTable201
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R4
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R4
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        LDR.W    R0,??DataTable199_3
        LDRB     R0,[R0, #+4]
        CBZ.N    R0,??mks_leveling_moveZ_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
??mks_leveling_moveZ_0:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock116

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_1:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable190_2:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock117 Using cfiCommon0
          CFI Function _Z19mks_leveling_moveXYff
        THUMB
// __interwork __softfp void mks_leveling_moveXY(float, float)
_Z19mks_leveling_moveXYff:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        MOV      R8,R0
        MOV      R4,R1
        LDR.W    R6,??DataTable200_6
        SUB      SP,SP,#+32
          CFI CFA R13+56
        MOVS     R5,#+0
        MOVS     R2,#+0
        MOVS     R1,#+96
        ADDW     R0,R6,#+2122
          CFI FunCall __aeabi_memset
        BL       __aeabi_memset
        ADDW     R6,R6,#+2122
        MOVS     R2,#+5
        LDR.W    R1,??DataTable199_5
        MOV      R0,R6
          CFI FunCall __aeabi_memcpy
        BL       __aeabi_memcpy
        MOVS     R7,#+20
        MOV      R2,R5
        MOV      R1,R7
        ADD      R0,SP,#+8
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R0,R8
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R1,??DataTable202_3
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        ADR.N    R1,??DataTable195_1  ;; 0x20, 0x59, 0x00, 0x00
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R2,R5
        MOV      R1,R7
        ADD      R0,SP,#+8
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.W    R0,??DataTable202_4
        LDR      R0,[R0, #+36]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        STRD     R0,R1,[SP, #+0]
        MOV      R0,R4
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        LDR.W    R1,??DataTable201
        ADD      R0,SP,#+8
          CFI FunCall sprintf
        BL       sprintf
        ADD      R1,SP,#+8
        MOV      R0,R6
          CFI FunCall strcat
        BL       strcat
        MOV      R0,R6
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        LDR.W    R0,??DataTable199_3
        LDRB     R0,[R0, #+4]
        CBZ.N    R0,??mks_leveling_moveXY_0
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
          CFI FunCall _Z27prepare_move_to_destinationv
        BL       _Z27prepare_move_to_destinationv
??mks_leveling_moveXY_0:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        ADD      SP,SP,#+32
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
          CFI EndBlock cfiBlock117

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock118 Using cfiCommon0
          CFI Function mks_manual_leveling
        THUMB
// __interwork __softfp void mks_manual_leveling(int16_t, int16_t)
mks_manual_leveling:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.W    R0,??DataTable202_5
        MOV      R5,R1
        LDRB     R1,[R0, #+0]
        CMP      R1,#+1
        BNE.N    ??mks_manual_leveling_0
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
        ADR.N    R0,??DataTable195_2  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
??mks_manual_leveling_0:
        LDR.N    R0,??DataTable195_3
        LDR.W    R1,??DataTable200_6
        LDR      R0,[R0, #+24]
        STR      R0,[R1, #+2060]
        LDR.W    R0,??DataTable202_6  ;; 0x41200000
          CFI FunCall _Z18mks_leveling_moveZf
        BL       _Z18mks_leveling_moveZf
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall _Z19mks_leveling_moveXYff
        BL       _Z19mks_leveling_moveXYff
        LDR.W    R1,??DataTable202_7
        LDR.W    R0,??DataTable207
        STR      R0,[R1, #+4]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z25drain_injected_commands_Pv
        B.W      _Z25drain_injected_commands_Pv
          CFI EndBlock cfiBlock118

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock119 Using cfiCommon0
          CFI Function mks_contiuePrintPause
        THUMB
// __interwork __softfp void mks_contiuePrintPause()
mks_contiuePrintPause:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable200_6
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        LDR.W    R0,??DataTable198_1
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+173
        BEQ.N    ??mks_contiuePrintPause_0
        LDR      R0,[R4, #+2028]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        ADDW     R0,R4,#+2028
        LDR      R1,[R0, #+28]
        LDR      R0,[R0, #+24]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.N    R5,??DataTable195_3
        LDR      R0,[R4, #+2096]
        STR      R0,[R5, #+112]
          CFI FunCall mks_adjust_extrude_speed
        BL       mks_adjust_extrude_speed
        MOVW     R1,#+10000
        LDRB     R0,[R4, #+2100]
        STR      R0,[R5, #+116]
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable199  ;; 0x40000440
        STR      R0,[R1, #+0]
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPause_1
??mks_contiuePrintPause_0:
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R0,R4,R5,PC}
??mks_contiuePrintPause_1:
        MOVS     R0,#+167
        STRB     R0,[R4, #+2068]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z9gcode_M24v
        B.W      _Z9gcode_M24v
          CFI EndBlock cfiBlock119

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193:
        DC32     BMP_PIC_Y

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_1:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_2:
        DC32     0x40a00000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable193_3:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock120 Using cfiCommon0
          CFI Function mks_contiuePrintPwdwn
        THUMB
// __interwork __softfp void mks_contiuePrintPwdwn()
mks_contiuePrintPwdwn:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R4,??DataTable200_6
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
          CFI FunCall mks_setPositionZ
        BL       mks_setPositionZ
        LDR      R0,[R4, #+2024]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.W    R0,??DataTable198_1
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+173
        BEQ.N    ??mks_contiuePrintPwdwn_0
        LDR.W    R0,??DataTable202_4
        LDRB     R0,[R0, #+66]
        ADDW     R5,R4,#+2024
        CMP      R0,#+8
        BNE.N    ??mks_contiuePrintPwdwn_1
        LDR      R1,[R5, #+20]
        LDR      R0,[R4, #+2024]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall _Z18mks_ResetPositionZf
        BL       _Z18mks_ResetPositionZf
??mks_contiuePrintPwdwn_1:
        MOVW     R0,#+3000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        LDR      R0,[R5, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.N    R6,??DataTable195_3
        ADDW     R5,R4,#+2068
        LDR      R0,[R5, #+28]
        STR      R0,[R6, #+112]
          CFI FunCall mks_adjust_extrude_speed
        BL       mks_adjust_extrude_speed
        MOVW     R1,#+10000
        LDRB     R0,[R4, #+2100]
        STR      R0,[R6, #+116]
        MULS     R0,R1,R0
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable199  ;; 0x40000440
        STR      R0,[R1, #+0]
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+173
        BNE.N    ??mks_contiuePrintPwdwn_2
??mks_contiuePrintPwdwn_0:
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        POP      {R4-R6,PC}
??mks_contiuePrintPwdwn_2:
        MOVS     R0,#+167
        STRB     R0,[R4, #+2068]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R5, #+20]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock120

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock121 Using cfiCommon0
          CFI Function mks_contiuePrintDelta
        THUMB
// __interwork __softfp void mks_contiuePrintDelta()
mks_contiuePrintDelta:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable200_6
        MOVS     R0,#+1
        STRB     R0,[R4, #+1888]
          CFI FunCall _Z18mks_setTemperaturev
        BL       _Z18mks_setTemperaturev
        ADR.N    R0,??DataTable195_2  ;; "G28"
          CFI FunCall _Z7mks_G28Pc
        BL       _Z7mks_G28Pc
        LDR      R0,[R4, #+2024]
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        ADDW     R5,R4,#+2024
        LDR      R0,[R5, #+4]
          CFI FunCall mks_preExtrude
        BL       mks_preExtrude
        LDR      R1,[R5, #+32]
        LDR      R0,[R5, #+28]
          CFI FunCall mks_moveXY
        BL       mks_moveXY
        MOVS     R0,#+0
          CFI FunCall mks_moveZ
        BL       mks_moveZ
        LDR.N    R0,??DataTable195_3
        ADDW     R5,R4,#+2068
        LDR      R1,[R5, #+28]
        STR      R1,[R0, #+112]
        LDRB     R1,[R4, #+2100]
        STR      R1,[R0, #+116]
        MOVW     R0,#+10000
        MULS     R0,R0,R1
        MOVS     R1,#+255
        SDIV     R0,R0,R1
        LDR.W    R1,??DataTable199  ;; 0x40000440
        STR      R0,[R1, #+0]
        MOVS     R0,#+167
        STRB     R0,[R4, #+2068]
          CFI FunCall _Z9gcode_M24v
        BL       _Z9gcode_M24v
        MOVS     R0,#+0
        STRB     R0,[R5, #+20]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock121

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195:
        DC32     axis_relative_modes+0xA

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_1:
        DC8      0x20, 0x59, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_2:
        DC8      "G28"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_3:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_4:
        DC32     _ZN7Planner17block_buffer_headE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_5:
        DC32     _ZN7Planner17block_buffer_tailE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_6:
        DC32     0x38d1b718

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_7:
        DC32     pause_resum

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_8:
        DC32     axis_relative_modes+0x84

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable195_9:
        DC32     IsChooseAutoShutdown

        SECTION `.data`:DATA:REORDER:NOROOT(0)
// static __absolute uint8_t first_resu
first_resu:
        DATA
        DC8 1

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock122 Using cfiCommon0
          CFI Function mks_getPositionXYZE
        THUMB
// __interwork __softfp void mks_getPositionXYZE()
mks_getPositionXYZE:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+28
          CFI CFA R13+64
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
        LDR.W    R9,??DataTable200_6
        LDR.W    R0,??DataTable207_2
        LDR.W    R11,??DataTable207_3  ;; 0x38d1b718
        LDRB     R0,[R0, #+431]
        LDR.W    R4,??DataTable199_3
        ADDW     R6,R9,#+2044
        CMP      R0,#+1
        BEQ.W    ??mks_getPositionXYZE_0
        LDR      R1,[R6, #+28]
        STR      R1,[R9, #+1120]
        MOV      R0,R9
          CFI FunCall f_lseek
        BL       f_lseek
        MOVS     R0,#+1
        STRB     R0,[R9, #+1888]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R0,#+0
        LDR.W    R8,??DataTable208
        STRB     R0,[R9, #+1888]
        STRB     R0,[R9, #+2088]
        STR      R0,[R4, #+16]
        STR      R0,[R4, #+32]
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+36]
        STR      R0,[R4, #+24]
        STR      R0,[R4, #+40]
        STR      R0,[R4, #+28]
        STR      R0,[R4, #+44]
        MOVS     R5,#+0
        MOV      R10,R8
        B.N      ??mks_getPositionXYZE_1
??mks_getPositionXYZE_2:
        CBNZ.N   R5,??mks_getPositionXYZE_3
??mks_getPositionXYZE_1:
        LDR.W    R0,??DataTable210
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_getPositionXYZE_3
        LDR.W    R1,??DataTable210
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        MOVS     R1,#+90
        MOV      R0,R8
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??mks_getPositionXYZE_4
??mks_getPositionXYZE_5:
        LDRSB    R1,[R0], #+1
        CBZ.N    R1,??mks_getPositionXYZE_6
        LDRSB    R1,[SP, #+0]
        ADDS     R2,R1,#+1
        STRB     R2,[SP, #+0]
        LDRB     R2,[R0, #+0]
        STRB     R2,[R1, R3]
        LDRSB    R1,[SP, #+0]
        CMP      R1,#+21
        BLT.N    ??mks_getPositionXYZE_5
??mks_getPositionXYZE_6:
        MOVS     R2,#+0
        MOVS     R1,#+0
        ADD      R0,SP,#+4
          CFI FunCall __iar_Stod
        BL       __iar_Stod
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+40]
        B.N      ??mks_getPositionXYZE_4
??mks_getPositionXYZE_3:
        MOV      R0,R10
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??mks_getPositionXYZE_4:
        LDR      R0,[R6, #+8]
        BIC      R0,R0,#0x80000000
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_7
        LDR      R0,[R4, #+32]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITT      LS 
        LDRLS    R0,[R4, #+32]
        STRLS    R0,[R6, #+8]
??mks_getPositionXYZE_7:
        LDR      R0,[R6, #+12]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_8
        LDR      R0,[R4, #+36]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITT      LS 
        LDRLS    R0,[R4, #+36]
        STRLS    R0,[R6, #+12]
??mks_getPositionXYZE_8:
        LDR      R0,[R6, #+16]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_9
        LDR      R0,[R4, #+40]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITT      LS 
        LDRLS    R0,[R4, #+40]
        STRLS    R0,[R6, #+16]
??mks_getPositionXYZE_9:
        LDR      R0,[R6, #+20]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_10
        LDR      R0,[R4, #+44]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITT      LS 
        LDRLS    R0,[R4, #+44]
        STRLS    R0,[R6, #+20]
??mks_getPositionXYZE_10:
        ADDS     R5,R5,#+1
        ADD      R10,R10,#+96
        CMP      R5,#+4
        BLT.N    ??mks_getPositionXYZE_2
        LDR      R0,[R6, #+16]
        STR      R0,[R9, #+2044]
        LDR      R0,[R6, #+20]
        STR      R0,[R6, #+4]
        B.N      ??mks_getPositionXYZE_11
??mks_getPositionXYZE_0:
        MOVS     R0,#+0
        STR      R0,[R4, #+16]
        STR      R0,[R4, #+32]
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+36]
        STR      R0,[R4, #+24]
        STR      R0,[R4, #+40]
        STR      R0,[R4, #+28]
        STR      R0,[R4, #+44]
        MOV      R0,R9
        LDR      R1,[R6, #+32]
        STR      R1,[R9, #+1120]
          CFI FunCall f_lseek
        BL       f_lseek
        LDR.W    R8,??DataTable208
        B.N      ??mks_getPositionXYZE_12
??mks_getPositionXYZE_13:
        MOV      R0,R10
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
??mks_getPositionXYZE_14:
        MOVS     R2,#+0
        ADDW     R3,R9,#+2052
        ADD      R7,R4,#+32
        MOV      R1,R11
??mks_getPositionXYZE_15:
        LDR      R0,[R3, #+0]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??mks_getPositionXYZE_16
        LDR      R0,[R7, #+0]
        BIC      R0,R0,#0x80000000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITT      LS 
        LDRLS    R0,[R7, #+0]
        STRLS    R0,[R3, #+0]
??mks_getPositionXYZE_16:
        CMP      R2,#+2
        BEQ.N    ??mks_getPositionXYZE_17
        LDR      R0,[R7, #+0]
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        IT       LS 
        STRLS    R0,[R3, #+0]
??mks_getPositionXYZE_17:
        ADDS     R2,R2,#+1
        ADDS     R7,R7,#+4
        ADDS     R3,R3,#+4
        CMP      R2,#+4
        BLT.N    ??mks_getPositionXYZE_15
        ADDS     R5,R5,#+1
        ADD      R10,R10,#+96
        CMP      R5,#+4
        BLT.N    ??mks_getPositionXYZE_18
        LDR      R0,[R6, #+16]
        STR      R0,[R9, #+2044]
        LDR      R0,[R6, #+20]
        STR      R0,[R6, #+4]
??mks_getPositionXYZE_12:
        MOV      R0,R9
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        LDR      R1,[R6, #+36]
        CMP      R0,R1
        BCS.N    ??mks_getPositionXYZE_19
        MOVS     R0,#+0
        STRB     R0,[R4, #+6]
        MOVS     R0,#+1
        STRB     R0,[R9, #+1888]
          CFI FunCall _Z19get_sdcard_commandsv
        BL       _Z19get_sdcard_commandsv
        MOVS     R5,#+0
        MOV      R10,R8
        B.N      ??mks_getPositionXYZE_20
??mks_getPositionXYZE_18:
        CMP      R5,#+0
        BNE.N    ??mks_getPositionXYZE_13
??mks_getPositionXYZE_20:
        LDR.W    R0,??DataTable210
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_getPositionXYZE_13
        LDR.W    R1,??DataTable210
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        MOVS     R1,#+90
        MOV      R0,R8
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CMP      R0,#+0
        ADD      R3,SP,#+4
        BEQ.N    ??mks_getPositionXYZE_14
??mks_getPositionXYZE_21:
        LDRSB    R1,[R0], #+1
        CBZ.N    R1,??mks_getPositionXYZE_22
        LDRSB    R1,[SP, #+0]
        ADDS     R2,R1,#+1
        STRB     R2,[SP, #+0]
        LDRB     R2,[R0, #+0]
        STRB     R2,[R1, R3]
        LDRSB    R1,[SP, #+0]
        CMP      R1,#+21
        BLT.N    ??mks_getPositionXYZE_21
??mks_getPositionXYZE_22:
        MOVS     R2,#+0
        MOVS     R1,#+0
        ADD      R0,SP,#+4
          CFI FunCall __iar_Stod
        BL       __iar_Stod
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R4, #+40]
        B.N      ??mks_getPositionXYZE_14
??mks_getPositionXYZE_19:
        MOVS     R0,#+0
        STRB     R0,[R9, #+1888]
        STRB     R0,[R9, #+2088]
??mks_getPositionXYZE_11:
        MOVS     R0,#+0
        STR      R0,[R4, #+16]
        STR      R0,[R4, #+32]
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+36]
        STR      R0,[R4, #+24]
        STR      R0,[R4, #+40]
        STR      R0,[R4, #+28]
        STR      R0,[R4, #+44]
        MOVS     R5,#+96
        MOV      R2,R0
        MOVS     R6,#+0
        MOV      R1,R5
        MOV      R0,R8
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,R8,#+96
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,R8,#+192
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,R8,#+288
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDRB     R0,[R4, #+8]
        STRB     R0,[R4, #+7]
        STRB     R6,[R4, #+6]
        B.W      ?Subroutine4
          CFI EndBlock cfiBlock122

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable196:
        DC32     0xbf800000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock123 Using cfiCommon0
          CFI Function mks_clearDir
        THUMB
// __interwork __softfp void mks_clearDir()
mks_clearDir:
        PUSH     {R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+12
        SUB      SP,SP,#+36
          CFI CFA R13+48
        LDR.W    R4,??DataTable210_1
        ADR.N    R5,??DataTable199_1  ;; "/"
        B.N      ??mks_clearDir_0
??mks_clearDir_1:
        ADDS     R1,R0,#+1
        ADD      R0,SP,#+0
          CFI FunCall strcpy
        BL       strcpy
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall strcpy
        BL       strcpy
??mks_clearDir_0:
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CMP      R0,#+0
        BNE.N    ??mks_clearDir_1
        ADD      SP,SP,#+36
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
          CFI EndBlock cfiBlock123

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197:
        DC32     `?<Constant "M140 S">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable197_1:
        DC32     `?<Constant "M104 T1 S">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock124 Using cfiCommon0
          CFI Function mks_contiuePrint_UI
        THUMB
// __interwork __softfp void mks_contiuePrint_UI()
mks_contiuePrint_UI:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.W    R4,??DataTable200_6
        ADDW     R5,R4,#+1916
        MOVS     R3,#+1
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8openFileEPcbb
        BL       _ZN10CardReader8openFileEPcbb
        MOV      R1,R5
        LDR.W    R0,??DataTable210_2
          CFI FunCall strcpy
        BL       strcpy
        LDR      R0,[R4, #+512]
        CBZ.N    R0,??mks_contiuePrint_UI_0
        ADDW     R6,R4,#+2068
        LDR      R0,[R6, #+4]
        CMP      R0,#+101
        ITT      CC 
        LDRCC    R0,[R6, #+12]
        CMPCC    R0,#+101
        BCC.N    ??mks_contiuePrint_UI_1
        MOVS     R2,#+100
        ADDW     R1,R4,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R0,#+0
        STRB     R0,[R4, #+1888]
        LDRSB    R0,[R4, #+2780]
        CMP      R0,#+2
        IT       EQ 
          CFI FunCall mks_getPositionXYZE
        BLEQ     mks_getPositionXYZE
        LDR.W    R5,??DataTable207_2
        LDRB     R0,[R5, #+431]
        CMP      R0,#+1
        ITE      NE 
        LDRNE    R1,[R6, #+4]
        LDREQ    R1,[R6, #+12]
        B.N      ??mks_contiuePrint_UI_2
??mks_contiuePrint_UI_0:
        MOV      R0,#+1200
          CFI FunCall _Z6Beeperj
        BL       _Z6Beeperj
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R0,#+2
          CFI FunCall draw_dialog
        B.W      draw_dialog
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_2:
        STR      R1,[R4, #+1120]
        MOV      R0,R4
          CFI FunCall f_lseek
        BL       f_lseek
        LDR.N    R0,??DataTable199_3
        LDR      R1,[R4, #+2036]
        STR      R1,[R0, #+16]
        ADDW     R1,R4,#+2036
        LDR      R2,[R1, #+4]
        LDR      R1,[R1, #+8]
        STR      R2,[R0, #+20]
        STR      R1,[R0, #+24]
        LDRB     R0,[R5, #+431]
        CMP      R0,#+1
        IT       NE 
          CFI FunCall mks_clearDir
        BLNE     mks_clearDir
??mks_contiuePrint_UI_3:
          CFI FunCall getTick
        BL       getTick
        LDR.W    R1,??DataTable210_3
        STR      R0,[R1, #+0]
        LDR.W    R1,??DataTable210_4
        LDR      R1,[R1, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        MOVW     R1,#+3000
        CMP      R0,R1
        BCS.N    ??mks_contiuePrint_UI_4
        LDRSB    R0,[R5, #+202]
        CMP      R0,#+0
        BNE.N    ??mks_contiuePrint_UI_3
??mks_contiuePrint_UI_4:
        LDR.W    R4,??DataTable210_5
        MOVS     R2,#+1
        MOV      R1,R4
        MOV      R0,#+1792
          CFI FunCall AT24CXX_Read
        BL       AT24CXX_Read
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        ITTEE    NE 
        MOVNE    R0,#+1
        LDRNE.W  R1,??DataTable210_6
        MOVEQ    R0,#+1
        LDREQ.W  R1,??DataTable210_7
        STRB     R0,[R1, #+0]
        POP      {R4-R6,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_printing
        B.W      draw_printing
          CFI R4 Frame(CFA, -16)
          CFI R5 Frame(CFA, -12)
          CFI R6 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??mks_contiuePrint_UI_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+2780]
        MOVS     R0,#+166
        STRB     R0,[R4, #+2068]
        LDR.W    R0,??DataTable207_2
        LDRB     R0,[R0, #+431]
        CMP      R0,#+1
        BEQ.N    ??mks_contiuePrint_UI_5
        MOVS     R2,#+1
        MOV      R1,R6
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_contiuePrint_UI_5:
        LDR.W    R1,??DataTable210_8
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock124

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_1:
        DC32     `?<Constant "G28 X0 Y0">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_2:
        DC32     `?<Constant "M109 T0 S">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_3:
        DC32     `?<Constant "M109 T1 S">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable198_4:
        DC32     `?<Constant "M190 S">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock125 Using cfiCommon0
          CFI Function mks_rePrintCheck
        THUMB
// __interwork __softfp void mks_rePrintCheck()
mks_rePrintCheck:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R4,??DataTable200_6
        ADDW     R5,R4,#+2068
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRB     R0,[R4, #+2068]
        CMP      R0,#+170
        BNE.N    ??mks_rePrintCheck_0
        MOVS     R0,#+171
        STRB     R0,[R4, #+2068]
          CFI FunCall mks_ReadFromEpr
        BL       mks_ReadFromEpr
        MOVS     R0,#+1
??mks_rePrintCheck_1:
        STRB     R0,[R4, #+2780]
          CFI FunCall mks_contiuePrint_UI
        BL       mks_contiuePrint_UI
        LDR.W    R0,??DataTable210_8
        LDRB     R0,[R0, #+0]
        CMP      R0,#+1
        BNE.N    ??mks_rePrintCheck_2
??mks_rePrintCheck_3:
        LDR.W    R1,??DataTable210_8
        LDR.W    R5,??DataTable210_4
        LDR.W    R6,??DataTable210_3
        LDR.W    R7,??DataTable210_9
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        MOVW     R4,#+3000
??mks_rePrintCheck_4:
        LDRB     R0,[R7, #+19]
        CMP      R0,#+1
        BEQ.N    ??mks_rePrintCheck_2
          CFI FunCall getTick
        BL       getTick
        LDR      R1,[R5, #+0]
        STR      R0,[R6, #+0]
          CFI FunCall getTickDiff
        BL       getTickDiff
        CMP      R0,R4
        BCC.N    ??mks_rePrintCheck_4
        POP      {R0,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall draw_ready_print
        B.W      draw_ready_print
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??mks_rePrintCheck_2:
        POP      {R0,R4-R7,PC}    ;; return
??mks_rePrintCheck_0:
        LDR.W    R1,??DataTable210_10
        CMP      R0,#+167
        BNE.N    ??mks_rePrintCheck_5
        LDRB     R0,[R1, #+431]
        CMP      R0,#+1
        BNE.N    ??mks_rePrintCheck_6
        MOVS     R0,#+171
        STRB     R0,[R4, #+2068]
          CFI FunCall _Z22mks_ReadFromEpr_pwroffv
        BL       _Z22mks_ReadFromEpr_pwroffv
        MOVS     R0,#+2
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_6:
        MOVS     R0,#+171
        STRB     R0,[R4, #+2068]
        MOVS     R2,#+100
        ADDW     R1,R4,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
          CFI FunCall mks_ReadFromFile
        BL       mks_ReadFromFile
        MOVS     R0,#+2
        B.N      ??mks_rePrintCheck_1
??mks_rePrintCheck_5:
        MOVS     R0,#+166
        STRB     R0,[R4, #+2068]
        LDRB     R0,[R1, #+431]
        CMP      R0,#+1
        BEQ.N    ??mks_rePrintCheck_7
        MOVS     R2,#+1
        MOV      R1,R5
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_rePrintCheck_7:
        LDR.W    R1,??DataTable210_8
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
        B.N      ??mks_rePrintCheck_3
          CFI EndBlock cfiBlock125

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199:
        DC32     0x40000440

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_1:
        DC8      "/",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_2:
        DC32     `?<Constant "G92 Z">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_3:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_4:
        DC32     `?<Constant "G1 E">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_5:
        DC32     `?<Constant "G1 X">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable199_6:
        DC32     `?<Constant "G1 Z">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock126 Using cfiCommon0
          CFI Function mks_WriteToFile
        THUMB
// __interwork __softfp void mks_WriteToFile()
mks_WriteToFile:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        SUB      SP,SP,#+56
          CFI CFA R13+88
        ADD      R0,SP,#+20
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        MOV      R4,R1
        STM      R0!,{R1-R4}
        STM      R0!,{R1-R4}
        LDR.W    R10,??DataTable200_6
        LDRB     R0,[R10, #+1891]
        CBZ.N    R0,??mks_WriteToFile_0
        LDR.W    R1,??DataTable210_11
        ADD      R0,SP,#+20
          CFI FunCall strcat
        BL       strcat
??mks_WriteToFile_0:
        LDR.W    R0,??DataTable210_12
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+20
          CFI FunCall strcat
        BL       strcat
        ADDW     R4,R10,#+2220
        MOVS     R2,#+3
        ADD      R1,SP,#+20
        MOV      R0,R4
          CFI FunCall f_open
        BL       f_open
        CMP      R0,#+0
        BNE.W    ??mks_WriteToFile_1
        MOVS     R5,#+20
        MOVS     R6,#+0
        MOVS     R2,#+0
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        MOVS     R2,#+7
        LDR.W    R1,??DataTable210_13
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.W    R8,??DataTable200_1  ;; 0x25, 0x64, 0x00, 0x00
        LDR      R2,[R10, #+2072]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        ADR.N    R7,??DataTable200_2  ;; "\n"
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.W    R9,??DataTable210_14
        LDR      R2,[R9, #+0]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R9, #+4]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.W    R0,??DataTable210_15
        LDRSH    R2,[R0, #+0]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        LDR.W    R9,??DataTable210_16
        ADD      R3,R10,#+2112
        ADDW     R2,R10,#+2108
        ADDW     R1,R10,#+2104
        ADD      R0,R9,#+132
          CFI FunCall _ZN9Stopwatch7getTimeEPmS0_S0_
        BL       _ZN9Stopwatch7getTimeEPmS0_S0_
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDW     R10,R10,#+2072
        LDR      R1,[R10, #+40]
        LDR      R2,[R10, #+36]
        STR      R0,[R10, #+44]
        CMP      R1,R2
        IT       CC 
        STRCC    R0,[R10, #+40]
        MOVS     R2,#+0
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R10, #+32]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR.W    R10,??DataTable210_17
        LDRH     R2,[R10, #+2]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDRB     R2,[R10, #+4]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDRSB    R2,[R10, #+5]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R2,[R9, #+116]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDR      R0,[R9, #+112]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        ADR.N    R1,??DataTable202  ;; 0x25, 0x66, 0x00, 0x00
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        LDRB     R2,[R9, #+10]
        MOV      R1,R8
        ADD      R0,SP,#+0
          CFI FunCall sprintf
        BL       sprintf
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R2,R6
        MOV      R1,R5
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memset4
        BL       __aeabi_memset4
        ADR.N    R0,??DataTable202_1  ;; "end"
        ADD      R1,SP,#+0
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        MOV      R1,R7
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R0,R4
          CFI FunCall f_close
        BL       f_close
??mks_WriteToFile_1:
        ADD      SP,SP,#+56
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
          CFI EndBlock cfiBlock126

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200:
        DC32     `?<Constant "G92 E">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_1:
        DC8      0x25, 0x64, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_2:
        DC8      "\n",0x0,0x0

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_3:
        DC32     _ZN11GCodeParser8codebitsE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_4:
        DC32     _ZN11GCodeParser5paramE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_5:
        DC32     _ZN11GCodeParser9value_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_6:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_7:
        DC32     _ZN7Planner17max_feedrate_mm_sE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable200_8:
        DC32     0x42700000

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock127 Using cfiCommon0
          CFI Function _Z21mks_WriteToEpr_pwroffv
        THUMB
// __interwork __softfp void mks_WriteToEpr_pwroff()
_Z21mks_WriteToEpr_pwroffv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.W    R4,??DataTable210_18
        MOVS     R2,#+1
        ADDW     R1,R4,#+2068
        MOV      R0,#+1200
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2076
        MOVW     R0,#+1269
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOV      R0,R4
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        STR      R0,[R4, #+2072]
        ADDW     R5,R4,#+2072
        MOVS     R2,#+4
        MOV      R1,R5
        MOVW     R0,#+1201
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable210_14
        LDR      R0,[R6, #+0]
        STRH     R0,[R5, #+18]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2090
        MOVW     R0,#+1205
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.N    R7,??DataTable202_4
        LDRB     R0,[R7, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_WriteToEpr_pwroff_0
        LDR      R0,[R6, #+4]
        STRH     R0,[R5, #+20]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2092
        MOVW     R0,#+1207
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_pwroff_0:
        LDRB     R0,[R7, #+56]
        CBZ.N    R0,??mks_WriteToEpr_pwroff_1
        LDR.W    R0,??DataTable210_15
        LDRH     R0,[R0, #+0]
        STRH     R0,[R5, #+22]
        MOVS     R2,#+2
        ADDW     R1,R4,#+2094
        MOVW     R0,#+1209
          CFI FunCall epr_write_data
        BL       epr_write_data
??mks_WriteToEpr_pwroff_1:
        LDR.W    R6,??DataTable210_17
        MOVS     R2,#+2
        ADDS     R1,R6,#+2
        MOV      R0,#+1264
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_write_data
        BL       epr_write_data
        MOVS     R2,#+1
        ADDS     R1,R6,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR.W    R6,??DataTable210_16
        LDR      R0,[R6, #+116]
        STRB     R0,[R5, #+28]
        MOVS     R2,#+1
        ADDW     R1,R4,#+2100
        MOVW     R0,#+1247
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDR      R0,[R6, #+112]
        STR      R0,[R5, #+24]
        MOVS     R2,#+4
        ADD      R1,R4,#+2096
        MOVW     R0,#+1243
          CFI FunCall epr_write_data
        BL       epr_write_data
        ADD      R1,R6,#+10
        POP      {R3-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R2,#+1
          CFI EndBlock cfiBlock127
        REQUIRE ?Subroutine7
        ;; // Fall through to label ?Subroutine7

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock128 Using cfiCommon0
          CFI NoFunction
        THUMB
?Subroutine7:
        MOVW     R0,#+1268
          CFI FunCall _Z14mks_WriteToEprv epr_write_data
          CFI FunCall _Z21mks_WriteToEpr_pwroffv epr_write_data
        B.W      epr_write_data
          CFI EndBlock cfiBlock128

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock129 Using cfiCommon0
          CFI Function _Z22mks_ReadFromEpr_pwroffv
        THUMB
// __interwork __softfp void mks_ReadFromEpr_pwroff()
_Z22mks_ReadFromEpr_pwroffv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.W    R4,??DataTable210_18
        MOVS     R2,#+100
        ADDW     R1,R4,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2080
        MOVW     R0,#+1201
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADDW     R1,R4,#+2076
        MOVW     R0,#+1269
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+2
        ADDW     R1,R4,#+2090
        MOVW     R0,#+1205
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.N    R5,??DataTable202_4
        LDRB     R0,[R5, #+247]
        CMP      R0,#+2
        BNE.N    ??mks_ReadFromEpr_pwroff_0
        MOVS     R2,#+2
        ADDW     R1,R4,#+2092
        MOVW     R0,#+1207
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_pwroff_0:
        LDRB     R0,[R5, #+56]
        CBZ.N    R0,??mks_ReadFromEpr_pwroff_1
        MOVS     R2,#+2
        ADDW     R1,R4,#+2094
        MOVW     R0,#+1209
          CFI FunCall epr_read_data
        BL       epr_read_data
??mks_ReadFromEpr_pwroff_1:
        LDR.W    R5,??DataTable210_17
        MOVS     R2,#+2
        ADDS     R1,R5,#+2
        MOV      R0,#+1264
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+4
        MOVW     R0,#+1266
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDS     R1,R5,#+5
        MOVW     R0,#+1267
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+1
        ADDW     R1,R4,#+2100
        MOVW     R0,#+1247
          CFI FunCall epr_read_data
        BL       epr_read_data
        MOVS     R2,#+4
        ADD      R1,R4,#+2096
        MOVW     R0,#+1243
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDR.W    R4,??DataTable210_16
        MOVS     R2,#+1
        ADD      R1,R4,#+10
        MOVW     R0,#+1268
          CFI FunCall epr_read_data
        BL       epr_read_data
        LDRSB    R0,[R4, #+10]
        LDR.W    R1,??DataTable210_10
        STRB     R0,[R1, #+172]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock129

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable201:
        DC32     `?<Constant "%.3f F%.3f">`

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock130 Using cfiCommon0
          CFI Function _Z7pft_getv
        THUMB
// __interwork __softfp int16_t pft_get()
_Z7pft_getv:
        PUSH     {R2-R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+16
        LDR.W    R4,??DataTable210_18
        ADD      R3,SP,#+4
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        ADDW     R0,R4,#+2220
          CFI FunCall f_read
        BL       f_read
        CBZ.N    R0,??pft_get_0
        MOVS     R0,#+255
        STRB     R0,[SP, #+0]
        B.N      ??pft_get_1
??pft_get_0:
        LDR      R0,[R4, #+2084]
        LDR      R1,[SP, #+4]
        ADDS     R0,R1,R0
        STR      R0,[R4, #+2084]
??pft_get_1:
        LDRB     R0,[SP, #+0]
        POP      {R1,R2,R4,PC}    ;; return
          CFI EndBlock cfiBlock130

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202:
        DC8      0x25, 0x66, 0x00, 0x00

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_1:
        DC8      "end"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_2:
        DC32     _ZN11GCodeParser11command_ptrE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_3:
        DC32     `?<Constant "%.3f">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_4:
        DC32     mksCfg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_5:
        DC32     leveling_first_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_6:
        DC32     0x41200000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable202_7:
        DC32     lcd_wait_for_move

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock131 Using cfiCommon0
          CFI Function _Z16mks_get_commandsv
        THUMB
// __interwork __softfp bool mks_get_commands()
_Z16mks_get_commandsv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
        MOVS     R5,#+0
        LDR.W    R10,??DataTable210_18
        LDR.W    R4,??DataTable210_17
        LDR.W    R8,??DataTable207_2
        MOVS     R7,#+0
        MOV      R11,R5
        ADD      R9,SP,#+0
        ADDW     R6,R10,#+2072
        B.N      ??mks_get_commands_1
??mks_get_commands_2:
        ADR.N    R1,??DataTable207_1  ;; "end"
        ADD      R0,SP,#+0
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??mks_get_commands_3
        MOV      R11,#+1
??mks_get_commands_3:
        MOVS     R7,#+0
        MOVS     R1,#+20
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        ADDS     R5,R5,#+1
??mks_get_commands_1:
        LDR      R0,[R6, #+12]
        LDR      R1,[R10, #+2776]
        CMP      R0,R1
        BCS.W    ??mks_get_commands_4
          CFI FunCall _Z7pft_getv
        BL       _Z7pft_getv
        CMN      R0,#+1
        BEQ.N    ??mks_get_commands_4
        SXTB     R0,R0
        CMP      R0,#+10
        BNE.N    ??mks_get_commands_5
        ADD      R2,SP,#+0
        ADDS     R1,R7,R2
        MOVS     R0,#+0
        STRB     R0,[R1, #-1]
        SXTB     R5,R5
        SUBS     R0,R5,#+1
        CMP      R0,#+11
        BHI.N    ??mks_get_commands_3
        TBB      [PC, R0]
        DATA
??mks_get_commands_0:
        DC8      0x8,0x10,0x17,0x1E
        DC8      0x25,0x2C,0x33,0x3A
        DC8      0x41,0x48,0x51,0x6
        THUMB
??mks_get_commands_6:
        B.N      ??mks_get_commands_2
??mks_get_commands_7:
        B.N      ??mks_get_commands_3
??mks_get_commands_8:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STR      R0,[R10, #+2072]
        B.N      ??mks_get_commands_3
??mks_get_commands_9:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRH     R0,[R6, #+18]
        B.N      ??mks_get_commands_3
??mks_get_commands_10:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRH     R0,[R6, #+20]
        B.N      ??mks_get_commands_3
??mks_get_commands_11:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRH     R0,[R6, #+22]
        B.N      ??mks_get_commands_3
??mks_get_commands_12:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STR      R0,[R6, #+32]
        B.N      ??mks_get_commands_3
??mks_get_commands_13:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRH     R0,[R4, #+2]
        B.N      ??mks_get_commands_3
??mks_get_commands_14:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRB     R0,[R4, #+4]
        B.N      ??mks_get_commands_3
??mks_get_commands_15:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRB     R0,[R4, #+5]
        B.N      ??mks_get_commands_3
??mks_get_commands_16:
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stoul
        BL       __iar_Stoul
        STRB     R0,[R6, #+28]
        B.N      ??mks_get_commands_3
??mks_get_commands_17:
        MOVS     R2,#+0
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stod
        BL       __iar_Stod
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[R6, #+24]
        B.N      ??mks_get_commands_3
??mks_get_commands_18:
        MOVS     R2,#+0
        MOVS     R1,#+0
        ADD      R0,SP,#+0
          CFI FunCall __iar_Stod
        BL       __iar_Stod
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        STRB     R0,[R8, #+172]
        LDR.N    R1,??DataTable210_16
        LDRB     R0,[R8, #+172]
        STRB     R0,[R1, #+10]
        B.N      ??mks_get_commands_3
??mks_get_commands_5:
        STRB     R0,[R7, R9]
        ADDS     R0,R7,#+1
        UXTH     R7,R0
        CMP      R7,#+20
        BLT.W    ??mks_get_commands_1
??mks_get_commands_4:
        MOV      R0,R11
        B.W      ?Subroutine5
          CFI EndBlock cfiBlock131

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock132 Using cfiCommon0
          CFI Function mks_ReadFromFile
        THUMB
// __interwork __softfp bool mks_ReadFromFile()
mks_ReadFromFile:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+32
          CFI CFA R13+48
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        MOV      R2,R1
        MOV      R3,R1
        MOV      R5,R1
        STM      R0!,{R1-R3,R5}
        STM      R0!,{R1-R3,R5}
        LDR.N    R5,??DataTable210_18
        LDRB     R0,[R5, #+1891]
        MOVS     R4,#+0
        CBZ.N    R0,??mks_ReadFromFile_0
        LDR.N    R1,??DataTable210_11
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
??mks_ReadFromFile_0:
        LDR.N    R0,??DataTable210_12
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADDW     R6,R5,#+2220
        MOVS     R2,#+1
        ADD      R1,SP,#+0
        MOV      R0,R6
          CFI FunCall f_open
        BL       f_open
        CBNZ.N   R0,??mks_ReadFromFile_1
        STR      R0,[R5, #+2084]
        LDR      R0,[R5, #+2744]
        STR      R0,[R5, #+2776]
          CFI FunCall _Z16mks_get_commandsv
        BL       _Z16mks_get_commandsv
        MOV      R4,R0
        MOV      R0,R6
          CFI FunCall f_close
        BL       f_close
??mks_ReadFromFile_1:
        MOV      R0,R4
        ADD      SP,SP,#+32
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock132

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock133 Using cfiCommon0
          CFI Function mks_clearFile
        THUMB
// __interwork __softfp void mks_clearFile()
mks_clearFile:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        SUB      SP,SP,#+56
          CFI CFA R13+72
        LDR.N    R1,??DataTable210_19
        LDM      R1!,{R2-R6}
        ADD      R0,SP,#+32
        MOVS     R1,#+0
        STM      R0!,{R2-R6}
        ADD      R0,SP,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        MOV      R4,R1
        STM      R0!,{R1-R4}
        STM      R0!,{R1-R4}
        LDR.N    R4,??DataTable210_18
        LDRB     R0,[R4, #+1891]
        CBZ.N    R0,??mks_clearFile_0
        LDR.N    R1,??DataTable210_11
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
??mks_clearFile_0:
        LDR.N    R0,??DataTable210_12
        LDR      R1,[R0, #+0]
        ADD      R0,SP,#+0
          CFI FunCall strcat
        BL       strcat
        ADDW     R4,R4,#+2220
        MOVS     R2,#+10
        ADD      R1,SP,#+0
        MOV      R0,R4
          CFI FunCall f_open
        BL       f_open
        CBNZ.N   R0,??mks_clearFile_1
        ADD      R1,SP,#+32
        MOV      R0,R4
          CFI FunCall f_printf
        BL       f_printf
        MOV      R0,R4
          CFI FunCall f_close
        BL       f_close
??mks_clearFile_1:
        ADD      SP,SP,#+56
          CFI CFA R13+16
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock133

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock134 Using cfiCommon0
          CFI Function mks_saveFileName
        THUMB
// __interwork __softfp void mks_saveFileName(char *)
mks_saveFileName:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable210_18
        MOVS     R1,#+100
        ADDW     R0,R5,#+1916
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        MOV      R1,R4
        ADDW     R0,R5,#+1916
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R2,#+100
        ADDW     R1,R5,#+1916
        MOVW     R0,#+1277
          CFI FunCall epr_write_data
        BL       epr_write_data
        LDRB     R0,[R5, #+2068]
        CMP      R0,#+166
        BNE.N    ??mks_saveFileName_0
        LDR.N    R0,??DataTable210_10
        LDRB     R0,[R0, #+431]
        CMP      R0,#+1
        ITT      NE 
        POPNE    {R0,R4,R5,LR}
          CFI FunCall mks_clearFile
        BNE.W    mks_clearFile
??mks_saveFileName_0:
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock134

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock135 Using cfiCommon0
          CFI Function mks_adjust_extrude_speed
        THUMB
// __interwork __softfp void mks_adjust_extrude_speed()
mks_adjust_extrude_speed:
        LDR.N    R0,??DataTable207_2
        LDRSH    R1,[R0, #+688]
        CBNZ.N   R1,??mks_adjust_extrude_speed_0
        BX       LR
??mks_adjust_extrude_speed_0:
        PUSH     {R4-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+16
        LDR.N    R4,??DataTable210_20
        LDRB     R1,[R4, #+15]
        CMP      R1,#+1
        BEQ.N    ??mks_adjust_extrude_speed_1
        LDR.N    R5,??DataTable210_21
        LDRSH    R1,[R5, #+0]
        LDRSH    R3,[R0, #+688]
        MOVW     R2,#+999
        SUBS     R2,R2,R3
        CMP      R1,R2
        ITTE     LT 
        LDRHLT   R0,[R0, #+688]
        ADDLT    R0,R0,R1
        MOVWGE   R0,#+999
        STRH     R0,[R5, #+0]
        LDRSH    R6,[R5, #+0]
        MOV      R0,R6
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??DataTable210_22  ;; 0x47ae147b
        LDR.N    R3,??DataTable210_23  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??DataTable210_24
        STR      R0,[R1, #+0]
        STR      R0,[R1, #+4]
        STRH     R6,[R5, #+2]
        MOVS     R0,#+1
        STRB     R0,[R4, #+15]
        MOVS     R0,#+0
        STRH     R0,[R4, #+26]
??mks_adjust_extrude_speed_1:
        POP      {R4-R6,PC}       ;; return
          CFI EndBlock cfiBlock135

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207:
        DC32     `?<Constant "G1 Z0">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207_1:
        DC8      "end"

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207_2:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable207_3:
        DC32     0x38d1b718

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock136 Using cfiCommon0
          CFI Function mks_resume_extrude_speed
        THUMB
// __interwork __softfp void mks_resume_extrude_speed()
mks_resume_extrude_speed:
        LDR.N    R0,??DataTable210_10
        LDRSH    R1,[R0, #+688]
        CBNZ.N   R1,??mks_resume_extrude_speed_0
        BX       LR
??mks_resume_extrude_speed_0:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R4,??DataTable210_21
        LDRH     R1,[R4, #+0]
        LDRH     R0,[R0, #+688]
        SUBS     R5,R1,R0
        STRH     R5,[R4, #+0]
        SXTH     R5,R5
        MOV      R0,R5
          CFI FunCall __aeabi_i2d
        BL       __aeabi_i2d
        LDR.N    R2,??DataTable210_22  ;; 0x47ae147b
        LDR.N    R3,??DataTable210_23  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.N    R1,??DataTable210_24
        STR      R0,[R1, #+0]
        STR      R0,[R1, #+4]
        STRH     R5,[R4, #+2]
        MOVS     R0,#+0
        LDR.N    R1,??DataTable210_20
        STRB     R0,[R1, #+15]
        POP      {R0,R4,R5,PC}    ;; return
          CFI EndBlock cfiBlock136

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable208:
        DC32     command_queue

        SECTION `.text`:CODE:NOROOT(2)
          CFI Block cfiBlock137 Using cfiCommon0
          CFI Function EXTI9_5_IRQHandler
        THUMB
// __interwork __softfp void EXTI9_5_IRQHandler()
EXTI9_5_IRQHandler:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R1,??DataTable210_25  ;; 0x422281b4
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
        LDR.N    R0,??DataTable210_26  ;; 0x40010414
        LDR      R1,[R0, #+0]
        LSLS     R1,R1,#+26
        BPL.N    ??EXTI9_5_IRQHandler_0
        MOVS     R1,#+32
        STR      R1,[R0, #+0]
        LDR.N    R0,??DataTable210_18
        LDRB     R0,[R0, #+2068]
        CMP      R0,#+166
        IT       NE 
        CMPNE    R0,#+171
        BEQ.N    ??EXTI9_5_IRQHandler_1
        CMP      R0,#+169
        IT       NE 
        CMPNE    R0,#+170
        BNE.N    ??EXTI9_5_IRQHandler_2
??EXTI9_5_IRQHandler_1:
        LDR.N    R1,??DataTable210_27  ;; 0x422381a8
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
        POP      {R0,PC}
??EXTI9_5_IRQHandler_2:
        LDR.N    R0,??DataTable210_10
        LDRB     R0,[R0, #+431]
        CMP      R0,#+1
        BNE.N    ??EXTI9_5_IRQHandler_0
        LDR.N    R1,??DataTable210_28  ;; 0x42210180
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
          CFI FunCall _Z21mks_WriteToEpr_pwroffv
        BL       _Z21mks_WriteToEpr_pwroffv
        MOV      R0,#+1000
          CFI FunCall HAL_Delay
        BL       HAL_Delay
        MOVS     R0,#+0
        LDR.N    R1,??DataTable210_27  ;; 0x422381a8
        STR      R0,[R1, #+0]
??EXTI9_5_IRQHandler_3:
        B.N      ??EXTI9_5_IRQHandler_3
??EXTI9_5_IRQHandler_0:
        cpsie i
        POP      {R0,PC}          ;; return
          CFI EndBlock cfiBlock137

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock138 Using cfiCommon0
          CFI Function rgb888_2_rgb565
          CFI NoCalls
        THUMB
// __interwork __softfp uint16_t rgb888_2_rgb565(int32_t)
rgb888_2_rgb565:
        ASRS     R2,R0,#+10
        AND      R2,R2,#0x3F
        ASRS     R1,R0,#+19
        LSLS     R2,R2,#+5
        ORR      R1,R2,R1, LSL #+11
        UBFX     R0,R0,#+3,#+5
        ORRS     R0,R0,R1
        UXTH     R0,R0
        BX       LR               ;; return
          CFI EndBlock cfiBlock138

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock139 Using cfiCommon0
          CFI Function excute_m290
        THUMB
// __interwork __softfp void excute_m290(char *)
excute_m290:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??DataTable210_18
        MOVS     R1,#+96
        ADDW     R0,R5,#+2122
          CFI FunCall __aeabi_memclr
        BL       __aeabi_memclr
        ADDW     R5,R5,#+2122
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall strcpy
        BL       strcpy
        MOV      R0,R5
          CFI FunCall _ZN11GCodeParser5parseEPc
        BL       _ZN11GCodeParser5parseEPc
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z10gcode_M290v
        B.W      _Z10gcode_M290v
          CFI EndBlock cfiBlock139

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210:
        DC32     first_resu

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_1:
        DC32     card+0x77C

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_2:
        DC32     curFileName

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_3:
        DC32     logo_tick2

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_4:
        DC32     logo_tick1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_5:
        DC32     from_flash_pic

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_6:
        DC32     flash_preview_begin

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_7:
        DC32     default_preview_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_8:
        DC32     continue_print_error_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_9:
        DC32     mksTmp

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_10:
        DC32     gCfgItems

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_11:
        DC32     SD_Path

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_12:
        DC32     mks_pft_name

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_13:
        DC32     `?<Constant "start\\n">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_14:
        DC32     _ZN11Temperature18target_temperatureE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_15:
        DC32     _ZN11Temperature22target_temperature_bedE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_16:
        DC32     axis_relative_modes

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_17:
        DC32     print_time

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_18:
        DC32     card

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_19:
        DC32     `?<Constant "clear">`

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_20:
        DC32     filament_loading_time_flg

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_21:
        DC32     _ZN7Planner15flow_percentageE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_22:
        DC32     0x47ae147b

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_23:
        DC32     0x3f847ae1

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_24:
        DC32     _ZN7Planner8e_factorE

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_25:
        DC32     0x422281b4

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_26:
        DC32     0x40010414

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_27:
        DC32     0x422381a8

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable210_28:
        DC32     0x42210180

        SECTION `.text`:CODE:NOROOT(1)
          CFI Block cfiBlock140 Using cfiCommon0
          CFI Function excute_m500
          CFI FunCall _ZN14MarlinSettings4saveEv
        THUMB
// __interwork __softfp void excute_m500()
excute_m500:
        B.W      _ZN14MarlinSettings4saveEv
          CFI EndBlock cfiBlock140

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z14serialprintPGMPKc
          CFI Block cfiBlock141 Using cfiCommon0
          CFI Function _Z14serialprintPGMPKc
        THUMB
// __interwork __softfp void serialprintPGM(char const *)
_Z14serialprintPGMPKc:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R5,??serialprintPGM_0
        B.N      ??serialprintPGM_1
??serialprintPGM_2:
        UXTB     R1,R1
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??serialprintPGM_1:
        LDRSB    R1,[R4], #+1
        MOVS     R0,R1
        BNE.N    ??serialprintPGM_2
        POP      {R0,R4,R5,PC}    ;; return
        Nop      
        DATA
??serialprintPGM_0:
        DC32     Serial3
          CFI EndBlock cfiBlock141

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z34position_is_reachable_IS_KINEMATICRKfS0_
          CFI Block cfiBlock142 Using cfiCommon0
          CFI Function _Z34position_is_reachable_IS_KINEMATICRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_IS_KINEMATIC(float const &, float const &)
_Z34position_is_reachable_IS_KINEMATICRKfS0_:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        MOV      R5,R0
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0
        MOV      R4,R1
        LDRSH    R1,[R0, #+88]
        LSLS     R2,R1,#+30
        BPL.N    ??position_is_reachable_IS_KINEMATIC_1
        LDR      R6,[R0, #+84]
        MOV      R8,#+1065353216
        MOVS     R7,#+2
        MOV      R9,R8
        B.N      ??position_is_reachable_IS_KINEMATIC_2
??position_is_reachable_IS_KINEMATIC_3:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_2:
        LSLS     R0,R7,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_4
        MOV      R0,R9
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??position_is_reachable_IS_KINEMATIC_4:
        LSRS     R7,R7,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_3
        LDR      R6,[R5, #+0]
        MOVS     R7,#+2
        MOV      R5,R8
        B.N      ??position_is_reachable_IS_KINEMATIC_5
??position_is_reachable_IS_KINEMATIC_6:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_5:
        LSLS     R0,R7,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_7
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_IS_KINEMATIC_7:
        LSRS     R7,R7,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_6
        LDR      R4,[R4, #+0]
        B.N      ??position_is_reachable_IS_KINEMATIC_8
??position_is_reachable_IS_KINEMATIC_1:
        MOV      R0,#+768
        TST      R1,R0
        BEQ.N    ??position_is_reachable_IS_KINEMATIC_9
        MOV      R8,#+1065353216
        LDR.N    R6,??position_is_reachable_IS_KINEMATIC_0+0x4  ;; 0x43960000
        MOVS     R7,#+2
        MOV      R9,R8
        B.N      ??position_is_reachable_IS_KINEMATIC_10
??position_is_reachable_IS_KINEMATIC_11:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_10:
        LSLS     R0,R7,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_12
        MOV      R0,R9
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??position_is_reachable_IS_KINEMATIC_12:
        LSRS     R7,R7,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_11
        LDR      R1,[R5, #+0]
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0x8  ;; 0xc2c80000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOVS     R7,#+2
        MOV      R5,R8
        B.N      ??position_is_reachable_IS_KINEMATIC_13
??position_is_reachable_IS_KINEMATIC_14:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??position_is_reachable_IS_KINEMATIC_13:
        LSLS     R0,R7,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_15
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??position_is_reachable_IS_KINEMATIC_15:
        LSRS     R7,R7,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_14
        LDR      R1,[R4, #+0]
        LDR.N    R0,??position_is_reachable_IS_KINEMATIC_0+0xC  ;; 0x42600000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
??position_is_reachable_IS_KINEMATIC_8:
        MOVS     R6,#+2
        B.N      ??position_is_reachable_IS_KINEMATIC_16
??position_is_reachable_IS_KINEMATIC_17:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??position_is_reachable_IS_KINEMATIC_16:
        LSLS     R0,R6,#+31
        BPL.N    ??position_is_reachable_IS_KINEMATIC_18
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??position_is_reachable_IS_KINEMATIC_18:
        LSRS     R6,R6,#+1
        BNE.N    ??position_is_reachable_IS_KINEMATIC_17
        MOV      R0,R5
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITE      LS 
        MOVLS    R0,#+1
        MOVHI    R0,#+0
??position_is_reachable_IS_KINEMATIC_9:
        POP      {R1,R4-R9,PC}    ;; return
        Nop      
        DATA
??position_is_reachable_IS_KINEMATIC_0:
        DC32     mksCfg
        DC32     0x43960000
        DC32     0xc2c80000
        DC32     0x42600000
          CFI EndBlock cfiBlock142

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
          CFI Block cfiBlock143 Using cfiCommon0
          CFI Function _Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_by_probe_IS_KINEMATIC(float const &, float const &)
_Z43position_is_reachable_by_probe_IS_KINEMATICRKfS0_:
        PUSH     {R2-R6,LR}
          CFI R14 Frame(CFA, -4)
          CFI R6 Frame(CFA, -8)
          CFI R5 Frame(CFA, -12)
          CFI R4 Frame(CFA, -16)
          CFI CFA R13+24
        MOV      R4,R0
        MOV      R5,R1
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CBZ.N    R0,??position_is_reachable_by_probe_IS_KINEMATIC_0
        LDR.N    R6,??position_is_reachable_by_probe_IS_KINEMATIC_1
        LDR      R0,[R4, #+0]
        LDR      R1,[R6, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R6, #+112]
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+4]
        ADD      R1,SP,#+4
        ADD      R0,SP,#+0
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
??position_is_reachable_by_probe_IS_KINEMATIC_0:
        POP      {R1,R2,R4-R6,PC}  ;; return
        DATA
??position_is_reachable_by_probe_IS_KINEMATIC_1:
        DC32     mksCfg
          CFI EndBlock cfiBlock143

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z34position_is_reachable_IS_CARTESIANRKfS0_
          CFI Block cfiBlock144 Using cfiCommon0
          CFI Function _Z34position_is_reachable_IS_CARTESIANRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_IS_CARTESIAN(float const &, float const &)
_Z34position_is_reachable_IS_CARTESIANRKfS0_:
        PUSH     {R2-R9,R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
        LDR      R0,[R0, #+0]
        MOV      R7,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R6,??position_is_reachable_IS_CARTESIAN_0
        LDR.W    R8,??position_is_reachable_IS_CARTESIAN_0+0x4  ;; 0xd2f1a9fc
        LDR.W    R9,??position_is_reachable_IS_CARTESIAN_0+0x8  ;; 0xbf50624d
        MOV      R4,R0
        LDR      R0,[R6, #+8]
        MOV      R5,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R6, #+20]
        LDR.W    R11,??position_is_reachable_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R7, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        LDR      R0,[R6, #+12]
        MOV      R5,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_IS_CARTESIAN_1
        LDR      R0,[R6, #+24]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        IT       LS 
        MOVLS    R0,#+1
        BLS.N    ??position_is_reachable_IS_CARTESIAN_2
??position_is_reachable_IS_CARTESIAN_1:
        MOVS     R0,#+0
??position_is_reachable_IS_CARTESIAN_2:
        POP      {R1,R2,R4-R9,R11,PC}  ;; return
        Nop      
        DATA
??position_is_reachable_IS_CARTESIAN_0:
        DC32     mksCfg
        DC32     0xd2f1a9fc
        DC32     0xbf50624d
        DC32     0x3f50624d
          CFI EndBlock cfiBlock144

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
          CFI Block cfiBlock145 Using cfiCommon0
          CFI Function _Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_
        THUMB
// __interwork __softfp bool position_is_reachable_by_probe_IS_CARTESIAN(float const &, float const &)
_Z43position_is_reachable_by_probe_IS_CARTESIANRKfS0_:
        PUSH     {R2-R9,R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+40
        LDR      R0,[R0, #+0]
        MOV      R7,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.N    R6,??position_is_reachable_by_probe_IS_CARTESIAN_0
        LDR.W    R8,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x4  ;; 0xd2f1a9fc
        LDR.W    R9,??position_is_reachable_by_probe_IS_CARTESIAN_0+0x8  ;; 0xbf50624d
        MOV      R4,R0
        LDR      R0,[R6, #+0]
        MOV      R5,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R6, #+4]
        LDR.W    R11,??position_is_reachable_by_probe_IS_CARTESIAN_0+0xC  ;; 0x3f50624d
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R7, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        LDR      R0,[R6, #+8]
        MOV      R5,R1
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
        MOV      R1,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        BHI.N    ??position_is_reachable_by_probe_IS_CARTESIAN_1
        LDR      R0,[R6, #+12]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_cdrcmple
        BL       __aeabi_cdrcmple
        IT       LS 
        MOVLS    R0,#+1
        BLS.N    ??position_is_reachable_by_probe_IS_CARTESIAN_2
??position_is_reachable_by_probe_IS_CARTESIAN_1:
        MOVS     R0,#+0
??position_is_reachable_by_probe_IS_CARTESIAN_2:
        POP      {R1,R2,R4-R9,R11,PC}  ;; return
        Nop      
        DATA
??position_is_reachable_by_probe_IS_CARTESIAN_0:
        DC32     mksTmp
        DC32     0xd2f1a9fc
        DC32     0xbf50624d
        DC32     0x3f50624d
          CFI EndBlock cfiBlock145

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner11buffer_lineEfffRKfS1_h
          CFI Block cfiBlock146 Using cfiCommon0
          CFI Function _ZN7Planner11buffer_lineEfffRKfS1_h
        THUMB
// __interwork __softfp void Planner::buffer_line(float, float, float, float const &, float const &, uint8_t)
_ZN7Planner11buffer_lineEfffRKfS1_h:
        PUSH     {R0-R2,R4,R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+24
        LDR.N    R0,??buffer_line_0
        LDRB     R1,[R0, #+66]
        SUB      SP,SP,#+8
          CFI CFA R13+32
        MOVS     R2,#+46
        LDR      R5,[SP, #+32]
        MOV      R4,R3
        TST      R1,R2
        BEQ.N    ??buffer_line_1
        ADDS     R0,R0,#+66
        LDRSH    R0,[R0, #+22]
        CMP      R0,#+1
        IT       NE 
        CMPNE    R0,#+4
        BNE.N    ??buffer_line_1
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??buffer_line_1:
        LDR      R0,[SP, #+36]
        STR      R0,[SP, #+4]
        STR      R5,[SP, #+0]
        MOV      R3,R4
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+12
        POP      {R4,R5,PC}       ;; return
        Nop      
        DATA
??buffer_line_0:
        DC32     mksCfg
          CFI EndBlock cfiBlock146

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
          CFI Block cfiBlock147 Using cfiCommon0
          CFI Function _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        THUMB
// __interwork __softfp void Planner::buffer_line_kinematic(float const (&)[4], float const &, uint8_t)
_ZN7Planner21buffer_line_kinematicERA4_KfRS0_h:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        MOV      R4,R0
        SUB      SP,SP,#+20
          CFI CFA R13+40
        LDR      R0,[R4, #+0]
        LDR.N    R7,??buffer_line_kinematic_0
        STR      R0,[SP, #+8]
        MOV      R5,R1
        ADD      R0,SP,#+8
        LDR      R1,[R4, #+4]
        STR      R1,[R0, #+4]
        MOV      R6,R2
        LDR      R1,[R4, #+8]
        STR      R1,[R0, #+8]
        MOVS     R1,#+46
        LDRB     R0,[R7, #+66]
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_1
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14apply_levelingERfS0_S0_
        BL       _ZN7Planner14apply_levelingERfS0_S0_
??buffer_line_kinematic_1:
        ADD      R0,R7,#+66
        MOVW     R1,#+770
        LDRSH    R0,[R0, #+22]
        TST      R0,R1
        BEQ.N    ??buffer_line_kinematic_2
        CMP      R0,#+256
        ADD      R0,SP,#+8
        BNE.N    ??buffer_line_kinematic_3
          CFI FunCall _Z31inverse_kinematics_MORGAN_SCARAPKf
        BL       _Z31inverse_kinematics_MORGAN_SCARAPKf
        B.N      ??buffer_line_kinematic_4
??buffer_line_kinematic_3:
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??buffer_line_kinematic_4:
        LDR.N    R1,??buffer_line_kinematic_0+0x4
        LDRB     R0,[R1, #+344]
        CMP      R0,#+1
        BNE.N    ??buffer_line_kinematic_5
        LDR      R0,[R4, #+8]
        LDR      R1,[R1, #+680]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??buffer_line_kinematic_5
        LDR.N    R0,??buffer_line_kinematic_0+0x8
        LDR      R1,[R4, #+12]
        ADD      R0,R0,R6, LSL #+2
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall lroundf
        BL       lroundf
        LDR.N    R1,??buffer_line_kinematic_0+0xC
        STR      R0,[R1, #+12]
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+40
??buffer_line_kinematic_5:
        LDR.N    R0,??buffer_line_kinematic_0+0x10
        ADD      R2,R0,#+68
        ADD      R1,R0,#+64
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        ADD      R3,R4,#+12
        ADDS     R0,R0,#+60
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+40
??buffer_line_kinematic_2:
        STR      R6,[SP, #+4]
        STR      R5,[SP, #+0]
        ADD      R3,R4,#+12
        ADD      R2,SP,#+16
        ADD      R1,SP,#+12
        ADD      R0,SP,#+8
          CFI FunCall _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        BL       _ZN7Planner14buffer_segmentERKfS1_S1_S1_S1_h
        ADD      SP,SP,#+20
          CFI CFA R13+20
        POP      {R4-R7,PC}       ;; return
        Nop      
        DATA
??buffer_line_kinematic_0:
        DC32     mksCfg
        DC32     gCfgItems
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     _ZN7Planner8positionE
        DC32     axis_homed
          CFI EndBlock cfiBlock147

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature12setTargetBedEf
          CFI Block cfiBlock148 Using cfiCommon0
          CFI Function _ZN11Temperature12setTargetBedEf
        THUMB
// __interwork __softfp void Temperature::setTargetBed(float)
_ZN11Temperature12setTargetBedEf:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOV      R4,R0
        LDR.N    R0,??setTargetBed_0
        LDRSH    R5,[R0, #+50]
        MOV      R0,R5
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??setTargetBed_1
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R5,R0
??setTargetBed_1:
        LDR.N    R0,??setTargetBed_0+0x4
        STRH     R5,[R0, #+0]
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature18start_watching_bedEv
        B.W      _ZN11Temperature18start_watching_bedEv
        DATA
??setTargetBed_0:
        DC32     mksCfg
        DC32     _ZN11Temperature22target_temperature_bedE
          CFI EndBlock cfiBlock148

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11Temperature13babystep_axisE8AxisEnums
          CFI Block cfiBlock149 Using cfiCommon0
          CFI Function _ZN11Temperature13babystep_axisE8AxisEnums
          CFI NoCalls
        THUMB
// __interwork __softfp void Temperature::babystep_axis(AxisEnum, int16_t)
_ZN11Temperature13babystep_axisE8AxisEnums:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        MOV      R4,R0
        LDR.N    R2,??babystep_axis_0
        ADDS     R2,R4,R2
        LDRB     R2,[R2, #+4]
        CMP      R2,#+0
        BEQ.N    ??babystep_axis_1
        LDR.N    R2,??babystep_axis_0+0x4
        LDRSH    R3,[R2, #+88]
        MOVS     R2,#+252
        TST      R3,R2
        BEQ.N    ??babystep_axis_2
        LDR.N    R4,??babystep_axis_0+0x8
        LDRB     R6,[R4, #+16]
        LDRB     R5,[R4, #+17]
        CMP      R0,R6
        BNE.N    ??babystep_axis_3
        LDR.N    R2,??babystep_axis_0+0xC
        LDR      R7,[R2, R6, LSL #+2]
        ADD      R7,R7,R1, LSL #+1
        STR      R7,[R2, R6, LSL #+2]
        LDR      R12,[R2, R5, LSL #+2]
        ADD      R7,R12,R1, LSL #+1
        STR      R7,[R2, R5, LSL #+2]
??babystep_axis_3:
        CMP      R0,R5
        BNE.N    ??babystep_axis_4
        LSLS     R7,R1,#+1
        MOVS     R2,#+168
        MOV      R12,R7
        TST      R3,R2
        IT       NE 
        RSBNE    R12,R12,#+0
        LDR.N    R2,??babystep_axis_0+0xC
        LDR      LR,[R2, R6, LSL #+2]
        ADD      R12,R12,LR
        STR      R12,[R2, R6, LSL #+2]
        MOVS     R6,#+168
        TST      R3,R6
        IT       NE 
        RSBNE    R7,R7,#+0
        LDR      R3,[R2, R5, LSL #+2]
        SUBS     R3,R3,R7
        STR      R3,[R2, R5, LSL #+2]
??babystep_axis_4:
        LDRB     R3,[R4, #+18]
        CMP      R0,R3
        BNE.N    ??babystep_axis_1
        LDR.N    R2,??babystep_axis_0+0xC
        LDR      R0,[R2, R3, LSL #+2]
        ADDS     R0,R1,R0
        STR      R0,[R2, R3, LSL #+2]
        POP      {R4-R7,PC}
??babystep_axis_2:
        LDR.N    R2,??babystep_axis_0+0xC
        LDR      R0,[R2, R4, LSL #+2]
        ADDS     R0,R1,R0
        STR      R0,[R2, R4, LSL #+2]
??babystep_axis_1:
        POP      {R4-R7,PC}       ;; return
        DATA
??babystep_axis_0:
        DC32     axis_homed
        DC32     mksCfg
        DC32     mksTmp
        DC32     _ZN11Temperature13babystepsTodoE
          CFI EndBlock cfiBlock149

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZNK10duration_t8toStringEPc
          CFI Block cfiBlock150 Using cfiCommon0
          CFI Function _ZNK10duration_t8toStringEPc
        THUMB
// __interwork __softfp void duration_t::toString(char *) const
_ZNK10duration_t8toStringEPc:
        PUSH     {R4-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+20
        MOV      R2,R0
        SUB      SP,SP,#+12
          CFI CFA R13+32
        MOV      R0,R1
        LDR      R1,[R2, #+0]
        MOVS     R3,#+60
        UDIV     R1,R1,R3
        UDIV     R3,R1,R3
        MOVS     R1,#+24
        UDIV     R5,R3,R1
        UXTH     R4,R5
        MOVW     R1,#+365
        SDIV     R6,R4,R1
        MOVW     R7,#+365
        UXTB     R1,R6
        MLS      R4,R7,R6,R4
        ADD      R6,R5,R5, LSL #+1
        SUB      R5,R3,R6, LSL #+3
        LDR      R3,[R2, #+0]
        MOVS     R2,#+60
        UDIV     R6,R3,R2
        UDIV     R2,R6,R2
        RSB      R7,R2,R2, LSL #+4
        SUB      R2,R6,R7, LSL #+2
        RSB      R7,R6,R6, LSL #+4
        SUB      R3,R3,R7, LSL #+2
        CBZ.N    R1,??toString_0
        STR      R2,[SP, #+4]
        STR      R3,[SP, #+8]
        MOV      R2,R1
        STR      R5,[SP, #+0]
        MOV      R3,R4
        LDR.N    R1,??toString_1
        B.N      ??toString_2
??toString_0:
        CBZ.N    R4,??toString_3
        STR      R3,[SP, #+4]
        STR      R2,[SP, #+0]
        MOV      R3,R5
        MOV      R2,R4
        LDR.N    R1,??toString_1+0x4
        B.N      ??toString_2
??toString_3:
        CBZ.N    R5,??toString_4
        LDR.N    R1,??toString_1+0x8
        STR      R3,[SP, #+0]
        MOV      R3,R2
        MOV      R2,R5
??toString_2:
          CFI FunCall sprintf
        BL       sprintf
        ADD      SP,SP,#+12
          CFI CFA R13+20
        POP      {R4-R7,PC}
          CFI CFA R13+32
??toString_4:
        CBZ.N    R2,??toString_5
        ADD      SP,SP,#+12
          CFI CFA R13+20
        POP      {R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        LDR.N    R1,??toString_1+0xC
          CFI FunCall sprintf
        B.W      sprintf
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??toString_5:
        LDR.N    R1,??toString_1+0x10
        ADD      SP,SP,#+12
          CFI CFA R13+20
        POP      {R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOV      R2,R3
          CFI FunCall sprintf
        B.W      sprintf
        Nop      
        DATA
??toString_1:
        DC32     _ZZNK10duration_t8toStringEPcEs
        DC32     _ZZNK10duration_t8toStringEPcEs_0
        DC32     _ZZNK10duration_t8toStringEPcEs_1
        DC32     _ZZNK10duration_t8toStringEPcEs_2
        DC32     _ZZNK10duration_t8toStringEPcEs_3
          CFI EndBlock cfiBlock150

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser4seenEc
          CFI Block cfiBlock151 Using cfiCommon0
          CFI Function _ZN11GCodeParser4seenEc
          CFI NoCalls
        THUMB
// __interwork __softfp bool GCodeParser::seen(char)
_ZN11GCodeParser4seenEc:
        SUB      R1,R0,#+65
        UXTB     R1,R1
        CMP      R1,#+26
        BCC.N    ??seen_0
        MOVS     R0,#+0
        BX       LR
??seen_0:
        LSRS     R0,R1,#+3
        LDR.N    R2,??seen_1
        LDRB     R0,[R0, R2]
        AND      R2,R1,#0x7
        LSRS     R0,R0,R2
        ANDS     R0,R0,#0x1
        BEQ.N    ??seen_2
        LDR.N    R2,??seen_1+0x4
        LDRB     R1,[R1, R2]
        LDR.N    R2,??seen_1+0x8
        CBZ.N    R1,??seen_3
        LDR.N    R3,??seen_1+0xC
        LDR      R3,[R3, #+0]
        ADDS     R1,R1,R3
??seen_3:
        STR      R1,[R2, #+0]
??seen_2:
        BX       LR               ;; return
        Nop      
        DATA
??seen_1:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
          CFI EndBlock cfiBlock151

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser7seenvalEc
          CFI Block cfiBlock152 Using cfiCommon0
          CFI Function _ZN11GCodeParser7seenvalEc
        THUMB
// __interwork __softfp bool GCodeParser::seenval(char)
_ZN11GCodeParser7seenvalEc:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTTT    NE 
        LDRNE.N  R0,??seenval_0
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        MOVNE    R0,#+1
        POP      {R1,PC}          ;; return
        DATA
??seenval_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock152

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser11value_floatEv
          CFI Block cfiBlock153 Using cfiCommon0
          CFI Function _ZN11GCodeParser11value_floatEv
        THUMB
// __interwork __softfp float GCodeParser::value_float()
_ZN11GCodeParser11value_floatEv:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        LDR.N    R3,??value_float_0
        LDR      R0,[R3, #+0]
        CBZ.N    R0,??value_float_1
        MOV      R4,R0
        B.N      ??value_float_2
??value_float_3:
        ADDS     R4,R4,#+1
??value_float_2:
        LDRSB    R5,[R4, #+0]
        CMP      R5,#+0
        IT       NE 
        CMPNE    R5,#+32
        BNE.N    ??value_float_4
        MOVS     R2,#+0
        MOVS     R1,#+0
          CFI FunCall __iar_Stod
        BL       __iar_Stod
        B.N      ??value_float_5
??value_float_4:
        CMP      R5,#+69
        IT       NE 
        CMPNE    R5,#+101
        BNE.N    ??value_float_3
        MOVS     R0,#+0
        STRB     R0,[R4, #+0]
        MOV      R1,R0
        LDR      R0,[R3, #+0]
        MOVS     R2,#+0
          CFI FunCall __iar_Stod
        BL       __iar_Stod
        STRB     R5,[R4, #+0]
??value_float_5:
        POP      {R2,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_d2f
        B.W      __aeabi_d2f
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??value_float_1:
        POP      {R1,R4,R5,PC}    ;; return
        Nop      
        DATA
??value_float_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock153

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN11GCodeParser10value_byteEv
          CFI Block cfiBlock154 Using cfiCommon0
          CFI Function _ZN11GCodeParser10value_byteEv
        THUMB
// __interwork __softfp uint8_t GCodeParser::value_byte()
_ZN11GCodeParser10value_byteEv:
        PUSH     {R4,LR}
          CFI R14 Frame(CFA, -4)
          CFI R4 Frame(CFA, -8)
          CFI CFA R13+8
        LDR.N    R4,??value_byte_0
        LDR      R0,[R4, #+0]
        CBZ.N    R0,??value_byte_1
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        CMP      R0,#+0
        BMI.N    ??value_byte_1
        LDR      R0,[R4, #+0]
        CBZ.N    R0,??value_byte_1
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        CMP      R0,#+255
        IT       GT 
        MOVGT    R0,#+255
        BGT.N    ??value_byte_2
        LDR      R0,[R4, #+0]
        CBZ.N    R0,??value_byte_1
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??value_byte_2
??value_byte_1:
        MOVS     R0,#+0
??value_byte_2:
        UXTB     R0,R0
        POP      {R4,PC}          ;; return
        Nop      
        DATA
??value_byte_0:
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock154

        SECTION `.text`:CODE:REORDER:NOROOT(1)
        SECTION_GROUP _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
          CFI Block cfiBlock155 Using cfiCommon0
          CFI Function _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        THUMB
// __interwork __softfp void incremental_LSF(linear_fit_data *, float const &, float const &, float const &)
_Z15incremental_LSFP15linear_fit_dataRKfS2_S2_:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R5,R0
        MOV      R7,R1
        LDR      R1,[R5, #+0]
        LDR      R0,[R7, #+0]
        MOV      R6,R2
        MOV      R8,R3
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+0]
        LDR      R1,[R5, #+4]
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+4]
        LDR      R1,[R5, #+8]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+8]
        MOV      R9,#+1065353216
        LDR      R11,[R7, #+0]
        MOVS     R4,#+2
        MOV      R10,R9
        B.N      ??incremental_LSF_0
??incremental_LSF_1:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??incremental_LSF_0:
        LSLS     R0,R4,#+31
        BPL.N    ??incremental_LSF_2
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_2:
        LSRS     R4,R4,#+1
        BNE.N    ??incremental_LSF_1
        LDR      R0,[R5, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+12]
        MOVS     R4,#+2
        LDR      R11,[R6, #+0]
        MOV      R10,R9
        B.N      ??incremental_LSF_3
??incremental_LSF_4:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??incremental_LSF_3:
        LSLS     R0,R4,#+31
        BPL.N    ??incremental_LSF_5
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_5:
        LSRS     R4,R4,#+1
        BNE.N    ??incremental_LSF_4
        LDR      R0,[R5, #+16]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+16]
        MOVS     R4,#+2
        LDR      R10,[R8, #+0]
        B.N      ??incremental_LSF_6
??incremental_LSF_7:
        MOV      R0,R10
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??incremental_LSF_6:
        LSLS     R0,R4,#+31
        BPL.N    ??incremental_LSF_8
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??incremental_LSF_8:
        LSRS     R4,R4,#+1
        BNE.N    ??incremental_LSF_7
        LDR      R0,[R5, #+20]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+20]
        LDR      R1,[R7, #+0]
        LDR      R0,[R6, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+24]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+24]
        LDR      R1,[R7, #+0]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+28]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+28]
        LDR      R1,[R6, #+0]
        LDR      R0,[R8, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[R5, #+32]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+32]
        LDR      R0,[R7, #+0]
        BIC      R1,R0,#0x80000000
        LDR      R0,[R5, #+36]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITT      CC 
        LDRCC    R0,[R7, #+0]
        BICCC    R0,R0,#0x80000000
        STR      R0,[R5, #+36]
        LDR      R0,[R6, #+0]
        BIC      R1,R0,#0x80000000
        LDR      R0,[R5, #+40]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITT      CC 
        LDRCC    R0,[R6, #+0]
        BICCC    R0,R0,#0x80000000
        STR      R0,[R5, #+40]
        MOV      R0,#+1065353216
        LDR      R1,[R5, #+56]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+56]
        POP      {R0,R4-R11,PC}   ;; return
          CFI EndBlock cfiBlock155

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling18mesh_index_to_xposEh
          CFI Block cfiBlock156 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling18mesh_index_to_xposEh
        THUMB
// __interwork __softfp float unified_bed_leveling::mesh_index_to_xpos(uint8_t)
_ZN20unified_bed_leveling18mesh_index_to_xposEh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R8,R0
        LDR.N    R6,??mesh_index_to_xpos_0
        LDRB     R7,[R6, #+96]
        ADD      R0,R6,#+8
        MOVW     R2,#+770
        LDRH     R1,[R0, #+80]
        TST      R1,R2
        BEQ.N    ??mesh_index_to_xpos_1
        CMP      R8,R7
        BCC.N    ??mesh_index_to_xpos_2
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        LDR.N    R4,??mesh_index_to_xpos_0+0x4
        MOV      R5,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,R8
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R8,R0
        LDR      R0,[R4, #+4]
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R7,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R8
        B.N      ??mesh_index_to_xpos_3
??mesh_index_to_xpos_1:
        CMP      R8,R7
        BCS.N    ??mesh_index_to_xpos_4
??mesh_index_to_xpos_2:
        LDR.N    R0,??mesh_index_to_xpos_0+0x8
        LDR      R0,[R0, R8, LSL #+2]
        POP      {R1,R4-R11,PC}
??mesh_index_to_xpos_4:
        LDR      R5,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        ADD      R0,R6,#+96
        LDR      R11,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R6,R0
        IT       CC 
        MOVCC    R6,R4
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        MOV      R0,R5
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R4,R1
        MOV      R0,R8
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        MOV      R0,R4
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R7,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
??mesh_index_to_xpos_3:
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
        DATA
??mesh_index_to_xpos_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     _ZN20unified_bed_leveling19_mesh_index_to_xposE
          CFI EndBlock cfiBlock156

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN20unified_bed_leveling18mesh_index_to_yposEh
          CFI Block cfiBlock157 Using cfiCommon0
          CFI Function _ZN20unified_bed_leveling18mesh_index_to_yposEh
        THUMB
// __interwork __softfp float unified_bed_leveling::mesh_index_to_ypos(uint8_t)
_ZN20unified_bed_leveling18mesh_index_to_yposEh:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOV      R8,R0
        LDR.N    R6,??mesh_index_to_ypos_0
        LDRB     R7,[R6, #+97]
        ADD      R0,R6,#+12
        MOVW     R2,#+770
        LDRH     R1,[R0, #+76]
        TST      R1,R2
        BEQ.N    ??mesh_index_to_ypos_1
        CMP      R8,R7
        BCC.N    ??mesh_index_to_ypos_2
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        LDR.N    R4,??mesh_index_to_ypos_0+0x4
        MOV      R5,R0
        LDR      R0,[R4, #+8]
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R6,R0
        MOV      R0,R8
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R8,R0
        LDR      R0,[R4, #+12]
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R7,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R8
        B.N      ??mesh_index_to_ypos_3
??mesh_index_to_ypos_1:
        CMP      R8,R7
        BCS.N    ??mesh_index_to_ypos_4
??mesh_index_to_ypos_2:
        LDR.N    R0,??mesh_index_to_ypos_0+0x8
        LDR      R0,[R0, R8, LSL #+2]
        POP      {R1,R4-R11,PC}
??mesh_index_to_ypos_4:
        LDR      R5,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R10,R0
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R11,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R6,R0
        IT       CC 
        MOVCC    R6,R4
        MOV      R0,#+1073741824
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        MOV      R0,R5
        MOV      R1,R11
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R4,R1
        MOV      R0,R8
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R5,R0
        MOV      R0,R4
        MOV      R1,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R4,R0
        SUBS     R0,R7,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R5
??mesh_index_to_ypos_3:
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R6
        POP      {R2,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall __aeabi_fadd
        B.W      __aeabi_fadd
        DATA
??mesh_index_to_ypos_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     _ZN20unified_bed_leveling19_mesh_index_to_yposE
          CFI EndBlock cfiBlock157

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_xERKf
          CFI Block cfiBlock158 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_x(float const &)
_ZN17mesh_bed_leveling12cell_index_xERKf:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R6,??cell_index_x_0
        MOV      R4,R0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R8,R0
        ADD      R0,R6,#+8
        MOVW     R2,#+770
        LDRH     R1,[R0, #+80]
        TST      R1,R2
        BEQ.N    ??cell_index_x_1
        LDR.N    R7,??cell_index_x_0+0x4
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+4]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
        B.N      ??cell_index_x_2
??cell_index_x_1:
        LDR      R5,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        ADD      R0,R6,#+96
        LDR      R9,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R7,R0
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R0,R5
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R8,R1
        LDR      R0,[R4, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R8
        MOV      R1,R7
??cell_index_x_2:
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_x_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        SXTB     R0,R0
        MOVS     R1,R0
        IT       MI 
        MOVMI    R0,#+0
        BMI.N    ??cell_index_x_3
        LDRB     R2,[R6, #+96]
        SUBS     R3,R2,#+2
        CMP      R3,R0
        IT       LT 
        SUBLT    R0,R2,#+2
??cell_index_x_3:
        SXTB     R0,R0
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??cell_index_x_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3ff00000
          CFI EndBlock cfiBlock158

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling12cell_index_yERKf
          CFI Block cfiBlock159 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling12cell_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::cell_index_y(float const &)
_ZN17mesh_bed_leveling12cell_index_yERKf:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R6,??cell_index_y_0
        MOV      R4,R0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R8,R0
        ADD      R0,R6,#+12
        MOVW     R2,#+770
        LDRH     R1,[R0, #+76]
        TST      R1,R2
        BEQ.N    ??cell_index_y_1
        LDR.N    R7,??cell_index_y_0+0x4
        LDR      R0,[R7, #+8]
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R9,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+12]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
        B.N      ??cell_index_y_2
??cell_index_y_1:
        LDR      R5,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R7,R0
        LDR      R9,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R7,R0
        MOV      R0,#+1073741824
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R0,R5
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R8,R1
        LDR      R0,[R4, #+0]
        MOV      R1,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        MOV      R0,R8
        MOV      R1,R7
??cell_index_y_2:
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??cell_index_y_0+0x8  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        SXTB     R0,R0
        MOVS     R1,R0
        IT       MI 
        MOVMI    R0,#+0
        BMI.N    ??cell_index_y_3
        LDRB     R2,[R6, #+97]
        SUBS     R3,R2,#+2
        CMP      R3,R0
        IT       LT 
        SUBLT    R0,R2,#+2
??cell_index_y_3:
        SXTB     R0,R0
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??cell_index_y_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3ff00000
          CFI EndBlock cfiBlock159

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_xERKf
          CFI Block cfiBlock160 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_xERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_x(float const &)
_ZN17mesh_bed_leveling13probe_index_xERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R6,??probe_index_x_0
        MOV      R7,R0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R9,R0
        ADD      R0,R6,#+8
        MOVW     R2,#+770
        LDRH     R1,[R0, #+80]
        TST      R1,R2
        BEQ.N    ??probe_index_x_1
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R4,??probe_index_x_0+0x4
        MOV      R5,R0
        LDR      R0,[R4, #+0]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R4, #+4]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R7,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0x8  ;; 0x3fe00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R7
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R7,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R7
        MOV      R3,R9
        B.N      ??probe_index_x_2
??probe_index_x_1:
        LDR      R5,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        ADD      R0,R6,#+96
        LDR      R10,[R0, #+12]
        LDR      R0,[R6, #+8]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R4,R0
        MOV      R0,#+1073741824
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R8,R1
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR      R0,[R7, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R7,R0
        MOV      R11,R1
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_x_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R7
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R7,R0
        MOV      R11,R1
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_x_0+0xC  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R7
        MOV      R3,R11
??probe_index_x_2:
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        SXTB     R0,R0
        MOVS     R1,R0
        BMI.N    ??probe_index_x_3
        LDRB     R2,[R6, #+96]
        SUBS     R2,R2,#+1
        CMP      R2,R0
        BGE.N    ??probe_index_x_4
??probe_index_x_3:
        MOV      R0,#-1
??probe_index_x_4:
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??probe_index_x_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock160

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _ZN17mesh_bed_leveling13probe_index_yERKf
          CFI Block cfiBlock161 Using cfiCommon0
          CFI Function _ZN17mesh_bed_leveling13probe_index_yERKf
        THUMB
// __interwork __softfp int8_t mesh_bed_leveling::probe_index_y(float const &)
_ZN17mesh_bed_leveling13probe_index_yERKf:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R6,??probe_index_y_0
        MOV      R7,R0
        LDRB     R0,[R6, #+152]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R9,R0
        ADD      R0,R6,#+12
        MOVW     R2,#+770
        LDRSH    R1,[R0, #+76]
        CMP      R1,R2
        BNE.N    ??probe_index_y_1
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.N    R4,??probe_index_y_0+0x4
        MOV      R5,R0
        LDR      R0,[R4, #+8]
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R8,R0
        LDR      R0,[R4, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R4,R0
        MOV      R5,R1
        LDR      R0,[R7, #+0]
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R7,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0x8  ;; 0x3fe00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R7
        MOV      R3,R9
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R7,R0
        MOV      R9,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
        MOV      R2,R4
        MOV      R3,R5
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R7
        MOV      R3,R9
        B.N      ??probe_index_y_2
??probe_index_y_1:
        LDR      R5,[R0, #+12]
        MOV      R0,#+1056964608
        MOV      R1,R5
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        MOV      R1,R8
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R4,R0
        LDR      R10,[R6, #+112]
        LDR      R0,[R6, #+12]
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R4,R0
        MOV      R0,#+1073741824
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R8,R0
        MOV      R0,R5
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CS 
        MOVCS    R8,R1
        LDRB     R0,[R6, #+97]
        SUBS     R0,R0,#+1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R5,R0
        LDR      R0,[R7, #+0]
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R7,R0
        MOV      R11,R1
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??probe_index_y_0+0x8  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R2,R7
        MOV      R3,R11
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOV      R7,R0
        MOV      R11,R1
        MOV      R0,R8
        MOV      R1,R4
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOVS     R0,#+0
        LDR.N    R1,??probe_index_y_0+0xC  ;; 0x3ff00000
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
        MOV      R2,R7
        MOV      R3,R11
??probe_index_y_2:
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        SXTB     R0,R0
        MOVS     R1,R0
        BMI.N    ??probe_index_y_3
        LDRB     R2,[R6, #+97]
        SUBS     R2,R2,#+1
        CMP      R2,R0
        BGE.N    ??probe_index_y_4
??probe_index_y_3:
        MOV      R0,#-1
??probe_index_y_4:
        POP      {R1,R4-R11,PC}   ;; return
        DATA
??probe_index_y_0:
        DC32     mksCfg
        DC32     mksTmp
        DC32     0x3fe00000
        DC32     0x3ff00000
          CFI EndBlock cfiBlock161

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z15_commit_commandb
          CFI Block cfiBlock162 Using cfiCommon0
          CFI Function _Z15_commit_commandb
          CFI NoCalls
        THUMB
_Z15_commit_commandb:
        LDR.N    R1,??_commit_command_0
        LDR.N    R3,??_commit_command_0+0x4
        LDRB     R2,[R1, #+8]
        ADDS     R3,R2,R3
        STRB     R0,[R3, #+20]
        ADDS     R0,R2,#+1
        UXTB     R0,R0
        CMP      R0,#+4
        IT       GE 
        MOVGE    R0,#+0
        STRB     R0,[R1, #+8]
        LDRB     R0,[R1, #+6]
        ADDS     R0,R0,#+1
        STRB     R0,[R1, #+6]
        BX       LR               ;; return
        Nop      
        DATA
??_commit_command_0:
        DC32     axis_relative_modes
        DC32     filament_loading_time_flg
          CFI EndBlock cfiBlock162

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_serial_commandsv
          CFI Block cfiBlock163 Using cfiCommon0
          CFI Function _Z19get_serial_commandsv
        THUMB
_Z19get_serial_commandsv:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R4,??get_serial_commands_0
        MOV      R5,R0
        LDRB     R0,[R4, #+6]
        CBNZ.N   R0,??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x4
          CFI FunCall _ZN10USARTClass9availableEv
        BL       _ZN10USARTClass9availableEv
        CBNZ.N   R0,??get_serial_commands_1
        LDR.N    R0,??get_serial_commands_0+0x8
        LDR      R1,[R0, #+0]
        SUBS     R1,R5,R1
        SUBS     R1,R1,#+1000
        BMI.N    ??get_serial_commands_1
        LDR.N    R6,??get_serial_commands_0+0xC
        LDRB     R1,[R6, #+0]
        CMP      R1,#+6
        ITT      LT 
        ADDLT    R1,R1,#+1
        STRBLT   R1,[R6, #+0]
        STR      R5,[R0, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_2:
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.N    ??get_serial_commands_1
        LDR.N    R1,??get_serial_commands_0+0x10
        LDRB     R1,[R1, #+0]
        CBNZ.N   R1,??get_serial_commands_1
        LDR      R1,[R6, #+8]
??get_serial_commands_3:
        LDR.N    R2,??get_serial_commands_0+0x14
        STRB     R0,[R1, R2]
        ADDS     R0,R1,#+1
        STR      R0,[R6, #+8]
??get_serial_commands_1:
        LDRB     R0,[R4, #+6]
        CMP      R0,#+4
        BGE.W    ??get_serial_commands_4
        LDR.W    R8,??get_serial_commands_0+0x4
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass4readEv
        BL       _ZN10USARTClass4readEv
        CMP      R0,#+0
        BMI.W    ??get_serial_commands_4
        LDR.N    R6,??get_serial_commands_0+0xC
        SXTB     R0,R0
        MOVS     R1,#+0
        STRB     R1,[R6, #+0]
        STRB     R1,[R6, #+1]
        CMP      R0,#+10
        IT       NE 
        CMPNE    R0,#+13
        BNE.W    ??get_serial_commands_5
        LDR.N    R1,??get_serial_commands_0+0x10
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        LDR      R1,[R6, #+8]
        CMP      R1,#+0
        BEQ.N    ??get_serial_commands_1
        LDR.W    R9,??get_serial_commands_0+0x14
        STRB     R0,[R1, R9]
        STR      R0,[R6, #+8]
        MOV      R5,R9
        B.N      ??get_serial_commands_6
??get_serial_commands_7:
        ADDS     R5,R5,#+1
??get_serial_commands_6:
        LDRSB    R0,[R5, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_serial_commands_7
        CMP      R0,#+78
        BNE.N    ??get_serial_commands_8
        MOVS     R10,R5
        BEQ.N    ??get_serial_commands_8
        LDR.N    R1,??get_serial_commands_0+0x18
        MOV      R0,R5
          CFI FunCall __iar_Strstr
        BL       __iar_Strstr
        CBZ.N    R0,??get_serial_commands_9
        MOVS     R7,#+1
        MOVS     R1,#+78
        ADDS     R0,R5,#+4
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CBZ.N    R0,??get_serial_commands_10
        MOV      R10,R0
??get_serial_commands_10:
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADD      R0,R10,#+1
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        LDR      R1,[R4, #+108]
        STR      R0,[R6, #+4]
        ADDS     R1,R1,#+1
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_11
        CBNZ.N   R7,??get_serial_commands_11
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x1C
        B.N      ??get_serial_commands_12
??get_serial_commands_9:
        MOVS     R7,#+0
        B.N      ??get_serial_commands_10
??get_serial_commands_11:
        MOVS     R1,#+42
        MOV      R0,R5
          CFI FunCall __iar_Strrchr
        BL       __iar_Strrchr
        CBZ.N    R0,??get_serial_commands_13
        SUBS     R1,R0,R5
        MOV      R2,R1
        MOVS     R7,#+0
        UXTB     R1,R1
        CBZ.N    R1,??get_serial_commands_14
        UXTB     R2,R2
        ADDS     R1,R2,R5
        SUBS     R1,R1,#+1
??get_serial_commands_15:
        LDRSB    R3,[R1], #-1
        EORS     R7,R3,R7
        SUBS     R2,R2,#+1
        BNE.N    ??get_serial_commands_15
??get_serial_commands_14:
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        UXTB     R1,R7
        CMP      R0,R1
        BEQ.N    ??get_serial_commands_16
        LDR.N    R0,??get_serial_commands_0+0x20
        MOVS     R1,#+1
        B.N      ??get_serial_commands_12
??get_serial_commands_16:
        LDR      R0,[R6, #+4]
        STR      R0,[R4, #+108]
??get_serial_commands_8:
        LDRB     R0,[R4, #+4]
        CBNZ.N   R0,??get_serial_commands_17
        MOVS     R1,#+71
        MOV      R0,R5
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CBZ.N    R0,??get_serial_commands_17
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        CMP      R0,#+3
        BHI.N    ??get_serial_commands_17
        LDR.N    R6,??get_serial_commands_0+0x24
        B.N      ??get_serial_commands_18
??get_serial_commands_13:
        MOVS     R1,#+1
        LDR.N    R0,??get_serial_commands_0+0x28
??get_serial_commands_12:
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z16gcode_line_errorPKcb
        B.W      _Z16gcode_line_errorPKcb
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??get_serial_commands_19:
        UXTB     R1,R1
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??get_serial_commands_18:
        LDRSB    R1,[R6], #+1
        MOVS     R0,R1
        BNE.N    ??get_serial_commands_19
??get_serial_commands_17:
        LDR.N    R1,??get_serial_commands_0+0x2C
        MOV      R0,R5
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??get_serial_commands_20
        STRB     R0,[R4, #+12]
??get_serial_commands_20:
        LDR.N    R1,??get_serial_commands_0+0x30
        MOV      R0,R5
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??get_serial_commands_21
        LDR.N    R0,??get_serial_commands_0+0x34
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_serial_commands_21:
        LDR.N    R1,??get_serial_commands_0+0x38
        MOV      R0,R5
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??get_serial_commands_22
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??get_serial_commands_22:
        LDRSB    R0,[R9, #+0]
        CMP      R0,#+59
        BEQ.W    ??get_serial_commands_1
        LDRB     R0,[R4, #+6]
        CMP      R0,#+4
        BGE.W    ??get_serial_commands_1
        LDRB     R0,[R4, #+8]
        ADD      R2,R0,R0, LSL #+1
        LDR.N    R0,??get_serial_commands_0+0x3C
        MOV      R1,R9
        ADD      R0,R0,R2, LSL #+5
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R0,#+1
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        B.N      ??get_serial_commands_1
??get_serial_commands_5:
        LDR      R1,[R6, #+8]
        CMP      R1,#+95
        BGE.W    ??get_serial_commands_1
        CMP      R0,#+92
        BEQ.W    ??get_serial_commands_2
        LDR.N    R2,??get_serial_commands_0+0x10
        CMP      R0,#+59
        BNE.N    ??get_serial_commands_23
        MOVS     R0,#+1
        STRB     R0,[R2, #+0]
        B.N      ??get_serial_commands_1
??get_serial_commands_23:
        LDRB     R2,[R2, #+0]
        CMP      R2,#+0
        BNE.W    ??get_serial_commands_1
        B.N      ??get_serial_commands_3
??get_serial_commands_4:
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??get_serial_commands_0:
        DC32     axis_relative_modes
        DC32     Serial3
        DC32     _ZZ19get_serial_commandsvE14last_wait_time
        DC32     serial_wait_tick
        DC32     _ZZ19get_serial_commandsvE19serial_comment_mode
        DC32     _ZZ19get_serial_commandsvE18serial_line_buffer
        DC32     _ZZ19get_serial_commandsvEs
        DC32     _ZZ19get_serial_commandsvEs_0
        DC32     _ZZ19get_serial_commandsvEs_1
        DC32     _ZZ19get_serial_commandsvEs_3
        DC32     _ZZ19get_serial_commandsvEs_2
        DC32     _ZZ19get_serial_commandsvEs_5
        DC32     _ZZ19get_serial_commandsvEs_6
        DC32     _ZZ19get_serial_commandsvEs_7
        DC32     _ZZ19get_serial_commandsvEs_8
        DC32     command_queue
          CFI EndBlock cfiBlock163

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z19get_sdcard_commandsv
          CFI Block cfiBlock164 Using cfiCommon0
          CFI Function _Z19get_sdcard_commandsv
        THUMB
_Z19get_sdcard_commandsv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        LDR.W    R8,??get_sdcard_commands_0
        LDRB     R0,[R8, #+1888]
        SUB      SP,SP,#+12
          CFI CFA R13+48
        CMP      R0,#+0
        BEQ.W    ??get_sdcard_commands_1
        LDR.N    R5,??get_sdcard_commands_0+0x4
        LDRB     R0,[R5, #+6]
        CBNZ.N   R0,??get_sdcard_commands_2
        LDR.N    R1,??get_sdcard_commands_0+0x8
        STRB     R0,[R1, #+0]
??get_sdcard_commands_2:
        ADDW     R0,R8,#+1116
        STR      R0,[SP, #+0]
        MOVS     R7,#+0
        LDR      R0,[R0, #+4]
        LDR      R1,[R8, #+1116]
        LDR.W    R9,??get_sdcard_commands_0+0xC
        LDR.W    R10,??get_sdcard_commands_0+0x10
        CMP      R0,R1
        SBCS     R4,R4,R4
        MVNS     R0,R4
        LSRS     R4,R0,#+31
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_4:
        UXTB     R1,R1
        MOV      R0,R9
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??get_sdcard_commands_5:
        LDRSB    R1,[R11], #+1
        MOVS     R0,R1
        BNE.N    ??get_sdcard_commands_4
          CFI FunCall SD_Init
        BL       SD_Init
        MOV      R0,R8
          CFI FunCall _ZN10CardReader6initsdEv
        BL       _ZN10CardReader6initsdEv
        LDR.N    R1,??get_sdcard_commands_0+0x14
        MOV      R0,R8
          CFI FunCall _ZN10CardReader10reopenfileEPc
        BL       _ZN10CardReader10reopenfileEPc
        CBZ.N    R0,??get_sdcard_commands_6
        LDR      R0,[SP, #+0]
        LDR      R1,[R0, #+4]
        STR      R1,[R0, #+4]
        MOV      R0,R8
          CFI FunCall f_lseek
        BL       f_lseek
??get_sdcard_commands_6:
        LDRB     R0,[R5, #+8]
        ADD      R2,R0,R0, LSL #+1
        LDR.N    R0,??get_sdcard_commands_0+0x18
        MOVS     R1,#+96
        ADD      R0,R0,R2, LSL #+5
          CFI FunCall __aeabi_memclr
        BL       __aeabi_memclr
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall _Z20display_temper_errorv
        BL       _Z20display_temper_errorv
        LDR.N    R0,??get_sdcard_commands_0+0x1C
        LDRSB    R0,[R0, R4]
        CMP      R0,#+16
        IT       NE 
          CFI FunCall GUI_RefreshPage
        BLNE     GUI_RefreshPage
        LDR.W    R11,??get_sdcard_commands_0+0x20
        LDRB     R0,[R11, #+5]
        CMP      R0,#+1
        BEQ.N    ??get_sdcard_commands_7
        MOVS     R1,#+36
        MOVS     R0,#+2
          CFI FunCall disp_pre_gcode
        BL       disp_pre_gcode
??get_sdcard_commands_7:
          CFI FunCall GUI_TOUCH_Exec
        BL       GUI_TOUCH_Exec
          CFI FunCall GUI_Exec
        BL       GUI_Exec
        MOVS     R0,#+1
        STRB     R0,[R11, #+6]
        LDRB     R0,[R11, #+7]
        ADDS     R0,R0,#+1
        STRB     R0,[R11, #+7]
??get_sdcard_commands_8:
        CMP      R6,#+35
        BNE.N    ??get_sdcard_commands_9
        MOVS     R0,#+1
        LDR.N    R1,??get_sdcard_commands_0+0x8
        STRB     R0,[R1, #+0]
??get_sdcard_commands_9:
        MOVS     R0,#+0
        LDR.N    R1,??get_sdcard_commands_0+0x24
        STRB     R0,[R1, #+0]
        UXTH     R7,R7
        CBZ.N    R7,??get_sdcard_commands_3
        LDRB     R0,[R5, #+8]
        LDR.N    R3,??get_sdcard_commands_0+0x18
        ADD      R2,R0,R0, LSL #+1
        ADD      R2,R3,R2, LSL #+5
        MOVS     R1,#+0
        STRB     R1,[R7, R2]
        MOVS     R7,#+0
        LDR.N    R2,??get_sdcard_commands_0+0x20
        ADDS     R2,R0,R2
        ADDS     R0,R0,#+1
        STRB     R1,[R2, #+20]
        STRB     R0,[R5, #+8]
        UXTB     R0,R0
        CMP      R0,#+4
        IT       GE 
        STRBGE   R1,[R5, #+8]
        LDRB     R0,[R5, #+6]
        ADDS     R0,R0,#+1
        STRB     R0,[R5, #+6]
??get_sdcard_commands_3:
        LDRB     R0,[R5, #+6]
        CMP      R0,#+4
        BGE.W    ??get_sdcard_commands_1
        LDR.N    R0,??get_sdcard_commands_0+0x8
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,R4
        BNE.W    ??get_sdcard_commands_1
        ADD      R3,SP,#+8
        MOVS     R2,#+1
        ADD      R1,SP,#+4
        MOV      R0,R8
          CFI FunCall f_read
        BL       f_read
        CBZ.N    R0,??get_sdcard_commands_10
        MOV      R0,#-1
        STRB     R0,[SP, #+4]
        B.N      ??get_sdcard_commands_11
??get_sdcard_commands_10:
        LDR      R0,[SP, #+0]
        LDR      R1,[SP, #+8]
        LDR      R0,[R0, #+4]
        ADDS     R0,R1,R0
        LDR      R1,[SP, #+0]
        STR      R0,[R1, #+4]
??get_sdcard_commands_11:
        LDR      R1,[SP, #+0]
        LDRSB    R0,[SP, #+4]
        LDR      R1,[R1, #+4]
        LDR      R2,[R8, #+1116]
        MOV      R6,R0
        CMP      R1,R2
        BCC.N    ??get_sdcard_commands_12
        MOVS     R0,#+0
        STRB     R0,[R10, #+344]
        STR      R0,[R10, #+680]
        STRB     R0,[R10, #+357]
        MOVS     R4,#+1
        MOV      R0,R8
          CFI FunCall _ZN10CardReader19printingHasFinishedEv
        BL       _ZN10CardReader19printingHasFinishedEv
        LDRB     R0,[R8, #+1888]
        CBNZ.N   R0,??get_sdcard_commands_13
        LDR.W    R11,??get_sdcard_commands_0+0x28
        B.N      ??get_sdcard_commands_14
??get_sdcard_commands_12:
        MOVS     R4,#+0
        CMN      R0,#+1
        BEQ.N    ??get_sdcard_commands_15
        CMP      R6,#+10
        IT       NE 
        CMPNE    R6,#+13
        BEQ.N    ??get_sdcard_commands_9
        CMP      R6,#+35
        ITEEE    NE 
        CMPNE    R6,#+58
        LDREQ.N  R0,??get_sdcard_commands_0+0x24
        LDRBEQ   R0,[R0, #+0]
        CMPEQ    R0,#+0
        BEQ.N    ??get_sdcard_commands_8
        UXTH     R7,R7
        CMP      R7,#+95
        BGE.N    ??get_sdcard_commands_3
        CMP      R6,#+59
        BNE.N    ??get_sdcard_commands_16
        LDR.N    R1,??get_sdcard_commands_0+0x24
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_13:
        MOVS     R7,#+0
        B.N      ??get_sdcard_commands_8
??get_sdcard_commands_17:
        UXTB     R1,R1
        MOV      R0,R9
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??get_sdcard_commands_14:
        LDRSB    R1,[R11], #+1
        MOVS     R0,R1
        BNE.N    ??get_sdcard_commands_17
        MOVS     R1,#+1
        MOV      R0,R8
          CFI FunCall _ZN10CardReader14checkautostartEb
        BL       _ZN10CardReader14checkautostartEb
        B.N      ??get_sdcard_commands_8
??get_sdcard_commands_15:
        LDR.W    R11,??get_sdcard_commands_0+0x2C
        B.N      ??get_sdcard_commands_18
??get_sdcard_commands_19:
        UXTB     R1,R1
        MOV      R0,R9
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??get_sdcard_commands_18:
        LDRSB    R1,[R11], #+1
        MOVS     R0,R1
        BNE.N    ??get_sdcard_commands_19
        LDR.W    R11,??get_sdcard_commands_0+0x30
        B.N      ??get_sdcard_commands_5
??get_sdcard_commands_16:
        LDR.N    R1,??get_sdcard_commands_0+0x24
        LDRB     R1,[R1, #+0]
        CMP      R1,#+0
        BNE.N    ??get_sdcard_commands_3
        LDRB     R1,[R5, #+8]
        ADD      R2,R1,R1, LSL #+1
        LDR.N    R1,??get_sdcard_commands_0+0x18
        ADD      R1,R1,R2, LSL #+5
        STRB     R6,[R7, R1]
        ADDS     R7,R7,#+1
        CMP      R6,#+90
        BNE.N    ??get_sdcard_commands_3
        MOV      R0,R8
          CFI FunCall _ZN10CardReader8getsdposEv
        BL       _ZN10CardReader8getsdposEv
        SUBS     R0,R0,#+3
        STR      R0,[R8, #+2072]
        ADDW     R0,R8,#+2072
        LDR      R1,[R8, #+2072]
        STR      R1,[R0, #+4]
        LDRB     R1,[R10, #+431]
        CMP      R1,#+1
        BEQ.W    ??get_sdcard_commands_3
        MOVS     R1,#+1
        STRB     R1,[R0, #+16]
        B.N      ??get_sdcard_commands_3
??get_sdcard_commands_1:
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??get_sdcard_commands_0:
        DC32     card
        DC32     axis_relative_modes
        DC32     _ZZ19get_sdcard_commandsvE14stop_buffering
        DC32     Serial3
        DC32     gCfgItems
        DC32     curFileName
        DC32     command_queue
        DC32     wifi_link_state
        DC32     filament_loading_time_flg
        DC32     _ZZ19get_sdcard_commandsvE15sd_comment_mode
        DC32     _ZZ19get_sdcard_commandsvEs
        DC32     errormagic
        DC32     _ZZ19get_sdcard_commandsvEs_0
          CFI EndBlock cfiBlock164

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z17get_wifi_commandsv
          CFI Block cfiBlock165 Using cfiCommon0
          CFI Function _Z17get_wifi_commandsv
        THUMB
_Z17get_wifi_commandsv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R4,??get_wifi_commands_0
        LDRB     R0,[R4, #+0]
        CMP      R0,#+6
        BLT.W    ??get_wifi_commands_1
        MOVS     R0,#+1
        STRB     R0,[R4, #+1]
        LDR.W    R9,??get_wifi_commands_0+0x4
        LDR.N    R6,??get_wifi_commands_0+0x8
        LDR.N    R7,??get_wifi_commands_0+0xC
        LDR.W    R8,??get_wifi_commands_0+0x10
        LDR.N    R5,??get_wifi_commands_0+0x14
        B.N      ??get_wifi_commands_2
??get_wifi_commands_3:
        LDRB     R2,[R7, #+0]
        CBNZ.N   R2,??get_wifi_commands_2
        STRB     R0,[R1, R6]
        ADDS     R0,R1,#+1
        STR      R0,[R4, #+12]
??get_wifi_commands_2:
        LDRB     R0,[R5, #+6]
        CMP      R0,#+4
        BGE.N    ??get_wifi_commands_4
        LDR      R1,[R8, #+288]
        LDR      R0,[R8, #+292]
        CMP      R1,R0
        BEQ.N    ??get_wifi_commands_4
        LDRSB    R0,[R1, R8]
        ADDS     R1,R1,#+1
        MOV      R2,#+288
        UDIV     R2,R1,R2
        ADD      R3,R2,R2, LSL #+3
        SUB      R1,R1,R3, LSL #+5
        STR      R1,[R8, #+288]
        CMP      R0,#+10
        IT       NE 
        CMPNE    R0,#+13
        BNE.N    ??get_wifi_commands_5
        LDR      R1,[R4, #+12]
        MOVS     R0,#+0
        STRB     R0,[R7, #+0]
        CMP      R1,#+0
        BEQ.N    ??get_wifi_commands_2
        STRB     R0,[R1, R6]
        STR      R0,[R4, #+12]
        MOV      R10,R6
        B.N      ??get_wifi_commands_6
??get_wifi_commands_7:
        ADD      R10,R10,#+1
??get_wifi_commands_6:
        LDRSB    R0,[R10, #+0]
        CMP      R0,#+32
        BEQ.N    ??get_wifi_commands_7
        LDRB     R0,[R5, #+4]
        CBNZ.N   R0,??get_wifi_commands_8
        MOVS     R1,#+71
        MOV      R0,R10
          CFI FunCall __iar_Strchr
        BL       __iar_Strchr
        CBZ.N    R0,??get_wifi_commands_8
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
        ADDS     R0,R0,#+1
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        CMP      R0,#+3
        BHI.N    ??get_wifi_commands_8
        LDR.W    R11,??get_wifi_commands_0+0x18
        B.N      ??get_wifi_commands_9
??get_wifi_commands_10:
        UXTB     R1,R1
        MOV      R0,R9
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??get_wifi_commands_9:
        LDRSB    R1,[R11], #+1
        MOVS     R0,R1
        BNE.N    ??get_wifi_commands_10
??get_wifi_commands_8:
        LDR.N    R1,??get_wifi_commands_0+0x1C
        MOV      R0,R10
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??get_wifi_commands_11
        STRB     R0,[R5, #+12]
??get_wifi_commands_11:
        LDR.N    R1,??get_wifi_commands_0+0x20
        MOV      R0,R10
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??get_wifi_commands_12
        LDR.N    R0,??get_wifi_commands_0+0x24
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??get_wifi_commands_12:
        LDR.N    R1,??get_wifi_commands_0+0x28
        MOV      R0,R10
          CFI FunCall strcmp
        BL       strcmp
        CBNZ.N   R0,??get_wifi_commands_13
          CFI FunCall _ZN7Stepper10quick_stopEv
        BL       _ZN7Stepper10quick_stopEv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+100
          CFI FunCall _Z34set_current_from_steppers_for_axis8AxisEnum
        BL       _Z34set_current_from_steppers_for_axis8AxisEnum
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??get_wifi_commands_13:
        LDRSB    R0,[R6, #+0]
        CMP      R0,#+59
        BEQ.N    ??get_wifi_commands_2
        LDRB     R0,[R5, #+6]
        CMP      R0,#+4
        BGE.N    ??get_wifi_commands_2
        LDRB     R0,[R5, #+8]
        ADD      R2,R0,R0, LSL #+1
        LDR.N    R0,??get_wifi_commands_0+0x2C
        MOV      R1,R6
        ADD      R0,R0,R2, LSL #+5
          CFI FunCall strcpy
        BL       strcpy
        MOVS     R0,#+1
          CFI FunCall _Z15_commit_commandb
        BL       _Z15_commit_commandb
        B.N      ??get_wifi_commands_2
??get_wifi_commands_5:
        LDR      R1,[R4, #+12]
        CMP      R1,#+95
        BGE.N    ??get_wifi_commands_2
        CMP      R0,#+59
        BNE.N    ??get_wifi_commands_3
        MOVS     R0,#+1
        STRB     R0,[R7, #+0]
        B.N      ??get_wifi_commands_2
??get_wifi_commands_1:
        MOVS     R0,#+0
        STRB     R0,[R4, #+1]
??get_wifi_commands_4:
        POP      {R0,R4-R11,PC}   ;; return
        Nop      
        DATA
??get_wifi_commands_0:
        DC32     serial_wait_tick
        DC32     Serial3
        DC32     _ZZ17get_wifi_commandsvE16wifi_line_buffer
        DC32     _ZZ17get_wifi_commandsvE17wifi_comment_mode
        DC32     espGcodeFifo
        DC32     axis_relative_modes
        DC32     _ZZ17get_wifi_commandsvEs
        DC32     _ZZ17get_wifi_commandsvEs_1
        DC32     _ZZ17get_wifi_commandsvEs_2
        DC32     _ZZ17get_wifi_commandsvEs_3
        DC32     _ZZ17get_wifi_commandsvEs_4
        DC32     command_queue
          CFI EndBlock cfiBlock165

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z31buffer_line_to_current_positionv
          CFI Block cfiBlock166 Using cfiCommon0
          CFI Function _Z31buffer_line_to_current_positionv
        THUMB
_Z31buffer_line_to_current_positionv:
        PUSH     {LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+4
        LDR.N    R0,??buffer_line_to_current_position_0
        LDRB     R1,[R0, #+10]
        LDR      R2,[R0, #+24]
        SUB      SP,SP,#+12
          CFI CFA R13+16
        ADD      R3,R0,#+28
        STR      R1,[SP, #+4]
        ADD      R1,R0,#+112
        STR      R1,[SP, #+0]
        LDR      R1,[R0, #+20]
        LDR      R0,[R0, #+16]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        ADD      SP,SP,#+12
          CFI CFA R13+4
        POP      {PC}             ;; return
        Nop      
        DATA
??buffer_line_to_current_position_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock166

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z26buffer_line_to_destinationf
          CFI Block cfiBlock167 Using cfiCommon0
          CFI Function _Z26buffer_line_to_destinationf
        THUMB
_Z26buffer_line_to_destinationf:
        PUSH     {R0,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        LDR.N    R0,??buffer_line_to_destination_0
        LDRB     R1,[R0, #+10]
        LDR      R2,[R0, #+40]
        SUB      SP,SP,#+8
          CFI CFA R13+16
        ADD      R3,R0,#+44
        STR      R1,[SP, #+4]
        ADD      R1,SP,#+8
        STR      R1,[SP, #+0]
        LDR      R1,[R0, #+36]
        LDR      R0,[R0, #+32]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
        ADD      SP,SP,#+12
          CFI CFA R13+4
        POP      {PC}             ;; return
        DATA
??buffer_line_to_destination_0:
        DC32     axis_relative_modes
          CFI EndBlock cfiBlock167

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z11gcode_G2_G3b
          CFI Block cfiBlock168 Using cfiCommon0
          CFI Function _Z11gcode_G2_G3b
        THUMB
_Z11gcode_G2_G3b:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R6,??gcode_G2_G3_0
        LDRB     R0,[R6, #+4]
        SUB      SP,SP,#+40
          CFI CFA R13+80
        CMP      R0,#+0
        BEQ.W    ??gcode_G2_G3_1
          CFI FunCall _Z21gcode_get_destinationv
        BL       _Z21gcode_get_destinationv
        ADD      R0,SP,#+20
        MOVS     R1,#+0
        MOVS     R2,#+0
        STM      R0!,{R1,R2}
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G2_G3_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G2_G3_2
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R8,R0
        LDR      R0,[R6, #+16]
        STR      R0,[SP, #+4]
        MOVS     R1,#+0
        LDR      R0,[R6, #+20]
        STR      R0,[SP, #+0]
        LDR      R0,[R6, #+32]
        STR      R0,[SP, #+16]
        LDR      R0,[R6, #+36]
        STR      R0,[SP, #+12]
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_G2_G3_3
        LDR      R0,[SP, #+16]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_4
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_G2_G3_3
??gcode_G2_G3_4:
        MOV      R0,R8
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITE      CC 
        MOVCC    R0,#+1
        MOVCS    R0,#+0
        B.N      ??gcode_G2_G3_5
??gcode_G2_G3_2:
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G2_G3_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G2_G3_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[SP, #+20]
??gcode_G2_G3_6:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G2_G3_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G2_G3_3
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
??gcode_G2_G3_7:
        STR      R0,[SP, #+24]
??gcode_G2_G3_3:
        LDR      R0,[SP, #+20]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G2_G3_8
        LDR      R0,[SP, #+24]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??gcode_G2_G3_9
??gcode_G2_G3_8:
        LDRB     R2,[SP, #+40]
        ADD      R1,SP,#+20
        ADD      R0,R6,#+32
          CFI FunCall _Z8plan_arcRA4_KfRA2_S_b
        BL       _Z8plan_arcRA4_KfRA2_S_b
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R6, #+120]
        ADD      SP,SP,#+44
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+80
??gcode_G2_G3_5:
        LDRB     R1,[SP, #+40]
        MOV      R11,#+1065353216
        TEQ      R0,R1
        ITE      NE 
        LDRNE.W  R10,??gcode_G2_G3_0+0x8  ;; 0xbf800000
        MOVEQ    R10,R11
        LDR      R0,[SP, #+16]
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+0]
        STR      R0,[SP, #+32]
        LDR      R0,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+28]
        MOV      R9,#+2
        LDR      R4,[SP, #+32]
        MOV      R5,R11
        B.N      ??gcode_G2_G3_10
??gcode_G2_G3_11:
        MOV      R0,R4
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
??gcode_G2_G3_10:
        LSLS     R0,R9,#+31
        BPL.N    ??gcode_G2_G3_12
        MOV      R0,R5
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??gcode_G2_G3_12:
        LSRS     R9,R9,#+1
        BNE.N    ??gcode_G2_G3_11
        LDR      R7,[SP, #+28]
        MOVS     R4,#+2
        MOV      R9,R11
        B.N      ??gcode_G2_G3_13
??gcode_G2_G3_14:
        MOV      R0,R7
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R7,R0
??gcode_G2_G3_13:
        LSLS     R0,R4,#+31
        BPL.N    ??gcode_G2_G3_15
        MOV      R0,R9
        MOV      R1,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??gcode_G2_G3_15:
        LSRS     R4,R4,#+1
        BNE.N    ??gcode_G2_G3_14
        MOV      R0,R5
        MOV      R1,R9
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        STR      R0,[SP, #+8]
        MOVS     R5,#+2
        B.N      ??gcode_G2_G3_16
??gcode_G2_G3_17:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??gcode_G2_G3_16:
        LSLS     R0,R5,#+31
        BPL.N    ??gcode_G2_G3_18
        MOV      R0,R11
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??gcode_G2_G3_18:
        LSRS     R5,R5,#+1
        BNE.N    ??gcode_G2_G3_17
        LDR      R0,[SP, #+8]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        LDR.N    R3,??gcode_G2_G3_0+0xC  ;; 0x3fe00000
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        LDR.N    R5,??gcode_G2_G3_0+0x10  ;; 0x3ff00000
        MOV      R4,R0
        MOV      R9,R1
        MOVS     R7,#+2
        MOV      R8,#+0
        B.N      ??gcode_G2_G3_19
??gcode_G2_G3_20:
        MOV      R0,R4
        MOV      R1,R9
        MOV      R2,R4
        MOV      R3,R9
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R4,R0
        MOV      R9,R1
??gcode_G2_G3_19:
        LSLS     R0,R7,#+31
        BPL.N    ??gcode_G2_G3_21
        MOV      R2,R4
        MOV      R3,R9
        MOV      R0,R8
        MOV      R1,R5
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
        MOV      R8,R0
        MOV      R5,R1
??gcode_G2_G3_21:
        LSRS     R7,R7,#+1
        BNE.N    ??gcode_G2_G3_20
        MOV      R0,R11
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R8
        MOV      R3,R5
          CFI FunCall __aeabi_dsub
        BL       __aeabi_dsub
          CFI FunCall sqrt
        BL       sqrt
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        MOV      R1,R10
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R4,R0
        LDR      R1,[SP, #+4]
        LDR      R0,[SP, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+8]
        MOV      R5,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+20]
        LDR      R1,[SP, #+0]
        LDR      R0,[SP, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+8]
        MOV      R5,R0
        LDR      R0,[SP, #+32]
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R1,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        B.N      ??gcode_G2_G3_7
??gcode_G2_G3_9:
        LDR.N    R0,??gcode_G2_G3_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G2_G3_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G2_G3_1:
        ADD      SP,SP,#+44
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??gcode_G2_G3_0:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     0xbf800000
        DC32     0x3fe00000
        DC32     0x3ff00000
        DC32     errormagic
        DC32     _ZZ11gcode_G2_G3bEs
          CFI EndBlock cfiBlock168

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13home_z_safelyv
          CFI Block cfiBlock169 Using cfiCommon0
          CFI Function _Z13home_z_safelyv
        THUMB
_Z13home_z_safelyv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        LDR.N    R0,??home_z_safely_0
        LDRB     R1,[R0, #+4]
        SUB      SP,SP,#+8
          CFI CFA R13+32
        CMP      R1,#+0
        ITT      NE 
        LDRBNE   R0,[R0, #+5]
        CMPNE    R0,#+0
        BNE.N    ??home_z_safely_1
        LDR.N    R0,??home_z_safely_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??home_z_safely_0+0x8
        B.N      ??home_z_safely_2
??home_z_safely_1:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        LDR.N    R5,??home_z_safely_0+0xC
        LDR      R1,[R5, #+20]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        ADD      R7,R5,#+20
        LDR.N    R4,??home_z_safely_0+0x10
        LDR      R1,[R7, #+4]
        MOV      R6,R0
        STR      R6,[R4, #+32]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        LDR      R0,[R4, #+24]
        STR      R0,[R4, #+40]
        STR      R8,[R4, #+36]
        LDRSB    R0,[R5, #+7]
        CMP      R0,#+0
        BPL.N    ??home_z_safely_3
        LDRB     R0,[R5, #+153]
        CMP      R0,#+1
        BNE.N    ??home_z_safely_3
        LDR      R1,[R7, #+88]
        MOV      R0,R6
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+32]
        MOV      R0,R8
        LDR      R1,[R7, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+36]
??home_z_safely_3:
        LDRH     R0,[R7, #+68]
        MOVW     R1,#+770
        TST      R0,R1
        ADD      R1,R4,#+36
        ADD      R0,R4,#+32
        BEQ.N    ??home_z_safely_4
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        B.N      ??home_z_safely_5
??home_z_safely_4:
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
??home_z_safely_5:
        CBZ.N    R0,??home_z_safely_6
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R4,#+24
        ADD      R1,R4,#+36
        ADD      R0,R4,#+32
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        POP      {R0,R1,R4-R8,PC}
??home_z_safely_6:
        LDR.N    R0,??home_z_safely_0+0x4
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??home_z_safely_0+0x14
??home_z_safely_2:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,R1,R4-R8,PC}  ;; return
        DATA
??home_z_safely_0:
        DC32     axis_homed
        DC32     echomagic
        DC32     _ZZ13home_z_safelyvEs
        DC32     mksCfg
        DC32     axis_relative_modes
        DC32     _ZZ13home_z_safelyvEs_0
          CFI EndBlock cfiBlock169

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G28b
          CFI Block cfiBlock170 Using cfiCommon0
          CFI Function _Z9gcode_G28b
        THUMB
_Z9gcode_G28b:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        MOV      R4,R0
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDR.N    R7,??gcode_G28_0
        ADDW     R0,R7,#+65
        STR      R0,[SP, #+4]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+16
        ITT      EQ 
        LDREQ.N  R1,??gcode_G28_0+0x4
        LDRBEQ   R5,[R1, #+0]
        MOVS     R1,#+62
        TST      R0,R1
        ITT      NE 
        MOVNE    R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BLNE     _Z24set_bed_leveling_enabledb
        LDR.W    R8,??gcode_G28_0+0x8
        LDRB     R0,[R8, #+10]
        STRB     R0,[SP, #+1]
        MOVS     R2,#+1
        MOVS     R1,#+0
        MOVS     R0,#+0
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        LDR.N    R6,??gcode_G28_0+0xC
        MOVS     R0,#+1
        STRB     R0,[R6, #+0]
        LDRSH    R0,[R7, #+88]
        CMP      R0,#+2
        BNE.N    ??gcode_G28_1
        ADD      R0,R8,#+16
        MOVS     R1,#+0
        MOVS     R2,#+0
        MOV      R3,R1
        MOV      R4,R1
        STM      R0!,{R1-R4}
          CFI FunCall _Z18sync_plan_positionv
        BL       _Z18sync_plan_positionv
        LDR      R1,[R8, #+128]
        LDR.N    R0,??gcode_G28_0+0x10  ;; 0x41200000
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R8, #+24]
        STR      R0,[R8, #+20]
        STR      R0,[R8, #+16]
        LDR.N    R0,??gcode_G28_0+0x14
        LDR      R0,[R0, #+4]
        STR      R0,[R8, #+112]
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R2,#+112
        LDR.N    R0,??gcode_G28_0+0x18
        LDRSB    R1,[R0, R4]
        TST      R1,R2
        BNE.N    ??gcode_G28_2
        LDR.N    R0,??gcode_G28_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_G28_0+0x20
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G28_3:
        LDR.N    R0,??gcode_G28_0+0x24
        LDRB     R0,[R0, #+0]
        STRB     R0,[R6, #+0]
        LDR      R0,[SP, #+4]
        LDRB     R0,[R0, #+1]
        CMP      R0,#+16
        ITT      EQ 
        UXTBEQ   R0,R5
          CFI FunCall _Z24set_bed_leveling_enabledb
        BLEQ     _Z24set_bed_leveling_enabledb
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
        LDRB     R0,[SP, #+1]
        MOVS     R2,#+1
        MOVS     R1,#+0
          CFI FunCall _Z11tool_changehfb
        BL       _Z11tool_changehfb
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+48
??gcode_G28_2:
        STRB     R4,[R0, #+0]
        MOVS     R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        MOV      R0,R4
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
        MOVS     R0,#+1
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
        MOVS     R0,#+2
          CFI FunCall _Z19set_axis_is_at_home8AxisEnum
        BL       _Z19set_axis_is_at_home8AxisEnum
??gcode_G28_4:
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??gcode_G28_3
??gcode_G28_1:
        CBNZ.N   R4,??gcode_G28_5
        LDR.N    R1,??gcode_G28_0+0x28
        LDRB     R0,[R1, #+2]
        LSRS     R9,R0,#+7
        BNE.N    ??gcode_G28_6
??gcode_G28_7:
        LDRB     R1,[R1, #+3]
        ANDS     R10,R1,#0x1
        BNE.N    ??gcode_G28_8
        B.N      ??gcode_G28_9
??gcode_G28_6:
        LDR.N    R0,??gcode_G28_0+0x2C
        LDRB     R2,[R0, #+23]
        LDR.N    R0,??gcode_G28_0+0x30
        CBZ.N    R2,??gcode_G28_10
        LDR.N    R3,??gcode_G28_0+0x34
        LDR      R3,[R3, #+0]
        ADDS     R2,R2,R3
??gcode_G28_10:
        STR      R2,[R0, #+0]
        B.N      ??gcode_G28_7
??gcode_G28_5:
        MOV      R9,#+1
        MOV      R10,R9
        MOVS     R4,#+1
        B.N      ??gcode_G28_11
??gcode_G28_8:
        LDR.N    R0,??gcode_G28_0+0x2C
        LDRB     R2,[R0, #+24]
        LDR.N    R0,??gcode_G28_0+0x30
        CBZ.N    R2,??gcode_G28_12
        LDR.N    R3,??gcode_G28_0+0x34
        LDR      R3,[R3, #+0]
        ADDS     R2,R2,R3
??gcode_G28_12:
        STR      R2,[R0, #+0]
??gcode_G28_9:
        LSRS     R0,R1,#+1
        ANDS     R4,R0,#0x1
        BEQ.N    ??gcode_G28_11
        LDR.N    R0,??gcode_G28_0+0x2C
        LDRB     R1,[R0, #+25]
        LDR.N    R0,??gcode_G28_0+0x30
        CBZ.N    R1,??gcode_G28_13
        LDR.N    R2,??gcode_G28_0+0x34
        LDR      R2,[R2, #+0]
        ADDS     R1,R1,R2
??gcode_G28_13:
        STR      R1,[R0, #+0]
??gcode_G28_11:
        AND      R0,R10,R9
        STRB     R0,[SP, #+0]
        ORR      R0,R10,R9
        LDRB     R1,[SP, #+0]
        ORRS     R0,R4,R0
        EOR      R0,R0,#0x1
        ANDS     R1,R4,R1
        ORR      R11,R1,R0
        ADD      R0,R8,#+16
        LDM      R0!,{R2,R3,R12,LR}
        ADD      R1,R8,#+32
        STM      R1!,{R2,R3,R12,LR}
        LDRSB    R0,[R7, #+7]
        CMP      R0,#+1
        BLT.N    ??gcode_G28_14
        ORRS     R0,R4,R11
        ITT      NE 
        MOVNE    R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BLNE     _Z8homeaxis8AxisEnum
??gcode_G28_14:
        ORR      R9,R9,R11
        ORRS     R0,R10,R9
        BEQ.N    ??gcode_G28_15
        LDR      R0,[R8, #+24]
        LDR.N    R1,??gcode_G28_0+0x38  ;; 0x40a00000
        STR      R1,[R8, #+40]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G28_15
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
        ADD      R3,SP,#+8
        ADD      R2,R8,#+40
        ADD      R1,R8,#+20
        ADD      R0,R8,#+16
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
??gcode_G28_15:
        LDRH     R0,[R7, #+88]
        MOV      R1,#+768
        TST      R0,R1
        ITTT     NE 
        LDRBNE   R0,[SP, #+0]
        ORRSNE   R0,R0,R11
          CFI FunCall _Z13quick_home_xyv
        BLNE     _Z13quick_home_xyv
        LDRB     R0,[R7, #+65]
        CMP      R0,#+0
        ITTT     NE 
        ORRSNE   R0,R10,R11
        MOVNE    R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BLNE     _Z8homeaxis8AxisEnum
        CMP      R9,#+0
        ITT      NE 
        MOVNE    R0,#+0
          CFI FunCall _Z8homeaxis8AxisEnum
        BLNE     _Z8homeaxis8AxisEnum
        LDRB     R0,[R7, #+65]
        CBNZ.N   R0,??gcode_G28_16
        ORRS     R0,R10,R11
        ITT      NE 
        MOVNE    R0,#+1
          CFI FunCall _Z8homeaxis8AxisEnum
        BLNE     _Z8homeaxis8AxisEnum
??gcode_G28_16:
        LDRSB    R0,[R7, #+7]
        CMP      R0,#+0
        BPL.W    ??gcode_G28_4
        ORRS     R0,R4,R11
        BEQ.W    ??gcode_G28_4
        LDRB     R0,[R7, #+264]
        CBZ.N    R0,??gcode_G28_17
          CFI FunCall _Z13home_z_safelyv
        BL       _Z13home_z_safelyv
        B.N      ??gcode_G28_4
??gcode_G28_17:
        MOVS     R0,#+2
          CFI FunCall _Z8homeaxis8AxisEnum
        BL       _Z8homeaxis8AxisEnum
        B.N      ??gcode_G28_4
        Nop      
        DATA
??gcode_G28_0:
        DC32     mksCfg
        DC32     _ZN7Planner15leveling_activeE
        DC32     axis_relative_modes
        DC32     _ZN8Endstops7enabledE
        DC32     0x41200000
        DC32     home_dir_P
        DC32     _ZN8Endstops16endstop_hit_bitsE
        DC32     errormagic
        DC32     _ZZ10home_deltavEs_0
        DC32     _ZN8Endstops16enabled_globallyE
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     0x40a00000
          CFI EndBlock cfiBlock170

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z27gcode_G29_MESH_BED_LEVELINGv
          CFI Block cfiBlock171 Using cfiCommon0
          CFI Function _Z27gcode_G29_MESH_BED_LEVELINGv
        THUMB
_Z27gcode_G29_MESH_BED_LEVELINGv:
        PUSH     {R4-R8,LR}
          CFI R14 Frame(CFA, -4)
          CFI R8 Frame(CFA, -8)
          CFI R7 Frame(CFA, -12)
          CFI R6 Frame(CFA, -16)
          CFI R5 Frame(CFA, -20)
          CFI R4 Frame(CFA, -24)
          CFI CFA R13+24
        SUB      SP,SP,#+16
          CFI CFA R13+40
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_MESH_BED_LEVELING_1
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
??gcode_G29_MESH_BED_LEVELING_1:
        SXTB     R0,R0
        CMP      R0,#+6
        IT       CS 
        LDRCS.N  R0,??gcode_G29_MESH_BED_LEVELING_2
        BCS.W    ??gcode_G29_MESH_BED_LEVELING_3
        CMP      R0,#+5
        BHI.W    ??gcode_G29_MESH_BED_LEVELING_4
        TBH      [PC, R0, LSL #+1]
        DATA
??gcode_G29_MESH_BED_LEVELING_0:
        DC16     0x6,0x1D,0x2C,0xB3
        DC16     0xFC,0x114
          CFI FunCall _Z17leveling_is_validv
        THUMB
??gcode_G29_MESH_BED_LEVELING_5:
        BL       _Z17leveling_is_validv
        CBZ.N    R0,??gcode_G29_MESH_BED_LEVELING_6
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x4
        LDRB     R0,[R0, #+0]
        CMP      R0,#+0
        ITE      NE 
        LDRNE.N  R1,??gcode_G29_MESH_BED_LEVELING_2+0x8
        LDREQ.N  R1,??gcode_G29_MESH_BED_LEVELING_2+0xC
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x10
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        MOVS     R1,#+10
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
        B.N      ??gcode_G29_MESH_BED_LEVELING_7
??gcode_G29_MESH_BED_LEVELING_6:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        B.N      ??gcode_G29_MESH_BED_LEVELING_7
??gcode_G29_MESH_BED_LEVELING_8:
          CFI FunCall _ZN17mesh_bed_leveling5resetEv
        BL       _ZN17mesh_bed_leveling5resetEv
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        MOVS     R0,#+0
        STR      R0,[R1, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x20
        LDRB     R1,[R0, #+0]
        CMP      R1,#+0
        ITE      NE 
        LDRNE.N  R1,??gcode_G29_MESH_BED_LEVELING_2+0x24
        LDREQ.N  R1,??gcode_G29_MESH_BED_LEVELING_2+0x28
        STR      R1,[R0, #+4]
          CFI FunCall _Z25drain_injected_commands_Pv
        BL       _Z25drain_injected_commands_Pv
        B.N      ??gcode_G29_MESH_BED_LEVELING_9
??gcode_G29_MESH_BED_LEVELING_10:
        LDR.N    R7,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        LDR      R1,[R7, #+0]
        CMP      R1,#+0
        IT       MI 
        LDRMI.N  R0,??gcode_G29_MESH_BED_LEVELING_2+0x2C
        BMI.W    ??gcode_G29_MESH_BED_LEVELING_3
        LDR.W    R8,??gcode_G29_MESH_BED_LEVELING_2+0x30
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x34
        LDRB     R0,[R8, #+96]
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_11
        LDRB     R3,[R6, #+9]
        LDR.N    R4,??gcode_G29_MESH_BED_LEVELING_2+0x38
        STRB     R3,[R4, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_12
??gcode_G29_MESH_BED_LEVELING_11:
        SUBS     R4,R1,#+1
        SXTB     R4,R4
        SDIV     R3,R4,R0
        MLS      R4,R0,R3,R4
        LSLS     R5,R3,#+31
        ITT      MI 
        SUBMI    R5,R0,#+1
        SUBMI    R4,R5,R4
        SXTB     R4,R4
        ADD      R5,R4,R4, LSL #+1
        LDR.N    R4,??gcode_G29_MESH_BED_LEVELING_2+0x3C
        ADD      R4,R4,R5, LSL #+4
        LDR      R5,[R6, #+24]
        SXTB     R3,R3
        STR      R5,[R4, R3, LSL #+2]
        LDR.N    R3,??gcode_G29_MESH_BED_LEVELING_2+0x38
        LDRB     R3,[R3, #+0]
        STRB     R3,[R6, #+9]
??gcode_G29_MESH_BED_LEVELING_12:
        ADD      R2,R8,#+96
        LDRB     R3,[R2, #+1]
        MULS     R3,R3,R0
        CMP      R1,R3
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_13
        SXTB     R1,R1
        SDIV     R4,R1,R0
        MLS      R5,R0,R4,R1
        LSLS     R1,R4,#+31
        ITT      MI 
        SUBMI    R0,R0,#+1
        SUBMI    R5,R0,R5
        SXTB     R4,R4
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x40
        ADD      R4,R0,R4, LSL #+2
        SXTB     R5,R5
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x44
        ADD      R5,R0,R5, LSL #+2
        LDR      R0,[R2, #+8]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_G29_MESH_BED_LEVELING_14
        LDR      R0,[R6, #+24]
        STR      R0,[SP, #+8]
        STR      R1,[SP, #+4]
        ADD      R3,SP,#+4
        ADD      R2,R8,#+104
        MOV      R1,R4
        MOV      R0,R5
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,SP,#+8
        ADD      R1,R6,#+20
        ADD      R0,R6,#+16
        B.N      ??gcode_G29_MESH_BED_LEVELING_15
??gcode_G29_MESH_BED_LEVELING_14:
        STR      R1,[SP, #+0]
        ADD      R3,SP,#+0
        ADD      R2,R6,#+24
        MOV      R1,R4
        MOV      R0,R5
??gcode_G29_MESH_BED_LEVELING_15:
          CFI FunCall _Z19do_blocking_move_toRKfS0_S0_S0_
        BL       _Z19do_blocking_move_toRKfS0_S0_S0_
        LDR      R0,[R5, #+0]
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x20
        STR      R0,[R6, #+16]
        LDR      R0,[R4, #+0]
        STR      R0,[R6, #+20]
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        STRB     R0,[R6, #+9]
        LDR      R0,[R7, #+0]
        ADDS     R0,R0,#+1
        STR      R0,[R7, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_9
??gcode_G29_MESH_BED_LEVELING_13:
        LDR      R1,[R8, #+16]
        LDR      R0,[R2, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, #+24]
          CFI FunCall _Z31buffer_line_to_current_positionv
        BL       _Z31buffer_line_to_current_positionv
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOV      R0,#-1
        STR      R0,[R7, #+0]
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x48
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x4C
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
          CFI FunCall _Z9gcode_G28b
        BL       _Z9gcode_G28b
        MOVS     R0,#+1
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MOVS     R0,#+0
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x20
        STRB     R0,[R1, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_9
??gcode_G29_MESH_BED_LEVELING_16:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R7,??gcode_G29_MESH_BED_LEVELING_2+0x50
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_17
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        SUBS     R5,R0,#+1
        SXTB     R5,R5
        CMP      R5,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_18
        LDR.N    R6,??gcode_G29_MESH_BED_LEVELING_2+0x30
        LDRB     R0,[R6, #+96]
        SUBS     R0,R0,#+1
        CMP      R0,R5
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_19
??gcode_G29_MESH_BED_LEVELING_18:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x54
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_17:
        MOVS     R1,#+88
        B.N      ??gcode_G29_MESH_BED_LEVELING_20
??gcode_G29_MESH_BED_LEVELING_19:
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_21
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        SUBS     R4,R0,#+1
        SXTB     R4,R4
        CMP      R4,#+0
        BMI.N    ??gcode_G29_MESH_BED_LEVELING_22
        ADD      R0,R6,#+96
        LDRB     R0,[R0, #+1]
        SUBS     R0,R0,#+1
        CMP      R0,R4
        BGE.N    ??gcode_G29_MESH_BED_LEVELING_23
??gcode_G29_MESH_BED_LEVELING_22:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x58
        B.N      ??gcode_G29_MESH_BED_LEVELING_3
??gcode_G29_MESH_BED_LEVELING_21:
        MOVS     R1,#+89
        B.N      ??gcode_G29_MESH_BED_LEVELING_20
??gcode_G29_MESH_BED_LEVELING_23:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R7, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
        ADD      R0,R5,R5, LSL #+1
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x3C
        ADD      R5,R1,R0, LSL #+4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R5, R4, LSL #+2]
        B.N      ??gcode_G29_MESH_BED_LEVELING_7
??gcode_G29_MESH_BED_LEVELING_25:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G29_MESH_BED_LEVELING_2+0x50
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_MESH_BED_LEVELING_24
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_G29_MESH_BED_LEVELING_2+0x5C
        STR      R0,[R1, #+0]
        B.N      ??gcode_G29_MESH_BED_LEVELING_7
??gcode_G29_MESH_BED_LEVELING_24:
        MOVS     R1,#+90
??gcode_G29_MESH_BED_LEVELING_20:
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x60
??gcode_G29_MESH_BED_LEVELING_3:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      SP,SP,#+16
          CFI CFA R13+24
        POP      {R4-R8,PC}
          CFI CFA R13+40
??gcode_G29_MESH_BED_LEVELING_26:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        B.N      ??gcode_G29_MESH_BED_LEVELING_7
??gcode_G29_MESH_BED_LEVELING_4:
        CMP      R0,#+1
        IT       NE 
        CMPNE    R0,#+2
        BNE.N    ??gcode_G29_MESH_BED_LEVELING_7
??gcode_G29_MESH_BED_LEVELING_9:
        LDR.N    R5,??gcode_G29_MESH_BED_LEVELING_2+0x30
        LDR.N    R7,??gcode_G29_MESH_BED_LEVELING_2+0x1C
        LDRB     R0,[R5, #+96]
        ADD      R4,R5,#+96
        LDRB     R1,[R4, #+1]
        MULS     R1,R1,R0
        LDR      R0,[R7, #+0]
        CMP      R0,R1
        IT       LT 
        MOVLT    R1,R0
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x64
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDRB     R0,[R5, #+96]
        LDRB     R1,[R4, #+1]
        MULS     R1,R1,R0
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x68
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_G29_MESH_BED_LEVELING_2+0x14
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_MESH_BED_LEVELING_7:
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        ADD      SP,SP,#+16
          CFI CFA R13+24
        POP      {R4-R8,PC}       ;; return
        DATA
??gcode_G29_MESH_BED_LEVELING_2:
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs
        DC32     _ZN7Planner15leveling_activeE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_1
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_2
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_0
        DC32     Serial3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_3
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE15mbl_probe_index
        DC32     lcd_wait_for_move
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_4
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_5
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_6
        DC32     mksCfg
        DC32     axis_relative_modes
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvE20enable_soft_endstops
        DC32     _ZN17mesh_bed_leveling8z_valuesE
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_7
        DC32     _ZN17mesh_bed_leveling8has_meshE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_8
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs_9
        DC32     _ZN17mesh_bed_leveling8z_offsetE
        DC32     `?<Constant " not entered.\\n">`
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__10_
        DC32     _ZZ27gcode_G29_MESH_BED_LEVELINGvEs__11_
          CFI EndBlock cfiBlock171

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G29v
          CFI Block cfiBlock172 Using cfiCommon0
          CFI Function _Z9gcode_G29v
        THUMB
_Z9gcode_G29v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        MOVS     R1,#+1
        SUB      SP,SP,#+828
          CFI CFA R13+864
        MOVS     R2,#+1
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.W    ??gcode_G29_0
        STR      R0,[SP, #+56]
        STR      R0,[SP, #+52]
        STR      R0,[SP, #+32]
        STR      R0,[SP, #+20]
        STR      R0,[SP, #+72]
        STR      R0,[SP, #+28]
        MOVS     R7,#+0
        LDR.W    R0,??gcode_G29_1
        STR      R0,[SP, #+8]
        MOV      R8,R7
        LDRB     R0,[R0, #+30]
        LDR      R1,[SP, #+8]
        STR      R0,[SP, #+40]
        MOVS     R2,#+6
        LDRB     R1,[R1, #+31]
        STR      R1,[SP, #+16]
        MULS     R0,R1,R0
        LDR.W    R1,??gcode_G29_1+0x4
        LDRB     R1,[R1, #+66]
        STRB     R7,[SP, #+12]
        TST      R1,R2
        IT       EQ 
        STREQ    R0,[SP, #+68]
        ADD      R0,R0,R0, LSL #+1
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        STR      R0,[SP, #+44]
        CBNZ.N   R0,??gcode_G29_2
        LDR.W    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+4]
        LDR.W    R0,??gcode_G29_1+0xC
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_2:
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+8]
        LDRB     R0,[R0, #+30]
        LDRB     R1,[R1, #+31]
        MULS     R0,R1,R0
        ADD      R1,R0,R0, LSL #+1
        ADDS     R1,R1,#+1
        CMP      R1,#+1
        BLT.N    ??gcode_G29_3
        LDR      R2,[SP, #+44]
        MOVS     R3,#+0
??gcode_G29_4:
        STR      R7,[R2], #+4
        SUBS     R1,R1,#+1
        BNE.N    ??gcode_G29_4
??gcode_G29_3:
        ADDS     R0,R0,#+1
        LSLS     R0,R0,#+2
          CFI FunCall malloc
        BL       malloc
        STR      R0,[SP, #+64]
        CBNZ.N   R0,??gcode_G29_5
        LDR.W    R1,??gcode_G29_1+0x8
        STRB     R0,[R1, #+4]
        LDR.W    R0,??gcode_G29_1+0x10
          CFI FunCall _Z4killPKc
        BL       _Z4killPKc
??gcode_G29_5:
        LDR      R0,[SP, #+8]
        LDR      R1,[SP, #+8]
        LDRB     R0,[R0, #+30]
        LDRB     R1,[R1, #+31]
        MULS     R0,R1,R0
        ADDS     R0,R0,#+1
        CMP      R0,#+1
        BLT.N    ??gcode_G29_6
        LDR      R1,[SP, #+64]
        MOVS     R2,#+0
??gcode_G29_7:
        STR      R7,[R1], #+4
        SUBS     R0,R0,#+1
        BNE.N    ??gcode_G29_7
??gcode_G29_6:
        LDR.W    R0,??gcode_G29_1+0x14
        LDR      R2,[R0, #+52]
        LDR      R1,[R0, #+48]
        STR      R0,[SP, #+36]
        MOVS     R3,#+0
        ADD      R0,SP,#+120
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDR      R0,[SP, #+36]
        LDR      R2,[R0, #+60]
        LDR      R1,[R0, #+56]
        MOV      R3,R7
        ADD      R0,SP,#+132
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDR      R0,[SP, #+36]
        LDR      R2,[R0, #+68]
        LDR      R1,[R0, #+64]
        MOV      R3,R7
        ADD      R0,SP,#+144
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        LSLS     R0,R0,#+29
        BPL.N    ??gcode_G29_8
        MOVS     R1,#+60
        ADD      R0,SP,#+192
          CFI FunCall __aeabi_memclr4
        BL       __aeabi_memclr4
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        LSLS     R0,R0,#+29
        IT       MI 
        MOVMI    R7,#-1
??gcode_G29_8:
        LDR.W    R0,??gcode_G29_9
        LDR.W    R1,??gcode_G29_1+0x4
        LDRB     R6,[R0, #+0]
        LDRB     R1,[R1, #+66]
        LDR.W    R0,??gcode_G29_9+0x4
        CMP      R1,#+8
        BNE.W    ??gcode_G29_10
        LDRB     R1,[R0, #+2]
        LSLS     R1,R1,#+25
        BPL.W    ??gcode_G29_10
        LDR.W    R0,??gcode_G29_9+0x8
        LDR.W    R4,??gcode_G29_9+0xC
        LDRB     R0,[R0, #+22]
        CBZ.N    R0,??gcode_G29_11
        LDR.W    R1,??gcode_G29_9+0x10
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_G29_11:
        STR      R0,[R4, #+0]
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CBNZ.N   R0,??gcode_G29_12
        LDR.W    R0,??gcode_G29_9+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_9+0x18
        B.N      ??gcode_G29_13
??gcode_G29_12:
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_14
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??gcode_G29_1+0x8
        LDR      R1,[R1, #+68]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R5,R0
        B.N      ??gcode_G29_15
??gcode_G29_14:
        LDR.W    R0,??gcode_G29_1+0x8
        LDR      R5,[R0, #+24]
??gcode_G29_15:
        LDR.W    R1,??gcode_G29_9+0x1C  ;; 0xc1200000
        MOV      R0,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_16
        LDR.W    R1,??gcode_G29_9+0x20  ;; 0x41200001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_17
??gcode_G29_16:
        LDR.W    R0,??gcode_G29_9+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.W    R0,??gcode_G29_9+0x24
        B.N      ??gcode_G29_13
??gcode_G29_17:
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_18
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        B.N      ??gcode_G29_19
??gcode_G29_18:
        MVN      R0,#-2147483648
??gcode_G29_19:
        LDR.W    R4,??gcode_G29_1+0x8
        LDR      R1,[R4, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_20
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        B.N      ??gcode_G29_21
??gcode_G29_20:
        MVN      R0,#-2147483648
??gcode_G29_21:
        LDR      R1,[R4, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_22
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R8,R0
        B.N      ??gcode_G29_23
??gcode_G29_22:
        MOV      R8,#+255
??gcode_G29_23:
        SXTB     R8,R8
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_24
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        MOV      R4,R0
        B.N      ??gcode_G29_25
??gcode_G29_24:
        MOVS     R4,#+255
??gcode_G29_25:
        SXTB     R4,R4
        MOV      R0,R9
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_26
        MOV      R0,R7
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_26
        LDR.W    R4,??gcode_G29_9+0x28
        LDR      R0,[R4, #+16]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOVS     R3,#+0
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        SXTB     R8,R0
        LDR      R0,[R4, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R7
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
        MOVS     R2,#+0
        MOV      R3,R2
          CFI FunCall __aeabi_ddiv
        BL       __aeabi_ddiv
          CFI FunCall __aeabi_d2iz
        BL       __aeabi_d2iz
        SXTB     R4,R0
        CMP      R8,#+0
        IT       MI 
        MOVMI    R8,#+0
        BMI.N    ??gcode_G29_27
        LDR      R0,[SP, #+8]
        LDRB     R0,[R0, #+30]
        SUBS     R1,R0,#+1
        CMP      R1,R8
        IT       LT 
        SUBLT    R8,R0,#+1
??gcode_G29_27:
        SXTB     R8,R8
        CMP      R4,#+0
        IT       MI 
        MOVMI    R4,#+0
        BMI.N    ??gcode_G29_28
        LDR      R0,[SP, #+8]
        LDRB     R0,[R0, #+31]
        SUBS     R1,R0,#+1
        CMP      R1,R4
        IT       LT 
        SUBLT    R4,R0,#+1
??gcode_G29_28:
        SXTB     R4,R4
??gcode_G29_26:
        CMP      R8,#+0
        BMI.W    ??gcode_G29_0
        LDR      R0,[SP, #+8]
        LDRB     R0,[R0, #+30]
        SUBS     R0,R0,#+1
        CMP      R0,R8
        BLT.W    ??gcode_G29_0
        CMP      R4,#+0
        BMI.W    ??gcode_G29_0
        LDR      R0,[SP, #+8]
        LDRB     R0,[R0, #+31]
        CMP      R0,R4
        BLT.W    ??gcode_G29_0
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        ADD      R0,R8,R8, LSL #+1
        LDR.W    R1,??gcode_G29_9+0x2C
        ADD      R0,R1,R0, LSL #+4
        STR      R5,[R0, R4, LSL #+2]
        MOV      R0,R6
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        CMP      R6,#+0
        BEQ.W    ??gcode_G29_0
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        ADD      SP,SP,#+828
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+864
??gcode_G29_10:
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+30
        BPL.N    ??gcode_G29_29
        LDR.W    R0,??gcode_G29_9+0x8
        LDR.W    R4,??gcode_G29_9+0xC
        LDRB     R0,[R0, #+9]
        CBZ.N    R0,??gcode_G29_30
        LDR.W    R1,??gcode_G29_9+0x10
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_G29_30:
        STR      R0,[R4, #+0]
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        ADD      SP,SP,#+828
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+864
??gcode_G29_29:
        MOVS     R0,#+86
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R4,??gcode_G29_9+0xC
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_31
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOV      R1,R3
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
??gcode_G29_31:
        SXTH     R0,R0
        STR      R0,[SP, #+48]
        CMP      R0,#+5
        IT       CS 
        LDRCS.W  R0,??gcode_G29_9+0x30
        BCS.N    ??gcode_G29_13
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??gcode_G29_9+0xC
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_32
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??gcode_G29_33
??gcode_G29_32:
        MOVS     R0,#+68
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
??gcode_G29_33:
        STR      R0,[SP, #+60]
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        LSLS     R1,R0,#+29
        BPL.N    ??gcode_G29_34
        LDR      R0,[SP, #+48]
        CMP      R0,#+3
        BGE.N    ??gcode_G29_35
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??gcode_G29_9+0xC
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_36
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??gcode_G29_37
??gcode_G29_36:
        MOVS     R0,#+84
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        B.N      ??gcode_G29_37
??gcode_G29_35:
        MOVS     R0,#+1
??gcode_G29_37:
        STRB     R0,[SP, #+12]
        LDR.W    R4,??gcode_G29_9+0xC
        LDR      R0,[SP, #+8]
        LDRB     R5,[R0, #+30]
        MOVS     R0,#+88
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_38
        LDR      R0,[R4, #+0]
        CBZ.N    R0,??gcode_G29_39
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOV      R1,R3
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R5,R0
        B.N      ??gcode_G29_38
??gcode_G29_39:
        MOVS     R5,#+0
??gcode_G29_38:
        UXTB     R5,R5
        LDR      R0,[SP, #+8]
        STR      R5,[SP, #+40]
        LDRB     R5,[R0, #+31]
        MOVS     R0,#+89
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_40
        LDR      R0,[R4, #+0]
        CBZ.N    R0,??gcode_G29_41
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOV      R1,R3
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R5,R0
        B.N      ??gcode_G29_40
??gcode_G29_41:
        MOVS     R5,#+0
??gcode_G29_40:
        UXTB     R5,R5
        STR      R5,[SP, #+16]
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_42
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOV      R1,R3
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        UXTB     R0,R0
        STR      R0,[SP, #+16]
        ADD      R0,SP,#+16
        LDRB     R0,[R0, #+0]
        STR      R0,[SP, #+40]
??gcode_G29_42:
        LDR      R0,[SP, #+40]
        CMP      R0,#+2
        ITT      GE 
        LDRGE    R0,[SP, #+16]
        CMPGE    R0,#+2
        BGE.N    ??gcode_G29_43
        LDR.W    R0,??gcode_G29_9+0x34
??gcode_G29_13:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      SP,SP,#+828
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+864
??gcode_G29_43:
        LDR      R0,[SP, #+40]
        LDR      R1,[SP, #+16]
        MULS     R0,R1,R0
        STR      R0,[SP, #+68]
        MOVS     R5,#+0
        B.N      ??gcode_G29_44
??gcode_G29_34:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_44
        MOVS     R0,#+90
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_45
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
??gcode_G29_45:
        STR      R0,[SP, #+84]
??gcode_G29_44:
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        MOVS     R1,#+12
        TST      R0,R1
        BEQ.W    ??gcode_G29_46
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G29_47
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        B.N      ??gcode_G29_48
??gcode_G29_47:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+8]
??gcode_G29_48:
        LDR.W    R1,??gcode_G29_9+0x38  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR.W    R1,??gcode_G29_9+0x3C
        LDR.W    R4,??gcode_G29_9+0xC
        STR      R0,[R1, #+100]
        MOVS     R0,#+76
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_49
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??gcode_G29_1+0x8
        LDR      R1,[R1, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        B.N      ??gcode_G29_50
??gcode_G29_49:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+28]
??gcode_G29_50:
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R8,R0
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_51
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??gcode_G29_1+0x8
        LDR      R1,[R1, #+60]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        B.N      ??gcode_G29_52
??gcode_G29_51:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+32]
??gcode_G29_52:
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R9,R0
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_53
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??gcode_G29_1+0x8
        LDR      R1,[R1, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        B.N      ??gcode_G29_54
??gcode_G29_53:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+36]
??gcode_G29_54:
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[SP, #+20]
        MOVS     R0,#+66
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_55
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.W    R1,??gcode_G29_1+0x8
        LDR      R1,[R1, #+64]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        B.N      ??gcode_G29_56
??gcode_G29_55:
        LDR      R0,[SP, #+36]
        LDR      R0,[R0, #+40]
??gcode_G29_56:
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.W    R10,??gcode_G29_9+0x40
        MOV      R4,R0
        MOV      R0,R8
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R10, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_57
        SUB      R0,R9,#+10
        CMP      R0,R8
        BGE.N    ??gcode_G29_58
??gcode_G29_57:
        MOVS     R0,#+1
        B.N      ??gcode_G29_59
??gcode_G29_58:
        MOVS     R0,#+0
??gcode_G29_59:
        STRB     R0,[SP, #+1]
        MOV      R0,R9
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R10, #+4]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_60
        ADD      R0,R8,#+10
        CMP      R9,R0
        BGE.N    ??gcode_G29_61
??gcode_G29_60:
        MOVS     R0,#+1
        B.N      ??gcode_G29_62
??gcode_G29_61:
        MOVS     R0,#+0
??gcode_G29_62:
        STRB     R0,[SP, #+0]
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR      R1,[R10, #+8]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_63
        LDR      R1,[SP, #+20]
        SUB      R0,R4,#+10
        CMP      R0,R1
        BGE.N    ??gcode_G29_64
??gcode_G29_63:
        MOV      R11,#+1
        B.N      ??gcode_G29_65
??gcode_G29_64:
        MOV      R11,#+0
??gcode_G29_65:
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[R10, #+12]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_G29_66
        LDR      R0,[SP, #+20]
        ADDS     R0,R0,#+10
        CMP      R4,R0
        BGE.N    ??gcode_G29_67
??gcode_G29_66:
        MOV      R10,#+1
        B.N      ??gcode_G29_68
??gcode_G29_67:
        MOV      R10,#+0
??gcode_G29_68:
        LDRB     R0,[SP, #+1]
        LDRB     R1,[SP, #+0]
        ORRS     R0,R1,R0
        ORR      R0,R11,R0
        ORRS     R0,R10,R0
        BEQ.N    ??gcode_G29_69
        LDRB     R0,[SP, #+1]
        CBZ.N    R0,??gcode_G29_70
        LDR.W    R0,??gcode_G29_9+0x44
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_70:
        LDRB     R0,[SP, #+0]
        CBZ.N    R0,??gcode_G29_71
        LDR.W    R0,??gcode_G29_9+0x48
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
??gcode_G29_71:
        CMP      R11,#+0
        ITT      NE 
        LDRNE.W  R0,??gcode_G29_9+0x4C
          CFI FunCall _Z18out_of_range_errorPKc
        BLNE     _Z18out_of_range_errorPKc
        CMP      R10,#+0
        BEQ.W    ??gcode_G29_0
        LDR.W    R0,??gcode_G29_9+0x50
          CFI FunCall _Z18out_of_range_errorPKc
        BL       _Z18out_of_range_errorPKc
        ADD      SP,SP,#+828
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+864
??gcode_G29_69:
        LDR      R1,[SP, #+40]
        SUB      R0,R9,R8
        SUBS     R1,R1,#+1
        SDIV     R0,R0,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+72]
        LDR      R1,[SP, #+16]
        LDR      R0,[SP, #+20]
        SUBS     R0,R4,R0
        SUBS     R1,R1,#+1
        SDIV     R0,R0,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+28]
??gcode_G29_46:
        LDR      R0,[SP, #+48]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_72
        LDR.W    R0,??gcode_G29_9+0x54
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[SP, #+60]
        CBZ.N    R0,??gcode_G29_73
        LDR.W    R0,??gcode_G29_9+0x58
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_G29_73:
        MOVS     R1,#+10
        LDR.W    R0,??gcode_G29_9+0x5C
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_72:
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        MOVS     R0,#+0
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MOVS     R0,#+1
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CBZ.N    R0,??gcode_G29_74
        MOV      R0,R6
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        ADD      SP,SP,#+828
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+864
??gcode_G29_74:
          CFI FunCall _Z31setup_for_endstop_or_probe_movev
        BL       _Z31setup_for_endstop_or_probe_movev
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_75
        LDR.W    R4,??gcode_G29_9+0x28
        LDR      R0,[R4, #+8]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_G29_76
        LDR      R0,[R4, #+12]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        ITT      EQ 
        LDREQ    R0,[R4, #+16]
        CMPEQ    R8,R0
        ITTT     EQ 
        LDREQ    R0,[SP, #+20]
        LDREQ    R1,[R4, #+20]
        CMPEQ    R0,R1
        BEQ.N    ??gcode_G29_75
??gcode_G29_76:
          CFI FunCall _Z15reset_bed_levelv
        BL       _Z15reset_bed_levelv
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+8]
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        STR      R0,[R4, #+12]
        STR      R8,[R4, #+16]
        MOVS     R6,#+0
        LDR      R0,[SP, #+20]
        STR      R0,[R4, #+20]
??gcode_G29_75:
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        CMP      R0,#+2
        BNE.N    ??gcode_G29_77
        ADD      R4,SP,#+120
        MOVS     R0,#+0
        STR      R0,[R4, #+32]
        STR      R0,[R4, #+20]
        STR      R0,[R4, #+8]
??gcode_G29_77:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.W  R0,??gcode_G29_9+0xC
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G29_78
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        B.N      ??gcode_G29_79
??gcode_G29_78:
        MOVS     R0,#+69
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
??gcode_G29_79:
        STRB     R0,[SP, #+5]
        MOVS     R1,#+12
        MOVS     R0,#+0
        STR      R0,[SP, #+32]
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        TST      R0,R1
        BEQ.W    ??gcode_G29_80
        LDR      R0,[SP, #+16]
        AND      R0,R0,#0x1
        STRB     R0,[SP, #+4]
        MOVS     R0,#+0
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+252
        STR      R0,[SP, #+80]
        LDR.W    R0,??gcode_G29_9+0x2C
        STR      R0,[SP, #+76]
        LDR      R0,[SP, #+40]
        SUBS     R0,R0,#+1
        STRB     R0,[SP, #+6]
        ADD      R0,SP,#+40
        LDRSB    R0,[R0, #+0]
        STR      R0,[SP, #+108]
        MOV      R0,R8
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+104]
        MOV      R10,#+0
        LDR.W    R11,??gcode_G29_9+0x60  ;; 0x3fe00000
        B.N      ??gcode_G29_81
??gcode_G29_82:
        LDRSB    R4,[SP, #+6]
        MOV      R0,#-1
        STR      R0,[SP, #+96]
??gcode_G29_83:
        STR      R0,[SP, #+92]
        LDRB     R0,[SP, #+4]
        EOR      R0,R0,#0x1
        SUBS     R0,R0,#+1
        SBCS     R0,R0,R0
        MVNS     R0,R0
        LSRS     R0,R0,#+31
        STRB     R0,[SP, #+4]
        LDR      R0,[SP, #+20]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+24
        LDRB     R0,[R0, #+0]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        LDR      R0,[SP, #+28]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[SP, #+100]
        B.N      ??gcode_G29_84
??gcode_G29_85:
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_G29_86
        LDR      R1,[SP, #+32]
        LDR      R0,[SP, #+84]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R2,[SP, #+76]
        ADD      R1,R4,R4, LSL #+1
        LSLS     R1,R1,#+4
        STR      R0,[R1, R2]
??gcode_G29_86:
        MOVS     R6,#+0
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??gcode_G29_87:
        LDR      R0,[SP, #+92]
        ADDS     R4,R0,R4
        SXTB     R4,R4
??gcode_G29_84:
        LDR      R0,[SP, #+96]
        CMP      R4,R0
        BEQ.N    ??gcode_G29_88
        MOV      R0,R4
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        LDR      R0,[SP, #+72]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR      R1,[SP, #+104]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+100]
        STR      R1,[SP, #+0]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITE      CC 
        STRDCC   R10,R10,[SP, #+112]
        STRDCS   R10,R11,[SP, #+112]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDRD     R2,R3,[SP, #+112]
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+56]
        MOVS     R1,#+0
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITE      CC 
        STRDCC   R10,R10,[SP, #+112]
        STRDCS   R10,R11,[SP, #+112]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDRD     R2,R3,[SP, #+112]
          CFI FunCall __aeabi_dadd
        BL       __aeabi_dadd
          CFI FunCall floor
        BL       floor
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+52]
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        LSLS     R0,R0,#+29
        BPL.N    ??gcode_G29_89
        ADD      R0,R4,R4, LSL #+1
        LDR      R1,[SP, #+80]
        LSLS     R0,R0,#+4
        ADDS     R7,R7,#+1
        STR      R7,[R0, R1]
??gcode_G29_89:
        MOVW     R1,#+770
        LDR      R0,[SP, #+8]
        LDRH     R0,[R0, #+22]
        TST      R0,R1
        BEQ.N    ??gcode_G29_90
        ADD      R1,SP,#+52
        ADD      R0,SP,#+56
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_87
        LDR.W    R1,??gcode_G29_1+0x4
        LDR      R0,[SP, #+56]
        LDR      R1,[R1, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[SP, #+36]
        STR      R0,[SP, #+0]
        LDR      R1,[R1, #+4]
        LDR      R0,[SP, #+52]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+88]
        ADD      R1,SP,#+88
        ADD      R0,SP,#+0
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_87
??gcode_G29_90:
          CFI FunCall rand
        BL       rand
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+52
        LDR      R3,[SP, #+48]
        LDRB     R2,[SP, #+5]
        UXTB     R3,R3
        ADD      R0,SP,#+56
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+32]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??gcode_G29_91
        MOV      R0,R6
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_G29_88:
        LDR      R0,[SP, #+24]
        ADDS     R0,R0,#+1
        UXTB     R0,R0
        STR      R0,[SP, #+24]
        LDR      R0,[SP, #+76]
        ADDS     R0,R0,#+4
        STR      R0,[SP, #+76]
        LDR      R0,[SP, #+80]
        ADDS     R0,R0,#+4
        STR      R0,[SP, #+80]
??gcode_G29_81:
        LDR      R0,[SP, #+24]
        LDR      R1,[SP, #+16]
        CMP      R0,R1
        BGE.W    ??gcode_G29_92
        LDR      R0,[SP, #+32]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.W    ??gcode_G29_92
        LDRB     R0,[SP, #+4]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_82
        LDR      R0,[SP, #+108]
        STR      R0,[SP, #+96]
        MOVS     R4,#+0
        MOVS     R0,#+1
        B.N      ??gcode_G29_83
??gcode_G29_91:
        LDR.W    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        LSLS     R1,R0,#+29
        BPL.W    ??gcode_G29_85
        LDR      R1,[SP, #+32]
        MOV      R0,R5
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R5,R0
        LDR      R1,[SP, #+64]
        LDR      R0,[SP, #+32]
        STR      R0,[R1, R7, LSL #+2]
        ADD      R3,SP,#+32
        LDR      R1,[SP, #+44]
        LDR      R0,[SP, #+56]
        STR      R0,[R1, R7, LSL #+2]
        ADD      R2,SP,#+52
        LDR      R0,[SP, #+68]
        LDR      R1,[SP, #+44]
        ADD      R0,R1,R0, LSL #+2
        LDR      R1,[SP, #+52]
        STR      R1,[R0, R7, LSL #+2]
        LDR      R0,[SP, #+68]
        LDR      R1,[SP, #+44]
        ADD      R0,R1,R0, LSL #+3
        MOV      R1,#+1065353216
        STR      R1,[R0, R7, LSL #+2]
        ADD      R0,SP,#+192
        ADD      R1,SP,#+56
          CFI FunCall _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        BL       _Z15incremental_LSFP15linear_fit_dataRKfS2_S2_
        B.N      ??gcode_G29_86
??gcode_G29_80:
        LSLS     R0,R0,#+30
        BPL.W    ??gcode_G29_92
        MOVS     R4,#+0
        ADD      R7,SP,#+120
??gcode_G29_93:
        LDR      R0,[R7], #+4
        STR      R0,[SP, #+56]
        LDR      R0,[R7], #+4
        STR      R0,[SP, #+52]
          CFI FunCall rand
        BL       rand
        MOVS     R0,#+1
        STR      R0,[SP, #+0]
        ADD      R1,SP,#+52
        LDR      R3,[SP, #+48]
        LDRB     R2,[SP, #+5]
        UXTB     R3,R3
        ADD      R0,SP,#+56
          CFI FunCall _Z8probe_ptRKfS0_bhb
        BL       _Z8probe_ptRKfS0_bhb
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        STR      R0,[SP, #+32]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BNE.N    ??gcode_G29_94
        MOV      R0,R6
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        B.N      ??gcode_G29_95
??gcode_G29_94:
        LDR      R0,[SP, #+32]
        STR      R0,[R7], #+4
        ADDS     R4,R4,#+1
        UXTB     R4,R4
        CMP      R4,#+3
        BLT.N    ??gcode_G29_93
??gcode_G29_95:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_92
        LDR      R0,[SP, #+32]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.N    ??gcode_G29_92
        ADD      R4,SP,#+120
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+872
        LDM      R0!,{R2,R3}
        MOV      R1,SP
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+864
        ADD      R1,SP,#+144
        ADD      R0,SP,#+100
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,R4,#+12
        SUB      SP,SP,#+8
          CFI CFA R13+872
        LDM      R0!,{R2,R3}
        MOV      R1,SP
        STM      R1!,{R2,R3}
        LDR      R2,[R0, #0]
        STR      R2,[R1, #+0]
        POP      {R2,R3}
          CFI CFA R13+864
        ADD      R1,SP,#+120
        ADD      R0,SP,#+72
          CFI FunCall _ZN8vector_3miES_
        BL       _ZN8vector_3miES_
        ADD      R0,SP,#+100
        LDM      R0!,{R1,R3}
        MOV      R2,SP
        STM      R2!,{R1,R3}
        LDR      R3,[R0, #0]
        STR      R3,[R2, #+0]
        ADD      R0,SP,#+72
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_35crossES_S_
        BL       _ZN8vector_35crossES_S_
        ADD      R1,SP,#+20
        LDM      R1!,{R2-R4}
        ADD      R0,SP,#+88
        ADD      R1,SP,#+88
        STM      R0!,{R2-R4}
        ADD      R0,SP,#+20
          CFI FunCall _ZN8vector_310get_normalEv
        BL       _ZN8vector_310get_normalEv
        ADD      R1,SP,#+20
        LDM      R1!,{R2-R4}
        ADD      R0,SP,#+0
        MOVS     R1,#+0
        STM      R0!,{R2-R4}
        MOV      R0,R4
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_96
        LDR.W    R6,??gcode_G29_9+0x64  ;; 0xbf800000
        MOV      R1,R2
        MOV      R0,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+0]
        MOV      R0,R6
        LDR      R1,[SP, #+4]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+4]
        MOV      R1,R6
        MOV      R0,R4
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+8]
??gcode_G29_96:
        ADD      R0,SP,#+0
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+156
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.W    R0,??gcode_G29_9+0x68
        ADD      R1,SP,#+156
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        MOVS     R6,#+0
??gcode_G29_92:
        MOVS     R0,#+0
          CFI FunCall _Z18set_probe_deployedb
        BL       _Z18set_probe_deployedb
        CBZ.N    R0,??gcode_G29_97
        MOV      R0,R6
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
        MVN      R0,#-2147483648
        STR      R0,[SP, #+32]
??gcode_G29_97:
        LDR      R0,[SP, #+32]
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        BEQ.W    ??gcode_G29_98
        LDR.N    R0,??gcode_G29_1+0x4
        LDRB     R0,[R0, #+66]
        CMP      R0,#+8
        BNE.N    ??gcode_G29_99
        LDR      R0,[SP, #+60]
        CBNZ.N   R0,??gcode_G29_100
          CFI FunCall _Z30extrapolate_unprobed_bed_levelv
        BL       _Z30extrapolate_unprobed_bed_levelv
??gcode_G29_100:
          CFI FunCall _Z28print_bilinear_leveling_gridv
        BL       _Z28print_bilinear_leveling_gridv
          CFI FunCall _Z17refresh_bed_levelv
        BL       _Z17refresh_bed_levelv
        B.N      ??gcode_G29_101
??gcode_G29_99:
        CMP      R0,#+4
        BNE.W    ??gcode_G29_101
        ADD      R0,SP,#+192
          CFI FunCall _Z22finish_incremental_LSFP15linear_fit_data
        BL       _Z22finish_incremental_LSFP15linear_fit_data
        LDR      R0,[SP, #+244]
        LDR      R9,[SP, #+236]
        LDR      R8,[SP, #+240]
        EOR      R10,R0,#0x80000000
        LDR      R0,[SP, #+68]
        EOR      R11,R9,#0x80000000
        EOR      R7,R8,#0x80000000
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R0
        MOV      R0,R5
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R5,R0
        LDR      R0,[SP, #+48]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_102
        LDR.W    R0,??gcode_G29_9+0x6C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R11
        LDR.W    R4,??gcode_G29_9+0x5C
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        LDR.W    R0,??gcode_G29_9+0x70
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        LDR.W    R0,??gcode_G29_9+0x74
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R10
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+48]
        CMP      R0,#+3
        BLT.N    ??gcode_G29_102
        LDR.W    R0,??gcode_G29_9+0x78
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOVS     R0,#+8
        STR      R0,[SP, #+0]
        MOV      R0,R5
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_102:
        LDR      R0,[SP, #+60]
        CBNZ.N   R0,??gcode_G29_103
        MOV      R3,#+1065353216
        MOV      R2,R8
        MOV      R1,R9
        ADD      R0,SP,#+0
          CFI FunCall _ZN8vector_3C1Efff
        BL       _ZN8vector_3C1Efff
        ADD      R0,SP,#+0
        LDM      R0,{R1-R3}
        ADD      R0,SP,#+72
          CFI FunCall _ZN10matrix_3x314create_look_atE8vector_3
        BL       _ZN10matrix_3x314create_look_atE8vector_3
        LDR.N    R0,??gcode_G29_9+0x68
        ADD      R1,SP,#+72
        MOVS     R2,#+36
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
??gcode_G29_103:
        LDRB     R0,[SP, #+12]
        CMP      R0,#+0
        BEQ.W    ??gcode_G29_101
        LDR.N    R0,??gcode_G29_9+0x7C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R0,[SP, #+16]
        LDR.W    R11,??gcode_G29_9+0x80  ;; 0x4479c000
        SUBS     R0,R0,#+1
        SXTB     R0,R0
        STR      R0,[SP, #+92]
        LDR      R0,[SP, #+92]
        STR      R0,[SP, #+72]
        CMP      R0,#+0
        BMI.N    ??gcode_G29_104
        ADD      R1,SP,#+252
        ADD      R0,R1,R0, LSL #+2
        STR      R0,[SP, #+80]
        LDR.N    R4,??gcode_G29_9+0x5C
??gcode_G29_105:
        LDR      R0,[SP, #+40]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_106
        LDR      R10,[SP, #+80]
        MOV      R8,R0
??gcode_G29_107:
        LDR      R0,[SP, #+64]
        LDR      R7,[R10, #+0]
        LDR      R0,[R0, R7, LSL #+2]
        MOV      R1,R5
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        LDR      R0,[SP, #+44]
        LDR      R0,[R0, R7, LSL #+2]
        LDR      R1,[SP, #+44]
        STR      R0,[SP, #+88]
        MOVS     R2,#+36
        LDR      R0,[SP, #+68]
        ADD      R0,R1,R0, LSL #+2
        LDR.N    R1,??gcode_G29_9+0x68
        LDR      R0,[R0, R7, LSL #+2]
        STR      R0,[SP, #+84]
        MOVS     R0,#+0
        STR      R0,[SP, #+76]
        ADD      R0,SP,#+76
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+84
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+88
        STR      R0,[SP, #+20]
        SUB      SP,SP,#+16
          CFI CFA R13+880
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+864
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[SP, #+64]
        LDR      R1,[SP, #+76]
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R11,R0
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_108
        LDR.N    R7,??gcode_G29_9+0x84
??gcode_G29_109:
        LDRSB    R1,[R7], #+1
        MOVS     R0,R1
        BEQ.N    ??gcode_G29_110
        UXTB     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_G29_109
??gcode_G29_108:
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_110:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        MOV      R0,R9
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADD      R10,R10,#+48
        SUBS     R8,R8,#+1
        BNE.N    ??gcode_G29_107
??gcode_G29_106:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+72]
        SUBS     R0,R0,#+1
        SXTB     R0,R0
        STR      R0,[SP, #+72]
        LDR      R0,[SP, #+80]
        SUBS     R0,R0,#+4
        STR      R0,[SP, #+80]
        LDR      R0,[SP, #+72]
        CMP      R0,#+0
        BPL.N    ??gcode_G29_105
??gcode_G29_104:
        LDR.N    R4,??gcode_G29_9+0x5C
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR      R0,[SP, #+48]
        CMP      R0,#+4
        BLT.N    ??gcode_G29_101
        LDR.N    R0,??gcode_G29_9+0x88
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR      R9,[SP, #+92]
        CMP      R9,#+0
        BMI.N    ??gcode_G29_111
        ADD      R0,SP,#+252
        ADD      R0,R0,R9, LSL #+2
        STR      R0,[SP, #+76]
??gcode_G29_112:
        LDR      R0,[SP, #+40]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_113
        LDR      R8,[SP, #+76]
        MOV      R5,R0
??gcode_G29_114:
        LDR      R0,[SP, #+44]
        LDR      R7,[R8, #+0]
        LDR      R0,[R0, R7, LSL #+2]
        LDR      R1,[SP, #+44]
        STR      R0,[SP, #+84]
        MOVS     R2,#+36
        LDR      R0,[SP, #+68]
        ADD      R0,R1,R0, LSL #+2
        LDR.N    R1,??gcode_G29_9+0x68
        LDR      R0,[R0, R7, LSL #+2]
        STR      R0,[SP, #+80]
        MOVS     R0,#+0
        STR      R0,[SP, #+72]
        ADD      R0,SP,#+72
        STR      R0,[SP, #+28]
        ADD      R0,SP,#+80
        STR      R0,[SP, #+24]
        ADD      R0,SP,#+84
        STR      R0,[SP, #+20]
        SUB      SP,SP,#+16
          CFI CFA R13+880
        MOV      R0,SP
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        POP      {R0-R3}
          CFI CFA R13+864
          CFI FunCall _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        BL       _Z18apply_rotation_xyz10matrix_3x3RfS0_S0_
        LDR      R0,[SP, #+64]
        LDR      R1,[SP, #+72]
        LDR      R0,[R0, R7, LSL #+2]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        MOV      R7,R0
        BHI.N    ??gcode_G29_115
        LDR.W    R10,??gcode_G29_9+0x84
??gcode_G29_116:
        LDRSB    R1,[R10], #+1
        MOVS     R0,R1
        BEQ.N    ??gcode_G29_117
        UXTB     R1,R1
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_G29_116
        DATA
??gcode_G29_1:
        DC32     mksCfg+0x42
        DC32     mksCfg
        DC32     axis_relative_modes
        DC32     _ZZ9gcode_G29vEs
        DC32     _ZZ9gcode_G29vEs_0
        DC32     mksCfg+0x6C
        THUMB
??gcode_G29_115:
        MOVS     R1,#+32
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_117:
        MOVS     R0,#+5
        STR      R0,[SP, #+0]
        MOV      R0,R7
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R4
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        ADD      R8,R8,#+48
        SUBS     R5,R5,#+1
        BNE.N    ??gcode_G29_114
??gcode_G29_113:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        SUB      R0,R9,#+1
        SXTB     R9,R0
        LDR      R0,[SP, #+76]
        SUBS     R0,R0,#+4
        STR      R0,[SP, #+76]
        CMP      R9,#+0
        BPL.N    ??gcode_G29_112
??gcode_G29_111:
        MOVS     R1,#+10
        MOV      R0,R4
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_G29_101:
        LDR.N    R0,??gcode_G29_9+0x8C
        LDRB     R0,[R0, #+66]
        MOVS     R1,#+6
        TST      R0,R1
        BEQ.N    ??gcode_G29_118
        LDR      R0,[SP, #+48]
        CMP      R0,#+1
        BLT.N    ??gcode_G29_119
        LDR.N    R1,??gcode_G29_9+0x90
        LDR.N    R0,??gcode_G29_9+0x68
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
??gcode_G29_119:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BNE.N    ??gcode_G29_120
        LDR.N    R4,??gcode_G29_9+0x94
        MOVS     R2,#+12
        ADD      R1,R4,#+16
        ADD      R0,SP,#+0
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
        LDR.N    R1,??gcode_G29_9
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN7Planner16unapply_levelingEPf
        BL       _ZN7Planner16unapply_levelingEPf
        LDR.N    R1,??gcode_G29_9
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        LDR.N    R0,??gcode_G29_9+0x8C
        LDR      R1,[SP, #+56]
        LDR      R0,[R0, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+16]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.N    R6,??gcode_G29_9+0x98  ;; 0xb58637bd
        MOV      R1,R6
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_121
        LDR.N    R7,??gcode_G29_9+0x9C  ;; 0x358637be
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_121
        LDR      R0,[SP, #+36]
        LDR      R1,[SP, #+52]
        LDR      R0,[R0, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R4, #+20]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R6
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_G29_121
        MOV      R1,R7
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_G29_121
        LDR      R0,[R4, #+24]
        LDR      R1,[SP, #+32]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+8]
??gcode_G29_121:
        MOVS     R2,#+12
        ADD      R1,SP,#+0
        ADD      R0,R4,#+16
          CFI FunCall __aeabi_memcpy4
        BL       __aeabi_memcpy4
??gcode_G29_122:
        LDR.N    R1,??gcode_G29_9
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
??gcode_G29_98:
          CFI FunCall _Z36clean_up_after_endstop_or_probe_movev
        BL       _Z36clean_up_after_endstop_or_probe_movev
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
        MOVS     R0,#+1
        LDR.N    R1,??gcode_G29_9+0xA0
        STRB     R0,[R1, #+9]
        LDR.N    R0,??gcode_G29_9
        LDRB     R0,[R0, #+0]
        CBZ.N    R0,??gcode_G29_123
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
??gcode_G29_123:
        LDR      R0,[SP, #+64]
          CFI FunCall free
        BL       free
        LDR      R0,[SP, #+44]
          CFI FunCall free
        BL       free
??gcode_G29_0:
        ADD      SP,SP,#+828
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
          CFI CFA R13+864
??gcode_G29_118:
        CMP      R0,#+8
        ITT      EQ 
        LDREQ    R0,[SP, #+60]
        CMPEQ    R0,#+0
        BNE.N    ??gcode_G29_120
        LDR.N    R4,??gcode_G29_9+0x94
        ADD      R0,R4,#+16
          CFI FunCall _Z17bilinear_z_offsetPKf
        BL       _Z17bilinear_z_offsetPKf
        MOV      R1,R0
        LDR      R0,[R4, #+24]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+24]
        B.N      ??gcode_G29_122
??gcode_G29_120:
        LDR      R0,[SP, #+60]
        CMP      R0,#+0
        BEQ.N    ??gcode_G29_122
        LDR.N    R0,??gcode_G29_9
        STRB     R6,[R0, #+0]
        B.N      ??gcode_G29_98
        DATA
??gcode_G29_9:
        DC32     _ZN7Planner15leveling_activeE
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     errormagic
        DC32     _ZZ9gcode_G29vEs_1
        DC32     0xc1200000
        DC32     0x41200001
        DC32     _ZZ9gcode_G29vEs_2
        DC32     ??gridx
        DC32     z_values
        DC32     _ZZ9gcode_G29vEs_3
        DC32     _ZZ9gcode_G29vEs_4
        DC32     0x42700000
        DC32     home_dir_P
        DC32     mksTmp
        DC32     _ZZ9gcode_G29vEs_5
        DC32     _ZZ9gcode_G29vEs_6
        DC32     _ZZ9gcode_G29vEs_7
        DC32     _ZZ9gcode_G29vEs_8
        DC32     _ZZ9gcode_G29vEs_9
        DC32     _ZZ9gcode_G29vEs__10_
        DC32     Serial3
        DC32     0x3fe00000
        DC32     0xbf800000
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ9gcode_G29vEs__11_
        DC32     _ZZ9gcode_G29vEs__12_
        DC32     _ZZ9gcode_G29vEs__13_
        DC32     _ZZ9gcode_G29vEs__14_
        DC32     _ZZ9gcode_G29vEs__15_
        DC32     0x4479c000
        DC32     _ZZ9gcode_G29vEs__16_
        DC32     _ZZ9gcode_G29vEs__17_
        DC32     mksCfg
        DC32     _ZZ9gcode_G29vEs__18_
        DC32     axis_relative_modes
        DC32     0xb58637bd
        DC32     0x358637be
        DC32     axis_homed
          CFI EndBlock cfiBlock172

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G42v
          CFI Block cfiBlock173 Using cfiCommon0
          CFI Function _Z9gcode_G42v
        THUMB
_Z9gcode_G42v:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R4,??gcode_G42_0
        LDRB     R0,[R4, #+4]
        CMP      R0,#+0
        BEQ.W    ??gcode_G42_1
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G42_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G42_2
        MOVS     R5,#+1
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        SXTB     R6,R0
        B.N      ??gcode_G42_3
??gcode_G42_2:
        MOVS     R5,#+0
        MOVS     R6,#+0
??gcode_G42_3:
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G42_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G42_4
        MOVS     R7,#+1
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        SXTB     R9,R0
        B.N      ??gcode_G42_5
??gcode_G42_4:
        MOVS     R7,#+0
        MOV      R9,R7
??gcode_G42_5:
        LDR.W    R8,??gcode_G42_0+0x8
        CBZ.N    R5,??gcode_G42_6
        CMP      R6,#+0
        BMI.N    ??gcode_G42_7
        ADD      R0,R8,#+66
        LDRB     R0,[R0, #+30]
        SUBS     R0,R0,#+1
        CMP      R0,R6
        BLT.N    ??gcode_G42_7
??gcode_G42_6:
        CBZ.N    R7,??gcode_G42_8
        CMP      R9,#+0
        BMI.N    ??gcode_G42_7
        ADD      R0,R8,#+66
        LDRB     R0,[R0, #+31]
        SUBS     R0,R0,#+1
        CMP      R0,R9
        BGE.N    ??gcode_G42_8
??gcode_G42_7:
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        LDR.N    R0,??gcode_G42_0+0xC
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_8:
        ADD      R0,R4,#+16
        LDM      R0!,{R2,R3,R12,LR}
        ADD      R1,R4,#+32
        STM      R1!,{R2,R3,R12,LR}
        CBZ.N    R5,??gcode_G42_9
        LDRB     R10,[R8, #+66]
        LSLS     R0,R10,#+28
        BPL.N    ??gcode_G42_10
        LDR.N    R0,??gcode_G42_0+0x10
        LDR      R1,[R0, #+16]
        LDR      R0,[R0, #+8]
        MLA      R0,R0,R6,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R4, #+32]
??gcode_G42_10:
        LSLS     R0,R10,#+27
        BPL.N    ??gcode_G42_11
        UXTB     R0,R6
          CFI FunCall _ZN20unified_bed_leveling18mesh_index_to_xposEh
        BL       _ZN20unified_bed_leveling18mesh_index_to_xposEh
        STR      R0,[R4, #+32]
??gcode_G42_11:
        LSLS     R0,R10,#+26
        BPL.N    ??gcode_G42_9
        LDR.N    R0,??gcode_G42_0+0x14
        LDR      R0,[R0, R6, LSL #+2]
        STR      R0,[R4, #+32]
??gcode_G42_9:
        CBZ.N    R7,??gcode_G42_12
        LDRB     R6,[R8, #+66]
        LSLS     R0,R6,#+28
        BPL.N    ??gcode_G42_13
        LDR.N    R0,??gcode_G42_0+0x10
        LDR      R1,[R0, #+20]
        LDR      R0,[R0, #+12]
        MLA      R0,R0,R9,R1
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        STR      R0,[R4, #+36]
??gcode_G42_13:
        LSLS     R0,R6,#+27
        BPL.N    ??gcode_G42_14
        UXTB     R0,R9
          CFI FunCall _ZN20unified_bed_leveling18mesh_index_to_yposEh
        BL       _ZN20unified_bed_leveling18mesh_index_to_yposEh
        STR      R0,[R4, #+36]
??gcode_G42_14:
        LSLS     R0,R6,#+26
        BPL.N    ??gcode_G42_12
        LDR.N    R0,??gcode_G42_0+0x18
        LDR      R0,[R0, R9, LSL #+2]
        STR      R0,[R4, #+36]
??gcode_G42_12:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_G42_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G42_15
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CBNZ.N   R0,??gcode_G42_16
        B.N      ??gcode_G42_17
??gcode_G42_15:
        MOVS     R0,#+80
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CBZ.N    R0,??gcode_G42_17
??gcode_G42_16:
        CBZ.N    R5,??gcode_G42_18
        LDR      R0,[R4, #+32]
        LDR      R1,[R8, #+108]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+32]
??gcode_G42_18:
        CBZ.N    R7,??gcode_G42_17
        LDR      R0,[R4, #+36]
        LDR      R1,[R8, #+112]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[R4, #+36]
??gcode_G42_17:
        MOVS     R0,#+70
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_G42_19
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_G42_19
        LDR.N    R1,??gcode_G42_0+0x1C  ;; 0x42700000
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        STR      R0,[R4, #+112]
??gcode_G42_19:
        ADD      R0,R8,#+66
        MOV      R1,#+768
        LDRH     R0,[R0, #+22]
        TST      R0,R1
        ITT      EQ 
        POPEQ    {R4-R10,LR}
          CFI FunCall _Z27prepare_move_to_destinationv
        BEQ.W    _Z27prepare_move_to_destinationv
        POP      {R4-R10,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
        MOVS     R0,#+0
          CFI FunCall _Z42prepare_uninterpolated_move_to_destinationf
        B.W      _Z42prepare_uninterpolated_move_to_destinationf
          CFI R4 Frame(CFA, -32)
          CFI R5 Frame(CFA, -28)
          CFI R6 Frame(CFA, -24)
          CFI R7 Frame(CFA, -20)
          CFI R8 Frame(CFA, -16)
          CFI R9 Frame(CFA, -12)
          CFI R10 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_G42_1:
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??gcode_G42_0:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     mksCfg
        DC32     _ZZ9gcode_G42vEs
        DC32     ??gridx
        DC32     _ZN17mesh_bed_leveling13index_to_xposE
        DC32     _ZN17mesh_bed_leveling13index_to_yposE
        DC32     0x42700000
          CFI EndBlock cfiBlock173

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_G92v
          CFI Block cfiBlock174 Using cfiCommon0
          CFI Function _Z9gcode_G92v
        THUMB
_Z9gcode_G92v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R0,??gcode_G92_0
        LDRB     R0,[R0, #+0]
        MOVS     R4,#+0
        LSRS     R0,R0,#+4
        ANDS     R0,R0,#0x1
        BEQ.N    ??gcode_G92_1
        LDR.N    R1,??gcode_G92_0+0x4
        LDR.N    R5,??gcode_G92_0+0x8
        LDRB     R1,[R1, #+4]
        CBZ.N    R1,??gcode_G92_2
        LDR.N    R2,??gcode_G92_0+0xC
        LDR      R2,[R2, #+0]
        ADDS     R1,R1,R2
??gcode_G92_2:
        STR      R1,[R5, #+0]
??gcode_G92_1:
        STR      R0,[SP, #+0]
        CBNZ.N   R0,??gcode_G92_3
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
??gcode_G92_3:
        LDR.W    R8,??gcode_G92_0+0x10
        LDR.W    R9,??gcode_G92_0+0x14
        LDR.W    R10,??gcode_G92_0+0x18
        LDR.N    R5,??gcode_G92_0+0x8
        MOVS     R6,#+0
        ADD      R7,R8,#+16
??gcode_G92_4:
        LDRSB    R0,[R9, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R5, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_G92_5
        LDR.N    R0,??gcode_G92_0+0x1C
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??gcode_G92_6
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R7, #+0]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_5
        MOVS     R4,#+1
        B.N      ??gcode_G92_5
??gcode_G92_6:
        LDR      R11,[R7, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R7, #+0]
        CMP      R6,#+3
        BEQ.N    ??gcode_G92_5
        MOVS     R4,#+1
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR      R1,[R10, #+0]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R10, #+0]
        SXTB     R0,R6
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??gcode_G92_5:
        ADDS     R6,R6,#+1
        ADDS     R7,R7,#+4
        ADD      R10,R10,#+4
        ADD      R9,R9,#+1
        CMP      R6,#+4
        BLT.N    ??gcode_G92_4
        CBZ.N    R4,??gcode_G92_7
          CFI FunCall _Z28SYNC_PLAN_POSITION_KINEMATICv
        BL       _Z28SYNC_PLAN_POSITION_KINEMATICv
        B.N      ??gcode_G92_8
??gcode_G92_7:
        LDR      R0,[SP, #+0]
        CBZ.N    R0,??gcode_G92_8
        ADD      R1,R8,#+28
        MOVS     R0,#+3
          CFI FunCall _ZN7Planner15set_position_mmE8AxisEnumRKf
        BL       _ZN7Planner15set_position_mmE8AxisEnumRKf
??gcode_G92_8:
        POP      {R0,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z23report_current_positionv
        B.W      _Z23report_current_positionv
        Nop      
        DATA
??gcode_G92_0:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     axis_relative_modes
        DC32     axis_codes
        DC32     home_dir_P+0x50
        DC32     mksCfg
          CFI EndBlock cfiBlock174

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M24v
          CFI Block cfiBlock175 Using cfiCommon0
          CFI Function _Z9gcode_M24v
        THUMB
_Z9gcode_M24v:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
          CFI FunCall mks_resumePrint
        BL       mks_resumePrint
        LDR.N    R0,??gcode_M24_0
        LDRB     R1,[R0, #+2068]
        CMP      R1,#+171
        IT       NE 
        CMPNE    R1,#+172
        BEQ.N    ??gcode_M24_1
          CFI FunCall _ZN10CardReader14startFileprintEv
        BL       _ZN10CardReader14startFileprintEv
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
        LDR.N    R0,??gcode_M24_0+0x4
          CFI FunCall _ZN9Stopwatch5startEv
        B.W      _ZN9Stopwatch5startEv
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M24_1:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M24_0:
        DC32     card
        DC32     axis_relative_modes+0x84
          CFI EndBlock cfiBlock175

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M104v
          CFI Block cfiBlock176 Using cfiCommon0
          CFI Function _Z10gcode_M104v
        THUMB
_Z10gcode_M104v:
        PUSH     {R3-R5,LR}
          CFI R14 Frame(CFA, -4)
          CFI R5 Frame(CFA, -8)
          CFI R4 Frame(CFA, -12)
          CFI CFA R13+16
        MOVS     R0,#+104
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CBNZ.N   R0,??gcode_M104_0
        LDR.N    R4,??gcode_M104_1
        LDRB     R0,[R4, #+5]
        LSLS     R0,R0,#+28
        BMI.N    ??gcode_M104_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_M104_1+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_M104_2
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRB     R5,[R4, #+13]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.N    R1,??gcode_M104_1+0x8
        STR      R0,[R1, R5, LSL #+2]
        MOV      R0,R5
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        BL       _ZN11Temperature21start_watching_heaterEh
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M104_1+0xC
        LDR      R1,[R0, #+44]
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        ITT      LS 
        ADDLS    R0,R4,#+132
          CFI FunCall _ZN9Stopwatch4stopEv
        BLLS     _ZN9Stopwatch4stopEv
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
??gcode_M104_2:
        POP      {R0,R4,R5,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        B.W      _ZN7Planner18autotemp_M104_M109Ev
          CFI R4 Frame(CFA, -12)
          CFI R5 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+16
??gcode_M104_0:
        POP      {R0,R4,R5,PC}    ;; return
        DATA
??gcode_M104_1:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11Temperature18target_temperatureE
        DC32     mksCfg
          CFI EndBlock cfiBlock176

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M109v
          CFI Block cfiBlock177 Using cfiCommon0
          CFI Function _Z10gcode_M109v
        THUMB
_Z10gcode_M109v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+12
          CFI CFA R13+48
        MOVS     R0,#+109
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.W    ??gcode_M109_0
        LDR.N    R4,??gcode_M109_1
        LDRB     R0,[R4, #+5]
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M109_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_M109_1+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_M109_2
        MOVS     R0,#+1
        STR      R0,[SP, #+8]
??gcode_M109_3:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDRB     R5,[R4, #+13]
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        SXTH     R0,R0
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        LDR.N    R1,??gcode_M109_1+0x8
        STR      R0,[R1, R5, LSL #+2]
        MOV      R0,R5
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        BL       _ZN11Temperature21start_watching_heaterEh
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M109_1+0xC
        LDR      R1,[R0, #+44]
        ADD      R6,R4,#+132
        MOV      R0,#+1056964608
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R1,R5
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        MOV      R0,R6
        BHI.N    ??gcode_M109_4
          CFI FunCall _ZN9Stopwatch4stopEv
        BL       _ZN9Stopwatch4stopEv
        B.N      ??gcode_M109_5
??gcode_M109_2:
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.W    ??gcode_M109_0
        LDR.N    R0,??gcode_M109_1+0x4
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??gcode_M109_3
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+48
??gcode_M109_4:
          CFI FunCall _ZN9Stopwatch5startEv
        BL       _ZN9Stopwatch5startEv
??gcode_M109_5:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall _ZN7Planner18autotemp_M104_M109Ev
        BL       _ZN7Planner18autotemp_M104_M109Ev
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
        MOVS     R5,#+0
        LDRB     R0,[R4, #+13]
        LDR.W    R9,??gcode_M109_1+0x10  ;; 0xbf800000
        LDR.W    R11,??gcode_M109_1+0x14  ;; 0x461c3c00
        STR      R5,[SP, #+4]
        MOVS     R7,#+0
        STR      R5,[SP, #+0]
          CFI FunCall _ZN11Temperature21start_watching_heaterEh
        BL       _ZN11Temperature21start_watching_heaterEh
        MOVS     R0,#+1
        LDR.N    R1,??gcode_M109_1+0x18
        LDR.W    R8,??gcode_M109_1+0x1C
        STRB     R0,[R1, #+0]
??gcode_M109_6:
        LDRB     R6,[R4, #+13]
        LDR.N    R0,??gcode_M109_1+0x8
        LDR      R0,[R0, R6, LSL #+2]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R2,R0
        MOV      R0,R9
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M109_7
        LDR.N    R1,??gcode_M109_1+0x20
        LDR      R1,[R1, R6, LSL #+2]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITE      CC 
        MOVCC    R7,#+1
        MOVCS    R7,#+0
        LDR      R0,[SP, #+8]
        UXTB     R0,R0
        MOV      R9,R2
        TST      R0,R7
        BNE.N    ??gcode_M109_8
??gcode_M109_7:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
        LDR      R0,[SP, #+4]
        SUBS     R0,R6,R0
        BMI.N    ??gcode_M109_9
        ADD      R0,R6,#+1000
        STR      R0,[SP, #+4]
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.W    R10,??gcode_M109_1+0x24
        B.N      ??gcode_M109_10
??gcode_M109_11:
        UXTB     R1,R1
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_10:
        LDRSB    R1,[R10], #+1
        MOVS     R0,R1
        BNE.N    ??gcode_M109_11
        CBZ.N    R5,??gcode_M109_12
        MOVW     R0,#+10000
        SUBS     R0,R0,R6
        ADDS     R0,R5,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOVS     R2,#+10
        MOV      R0,R8
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M109_13
??gcode_M109_12:
        MOVS     R1,#+63
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_13:
        MOVS     R1,#+10
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M109_9:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R4, #+120]
        LDR.N    R1,??gcode_M109_1+0x20
        LDRB     R0,[R4, #+13]
        LDR      R10,[R1, R0, LSL #+2]
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CBNZ.N   R5,??gcode_M109_14
        MOV      R1,#+1065353216
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M109_15
        B.N      ??gcode_M109_16
??gcode_M109_14:
        LDR.N    R1,??gcode_M109_1+0x28  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M109_15
??gcode_M109_16:
        MOV      R5,R6
??gcode_M109_15:
        CBZ.N    R7,??gcode_M109_17
        LDR      R0,[SP, #+0]
        CBZ.N    R0,??gcode_M109_18
        SUBS     R0,R6,R0
        BMI.N    ??gcode_M109_17
??gcode_M109_18:
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M109_8
        ADD      R0,R6,#+59904
        ADDS     R0,R0,#+96
        STR      R0,[SP, #+0]
        MOV      R11,R10
??gcode_M109_17:
        LDRB     R0,[R4, #+12]
        CBZ.N    R0,??gcode_M109_8
        CMP      R5,#+0
        BEQ.N    ??gcode_M109_6
        SUBS     R0,R6,R5
        LDR.N    R1,??gcode_M109_1+0x2C  ;; 0xffffd8f0
        ADDS     R0,R1,R0
        BMI.N    ??gcode_M109_6
??gcode_M109_8:
        MOVS     R0,#+0
        LDR.N    R1,??gcode_M109_1+0x18
        STRB     R0,[R1, #+0]
        LDRB     R0,[R4, #+12]
??gcode_M109_0:
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??gcode_M109_1:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11Temperature18target_temperatureE
        DC32     mksCfg
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     mks_heating_busy
        DC32     Serial3
        DC32     _ZN11Temperature19current_temperatureE
        DC32     _ZZ10gcode_M109vEs_5
        DC32     0x40000001
        DC32     0xffffd8f0
          CFI EndBlock cfiBlock177

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M190v
          CFI Block cfiBlock178 Using cfiCommon0
          CFI Function _Z10gcode_M190v
        THUMB
_Z10gcode_M190v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        LDR.N    R4,??gcode_M190_0
        LDRB     R0,[R4, #+5]
        SUB      SP,SP,#+12
          CFI CFA R13+48
        LSLS     R0,R0,#+28
        BMI.W    ??gcode_M190_1
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_M190_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_M190_2
        MOVS     R0,#+1
        STR      R0,[SP, #+8]
??gcode_M190_3:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
          CFI FunCall _ZN11Temperature12setTargetBedEf
        BL       _ZN11Temperature12setTargetBedEf
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R5,R0
        LDR.N    R0,??gcode_M190_0+0x8
        LDRSH    R0,[R0, #+52]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R1,R5
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITT      CC 
        ADDCC    R0,R4,#+132
          CFI FunCall _ZN9Stopwatch5startEv
        BLCC     _ZN9Stopwatch5startEv
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
        MOVS     R5,#+0
        LDRB     R0,[R4, #+10]
        LDR.W    R9,??gcode_M190_0+0xC  ;; 0xbf800000
        LDR.W    R11,??gcode_M190_0+0x10  ;; 0x461c3c00
        LDR.N    R1,??gcode_M190_0+0x14
        LDR.W    R8,??gcode_M190_0+0x18
        STRB     R0,[R4, #+13]
        STR      R5,[SP, #+4]
        STR      R5,[SP, #+0]
        MOVS     R0,#+1
        MOVS     R7,#+0
        STRB     R0,[R1, #+0]
??gcode_M190_4:
        LDR.N    R0,??gcode_M190_0+0x1C
        LDRSH    R0,[R0, #+0]
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        MOV      R2,R0
        MOV      R0,R9
        MOV      R1,R2
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M190_5
        LDR.N    R1,??gcode_M190_0+0x20
        LDR      R1,[R1, #+0]
        MOV      R0,R2
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        ITE      CC 
        MOVCC    R7,#+1
        MOVCS    R7,#+0
        B.N      ??gcode_M190_6
??gcode_M190_2:
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
        MOVS     R0,#+82
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M190_1
        LDR.N    R0,??gcode_M190_0+0x4
        LDR      R0,[R0, #+0]
        CMP      R0,#+0
        BNE.N    ??gcode_M190_3
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+48
??gcode_M190_6:
        LDR      R0,[SP, #+8]
        UXTB     R0,R0
        MOV      R9,R2
        TST      R0,R7
        BNE.N    ??gcode_M190_7
??gcode_M190_5:
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        MOV      R6,R0
        LDR      R0,[SP, #+4]
        SUBS     R0,R6,R0
        BMI.N    ??gcode_M190_8
        ADD      R0,R6,#+1000
        STR      R0,[SP, #+4]
          CFI FunCall _ZN11Temperature18print_heaterstatesEv
        BL       _ZN11Temperature18print_heaterstatesEv
        LDR.W    R10,??gcode_M190_0+0x24
        B.N      ??gcode_M190_9
??gcode_M190_10:
        UXTB     R1,R1
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_9:
        LDRSB    R1,[R10], #+1
        MOVS     R0,R1
        BNE.N    ??gcode_M190_10
        CBZ.N    R5,??gcode_M190_11
        MOVW     R0,#+10000
        SUBS     R0,R0,R6
        ADDS     R0,R5,R0
        MOV      R1,#+1000
        UDIV     R1,R0,R1
        MOVS     R2,#+10
        MOV      R0,R8
          CFI FunCall _ZN5Print5printEli
        BL       _ZN5Print5printEli
        B.N      ??gcode_M190_12
??gcode_M190_11:
        MOVS     R1,#+63
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_12:
        MOVS     R1,#+10
        MOV      R0,R8
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M190_8:
          CFI FunCall _Z4idlev
        BL       _Z4idlev
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        STR      R0,[R4, #+120]
        LDR.N    R0,??gcode_M190_0+0x20
        LDR      R10,[R0, #+0]
        MOV      R0,R9
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        BIC      R0,R0,#0x80000000
        CBNZ.N   R5,??gcode_M190_13
        MOV      R1,#+1065353216
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M190_14
        B.N      ??gcode_M190_15
??gcode_M190_13:
        LDR.N    R1,??gcode_M190_0+0x28  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M190_14
??gcode_M190_15:
        MOV      R5,R6
??gcode_M190_14:
        CBZ.N    R7,??gcode_M190_16
        LDR      R0,[SP, #+0]
        CBZ.N    R0,??gcode_M190_17
        SUBS     R0,R6,R0
        BMI.N    ??gcode_M190_16
??gcode_M190_17:
        MOV      R0,R11
        MOV      R1,R10
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R1,#+1069547520
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M190_7
        ADD      R0,R6,#+59904
        ADDS     R0,R0,#+96
        STR      R0,[SP, #+0]
        MOV      R11,R10
??gcode_M190_16:
        LDRB     R0,[R4, #+12]
        CBZ.N    R0,??gcode_M190_7
        CMP      R5,#+0
        BEQ.W    ??gcode_M190_4
        SUBS     R0,R6,R5
        LDR.N    R1,??gcode_M190_0+0x2C  ;; 0xffffd8f0
        ADDS     R0,R1,R0
        BMI.W    ??gcode_M190_4
??gcode_M190_7:
        LDR.N    R1,??gcode_M190_0+0x14
        MOVS     R0,#+0
        STRB     R0,[R1, #+0]
        LDRB     R0,[R4, #+12]
??gcode_M190_1:
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??gcode_M190_0:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     mksCfg
        DC32     0xbf800000
        DC32     0x461c3c00
        DC32     mks_heating_busy
        DC32     Serial3
        DC32     _ZN11Temperature22target_temperature_bedE
        DC32     _ZN11Temperature23current_temperature_bedE
        DC32     _ZZ10gcode_M190vEs_0
        DC32     0x40000001
        DC32     0xffffd8f0
          CFI EndBlock cfiBlock178

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M140v
          CFI Block cfiBlock179 Using cfiCommon0
          CFI Function _Z10gcode_M140v
        THUMB
_Z10gcode_M140v:
        LDR.N    R0,??gcode_M140_0
        LDRB     R0,[R0, #+5]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M140_1
        BX       LR
??gcode_M140_1:
        PUSH     {R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R0,??gcode_M140_0+0x4
        LDRNE    R0,[R0, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_M140_2
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        POP      {R1,LR}
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN11Temperature12setTargetBedEf
        B.W      _ZN11Temperature12setTargetBedEf
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+8
??gcode_M140_2:
        POP      {R0,PC}          ;; return
        DATA
??gcode_M140_0:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser9value_ptrE
          CFI EndBlock cfiBlock179

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z13gcode_M18_M84v
          CFI Block cfiBlock180 Using cfiCommon0
          CFI Function _Z13gcode_M18_M84v
        THUMB
_Z13gcode_M18_M84v:
        PUSH     {R3-R9,LR}
          CFI R14 Frame(CFA, -4)
          CFI R9 Frame(CFA, -8)
          CFI R8 Frame(CFA, -12)
          CFI R7 Frame(CFA, -16)
          CFI R6 Frame(CFA, -20)
          CFI R5 Frame(CFA, -24)
          CFI R4 Frame(CFA, -28)
          CFI CFA R13+32
        LDR.N    R4,??gcode_M18_M84_0
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R4, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_M18_M84_1
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_M18_M84_0+0x4  ;; 0x447a0000
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        LDR.N    R1,??gcode_M18_M84_0+0x8
        STR      R0,[R1, #+0]
        POP      {R0,R4-R9,PC}
??gcode_M18_M84_1:
        LDR.N    R6,??gcode_M18_M84_0+0xC
        LDR.N    R5,??gcode_M18_M84_0+0x10
        LDRB     R0,[R6, #+2]
        LSLS     R0,R0,#+24
        BPL.N    ??gcode_M18_M84_2
        LDRB     R0,[R5, #+23]
        CBNZ.N   R0,??gcode_M18_M84_3
??gcode_M18_M84_4:
        STR      R0,[R4, #+0]
          CFI FunCall _ZN7Stepper11synchronizeEv
        BL       _ZN7Stepper11synchronizeEv
        LDRB     R0,[R6, #+2]
        LSLS     R0,R0,#+24
        BPL.N    ??gcode_M18_M84_5
        LDRB     R0,[R5, #+23]
        CMP      R0,#+0
        ITTT     NE 
        LDRNE.N  R1,??gcode_M18_M84_0+0x14
        LDRNE    R1,[R1, #+0]
        ADDNE    R0,R0,R1
        B.N      ??gcode_M18_M84_6
??gcode_M18_M84_3:
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        B.N      ??gcode_M18_M84_4
??gcode_M18_M84_2:
        LDRB     R0,[R6, #+3]
        LSLS     R1,R0,#+31
        BPL.N    ??gcode_M18_M84_7
        LDRB     R0,[R5, #+24]
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        B.N      ??gcode_M18_M84_4
??gcode_M18_M84_7:
        LSLS     R0,R0,#+30
        BPL.N    ??gcode_M18_M84_8
        LDRB     R0,[R5, #+25]
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        B.N      ??gcode_M18_M84_4
??gcode_M18_M84_8:
        LDRB     R0,[R6, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_M18_M84_9
        LDRB     R0,[R5, #+4]
        CMP      R0,#+0
        BEQ.N    ??gcode_M18_M84_4
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        B.N      ??gcode_M18_M84_4
??gcode_M18_M84_9:
        POP      {R0,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Stepper18finish_and_disableEv
        B.W      _ZN7Stepper18finish_and_disableEv
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M18_M84_6:
        STR      R0,[R4, #+0]
        LDR.N    R0,??gcode_M18_M84_0+0x18
        LDRB     R0,[R0, #+260]
        SUBS     R2,R0,#+1
        LDR.N    R0,??gcode_M18_M84_0+0x1C
        LDRH     R1,[R0, #+4]
        LDR.N    R0,??gcode_M18_M84_0+0x20
        LDR      R0,[R0, #+8]
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.N    R1,??gcode_M18_M84_0+0x24
        MOVS     R0,#+0
        STRB     R0,[R1, #+4]
??gcode_M18_M84_5:
        LDRB     R0,[R6, #+3]
        LSLS     R0,R0,#+31
        BPL.N    ??gcode_M18_M84_10
        LDRB     R0,[R5, #+24]
        CBZ.N    R0,??gcode_M18_M84_11
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M18_M84_11:
        STR      R0,[R4, #+0]
        LDR.N    R0,??gcode_M18_M84_0+0x28
        LDRB     R0,[R0, #+1]
        SUBS     R2,R0,#+1
        LDR.N    R0,??gcode_M18_M84_0+0x1C
        LDRH     R1,[R0, #+14]
        LDR.N    R0,??gcode_M18_M84_0+0x20
        LDR      R0,[R0, #+28]
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.N    R1,??gcode_M18_M84_0+0x24
        MOVS     R0,#+0
        STRB     R0,[R1, #+5]
??gcode_M18_M84_10:
        LDRB     R0,[R6, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??gcode_M18_M84_12
        LDRB     R0,[R5, #+25]
        CBZ.N    R0,??gcode_M18_M84_13
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M18_M84_13:
        STR      R0,[R4, #+0]
        LDR.W    R9,??gcode_M18_M84_0+0x28
        LDR.N    R7,??gcode_M18_M84_0+0x20
        LDRB     R0,[R9, #+2]
        LDR.W    R8,??gcode_M18_M84_0+0x1C
        LDRH     R1,[R8, #+24]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R7, #+48]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDRB     R0,[R9, #+2]
        LDRH     R1,[R8, #+40]
        SUBS     R2,R0,#+1
        SBCS     R2,R2,R2
        LSRS     R2,R2,#+31
        LDR      R0,[R7, #+80]
        SXTB     R2,R2
          CFI FunCall HAL_GPIO_WritePin
        BL       HAL_GPIO_WritePin
        LDR.N    R1,??gcode_M18_M84_0+0x24
        MOVS     R0,#+0
        STRB     R0,[R1, #+6]
??gcode_M18_M84_12:
        LDRB     R0,[R6, #+0]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_M18_M84_14
        LDRB     R0,[R5, #+4]
        CBZ.N    R0,??gcode_M18_M84_15
        LDR.N    R1,??gcode_M18_M84_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M18_M84_15:
        STR      R0,[R4, #+0]
        POP      {R0,R4-R9,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z18disable_e_steppersv
        B.W      _Z18disable_e_steppersv
          CFI R4 Frame(CFA, -28)
          CFI R5 Frame(CFA, -24)
          CFI R6 Frame(CFA, -20)
          CFI R7 Frame(CFA, -16)
          CFI R8 Frame(CFA, -12)
          CFI R9 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+32
??gcode_M18_M84_14:
        POP      {R0,R4-R9,PC}    ;; return
        DATA
??gcode_M18_M84_0:
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     0x447a0000
        DC32     stepper_inactive_time
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     mksCfg
        DC32     gArrayGpioPin
        DC32     gArrayGpioPort
        DC32     axis_homed
        DC32     mksCfg+0x104
          CFI EndBlock cfiBlock180

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z9gcode_M92v
          CFI Block cfiBlock181 Using cfiCommon0
          CFI Function _Z9gcode_M92v
        THUMB
_Z9gcode_M92v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOVS     R0,#+92
          CFI FunCall _Z32get_target_extruder_from_commandt
        BL       _Z32get_target_extruder_from_commandt
        CMP      R0,#+0
        BNE.N    ??gcode_M92_0
        MOVS     R4,#+0
        LDR.W    R10,??gcode_M92_1
        LDR.N    R6,??gcode_M92_1+0x4
??gcode_M92_2:
        LDRSB    R0,[R10, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        BEQ.N    ??gcode_M92_3
        CMP      R4,#+3
        BNE.N    ??gcode_M92_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R11,R0
        LDR.N    R0,??gcode_M92_1+0x8
        LDR.N    R1,??gcode_M92_1+0xC  ;; 0x41a00000
        LDRB     R5,[R0, #+13]
        LDR.N    R0,??gcode_M92_1+0x4
        ADD      R8,R0,R5, LSL #+2
        MOV      R0,R11
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??gcode_M92_5
        LDR      R0,[R8, #+12]
        MOV      R1,R11
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R9,R0
        LDR.N    R0,??gcode_M92_1+0x10
        LDR      R0,[R0, #+12]
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        LDR.N    R1,??gcode_M92_1+0x10
        STR      R0,[R1, #+12]
        MOV      R1,R9
        LDR.N    R0,??gcode_M92_1+0x14
        ADD      R7,R0,R5, LSL #+2
        LDR      R0,[R7, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[R7, #+12]
        LDR.N    R0,??gcode_M92_1+0x18
        ADD      R5,R0,R5, LSL #+2
        LDR      R0,[R5, #+12]
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2uiz
        BL       __aeabi_f2uiz
        STR      R0,[R5, #+12]
??gcode_M92_5:
        STR      R11,[R8, #+12]
        B.N      ??gcode_M92_3
??gcode_M92_4:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[R6, #+0]
??gcode_M92_3:
        ADDS     R4,R4,#+1
        ADDS     R6,R6,#+4
        ADD      R10,R10,#+1
        CMP      R4,#+4
        BLT.N    ??gcode_M92_2
        POP      {R0,R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _ZN7Planner19refresh_positioningEv
        B.W      _ZN7Planner19refresh_positioningEv
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+40
??gcode_M92_0:
        POP      {R0,R4-R11,PC}   ;; return
        Nop      
        DATA
??gcode_M92_1:
        DC32     axis_codes
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     axis_relative_modes
        DC32     0x41a00000
        DC32     _ZN7Planner8max_jerkE
        DC32     _ZN7Planner17max_feedrate_mm_sE
        DC32     _ZN7Planner29max_acceleration_steps_per_s2E
          CFI EndBlock cfiBlock181

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M290v
          CFI Block cfiBlock182 Using cfiCommon0
          CFI Function _Z10gcode_M290v
        THUMB
_Z10gcode_M290v:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        MOVS     R4,#+0
        LDR.W    R9,??gcode_M290_0
        LDR.N    R6,??gcode_M290_0+0x4
        LDR.W    R10,??gcode_M290_0+0x8
        LDR.N    R5,??gcode_M290_0+0xC
        LDR.N    R7,??gcode_M290_0+0x10
        MOV      R8,#-1073741824
??gcode_M290_1:
        LDRSB    R0,[R9, #+0]
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R5, #+0]
        CMPNE    R0,#+0
        BNE.N    ??gcode_M290_2
        CMP      R4,#+2
        BNE.N    ??gcode_M290_3
        MOVS     R0,#+83
          CFI FunCall _ZN11GCodeParser4seenEc
        BL       _ZN11GCodeParser4seenEc
        CMP      R0,#+0
        ITT      NE 
        LDRNE    R0,[R5, #+0]
        CMPNE    R0,#+0
        BEQ.N    ??gcode_M290_3
??gcode_M290_2:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R1,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        IT       CC 
        MOVCC    R11,R8
        BCC.N    ??gcode_M290_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        LDR.N    R1,??gcode_M290_0+0x14  ;; 0x40000001
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        IT       LS 
        MOVLS    R11,#+1073741824
        BLS.N    ??gcode_M290_4
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOV      R11,R0
??gcode_M290_4:
        LDR      R0,[R6, #+0]
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        SXTH     R1,R0
        SXTB     R0,R4
          CFI FunCall _ZN11Temperature13babystep_axisE8AxisEnums
        BL       _ZN11Temperature13babystep_axisE8AxisEnums
        CMP      R4,#+2
        BNE.N    ??gcode_M290_3
        LDR.N    R0,??gcode_M290_0+0x18
        LDRB     R0,[R0, #+1]
        LSLS     R0,R0,#+24
        BPL.N    ??gcode_M290_5
        LDR.N    R0,??gcode_M290_0+0x1C
        LDRB     R0,[R0, #+15]
        CBNZ.N   R0,??gcode_M290_6
        STR      R0,[R5, #+0]
        B.N      ??gcode_M290_5
??gcode_M290_6:
        LDR.N    R1,??gcode_M290_0+0x20
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R5, #+0]
        BEQ.N    ??gcode_M290_5
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CBZ.N    R0,??gcode_M290_3
??gcode_M290_5:
        MOV      R1,R11
        LDR      R0,[R7, #+124]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR.W    R11,??gcode_M290_0+0x24
        STR      R0,[R7, #+124]
        B.N      ??gcode_M290_7
??gcode_M290_8:
        UXTB     R1,R1
        MOV      R0,R10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M290_7:
        LDRSB    R1,[R11], #+1
        MOVS     R0,R1
        BNE.N    ??gcode_M290_8
        LDR      R1,[R7, #+124]
        LDR.N    R0,??gcode_M290_0+0x28
          CFI FunCall _Z17serial_echopair_PPKcf
        BL       _Z17serial_echopair_PPKcf
        MOVS     R1,#+10
        MOV      R0,R10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M290_3:
        ADDS     R4,R4,#+1
        ADDS     R6,R6,#+4
        ADD      R9,R9,#+1
        CMP      R4,#+3
        BLT.N    ??gcode_M290_1
        POP      {R0,R4-R11,PC}   ;; return
        DATA
??gcode_M290_0:
        DC32     axis_codes
        DC32     _ZN7Planner17axis_steps_per_mmE
        DC32     Serial3
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     axis_relative_modes
        DC32     0x40000001
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     echomagic
        DC32     _ZZ18mod_zprobe_zoffsetRKfEs
          CFI EndBlock cfiBlock182

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M420v
          CFI Block cfiBlock183 Using cfiCommon0
          CFI Function _Z10gcode_M420v
        THUMB
_Z10gcode_M420v:
        PUSH     {R4-R10,LR}
          CFI R14 Frame(CFA, -4)
          CFI R10 Frame(CFA, -8)
          CFI R9 Frame(CFA, -12)
          CFI R8 Frame(CFA, -16)
          CFI R7 Frame(CFA, -20)
          CFI R6 Frame(CFA, -24)
          CFI R5 Frame(CFA, -28)
          CFI R4 Frame(CFA, -32)
          CFI CFA R13+32
        LDR.N    R4,??gcode_M420_0
        LDR.N    R6,??gcode_M420_0+0x4
        LDR      R0,[R4, #+16]
        LDR      R1,[R4, #+20]
        LDR.W    R8,??gcode_M420_0+0x8
        SUB      SP,SP,#+16
          CFI CFA R13+48
        STR      R0,[SP, #+4]
        ADD      R0,SP,#+4
        STR      R1,[R0, #+4]
        LDR      R1,[R4, #+24]
        STR      R1,[R0, #+8]
        LDRB     R0,[R8, #+66]
        CMP      R0,#+16
        BNE.W    ??gcode_M420_1
        LDRB     R0,[R6, #+1]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M420_2
        LDR.N    R5,??gcode_M420_0+0xC
        LDR.N    R7,??gcode_M420_0+0x10
        LDRB     R0,[R5, #+11]
        CBNZ.N   R0,??gcode_M420_3
        STR      R0,[R7, #+0]
        B.N      ??gcode_M420_4
??gcode_M420_3:
        LDR.N    R1,??gcode_M420_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R7, #+0]
        BNE.N    ??gcode_M420_5
??gcode_M420_4:
        LDR.N    R0,??gcode_M420_0+0x18
        LDRSB    R9,[R0, #+0]
        B.N      ??gcode_M420_6
??gcode_M420_5:
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R9,R0
??gcode_M420_6:
          CFI FunCall _ZN14MarlinSettings15calc_num_meshesEv
        BL       _ZN14MarlinSettings15calc_num_meshesEv
        SXTH     R0,R0
        CBNZ.N   R0,??gcode_M420_7
        LDR.N    R0,??gcode_M420_0+0x1C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}
          CFI CFA R13+48
??gcode_M420_7:
        SUB      R10,R0,#+1
        SXTB     R9,R9
        MOV      R0,R9
        CMP      R0,#+0
        BMI.N    ??gcode_M420_8
        CMP      R10,R0
        BGE.N    ??gcode_M420_9
??gcode_M420_8:
        LDR.N    R0,??gcode_M420_0+0x20
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        MOV      R1,R10
        LDR.N    R0,??gcode_M420_0+0x24
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R0,??gcode_M420_0+0x28
        MOVS     R1,#+10
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}
          CFI CFA R13+48
??gcode_M420_9:
        MOVS     R1,#+0
          CFI FunCall _ZN14MarlinSettings9load_meshEaPv
        BL       _ZN14MarlinSettings9load_meshEaPv
        LDR.N    R0,??gcode_M420_0+0x18
        STRB     R9,[R0, #+0]
        LDRB     R0,[R6, #+1]
        LSLS     R0,R0,#+28
        BPL.N    ??gcode_M420_2
        LDRB     R0,[R5, #+11]
        CBZ.N    R0,??gcode_M420_10
        LDR.N    R1,??gcode_M420_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M420_10:
        STR      R0,[R7, #+0]
        B.N      ??gcode_M420_11
??gcode_M420_2:
        LDRB     R0,[R6, #+2]
        LSLS     R0,R0,#+26
        BPL.N    ??gcode_M420_12
        LDR.N    R5,??gcode_M420_0+0xC
        LDR.N    R2,??gcode_M420_0+0x10
        LDRB     R0,[R5, #+21]
        CBZ.N    R0,??gcode_M420_13
        LDR.N    R1,??gcode_M420_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M420_13:
        STR      R0,[R2, #+0]
??gcode_M420_11:
        MOVS     R0,#+0
          CFI FunCall _ZN20unified_bed_leveling11display_mapEi
        BL       _ZN20unified_bed_leveling11display_mapEi
        LDR.N    R2,??gcode_M420_0+0x2C
        LDR      R3,[R2, #+4]
        LDR      R5,[R2, #+0]
        MOV      R0,R5
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        LDR      R1,[R2, #+8]
        MOV      R0,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        LDR      R3,[R2, #+52]
        LDR      R7,[R2, #+48]
        MOV      R0,R7
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        LDR      R1,[R2, #+56]
        MOV      R0,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        LDR      R3,[R2, #+100]
        LDR      R9,[R2, #+96]
        MOV      R0,R9
        MOV      R1,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        LDR      R1,[R2, #+104]
        MOV      R0,R3
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        MOV      R0,R5
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??gcode_M420_14
        MOV      R0,R9
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.N    ??gcode_M420_15
??gcode_M420_14:
        MOV      R0,R5
          CFI FunCall __iar_FDtest
        BL       __iar_FDtest
        CMP      R0,#+2
        IT       NE 
        MOVNE    R1,#+1
        BNE.N    ??gcode_M420_16
??gcode_M420_15:
        MOVS     R1,#+0
??gcode_M420_16:
        LDR.N    R0,??gcode_M420_0+0x30
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        LDR.N    R5,??gcode_M420_0+0x28
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        LDR.N    R0,??gcode_M420_0+0x18
        LDRSB    R1,[R0, #+0]
        LDR.N    R0,??gcode_M420_0+0x34
          CFI FunCall _Z17serial_echopair_PPKci
        BL       _Z17serial_echopair_PPKci
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
??gcode_M420_1:
        LDRB     R0,[R6, #+2]
        LSLS     R0,R0,#+26
        BPL.N    ??gcode_M420_12
        LDR.N    R5,??gcode_M420_0+0xC
        LDR.N    R2,??gcode_M420_0+0x10
        LDRB     R0,[R5, #+21]
        CBZ.N    R0,??gcode_M420_17
        LDR.N    R1,??gcode_M420_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M420_17:
        STR      R0,[R2, #+0]
        MOVS     R0,#+6
        LDRB     R5,[R8, #+66]
        TST      R5,R0
        BEQ.N    ??gcode_M420_18
        LDR.N    R1,??gcode_M420_0+0x38
        LDR.N    R0,??gcode_M420_0+0x3C
          CFI FunCall _ZN10matrix_3x35debugEPKc
        BL       _ZN10matrix_3x35debugEPKc
        B.N      ??gcode_M420_12
??gcode_M420_18:
          CFI FunCall _Z17leveling_is_validv
        BL       _Z17leveling_is_validv
        CBZ.N    R0,??gcode_M420_12
        CMP      R5,#+8
        BNE.N    ??gcode_M420_19
          CFI FunCall _Z28print_bilinear_leveling_gridv
        BL       _Z28print_bilinear_leveling_gridv
        B.N      ??gcode_M420_12
??gcode_M420_19:
        CMP      R5,#+32
        BNE.N    ??gcode_M420_12
        LDR.N    R0,??gcode_M420_0+0x40
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
          CFI FunCall _Z15mbl_mesh_reportv
        BL       _Z15mbl_mesh_reportv
??gcode_M420_12:
        LDRSH    R0,[R8, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M420_20
        LDRB     R0,[R8, #+66]
        LSLS     R0,R0,#+27
        BPL.N    ??gcode_M420_20
        LDRB     R0,[R6, #+3]
        LSLS     R0,R0,#+30
        BPL.N    ??gcode_M420_20
        LDR.N    R5,??gcode_M420_0+0xC
        LDR.N    R2,??gcode_M420_0+0x10
        LDRB     R0,[R5, #+25]
        CBZ.N    R0,??gcode_M420_21
        LDR.N    R1,??gcode_M420_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M420_21:
        STR      R0,[R2, #+0]
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        MOVS     R1,#+0
          CFI FunCall _Z17set_z_fade_heightfb
        BL       _Z17set_z_fade_heightfb
??gcode_M420_20:
        LDRB     R0,[R6, #+2]
        MOV      R8,#+0
        LSLS     R0,R0,#+29
        BPL.N    ??gcode_M420_22
        LDR.N    R5,??gcode_M420_0+0xC
        LDR.N    R2,??gcode_M420_0+0x10
        LDRB     R0,[R5, #+18]
        CBNZ.N   R0,??gcode_M420_23
        STR      R0,[R2, #+0]
        B.N      ??gcode_M420_24
??gcode_M420_23:
        LDR.N    R1,??gcode_M420_0+0x14
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
        STR      R0,[R2, #+0]
        BEQ.N    ??gcode_M420_24
          CFI FunCall _ZN11GCodeParser10value_byteEv
        BL       _ZN11GCodeParser10value_byteEv
        CBZ.N    R0,??gcode_M420_25
??gcode_M420_24:
        MOV      R8,#+1
??gcode_M420_25:
        MOV      R0,R8
          CFI FunCall _Z24set_bed_leveling_enabledb
        BL       _Z24set_bed_leveling_enabledb
??gcode_M420_22:
        LDR.N    R0,??gcode_M420_0+0x44
        LDRB     R5,[R0, #+0]
        EOR      R0,R5,#0x1
        TST      R8,R0
        BEQ.N    ??gcode_M420_26
        LDR.N    R0,??gcode_M420_0+0x48
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x4C
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_26:
        LDR.N    R6,??gcode_M420_0+0x50
        MOV      R0,R6
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        CMP      R5,#+0
        ITE      NE 
        LDRNE.N  R1,??gcode_M420_0+0x54
        LDREQ.N  R1,??gcode_M420_0+0x58
        LDR.N    R0,??gcode_M420_0+0x5C
          CFI FunCall _Z17serial_echopair_PPKcS0_
        BL       _Z17serial_echopair_PPKcS0_
        LDR.N    R5,??gcode_M420_0+0x28
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        MOV      R0,R6
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x60
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M420_0+0x64
        LDR      R0,[R0, #+0]
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BCS.N    ??gcode_M420_27
        MOVS     R1,#+2
        STR      R1,[SP, #+0]
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        MOV      R2,R0
        MOV      R3,R1
        MOV      R0,R5
          CFI FunCall _ZN5Print5printEdi
        BL       _ZN5Print5printEdi
        MOVS     R1,#+10
        MOV      R0,R5
          CFI FunCall _ZN10USARTClass5writeEh
        BL       _ZN10USARTClass5writeEh
        B.N      ??gcode_M420_28
??gcode_M420_27:
        LDR.N    R0,??gcode_M420_0+0x68
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
??gcode_M420_28:
        MOVS     R2,#+12
        ADD      R1,R4,#+16
        ADD      R0,SP,#+4
          CFI FunCall memcmp
        BL       memcmp
        CBZ.N    R0,??gcode_M420_29
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_M420_29:
        ADD      SP,SP,#+16
          CFI CFA R13+32
        POP      {R4-R10,PC}      ;; return
        Nop      
        DATA
??gcode_M420_0:
        DC32     axis_relative_modes
        DC32     _ZN11GCodeParser8codebitsE
        DC32     mksCfg
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     _ZN20unified_bed_leveling12storage_slotE
        DC32     _ZZ10gcode_M420vEs
        DC32     _ZZ10gcode_M420vEs_0
        DC32     _ZZ10gcode_M420vEs_1
        DC32     Serial3
        DC32     _ZN20unified_bed_leveling8z_valuesE
        DC32     _ZZ10gcode_M420vEs_2
        DC32     _ZZ10gcode_M420vEs_3
        DC32     _ZZ10gcode_M420vEs_4
        DC32     _ZN7Planner16bed_level_matrixE
        DC32     _ZZ10gcode_M420vEs_5
        DC32     _ZN7Planner15leveling_activeE
        DC32     errormagic
        DC32     _ZZ10gcode_M420vEs_6
        DC32     echomagic
        DC32     _ZZ10gcode_M420vEs_8
        DC32     _ZZ10gcode_M420vEs_9
        DC32     _ZZ10gcode_M420vEs_7
        DC32     _ZZ10gcode_M420vEs__10_
        DC32     _ZN7Planner13z_fade_heightE
        DC32     _ZZ10gcode_M420vEs__11_
          CFI EndBlock cfiBlock183

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z28gcode_M421_MESH_BED_LEVELINGv
          CFI Block cfiBlock184 Using cfiCommon0
          CFI Function _Z28gcode_M421_MESH_BED_LEVELINGv
        THUMB
_Z28gcode_M421_MESH_BED_LEVELINGv:
        PUSH     {R3-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.N    R4,??gcode_M421_MESH_BED_LEVELING_0
        LDR.N    R5,??gcode_M421_MESH_BED_LEVELING_0+0x4
        LDRB     R0,[R4, #+2]
        LDR.N    R6,??gcode_M421_MESH_BED_LEVELING_0+0x8
        LSRS     R7,R0,#+7
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_1
        LDRB     R0,[R6, #+23]
        CBZ.N    R0,??gcode_M421_MESH_BED_LEVELING_2
        LDR.N    R1,??gcode_M421_MESH_BED_LEVELING_0+0xC
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M421_MESH_BED_LEVELING_2:
        STR      R0,[R5, #+0]
??gcode_M421_MESH_BED_LEVELING_1:
        LDRB     R0,[R4, #+1]
        ANDS     R8,R0,#0x1
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_3
        LDRB     R0,[R6, #+8]
        CBZ.N    R0,??gcode_M421_MESH_BED_LEVELING_4
        LDR.N    R1,??gcode_M421_MESH_BED_LEVELING_0+0xC
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M421_MESH_BED_LEVELING_4:
        STR      R0,[R5, #+0]
??gcode_M421_MESH_BED_LEVELING_3:
        CMP      R8,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_5
        LDR      R0,[R5, #+0]
        CBZ.N    R0,??gcode_M421_MESH_BED_LEVELING_6
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??gcode_M421_MESH_BED_LEVELING_6
??gcode_M421_MESH_BED_LEVELING_5:
        CBZ.N    R7,??gcode_M421_MESH_BED_LEVELING_7
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_xERKf
        BL       _ZN17mesh_bed_leveling13probe_index_xERKf
??gcode_M421_MESH_BED_LEVELING_6:
        MOV      R9,R0
        B.N      ??gcode_M421_MESH_BED_LEVELING_8
??gcode_M421_MESH_BED_LEVELING_7:
        MOV      R9,#-1
??gcode_M421_MESH_BED_LEVELING_8:
        LDRB     R0,[R4, #+3]
        ANDS     R10,R0,#0x1
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_9
        LDRB     R0,[R6, #+24]
        CBZ.N    R0,??gcode_M421_MESH_BED_LEVELING_10
        LDR.N    R1,??gcode_M421_MESH_BED_LEVELING_0+0xC
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M421_MESH_BED_LEVELING_10:
        STR      R0,[R5, #+0]
??gcode_M421_MESH_BED_LEVELING_9:
        LDRB     R0,[R4, #+1]
        LSRS     R0,R0,#+1
        ANDS     R11,R0,#0x1
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_11
        LDRB     R0,[R6, #+9]
        CBZ.N    R0,??gcode_M421_MESH_BED_LEVELING_12
        LDR.N    R1,??gcode_M421_MESH_BED_LEVELING_0+0xC
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M421_MESH_BED_LEVELING_12:
        STR      R0,[R5, #+0]
??gcode_M421_MESH_BED_LEVELING_11:
        CMP      R11,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_13
        LDR      R0,[R5, #+0]
        CBZ.N    R0,??gcode_M421_MESH_BED_LEVELING_14
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??gcode_M421_MESH_BED_LEVELING_14
??gcode_M421_MESH_BED_LEVELING_13:
        CMP      R10,#+0
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_15
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        STR      R0,[SP, #+0]
        ADD      R0,SP,#+0
          CFI FunCall _ZN17mesh_bed_leveling13probe_index_yERKf
        BL       _ZN17mesh_bed_leveling13probe_index_yERKf
        B.N      ??gcode_M421_MESH_BED_LEVELING_14
??gcode_M421_MESH_BED_LEVELING_15:
        MOV      R0,#-1
??gcode_M421_MESH_BED_LEVELING_14:
        LDRB     R1,[R4, #+3]
        LSRS     R1,R1,#+1
        ANDS     R1,R1,#0x1
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_16
        LDRB     R2,[R6, #+25]
        CBZ.N    R2,??gcode_M421_MESH_BED_LEVELING_17
        LDR.N    R3,??gcode_M421_MESH_BED_LEVELING_0+0xC
        LDR      R3,[R3, #+0]
        ADDS     R2,R2,R3
??gcode_M421_MESH_BED_LEVELING_17:
        STR      R2,[R5, #+0]
??gcode_M421_MESH_BED_LEVELING_16:
        CBNZ.N   R1,??gcode_M421_MESH_BED_LEVELING_18
        LDRB     R2,[R4, #+2]
        ANDS     R4,R2,#0x1
        BEQ.N    ??gcode_M421_MESH_BED_LEVELING_19
        LDRB     R2,[R6, #+16]
        CBZ.N    R2,??gcode_M421_MESH_BED_LEVELING_20
        LDR.N    R3,??gcode_M421_MESH_BED_LEVELING_0+0xC
        LDR      R3,[R3, #+0]
        ADDS     R2,R2,R3
??gcode_M421_MESH_BED_LEVELING_20:
        STR      R2,[R5, #+0]
        B.N      ??gcode_M421_MESH_BED_LEVELING_19
??gcode_M421_MESH_BED_LEVELING_18:
        MOVS     R4,#+0
??gcode_M421_MESH_BED_LEVELING_19:
        AND      R2,R11,R8
        AND      R3,R10,R7
        ADDS     R2,R3,R2
        CMP      R2,#+1
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_21
        ORRS     R1,R4,R1
        BNE.N    ??gcode_M421_MESH_BED_LEVELING_22
??gcode_M421_MESH_BED_LEVELING_21:
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0x14
        B.N      ??gcode_M421_MESH_BED_LEVELING_23
??gcode_M421_MESH_BED_LEVELING_22:
        SXTB     R6,R9
        CMP      R6,#+0
        ITT      PL 
        SXTBPL   R5,R0
        CMPPL    R5,#+0
        BPL.N    ??gcode_M421_MESH_BED_LEVELING_24
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_MESH_BED_LEVELING_0+0x18
??gcode_M421_MESH_BED_LEVELING_23:
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        POP      {R0,R4-R11,PC}
??gcode_M421_MESH_BED_LEVELING_24:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        ADD      R1,R6,R6, LSL #+1
        LDR.N    R2,??gcode_M421_MESH_BED_LEVELING_0+0x1C
        ADD      R6,R2,R1, LSL #+4
        CMP      R4,#+0
        ITE      NE 
        LDRNE    R1,[R6, R5, LSL #+2]
        MOVEQ    R1,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R6, R5, LSL #+2]
        POP      {R0,R4-R11,PC}   ;; return
        Nop      
        DATA
??gcode_M421_MESH_BED_LEVELING_0:
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     errormagic
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs
        DC32     _ZZ28gcode_M421_MESH_BED_LEVELINGvEs_0
        DC32     _ZN17mesh_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock184

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
          CFI Block cfiBlock185 Using cfiCommon0
          CFI Function _Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv
        THUMB
_Z37gcode_M421_AUTO_BED_LEVELING_BILINEARv:
        PUSH     {R3-R7,LR}
          CFI R14 Frame(CFA, -4)
          CFI R7 Frame(CFA, -8)
          CFI R6 Frame(CFA, -12)
          CFI R5 Frame(CFA, -16)
          CFI R4 Frame(CFA, -20)
          CFI CFA R13+24
        LDR.N    R5,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1
        LDR      R0,[R5, #+0]
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_1:
        MOV      R0,#-1
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_2:
        SXTB     R4,R0
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3
        LDR      R0,[R5, #+0]
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        MOV      R6,R0
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_4:
        MOVS     R6,#+0
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_3:
        MOV      R6,#-1
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_5:
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x4
        LDRB     R3,[R2, #+3]
        SXTB     R6,R6
        MVNS     R1,R6
        MVNS     R0,R4
        LSRS     R1,R1,#+31
        LSRS     R3,R3,#+1
        ANDS     R3,R3,#0x1
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6
        LDR.W    R12,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x8
        LDRB     R7,[R12, #+25]
        CBZ.N    R7,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7
        LDR.W    R12,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0xC
        LDR      R12,[R12, #+0]
        ADD      R7,R7,R12
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_7:
        STR      R7,[R5, #+0]
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_6:
        CBNZ.N   R3,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_8
        LDRB     R2,[R2, #+2]
        ANDS     R7,R2,#0x1
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_9
        LDR.W    R12,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x8
        LDRB     R2,[R12, #+16]
        CBZ.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_10
        LDR.W    R12,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0xC
        LDR      R12,[R12, #+0]
        ADD      R2,R2,R12
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_10:
        STR      R2,[R5, #+0]
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_9
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_8:
        MOVS     R7,#+0
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_9:
        AND      R0,R1,R0, LSR #+31
        ORR      R1,R7,R3
        TST      R0,R1
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_11
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x14
        B.N      ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_12
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_11:
        CMP      R4,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_13
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x18
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R4
        BLT.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_13
        CMP      R6,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_13
        LDRB     R0,[R0, #+97]
        SUBS     R0,R0,#+1
        CMP      R0,R6
        BGE.N    ??gcode_M421_AUTO_BED_LEVELING_BILINEAR_14
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_13:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x10
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x1C
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_12:
        POP      {R1,R4-R7,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -20)
          CFI R5 Frame(CFA, -16)
          CFI R6 Frame(CFA, -12)
          CFI R7 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+24
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_14:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        ADD      R1,R4,R4, LSL #+1
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0+0x20
        ADD      R4,R2,R1, LSL #+4
        CMP      R7,#+0
        ITE      NE 
        LDRNE    R1,[R4, R6, LSL #+2]
        MOVEQ    R1,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, R6, LSL #+2]
        POP      {R0,R4-R7,PC}    ;; return
        DATA
??gcode_M421_AUTO_BED_LEVELING_BILINEAR_0:
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     errormagic
        DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs
        DC32     mksCfg
        DC32     _ZZ37gcode_M421_AUTO_BED_LEVELING_BILINEARvEs_0
        DC32     z_values
          CFI EndBlock cfiBlock185

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
          CFI Block cfiBlock186 Using cfiCommon0
          CFI Function _Z32gcode_M421_AUTO_BED_LEVELING_UBLv
        THUMB
_Z32gcode_M421_AUTO_BED_LEVELING_UBLv:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        SUB      SP,SP,#+20
          CFI CFA R13+56
        LDR.N    R6,??gcode_M421_AUTO_BED_LEVELING_UBL_0
        MOVS     R0,#+73
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_1
        LDR      R0,[R6, #+0]
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_2
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_2
??gcode_M421_AUTO_BED_LEVELING_UBL_1:
        MOV      R0,#-1
??gcode_M421_AUTO_BED_LEVELING_UBL_2:
        SXTB     R4,R0
        MOVS     R0,#+74
          CFI FunCall _ZN11GCodeParser7seenvalEc
        BL       _ZN11GCodeParser7seenvalEc
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_3
        LDR      R0,[R6, #+0]
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_4
        MOVS     R3,#+0
        MOVS     R2,#+10
        MOVS     R1,#+0
          CFI FunCall __iar_Stolx
        BL       __iar_Stolx
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_4
??gcode_M421_AUTO_BED_LEVELING_UBL_3:
        MOV      R0,#-1
??gcode_M421_AUTO_BED_LEVELING_UBL_4:
        SXTB     R5,R0
        MVNS     R0,R5
        LSR      R9,R0,#+31
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x4
        LDRB     R1,[R0, #+0]
        LSRS     R1,R1,#+2
        MVN      R8,R4
        ANDS     R10,R1,#0x1
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_5
        LDR.N    R1,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x8
        LDRB     R1,[R1, #+2]
        CBZ.N    R1,??gcode_M421_AUTO_BED_LEVELING_UBL_6
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0xC
        LDR      R2,[R2, #+0]
        ADDS     R1,R1,R2
??gcode_M421_AUTO_BED_LEVELING_UBL_6:
        STR      R1,[R6, #+0]
??gcode_M421_AUTO_BED_LEVELING_UBL_5:
        LDRB     R1,[R0, #+3]
        LSRS     R1,R1,#+1
        ANDS     R11,R1,#0x1
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_7
        LDR.N    R1,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x8
        LDRB     R1,[R1, #+25]
        CBZ.N    R1,??gcode_M421_AUTO_BED_LEVELING_UBL_8
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0xC
        LDR      R2,[R2, #+0]
        ADDS     R1,R1,R2
??gcode_M421_AUTO_BED_LEVELING_UBL_8:
        STR      R1,[R6, #+0]
??gcode_M421_AUTO_BED_LEVELING_UBL_7:
        CMP      R11,#+0
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_9
        LDRB     R0,[R0, #+2]
        ANDS     R7,R0,#0x1
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_10
        LDR.N    R1,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x8
        LDRB     R0,[R1, #+16]
        CBZ.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_11
        LDR.N    R1,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0xC
        LDR      R1,[R1, #+0]
        ADDS     R0,R0,R1
??gcode_M421_AUTO_BED_LEVELING_UBL_11:
        STR      R0,[R6, #+0]
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_10
??gcode_M421_AUTO_BED_LEVELING_UBL_9:
        MOVS     R7,#+0
??gcode_M421_AUTO_BED_LEVELING_UBL_10:
        CMP      R10,#+0
        BEQ.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_12
        MOVS     R1,#+0
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x10
        STR      R1,[SP, #+4]
        STR      R1,[SP, #+0]
        ADD      R3,R0,#+20
        ADD      R2,R0,#+16
        MOVS     R1,#+1
        ADD      R0,SP,#+8
          CFI FunCall _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        BL       _ZN20unified_bed_leveling31find_closest_mesh_point_of_typeE13MeshPointTypeRKfS2_bPj
        LDRSB    R4,[SP, #+8]
        LDRSB    R5,[SP, #+9]
??gcode_M421_AUTO_BED_LEVELING_UBL_12:
        AND      R0,R9,R8, LSR #+31
        ADD      R0,R0,R10
        CMP      R0,#+1
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_13
        ORRS     R0,R7,R11
        BNE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_14
??gcode_M421_AUTO_BED_LEVELING_UBL_13:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x18
        B.N      ??gcode_M421_AUTO_BED_LEVELING_UBL_15
??gcode_M421_AUTO_BED_LEVELING_UBL_14:
        CMP      R4,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_16
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x1C
        LDRB     R1,[R0, #+96]
        SUBS     R1,R1,#+1
        CMP      R1,R4
        BLT.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_16
        CMP      R5,#+0
        BMI.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_16
        LDRB     R0,[R0, #+97]
        SUBS     R0,R0,#+1
        CMP      R0,R5
        BGE.N    ??gcode_M421_AUTO_BED_LEVELING_UBL_17
??gcode_M421_AUTO_BED_LEVELING_UBL_16:
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x20
??gcode_M421_AUTO_BED_LEVELING_UBL_15:
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,LR}
          CFI R4 SameValue
          CFI R5 SameValue
          CFI R6 SameValue
          CFI R7 SameValue
          CFI R8 SameValue
          CFI R9 SameValue
          CFI R10 SameValue
          CFI R11 SameValue
          CFI R14 SameValue
          CFI CFA R13+0
          CFI FunCall _Z14serialprintPGMPKc
        B.W      _Z14serialprintPGMPKc
          CFI R4 Frame(CFA, -36)
          CFI R5 Frame(CFA, -32)
          CFI R6 Frame(CFA, -28)
          CFI R7 Frame(CFA, -24)
          CFI R8 Frame(CFA, -20)
          CFI R9 Frame(CFA, -16)
          CFI R10 Frame(CFA, -12)
          CFI R11 Frame(CFA, -8)
          CFI R14 Frame(CFA, -4)
          CFI CFA R13+56
??gcode_M421_AUTO_BED_LEVELING_UBL_17:
          CFI FunCall _ZN11GCodeParser11value_floatEv
        BL       _ZN11GCodeParser11value_floatEv
        ADD      R1,R4,R4, LSL #+1
        LDR.N    R2,??gcode_M421_AUTO_BED_LEVELING_UBL_0+0x24
        ADD      R4,R2,R1, LSL #+4
        CMP      R7,#+0
        ITE      NE 
        LDRNE    R1,[R4, R5, LSL #+2]
        MOVEQ    R1,#+0
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R4, R5, LSL #+2]
        ADD      SP,SP,#+20
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??gcode_M421_AUTO_BED_LEVELING_UBL_0:
        DC32     _ZN11GCodeParser9value_ptrE
        DC32     _ZN11GCodeParser8codebitsE
        DC32     _ZN11GCodeParser5paramE
        DC32     _ZN11GCodeParser11command_ptrE
        DC32     axis_relative_modes
        DC32     errormagic
        DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs
        DC32     mksCfg
        DC32     _ZZ32gcode_M421_AUTO_BED_LEVELING_UBLvEs_0
        DC32     _ZN20unified_bed_leveling8z_valuesE
          CFI EndBlock cfiBlock186

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z10gcode_M428v
          CFI Block cfiBlock187 Using cfiCommon0
          CFI Function _Z10gcode_M428v
        THUMB
_Z10gcode_M428v:
        PUSH     {R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+36
        LDR.W    R8,??gcode_M428_0
        LDRSH    R0,[R8, #+88]
        SUB      SP,SP,#+12
          CFI CFA R13+48
        CMP      R0,#+2
        BEQ.N    ??gcode_M428_1
        MOVS     R1,#+1
        MOVS     R2,#+1
        MOV      R0,R1
          CFI FunCall _Z18axis_unhomed_errorbbb
        BL       _Z18axis_unhomed_errorbbb
        CMP      R0,#+0
        BNE.N    ??gcode_M428_1
        LDR.N    R4,??gcode_M428_0+0x4
        LDR.N    R7,??gcode_M428_0+0x8
        MOVS     R6,#+0
        ADD      R9,SP,#+0
        ADD      R5,R4,#+44
        ADD      R10,R7,#+16
??gcode_M428_2:
        LDR      R11,[R10, #+0]
        LDR      R0,[R5, #+0]
        MOV      R1,R11
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.N    R1,??gcode_M428_0+0xC  ;; 0xc1a00000
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_3
        LDR.N    R1,??gcode_M428_0+0x10  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M428_4
??gcode_M428_3:
        LDRSB    R1,[R4, #+0]
        CMP      R1,#+1
        IT       GE 
        EORGE    R0,R11,#0x80000000
??gcode_M428_4:
        LDR.N    R1,??gcode_M428_0+0xC  ;; 0xc1a00000
        STR      R0,[R9, #+0]
          CFI FunCall __aeabi_cfrcmple
        BL       __aeabi_cfrcmple
        BHI.N    ??gcode_M428_5
        LDR      R0,[R9], #+4
        LDR.N    R1,??gcode_M428_0+0x10  ;; 0x41a00001
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCC.N    ??gcode_M428_6
??gcode_M428_5:
        LDR.N    R0,??gcode_M428_0+0x14
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        LDR.N    R0,??gcode_M428_0+0x18
          CFI FunCall _Z14serialprintPGMPKc
        BL       _Z14serialprintPGMPKc
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+48
??gcode_M428_6:
        ADDS     R6,R6,#+1
        UXTB     R6,R6
        ADDS     R5,R5,#+4
        ADDS     R4,R4,#+1
        ADD      R10,R10,#+4
        CMP      R6,#+3
        BLT.N    ??gcode_M428_2
        LDRSH    R0,[R8, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M428_7
        LDR      R0,[SP, #+0]
        STR      R0,[R7, #+48]
        MOVS     R0,#+0
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
        LDRSH    R0,[R8, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M428_7
        LDR      R0,[SP, #+4]
        STR      R0,[R7, #+52]
        MOVS     R0,#+1
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
        LDRSH    R0,[R8, #+88]
        CMP      R0,#+2
        BEQ.N    ??gcode_M428_7
        LDR      R0,[SP, #+8]
        STR      R0,[R7, #+56]
        MOVS     R0,#+2
          CFI FunCall _Z24update_software_endstops8AxisEnum
        BL       _Z24update_software_endstops8AxisEnum
??gcode_M428_7:
          CFI FunCall _Z23report_current_positionv
        BL       _Z23report_current_positionv
??gcode_M428_1:
        ADD      SP,SP,#+12
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        DATA
??gcode_M428_0:
        DC32     mksCfg
        DC32     home_dir_P
        DC32     axis_relative_modes
        DC32     0xc1a00000
        DC32     0x41a00001
        DC32     errormagic
        DC32     _ZZ10gcode_M428vEs
          CFI EndBlock cfiBlock187

        SECTION `.text`:CODE:REORDER:NOROOT(2)
        SECTION_GROUP _Z25prepare_kinematic_move_toRA4_Kf
          CFI Block cfiBlock188 Using cfiCommon0
          CFI Function _Z25prepare_kinematic_move_toRA4_Kf
        THUMB
_Z25prepare_kinematic_move_toRA4_Kf:
        PUSH     {R0,R4-R11,LR}
          CFI R14 Frame(CFA, -4)
          CFI R11 Frame(CFA, -8)
          CFI R10 Frame(CFA, -12)
          CFI R9 Frame(CFA, -16)
          CFI R8 Frame(CFA, -20)
          CFI R7 Frame(CFA, -24)
          CFI R6 Frame(CFA, -28)
          CFI R5 Frame(CFA, -32)
          CFI R4 Frame(CFA, -36)
          CFI CFA R13+40
        LDR.W    R0,??prepare_kinematic_move_to_0
        LDRSH    R0,[R0, #+14]
        SUB      SP,SP,#+48
          CFI CFA R13+88
          CFI FunCall __aeabi_i2f
        BL       __aeabi_i2f
        LDR.W    R1,??prepare_kinematic_move_to_0
        LDR      R1,[R1, #+112]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2d
        BL       __aeabi_f2d
        LDR.W    R2,??prepare_kinematic_move_to_0+0x4  ;; 0x47ae147b
        LDR.W    R3,??prepare_kinematic_move_to_0+0x8  ;; 0x3f847ae1
          CFI FunCall __aeabi_dmul
        BL       __aeabi_dmul
          CFI FunCall __aeabi_d2f
        BL       __aeabi_d2f
        LDR.W    R1,??prepare_kinematic_move_to_0
        LDR      R1,[R1, #+16]
        STR      R0,[SP, #+8]
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+0]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R1,??prepare_kinematic_move_to_0
        LDR      R1,[R1, #+20]
        MOV      R9,R0
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R7,R0
        MOV      R0,R9
        MOVS     R1,#+0
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BNE.N    ??prepare_kinematic_move_to_1
        MOV      R0,R7
          CFI FunCall __aeabi_cfcmpeq
        BL       __aeabi_cfcmpeq
        BEQ.W    ??prepare_kinematic_move_to_2
??prepare_kinematic_move_to_1:
        LDR.W    R0,??prepare_kinematic_move_to_0+0xC
        LDRH     R0,[R0, #+88]
        MOVW     R1,#+770
        TST      R0,R1
        LDR      R0,[SP, #+48]
        BEQ.N    ??prepare_kinematic_move_to_3
        ADDS     R1,R0,#+4
          CFI FunCall _Z34position_is_reachable_IS_KINEMATICRKfS0_
        BL       _Z34position_is_reachable_IS_KINEMATICRKfS0_
        CBNZ.N   R0,??prepare_kinematic_move_to_4
        B.N      ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_3:
        ADDS     R1,R0,#+4
          CFI FunCall _Z34position_is_reachable_IS_CARTESIANRKfS0_
        BL       _Z34position_is_reachable_IS_CARTESIANRKfS0_
        CMP      R0,#+0
        BEQ.N    ??prepare_kinematic_move_to_5
??prepare_kinematic_move_to_4:
        LDR      R0,[SP, #+48]
        LDR.W    R1,??prepare_kinematic_move_to_0
        LDR      R0,[R0, #+8]
        LDR      R1,[R1, #+24]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        LDR.W    R1,??prepare_kinematic_move_to_0
        LDR      R1,[R1, #+28]
        STR      R0,[SP, #+4]
        LDR      R0,[SP, #+48]
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        STR      R0,[SP, #+0]
        MOV      R4,#+1065353216
        MOV      R6,R9
        MOV      R8,#+2
        MOV      R5,R4
        B.N      ??prepare_kinematic_move_to_6
??prepare_kinematic_move_to_7:
        MOV      R0,R6
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_6:
        LSLS     R0,R8,#+31
        BPL.N    ??prepare_kinematic_move_to_8
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R5,R0
??prepare_kinematic_move_to_8:
        LSRS     R8,R8,#+1
        BNE.N    ??prepare_kinematic_move_to_7
        MOV      R8,R7
        MOV      R10,#+2
        MOV      R6,R4
        B.N      ??prepare_kinematic_move_to_9
??prepare_kinematic_move_to_10:
        MOV      R0,R8
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_9:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_11
        MOV      R0,R6
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R6,R0
??prepare_kinematic_move_to_11:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_10
        LDR      R11,[SP, #+4]
        MOV      R8,#+2
        MOV      R10,R4
        B.N      ??prepare_kinematic_move_to_12
??prepare_kinematic_move_to_13:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_12:
        LSLS     R0,R8,#+31
        BPL.N    ??prepare_kinematic_move_to_14
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_14:
        LSRS     R8,R8,#+1
        BNE.N    ??prepare_kinematic_move_to_13
        MOV      R0,R5
        MOV      R1,R6
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
          CFI FunCall sqrtf
        BL       sqrtf
        LDR.N    R1,??prepare_kinematic_move_to_0+0x10  ;; 0x358637be
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        MOV      R8,R0
        ITT      CC 
        LDRCC    R0,[SP, #+0]
        BICCC    R8,R0,#0x80000000
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_15
??prepare_kinematic_move_to_5:
        MOVS     R0,#+1
        ADD      SP,SP,#+52
          CFI CFA R13+36
        POP      {R4-R11,PC}
          CFI CFA R13+88
??prepare_kinematic_move_to_15:
        LDR      R1,[SP, #+8]
        LDR.N    R5,??prepare_kinematic_move_to_0+0x14
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        LDR      R1,[R5, #+128]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
        LDR.N    R0,??prepare_kinematic_move_to_0+0xC
        LDRH     R0,[R0, #+88]
        MOV      R1,#+768
        TST      R0,R1
        BEQ.N    ??prepare_kinematic_move_to_16
        MOV      R0,#+1082130432
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
        UXTH     R6,R6
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R8
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.N    ??prepare_kinematic_move_to_16
          CFI FunCall __aeabi_f2iz
        BL       __aeabi_f2iz
        MOV      R6,R0
??prepare_kinematic_move_to_16:
        UXTH     R6,R6
        CBNZ.N   R6,??prepare_kinematic_move_to_17
        MOVS     R6,#+1
??prepare_kinematic_move_to_17:
        MOV      R0,R6
          CFI FunCall __aeabi_ui2f
        BL       __aeabi_ui2f
        MOV      R1,R0
        MOV      R0,R4
          CFI FunCall __aeabi_fdiv
        BL       __aeabi_fdiv
        MOV      R8,R0
        MOV      R0,R9
        MOV      R1,R8
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+40]
        MOV      R1,R8
        MOV      R0,R7
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+36]
        MOV      R1,R8
        LDR      R0,[SP, #+4]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+32]
        MOV      R1,R8
        LDR      R0,[SP, #+0]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        STR      R0,[SP, #+28]
        ADD      R1,SP,#+12
        LDR.N    R0,??prepare_kinematic_move_to_0+0x18
        LDM      R0!,{R2,R3,R7,R12}
        STM      R1!,{R2,R3,R7,R12}
        ADD      R7,SP,#+12
        B.N      ??prepare_kinematic_move_to_18
??prepare_kinematic_move_to_19:
        LDR.N    R0,??prepare_kinematic_move_to_0
        LDRB     R0,[R0, #+10]
        LDR      R2,[R5, #+68]
        LDR      R1,[R5, #+64]
        STR      R0,[SP, #+4]
        ADD      R3,SP,#+24
        ADD      R0,SP,#+8
        STR      R0,[SP, #+0]
        LDR      R0,[R5, #+60]
          CFI FunCall _ZN7Planner11buffer_lineEfffRKfS1_h
        BL       _ZN7Planner11buffer_lineEfffRKfS1_h
??prepare_kinematic_move_to_18:
        SUBS     R6,R6,#+1
        UXTH     R6,R6
        CMP      R6,#+0
        BEQ.W    ??prepare_kinematic_move_to_2
        LDR.N    R0,??prepare_kinematic_move_to_0+0x1C
        LDRB     R0,[R0, #+0]
        CBNZ.N   R0,??prepare_kinematic_move_to_20
        LDR.N    R1,??prepare_kinematic_move_to_0+0x1C
        MOVS     R0,#+1
        STRB     R0,[R1, #+0]
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        ADDS     R0,R0,#+200
        LDR.N    R1,??prepare_kinematic_move_to_0+0x20
        STR      R0,[R1, #+0]
??prepare_kinematic_move_to_20:
          CFI FunCall _ZN11Temperature13manage_heaterEv
        BL       _ZN11Temperature13manage_heaterEv
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??prepare_kinematic_move_to_0+0x20
        LDR      R1,[R1, #+0]
        SUBS     R0,R0,R1
        BMI.N    ??prepare_kinematic_move_to_21
          CFI FunCall HAL_GetTick
        BL       HAL_GetTick
        LDR.N    R1,??prepare_kinematic_move_to_0+0x20
        ADDS     R0,R0,#+200
        STR      R0,[R1, #+0]
          CFI FunCall _Z4idlev
        BL       _Z4idlev
??prepare_kinematic_move_to_21:
        LDR      R0,[SP, #+12]
        LDR      R1,[SP, #+40]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+36]
        STR      R0,[SP, #+12]
        LDR      R0,[R7, #+4]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+32]
        MOV      R9,R0
        LDR      R0,[R7, #+8]
        STR      R9,[R7, #+4]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+8]
        LDR      R1,[SP, #+28]
        LDR      R0,[R7, #+12]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R7, #+12]
        LDR.N    R0,??prepare_kinematic_move_to_0+0xC
        LDRB     R0,[R0, #+88]
        LSLS     R0,R0,#+30
        BPL.W    ??prepare_kinematic_move_to_22
        LDR      R0,[R5, #+12]
        LDR      R1,[SP, #+12]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??prepare_kinematic_move_to_23
??prepare_kinematic_move_to_24:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_23:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_25
        MOV      R0,R8
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_25:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_24
        LDR      R0,[R5, #+16]
        MOV      R1,R9
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??prepare_kinematic_move_to_26
??prepare_kinematic_move_to_27:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_26:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_28
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_28:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_27
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+84]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+12]
        STR      R0,[R5, #+60]
        LDR      R0,[R5, #+20]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??prepare_kinematic_move_to_29
??prepare_kinematic_move_to_30:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_29:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_31
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_31:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_30
        LDR      R0,[R5, #+24]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??prepare_kinematic_move_to_32
??prepare_kinematic_move_to_33:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_32:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_34
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_34:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_33
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+88]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        LDR      R1,[SP, #+12]
        STR      R0,[R5, #+64]
        LDR      R0,[R5, #+28]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R9,R0
        MOV      R10,#+2
        MOV      R8,R4
        B.N      ??prepare_kinematic_move_to_35
??prepare_kinematic_move_to_36:
        MOV      R0,R9
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R9,R0
??prepare_kinematic_move_to_35:
        LSLS     R0,R10,#+31
        BPL.N    ??prepare_kinematic_move_to_37
        MOV      R0,R8
        MOV      R1,R9
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R8,R0
??prepare_kinematic_move_to_37:
        LSRS     R10,R10,#+1
        BNE.N    ??prepare_kinematic_move_to_36
        LDR      R0,[R5, #+32]
        LDR      R1,[R7, #+4]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
        MOV      R11,R0
        MOV      R9,#+2
        MOV      R10,R4
        B.N      ??prepare_kinematic_move_to_38
??prepare_kinematic_move_to_39:
        MOV      R0,R11
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R11,R0
??prepare_kinematic_move_to_38:
        LSLS     R0,R9,#+31
        BPL.N    ??prepare_kinematic_move_to_40
        MOV      R0,R10
        MOV      R1,R11
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
        MOV      R10,R0
??prepare_kinematic_move_to_40:
        LSRS     R9,R9,#+1
        BNE.N    ??prepare_kinematic_move_to_39
        MOV      R0,R8
        MOV      R1,R10
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        MOV      R1,R0
        LDR      R0,[R5, #+92]
          CFI FunCall __aeabi_fsub
        BL       __aeabi_fsub
          CFI FunCall sqrtf
        BL       sqrtf
        MOV      R1,R0
        LDR      R0,[R7, #+8]
          CFI FunCall __aeabi_fadd
        BL       __aeabi_fadd
        STR      R0,[R5, #+68]
        B.N      ??prepare_kinematic_move_to_41
??prepare_kinematic_move_to_22:
        ADD      R0,SP,#+12
          CFI FunCall _Z18inverse_kinematicsPKf
        BL       _Z18inverse_kinematicsPKf
??prepare_kinematic_move_to_41:
        ADD      R0,SP,#+12
          CFI FunCall _Z12ADJUST_DELTAPKf
        BL       _Z12ADJUST_DELTAPKf
        LDR.N    R0,??prepare_kinematic_move_to_0+0x24
        LDRB     R0,[R0, #+344]
        CMP      R0,#+1
        BNE.W    ??prepare_kinematic_move_to_19
        LDR      R0,[SP, #+48]
        LDR.N    R1,??prepare_kinematic_move_to_0+0x24
        LDR      R0,[R0, #+8]
        LDR      R1,[R1, #+680]
          CFI FunCall __aeabi_cfcmple
        BL       __aeabi_cfcmple
        BCS.W    ??prepare_kinematic_move_to_19
        LDR.N    R4,??prepare_kinematic_move_to_0+0x28
        MOVS     R0,#+1
        STRB     R0,[R4, #+12]
        LDR.N    R0,??prepare_kinematic_move_to_0+0x2C
        LDR      R1,[R7, #+12]
        LDR      R0,[R0, #+12]
          CFI FunCall __aeabi_fmul
        BL       __aeabi_fmul
          CFI FunCall lroundf
        BL       lroundf
        STR      R0,[R4, #+8]
        B.N      ??prepare_kinematic_move_to_42
??prepare_kinematic_move_to_2:
        LDR.N    R0,??prepare_kinematic_move_to_0
        LDRB     R2,[R0, #+10]
        LDR      R0,[SP, #+48]
        ADD      R1,SP,#+8
          CFI FunCall _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
        BL       _ZN7Planner21buffer_line_kinematicERA4_KfRS0_h
??prepare_kinematic_move_to_42:
        MOVS     R0,#+0
        ADD      SP,SP,#+52
          CFI CFA R13+36
        POP      {R4-R11,PC}      ;; return
        Nop      
        DATA
??prepare_kinematic_move_to_0:
        DC32     axis_relative_modes
        DC32     0x47ae147b
        DC32     0x3f847ae1
        DC32     mksCfg
        DC32     0x358637be
        DC32     axis_homed
        DC32     axis_relative_modes+0x10
        DC32     _ZGVZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        DC32     _ZZ25prepare_kinematic_move_toRA4_KfE12next_idle_ms
        DC32     gCfgItems
        DC32     gCfgItems+0x158
        DC32     _ZN7Planner17axis_steps_per_mmE
          CFI EndBlock cfiBlock188

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 16421 
// 
//  4 107 bytes in section .bss
//    485 bytes in section .data
//      4 bytes in section .init_array
//  4 787 bytes in section .rodata
// 51 464 bytes in section .text
// 
// 34 062 bytes of CODE  memory (+ 17 406 bytes shared)
//  1 540 bytes of CONST memory (+  3 247 bytes shared)
//  4 382 bytes of DATA  memory (+    210 bytes shared)
//
//Errors: none
//Warnings: 165
